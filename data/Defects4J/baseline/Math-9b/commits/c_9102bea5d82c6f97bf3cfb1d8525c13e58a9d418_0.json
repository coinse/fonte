{"sha": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418", "log": "MATH-394, MATH-397, MATH-404 Overhaul of the \"optimization\" package. Removed lots of duplicate code. Removed methods referring to the concept of \"iteration\". Removed interface methods to access the number of evaluations of the gradient and Jacobian. Removed all references to \"OptimizationException\" (replaced by \"ConvergenceException\"). Javadoc comments updated.    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n  * @see ConvergenceException\n  * @version $Revision$ $Date$\n  * @since 2.0\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link IterativeAlgorithm} instead.\n  */\n public interface ConvergingAlgorithm {\n \n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n+ * @deprecated in 2.2 (to be removed in 3.0).\n  */\n public abstract class ConvergingAlgorithmImpl implements ConvergingAlgorithm {\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Base class for all convergence checker implementations.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class AbstractConvergenceChecker<T>\n+    implements ConvergenceChecker<T> {\n+    /**\n+     * Default relative threshold.\n+     */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+    /**\n+     * Default absolute threshold.\n+     */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+    /**\n+     * Relative tolerance threshold.\n+     */\n+    private final double relativeThreshold;\n+    /**\n+     * Absolute tolerance threshold.\n+     */\n+    private final double absoluteThreshold;\n+\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public AbstractConvergenceChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /**\n+     * Build an instance with a specified thresholds.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public AbstractConvergenceChecker(final double relativeThreshold,\n+                                      final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getRelativeThreshold() {\n+        return relativeThreshold;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getAbsoluteThreshold() {\n+        return absoluteThreshold;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract boolean converged(int iteration, T ... points);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Base class for all implementations of a multi-start optimizer.\n+ *\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * {@link MultiStartMultivariateRealOptimizer} or on\n+ * {@link MultiStartDifferentiableMultivariateRealOptimizer}.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class BaseMultiStartMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+    implements BaseMultivariateRealOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseMultivariateRealOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n+     */\n+    protected BaseMultiStartMultivariateRealOptimizer(final BaseMultivariateRealOptimizer<FUNC> optimizer,\n+                                                      final int starts,\n+                                                      final RandomVectorGenerator generator) {\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(FUNC,GoalType,double[]) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(FUNC,GoalType,double[])\n+     * optimize} method returns the best point only. This method\n+     * returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(FUNC,GoalType,double[]) optimize} method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(FUNC,GoalType,double[])\n+     * optimize} method did throw a {@link ConvergenceException}).\n+     * This also means that if the first element is not {@code null}, it\n+     * is the best point found across all starts.\n+     *\n+     * @return an array containing the optima.\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(FUNC,GoalType,double[]) optimize} has not been called.\n+     */\n+    public RealPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+        optimizer.setMaxEvaluations(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /**\n+     * @param f Function to optimize.\n+     * @param goal Goal type ({@link GoalType#MINIMIZE} or\n+     * {@link GoalType#MAXIMIZE}).\n+     * @param startPoint Start point.\n+     */\n+    public RealPointValuePair optimize(final FUNC f,\n+                                       final GoalType goal,\n+                                       double[] startPoint)\n+        throws FunctionEvaluationException {\n+        optima = new RealPointValuePair[starts];\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optima[i] = optimizer.optimize(f, goal,\n+                                               (i == 0 ? startPoint :\n+                                                generator.nextVector()));\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (ConvergenceException oe) {\n+                optima[i] = null;\n+            }\n+\n+            final int usedEvaluations = optimizer.getEvaluations();\n+            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n+            totalEvaluations += usedEvaluations;\n+        }\n+\n+        sortPairs(goal);\n+\n+        if (optima[0] == null) {\n+            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n+                                           starts);\n+        }\n+\n+        // Return the found point given the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param goal Goal type.\n+     */\n+    private void sortPairs(final GoalType goal) {\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+                public int compare(final RealPointValuePair o1,\n+                                   final RealPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goal == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            });\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Base class for all implementations of a multi-start optimizer.\n+ *\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * {@link MultiStartDifferentiableMultivariateVectorialOptimizer}.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class BaseMultiStartMultivariateVectorialOptimizer<FUNC extends MultivariateVectorialFunction>\n+    implements BaseMultivariateVectorialOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseMultivariateVectorialOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+    /** Found optima. */\n+    private VectorialPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n+     */\n+    protected BaseMultiStartMultivariateVectorialOptimizer(final BaseMultivariateVectorialOptimizer<FUNC> optimizer,\n+                                                           final int starts,\n+                                                           final RandomVectorGenerator generator) {\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(FUNC,double[],double[],double[]) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(FUNC,double[],double[],double[])\n+     * optimize} method returns the best point only. This method\n+     * returns all the points found at the end of each starts, including\n+     * the best one already returned by the {@link\n+     * #optimize(FUNC,double[],double[],double[]) optimize} method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e. in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link\n+     * #optimize(FUNC,double[],double[],double[]) optimize} method did\n+     * throw a {@link ConvergenceException}). This also means that if\n+     * the first element is not {@code null}, it is the best point found\n+     * across all starts.\n+     *\n+     * @return array containing the optima\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(FUNC,double[],double[],double[]) optimize} has not been\n+     * called.\n+     */\n+    public VectorialPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+        optimizer.setMaxEvaluations(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public VectorialPointValuePair optimize(final FUNC f,\n+                                            double[] target, double[] weights,\n+                                            double[] startPoint)\n+        throws FunctionEvaluationException {\n+\n+        optima = new VectorialPointValuePair[starts];\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optima[i] = optimizer.optimize(f, target, weights,\n+                                               (i == 0 ? startPoint :\n+                                                generator.nextVector()));\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (ConvergenceException oe) {\n+                optima[i] = null;\n+            }\n+\n+            final int usedEvaluations = optimizer.getEvaluations();\n+            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n+            totalEvaluations += usedEvaluations;\n+        }\n+\n+        sortPairs(target, weights);\n+\n+        if (optima[0] == null) {\n+            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n+                                           starts);\n+        }\n+\n+        // Return the found point given the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param target Target value for the objective functions at optimum.\n+     * @param weights Weights for the least-squares cost computation.\n+     */\n+    private void sortPairs(final double[] target,\n+                           final double[] weights) {\n+        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n+                public int compare(final VectorialPointValuePair o1,\n+                                   final VectorialPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    return Double.compare(weightedResidual(o1), weightedResidual(o2));\n+                }\n+                private double weightedResidual(final VectorialPointValuePair pv) {\n+                    final double[] value = pv.getValueRef();\n+                    double sum = 0;\n+                    for (int i = 0; i < value.length; ++i) {\n+                        final double ri = value[i] - target[i];\n+                        sum += weights[i] * ri * ri;\n+                    }\n+                    return sum;\n+                }\n+            });\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n /**\n- * Optimization algorithms find the input point set that either {@link GoalType\n- * maximize or minimize} an objective function.\n  * This interface is mainly intended to enforce the internal coherence of\n  * Commons-FastMath. Users of the API are advised to base their code on\n- * {@link MultivariateRealOptimizer} or on\n- * {@link DifferentiableMultivariateRealOptimizer}.\n- * @param <T> the type of the objective function to be optimized\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer}</li>\n+ * </ul>\n  *\n- * @see MultivariateRealOptimizer\n- * @see DifferentiableMultivariateRealOptimizer\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.2\n+ * @since 3.0\n  */\n-public interface BaseMultivariateRealOptimizer<T extends MultivariateRealFunction> {\n-    /**\n-     * Set the maximal number of iterations of the algorithm.\n-     *\n-     * @param maxIterations Maximal number of algorithm iterations.\n-     */\n-    void setMaxIterations(int maxIterations);\n-\n-    /**\n-     * Get the maximal number of iterations of the algorithm.\n-     *\n-     * @return the maximal number of iterations.\n-     */\n-    int getMaxIterations();\n-\n-    /**\n-     * Set the maximal number of functions evaluations.\n-     *\n-     * @param maxEvaluations Maximal number of function evaluations.\n-     */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /**\n-     * Get the maximal number of functions evaluations.\n-     *\n-     * @return the maximal number of functions evaluations.\n-     */\n-    int getMaxEvaluations();\n-\n-    /**\n-     * Get the number of iterations realized by the algorithm.\n-     * The number of iterations corresponds to the last call to the\n-     * {@code optimize} method. It is 0 if the method has not been\n-     * called yet.\n-     *\n-     * @return the number of iterations.\n-     */\n-    int getIterations();\n-\n-    /**\n-     * Get the number of evaluations of the objective function.\n-     * The number of evaluations corresponds to the last call to the\n-     * {@code optimize} method. It is 0 if the method has not been\n-     * called yet.\n-     *\n-     * @return the number of evaluations of the objective function.\n-     */\n-    int getEvaluations();\n-\n-    /**\n-     * Set the convergence checker.\n-     *\n-     * @param checker Object to use to check for convergence.\n-     */\n-    void setConvergenceChecker(RealConvergenceChecker checker);\n-\n-    /**\n-     * Get the convergence checker.\n-     *\n-     * @return the object used to check for convergence.\n-     */\n-    RealConvergenceChecker getConvergenceChecker();\n-\n+public interface BaseMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+    extends BaseOptimizer<RealPointValuePair> {\n     /**\n      * Optimize an objective function.\n      *\n      * @param f Objective function.\n-     * @param goalType Type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n      * @param startPoint Start point for optimization.\n-     * @return the point/value pair giving the optimal value for objective function.\n-     * @throws FunctionEvaluationException if the objective function throws one during\n-     * the search.\n-     * @throws OptimizationException if the algorithm failed to converge.\n-     * @throws IllegalArgumentException if the start point dimension is wrong.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @throws FunctionEvaluationException if the objective function throws one\n+     * during the search.\n+     * @throws DimensionMismatchException if the start point dimension is wrong.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n      */\n-    RealPointValuePair optimize(T f, GoalType goalType, double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException;\n+    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint)\n+        throws FunctionEvaluationException;\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface BaseMultivariateVectorialOptimizer<FUNC extends MultivariateVectorialFunction>\n+    extends BaseOptimizer<VectorialPointValuePair> {\n+    /**\n+     * Optimize an objective function.\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n+     *\n+     * @param f Objective function.\n+     * @param target Target value for the objective functions at optimum.\n+     * @param weight Weights for the least squares cost computation.\n+     * @param startPoint Start point for optimization.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @throws FunctionEvaluationException if the objective function throws one\n+     * during the search.\n+     * @throws DimensionMismatchException if the start point dimension is wrong.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n+     */\n+    VectorialPointValuePair optimize(FUNC f, double[] target, double[] weight,\n+                                     double[] startPoint)\n+        throws FunctionEvaluationException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <PAIR> Type of the point/objective pair.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface BaseOptimizer<PAIR> {\n+    /**\n+     * Set the maximal number of function evaluations.\n+     *\n+     * @param maxEvaluations Maximal number of function evaluations.\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /**\n+     * Get the maximal number of function evaluations.\n+     *\n+     * @return the maximal number of function evaluations.\n+     */\n+    int getMaxEvaluations();\n+\n+    /**\n+     * Get the number of evaluations of the objective function.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * Set the convergence checker.\n+     *\n+     * @param checker Object to use to check for convergence.\n+     */\n+    void setConvergenceChecker(ConvergenceChecker<PAIR> checker);\n+\n+    /**\n+     * Get the convergence checker.\n+     *\n+     * @return the object used to check for convergence.\n+     */\n+    ConvergenceChecker<PAIR> getConvergenceChecker();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+/**\n+ * This interface specifies how to check if an optimization algorithm has\n+ * converged.\n+ * Deciding if convergence has been reached is a problem-dependent issue. The\n+ * user should provide a class implementing this interface to allow the\n+ * optimization algorithm to stop its search according to the problem at hand.\n+ *\n+ * @param <PAIR> Type of the (point, objective value) pair.\n+ *\n+ * @see org.apache.commons.math.optimization.SimpleScalarValueChecker\n+ * @see org.apache.commons.math.optimization.SimpleRealPointChecker\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface ConvergenceChecker<PAIR> {\n+    /**\n+     * Check if the optimization algorithm has converged.\n+     *\n+     * @param iteration Current iteration.\n+     * @param points Data used for checking the convergence.\n+     * @return {@code true} if the algorithm is considered to have converged.\n+     */\n+    boolean converged(int iteration, PAIR ... points);\n+\n+    /**\n+     * Get the relative tolerance.\n+     *\n+     * @return the relative threshold.\n+     */\n+    double getRelativeThreshold();\n+\n+    /**\n+     * Get the absolute tolerance.\n+     *\n+     * @return the absolute threshold.\n+     */\n+    double getAbsoluteThreshold();\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n  *\n  * @see MultivariateRealOptimizer\n  * @see DifferentiableMultivariateVectorialOptimizer\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface DifferentiableMultivariateRealOptimizer\n-    extends BaseMultivariateRealOptimizer<DifferentiableMultivariateRealFunction> {\n-    /**\n-     * Get the number of evaluations of the objective function gradient.\n-     * The number of evaluations corresponds to the last call to the\n-     * {@code optimize} method (see {@link BaseMultivariateRealOptimizer}).\n-     * It is 0 if the method has not been called yet.\n-     *\n-     * @return the number of evaluations of the objective function gradient.\n-     */\n-    int getGradientEvaluations();\n-}\n+    extends BaseMultivariateRealOptimizer<DifferentiableMultivariateRealFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n \n /**\n- * This interface represents an optimization algorithm for {@link DifferentiableMultivariateVectorialFunction\n- * vectorial differentiable objective functions}.\n- * <p>Optimization algorithms find the input point set that either {@link GoalType\n- * maximize or minimize} an objective function.</p>\n- * @see MultivariateRealOptimizer\n- * @see DifferentiableMultivariateRealOptimizer\n+ * This interface represents an optimization algorithm for\n+ * {@link DifferentiableMultivariateVectorialFunction vectorial differentiable\n+ * objective functions}.\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.0\n+ * @since 3.0\n  */\n-public interface DifferentiableMultivariateVectorialOptimizer {\n-\n-    /** Set the maximal number of iterations of the algorithm.\n-     * @param maxIterations maximal number of function calls\n-     * .\n-     */\n-    void setMaxIterations(int maxIterations);\n-\n-    /** Get the maximal number of iterations of the algorithm.\n-      * @return maximal number of iterations\n-     */\n-    int getMaxIterations();\n-\n-    /** Get the number of iterations realized by the algorithm.\n-     * @return number of iterations\n-    */\n-   int getIterations();\n-\n-   /** Set the maximal number of functions evaluations.\n-    * @param maxEvaluations maximal number of function evaluations\n-    */\n-   void setMaxEvaluations(int maxEvaluations);\n-\n-   /** Get the maximal number of functions evaluations.\n-    * @return maximal number of functions evaluations\n-    */\n-   int getMaxEvaluations();\n-\n-    /** Get the number of evaluations of the objective function.\n-     * <p>\n-     * The number of evaluation correspond to the last call to the\n-     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize} method. It is 0 if\n-     * the method has not been called yet.\n-     * </p>\n-     * @return number of evaluations of the objective function\n-     */\n-    int getEvaluations();\n-\n-    /** Get the number of evaluations of the objective function jacobian .\n-     * <p>\n-     * The number of evaluation correspond to the last call to the\n-     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize} method. It is 0 if\n-     * the method has not been called yet.\n-     * </p>\n-     * @return number of evaluations of the objective function jacobian\n-     */\n-    int getJacobianEvaluations();\n-\n-    /** Set the convergence checker.\n-     * @param checker object to use to check for convergence\n-     */\n-    void setConvergenceChecker(VectorialConvergenceChecker checker);\n-\n-    /** Get the convergence checker.\n-     * @return object used to check for convergence\n-     */\n-    VectorialConvergenceChecker getConvergenceChecker();\n-\n-    /** Optimizes an objective function.\n-     * <p>\n-     * Optimization is considered to be a weighted least-squares minimization.\n-     * The cost function to be minimized is\n-     * &sum;weight<sub>i</sub>(objective<sub>i</sub>-target<sub>i</sub>)<sup>2</sup>\n-     * </p>\n-     * @param f objective function\n-     * @param target target value for the objective functions at optimum\n-     * @param weights weight for the least squares cost computation\n-     * @param startPoint the start point for optimization\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    VectorialPointValuePair optimize(DifferentiableMultivariateVectorialFunction f,\n-                                     double[] target, double[] weights,\n-                                     double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n-}\n+public interface DifferentiableMultivariateVectorialOptimizer\n+    extends BaseMultivariateVectorialOptimizer<DifferentiableMultivariateVectorialFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n- * Special implementation of the {@link DifferentiableMultivariateRealOptimizer} interface adding\n- * multi-start features to an existing optimizer.\n- * <p>\n+ * Special implementation of the {@link DifferentiableMultivariateRealOptimizer}\n+ * interface adding multi-start features to an existing optimizer.\n+ *\n  * This class wraps a classical optimizer to use it several times in\n  * turn with different starting points in order to avoid being trapped\n  * into a local extremum when looking for a global one.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class MultiStartDifferentiableMultivariateRealOptimizer\n+    extends BaseMultiStartMultivariateRealOptimizer<DifferentiableMultivariateRealFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n-\n-    /** Underlying classical optimizer. */\n-    private final DifferentiableMultivariateRealOptimizer optimizer;\n-\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed for all starts. */\n-    private int totalIterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed for all starts. */\n-    private int totalEvaluations;\n-\n-    /** Number of gradient evaluations already performed for all starts. */\n-    private int totalGradientEvaluations;\n-\n-    /** Number of starts to go. */\n-    private int starts;\n-\n-    /** Random generator for multi-start. */\n-    private RandomVectorGenerator generator;\n-\n-    /** Found optima. */\n-    private RealPointValuePair[] optima;\n-\n     /**\n-     * Create a multi-start optimizer from a single-start optimizer\n-     * @param optimizer single-start optimizer to wrap\n-     * @param starts number of starts to perform (including the\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n      * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param generator random vector generator to use for restarts\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n      */\n     public MultiStartDifferentiableMultivariateRealOptimizer(final DifferentiableMultivariateRealOptimizer optimizer,\n                                                              final int starts,\n                                                              final RandomVectorGenerator generator) {\n-        this.optimizer                = optimizer;\n-        this.totalIterations          = 0;\n-        this.totalEvaluations         = 0;\n-        this.totalGradientEvaluations = 0;\n-        this.starts                   = starts;\n-        this.generator                = generator;\n-        this.optima                   = null;\n-        setMaxIterations(Integer.MAX_VALUE);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n+        super(optimizer, starts, generator);\n     }\n-\n-    /** Get all the optima found during the last call to {@link\n-     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n-     * optimize}.\n-     * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(DifferentiableMultivariateRealFunction,\n-     * GoalType, double[]) optimize} method returns the best point only. This\n-     * method returns all the points found at the end of each starts,\n-     * including the best one already returned by the {@link\n-     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n-     * optimize} method.\n-     * </p>\n-     * <p>\n-     * The returned array as one element for each start as specified\n-     * in the constructor. It is ordered with the results from the\n-     * runs that did converge first, sorted from best to worst\n-     * objective value (i.e in ascending order if minimizing and in\n-     * descending order if maximizing), followed by and null elements\n-     * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(DifferentiableMultivariateRealFunction,\n-     * GoalType, double[]) optimize} method did throw a {@link\n-     * org.apache.commons.math.ConvergenceException ConvergenceException}).\n-     * This also means that if the first element is non null, it is the best\n-     * point found across all starts.</p>\n-     * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateRealFunction,\n-     * GoalType, double[]) optimize} has not been called\n-     */\n-    public RealPointValuePair[] getOptima() throws IllegalStateException {\n-        if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n-        }\n-        return optima.clone();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return totalIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return totalEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getGradientEvaluations() {\n-        return totalGradientEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker checker) {\n-        optimizer.setConvergenceChecker(checker);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealConvergenceChecker getConvergenceChecker() {\n-        return optimizer.getConvergenceChecker();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n-                                         final GoalType goalType,\n-                                         double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException {\n-\n-        optima                   = new RealPointValuePair[starts];\n-        totalIterations          = 0;\n-        totalEvaluations         = 0;\n-        totalGradientEvaluations = 0;\n-\n-        // multi-start loop\n-        for (int i = 0; i < starts; ++i) {\n-\n-            try {\n-                optimizer.setMaxIterations(maxIterations - totalIterations);\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n-                optima[i] = optimizer.optimize(f, goalType,\n-                                               (i == 0) ? startPoint : generator.nextVector());\n-            } catch (FunctionEvaluationException fee) {\n-                optima[i] = null;\n-            } catch (OptimizationException oe) {\n-                optima[i] = null;\n-            }\n-\n-            totalIterations          += optimizer.getIterations();\n-            totalEvaluations         += optimizer.getEvaluations();\n-            totalGradientEvaluations += optimizer.getGradientEvaluations();\n-\n-        }\n-\n-        // sort the optima from best to worst, followed by null elements\n-        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n-            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n-                if (o1 == null) {\n-                    return (o2 == null) ? 0 : +1;\n-                } else if (o2 == null) {\n-                    return -1;\n-                }\n-                final double v1 = o1.getValue();\n-                final double v2 = o2.getValue();\n-                return (goalType == GoalType.MINIMIZE) ?\n-                        Double.compare(v1, v2) : Double.compare(v2, v1);\n-            }\n-        });\n-\n-        if (optima[0] == null) {\n-            throw new OptimizationException(\n-                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                    starts);\n-        }\n-\n-        // return the found point given the best objective function value\n-        return optima[0];\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import java.util.Arrays;\n-import java.util.Comparator;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n- * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer} interface adding\n- * multi-start features to an existing optimizer.\n- * <p>\n+ * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer}\n+ * interface addind multi-start features to an existing optimizer.\n+ *\n  * This class wraps a classical optimizer to use it several times in\n  * turn with different starting points in order to avoid being trapped\n  * into a local extremum when looking for a global one.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class MultiStartDifferentiableMultivariateVectorialOptimizer\n+    extends BaseMultiStartMultivariateVectorialOptimizer<DifferentiableMultivariateVectorialFunction>\n     implements DifferentiableMultivariateVectorialOptimizer {\n-\n-    /** Serializable version identifier. */\n-    private static final long serialVersionUID = 9206382258980561530L;\n-\n-    /** Underlying classical optimizer. */\n-    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n-\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed for all starts. */\n-    private int totalIterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed for all starts. */\n-    private int totalEvaluations;\n-\n-    /** Number of jacobian evaluations already performed for all starts. */\n-    private int totalJacobianEvaluations;\n-\n-    /** Number of starts to go. */\n-    private int starts;\n-\n-    /** Random generator for multi-start. */\n-    private RandomVectorGenerator generator;\n-\n-    /** Found optima. */\n-    private VectorialPointValuePair[] optima;\n-\n     /**\n-     * Create a multi-start optimizer from a single-start optimizer\n-     * @param optimizer single-start optimizer to wrap\n-     * @param starts number of starts to perform (including the\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n      * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param generator random vector generator to use for restarts\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n      */\n     public MultiStartDifferentiableMultivariateVectorialOptimizer(\n                 final DifferentiableMultivariateVectorialOptimizer optimizer,\n                 final int starts,\n                 final RandomVectorGenerator generator) {\n-        this.optimizer                = optimizer;\n-        this.totalIterations          = 0;\n-        this.totalEvaluations         = 0;\n-        this.totalJacobianEvaluations = 0;\n-        this.starts                   = starts;\n-        this.generator                = generator;\n-        this.optima                   = null;\n-        setMaxIterations(Integer.MAX_VALUE);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n+        super(optimizer, starts, generator);\n     }\n-\n-    /** Get all the optima found during the last call to {@link\n-     * #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize}.\n-     * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize} method returns the\n-     * best point only. This method returns all the points found at the\n-     * end of each starts, including the best one already returned by the {@link\n-     * #optimize(DifferentiableMultivariateVectorialFunction, double[],\n-     * double[], double[]) optimize} method.\n-     * </p>\n-     * <p>\n-     * The returned array as one element for each start as specified\n-     * in the constructor. It is ordered with the results from the\n-     * runs that did converge first, sorted from best to worst\n-     * objective value (i.e in ascending order if minimizing and in\n-     * descending order if maximizing), followed by and null elements\n-     * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize} method did throw a {@link\n-     * org.apache.commons.math.ConvergenceException ConvergenceException}).\n-     * This also means that if the first element is non null, it is the best\n-     * point found across all starts.</p>\n-     * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateVectorialFunction,\n-     * double[], double[], double[]) optimize} has not been called\n-     */\n-    public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n-        if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n-        }\n-        return optima.clone();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return totalIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return totalEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getJacobianEvaluations() {\n-        return totalJacobianEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n-        optimizer.setConvergenceChecker(checker);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public VectorialConvergenceChecker getConvergenceChecker() {\n-        return optimizer.getConvergenceChecker();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n-                                            final double[] target, final double[] weights,\n-                                            final double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        optima                   = new VectorialPointValuePair[starts];\n-        totalIterations          = 0;\n-        totalEvaluations         = 0;\n-        totalJacobianEvaluations = 0;\n-\n-        // multi-start loop\n-        for (int i = 0; i < starts; ++i) {\n-\n-            try {\n-                optimizer.setMaxIterations(maxIterations - totalIterations);\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n-                optima[i] = optimizer.optimize(f, target, weights,\n-                                               (i == 0) ? startPoint : generator.nextVector());\n-            } catch (FunctionEvaluationException fee) {\n-                optima[i] = null;\n-            } catch (OptimizationException oe) {\n-                optima[i] = null;\n-            }\n-\n-            totalIterations          += optimizer.getIterations();\n-            totalEvaluations         += optimizer.getEvaluations();\n-            totalJacobianEvaluations += optimizer.getJacobianEvaluations();\n-\n-        }\n-\n-        // sort the optima from best to worst, followed by null elements\n-        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n-            public int compare(final VectorialPointValuePair o1, final VectorialPointValuePair o2) {\n-                if (o1 == null) {\n-                    return (o2 == null) ? 0 : +1;\n-                } else if (o2 == null) {\n-                    return -1;\n-                }\n-                return Double.compare(weightedResidual(o1), weightedResidual(o2));\n-            }\n-            private double weightedResidual(final VectorialPointValuePair pv) {\n-                final double[] value = pv.getValueRef();\n-                double sum = 0;\n-                for (int i = 0; i < value.length; ++i) {\n-                    final double ri = value[i] - target[i];\n-                    sum += weights[i] * ri * ri;\n-                }\n-                return sum;\n-            }\n-        });\n-\n-        if (optima[0] == null) {\n-            throw new OptimizationException(\n-                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                    starts);\n-        }\n-\n-        // return the found point given the best objective function value\n-        return optima[0];\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import java.util.Arrays;\n-import java.util.Comparator;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n  * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n- * <p>\n+ *\n  * This class wraps a classical optimizer to use it several times in\n  * turn with different starting points in order to avoid being trapped\n  * into a local extremum when looking for a global one.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class MultiStartMultivariateRealOptimizer\n+    extends BaseMultiStartMultivariateRealOptimizer<MultivariateRealFunction>\n     implements MultivariateRealOptimizer {\n-\n-    /** Underlying classical optimizer. */\n-    private final MultivariateRealOptimizer optimizer;\n-\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of iterations already performed for all starts. */\n-    private int totalIterations;\n-\n-    /** Number of evaluations already performed for all starts. */\n-    private int totalEvaluations;\n-\n-    /** Number of starts to go. */\n-    private int starts;\n-\n-    /** Random generator for multi-start. */\n-    private RandomVectorGenerator generator;\n-\n-    /** Found optima. */\n-    private RealPointValuePair[] optima;\n-\n     /**\n-     * Create a multi-start optimizer from a single-start optimizer\n-     * @param optimizer single-start optimizer to wrap\n-     * @param starts number of starts to perform (including the\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n      * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param generator random vector generator to use for restarts\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n      */\n     public MultiStartMultivariateRealOptimizer(final MultivariateRealOptimizer optimizer,\n                                                final int starts,\n                                                final RandomVectorGenerator generator) {\n-        this.optimizer        = optimizer;\n-        this.totalIterations  = 0;\n-        this.totalEvaluations = 0;\n-        this.starts           = starts;\n-        this.generator        = generator;\n-        this.optima           = null;\n-        setMaxIterations(Integer.MAX_VALUE);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n+        super(optimizer, starts, generator);\n     }\n-\n-    /** Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n-     * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n-     * double[]) optimize} method returns the best point only. This\n-     * method returns all the points found at the end of each starts,\n-     * including the best one already returned by the {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n-     * method.\n-     * </p>\n-     * <p>\n-     * The returned array as one element for each start as specified\n-     * in the constructor. It is ordered with the results from the\n-     * runs that did converge first, sorted from best to worst\n-     * objective value (i.e in ascending order if minimizing and in\n-     * descending order if maximizing), followed by and null elements\n-     * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} method did throw a {@link\n-     * org.apache.commons.math.ConvergenceException ConvergenceException}).\n-     * This also means that if the first element is non null, it is the best\n-     * point found across all starts.</p>\n-     * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} has not been called\n-     */\n-    public RealPointValuePair[] getOptima() throws IllegalStateException {\n-        if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n-        }\n-        return optima.clone();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return totalIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return totalEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker checker) {\n-        optimizer.setConvergenceChecker(checker);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealConvergenceChecker getConvergenceChecker() {\n-        return optimizer.getConvergenceChecker();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealPointValuePair optimize(final MultivariateRealFunction f,\n-                                         final GoalType goalType,\n-                                         double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException {\n-\n-        optima           = new RealPointValuePair[starts];\n-        totalIterations  = 0;\n-        totalEvaluations = 0;\n-\n-        // multi-start loop\n-        for (int i = 0; i < starts; ++i) {\n-\n-            try {\n-                optimizer.setMaxIterations(maxIterations - totalIterations);\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n-                optima[i] = optimizer.optimize(f, goalType,\n-                                               (i == 0) ? startPoint : generator.nextVector());\n-            } catch (FunctionEvaluationException fee) {\n-                optima[i] = null;\n-            } catch (OptimizationException oe) {\n-                optima[i] = null;\n-            }\n-\n-            totalIterations  += optimizer.getIterations();\n-            totalEvaluations += optimizer.getEvaluations();\n-\n-        }\n-\n-        // sort the optima from best to worst, followed by null elements\n-        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n-            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n-                if (o1 == null) {\n-                    return (o2 == null) ? 0 : +1;\n-                } else if (o2 == null) {\n-                    return -1;\n-                }\n-                final double v1 = o1.getValue();\n-                final double v2 = o2.getValue();\n-                return (goalType == GoalType.MINIMIZE) ?\n-                        Double.compare(v1, v2) : Double.compare(v2, v1);\n-            }\n-        });\n-\n-        if (optima[0] == null) {\n-            throw new OptimizationException(\n-                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                    starts);\n-        }\n-\n-        // return the found point given the best objective function value\n-        return optima[0];\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n  * scalar objective functions}.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n  * maximize or minimize} an objective function.</p>\n+ *\n  * @see DifferentiableMultivariateRealOptimizer\n  * @see DifferentiableMultivariateVectorialOptimizer\n  * @version $Revision$ $Date$\n--- a/src/main/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n+ * @deprecated To be removed in 3.0.\n  */\n-\n public interface RealConvergenceChecker {\n \n   /** Check if the optimization algorithm has converged considering the last points.\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n- * Simple implementation of the {@link RealConvergenceChecker} interface using\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n  * only point coordinates.\n- * <p>\n+ * \n  * Convergence is considered to have been reached if either the relative\n  * difference between each point coordinate are smaller than a threshold\n  * or if either the absolute difference between the point coordinates are\n  * smaller than another threshold.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.0\n+ * @since 3.0\n  */\n-public class SimpleRealPointChecker implements RealConvergenceChecker {\n+public class SimpleRealPointChecker\n+    extends AbstractConvergenceChecker<RealPointValuePair> {\n+    /**\n+     * Build an instance with default threshold.\n+     */\n+    public SimpleRealPointChecker() {}\n \n-    /** Default relative threshold. */\n-    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n-\n-    /** Default absolute threshold. */\n-    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n-\n-    /** Relative tolerance threshold. */\n-    private final double relativeThreshold;\n-\n-    /** Absolute tolerance threshold. */\n-    private final double absoluteThreshold;\n-\n-   /** Build an instance with default threshold.\n-     */\n-    public SimpleRealPointChecker() {\n-        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n-        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n-    }\n-\n-    /** Build an instance with a specified threshold.\n-     * <p>\n+    /**\n+     * Build an instance with specified thresholds.\n      * In order to perform only relative checks, the absolute tolerance\n      * must be set to a negative value. In order to perform only absolute\n      * checks, the relative tolerance must be set to a negative value.\n-     * </p>\n+     *\n      * @param relativeThreshold relative tolerance threshold\n      * @param absoluteThreshold absolute tolerance threshold\n      */\n     public SimpleRealPointChecker(final double relativeThreshold,\n-                                 final double absoluteThreshold) {\n-        this.relativeThreshold = relativeThreshold;\n-        this.absoluteThreshold = absoluteThreshold;\n+                                  final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param points Points used for checking convergence. The list must\n+     * contain two elements:\n+     * <ul>\n+     *  <li>the previous best point,</li>\n+     *  <li>the current best point.</li>\n+     * </ul>\n+     * @return {@code true} if the algorithm has converged.\n+     * @throws DimensionMismatchException if the length of the {@code points}\n+     * list is not equal to 2.\n+     */\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair previous,\n-                             final RealPointValuePair current) {\n-        final double[] p        = previous.getPoint();\n-        final double[] c        = current.getPoint();\n+                             final RealPointValuePair ... points) {\n+        if (points.length != 2) {\n+            throw new DimensionMismatchException(points.length, 2);\n+        }\n+\n+        final double[] p = points[0].getPoint();\n+        final double[] c = points[1].getPoint();\n         for (int i = 0; i < p.length; ++i) {\n             final double difference = FastMath.abs(p[i] - c[i]);\n-            final double size       = FastMath.max(FastMath.abs(p[i]), FastMath.abs(c[i]));\n-            if ((difference > (size * relativeThreshold)) && (difference > absoluteThreshold)) {\n+            final double size = FastMath.max(FastMath.abs(p[i]), FastMath.abs(c[i]));\n+            if (difference > size * getRelativeThreshold() &&\n+                difference > getAbsoluteThreshold()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n- * Simple implementation of the {@link RealConvergenceChecker} interface using\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n  * only objective function values.\n- * <p>\n+ *\n  * Convergence is considered to have been reached if either the relative\n  * difference between the objective function values is smaller than a\n  * threshold or if either the absolute difference between the objective\n  * function values is smaller than another threshold.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.0\n+ * @since 3.0\n  */\n-public class SimpleScalarValueChecker implements RealConvergenceChecker {\n+public class SimpleScalarValueChecker\n+    extends AbstractConvergenceChecker<RealPointValuePair> {\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public SimpleScalarValueChecker() {}\n \n-    /** Default relative threshold. */\n-    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n-\n-    /** Default absolute threshold. */\n-    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n-\n-    /** Relative tolerance threshold. */\n-    private final double relativeThreshold;\n-\n-    /** Absolute tolerance threshold. */\n-    private final double absoluteThreshold;\n-\n-   /** Build an instance with default threshold.\n-     */\n-    public SimpleScalarValueChecker() {\n-        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n-        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n-    }\n-\n-    /** Build an instance with a specified threshold.\n-     * <p>\n+    /** Build an instance with specified thresholds.\n+     *\n      * In order to perform only relative checks, the absolute tolerance\n      * must be set to a negative value. In order to perform only absolute\n      * checks, the relative tolerance must be set to a negative value.\n-     * </p>\n+     *\n      * @param relativeThreshold relative tolerance threshold\n      * @param absoluteThreshold absolute tolerance threshold\n      */\n     public SimpleScalarValueChecker(final double relativeThreshold,\n                                     final double absoluteThreshold) {\n-        this.relativeThreshold = relativeThreshold;\n-        this.absoluteThreshold = absoluteThreshold;\n+        super(relativeThreshold, absoluteThreshold);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param points Points used for checking convergence. The list must\n+     * contain two elements:\n+     * <ul>\n+     *  <li>the previous best point,</li>\n+     *  <li>the current best point.</li>\n+     * </ul>\n+     * @return {@code true} if the algorithm has converged.\n+     * @throws DimensionMismatchException if the length of the {@code points}\n+     * list is not equal to 2.\n+     */\n     public boolean converged(final int iteration,\n-                             final RealPointValuePair previous,\n-                             final RealPointValuePair current) {\n-        final double p          = previous.getValue();\n-        final double c          = current.getValue();\n+                             final RealPointValuePair ... points) {\n+        if (points.length != 2) {\n+            throw new DimensionMismatchException(points.length, 2);\n+        }\n+\n+        final double p = points[0].getValue();\n+        final double c = points[1].getValue();\n         final double difference = FastMath.abs(p - c);\n-        final double size       = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n-        return (difference <= (size * relativeThreshold)) || (difference <= absoluteThreshold);\n+        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n+        return (difference <= size * getRelativeThreshold() ||\n+                difference <= getAbsoluteThreshold());\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n- * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n  * only point coordinates.\n- * <p>\n+ *\n  * Convergence is considered to have been reached if either the relative\n  * difference between each point coordinate are smaller than a threshold\n  * or if either the absolute difference between the point coordinates are\n  * smaller than another threshold.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.0\n+ * @since 3.0\n  */\n-public class SimpleVectorialPointChecker implements VectorialConvergenceChecker {\n+public class SimpleVectorialPointChecker\n+    extends AbstractConvergenceChecker<VectorialPointValuePair> {\n+    /**\n+     * Build an instance with default threshold.\n+     */\n+    public SimpleVectorialPointChecker() {}\n \n-    /** Default relative threshold. */\n-    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n-\n-    /** Default absolute threshold. */\n-    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n-\n-    /** Relative tolerance threshold. */\n-    private final double relativeThreshold;\n-\n-    /** Absolute tolerance threshold. */\n-    private final double absoluteThreshold;\n-\n-   /** Build an instance with default threshold.\n-     */\n-    public SimpleVectorialPointChecker() {\n-        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n-        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n-    }\n-\n-    /** Build an instance with a specified threshold.\n-     * <p>\n+    /**\n+     * Build an instance with a specified threshold.\n+     *\n      * In order to perform only relative checks, the absolute tolerance\n      * must be set to a negative value. In order to perform only absolute\n      * checks, the relative tolerance must be set to a negative value.\n-     * </p>\n+     *\n      * @param relativeThreshold relative tolerance threshold\n      * @param absoluteThreshold absolute tolerance threshold\n      */\n     public SimpleVectorialPointChecker(final double relativeThreshold,\n                                        final double absoluteThreshold) {\n-        this.relativeThreshold = relativeThreshold;\n-        this.absoluteThreshold = absoluteThreshold;\n+        super(relativeThreshold, absoluteThreshold);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param points Points used for checking convergence. The list must\n+     * contain two elements:\n+     * <ul>\n+     *  <li>the previous best point,</li>\n+     *  <li>the current best point.</li>\n+     * </ul>\n+     * @return {@code true} if the algorithm has converged.\n+     * @throws DimensionMismatchException if the length of the {@code points}\n+     * list is not equal to 2.\n+     */\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair previous,\n-                             final VectorialPointValuePair current) {\n-        final double[] p = previous.getPointRef();\n-        final double[] c = current.getPointRef();\n+                             final VectorialPointValuePair ... points) {\n+        if (points.length != 2) {\n+            throw new DimensionMismatchException(points.length, 2);\n+        }\n+\n+        final double[] p = points[0].getPointRef();\n+        final double[] c = points[1].getPointRef();\n         for (int i = 0; i < p.length; ++i) {\n-            final double pi         = p[i];\n-            final double ci         = c[i];\n-            final double difference = FastMath.abs(pi - ci);\n-            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n-            if ((difference > (size * relativeThreshold)) &&\n-                (difference > absoluteThreshold)) {\n+            final double pi = p[i];\n+            final double ci = c[i];\n+            final double difference = Math.abs(pi - ci);\n+            final double size = Math.max(Math.abs(pi), Math.abs(ci));\n+            if (difference > size * getRelativeThreshold() &&\n+                difference > getAbsoluteThreshold()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n- * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n  * only objective function values.\n- * <p>\n+ *\n  * Convergence is considered to have been reached if either the relative\n  * difference between the objective function values is smaller than a\n  * threshold or if either the absolute difference between the objective\n  * function values is smaller than another threshold for all vectors elements.\n- * </p>\n+ *\n  * @version $Revision$ $Date$\n- * @since 2.0\n+ * @since 3.0\n  */\n-public class SimpleVectorialValueChecker implements VectorialConvergenceChecker {\n+public class SimpleVectorialValueChecker\n+    extends AbstractConvergenceChecker<VectorialPointValuePair> {\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public SimpleVectorialValueChecker() {}\n \n-    /** Default relative threshold. */\n-    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n-\n-    /** Default absolute threshold. */\n-    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n-\n-    /** Relative tolerance threshold. */\n-    private final double relativeThreshold;\n-\n-    /** Absolute tolerance threshold. */\n-    private final double absoluteThreshold;\n-\n-   /** Build an instance with default threshold.\n-     */\n-    public SimpleVectorialValueChecker() {\n-        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n-        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n-    }\n-\n-    /** Build an instance with a specified threshold.\n-     * <p>\n+    /**\n+     * Build an instance with specified thresholds.\n+     *\n      * In order to perform only relative checks, the absolute tolerance\n      * must be set to a negative value. In order to perform only absolute\n      * checks, the relative tolerance must be set to a negative value.\n-     * </p>\n+     *\n      * @param relativeThreshold relative tolerance threshold\n      * @param absoluteThreshold absolute tolerance threshold\n      */\n     public SimpleVectorialValueChecker(final double relativeThreshold,\n                                        final double absoluteThreshold) {\n-        this.relativeThreshold = relativeThreshold;\n-        this.absoluteThreshold = absoluteThreshold;\n+        super(relativeThreshold, absoluteThreshold);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param points Points used for checking convergence. The list must\n+     * contain two elements:\n+     * <ul>\n+     *  <li>the previous best point,</li>\n+     *  <li>the current best point.</li>\n+     * </ul>\n+     * @return {@code true} if the algorithm has converged.\n+     * @throws DimensionMismatchException if the length of the {@code points}\n+     * list is not equal to 2.\n+     */\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair previous,\n-                             final VectorialPointValuePair current) {\n-        final double[] p        = previous.getValueRef();\n-        final double[] c        = current.getValueRef();\n+                             final VectorialPointValuePair ... points) {\n+        if (points.length != 2) {\n+            throw new DimensionMismatchException(points.length, 2);\n+        }\n+\n+        final double[] p = points[0].getValueRef();\n+        final double[] c = points[1].getValueRef();\n         for (int i = 0; i < p.length; ++i) {\n             final double pi         = p[i];\n             final double ci         = c[i];\n             final double difference = FastMath.abs(pi - ci);\n             final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n-            if ((difference > (size * relativeThreshold)) &&\n-                (difference > absoluteThreshold)) {\n+            if (difference > size * getRelativeThreshold() &&\n+                difference > getAbsoluteThreshold()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxEvaluationsExceededException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.general.AbstractScalarOptimizer;\n \n /**\n  * This class implements simplex-based direct search optimization\n  * change, the start configuration will be reset to a default one with the\n  * appropriate dimensions.</p>\n  *\n- * <p>If {@link #setConvergenceChecker(RealConvergenceChecker)} is not called,\n+ * <p>If {@link #setConvergenceChecker(ConvergenceChecker)} is not called,\n  * a default {@link SimpleScalarValueChecker} is used.</p>\n  *\n  * <p>Convergence is checked by providing the <em>worst</em> points of\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public abstract class DirectSearchOptimizer implements MultivariateRealOptimizer {\n-\n+public abstract class DirectSearchOptimizer\n+    extends AbstractScalarOptimizer\n+    implements MultivariateRealOptimizer {\n     /** Simplex. */\n     protected RealPointValuePair[] simplex;\n-\n-    /** Objective function. */\n-    private MultivariateRealFunction f;\n-\n-    /** Convergence checker. */\n-    private RealConvergenceChecker checker;\n-\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed. */\n-    private int evaluations;\n-\n     /** Start simplex configuration. */\n     private double[][] startConfiguration;\n \n-    /** Simple constructor.\n+    /**\n+     * Default constructor.\n      */\n     protected DirectSearchOptimizer() {\n         setConvergenceChecker(new SimpleScalarValueChecker());\n-        setMaxIterations(Integer.MAX_VALUE);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n-    }\n-\n-    /** Set start configuration for simplex.\n+    }\n+\n+    /**\n+     * Set start configuration for simplex.\n+     *\n      * <p>The start configuration for simplex is built from a box parallel to\n      * the canonical axes of the space. The simplex is the subset of vertices\n      * of a box parallel to the canonical axes. It is built as the path followed\n      * start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }.\n      * The first vertex would be set to the start point at (1, 1, 1) and the\n      * last vertex would be set to the diagonally opposite vertex at (2, 11, 3).</p>\n-     * @param steps steps along the canonical axes representing box edges,\n-     * they may be negative but not null\n-     * @exception IllegalArgumentException if one step is null\n+     *\n+     * @param steps Steps along the canonical axes representing box edges. They\n+     * may be negative but not zero.\n+     * @throws IllegalArgumentException if one step is zero.\n      */\n     public void setStartConfiguration(final double[] steps)\n         throws IllegalArgumentException {\n         }\n     }\n \n-    /** Set start configuration for simplex.\n-     * <p>The real initial simplex will be set up by moving the reference\n+    /**\n+     * Set start configuration for simplex.\n+     * The real initial simplex will be set up by moving the reference\n      * simplex such that its first point is located at the start point of the\n-     * optimization.</p>\n-     * @param referenceSimplex reference simplex\n-     * @exception IllegalArgumentException if the reference simplex does not\n+     * optimization.\n+     *\n+     * @param referenceSimplex Reference simplex.\n+     * @throws IllegalArgumentException if the reference simplex does not\n      * contain at least one point, or if there is a dimension mismatch\n-     * in the reference simplex or if one of its vertices is duplicated\n+     * in the reference simplex or if one of its vertices is duplicated.\n      */\n     public void setStartConfiguration(final double[][] referenceSimplex)\n         throws IllegalArgumentException {\n \n             // safety checks\n             if (refI.length != n) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, refI.length, n);\n+                throw new DimensionMismatchException(refI.length, n);\n             }\n             for (int j = 0; j < i; ++j) {\n                 final double[] refJ = referenceSimplex[j];\n                     confI[k] = refI[k] - ref0[k];\n                 }\n             }\n-\n-        }\n-\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return iterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return evaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n-        this.checker = convergenceChecker;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealConvergenceChecker getConvergenceChecker() {\n-        return checker;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealPointValuePair optimize(final MultivariateRealFunction function,\n-                                       final GoalType goalType,\n-                                       final double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException,\n-        IllegalArgumentException {\n-\n+    protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException {\n+\n+        final double[] startPoint = getStartPoint();\n         if ((startConfiguration == null) ||\n             (startConfiguration.length != startPoint.length)) {\n-            // no initial configuration has been set up for simplex\n-            // build a default one from a unit hypercube\n+            // No initial configuration has been set up for simplex\n+            // build a default one from a unit hypercube.\n             final double[] unit = new double[startPoint.length];\n             Arrays.fill(unit, 1.0);\n             setStartConfiguration(unit);\n         }\n-\n-        this.f = function;\n-        final Comparator<RealPointValuePair> comparator =\n-            new Comparator<RealPointValuePair>() {\n-                public int compare(final RealPointValuePair o1,\n-                                   final RealPointValuePair o2) {\n-                    final double v1 = o1.getValue();\n-                    final double v2 = o2.getValue();\n-                    return (goalType == GoalType.MINIMIZE) ?\n-                            Double.compare(v1, v2) : Double.compare(v2, v1);\n-                }\n-            };\n-\n-        // initialize search\n-        iterations  = 0;\n-        evaluations = 0;\n+        \n+        final boolean isMinim = (getGoalType() == GoalType.MINIMIZE);\n+        final Comparator<RealPointValuePair> comparator\n+            = new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1,\n+                               final RealPointValuePair o2) {\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        };\n+\n+        // Initialize search.\n         buildSimplex(startPoint);\n         evaluateSimplex(comparator);\n \n         RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\n+        int iteration = 0;\n+        final ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-\n-            if (iterations > 0) {\n+            if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.length; ++i) {\n-                    converged &= checker.converged(iterations, previous[i], simplex[i]);\n+                    converged &= checker.converged(iteration, previous[i], simplex[i]);\n                 }\n                 if (converged) {\n                     // we have found an optimum\n                 }\n             }\n \n-            // we still need to search\n+            // We still need to search.\n             System.arraycopy(simplex, 0, previous, 0, simplex.length);\n             iterateSimplex(comparator);\n-\n-        }\n-\n-    }\n-\n-    /** Increment the iterations counter by 1.\n-     * @exception OptimizationException if the maximal number\n-     * of iterations is exceeded\n-     */\n-    protected void incrementIterationsCounter()\n-        throws OptimizationException {\n-        if (++iterations > maxIterations) {\n-            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-        }\n-    }\n-\n-    /** Compute the next simplex of the algorithm.\n-     * @param comparator comparator to use to sort simplex vertices from best to worst\n-     * @exception FunctionEvaluationException if the function cannot be evaluated at\n-     * some point\n-     * @exception OptimizationException if the algorithm fails to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n+            ++iteration;\n+        }\n+    }\n+\n+    /**\n+     * Compute the next simplex of the algorithm.\n+     *\n+     * @param comparator Comparator to use to sort simplex vertices from best to worst.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated at\n+     * some point.\n+     * @throws TooManyEvaluationsException if the algorithm fails to converge.\n+     * @throws DimensionMismatchException if the start point dimension is wrong.\n      */\n     protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n-    /** Evaluate the objective function on one point.\n-     * <p>A side effect of this method is to count the number of\n-     * function evaluations</p>\n-     * @param x point on which the objective function should be evaluated\n-     * @return objective function value at the given point\n-     * @exception FunctionEvaluationException if no value can be computed for the\n-     * parameters or if the maximal number of evaluations is exceeded\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    protected double evaluate(final double[] x)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n-        if (++evaluations > maxEvaluations) {\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  x);\n-        }\n-        return f.value(x);\n-    }\n-\n-    /** Build an initial simplex.\n-     * @param startPoint the start point for optimization\n-     * @exception IllegalArgumentException if the start point does not match\n-     * simplex dimension\n-     */\n-    private void buildSimplex(final double[] startPoint)\n-        throws IllegalArgumentException {\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * Build an initial simplex.\n+     *\n+     * @param startPoint Start point for optimization.\n+     * @throws DimensionMismatchException if the start point does not match\n+     * simplex dimension.\n+     */\n+    private void buildSimplex(final double[] startPoint) {\n \n         final int n = startPoint.length;\n         if (n != startConfiguration.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, startConfiguration.length);\n+            throw new DimensionMismatchException(n, startConfiguration.length);\n         }\n \n         // set first vertex\n \n         // set remaining vertices\n         for (int i = 0; i < n; ++i) {\n-            final double[] confI   = startConfiguration[i];\n+            final double[] confI = startConfiguration[i];\n             final double[] vertexI = new double[n];\n             for (int k = 0; k < n; ++k) {\n                 vertexI[k] = startPoint[k] + confI[k];\n             }\n             simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);\n         }\n-\n-    }\n-\n-    /** Evaluate all the non-evaluated points of the simplex.\n-     * @param comparator comparator to use to sort simplex vertices from best to worst\n-     * @exception FunctionEvaluationException if no value can be computed for the parameters\n-     * @exception OptimizationException if the maximal number of evaluations is exceeded\n+    }\n+\n+    /**\n+     * Evaluate all the non-evaluated points of the simplex.\n+     *\n+     * @param comparator Comparator to use to sort simplex vertices from best to worst.\n+     * @throws FunctionEvaluationException if no value can be computed for the parameters.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n      */\n     protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException {\n-\n-        // evaluate the objective function at all non-evaluated simplex points\n+        throws FunctionEvaluationException {\n+\n+        // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; ++i) {\n             final RealPointValuePair vertex = simplex[i];\n             final double[] point = vertex.getPointRef();\n             if (Double.isNaN(vertex.getValue())) {\n-                simplex[i] = new RealPointValuePair(point, evaluate(point), false);\n-            }\n-        }\n-\n-        // sort the simplex from best to worst\n+                simplex[i] = new RealPointValuePair(point, computeObjectiveValue(point), false);\n+            }\n+        }\n+\n+        // Sort the simplex from best to worst.\n         Arrays.sort(simplex, comparator);\n-\n-    }\n-\n-    /** Replace the worst point of the simplex by a new point.\n-     * @param pointValuePair point to insert\n-     * @param comparator comparator to use to sort simplex vertices from best to worst\n+    }\n+\n+    /**\n+     * Replace the worst point of the simplex by a new point.\n+     *\n+     * @param pointValuePair Point to insert.\n+     * @param comparator Comparator to use to sort simplex vertices from best to worst.\n      */\n     protected void replaceWorstPoint(RealPointValuePair pointValuePair,\n                                      final Comparator<RealPointValuePair> comparator) {\n         for (int i = 0; i < n; ++i) {\n             if (comparator.compare(simplex[i], pointValuePair) > 0) {\n                 RealPointValuePair tmp = simplex[i];\n-                simplex[i]         = pointValuePair;\n-                pointValuePair     = tmp;\n+                simplex[i] = pointValuePair;\n+                pointValuePair = tmp;\n             }\n         }\n         simplex[n] = pointValuePair;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n import java.util.Comparator;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n     /** {@inheritDoc} */\n     @Override\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException {\n \n-        final RealConvergenceChecker checker = getConvergenceChecker();\n+        final ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n+        int iteration = 0;\n         while (true) {\n+            ++iteration;\n \n-            incrementIterationsCounter();\n-\n-            // save the original vertex\n+            // Save the original vertex.\n             final RealPointValuePair[] original = simplex;\n             final RealPointValuePair best = original[0];\n \n-            // perform a reflection step\n+            // Perform a reflection step.\n             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n             if (comparator.compare(reflected, best) < 0) {\n \n-                // compute the expanded simplex\n+                // Compute the expanded simplex.\n                 final RealPointValuePair[] reflectedSimplex = simplex;\n                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                 if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n+                    // Accept the reflected simplex.\n                     simplex = reflectedSimplex;\n                 }\n \n                 return;\n-\n             }\n \n-            // compute the contracted simplex\n+            // Compute the contracted simplex.\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+                // Accept the contracted simplex.\n                 return;\n             }\n \n-            // check convergence\n-            final int iter = getIterations();\n+            // Check convergence.\n             boolean converged = true;\n             for (int i = 0; i < simplex.length; ++i) {\n-                converged &= checker.converged(iter, original[i], simplex[i]);\n+                converged &= checker.converged(iteration, original[i], simplex[i]);\n             }\n             if (converged) {\n                 return;\n             }\n-\n         }\n-\n     }\n \n-    /** Compute and evaluate a new simplex.\n-     * @param original original simplex (to be preserved)\n-     * @param coeff linear coefficient\n-     * @param comparator comparator to use to sort simplex vertices from best to poorest\n-     * @return best point in the transformed simplex\n-     * @exception FunctionEvaluationException if the function cannot be evaluated at\n-     * some point\n-     * @exception OptimizationException if the maximal number of evaluations is exceeded\n+    /**\n+     * Compute and evaluate a new simplex.\n+     *\n+     * @param original Original simplex (to be preserved).\n+     * @param coeff Linear coefficient.\n+     * @param comparator Comparator to use to sort simplex vertices from best\n+     * to poorest.\n+     * @return the best point in the transformed simplex.\n+     * @exception FunctionEvaluationException if the function cannot be\n+     * evaluated at some point.\n+     * @exception TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n      */\n     private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n                                               final double coeff,\n                                               final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n \n         final double[] xSmallest = original[0].getPointRef();\n         final int n = xSmallest.length;\n \n-        // create the linearly transformed simplex\n+        // Create the linearly transformed simplex.\n         simplex = new RealPointValuePair[n + 1];\n         simplex[0] = original[0];\n         for (int i = 1; i <= n; ++i) {\n             simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n         }\n \n-        // evaluate it\n+        // Evaluate the simplex.\n         evaluateSimplex(comparator);\n         return simplex[0];\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n import java.util.Comparator;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n     /** {@inheritDoc} */\n     @Override\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException {\n-\n-        incrementIterationsCounter();\n+        throws FunctionEvaluationException {\n \n         // the simplex has n+1 point if dimension is n\n         final int n = simplex.length - 1;\n         for (int j = 0; j < n; ++j) {\n             xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n         }\n-        final RealPointValuePair reflected = new RealPointValuePair(xR, evaluate(xR), false);\n+        final RealPointValuePair reflected\n+            = new RealPointValuePair(xR, computeObjectiveValue(xR), false);\n \n         if ((comparator.compare(best, reflected) <= 0) &&\n             (comparator.compare(reflected, secondBest) < 0)) {\n             for (int j = 0; j < n; ++j) {\n                 xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n             }\n-            final RealPointValuePair expanded = new RealPointValuePair(xE, evaluate(xE), false);\n+            final RealPointValuePair expanded\n+                = new RealPointValuePair(xE, computeObjectiveValue(xE), false);\n \n             if (comparator.compare(expanded, reflected) < 0) {\n                 // accept the expansion point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                 }\n-                final RealPointValuePair outContracted = new RealPointValuePair(xC, evaluate(xC), false);\n+                final RealPointValuePair outContracted\n+                    = new RealPointValuePair(xC, computeObjectiveValue(xC), false);\n \n                 if (comparator.compare(outContracted, reflected) <= 0) {\n                     // accept the contraction point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                 }\n-                final RealPointValuePair inContracted = new RealPointValuePair(xC, evaluate(xC), false);\n+                final RealPointValuePair inContracted\n+                    = new RealPointValuePair(xC, computeObjectiveValue(xC), false);\n \n                 if (comparator.compare(inContracted, worst) < 0) {\n                     // accept the contraction point\n                 simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n             }\n             evaluateSimplex(comparator);\n-\n         }\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /** Fitter for parametric univariate real functions y = f(x).\n      * @return fitted parameters\n      * @exception FunctionEvaluationException if the objective function throws one during\n      * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n+     * @exception ConvergenceException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong.\n      */\n     public double[] fit(final ParametricRealFunction f,\n                         final double[] initialGuess)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException {\n \n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n \n         // extract the coefficients\n         return optimum.getPointRef();\n-\n     }\n \n     /** Vectorial function computing function theoretical values. */\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n \n /** This class implements a curve fitting specialized for polynomials.\n  * <p>Polynomial fitting is a very simple case of curve fitting. The\n \n     /** Get the polynomial fitting the weighted (x, y) points.\n      * @return polynomial function best fitting the observed points\n-     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception ConvergenceException if the algorithm failed to converge\n      */\n-    public PolynomialFunction fit()\n-        throws OptimizationException {\n+    public PolynomialFunction fit() {\n         try {\n             return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n         } catch (FunctionEvaluationException fee) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxEvaluationsExceededException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for implementing least squares optimizers.\n- * <p>This base class handles the boilerplate methods associated to thresholds\n- * settings, jacobian and error estimation.</p>\n+ * It handles the boilerplate methods associated to thresholds settings,\n+ * jacobian and error estimation.\n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  *\n  */\n-public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer {\n-\n-    /** Default maximal number of iterations allowed. */\n-    public static final int DEFAULT_MAX_ITERATIONS = 100;\n-\n-    /** Convergence checker. */\n-    protected VectorialConvergenceChecker checker;\n-\n+public abstract class AbstractLeastSquaresOptimizer\n+    extends BaseAbstractVectorialOptimizer<DifferentiableMultivariateVectorialFunction>\n+    implements DifferentiableMultivariateVectorialOptimizer {\n     /**\n      * Jacobian matrix of the weighted residuals.\n-     * <p>This matrix is in canonical form just after the calls to\n+     * This matrix is in canonical form just after the calls to\n      * {@link #updateJacobian()}, but may be modified by the solver\n      * in the derived class (the {@link LevenbergMarquardtOptimizer\n-     * Levenberg-Marquardt optimizer} does this).</p>\n+     * Levenberg-Marquardt optimizer} does this).\n      */\n     protected double[][] weightedResidualJacobian;\n-\n     /** Number of columns of the jacobian matrix. */\n     protected int cols;\n-\n     /** Number of rows of the jacobian matrix. */\n     protected int rows;\n-\n-    /**\n-     * Target value for the objective functions at optimum.\n-     * @since 2.1\n-     */\n-    protected double[] targetValues;\n-\n-    /**\n-     * Weight for the least squares cost computation.\n-     * @since 2.1\n-     */\n-    protected double[] residualsWeights;\n-\n     /** Current point. */\n     protected double[] point;\n-\n     /** Current objective function value. */\n     protected double[] objective;\n-\n+    /** Current residuals. */\n+    protected double[] residuals;\n     /** Weighted residuals */\n     protected double[] weightedResiduals;\n-\n     /** Cost value (square root of the sum of the residuals). */\n     protected double cost;\n-\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed. */\n-    private int objectiveEvaluations;\n-\n-    /** Number of jacobian evaluations. */\n-    private int jacobianEvaluations;\n-\n-    /** Objective function. */\n-    private DifferentiableMultivariateVectorialFunction function;\n-\n     /** Objective function derivatives. */\n     private MultivariateMatrixFunction jF;\n-\n-    /** Simple constructor with default settings.\n-     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n-     * and the maximal number of evaluation is set to its default value.</p>\n-     */\n-    protected AbstractLeastSquaresOptimizer() {\n-        setConvergenceChecker(new SimpleVectorialValueChecker());\n-        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return iterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return objectiveEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n+    /** Number of evaluations of the Jacobian. */\n+    private int jacobianEvaluations;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleVectorialValueChecker}.\n+     */\n+    protected AbstractLeastSquaresOptimizer() {}\n+    /**\n+     * @param checker Convergence checker.\n+     * @param maxEvaluations Maximal number of function evaluations.\n+     */\n+    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<VectorialPointValuePair> checker,\n+                                            int maxEvaluations) {\n+        super(checker, maxEvaluations);\n+    }\n+\n+    /**\n+     * @return the number of evaluations of the Jacobian function.\n+     */\n     public int getJacobianEvaluations() {\n         return jacobianEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n-        this.checker = convergenceChecker;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public VectorialConvergenceChecker getConvergenceChecker() {\n-        return checker;\n-    }\n-\n-    /** Increment the iterations counter by 1.\n-     * @exception OptimizationException if the maximal number\n-     * of iterations is exceeded\n-     */\n-    protected void incrementIterationsCounter()\n-        throws OptimizationException {\n-        if (++iterations > maxIterations) {\n-            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-        }\n     }\n \n     /**\n             throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                   weightedResidualJacobian.length, rows);\n         }\n+\n+        final double[] residualsWeights = getWeightRef();\n+\n         for (int i = 0; i < rows; i++) {\n             final double[] ji = weightedResidualJacobian[i];\n             double wi = FastMath.sqrt(residualsWeights[i]);\n      * or its dimension doesn't match problem dimension or maximal number of\n      * of evaluations is exceeded\n      */\n-    protected void updateResidualsAndCost()\n-        throws FunctionEvaluationException {\n-\n-        if (++objectiveEvaluations > maxEvaluations) {\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  point);\n-        }\n-        objective = function.value(point);\n+    protected void updateResidualsAndCost() throws FunctionEvaluationException {\n+        objective = computeObjectiveValue(point);\n         if (objective.length != rows) {\n             throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                   objective.length, rows);\n         }\n+\n+        final double[] targetValues = getTargetRef();\n+        final double[] residualsWeights = getWeightRef();\n+\n         cost = 0;\n         int index = 0;\n         for (int i = 0; i < rows; i++) {\n             index += cols;\n         }\n         cost = FastMath.sqrt(cost);\n-\n     }\n \n     /**\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n-        return cost*cost;\n+        return cost * cost;\n     }\n \n     /**\n      * @return covariance matrix\n      * @exception FunctionEvaluationException if the function jacobian cannot\n      * be evaluated\n-     * @exception OptimizationException if the covariance matrix\n+     * @exception ConvergenceException if the covariance matrix\n      * cannot be computed (singular problem)\n      */\n     public double[][] getCovariances()\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n \n         // set up the jacobian\n         updateJacobian();\n                 new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n             return inverse.getData();\n         } catch (InvalidMatrixException ime) {\n-            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n+            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n         }\n \n     }\n      * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n      * @return errors in optimized parameters\n      * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n-     * @exception OptimizationException if the covariances matrix cannot be computed\n+     * @exception ConvergenceException if the covariances matrix cannot be computed\n      * or the number of degrees of freedom is not positive (number of measurements\n      * lesser or equal to number of parameters)\n      */\n     public double[] guessParametersErrors()\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n         if (rows <= cols) {\n-            throw new OptimizationException(\n-                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n-                    rows, cols);\n+            throw new ConvergenceException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n+                                           rows, cols);\n         }\n         double[] errors = new double[cols];\n         final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n     public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n                                             final double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        if (target.length != weights.length) {\n-            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                                            target.length, weights.length);\n-        }\n-\n-        // reset counters\n-        iterations           = 0;\n-        objectiveEvaluations = 0;\n-        jacobianEvaluations  = 0;\n-\n-        // store least squares problem characteristics\n-        function         = f;\n-        jF               = f.jacobian();\n-        targetValues     = target.clone();\n-        residualsWeights = weights.clone();\n-        this.point       = startPoint.clone();\n-\n-        // arrays shared with the other private methods\n-        rows      = target.length;\n-        cols      = point.length;\n+        throws FunctionEvaluationException {\n+        // Reset counter.\n+        jacobianEvaluations = 0;\n+\n+        // Store least squares problem characteristics.\n+        jF = f.jacobian();\n+        this.residuals = new double[target.length];\n+\n+        // Arrays shared with the other private methods.\n+        point = startPoint.clone();\n+        rows = target.length;\n+        cols = point.length;\n \n         weightedResidualJacobian = new double[rows][cols];\n         this.weightedResiduals = new double[rows];\n \n         cost = Double.POSITIVE_INFINITY;\n \n-        return doOptimize();\n-\n-    }\n-\n-    /** Perform the bulk of optimization algorithm.\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    protected abstract VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n+        return super.optimize(f, target, weights, startPoint);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n public abstract class AbstractScalarDifferentiableOptimizer\n     extends BaseAbstractScalarOptimizer<DifferentiableMultivariateRealFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n-\n-    /** Convergence checker.\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use the accessor\n-     * {@link BaseAbstractScalarOptimizer#getConvergenceChecker()} instead.\n+    /**\n+     * Objective function gradient.\n      */\n-    protected RealConvergenceChecker checker;\n-    /**\n-     * Type of optimization.\n-     * @since 2.1\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use the accessor\n-     * {@link BaseAbstractScalarOptimizer#getGoalType()} instead.\n-     */\n-    protected GoalType goal;\n-    /** Current point set.\n-     * @deprecated in 2.2 (to be removed in 3.0).\n-     */\n-    protected double[] point;\n-\n-    /** Number of gradient evaluations. */\n-    private int gradientEvaluations;\n-\n-    /** Objective function gradient. */\n     private MultivariateVectorialFunction gradient;\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link org.apache.commons.math.optimization.SimpleScalarValueChecker},\n-     * the allowed number of iterations and evaluations are set to their\n-     * default values.\n+     * The convergence check is set to a\n+     * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker\n+     * SimpleScalarValueChecker}.\n      */\n     protected AbstractScalarDifferentiableOptimizer() {}\n     /**\n      * @param checker Convergence checker.\n-     * @param maxIterations Maximum number of iterations.\n-     * @param maxEvaluations Maximum number of evaluations.\n+     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected AbstractScalarDifferentiableOptimizer(RealConvergenceChecker checker,\n-                                                    int maxIterations,\n+    protected AbstractScalarDifferentiableOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n                                                     int maxEvaluations) {\n-        super(checker, maxIterations, maxEvaluations);\n-        this.checker = checker; // Do not use (deprecated).\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getGradientEvaluations() {\n-        return gradientEvaluations;\n+        super(checker, maxEvaluations);\n     }\n \n     /**\n      * Compute the gradient vector.\n-     * @param evaluationPoint point at which the gradient must be evaluated\n-     * @return gradient at the specified point\n-     * @exception FunctionEvaluationException if the function gradient\n+     *\n+     * @param evaluationPoint Point at which the gradient must be evaluated.\n+     * @return the gradient at the specified point.\n+     * @throws FunctionEvaluationException if the function gradient cannot be\n+     * evaluated.\n+     * @throws TooManyEvaluationsException if the allowed number of evaluations\n+     * is exceeded.\n      */\n     protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n         throws FunctionEvaluationException {\n-        ++gradientEvaluations;\n         return gradient.value(evaluationPoint);\n     }\n \n     public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint)\n-        throws FunctionEvaluationException,\n-               OptimizationException {\n-        // reset counters\n-        gradientEvaluations = 0;\n-\n-        // store optimization problem characteristics\n+        throws FunctionEvaluationException {\n+        // Store optimization problem characteristics.\n         gradient = f.gradient();\n-\n-        goal = goalType; // Do not use (deprecated).\n-        point = startPoint.clone(); // Do not use (deprecated).\n \n         return super.optimize(f, goalType, startPoint);\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarOptimizer.java\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n-import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n  * Base class for implementing optimizers for multivariate (not necessarily\n     implements MultivariateRealOptimizer {\n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link org.apache.commons.math.optimization.SimpleScalarValueChecker},\n-     * the allowed number of iterations and evaluations are set to their\n-     * default values.\n+     * The convergence check is set to a\n+     * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker}.\n      */\n     protected AbstractScalarOptimizer() {}\n     /**\n      * @param checker Convergence checker.\n-     * @param maxIterations Maximum number of iterations.\n-     * @param maxEvaluations Maximum number of evaluations.\n+     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected AbstractScalarOptimizer(RealConvergenceChecker checker,\n-                                      int maxIterations,\n+    protected AbstractScalarOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n                                       int maxEvaluations) {\n-        super(checker, maxIterations, maxEvaluations);\n+        super(checker, maxEvaluations);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxEvaluationsExceededException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n  * A class that implements an optimization algorithm should inherit from\n  * {@link AbstractScalarOptimizer} or from\n  * {@link AbstractScalarDifferentiableOptimizer}.\n+ *\n  * @param <T> the type of the objective function to be optimized\n  *\n  * @version $Revision$ $Date$\n  */\n public abstract class BaseAbstractScalarOptimizer<T extends MultivariateRealFunction>\n     implements BaseMultivariateRealOptimizer<T> {\n-    /** Default maximal number of iterations allowed ({@value}). */\n-    public static final int DEFAULT_MAX_ITERATIONS = 1000;\n-    /** Default maximal number of iterations allowed ({@value}). */\n-    public static final int DEFAULT_MAX_EVALUATIONS = 10000;\n-\n+    /** Evaluations counter. */\n+    protected final Incrementor evaluations = new Incrementor();\n     /** Convergence checker. */\n-    private RealConvergenceChecker checker;\n+    private ConvergenceChecker<RealPointValuePair> checker;\n     /** Type of optimization. */\n     private GoalType goal;\n     /** Initial guess. */\n     private double[] start;\n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-    /** Number of evaluations already performed. */\n-    private int evaluations;\n     /** Objective function. */\n     private MultivariateRealFunction function;\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleScalarValueChecker},\n-     * the allowed number of iterations and evaluations are set to their\n-     * default values.\n+     * The convergence check is set to a {@link SimpleScalarValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      */\n     protected BaseAbstractScalarOptimizer() {\n-        this(new SimpleScalarValueChecker(),\n-             DEFAULT_MAX_ITERATIONS,\n-             DEFAULT_MAX_EVALUATIONS);\n+        this(new SimpleScalarValueChecker(), Integer.MAX_VALUE);\n     }\n     /**\n      * @param checker Convergence checker.\n-     * @param maxIterations Maximum number of iterations.\n-     * @param maxEvaluations Maximum number of evaluations.\n+     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected BaseAbstractScalarOptimizer(RealConvergenceChecker checker,\n-                                          int maxIterations,\n+    protected BaseAbstractScalarOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n                                           int maxEvaluations) {\n         this.checker = checker;\n-        this.maxIterations = maxIterations;\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return iterations;\n+        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n     public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n+        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n     public int getMaxEvaluations() {\n-        return maxEvaluations;\n+        return evaluations.getMaximalCount();\n     }\n \n     /** {@inheritDoc} */\n     public int getEvaluations() {\n-        return evaluations;\n+        return evaluations.getCount();\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n+    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> convergenceChecker) {\n         this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n-    public RealConvergenceChecker getConvergenceChecker() {\n+    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n         return checker;\n     }\n \n     /**\n-     * Increment the iterations counter by 1.\n-     * @throws OptimizationException if the maximal number\n-     * of iterations is exceeded\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at the specified point.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n      */\n-    protected void incrementIterationsCounter()\n-        throws OptimizationException {\n-        if (++iterations > maxIterations) {\n-            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+    protected double computeObjectiveValue(double[] point)\n+        throws FunctionEvaluationException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n         }\n-    }\n-\n-    /**\n-     * Compute the objective function value.\n-     * @param evaluationPoint point at which the objective function must be evaluated\n-     * @return objective function value at specified point\n-     * @throws FunctionEvaluationException if the function cannot be evaluated\n-     * or its dimension doesn't match problem dimension or the maximal number\n-     * of iterations is exceeded\n-     */\n-    protected double computeObjectiveValue(double[] evaluationPoint)\n-        throws FunctionEvaluationException {\n-        if (++evaluations > maxEvaluations) {\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  evaluationPoint);\n-        }\n-        return function.value(evaluationPoint);\n+        return function.value(point);\n     }\n \n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(T f,\n                                        GoalType goalType,\n                                        double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n+        // Reset.\n+        evaluations.resetCount();\n \n-        // reset counters\n-        iterations = 0;\n-        evaluations = 0;\n-\n-        // store optimization problem characteristics\n+        // Store optimization problem characteristics.\n         function = f;\n         goal = goalType;\n         start = startPoint.clone();\n \n+        // Perform computation.\n         return doOptimize();\n     }\n \n     }\n \n     /**\n-     * Perform the bulk of optimization algorithm.\n+     * Perform the bulk of the optimization algorithm.\n+     *\n      * @return the point/value pair giving the optimal value for objective function\n      * @throws FunctionEvaluationException if the objective function throws one during\n      * the search\n-     * @throws OptimizationException if the algorithm failed to converge\n-     * @throws IllegalArgumentException if the start point dimension is wrong\n      */\n     protected abstract RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException;\n+        throws FunctionEvaluationException;\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> the type of the objective function to be optimized\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class BaseAbstractVectorialOptimizer<FUNC extends MultivariateVectorialFunction>\n+    implements BaseMultivariateVectorialOptimizer<FUNC> {\n+    /** Evaluations counter. */\n+    protected final Incrementor evaluations = new Incrementor();\n+    /** Convergence checker. */\n+    private ConvergenceChecker<VectorialPointValuePair> checker;\n+    /** Target value for the objective functions at optimum. */\n+    private double[] target;\n+    /** Weight for the least squares cost computation. */\n+    private double[] weight;\n+    /** Initial guess. */\n+    private double[] start;\n+    /** Objective function. */\n+    private MultivariateVectorialFunction function;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleVectorialValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n+     */\n+    protected BaseAbstractVectorialOptimizer() {\n+        this(new SimpleVectorialValueChecker(),  Integer.MAX_VALUE);\n+    }\n+    /**\n+     * @param checker Convergence checker.\n+     * @param maxEvaluations Maximum number of function evaluations.\n+     */\n+    protected BaseAbstractVectorialOptimizer(ConvergenceChecker<VectorialPointValuePair> checker,\n+                                             int maxEvaluations) {\n+        this.checker = checker;\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> convergenceChecker) {\n+        this.checker = convergenceChecker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at the specified point.\n+     * @throws FunctionEvaluationException if the function cannot be evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n+     */\n+    protected double[] computeObjectiveValue(double[] point)\n+        throws FunctionEvaluationException {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(FUNC f,\n+                                            double[] target, double[] weight,\n+                                            double[] startPoint)\n+        throws FunctionEvaluationException {\n+\n+        if (target.length != weight.length) {\n+            throw new DimensionMismatchException(target.length, weight.length);\n+        }\n+\n+        // Reset.\n+        evaluations.resetCount();\n+\n+        // Store optimization problem characteristics.\n+        function = f;\n+        this.target = target.clone();\n+        this.weight = weight.clone();\n+        start = startPoint.clone();\n+\n+        // Perform computation.\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double[] getStartPoint() {\n+        return start.clone();\n+    }\n+\n+    /**\n+     * Perform the bulk of the optimization algorithm.\n+     *\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @throws FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     */\n+    protected abstract VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * @return a reference to the {@link #target array}.\n+     */\n+    protected double[] getTargetRef() {\n+        return target;\n+    }\n+    /**\n+     * @return a reference to the {@link #weight array}.\n+     */\n+    protected double[] getWeightRef() {\n+        return weight;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /**\n  */\n \n public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n-\n     /** Indicator for using LU decomposition. */\n     private final boolean useLU;\n \n-    /** Simple constructor with default settings.\n-     * <p>The convergence check is set to a {@link\n-     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}\n-     * and the maximal number of evaluation is set to\n-     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_ITERATIONS}.\n-     * @param useLU if true, the normal equations will be solved using LU\n-     * decomposition, otherwise they will be solved using QR decomposition\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link\n+     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.\n+     *\n+     * @param useLU if {@code true}, the normal equations will be solved\n+     * using LU decomposition, otherwise they will be solved using QR\n+     * decomposition.\n      */\n     public GaussNewtonOptimizer(final boolean useLU) {\n         this.useLU = useLU;\n     /** {@inheritDoc} */\n     @Override\n     public VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException {\n \n         // iterate until convergence is reached\n         VectorialPointValuePair current = null;\n+        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-\n-            incrementIterationsCounter();\n+            ++iter;\n \n             // evaluate the objective function and its jacobian\n             VectorialPointValuePair previous = current;\n             updateResidualsAndCost();\n             updateJacobian();\n             current = new VectorialPointValuePair(point, objective);\n+\n+            final double[] targetValues = getTargetRef();\n+            final double[] residualsWeights = getWeightRef();\n \n             // build the linear problem\n             final double[]   b = new double[cols];\n                         ak[l] += wgk * grad[l];\n                     }\n                 }\n-\n             }\n \n             try {\n-\n                 // solve the linearized least squares problem\n                 RealMatrix mA = new BlockRealMatrix(a);\n                 DecompositionSolver solver = useLU ?\n                 for (int i = 0; i < cols; ++i) {\n                     point[i] += dX[i];\n                 }\n-\n-            } catch(InvalidMatrixException e) {\n-                throw new OptimizationException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n+            } catch (InvalidMatrixException e) {\n+                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n             }\n \n             // check convergence\n             if (previous != null) {\n-                converged = checker.converged(getIterations(), previous, current);\n+                converged = getConvergenceChecker().converged(iter, previous, current);\n             }\n-\n         }\n-\n         // we have converged\n         return current;\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import java.util.Arrays;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n      * Build an optimizer for least squares problems.\n      * <p>The default values for the algorithm settings are:\n      *   <ul>\n-     *    <li>{@link #setConvergenceChecker(VectorialConvergenceChecker) vectorial convergence checker}: null</li>\n+     *    <li>{@link #setConvergenceChecker(ConvergenceChecker) vectorial convergence checker}: null</li>\n      *    <li>{@link #setInitialStepBoundFactor(double) initial step bound factor}: 100.0</li>\n-     *    <li>{@link #setMaxIterations(int) maximal iterations}: 1000</li>\n      *    <li>{@link #setCostRelativeTolerance(double) cost relative tolerance}: 1.0e-10</li>\n      *    <li>{@link #setParRelativeTolerance(double) parameters relative tolerance}: 1.0e-10</li>\n      *    <li>{@link #setOrthoTolerance(double) orthogonality tolerance}: 1.0e-10</li>\n      * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n      */\n     public LevenbergMarquardtOptimizer() {\n-\n-        // set up the superclass with a default  max cost evaluations setting\n-        setMaxIterations(1000);\n-\n         // default values for the tuning parameters\n         setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setParRelativeTolerance(1.0e-10);\n         setOrthoTolerance(1.0e-10);\n         setQRRankingThreshold(MathUtils.SAFE_MIN);\n-\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+    protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException {\n \n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         lmPar = 0;\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n+        int iter = 0;\n+        final ConvergenceChecker<VectorialPointValuePair> checker = getConvergenceChecker();\n         while (true) {\n+            ++iter;\n+\n             for (int i=0;i<rows;i++) {\n                 qtf[i]=weightedResiduals[i];\n             }\n-            incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n             VectorialPointValuePair previous = current;\n             }\n \n             if (firstIteration) {\n-\n                 // scale the point according to the norms of the columns\n                 // of the initial jacobian\n                 xNorm = 0;\n \n                 // initialize the step bound delta\n                 delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n-\n             }\n \n             // check orthogonality between function vector and jacobian columns\n                     xNorm = 0;\n                     for (int k = 0; k < cols; ++k) {\n                         double xK = diag[k] * point[k];\n-                        xNorm    += xK * xK;\n+                        xNorm += xK * xK;\n                     }\n                     xNorm = FastMath.sqrt(xNorm);\n                     current = new VectorialPointValuePair(point, objective);\n \n                     // tests for convergence.\n                     if (checker != null) {\n-                    // we use the vectorial convergence checker\n-                        if (checker.converged(getIterations(), previous, current)) {\n-                            return current;\n-                        }\n+                        // we use the vectorial convergence checker\n+                    \tif (checker.converged(iter, previous, current)) {\n+                    \t\treturn current;\n+                    \t}\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n                 if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n-                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n+                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                             costRelativeTolerance);\n                 } else if (delta <= 2.2204e-16 * xNorm) {\n-                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n+                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                             parRelativeTolerance);\n                 } else if (maxCosine <= 2.2204e-16)  {\n-                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n+                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                             orthoTolerance);\n                 }\n-\n-            }\n-\n-        }\n-\n+            }\n+        }\n     }\n \n     /**\n                         lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                         weightedResidualJacobian[i][pk] = temp2;\n                     }\n-\n                 }\n             }\n \n             // the corresponding diagonal element of R\n             lmDiag[j] = weightedResidualJacobian[j][permutation[j]];\n             weightedResidualJacobian[j][permutation[j]] = lmDir[j];\n-\n         }\n \n         // solve the triangular system for z, if the system is\n         for (int j = 0; j < lmDir.length; ++j) {\n             lmDir[permutation[j]] = work[j];\n         }\n-\n     }\n \n     /**\n      * are performed in non-increasing columns norms order thanks to columns\n      * pivoting. The diagonal elements of the R matrix are therefore also in\n      * non-increasing absolute values order.</p>\n-     * @exception OptimizationException if the decomposition cannot be performed\n-     */\n-    private void qrDecomposition() throws OptimizationException {\n+     * @exception ConvergenceException if the decomposition cannot be performed\n+     */\n+    private void qrDecomposition() throws ConvergenceException {\n \n         // initializations\n         for (int k = 0; k < cols; ++k) {\n                     norm2 += aki * aki;\n                 }\n                 if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                    throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n+                    throw new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                             rows, cols);\n                 }\n                 if (norm2 > ak2) {\n                     weightedResidualJacobian[j][permutation[k + dk]] -= gamma * weightedResidualJacobian[j][pk];\n                 }\n             }\n-\n-        }\n-\n+        }\n         rank = solvedCols;\n-\n     }\n \n     /**\n             }\n         }\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.util.FastMath;\n \n     /** Current point. */\n     private double[] point;\n \n-    /** Simple constructor with default settings.\n-     * <p>The convergence check is set to a {@link\n-     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}\n-     * and the maximal number of iterations is set to\n-     * {@link AbstractScalarDifferentiableOptimizer#DEFAULT_MAX_ITERATIONS}.\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link\n+     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.\n+     *\n      * @param updateFormula formula to use for updating the &beta; parameter,\n      * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n      * ConjugateGradientFormula#POLAK_RIBIERE}\n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-        try {\n-            // initialization\n-            if (preconditioner == null) {\n-                preconditioner = new IdentityPreconditioner();\n-            }\n-            if (solver == null) {\n-                solver = new BrentSolver();\n-            }\n-            point = getStartPoint();\n-            final GoalType goal = getGoalType();\n-            final int n = point.length;\n-            double[] r = computeObjectiveGradient(point);\n+        throws FunctionEvaluationException {\n+        // Initialization.\n+        if (preconditioner == null) {\n+            preconditioner = new IdentityPreconditioner();\n+        }\n+        if (solver == null) {\n+            solver = new BrentSolver();\n+        }\n+        point = getStartPoint();\n+        final GoalType goal = getGoalType();\n+        final int n = point.length;\n+        double[] r = computeObjectiveGradient(point);\n+        if (goal == GoalType.MINIMIZE) {\n+            for (int i = 0; i < n; ++i) {\n+                r[i] = -r[i];\n+            }\n+        }\n+\n+        // Initial search direction.\n+        double[] steepestDescent = preconditioner.precondition(point, r);\n+        double[] searchDirection = steepestDescent.clone();\n+\n+        double delta = 0;\n+        for (int i = 0; i < n; ++i) {\n+            delta += r[i] * searchDirection[i];\n+        }\n+\n+        RealPointValuePair current = null;\n+        int iter = 0;\n+        while (true) {\n+            ++iter;\n+\n+            final double objective = computeObjectiveValue(point);\n+            RealPointValuePair previous = current;\n+            current = new RealPointValuePair(point, objective);\n+            if (previous != null) {\n+                if (getConvergenceChecker().converged(iter, previous, current)) {\n+                    // We have found an optimum.\n+                    return current;\n+                }\n+            }\n+\n+            double dTd = 0;\n+            for (final double di : searchDirection) {\n+                dTd += di * di;\n+            }\n+\n+            // Find the optimal step in the search direction.\n+            final UnivariateRealFunction lsf = new LineSearchFunction(searchDirection);\n+            try {\n+                final double step = solver.solve(lsf, 0, findUpperBound(lsf, 0, initialStep));\n+\n+                // Validate new point.\n+                for (int i = 0; i < point.length; ++i) {\n+                    point[i] += step * searchDirection[i];\n+                }\n+            } catch (org.apache.commons.math.ConvergenceException e) {\n+                throw new ConvergenceException(); // XXX ugly workaround.\n+            }\n+\n+            r = computeObjectiveGradient(point);\n             if (goal == GoalType.MINIMIZE) {\n                 for (int i = 0; i < n; ++i) {\n                     r[i] = -r[i];\n                 }\n             }\n \n-            // initial search direction\n-            double[] steepestDescent = preconditioner.precondition(point, r);\n-            double[] searchDirection = steepestDescent.clone();\n-\n-            double delta = 0;\n+            // Compute beta.\n+            final double deltaOld = delta;\n+            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n+            delta = 0;\n             for (int i = 0; i < n; ++i) {\n-                delta += r[i] * searchDirection[i];\n-            }\n-\n-            RealPointValuePair current = null;\n-            while (true) {\n-\n-                final double objective = computeObjectiveValue(point);\n-                RealPointValuePair previous = current;\n-                current = new RealPointValuePair(point, objective);\n-                if (previous != null) {\n-                    if (getConvergenceChecker().converged(getIterations(), previous, current)) {\n-                        // we have found an optimum\n-                        return current;\n-                    }\n-                }\n-\n-                incrementIterationsCounter();\n-\n-                double dTd = 0;\n-                for (final double di : searchDirection) {\n-                    dTd += di * di;\n-                }\n-\n-                // find the optimal step in the search direction\n-                final UnivariateRealFunction lsf = new LineSearchFunction(searchDirection);\n-                final double step = solver.solve(lsf, 0, findUpperBound(lsf, 0, initialStep));\n-\n-                // validate new point\n-                for (int i = 0; i < point.length; ++i) {\n-                    point[i] += step * searchDirection[i];\n-                }\n-                r = computeObjectiveGradient(point);\n-                if (goal == GoalType.MINIMIZE) {\n-                    for (int i = 0; i < n; ++i) {\n-                        r[i] = -r[i];\n-                    }\n-                }\n-\n-                // compute beta\n-                final double deltaOld = delta;\n-                final double[] newSteepestDescent = preconditioner.precondition(point, r);\n-                delta = 0;\n+                delta += r[i] * newSteepestDescent[i];\n+            }\n+\n+            final double beta;\n+            if (updateFormula == ConjugateGradientFormula.FLETCHER_REEVES) {\n+                beta = delta / deltaOld;\n+            } else {\n+                double deltaMid = 0;\n+                for (int i = 0; i < r.length; ++i) {\n+                    deltaMid += r[i] * steepestDescent[i];\n+                }\n+                beta = (delta - deltaMid) / deltaOld;\n+            }\n+            steepestDescent = newSteepestDescent;\n+\n+            // Compute conjugate search direction.\n+            if (iter % n == 0 ||\n+                beta < 0) {\n+                // Break conjugation: reset search direction.\n+                searchDirection = steepestDescent.clone();\n+            } else {\n+                // Compute new conjugate search direction.\n                 for (int i = 0; i < n; ++i) {\n-                    delta += r[i] * newSteepestDescent[i];\n-                }\n-\n-                final double beta;\n-                if (updateFormula == ConjugateGradientFormula.FLETCHER_REEVES) {\n-                    beta = delta / deltaOld;\n-                } else {\n-                    double deltaMid = 0;\n-                    for (int i = 0; i < r.length; ++i) {\n-                        deltaMid += r[i] * steepestDescent[i];\n-                    }\n-                    beta = (delta - deltaMid) / deltaOld;\n-                }\n-                steepestDescent = newSteepestDescent;\n-\n-                // compute conjugate search direction\n-                if ((getIterations() % n == 0) || (beta < 0)) {\n-                    // break conjugation: reset search direction\n-                    searchDirection = steepestDescent.clone();\n-                } else {\n-                    // compute new conjugate search direction\n-                    for (int i = 0; i < n; ++i) {\n-                        searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n-                    }\n-                }\n-\n-            }\n-\n-        } catch (ConvergenceException ce) {\n-            throw new OptimizationException(ce);\n+                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n+                }\n+            }\n         }\n     }\n \n      * @param h initial step to try\n      * @return b such that f(a) and f(b) have opposite signs\n      * @exception FunctionEvaluationException if the function cannot be computed\n-     * @exception OptimizationException if no bracket can be found\n+     * @exception MathIllegalStateException if no bracket can be found\n+     * @deprecated in 2.2 (must be replaced with \"BracketFinder\").\n      */\n     private double findUpperBound(final UnivariateRealFunction f,\n                                   final double a, final double h)\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n         final double yA = f.value(a);\n         double yB = yA;\n         for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n                 return b;\n             }\n         }\n-        throw new OptimizationException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n+        throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n     }\n \n     /** Default identity preconditioner. */\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n import java.util.Arrays;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer;\n import org.apache.commons.math.optimization.univariate.BracketFinder;\n import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair;\n \n /**\n  * Powell algorithm.\n  * This code is translated and adapted from the Python version of this\n  * algorithm (as implemented in module {@code optimize.py} v0.5 of\n  * <em>SciPy</em>).\n+ * <br/>\n+ * The user is responsible for calling {@link\n+ * #setConvergenceChecker(ConvergenceChecker) ConvergenceChecker}\n+ * prior to using the optimizer.\n  *\n  * @version $Revision$ $Date$\n  * @since 2.2\n public class PowellOptimizer\n     extends AbstractScalarOptimizer {\n     /**\n-     * Default relative tolerance for line search ({@value}).\n-     */\n-    public static final double DEFAULT_LS_RELATIVE_TOLERANCE = 1e-7;\n-    /**\n-     * Default absolute tolerance for line search ({@value}).\n-     */\n-    public static final double DEFAULT_LS_ABSOLUTE_TOLERANCE = 1e-11;\n-    /**\n      * Line search.\n      */\n-    private final LineSearch line;\n-\n-    /**\n-     * Constructor with default line search tolerances (see the\n-     * {@link #PowellOptimizer(double,double) other constructor}).\n-     */\n-    public PowellOptimizer() {\n-        this(DEFAULT_LS_RELATIVE_TOLERANCE,\n-             DEFAULT_LS_ABSOLUTE_TOLERANCE);\n-    }\n-\n-    /**\n-     * Constructor with default absolute line search tolerances (see\n-     * the {@link #PowellOptimizer(double,double) other constructor}).\n+    private LineSearch line = new LineSearch();\n+\n+    /**\n+     * Set the convergence checker.\n+     * It also indirectly sets the line search tolerances to the square-root\n+     * of the correponding tolerances in the checker.\n      *\n-     * @param lsRelativeTolerance Relative error tolerance for\n-     * the line search algorithm ({@link BrentOptimizer}).\n-     */\n-    public PowellOptimizer(double lsRelativeTolerance) {\n-        this(lsRelativeTolerance,\n-             DEFAULT_LS_ABSOLUTE_TOLERANCE);\n-    }\n-\n-    /**\n-     * @param lsRelativeTolerance Relative error tolerance for\n-     * the line search algorithm ({@link BrentOptimizer}).\n-     * @param lsAbsoluteTolerance Relative error tolerance for\n-     * the line search algorithm ({@link BrentOptimizer}).\n-     */\n-    public PowellOptimizer(double lsRelativeTolerance,\n-                           double lsAbsoluteTolerance) {\n-        line = new LineSearch(lsRelativeTolerance,\n-                              lsAbsoluteTolerance);\n+     * @param checker Convergence checker.\n+     */\n+    public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> checker) {\n+        super.setConvergenceChecker(checker);\n+\n+        // Line search tolerances can be much lower than the tolerances\n+        // required for the optimizer itself.\n+        final double minTol = 1e-4;\n+        final double rel = Math.min(Math.sqrt(checker.getRelativeThreshold()), minTol);\n+        final double abs = Math.min(Math.sqrt(checker.getAbsoluteThreshold()), minTol);\n+        line.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(rel, abs));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        super.setMaxEvaluations(maxEvaluations);\n+\n+        // We must allow at least as many iterations to the underlying line\n+        // search optimizer. Because the line search inner class will call \n+        // \"computeObjectiveValue\" in this class, we ensure that this class\n+        // will be the first to eventually throw \"TooManyEvaluationsException\".\n+        line.setMaxEvaluations(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException,\n-               OptimizationException {\n+        throws FunctionEvaluationException {\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n+        int iter = 0;\n         while (true) {\n-            incrementIterationsCounter();\n+            ++iter;\n \n             double fX = fVal;\n             double fX2 = 0;\n \n                 fX2 = fVal;\n \n-                line.search(x, d);\n-                fVal = line.getValueAtOptimum();\n-                alphaMin = line.getOptimum();\n+                final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                fVal = optimum.getValue();\n+                alphaMin = optimum.getPoint();\n                 final double[][] result = newPointAndDirection(x, d, alphaMin);\n                 x = result[0];\n \n \n             final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n             final RealPointValuePair current = new RealPointValuePair(x, fVal);\n-            if (getConvergenceChecker().converged(getIterations(), previous, current)) {\n+            if (getConvergenceChecker().converged(iter, previous, current)) {\n                 if (goal == GoalType.MINIMIZE) {\n                     return (fVal < fX) ? current : previous;\n                 } else {\n                 t -= delta * temp * temp;\n \n                 if (t < 0.0) {\n-                    line.search(x, d);\n-                    fVal = line.getValueAtOptimum();\n-                    alphaMin = line.getOptimum();\n+                    final UnivariateRealPointValuePair optimum = line.search(x, d);\n+                    fVal = optimum.getValue();\n+                    alphaMin = optimum.getPoint();\n                     final double[][] result = newPointAndDirection(x, d, alphaMin);\n                     x = result[0];\n \n      * Class for finding the minimum of the objective function along a given\n      * direction.\n      */\n-    private class LineSearch {\n-        /**\n-         * Optimizer.\n-         */\n-        private final AbstractUnivariateRealOptimizer optim = new BrentOptimizer();\n+    private class LineSearch extends BrentOptimizer {\n         /**\n          * Automatic bracketing.\n          */\n         /**\n          * Value of the optimum.\n          */\n-        private double optimum = Double.NaN;\n-        /**\n-         * Value of the objective function at the optimum.\n-         */\n-        private double valueAtOptimum = Double.NaN;\n-\n-        /**\n-         * @param relativeTolerance Relative tolerance.\n-         * @param absoluteTolerance Absolute tolerance.\n-         */\n-        public LineSearch(double relativeTolerance,\n-                          double absoluteTolerance) {\n-            optim.setRelativeAccuracy(relativeTolerance);\n-            optim.setAbsoluteAccuracy(absoluteTolerance);\n-        }\n+        private UnivariateRealPointValuePair optimum;\n \n         /**\n          * Find the minimum of the function {@code f(p + alpha * d)}.\n          *\n          * @param p Starting point.\n          * @param d Search direction.\n-         * @throws OptimizationException if function cannot be evaluated at some test point\n-         * or algorithm fails to converge\n+         * @return the optimum.\n+         * @throws FunctionEvaluationException if the function evaluation\n+         * fails.\n+         * @throws TooManyEvaluationsException if the number of evaluations is\n+         * exceeded.\n          */\n-        public void search(final double[] p,\n-                           final double[] d)\n-            throws OptimizationException {\n-\n-            // Reset.\n-            optimum = Double.NaN;\n-            valueAtOptimum = Double.NaN;\n-\n-            try {\n-                final int n = p.length;\n-                final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                        public double value(double alpha)\n-                            throws FunctionEvaluationException {\n-\n-                            final double[] x = new double[n];\n-                            for (int i = 0; i < n; i++) {\n-                                x[i] = p[i] + alpha * d[i];\n-                            }\n-                            final double obj = computeObjectiveValue(x);\n-                            return obj;\n+        public UnivariateRealPointValuePair search(final double[] p,\n+                                                   final double[] d)\n+            throws FunctionEvaluationException {\n+\n+            final int n = p.length;\n+            final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                    public double value(double alpha)\n+                        throws FunctionEvaluationException {\n+                        \n+                        final double[] x = new double[n];\n+                        for (int i = 0; i < n; i++) {\n+                            x[i] = p[i] + alpha * d[i];\n                         }\n-                    };\n-\n-                final GoalType goal = getGoalType();\n-                bracket.search(f, goal, 0, 1);\n-                optimum = optim.optimize(f, goal,\n-                                         bracket.getLo(),\n-                                         bracket.getHi(),\n-                                         bracket.getMid());\n-                valueAtOptimum = optim.getFunctionValue();\n-            } catch (FunctionEvaluationException e) {\n-                throw new OptimizationException(e);\n-            } catch (MaxIterationsExceededException e) {\n-                throw new OptimizationException(e);\n-            }\n-        }\n-\n-        /**\n-         * @return the optimum.\n-         */\n-        public double getOptimum() {\n-            return optimum;\n-        }\n-        /**\n-         * @return the value of the function at the optimum.\n-         */\n-        public double getValueAtOptimum() {\n-            return valueAtOptimum;\n+                        final double obj = PowellOptimizer.this.computeObjectiveValue(x);\n+                        return obj;\n+                    }\n+                };\n+            \n+            final GoalType goal = PowellOptimizer.this.getGoalType();\n+            bracket.search(f, goal, 0, 1);\n+            return optimize(f, goal, bracket.getLo(), bracket.getHi(),\n+                            bracket.getMid());\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.ConvergingAlgorithmImpl;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxEvaluationsExceededException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n  * @since 2.0\n  */\n public abstract class AbstractUnivariateRealOptimizer\n-    extends ConvergingAlgorithmImpl implements UnivariateRealOptimizer {\n-    /** Indicates where a root has been computed. */\n-    private boolean resultComputed;\n-    /** The last computed root. */\n-    private double result;\n-    /** Value of the function at the last computed result. */\n-    private double functionValue;\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-    /** Number of evaluations already performed. */\n-    private int evaluations;\n+    implements UnivariateRealOptimizer {\n+    /** Convergence checker. */\n+    private ConvergenceChecker<UnivariateRealPointValuePair> checker;\n+    /** Evaluations counter. */\n+    private final Incrementor evaluations = new Incrementor();\n     /** Optimization type */\n-    private GoalType optimizationGoal;\n+    private GoalType goal;\n     /** Lower end of search interval. */\n     private double searchMin;\n     /** Higher end of search interval. */\n     /** Function to optimize. */\n     private UnivariateRealFunction function;\n \n-    /**\n-     * Construct a solver with given iteration count and accuracy.\n-     * FunctionEvaluationExceptionFunctionEvaluationException\n-     * @param defaultAbsoluteAccuracy maximum absolute error\n-     * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the\n-     * defaultAbsoluteAccuracy is not valid\n-     * @deprecated in 2.2. Please use the \"setter\" methods to assign meaningful\n-     * values to the maximum numbers of iterations and evaluations, and to the\n-     * absolute and relative accuracy thresholds.\n-     */\n-    protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n-                                              final double defaultAbsoluteAccuracy) {\n-        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n-        resultComputed = false;\n-        setMaxEvaluations(Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Default constructor.\n-     * To be removed once the single non-default one has been removed.\n-     */\n-    protected AbstractUnivariateRealOptimizer() {}\n-\n-    /**\n-     * Check whether a result has been computed.\n-     * @throws NoDataException if no result has been computed\n-     * @deprecated in 2.2 (no alternative).\n-     */\n-    protected void checkResultComputed() {\n-        if (!resultComputed) {\n-            throw new NoDataException();\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        if (!resultComputed) {\n-            throw new NoDataException();\n-        }\n-        return result;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getFunctionValue() {\n-        if (functionValue == Double.NaN) {\n-            final double opt = getResult();\n-            try {\n-                functionValue = function.value(opt);\n-            } catch (FunctionEvaluationException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        return functionValue;\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     *\n-     * @param x the result to set\n-     * @param fx the result to set\n-     * @param iterationCount the iteration count to set\n-     * @deprecated in 2.2 (no alternative).\n-     */\n-    protected final void setResult(final double x, final double fx,\n-                                   final int iterationCount) {\n-        this.result         = x;\n-        this.functionValue  = fx;\n-        this.iterationCount = iterationCount;\n-        this.resultComputed = true;\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     * @deprecated in 2.2 (no alternative).\n-     */\n-    protected final void clearResult() {\n-        this.resultComputed = false;\n-    }\n-\n     /** {@inheritDoc} */\n     public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n+        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n     public int getMaxEvaluations() {\n-        return maxEvaluations;\n+        return evaluations.getMaximalCount();\n     }\n \n     /** {@inheritDoc} */\n     public int getEvaluations() {\n-        return evaluations;\n+        return evaluations.getCount();\n     }\n \n     /**\n      * @return the optimization type.\n      */\n     public GoalType getGoalType() {\n-        return optimizationGoal;\n+        return goal;\n     }\n     /**\n-     * @return the lower of the search interval.\n+     * @return the lower end of the search interval.\n      */\n     public double getMin() {\n         return searchMin;\n     }\n     /**\n-     * @return the higher of the search interval.\n+     * @return the higher end of the search interval.\n      */\n     public double getMax() {\n         return searchMax;\n \n     /**\n      * Compute the objective function value.\n-     * @param f objective function\n-     * @param point point at which the objective function must be evaluated\n-     * @return objective function value at specified point\n-     * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or the maximal number of iterations is exceeded\n-     * @deprecated in 2.2. Use this {@link #computeObjectiveValue(double)\n-     * replacement} instead.\n-     */\n-    protected double computeObjectiveValue(final UnivariateRealFunction f,\n-                                           final double point)\n-        throws FunctionEvaluationException {\n-        if (++evaluations > maxEvaluations) {\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  point);\n-        }\n-        return f.value(point);\n-    }\n-\n-    /**\n-     * Compute the objective function value.\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at specified point.\n-     * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or the maximal number of iterations is exceeded.\n+     * @throws FunctionEvaluationException if the function cannot be\n+     * evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n      */\n     protected double computeObjectiveValue(double point)\n         throws FunctionEvaluationException {\n-        if (++evaluations > maxEvaluations) {\n-            resultComputed = false;\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  point);\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n         }\n         return function.value(point);\n     }\n \n     /** {@inheritDoc} */\n-    public double optimize(UnivariateRealFunction f, GoalType goal,\n-                           double min, double max, double startValue)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        // Initialize.\n-        this.searchMin = min;\n-        this.searchMax = max;\n-        this.searchStart = startValue;\n-        this.optimizationGoal = goal;\n-        this.function = f;\n-\n+    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n+                                                 GoalType goalType,\n+                                                 double min, double max,\n+                                                 double startValue)\n+        throws FunctionEvaluationException {\n         // Reset.\n-        functionValue = Double.NaN;\n-        evaluations = 0;\n-        resetIterationsCounter();\n+        searchMin = min;\n+        searchMax = max;\n+        searchStart = startValue;\n+        goal = goalType;\n+        function = f;\n+        evaluations.resetCount();\n \n         // Perform computation.\n-        result = doOptimize();\n-        resultComputed = true;\n+        return doOptimize();\n+    }\n \n-        return result;\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n+                                                 GoalType goal,\n+                                                 double min, double max)\n+        throws FunctionEvaluationException {\n+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /**\n-     * Set the value at the optimum.\n-     *\n-     * @param functionValue Value of the objective function at the optimum.\n+     * {@inheritDoc}\n      */\n-    protected void setFunctionValue(double functionValue) {\n-        this.functionValue = functionValue;\n+    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        this.checker = checker;\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(UnivariateRealFunction f, GoalType goal,\n-                           double min, double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+        return checker;\n     }\n \n     /**\n      * Method for implementing actual optimization algorithms in derived\n      * classes.\n      *\n-     * @return the optimum.\n-     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * @return the optimum and its corresponding function value.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n      */\n-    protected abstract double doOptimize()\n-        throws MaxIterationsExceededException, FunctionEvaluationException;\n+    protected abstract UnivariateRealPointValuePair doOptimize()\n+        throws FunctionEvaluationException;\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.BaseOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface BaseUnivariateRealOptimizer<FUNC extends UnivariateRealFunction>\n+    extends BaseOptimizer<UnivariateRealPointValuePair> {\n+    /**\n+     * Find an optimum in the given interval.\n+     *\n+     * An optimizer may require that the interval brackets a single optimum.\n+     *\n+     * @param f Function to optimize.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @return a (point, value) pair where the function is optimum.\n+     * @throws {@link org.apache.commons.math.exception.TooManyEvaluationsException}\n+     * if the maximum evaluation count is exceeded.\n+     * @throws {@link org.apache.commons.math.exception.ConvergenceException}\n+     * if the optimizer detects a convergence problem.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function.\n+     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n+     * do not satisfy the requirements specified by the optimizer.\n+     */\n+    UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n+                                          double min, double max)\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * Find an optimum in the given interval, start at startValue.\n+     * An optimizer may require that the interval brackets a single optimum.\n+     *\n+     * @param f Function to optimize.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @return a (point, value) pair where the function is optimum.\n+     * @throws {@link org.apache.commons.math.exception.TooManyEvaluationsException}\n+     * if the maximum evaluation count is exceeded.\n+     * @throws {@link org.apache.commons.math.exception.ConvergenceException}\n+     * if the optimizer detects a convergence problem.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function.\n+     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n+     * do not satisfy the requirements specified by the optimizer.\n+     */\n+    UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n+                                          double min, double max,\n+                                          double startValue)\n+        throws FunctionEvaluationException;\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n+import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n  * Provide an interval that brackets a local optimum of a function.\n  * This code is based on a Python implementation (from <em>SciPy</em>,\n  * module {@code optimize.py} v0.5).\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.2\n  */\n      */\n     private final double growLimit;\n     /**\n-     * Maximum number of iterations.\n-     */\n-    private final int maxIterations;\n-    /**\n-     * Number of iterations.\n-     */\n-    private int iterations;\n-    /**\n-     * Number of function evaluations.\n-     */\n-    private int evaluations;\n+     * Counter for function evaluations.\n+     */\n+    private final Incrementor evaluations = new Incrementor();\n     /**\n      * Lower bound of the bracket.\n      */\n      * Create a bracketing interval finder.\n      *\n      * @param growLimit Expanding factor.\n-     * @param maxIterations Maximum number of iterations allowed for finding\n+     * @param maxEvaluations Maximum number of evaluations allowed for finding\n      * a bracketing interval.\n      */\n     public BracketFinder(double growLimit,\n-                         int maxIterations) {\n+                         int maxEvaluations) {\n         if (growLimit <= 0) {\n             throw new NotStrictlyPositiveException(growLimit);\n         }\n-        if (maxIterations <= 0) {\n-            throw new NotStrictlyPositiveException(maxIterations);\n+        if (maxEvaluations <= 0) {\n+            throw new NotStrictlyPositiveException(maxEvaluations);\n         }\n \n         this.growLimit = growLimit;\n-        this.maxIterations = maxIterations;\n+        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /**\n      * @param goal {@link GoalType Goal type}.\n      * @param xA Initial point.\n      * @param xB Initial point.\n-     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * @throws TooManyEvaluationsException if the maximum number of evaluations\n      * is exceeded.\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n                        GoalType goal,\n                        double xA,\n                        double xB)\n-        throws MaxIterationsExceededException,\n-               FunctionEvaluationException {\n-        reset();\n+        throws FunctionEvaluationException {\n+        evaluations.resetCount();\n         final boolean isMinim = goal == GoalType.MINIMIZE;\n \n         double fA = eval(func, xA);\n         if (isMinim ?\n             fA < fB :\n             fA > fB) {\n+\n             double tmp = xA;\n             xA = xB;\n             xB = tmp;\n         double fC = eval(func, xC);\n \n         while (isMinim ? fC < fB : fC > fB) {\n-            if (++iterations > maxIterations) {\n-                throw new MaxIterationsExceededException(maxIterations);\n-            }\n-\n             double tmp1 = (xB - xA) * (fB - fC);\n             double tmp2 = (xB - xC) * (fB - fA);\n \n                     fW > fC) {\n                     xB = xC;\n                     xC = w;\n-                    w = xC + GOLD * (xC -xB);\n+                    w = xC + GOLD * (xC - xB);\n                     fB = fC;\n                     fC =fW;\n                     fW = eval(func, w);\n             }\n \n             xA = xB;\n+            fA = fB;\n             xB = xC;\n+            fB = fC;\n             xC = w;\n-            fA = fB;\n-            fB = fC;\n             fC = fW;\n         }\n \n         lo = xA;\n+        fLo = fA;\n         mid = xB;\n+        fMid = fB;\n         hi = xC;\n-        fLo = fA;\n-        fMid = fB;\n         fHi = fC;\n-    }\n-\n-    /**\n-     * @return the number of iterations.\n-     */\n-    public int getIterations() {\n-        return iterations;\n-    }\n+\n+        if (lo > hi) {\n+            double tmp = lo;\n+            lo = hi;\n+            hi = tmp;\n+\n+            tmp = fLo;\n+            fLo = fHi;\n+            fHi = tmp;\n+        }\n+    }\n+\n     /**\n      * @return the number of evalutations.\n      */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /**\n+     * @return the number of evalutations.\n+     */\n     public int getEvaluations() {\n-        return evaluations;\n+        return evaluations.getCount();\n     }\n \n     /**\n      * @return the lower bound of the bracket.\n-     * @see #getFLow()\n+     * @see #getFLo()\n      */\n     public double getLo() {\n         return lo;\n      * Get function value at {@link #getLo()}.\n      * @return function value at {@link #getLo()}\n      */\n-    public double getFLow() {\n+    public double getFLo() {\n         return fLo;\n     }\n \n      * @param f Function.\n      * @param x Argument.\n      * @return {@code f(x)}\n-     * @throws FunctionEvaluationException if function cannot be evaluated at x\n+     * @throws FunctionEvaluationException if function cannot be evaluated.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n+     * exceeded.\n      */\n     private double eval(UnivariateRealFunction f,\n                         double x)\n         throws FunctionEvaluationException {\n-\n-        ++evaluations;\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n         return f.value(x);\n     }\n-\n-    /**\n-     * Reset internal state.\n-     */\n-    private void reset() {\n-        iterations = 0;\n-        evaluations = 0;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.AbstractConvergenceChecker;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n  * univariate functions. This implementation is an adaptation partly\n  * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n+ * If the function is defined on some interval {@code (lo, hi)}, then\n+ * this method finds an approximation {@code x} to the point at which\n+ * the function attains its minimum.\n+ * <br/>\n+ * The user is responsible for calling {@link\n+ * #setConvergenceChecker(ConvergenceChecker) ConvergenceChecker}\n+ * prior to using the optimizer.\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n     private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n \n     /**\n-     * Construct a solver.\n+     * Convergence checker that implements the original stopping criterion\n+     * of Brent's algorithm.\n+     * {@code abs} and {@code rel} define a tolerance\n+     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n+     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n+     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n+     * be positive.\n+     *\n+     * @since 3.0\n      */\n-    public BrentOptimizer() {\n-        setMaxEvaluations(1000);\n-        setMaximalIterationCount(100);\n-        setAbsoluteAccuracy(1e-11);\n-        setRelativeAccuracy(1e-9);\n+    public static class BrentConvergenceChecker\n+        extends AbstractConvergenceChecker<UnivariateRealPointValuePair> {\n+        /**\n+         * Minimum relative tolerance.\n+         */\n+        private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n+\n+        /**\n+         * Build an instance with specified thresholds.\n+         *\n+         * @param rel Relative tolerance threshold\n+         * @param abs Absolute tolerance threshold\n+         */\n+        public BrentConvergenceChecker(final double rel,\n+                                       final double abs) {\n+            super(rel, abs);\n+            \n+            if (rel < MIN_RELATIVE_TOLERANCE) {\n+                throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n+            }\n+            if (abs <= 0) {\n+                throw new NotStrictlyPositiveException(abs);\n+            }\n+        }\n+\n+        /**\n+         * Convergence criterion.\n+         *\n+         * @param iteration Current iteration.\n+         * @param points Points used for checking the stopping criterion. The list\n+         * must contain 3 points (in the following order):\n+         * <ul>\n+         *  <li>the lower end of the current interval</li>\n+         *  <li>the current best point</li>\n+         *  <li>the higher end of the current interval</li>\n+         * </ul>\n+         * @return {@code true} if the stopping criterion is satisfied.\n+         * @throws DimensionMismatchException if the length of the {@code points}\n+         * list is not equal to 3.\n+         */\n+        public boolean converged(final int iteration,\n+                                 final UnivariateRealPointValuePair ... points) {\n+            if (points.length != 3) {\n+                throw new DimensionMismatchException(points.length, 3);\n+            }\n+            \n+            final double a = points[0].getPoint();\n+            final double x = points[1].getPoint();\n+            final double b = points[2].getPoint();\n+            \n+            final double tol1 = getRelativeThreshold() * FastMath.abs(x) + getAbsoluteThreshold();\n+            final double tol2 = 2 * tol1;\n+            \n+            final double m = 0.5 * (a + b);\n+            return FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n+        }\n     }\n \n+    /**\n+     * Set the convergence checker.\n+     * Since this algorithm requires a specific checker, this method will throw\n+     * an {@code UnsupportedOperationexception} if the argument type is not\n+     * {@link BrentConvergenceChecker}.\n+     *\n+     * @throws MathUnsupportedOperationexception if the checker is not an\n+     * instance of {@link BrentConvergenceChecker}.\n+     */\n+    @Override\n+    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        if (checker instanceof BrentConvergenceChecker) {\n+            super.setConvergenceChecker(checker);\n+        } else {\n+            throw new MathUnsupportedOperationException();\n+        }\n+    }\n+\n     /** {@inheritDoc} */\n-    protected double doOptimize()\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return localMin(getGoalType() == GoalType.MINIMIZE,\n-                        getMin(), getStartValue(), getMax(),\n-                        getRelativeAccuracy(), getAbsoluteAccuracy());\n-    }\n-\n-    /**\n-     * Find the minimum of the function within the interval {@code (lo, hi)}.\n-     *\n-     * If the function is defined on the interval {@code (lo, hi)}, then\n-     * this method finds an approximation {@code x} to the point at which\n-     * the function attains its minimum.<br/>\n-     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n-     * and the function is never evaluated at two points closer together than\n-     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n-     * preferable not much less than <em>sqrt(macheps)</em>, where\n-     * <em>macheps</em> is the relative machine precision. {@code t} should be\n-     * positive.\n-     * @param isMinim {@code true} when minimizing the function.\n-     * @param lo Lower bound of the interval.\n-     * @param mid Point inside the interval {@code [lo, hi]}.\n-     * @param hi Higher bound of the interval.\n-     * @param eps Relative accuracy.\n-     * @param t Absolute accuracy.\n-     * @return the optimum point.\n-     * @throws MaxIterationsExceededException if the maximum iteration count\n-     * is exceeded.\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function.\n-     */\n-    private double localMin(boolean isMinim,\n-                            double lo, double mid, double hi,\n-                            double eps, double t)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        if (eps <= 0) {\n-            throw new NotStrictlyPositiveException(eps);\n-        }\n-        if (t <= 0) {\n-            throw new NotStrictlyPositiveException(t);\n-        }\n+    protected UnivariateRealPointValuePair doOptimize()\n+        throws FunctionEvaluationException {\n+        final boolean isMinim = (getGoalType() == GoalType.MINIMIZE);\n+        final double lo = getMin();\n+        final double mid = getStartValue();\n+        final double hi = getMax();\n+\n+        final ConvergenceChecker<UnivariateRealPointValuePair> checker\n+            = getConvergenceChecker();\n+        final double eps = checker.getRelativeThreshold();\n+        final double t = checker.getAbsoluteThreshold();\n+\n         double a;\n         double b;\n         if (lo < hi) {\n         double fv = fx;\n         double fw = fx;\n \n+        int iter = 0;\n         while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * FastMath.abs(x) + t;\n             final double tol2 = 2 * tol1;\n \n             // Check stopping criterion.\n-            if (FastMath.abs(x - m) > tol2 - 0.5 * (b - a)) {\n+            // This test will work only if the \"checker\" is an instance of\n+            // \"BrentOptimizer.BrentConvergenceChecker\".\n+            if (!getConvergenceChecker().converged(iter,\n+                                                   new UnivariateRealPointValuePair(a, Double.NaN),\n+                                                   new UnivariateRealPointValuePair(x, Double.NaN),\n+                                                   new UnivariateRealPointValuePair(b, Double.NaN))) {\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n                         fv = fu;\n                     }\n                 }\n-            } else { // termination\n-                setFunctionValue(isMinim ? fx : -fx);\n-                return x;\n-            }\n-            incrementIterationsCounter();\n+            } else { // Termination.\n+                return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+            }\n+            ++iter;\n         }\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Special implementation of the {@link UnivariateRealOptimizer} interface\n+ * adding multi-start features to an existing optimizer.\n+ *\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFunction>\n+    implements BaseUnivariateRealOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseUnivariateRealOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomGenerator generator;\n+    /** Found optima. */\n+    private UnivariateRealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random generator to use for restarts.\n+     */\n+    public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer,\n+                                             final int starts,\n+                                             final RandomGenerator generator) {\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+        optimizer.setMaxEvaluations(maxEvaluations);\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(FUNC,GoalType,double,double) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(FUNC,GoalType,double,double) optimize}\n+     * method returns the best point only. This method returns all the points\n+     * found at the end of each starts, including the best one already\n+     * returned by the {@link #optimize(FUNC,GoalType,double,double) optimize}\n+     * method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by {@code null} elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be {@code null} if the {@link\n+     * #optimize(FUNC,GoalType,double,double) optimize} method did throw a\n+     * {@link ConvergenceException}). This also means that if the first\n+     * element is not {@code null}, it is the best point found across all\n+     * starts.\n+     *\n+     * @return an array containing the optima.\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(FUNC,GoalType,double,double) optimize} has not been called.\n+     */\n+    public UnivariateRealPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(final FUNC f,\n+                                                 final GoalType goal,\n+                                                 final double min, final double max)\n+        throws FunctionEvaluationException {\n+\n+        optima = new UnivariateRealPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+            try {\n+                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n+                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal,\n+                                               FastMath.min(bound1, bound2),\n+                                               FastMath.max(bound1, bound2));\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (ConvergenceException ce) {\n+                optima[i] = null;\n+            }\n+\n+            final int usedEvaluations = optimizer.getEvaluations();\n+            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n+            totalEvaluations += usedEvaluations;\n+        }\n+\n+        sortPairs(goal);\n+\n+        if (optima[0] == null) {\n+            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n+                                           starts);\n+        }\n+\n+        // Return the point with the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType,\n+                                                 final double min, final double max,\n+                                                 final double startValue)\n+            throws FunctionEvaluationException {\n+        // XXX Main code should be here, using \"startValue\" for the first start.\n+        // XXX This method should set \"startValue\" to min + 0.5 * (max - min)\n+        return optimize(f, goalType, min, max);\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param goal Goal type.\n+     */\n+    private void sortPairs(final GoalType goal) {\n+        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n+                public int compare(final UnivariateRealPointValuePair o1,\n+                                   final UnivariateRealPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goal == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            });\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Interface for univariate optimization algorithms.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface UnivariateRealOptimizer \n+    extends BaseUnivariateRealOptimizer<UnivariateRealFunction> {}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class holds a point and the value of an objective function at this\n+ * point.\n+ * This is a simple immutable container.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class UnivariateRealPointValuePair implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+    /** Point. */\n+    private final double point;\n+    /** Value of the objective function at the point. */\n+    private final double value;\n+\n+    /**\n+     * Build a point/objective function value pair.\n+     *\n+     * @param point Point.\n+     * @param value Value of an objective function at the point\n+     */\n+    public UnivariateRealPointValuePair(final double point,\n+                                        final double value) {\n+        this.point = point;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Get the point.\n+     *\n+     * @return the point.\n+     */\n+    public double getPoint() {\n+        return point;\n+    }\n+\n+    /**\n+     * Get the value of the objective function.\n+     *\n+     * @return the stored value of the objective function.\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n \n     @Test\n-    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n                                                   new GaussianRandomGenerator(g));\n         MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n-        optimizer.setMaxIterations(100);\n-        assertEquals(100, optimizer.getMaxIterations());\n         optimizer.setMaxEvaluations(100);\n         assertEquals(100, optimizer.getMaxEvaluations());\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n         BrentSolver solver = new BrentSolver();\n-        solver.setAbsoluteAccuracy(1.0e-13);\n-        solver.setRelativeAccuracy(1.0e-15);\n         RealPointValuePair optimum =\n             optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         RealPointValuePair[] optima = optimizer.getOptima();\n             assertEquals(96.075902096, center.x, 1.0e-8);\n             assertEquals(48.135167894, center.y, 1.0e-8);\n         }\n-        assertTrue(optimizer.getGradientEvaluations() > 650);\n-        assertTrue(optimizer.getGradientEvaluations() < 700);\n         assertTrue(optimizer.getEvaluations() > 70);\n         assertTrue(optimizer.getEvaluations() < 90);\n-        assertTrue(optimizer.getIterations() > 70);\n-        assertTrue(optimizer.getIterations() < 90);\n         assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n     }\n \n             dJdY *= 2;\n \n             return new double[] { dJdX, dJdY };\n-\n         }\n \n         public double value(double[] variables)\n                 double di = point.distance(center) - radius;\n                 sum += di * di;\n             }\n-\n             return sum;\n-\n         }\n \n         public MultivariateVectorialFunction gradient() {\n                 }\n             };\n         }\n-\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n import java.io.Serializable;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n         // no optima before first optimization attempt\n         }\n         assertTrue(optimizer.getEvaluations() > 20);\n         assertTrue(optimizer.getEvaluations() < 50);\n-        assertTrue(optimizer.getIterations() > 20);\n-        assertTrue(optimizer.getIterations() < 50);\n-        assertTrue(optimizer.getJacobianEvaluations() > 20);\n-        assertTrue(optimizer.getJacobianEvaluations() < 50);\n-        assertEquals(100, optimizer.getMaxIterations());\n+        assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n-    @Test(expected = OptimizationException.class)\n+    @Test(expected = ConvergenceException.class)\n     public void testNoOptimum() throws FunctionEvaluationException, OptimizationException {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true);\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         optimizer.optimize(new DifferentiableMultivariateVectorialFunction() {\n                 public MultivariateMatrixFunction jacobian() {\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n     MultiStartMultivariateRealOptimizer optimizer =\n         new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxIterations(100);\n+    optimizer.setMaxEvaluations(1100);\n     RealPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n     assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 20);\n-    assertTrue(optimizer.getEvaluations() < 250);\n+    assertTrue(optimizer.getEvaluations() > 900);\n+    assertTrue(optimizer.getEvaluations() < 1200);\n     assertTrue(optimum.getValue() < 8.0e-4);\n \n   }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n \n       MultiDirectional optimizer = new MultiDirectional();\n       optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n-      optimizer.setMaxIterations(200);\n+      optimizer.setMaxEvaluations(200);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n       RealPointValuePair optimum;\n \n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxIterations(100);\n+    optimizer.setMaxEvaluations(100);\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n-    optimizer.setMaxIterations(1000);\n+    optimizer.setMaxEvaluations(1000);\n     RealPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     Assert.assertEquals(count, optimizer.getEvaluations());\n       // fails because MultiDirectional.iterateSimplex is looping forever\n       // the while(true) should be replaced with a convergence check\n       MultiDirectional multiDirectional = new MultiDirectional();\n-      multiDirectional.setMaxIterations(100);\n       multiDirectional.setMaxEvaluations(1000);\n \n       final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n--- a/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MaxEvaluationsExceededException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.LeastSquaresConverter;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleRealPointChecker;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n-import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class NelderMeadTest {\n-\n-  @Test\n-  public void testFunctionEvaluationExceptions() {\n-      MultivariateRealFunction wrong =\n-          new MultivariateRealFunction() {\n-            private static final long serialVersionUID = 4751314470965489371L;\n-            public double value(double[] x) throws FunctionEvaluationException {\n-                if (x[0] < 0) {\n-                    throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n-                } else if (x[0] > 1) {\n-                    throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n-                } else {\n-                    return x[0] * (1 - x[0]);\n-                }\n-            }\n-      };\n-      try {\n-          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n-          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n-          fail(\"an exception should have been thrown\");\n-      } catch (FunctionEvaluationException ce) {\n-          // expected behavior\n-          assertNull(ce.getCause());\n-      } catch (Exception e) {\n-          fail(\"wrong exception caught: \" + e.getMessage());\n-      }\n-      try {\n-          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n-          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n-          fail(\"an exception should have been thrown\");\n-      } catch (FunctionEvaluationException ce) {\n-          // expected behavior\n-          assertNotNull(ce.getCause());\n-      } catch (Exception e) {\n-          fail(\"wrong exception caught: \" + e.getMessage());\n-      }\n-  }\n-\n-  @Test\n-  public void testMinimizeMaximize()\n-      throws FunctionEvaluationException, ConvergenceException {\n-\n-      // the following function has 4 local extrema:\n-      final double xM        = -3.841947088256863675365;\n-      final double yM        = -1.391745200270734924416;\n-      final double xP        =  0.2286682237349059125691;\n-      final double yP        = -yM;\n-      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n-      final double valueXmYp = -valueXmYm;                // local  minimum\n-      final double valueXpYm = -0.7290400707055187115322; // global minimum\n-      final double valueXpYp = -valueXpYm;                // global maximum\n-      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n-          private static final long serialVersionUID = -7039124064449091152L;\n-          public double value(double[] variables) throws FunctionEvaluationException {\n-              final double x = variables[0];\n-              final double y = variables[1];\n-              return ((x == 0) || (y == 0)) ? 0 : (FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y));\n-          }\n-      };\n-\n-      NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n-      optimizer.setMaxIterations(100);\n-      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n-      RealPointValuePair optimum;\n-\n-      // minimization\n-      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n-      assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);\n-      assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);\n-      assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 90);\n-\n-      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n-      assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);\n-      assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);\n-      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 90);\n-\n-      // maximization\n-      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n-      assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);\n-      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n-      assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 90);\n-\n-      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n-      assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);\n-      assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);\n-      assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 90);\n-\n-  }\n-\n-  @Test\n-  public void testRosenbrock()\n-    throws FunctionEvaluationException, ConvergenceException {\n-\n-    Rosenbrock rosenbrock = new Rosenbrock();\n-    NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxIterations(100);\n-    optimizer.setStartConfiguration(new double[][] {\n-            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n-    });\n-    RealPointValuePair optimum =\n-        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n-\n-    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 40);\n-    assertTrue(optimizer.getEvaluations() < 50);\n-    assertTrue(optimum.getValue() < 8.0e-4);\n-\n-  }\n-\n-  @Test\n-  public void testPowell()\n-    throws FunctionEvaluationException, ConvergenceException {\n-\n-    Powell powell = new Powell();\n-    NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n-    optimizer.setMaxIterations(200);\n-    RealPointValuePair optimum =\n-      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-    assertEquals(powell.getCount(), optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 110);\n-    assertTrue(optimizer.getEvaluations() < 130);\n-    assertTrue(optimum.getValue() < 2.0e-3);\n-\n-  }\n-\n-  @Test\n-  public void testLeastSquares1()\n-  throws FunctionEvaluationException, ConvergenceException {\n-\n-      final RealMatrix factors =\n-          new Array2DRowRealMatrix(new double[][] {\n-              { 1.0, 0.0 },\n-              { 0.0, 1.0 }\n-          }, false);\n-      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n-          public double[] value(double[] variables) {\n-              return factors.operate(variables);\n-          }\n-      }, new double[] { 2.0, -3.0 });\n-      NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n-      optimizer.setMaxIterations(200);\n-      RealPointValuePair optimum =\n-          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n-      assertEquals( 2.0, optimum.getPointRef()[0], 3.0e-5);\n-      assertEquals(-3.0, optimum.getPointRef()[1], 4.0e-4);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 80);\n-      assertTrue(optimum.getValue() < 1.0e-6);\n-  }\n-\n-  @Test\n-  public void testLeastSquares2()\n-  throws FunctionEvaluationException, ConvergenceException {\n-\n-      final RealMatrix factors =\n-          new Array2DRowRealMatrix(new double[][] {\n-              { 1.0, 0.0 },\n-              { 0.0, 1.0 }\n-          }, false);\n-      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n-          public double[] value(double[] variables) {\n-              return factors.operate(variables);\n-          }\n-      }, new double[] { 2.0, -3.0 }, new double[] { 10.0, 0.1 });\n-      NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n-      optimizer.setMaxIterations(200);\n-      RealPointValuePair optimum =\n-          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n-      assertEquals( 2.0, optimum.getPointRef()[0], 5.0e-5);\n-      assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 80);\n-      assertTrue(optimum.getValue() < 1.0e-6);\n-  }\n-\n-  @Test\n-  public void testLeastSquares3()\n-  throws FunctionEvaluationException, ConvergenceException {\n-\n-      final RealMatrix factors =\n-          new Array2DRowRealMatrix(new double[][] {\n-              { 1.0, 0.0 },\n-              { 0.0, 1.0 }\n-          }, false);\n-      LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n-          public double[] value(double[] variables) {\n-              return factors.operate(variables);\n-          }\n-      }, new double[] { 2.0, -3.0 }, new Array2DRowRealMatrix(new double [][] {\n-          { 1.0, 1.2 }, { 1.2, 2.0 }\n-      }));\n-      NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n-      optimizer.setMaxIterations(200);\n-      RealPointValuePair optimum =\n-          optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n-      assertEquals( 2.0, optimum.getPointRef()[0], 2.0e-3);\n-      assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n-      assertTrue(optimizer.getEvaluations() > 60);\n-      assertTrue(optimizer.getEvaluations() < 80);\n-      assertTrue(optimum.getValue() < 1.0e-6);\n-  }\n-\n-  @Test(expected = MaxIterationsExceededException.class)\n-  public void testMaxIterations() throws MathException {\n-      try {\n-          Powell powell = new Powell();\n-          NelderMead optimizer = new NelderMead();\n-          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n-          optimizer.setMaxIterations(20);\n-          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-      } catch (OptimizationException oe) {\n-          if (oe.getCause() instanceof ConvergenceException) {\n-              throw (ConvergenceException) oe.getCause();\n-          }\n-          throw oe;\n-      }\n-  }\n-\n-  @Test(expected = MaxEvaluationsExceededException.class)\n-  public void testMaxEvaluations() throws MathException {\n-      try {\n-          Powell powell = new Powell();\n-          NelderMead optimizer = new NelderMead();\n-          optimizer.setConvergenceChecker(new SimpleRealPointChecker(-1.0, 1.0e-3));\n-          optimizer.setMaxEvaluations(20);\n-          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-      } catch (FunctionEvaluationException fee) {\n-          if (fee.getCause() instanceof ConvergenceException) {\n-              throw (ConvergenceException) fee.getCause();\n-          }\n-          throw fee;\n-      }\n-  }\n-\n-  private static class Rosenbrock implements MultivariateRealFunction {\n-\n-      private int count;\n-\n-      public Rosenbrock() {\n-          count = 0;\n-      }\n-\n-      public double value(double[] x) throws FunctionEvaluationException {\n-          ++count;\n-          double a = x[1] - x[0] * x[0];\n-          double b = 1.0 - x[0];\n-          return 100 * a * a + b * b;\n-      }\n-\n-      public int getCount() {\n-          return count;\n-      }\n-\n-  }\n-\n-  private static class Powell implements MultivariateRealFunction {\n-\n-      private int count;\n-\n-      public Powell() {\n-          count = 0;\n-      }\n-\n-      public double value(double[] x) throws FunctionEvaluationException {\n-          ++count;\n-          double a = x[0] + 10 * x[1];\n-          double b = x[2] - x[3];\n-          double c = x[1] - 2 * x[2];\n-          double d = x[0] - x[3];\n-          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n-      }\n-\n-      public int getCount() {\n-          return count;\n-      }\n-\n-  }\n-\n+    @Test\n+    public void testFunctionEvaluationExceptions() {\n+        MultivariateRealFunction wrong =\n+            new MultivariateRealFunction() {\n+                private static final long serialVersionUID = 4751314470965489371L;\n+                public double value(double[] x) throws FunctionEvaluationException {\n+                    if (x[0] < 0) {\n+                        throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n+                    } else if (x[0] > 1) {\n+                        throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n+                    } else {\n+                        return x[0] * (1 - x[0]);\n+                    }\n+                }\n+            };\n+        try {\n+            NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+            optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException ce) {\n+            // expected behavior\n+            assertNull(ce.getCause());\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+        try {\n+            NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+            optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException ce) {\n+            // expected behavior\n+            assertNotNull(ce.getCause());\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testMinimizeMaximize()\n+        throws FunctionEvaluationException {\n+\n+        // the following function has 4 local extrema:\n+        final double xM        = -3.841947088256863675365;\n+        final double yM        = -1.391745200270734924416;\n+        final double xP        =  0.2286682237349059125691;\n+        final double yP        = -yM;\n+        final double valueXmYm =  0.2373295333134216789769; // local  maximum\n+        final double valueXmYp = -valueXmYm;                // local  minimum\n+        final double valueXpYm = -0.7290400707055187115322; // global minimum\n+        final double valueXpYp = -valueXpYm;                // global maximum\n+        MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n+                private static final long serialVersionUID = -7039124064449091152L;\n+                public double value(double[] variables) throws FunctionEvaluationException {\n+                    final double x = variables[0];\n+                    final double y = variables[1];\n+                    return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+                }\n+            };\n+\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+        optimizer.setMaxEvaluations(100);\n+        optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n+        RealPointValuePair optimum;\n+\n+        // minimization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n+        assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);\n+        assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);\n+        assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n+        assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);\n+        assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);\n+        assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // maximization\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+        assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);\n+        assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+        assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+\n+        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n+        assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);\n+        assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);\n+        assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+    }\n+\n+    @Test\n+    public void testRosenbrock()\n+        throws FunctionEvaluationException {\n+\n+        Rosenbrock rosenbrock = new Rosenbrock();\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+        optimizer.setMaxEvaluations(100);\n+        optimizer.setStartConfiguration(new double[][] {\n+                { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+            });\n+        RealPointValuePair optimum =\n+            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        assertTrue(optimizer.getEvaluations() > 40);\n+        assertTrue(optimizer.getEvaluations() < 50);\n+        assertTrue(optimum.getValue() < 8.0e-4);\n+    }\n+\n+    @Test\n+    public void testPowell()\n+        throws FunctionEvaluationException {\n+\n+        Powell powell = new Powell();\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+        optimizer.setMaxEvaluations(200);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+        assertEquals(powell.getCount(), optimizer.getEvaluations());\n+        assertTrue(optimizer.getEvaluations() > 110);\n+        assertTrue(optimizer.getEvaluations() < 130);\n+        assertTrue(optimum.getValue() < 2.0e-3);\n+    }\n+\n+    @Test\n+    public void testLeastSquares1()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1.0, 0.0 },\n+                    { 0.0, 1.0 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2.0, -3.0 });\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+        optimizer.setMaxEvaluations(200);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+        assertEquals( 2.0, optimum.getPointRef()[0], 3.0e-5);\n+        assertEquals(-3.0, optimum.getPointRef()[1], 4.0e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1.0e-6);\n+    }\n+\n+    @Test\n+    public void testLeastSquares2()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1.0, 0.0 },\n+                    { 0.0, 1.0 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2.0, -3.0 }, new double[] { 10.0, 0.1 });\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+        optimizer.setMaxEvaluations(200);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+        assertEquals( 2.0, optimum.getPointRef()[0], 5.0e-5);\n+        assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1.0e-6);\n+    }\n+\n+    @Test\n+    public void testLeastSquares3()\n+        throws FunctionEvaluationException {\n+\n+        final RealMatrix factors =\n+            new Array2DRowRealMatrix(new double[][] {\n+                    { 1.0, 0.0 },\n+                    { 0.0, 1.0 }\n+                }, false);\n+        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {\n+                public double[] value(double[] variables) {\n+                    return factors.operate(variables);\n+                }\n+            }, new double[] { 2.0, -3.0 }, new Array2DRowRealMatrix(new double [][] {\n+                    { 1.0, 1.2 }, { 1.2, 2.0 }\n+                }));\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));\n+        optimizer.setMaxEvaluations(200);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });\n+        assertEquals( 2.0, optimum.getPointRef()[0], 2.0e-3);\n+        assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);\n+        assertTrue(optimizer.getEvaluations() > 60);\n+        assertTrue(optimizer.getEvaluations() < 80);\n+        assertTrue(optimum.getValue() < 1.0e-6);\n+    }\n+\n+    @Test(expected = TooManyEvaluationsException.class)\n+    public void testMaxIterations() throws FunctionEvaluationException {\n+        Powell powell = new Powell();\n+        NelderMead optimizer = new NelderMead();\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+        optimizer.setMaxEvaluations(20);\n+        optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    }\n+\n+    private static class Rosenbrock implements MultivariateRealFunction {\n+        private int count;\n+\n+        public Rosenbrock() {\n+            count = 0;\n+        }\n+\n+        public double value(double[] x) throws FunctionEvaluationException {\n+            ++count;\n+            double a = x[1] - x[0] * x[0];\n+            double b = 1.0 - x[0];\n+            return 100 * a * a + b * b;\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    private static class Powell implements MultivariateRealFunction {\n+        private int count;\n+\n+        public Powell() {\n+            count = 0;\n+        }\n+\n+        public double value(double[] x) throws FunctionEvaluationException {\n+            ++count;\n+            double a = x[0] + 10 * x[1];\n+            double b = x[2] - x[3];\n+            double c = x[1] - 2 * x[2];\n+            double d = x[0] - x[3];\n+            return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n import java.util.Random;\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n public class PolynomialFitterTest {\n \n     @Test\n-    public void testNoError() throws OptimizationException {\n+    public void testNoError() {\n         Random randomizer = new Random(64925784252l);\n         for (int degree = 1; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n     }\n \n     @Test\n-    public void testSmallError() throws OptimizationException {\n+    public void testSmallError() {\n         Random randomizer = new Random(53882150042l);\n         double maxError = 0;\n         for (int degree = 0; degree < 10; ++degree) {\n             try {\n                 fitter.fit();\n                 assertTrue(solvable || (degree == 0));\n-            } catch(OptimizationException e) {\n+            } catch(ConvergenceException e) {\n                 assertTrue((! solvable) && (degree > 0));\n             }\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialPointChecker;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+    public void testColumnsPermutation() throws FunctionEvaluationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n \n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+    public void testNoDependency() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n                 { 0, 0, 0, 0, 0, 2 }\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+    public void testOneSet() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n                 {  0, -1, 1 }\n         }, new double[] { 1, 1, 1});\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n \n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+    public void testTwoSets() throws FunctionEvaluationException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n             fail(\"an exception should have been caught\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n         }\n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+    public void testIllConditioned() throws FunctionEvaluationException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n                 {  7.0, 5.0,  9.0, 10.0 }\n         }, new double[] { 32, 23, 33, 31 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum1 =\n             optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 7, 6, 5, 4 });\n             fail(\"an exception should have been caught\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n             fail(\"an exception should have been caught\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n         }\n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testRedundantEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n \n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testInconsistentEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         assertTrue(optimizer.getRMS() > 0.1);\n \n     }\n \n-    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n+    public void testInconsistentSizes() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n         VectorialPointValuePair optimum =\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (OptimizationException oe) {\n+        } catch (DimensionMismatchException oe) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n \n     }\n \n-    public void testMaxIterations() {\n+    public void testMaxEvaluations() {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialPointChecker(1.0e-30, 1.0e-30));\n         try {\n             optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n             fail(\"an exception should have been caught\");\n-        } catch (OptimizationException ee) {\n+        } catch (TooManyEvaluationsException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n         }\n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n         assertEquals(48.135167894714,   center.y, 1.0e-10);\n     }\n \n-    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n             fail(\"an exception should have been caught\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         try {\n             optimizer.guessParametersErrors();\n             fail(\"an exception should have been thrown\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testQRColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+    public void testQRColumnsPermutation() throws FunctionEvaluationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+    public void testNoDependency() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+    public void testOneSet() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+    public void testTwoSets() throws FunctionEvaluationException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n \n     }\n \n-    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {\n+    public void testNonInversible() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         try {\n             optimizer.getCovariances();\n             fail(\"an exception should have been thrown\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n \n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+    public void testIllConditioned() throws FunctionEvaluationException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n \n     }\n \n-    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException, OptimizationException {\n+    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n \n     }\n \n-    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException, OptimizationException {\n+    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n \n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testRedundantEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testInconsistentEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n+    public void testInconsistentSizes() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (OptimizationException oe) {\n+        } catch (DimensionMismatchException oe) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         try {\n             LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n             optimizer.setInitialStepBoundFactor(initialStepBoundFactor);\n-            optimizer.setMaxIterations(maxCostEval);\n+            optimizer.setMaxEvaluations(maxCostEval);\n             optimizer.setCostRelativeTolerance(costRelativeTolerance);\n             optimizer.setParRelativeTolerance(parRelativeTolerance);\n             optimizer.setOrthoTolerance(orthoTolerance);\n             optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-            assertTrue(! shouldFail);\n-        } catch (OptimizationException ee) {\n+            assertTrue(!shouldFail);\n+        } catch (FunctionEvaluationException ee) {\n             assertTrue(shouldFail);\n-        } catch (FunctionEvaluationException ee) {\n+        } catch (TooManyEvaluationsException ee) {\n             assertTrue(shouldFail);\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n         }\n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n \n     }\n \n-    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n                                new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n                                new double[] { 0, 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (OptimizationException ee) {\n+        } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.FastMath;\n \n \n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n       LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-      optimizer.setMaxIterations(100 * (function.getN() + 1));\n+      optimizer.setMaxEvaluations(400 * (function.getN() + 1));\n       optimizer.setCostRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n       optimizer.setParRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n       optimizer.setOrthoTolerance(2.22044604926e-16);\n           assertFalse(exceptionExpected);\n           function.checkTheoreticalMinCost(optimizer.getRMS());\n           function.checkTheoreticalMinParams(optimum);\n-      } catch (OptimizationException lsse) {\n+      } catch (TooManyEvaluationsException e) {\n           assertTrue(exceptionExpected);\n       } catch (FunctionEvaluationException fe) {\n           assertTrue(exceptionExpected);\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         }, new double[] { 1, 1, 1});\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setPreconditioner(new Preconditioner() {\n             public double[] precondition(double[] point, double[] r) {\n                 double[] d = r.clone();\n         }, new double[] { 1, 1, 1 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n                 optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         }, new double[] { 32, 23, 33, 31 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n         BrentSolver solver = new BrentSolver();\n         solver.setAbsoluteAccuracy(1.0e-15);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxIterations(100);\n+        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));\n         BrentSolver solver = new BrentSolver();\n         solver.setAbsoluteAccuracy(1.0e-13);\n--- a/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i];\n         }\n-        // doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-7);\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i] + 3;\n         }\n-        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-7);\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n     }\n \n     @Test\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i];\n         }\n-        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-8);\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i] - 20;\n         }\n-        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-5, 1e-9, 1e-8);\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);\n     }\n \n     @Test\n         for (int i = 0; i < dim; i++) {\n             init[i] = maxPoint[i];\n         }\n-        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-5, 1e-9, 1e-8);\n+        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = maxPoint[i] - 20;\n         }\n-        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-5, 1e-9, 1e-8);\n+        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);\n     }\n \n     /**\n      * @param optimum Expected optimum.\n      * @param init Starting point.\n      * @param goal Minimization or maximization.\n-     * @param xTol Tolerance (relative error on the objective function) for\n-     * \"Brent\" line search algorithm used by \"Powell\".\n      * @param fTol Tolerance (relative error on the objective function) for\n      * \"Powell\" algorithm.\n      * @param pointTol Tolerance for checking that the optimum is correct.\n                         double[] optimum,\n                         double[] init,\n                         GoalType goal,\n-                        double xTol,\n                         double fTol,\n                         double pointTol)\n         throws MathException {\n-        final MultivariateRealOptimizer optim = new PowellOptimizer(xTol);\n-        optim.setConvergenceChecker(new SimpleScalarValueChecker(fTol, -1));\n+        final MultivariateRealOptimizer optim = new PowellOptimizer();\n+        optim.setMaxEvaluations(1000);\n+        optim.setConvergenceChecker(new SimpleScalarValueChecker(fTol, Math.ulp(1d)));\n \n         final RealPointValuePair result = optim.optimize(func, goal, init);\n         final double[] found = result.getPoint();\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n import org.junit.Assert;\n import org.junit.Test;\n \n+/**\n+ * Test for {@link BracketFinder}.\n+ */\n public class BracketFinderTest {\n \n     @Test\n         Assert.assertEquals(-1, bFind.getMid(), tol);\n         Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);\n     }\n+\n+    @Test\n+    public void testMinimumIsOnIntervalBoundary() throws MathException {\n+        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+                public double value(double x)\n+                    throws FunctionEvaluationException {\n+                    return x * x;\n+                }\n+            };\n+\n+        final BracketFinder bFind = new BracketFinder();\n+\n+        bFind.search(func, GoalType.MINIMIZE, 0, 1);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+\n+        bFind.search(func, GoalType.MINIMIZE, -1, 0);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+    }\n+\n+    @Test\n+    public void testIntervalBoundsOrdering() throws MathException {\n+        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+                public double value(double x)\n+                    throws FunctionEvaluationException {\n+                    return x * x;\n+                }\n+            };\n+\n+        final BracketFinder bFind = new BracketFinder();\n+\n+        bFind.search(func, GoalType.MINIMIZE, -1, 1);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+\n+        bFind.search(func, GoalType.MINIMIZE, 1, -1);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+\n+        bFind.search(func, GoalType.MINIMIZE, 1, 2);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+\n+        bFind.search(func, GoalType.MINIMIZE, 2, 1);\n+        Assert.assertTrue(bFind.getLo() <= 0);\n+        Assert.assertTrue(0 <= bFind.getHi());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n-import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n /**\n     @Test\n     public void testSinMin() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n-        minimizer.setMaxEvaluations(200);\n-        assertEquals(200, minimizer.getMaxEvaluations());\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n+        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        optimizer.setMaxEvaluations(200);\n+        assertEquals(200, optimizer.getMaxEvaluations());\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 4, 5).getPoint(),\n+                     100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertTrue(optimizer.getEvaluations() <= 50);\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 1, 5).getPoint(),\n+                     100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n+        assertTrue(optimizer.getEvaluations() <= 100);\n+        assertTrue(optimizer.getEvaluations() >= 15);\n+        optimizer.setMaxEvaluations(10);\n         try {\n-            minimizer.getResult();\n+            optimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n             fail(\"an exception should have been thrown\");\n-        } catch (NoDataException ise) {\n-            // expected\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        assertEquals(3 * FastMath.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n-        assertTrue(minimizer.getIterationCount() <= 50);\n-        assertEquals(3 * FastMath.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n-        assertTrue(minimizer.getIterationCount() <= 50);\n-        assertTrue(minimizer.getEvaluations()    <= 100);\n-        assertTrue(minimizer.getEvaluations()    >=  15);\n-        minimizer.setMaxEvaluations(10);\n-        try {\n-            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n-            fail(\"an exception should have been thrown\");\n-        } catch (FunctionEvaluationException fee) {\n+        } catch (TooManyEvaluationsException fee) {\n             // expected\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n     public void testQuinticMin() throws MathException {\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n-        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n-        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n-        assertTrue(minimizer.getIterationCount() <= 50);\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n+        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        optimizer.setMaxEvaluations(200);\n+        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n+        assertEquals( 0.82221643, optimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n+        assertTrue(optimizer.getEvaluations() <= 50);\n \n         // search in a large interval\n-        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n-        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);\n+        assertTrue(optimizer.getEvaluations() <= 50);\n     }\n \n     @Test\n     public void testQuinticMinStatistics() throws MathException {\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n-        minimizer.setRelativeAccuracy(1e-10);\n-        minimizer.setAbsoluteAccuracy(1e-11);\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n+        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-12, 1e-14));\n+        optimizer.setMaxEvaluations(40);\n \n-        final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n+        final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];\n         for (int i = 0; i < stat.length; i++) {\n             stat[i] = new DescriptiveStatistics();\n         }\n         final double delta = (max - min) / nSamples;\n         for (int i = 0; i < nSamples; i++) {\n             final double start = min + i * delta;\n-            stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n-            stat[1].addValue(minimizer.getIterationCount());\n-            stat[2].addValue(minimizer.getEvaluations());\n+            stat[0].addValue(optimizer.optimize(f, GoalType.MINIMIZE, min, max, start).getPoint());\n+            stat[1].addValue(optimizer.getEvaluations());\n         }\n \n         final double meanOptValue = stat[0].getMean();\n-        final double medianIter = stat[1].getPercentile(50);\n-        final double medianEval = stat[2].getPercentile(50);\n-        assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n-        assertEquals(medianIter, 17, FastMath.ulp(1d));\n-        assertEquals(medianEval, 18, FastMath.ulp(1d));\n+        final double medianEval = stat[1].getPercentile(50);\n+        assertTrue(meanOptValue > -0.2719561281 && meanOptValue < -0.2719561280);\n+        assertEquals((int) medianEval, 27);\n     }\n \n-    @Test\n+    @Test(expected = TooManyEvaluationsException.class)\n     public void testQuinticMax() throws MathException {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has a local maximum at 0.27195613.\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n-        assertEquals(0.27195613, minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3), 1.0e-8);\n-        minimizer.setMaximalIterationCount(5);\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n+        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-12, 1e-14));\n+        assertEquals(0.27195613, optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n+        optimizer.setMaxEvaluations(5);\n         try {\n-            minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n+            optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n             fail(\"an exception should have been thrown\");\n-        } catch (MaxIterationsExceededException miee) {\n+        } catch (TooManyEvaluationsException miee) {\n             // expected\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n     @Test\n     public void testMinEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealOptimizer solver = new BrentOptimizer();\n-\n-        solver.setRelativeAccuracy(1e-8);\n+        UnivariateRealOptimizer optimizer = new BrentOptimizer();\n+        optimizer.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-8, 1e-14));\n+        optimizer.setMaxEvaluations(50);\n \n         // endpoint is minimum\n-        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * FastMath.PI / 2, 5);\n-        assertEquals(3 * FastMath.PI / 2, result, 10 * solver.getRelativeAccuracy());\n+        double result = optimizer.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();\n+        assertEquals(3 * Math.PI / 2, result, 100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n \n-        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * FastMath.PI / 2);\n-        assertEquals(3 * FastMath.PI / 2, result, 10 * solver.getRelativeAccuracy());\n+        result = optimizer.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();\n+        assertEquals(3 * Math.PI / 2, result, 100 * optimizer.getConvergenceChecker().getRelativeThreshold());\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Test;\n+\n+public class MultiStartUnivariateRealOptimizerTest {\n+\n+    @Test\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        underlying.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-10, 1e-14));\n+        underlying.setMaxEvaluations(300);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(44428400075l);\n+        MultiStartUnivariateRealOptimizer optimizer =\n+            new MultiStartUnivariateRealOptimizer(underlying, 10, g);\n+        optimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n+        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        for (int i = 1; i < optima.length; ++i) {\n+            double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);\n+            assertTrue (FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n+            assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);\n+            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);\n+        }\n+        assertTrue(optimizer.getEvaluations() > 150);\n+        assertTrue(optimizer.getEvaluations() < 250);\n+    }\n+\n+    @Test\n+    public void testQuinticMin() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        underlying.setConvergenceChecker(new BrentOptimizer.BrentConvergenceChecker(1e-9, 1e-14));\n+        underlying.setMaxEvaluations(300);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(4312000053L);\n+        MultiStartUnivariateRealOptimizer optimizer =\n+            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n+\n+        UnivariateRealPointValuePair optimum\n+            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+        assertEquals(-0.2719561271, optimum.getPoint(), 1e-9);\n+        assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n+\n+        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        for (int i = 0; i < optima.length; ++i) {\n+            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n+        }\n+        assertTrue(optimizer.getEvaluations() >= 110);\n+        assertTrue(optimizer.getEvaluations() <= 150);\n+    }\n+}", "timestamp": 1283173582, "metainfo": ""}