{"sha": "6537e18ad189603e19615226e6aa1a9cdd154b8f", "log": "Fixed an error in events handling in ODE solvers. In some rare cases, events occurring close to a step start were handled without truncating the step, making them appear as is they occurred close to the step end JIRA: MATH-358  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n-                            loop = false;\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n+                            loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\n                             hNew = dt;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n-                            loop = false;\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n+                            loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\n                             hNew = dt;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n-                  loop = false;\n+                  // we cannot simply truncate the step, reject the current computation\n+                  // and let the loop compute another state with the truncated step.\n+                  // it is so small (much probably exactly 0 due to limited accuracy)\n+                  // that the code above would fail handling it.\n+                  // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n+                  loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // rejecting the step would lead to a too small next step, we accept it\n-                loop = false;\n+                // we cannot simply truncate the step, reject the current computation\n+                // and let the loop compute another state with the truncated step.\n+                // it is so small (much probably exactly 0 due to limited accuracy)\n+                // that the code above would fail handling it.\n+                // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n+                loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n     super(name);\n   }\n \n+  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n+      final double   t0     = 1878250320.0000029;\n+      final double   tEvent = 1878250379.9999986;\n+      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n+      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n+\n+          public int getDimension() {\n+              return k.length;\n+          }\n+\n+          public void computeDerivatives(double t, double[] y, double[] yDot) {\n+              for (int i = 0; i < y.length; ++i) {\n+                  yDot[i] = k[i] * y[i];\n+              }\n+          }\n+      };\n+\n+      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n+\n+      double[] y0   = new double[k.length];\n+      for (int i = 0; i < y0.length; ++i) {\n+          y0[i] = i + 1;\n+      }\n+      double[] y    = new double[k.length];\n+\n+      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n+      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n+      for (int i = 0; i < y.length; ++i) {\n+          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+      }\n+\n+      integrator.addEventHandler(new EventHandler() {\n+\n+          public void resetState(double t, double[] y) {\n+          }\n+\n+          public double g(double t, double[] y) {\n+              return t - tEvent;\n+          }\n+\n+          public int eventOccurred(double t, double[] y, boolean increasing) {\n+              Assert.assertEquals(tEvent, t, 5.0e-6);\n+              return CONTINUE;\n+          }\n+      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n+      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n+      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n+      for (int i = 0; i < y.length; ++i) {\n+          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+      }\n+\n+  }\n+\n   public void testSanityChecks() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n package org.apache.commons.math.ode.nonstiff;\n \n import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblem1;\n \n   public DormandPrince853IntegratorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n+      final double   t0     = 1878250320.0000029;\n+      final double   tEvent = 1878250379.9999986;\n+      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n+      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n+\n+          public int getDimension() {\n+              return k.length;\n+          }\n+\n+          public void computeDerivatives(double t, double[] y, double[] yDot) {\n+              for (int i = 0; i < y.length; ++i) {\n+                  yDot[i] = k[i] * y[i];\n+              }\n+          }\n+      };\n+\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n+                                                                             1.0e-10, 1.0e-10);\n+\n+      double[] y0   = new double[k.length];\n+      for (int i = 0; i < y0.length; ++i) {\n+          y0[i] = i + 1;\n+      }\n+      double[] y    = new double[k.length];\n+\n+      integrator.setInitialStepSize(60.0);\n+      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n+      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n+      for (int i = 0; i < y.length; ++i) {\n+          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+      }\n+\n+      integrator.setInitialStepSize(60.0);\n+      integrator.addEventHandler(new EventHandler() {\n+\n+          public void resetState(double t, double[] y) {\n+          }\n+\n+          public double g(double t, double[] y) {\n+              return t - tEvent;\n+          }\n+\n+          public int eventOccurred(double t, double[] y, boolean increasing) {\n+              Assert.assertEquals(tEvent, t, 5.0e-6);\n+              return CONTINUE;\n+          }\n+      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n+      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n+      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n+      for (int i = 0; i < y.length; ++i) {\n+          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+      }\n+\n   }\n \n   public void testDimensionCheck() {", "timestamp": 1269468711, "metainfo": ""}