{"sha": "0b5f157e93d941ccd9c6dd129032ef275dbb5224", "log": "Added method multiply(int) to FieldElement, and updated implementing classes and tests accordingly. Solves MATH-684.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/FieldElement.java\n+++ b/src/main/java/org/apache/commons/math/FieldElement.java\n      */\n     T subtract(T a);\n \n+    /** Compute n &times; this. Multiplication by an integer number is defined\n+     * as the following sum\n+     * <center>\n+     * n &times; this = &sum;<sub>i=1</sub><sup>n</sup> this.\n+     * </center>\n+     * @param n Number of times {@code this} must be added to itself.\n+     * @return A new element representing n &times; this.\n+     */\n+    T multiply(int n);\n+\n     /** Compute this &times; a.\n      * @param a element to multiply\n      * @return a new element representing this &times; a\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n \n     /**\n      * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n+     * interpreted as a integer number.\n+     *\n+     * @param  factor value to be multiplied by this {@code Complex}.\n+     * @return {@code this * factor}.\n+     * @see #multiply(Complex)\n+     */\n+    public Complex multiply(final int factor) {\n+        if (isNaN) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) ||\n+            Double.isInfinite(imaginary)) {\n+            return INF;\n+        }\n+        return createComplex(real * factor, imaginary * factor);\n+    }\n+\n+    /**\n+     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n      * interpreted as a real number.\n      *\n      * @param  factor value to be multiplied by this {@code Complex}.\n--- a/src/main/java/org/apache/commons/math/util/BigReal.java\n+++ b/src/main/java/org/apache/commons/math/util/BigReal.java\n     }\n \n     /** {@inheritDoc} */\n+    public BigReal multiply(final int n) {\n+        return new BigReal(d.multiply(new BigDecimal(n)));\n+    }\n+\n+    /** {@inheritDoc} */\n     public int compareTo(BigReal a) {\n         return d.compareTo(a.d);\n     }\n     public Field<BigReal> getField() {\n         return BigRealField.getInstance();\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n         Assert.assertTrue(Double.isNaN(x.add(z).getReal()));\n     }\n \n-    \n+\n     @Test\n     public void testScalarAdd() {\n         Complex x = new Complex(3.0, 4.0);\n     public void testScalarAddInf() {\n         Complex x = new Complex(1, 1);\n         double yDouble = Double.POSITIVE_INFINITY;\n-        \n+\n         Complex yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.add(yComplex), x.add(yDouble));\n \n         yDouble = Double.NEGATIVE_INFINITY;\n         yComplex = new Complex(yDouble);\n         TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0);\n-        \n+\n         x = new Complex(1, Double.NEGATIVE_INFINITY);\n         TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0);\n     }\n-    \n+\n     @Test\n     public void testScalarDivideZero() {\n         Complex x = new Complex(1,1);\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Complex.NaN);\n         Assert.assertSame(Complex.NaN, z);\n-    }\n-\n-    @Test\n-    public void testMultiplyInInf() {\n+        z = Complex.NaN.multiply(5);\n+        Assert.assertSame(Complex.NaN, z);\n+    }\n+\n+    @Test\n+    public void testMultiplyInfInf() {\n         // Assert.assertTrue(infInf.multiply(infInf).isNaN()); // MATH-620\n         Assert.assertTrue(infInf.multiply(infInf).isInfinite());\n     }\n         w = negInfNegInf.multiply(oneNaN);\n         Assert.assertTrue(Double.isNaN(w.getReal()));\n         Assert.assertTrue(Double.isNaN(w.getImaginary()));\n-        \n+\n         z = new Complex(1, neginf);\n         Assert.assertSame(Complex.INF, z.multiply(z));\n     }\n         double yDouble = 2.0;\n         Complex yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n+        int zInt = -5;\n+        Complex zComplex = new Complex(zInt);\n+        Assert.assertEquals(x.multiply(zComplex), x.multiply(zInt));\n     }\n \n     @Test\n         double yDouble = Double.POSITIVE_INFINITY;\n         Complex yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n-        \n+\n         yDouble = Double.NEGATIVE_INFINITY;\n         yComplex = new Complex(yDouble);\n         Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n         x = new Complex(neginf, 0);\n         Assert.assertTrue(Double.isNaN(x.subtract(z).getReal()));\n     }\n-    \n+\n     @Test\n     public void testScalarSubtract() {\n         Complex x = new Complex(3.0, 4.0);\n         Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));\n     }\n \n-    \n+\n     @Test\n     public void testEqualsNull() {\n         Complex x = new Complex(3.0, 4.0);\n         Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n         Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n     }\n-    \n+\n     @Test\n     public void testAcos() {\n         Complex z = new Complex(3, 4);\n--- a/src/test/java/org/apache/commons/math/util/BigRealTest.java\n+++ b/src/test/java/org/apache/commons/math/util/BigRealTest.java\n         BigReal a = new BigReal(\"1024.0\");\n         BigReal b = new BigReal(\"0.0009765625\");\n         Assert.assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);\n+        int n = 1024;\n+        Assert.assertEquals(1.0, b.multiply(n).doubleValue(), 1.0e-15);\n     }\n \n     @Test", "timestamp": 1317715925, "metainfo": ""}