{"sha": "a86a2771460679ff91c49e2c0c33b2fb65b7c40c", "log": "added a way to handle errors in user-defined switching functions previously, only the function evaluation could trigger errors, not the other functions of the interface  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SwitchException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered by {@link SwitchingFunction}\n+ * @version $Revision: 620312 $ $Date: 2008-02-10 20:28:59 +0100 (dim., 10 f\u00e9vr. 2008) $\n+ * @since 2.0\n+ */\n+public class SwitchException extends MathException {\n+\n+    /** Serialization UID. */\n+    private static final long serialVersionUID = -3662133702316614545L;\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public SwitchException(String specifier, Object[] parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public SwitchException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/SwitchState.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchState.java\n class SwitchState implements Serializable {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -7307007422156119622L;\n+    private static final long serialVersionUID = -7307007422156119622L;\n \n   /** Switching function. */\n   private SwitchingFunction function;\n   /** Maximal time interval between switching function checks. */\n   private double maxCheckInterval;\n \n-  /** Convergence threshold for event localisation. */\n+  /** Convergence threshold for event localization. */\n   private double convergence;\n \n-  /** Upper limit in the iteration count for event localisation. */\n+  /** Upper limit in the iteration count for event localization. */\n   private int maxIterationCount;\n \n   /** Time at the beginning of the step. */\n    * beginning of the step\n    * @param y0 array containing the current value of the state vector\n    * at the beginning of the step\n-   * @exception FunctionEvaluationException if the switching function\n+   * @exception SwitchException if the switching function\n    * value cannot be evaluated at the beginning of the step\n    */\n   public void reinitializeBegin(double t0, double[] y0)\n-    throws FunctionEvaluationException {\n+    throws SwitchException {\n     this.t0 = t0;\n     g0 = function.g(t0, y0);\n     g0Positive = (g0 >= 0);\n    * rejected)\n    * @exception DerivativeException if the interpolator fails to\n    * compute the function somewhere within the step\n-   * @exception FunctionEvaluationException if the switching function\n+   * @exception SwitchException if the switching function\n    * cannot be evaluated\n    * @exception ConvergenceException if an event cannot be located\n    */\n   public boolean evaluateStep(final StepInterpolator interpolator)\n-    throws DerivativeException, FunctionEvaluationException, ConvergenceException {\n+    throws DerivativeException, SwitchException, ConvergenceException {\n \n     try {\n \n                       interpolator.setInterpolatedTime(t);\n                       return function.g(t, interpolator.getInterpolatedState());\n                   } catch (DerivativeException e) {\n+                      throw new FunctionEvaluationException(t, e);\n+                  } catch (SwitchException e) {\n                       throw new FunctionEvaluationException(t, e);\n                   }\n               }\n \n     } catch (FunctionEvaluationException e) {\n      Throwable cause = e.getCause();\n-      if ((cause != null) && (cause instanceof DerivativeException)) {\n-        throw (DerivativeException) cause;\n-      }\n-      throw e;\n+     if ((cause != null) && (cause instanceof DerivativeException)) {\n+         throw (DerivativeException) cause;\n+     } else if ((cause != null) && (cause instanceof SwitchException)) {\n+         throw (SwitchException) cause;\n+     }\n+     throw new SwitchException(e);\n     }\n \n   }\n    * end of the step\n    * @param y array containing the current value of the state vector\n    * at the end of the step\n-   * @exception FunctionEvaluationException if the value of the switching\n+   * @exception SwitchException if the value of the switching\n    * function cannot be evaluated\n    */\n-  public void stepAccepted(double t, double[] y)\n-    throws FunctionEvaluationException {\n+  public void stepAccepted(double t, double[] y) throws SwitchException {\n \n     t0 = t;\n     g0 = function.g(t, y);\n    * @param y array were to put the desired state vector at the beginning\n    * of the next step\n    * @return true if the integrator should reset the derivatives too\n-   */\n-  public boolean reset(double t, double[] y) {\n+   * @exception SwitchException if the state cannot be reseted by the switching\n+   * function\n+   */\n+  public boolean reset(double t, double[] y) throws SwitchException {\n \n     if (! pendingEvent) {\n       return false;\n--- a/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n package org.apache.commons.math.ode;\n \n import java.io.Serializable;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n \n /** This interface represents a switching function.\n  *\n    * @param t current value of the independent <i>time</i> variable\n    * @param y array containing the current value of the state vector\n    * @return value of the g function\n-   * @exception FunctionEvaluationException if the value of the function\n-   * cannot be evaluated\n+   * @exception SwitchException if the switching function cannot be evaluated\n    */\n-  public double g(double t, double[] y) throws FunctionEvaluationException;\n+  public double g(double t, double[] y) throws SwitchException;\n \n   /** Handle an event and choose what to do next.\n \n    * @return indication of what the integrator should do next, this\n    * value must be one of {@link #STOP}, {@link #RESET_STATE},\n    * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+   * @exception SwitchException if the event occurrence triggers an error\n    */\n-  public int eventOccurred(double t, double[] y);\n+  public int eventOccurred(double t, double[] y) throws SwitchException;\n   \n   /** Reset the state prior to continue the integration.\n \n    * @param t current value of the independent <i>time</i> variable\n    * @param y array containing the current value of the state vector\n    * the new state should be put in the same array\n+   * @exception SwitchException if the state cannot be reseted\n    */\n-  public void resetState(double t, double[] y);\n+  public void resetState(double t, double[] y) throws SwitchException;\n \n }\n--- a/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n \n package org.apache.commons.math.ode;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n \n /** This class handles several {@link SwitchingFunction switching\n  * functions} during integration.\n \n       return first != null;\n \n-    } catch (FunctionEvaluationException fee) {\n-      throw new IntegratorException(fee);\n+    } catch (SwitchException se) {\n+      throw new IntegratorException(se);\n     } catch (ConvergenceException ce) {\n       throw new IntegratorException(ce);\n     }\n       for (Iterator iter = functions.iterator(); iter.hasNext();) {\n         ((SwitchState) iter.next()).stepAccepted(t, y);\n       }\n-    } catch (FunctionEvaluationException fee) {\n-      throw new IntegratorException(fee);\n+    } catch (SwitchException se) {\n+      throw new IntegratorException(se);\n     }\n   }\n \n    * @param y array were to put the desired state vector at the beginning\n    * of the next step\n    * @return true if the integrator should reset the derivatives too\n-   */\n-  public boolean reset(double t, double[] y) {\n-    boolean resetDerivatives = false;\n-    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-      if (((SwitchState) iter.next()).reset(t, y)) {\n-        resetDerivatives = true;\n-      }\n-    }\n-    return resetDerivatives;\n+   * @exception IntegratorException if one of the switching functions\n+   * that should reset the state fails to do it\n+   */\n+  public boolean reset(double t, double[] y) throws IntegratorException {\n+      try {\n+          boolean resetDerivatives = false;\n+          for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+              if (((SwitchState) iter.next()).reset(t, y)) {\n+                  resetDerivatives = true;\n+              }\n+          }\n+          return resetDerivatives;\n+      } catch (SwitchException se) {\n+          throw new IntegratorException(se);\n+      }\n   }\n \n   /** Switching functions. */\n--- a/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n \n package org.apache.commons.math.ode;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.FirstOrderIntegrator;\n-import org.apache.commons.math.ode.HighamHall54Integrator;\n-import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.StepHandler;\n-import org.apache.commons.math.ode.StepInterpolator;\n-import org.apache.commons.math.ode.SwitchingFunction;\n-\n-import junit.framework.*;\n \n public class HighamHall54IntegratorTest\n   extends TestCase {\n         public int eventOccurred(double t, double[] y) {\n           return SwitchingFunction.CONTINUE;\n         }\n-        public double g(double t, double[] y) throws FunctionEvaluationException {\n+        public double g(double t, double[] y) throws SwitchException {\n           double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n           double offset = t - middle;\n           if (offset > 0) {\n-            throw new FunctionEvaluationException(t);\n+            throw new SwitchException(\"Evaluation failed for argument = {0}\",\n+                                      new Object[] { new Double(t) });\n           }\n           return offset;\n         }", "timestamp": 1209108358, "metainfo": ""}