{"sha": "9d8efd6affe7ee59a08d5e18eb883ce6793df1e7", "log": "MATH-365   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n \n-\n-\n /**\n  * An interface representing a bivariate real function.\n  *\n  * @version $Revision$ $Date$\n  */\n public interface BivariateRealFunction {\n-\n     /**\n      * Compute the value for the function.\n-     * @param x abscissa for which the function value should be computed\n-     * @param y ordinate for which the function value should be computed\n-     * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     *\n+     * @param x Abscissa for which the function value should be computed.\n+     * @param y Ordinate for which the function value should be computed.\n+     * @return the value.\n+     * @throws FunctionEvaluationException if the function evaluation fails.\n      */\n-    double value(double x, double y) throws FunctionEvaluationException;\n+    public double value(double x, double y)\n+        throws FunctionEvaluationException;\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Generates a bicubic interpolating function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class BicubicSplineInterpolator\n+    implements BivariateRealGridInterpolator {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n+                                                          final double[] yval,\n+                                                          final double[][] fval)\n+        throws MathException, IllegalArgumentException {\n+        if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xval.length != fval.length) {\n+            throw new DimensionMismatchException(xval.length, fval.length);\n+        }\n+\n+        MathUtils.checkOrder(xval, 1, true);\n+        MathUtils.checkOrder(yval, 1, true);\n+\n+        final int xLen = xval.length;\n+        final int yLen = yval.length;\n+\n+        // Samples (first index is y-coordinate, i.e. subarray variable is x)\n+        // 0 <= i < xval.length\n+        // 0 <= j < yval.length\n+        // fX[j][i] = f(xval[i], yval[j])\n+        final double[][] fX = new double[yLen][xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            if (fval[i].length != yLen) {\n+                throw new DimensionMismatchException(fval[i].length, yLen);\n+            }\n+\n+            for (int j = 0; j < yLen; j++) {\n+                fX[j][i] = fval[i][j];\n+            }\n+        }\n+\n+        final SplineInterpolator spInterpolator = new SplineInterpolator();\n+\n+        // For each line y[j] (0 <= j < yLen), construct a 1D spline with\n+        // respect to variable x\n+        final PolynomialSplineFunction[] ySplineX = new PolynomialSplineFunction[yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            ySplineX[j] = spInterpolator.interpolate(xval, fX[j]);\n+        }\n+\n+        // For each line x[i] (0 <= i < xLen), construct a 1D spline with\n+        // respect to variable y generated by array fY_1[i]\n+        final PolynomialSplineFunction[] xSplineY = new PolynomialSplineFunction[xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            xSplineY[i] = spInterpolator.interpolate(yval, fval[i]);\n+        }\n+\n+        // Partial derivatives with respect to x at the grid knots\n+        final double[][] dFdX = new double[xLen][yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            final UnivariateRealFunction f = ySplineX[j].derivative();\n+            for (int i = 0; i < xLen; i++) {\n+                dFdX[i][j] = f.value(xval[i]);\n+            }\n+        }\n+\n+        // Partial derivatives with respect to y at the grid knots\n+        final double[][] dFdY = new double[xLen][yLen];\n+        for (int i = 0; i < xLen; i++) {\n+            final UnivariateRealFunction f = xSplineY[i].derivative();\n+            for (int j = 0; j < yLen; j++) {\n+                dFdY[i][j] = f.value(yval[j]);\n+            }\n+        }\n+\n+        // Cross partial derivatives\n+        final double[][] d2FdXdY = new double[xLen][yLen];\n+        for (int i = 0; i < xLen ; i++) {\n+            final int nI = nextIndex(i, xLen);\n+            final int pI = previousIndex(i);\n+            for (int j = 0; j < yLen; j++) {\n+                final int nJ = nextIndex(j, yLen);\n+                final int pJ = previousIndex(j);\n+                d2FdXdY[i][j] = (fval[nI][nJ] - fval[nI][pJ] -\n+                                 fval[pI][nJ] + fval[pI][pJ]) /\n+                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));\n+            }\n+        }\n+\n+        // Create the interpolating splines\n+        return new BicubicSplineInterpolatingFunction(xval, yval, fval,\n+                                                      dFdX, dFdY, d2FdXdY);\n+    }\n+\n+    /**\n+     * Compute the next index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is larger than or equal to 0}.\n+     *\n+     * @param i Index\n+     * @param max Upper limit of the array\n+     * @return the next index\n+     */\n+    private int nextIndex(int i, int max) {\n+        final int index = i + 1;\n+        return index < max ? index : index - 1;\n+    }\n+    /**\n+     * Compute the previous index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is smaller than the size of the array.\n+     *\n+     * @param i Index\n+     * @return the previous index\n+     */\n+    private int previousIndex(int i) {\n+        final int index = i - 1;\n+        return index >= 0 ? index : 0;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java\n  * @version $Revision$ $Date$\n  */\n public interface BivariateRealGridInterpolator {\n-\n     /**\n      * Computes an interpolating function for the data set.\n      *\n-     * @param xval all the x-coordinates of the interpolation points, sorted\n+     * @param xval All the x-coordinates of the interpolation points, sorted\n      * in increasing order.\n-     * @param yval all the y-coordinates of the interpolation points, sorted\n+     * @param yval All the y-coordinates of the interpolation points, sorted\n      * in increasing order.\n-     * @param zval the values of the interpolation points on all the grid knots:\n-     * {@code zval[i][j] = f(xval[i], yval[j])}\n-     * @return a function which interpolates the data set\n+     * @param fval The values of the interpolation points on all the grid knots:\n+     * {@code fval[i][j] = f(xval[i], yval[j])}.\n+     * @return a function which interpolates the data set.\n      * @throws MathException if arguments violate assumptions made by the\n-     *         interpolation algorithm\n+     *         interpolation algorithm.\n      */\n-    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] zval)\n+    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] fval)\n         throws MathException;\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  * @since 2.1\n+ * @deprecated This class does not perform smoothing; the name is thus misleading.\n+ * Please use {@link org.apache.commons.math.analysis.interpolation.BicubicSplineInterpolator}\n+ * instead. If smoothing is desired, a tentative implementation is provided in class\n+ * {@link org.apache.commons.math.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator}.\n+ * This class will be removed in math 3.0.\n  */\n public class SmoothingBicubicSplineInterpolator\n     implements BivariateRealGridInterpolator {\n     /**\n      * {@inheritDoc}\n      */\n-    public BivariateRealFunction interpolate(final double[] xval,\n-                                             final double[] yval,\n-                                             final double[][] zval)\n+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n+                                                          final double[] yval,\n+                                                          final double[][] zval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n             for (int j = 0; j < yLen; j++) {\n                 final int nJ = nextIndex(j, yLen);\n                 final int pJ = previousIndex(j);\n-                dZdXdY[i][j] =  (zY_2[nI][nJ] - zY_2[nI][pJ] -\n-                                 zY_2[pI][nJ] + zY_2[pI][pJ]) /\n-                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ])) ;\n+                dZdXdY[i][j] = (zY_2[nI][nJ] - zY_2[nI][pJ] -\n+                                zY_2[pI][nJ] + zY_2[pI][pJ]) /\n+                    ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));\n             }\n         }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n+import org.apache.commons.math.optimization.fitting.PolynomialFitter;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+\n+/**\n+ * Generates a bicubic interpolation function.\n+ * Prior to generating the interpolating function, the input is smoothed using\n+ * polynomial fitting.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class SmoothingPolynomialBicubicSplineInterpolator\n+    extends BicubicSplineInterpolator {\n+    private final PolynomialFitter xFitter;\n+    private final PolynomialFitter yFitter;\n+\n+    /**\n+     * Default constructor. The degree of the fitting polynomials are set to 3.\n+     */\n+    public SmoothingPolynomialBicubicSplineInterpolator() {\n+        this(3);\n+    }\n+\n+    /**\n+     * @param degree Degree of the polynomial fitting functions.\n+     */\n+    public SmoothingPolynomialBicubicSplineInterpolator(int degree) {\n+        this(degree, degree);\n+    }\n+\n+    /**\n+     * @param xDegree Degree of the polynomial fitting functions along the\n+     * x-dimension.\n+     * @param yDegree Degree of the polynomial fitting functions along the\n+     * y-dimension.\n+     */\n+    public SmoothingPolynomialBicubicSplineInterpolator(int xDegree,\n+                                                        int yDegree) {\n+        xFitter = new PolynomialFitter(xDegree, new GaussNewtonOptimizer(false));\n+        yFitter = new PolynomialFitter(yDegree, new GaussNewtonOptimizer(false));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n+                                                          final double[] yval,\n+                                                          final double[][] fval)\n+        throws MathException, IllegalArgumentException {\n+        if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xval.length != fval.length) {\n+            throw new DimensionMismatchException(xval.length, fval.length);\n+        }\n+\n+        final int xLen = xval.length;\n+        final int yLen = yval.length;\n+\n+        for (int i = 0; i < xLen; i++) {\n+            if (fval[i].length != yLen) {\n+                throw new DimensionMismatchException(fval[i].length, yLen);\n+            }\n+        }\n+\n+        MathUtils.checkOrder(xval, 1, true);\n+        MathUtils.checkOrder(yval, 1, true);\n+\n+        // For each line y[j] (0 <= j < yLen), construct a polynomial, with\n+        // respect to variable x, fitting array fval[][j]\n+        final PolynomialFunction[] yPolyX = new PolynomialFunction[yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            xFitter.clearObservations();\n+            for (int i = 0; i < xLen; i++) {\n+                xFitter.addObservedPoint(1, xval[i], fval[i][j]);\n+            }\n+\n+            yPolyX[j] = xFitter.fit();\n+        }\n+\n+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n+        // values fval_1\n+        final double[][] fval_1 = new double[xLen][yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            final PolynomialFunction f = yPolyX[j];\n+            for (int i = 0; i < xLen; i++) {\n+                fval_1[i][j] = f.value(xval[i]);\n+            }\n+        }\n+\n+        // For each line x[i] (0 <= i < xLen), construct a polynomial, with\n+        // respect to variable y, fitting array fval_1[i][]\n+        final PolynomialFunction[] xPolyY = new PolynomialFunction[xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            yFitter.clearObservations();\n+            for (int j = 0; j < yLen; j++) {\n+                yFitter.addObservedPoint(1, yval[j], fval_1[i][j]);\n+            }\n+\n+            xPolyY[i] = yFitter.fit();\n+        }\n+\n+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n+        // values fval_2\n+        final double[][] fval_2 = new double[xLen][yLen];\n+        for (int i = 0; i < xLen; i++) {\n+            final PolynomialFunction f = xPolyY[i];\n+            for (int j = 0; j < yLen; j++) {\n+                fval_2[i][j] = f.value(yval[j]);\n+            }\n+        }\n+\n+        return super.interpolate(xval, yval, fval_2);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n         fitter.addObservedPoint(weight, x, y);\n     }\n \n+    /**\n+     * Remove all observations.\n+     */\n+    public void clearObservations() {\n+        fitter.clearObservations();\n+    }\n+\n     /** Get the polynomial fitting the weighted (x, y) points.\n      * @return polynomial function best fitting the observed points\n      * @exception OptimizationException if the algorithm failed to converge\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the bicubic interpolator.\n+ * \n+ * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n+ */\n+public final class BicubicSplineInterpolatorTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+\n+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+        \n+        @SuppressWarnings(\"unused\")\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            p = interpolator.interpolate(wxval, yval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[] wyval = new double[] {-4, -3, -1, -1};\n+        try {\n+            p = interpolator.interpolate(xval, wyval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[][] wzval = new double[xval.length][yval.length + 1];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wzval = new double[xval.length - 1][yval.length];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test of interpolator for a plane.\n+     * <p>\n+     * z = 2 x - 3 y + 5\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x - 3 * y + 5;\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 0.3);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 0.3);\n+    }\n+\n+    /**\n+     * Test of interpolator for a paraboloid.\n+     * <p>\n+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5\n+     */\n+    @Test\n+    public void testParaboloid() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 5;\n+        y = 0.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 1e-13);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 0.2);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 0.2);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java\n  * Testcase for the bicubic interpolator.\n  * \n  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n+ * @deprecated To be removed in  math 3.0 (when the class for which it is a test will also be removed).\n  */\n public final class SmoothingBicubicSplineInterpolatorTest {\n     /**\n \n         double[][] wzval = new double[xval.length][yval.length + 1];\n         try {\n-            p = interpolator.interpolate(xval, wyval, wzval);\n+            p = interpolator.interpolate(xval, yval, wzval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (DimensionMismatchException e) {\n             // Expected\n         }\n         wzval = new double[xval.length - 1][yval.length];\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the smoothing bicubic interpolator.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public final class SmoothingPolynomialBicubicSplineInterpolatorTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);\n+        \n+        @SuppressWarnings(\"unused\")\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            p = interpolator.interpolate(wxval, yval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[] wyval = new double[] {-4, -3, -1, -1};\n+        try {\n+            p = interpolator.interpolate(xval, wyval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[][] wzval = new double[xval.length][yval.length + 1];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wzval = new double[xval.length - 1][yval.length];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wzval = new double[xval.length][yval.length - 1];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test of interpolator for a plane.\n+     * <p>\n+     * z = 2 x - 3 y + 5\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x - 3 * y + 5\n+                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 2);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 2);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 2);\n+    }\n+\n+    /**\n+     * Test of interpolator for a paraboloid.\n+     * <p>\n+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5\n+     */\n+    @Test\n+    public void testParaboloid() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5\n+                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+\n+        x = 5;\n+        y = 0.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 2);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 2);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 2);\n+    }\n+}", "timestamp": 1271856464, "metainfo": ""}