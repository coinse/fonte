{"sha": "9e94c3d8836a01ea93653eb92b1f7a8d2089ab79", "log": "added new tests for multistart optimizers  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n+import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Test;\n+\n+public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n+\n+    @Test\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        NonLinearConjugateGradientOptimizer underlying =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(753289573253l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 },\n+                                                  new GaussianRandomGenerator(g));\n+        MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n+            new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n+        optimizer.setMaxIterations(100);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n+        BrentSolver solver = new BrentSolver();\n+        solver.setAbsoluteAccuracy(1.0e-13);\n+        solver.setRelativeAccuracy(1.0e-15);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+        RealPointValuePair[] optima = optimizer.getOptima();\n+        for (RealPointValuePair o : optima) {\n+            Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n+            assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+            assertEquals(96.075902096, center.x, 1.0e-8);\n+            assertEquals(48.135167894, center.y, 1.0e-8);\n+        }\n+        assertTrue(optimizer.getEvaluations() > 70);\n+        assertTrue(optimizer.getEvaluations() < 90);\n+        assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateRealFunction {\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[] gradient(double[] point) {\n+\n+            // optimal radius\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+            double radius = getRadius(center);\n+\n+            // gradient of the sum of squared residuals\n+            double dJdX = 0;\n+            double dJdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dJdX += (center.x - pk.x) * (dk - radius) / dk;\n+                dJdY += (center.y - pk.y) * (dk - radius) / dk;\n+            }\n+            dJdX *= 2;\n+            dJdY *= 2;\n+\n+            return new double[] { dJdX, dJdY };\n+\n+        }\n+\n+        public double value(double[] variables)\n+        throws IllegalArgumentException, FunctionEvaluationException {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double sum = 0;\n+            for (Point2D.Double point : points) {\n+                double di = point.distance(center) - radius;\n+                sum += di * di;\n+            }\n+\n+            return sum;\n+\n+        }\n+\n+        public MultivariateVectorialFunction gradient() {\n+            return new MultivariateVectorialFunction() {\n+                public double[] value(double[] point) {\n+                    return gradient(point);\n+                }\n+            };\n+        }\n+\n+        public MultivariateRealFunction partialDerivative(final int k) {\n+            return new MultivariateRealFunction() {\n+                public double value(double[] point) {\n+                    return gradient(point)[k];\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.junit.Test;\n+\n+public class MultiStartUnivariateRealOptimizerTest {\n+\n+    @Test\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(44428400075l);\n+        MultiStartUnivariateRealOptimizer minimizer =\n+            new MultiStartUnivariateRealOptimizer(underlying, 10, g);\n+        minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n+        double[] optima = minimizer.getOptima();\n+        for (int i = 1; i < optima.length; ++i) {\n+            double d = (optima[i] - optima[i-1]) / (2 * Math.PI);\n+            assertTrue (Math.abs(d - Math.rint(d)) < 1.0e-8);\n+            assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n+        }\n+        assertTrue(minimizer.getEvaluations() > 2900);\n+        assertTrue(minimizer.getEvaluations() < 3100);\n+\n+    }\n+\n+}", "timestamp": 1248033934, "metainfo": ""}