{"sha": "512526d572d8abe9379d98be50aa1d2e7d128217", "log": "MATH-379   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.util.Arrays;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+\n+/**\n+ * Converter between unidimensional storage structure and multidimensional\n+ * conceptual structure.\n+ * This utility will convert from indices in a multidimensional structure\n+ * to the corresponding index in a one-dimensional array. For example,\n+ * assuming that the ranges (in 3 dimensions) of indices are 2, 4 and 3,\n+ * the following correspondences, between 3-tuples indices and unidimensional\n+ * indices, will hold:\n+ * <ul>\n+ *  <li>(0, 0, 0) corresponds to 0</li>\n+ *  <li>(0, 0, 1) corresponds to 1</li>\n+ *  <li>(0, 0, 2) corresponds to 2</li>\n+ *  <li>(0, 1, 0) corresponds to 3</li>\n+ *  <li>...</li>\n+ *  <li>(1, 0, 0) corresponds to 12</li>\n+ *  <li>...</li>\n+ *  <li>(1, 3, 2) corresponds to 23</li>\n+ * </ul>\n+ */\n+public class MultidimensionalCounter implements Iterable<Integer> {\n+    /**\n+     * Number of dimensions.\n+     */\n+    private final int dimension;\n+    /**\n+     * Offset for each dimension.\n+     */\n+    private final int[] uniCounterOffset;\n+    /**\n+     * Counter sizes.\n+     */\n+    private final int[] size;\n+    /**\n+     * Total number of (one-dimensional) slots.\n+     */\n+    private final int totalSize;\n+    /**\n+     * Index of last dimension.\n+     */\n+    private final int last;\n+\n+    /**\n+     * Perform iteration over the multidimensional counter.\n+     */\n+    public class Iterator implements java.util.Iterator<Integer> {\n+        /**\n+         * Multidimensional counter.\n+         */\n+        private final int[] counter = new int[dimension];\n+        /**\n+         * Unidimensional counter.\n+         */\n+        private int count = -1;\n+\n+        /**\n+         * Create an iterator (see {@link MultidimensionalCounter#iterator()}.\n+         */\n+        Iterator() {\n+            counter[last] = -1;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasNext() {\n+            for (int i = 0; i < dimension; i++) {\n+                if (counter[i] != size[i] - 1) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * @return the unidimensional count after the counter has been\n+         * incremented by {@code 1}.\n+         */\n+        public Integer next() {\n+            for (int i = last; i >= 0; i--) {\n+                if (counter[i] == size[i] - 1) {\n+                    counter[i] = 0;\n+                } else {\n+                    ++counter[i];\n+                    break;\n+                }\n+            }\n+            \n+            return ++count;\n+        }\n+\n+        /**\n+         * Get the current unidimensional counter slot.\n+         *\n+         * @return the index within the unidimensionl counter.\n+         */\n+        public int getCount() {\n+            return count;\n+        }\n+        /**\n+         * Get the current multidimensional counter slots.\n+         *\n+         * @return the indices within the multidimensional counter.\n+         */\n+        public int[] getCounts() {\n+            return Arrays.copyOf(counter, dimension);\n+        }\n+\n+        /**\n+         * Get the current count in the selected dimension.\n+         *\n+         * @param dim Dimension index.\n+         * @return the count at the corresponding index for the current state\n+         * of the iterator.\n+         * @throws IndexOutOfBoundsException if {@code index} is not in the\n+         * correct interval (as defined by the length of the argument in the\n+         * {@link MultidimensionalCounter#MultidimensionalCounter(int[])\n+         * constructor of the enclosing class}).\n+         */\n+        public int getCount(int dim) {\n+            return counter[dim];\n+        }\n+\n+        /**\n+         * @throws UnsupportedOperationException.\n+         */\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Create a counter.\n+     *\n+     * @param size Counter sizes (number of slots in each dimension).\n+     * @throws {@link NotStrictlyPositiveException} if one of the sizes is\n+     * negative or zero.\n+     */\n+    public MultidimensionalCounter(int ... size) {\n+        dimension = size.length;\n+        this.size = Arrays.copyOf(size, dimension);\n+\n+        uniCounterOffset = new int[dimension];\n+\n+        last = dimension - 1;\n+        int tS = size[last];\n+        for (int i = 0; i < last; i++) {\n+            int count = 1;\n+            for (int j = i + 1; j < dimension; j++) {\n+                count *= size[j];\n+            }\n+            uniCounterOffset[i] = count;\n+            tS *= size[i];\n+        }\n+        uniCounterOffset[last] = 0;\n+\n+        if (tS <= 0) {\n+            throw new NotStrictlyPositiveException(tS);\n+        }\n+\n+        totalSize = tS;\n+    }\n+\n+    /**\n+     * Create an iterator over this counter.\n+     *\n+     * @return the iterator.\n+     */\n+    public Iterator iterator() {\n+        return new Iterator();\n+    }\n+\n+    /**\n+     * Get the number of dimensions of the multidimensional counter.\n+     *\n+     * @return the number of dimensions.\n+     */\n+    public int getDimension() {\n+        return dimension;\n+    }\n+\n+    /**\n+     * Convert to multidimensional counter.\n+     *\n+     * @param index Index in unidimensional counter.\n+     * @returns the multidimensional counts.\n+     * @throws {@link OutOfRangeException} if {@code index} is not between\n+     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n+     */\n+    public int[] getCounts(int index) {\n+        if (index < 0\n+            || index >= totalSize) {\n+            throw new OutOfRangeException(index, 0, totalSize);\n+        }\n+        \n+        final int[] indices = new int[dimension];\n+        \n+        int count = 0;\n+        for (int i = 0; i < last; i++) {\n+            int idx = 0;\n+            final int offset = uniCounterOffset[i];\n+            while (count <= index) {\n+                count += offset;\n+                ++idx;\n+            }\n+            --idx;\n+            count -= offset;\n+            indices[i] = idx;\n+        }\n+\n+        int idx = 1;\n+        while (count < index) {\n+            count += idx;\n+            ++idx;\n+        }\n+        --idx;\n+        indices[last] = idx;\n+\n+        return indices;\n+    }\n+\n+    /**\n+     * Convert to unidimensional counter.\n+     *\n+     * @param c Indices in multidimensional counter.\n+     * @return the index within the unidimensionl counter.\n+     * @throws {@link DimensionMismatchException} if the size of {@code c}\n+     * does not match the size of the array given in the contructor.\n+     * @throws {@link OutOfRangeException} if a value of {@code c} is not in\n+     * the range of the corresponding dimension, as defined in the\n+     * {@link #MultidimensionalCounter(int[]) constructor}.\n+     */\n+    public int getCount(int ... c) {\n+        if (c.length != dimension) {\n+            throw new DimensionMismatchException(c.length, dimension);\n+        }\n+        int count = 0;\n+        for (int i = 0; i < dimension; i++) {\n+            final int index = c[i];\n+            if (index < 0\n+                || index >= size[i]) {\n+                throw new OutOfRangeException(index, 0, size[i] - 1);\n+            }\n+            count += uniCounterOffset[i] * c[i];\n+        }\n+        return count + c[last];\n+    }\n+\n+    /**\n+     * Get the total number of elements.\n+     *\n+     * @return the total size of the unidimensional counter.\n+     */\n+    public int getSize() {\n+        return totalSize;\n+    }\n+    /**\n+     * Get the number of multidimensional counter slots in each dimension.\n+     *\n+     * @return the sizes of the multidimensional counter in each dimension.\n+     */\n+    public int[] getSizes() {\n+        return Arrays.copyOf(size, dimension);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < dimension; i++) {\n+            sb.append(\"[\").append(getCount(i)).append(\"]\");\n+        }\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/MultidimensionalCounterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ */\n+public class MultidimensionalCounterTest {\n+    @Test\n+    public void testPreconditions() {\n+        MultidimensionalCounter c;\n+\n+        try {\n+            c = new MultidimensionalCounter(0, 1);\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n+        try {\n+            c = new MultidimensionalCounter(2, 0);\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n+        try {\n+            c = new MultidimensionalCounter(-1, 1);\n+            Assert.fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n+\n+        c = new MultidimensionalCounter(2, 3);\n+        try {\n+            c.getCount(1, 1, 1);\n+            Assert.fail(\"DimensionMismatchException expected\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected.\n+        }\n+        try {\n+            c.getCount(3, 1);\n+            Assert.fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException e) {\n+            // Expected.\n+        }\n+        try {\n+            c.getCount(0, -1);\n+            Assert.fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException e) {\n+            // Expected.\n+        }\n+        try {\n+            c.getCounts(-1);\n+            Assert.fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException e) {\n+            // Expected.\n+        }\n+        try {\n+            c.getCounts(6);\n+            Assert.fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException e) {\n+            // Expected.\n+        }\n+    }\n+\n+    @Test\n+    public void testIteratorPreconditions() {\n+        MultidimensionalCounter.Iterator iter = (new MultidimensionalCounter(2, 3)).iterator();\n+        try {\n+            iter.getCount(-1);\n+            Assert.fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected.\n+        }\n+        try {\n+            iter.getCount(2);\n+            Assert.fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected.\n+        }\n+    }\n+\n+    @Test\n+    public void testMulti2UniConversion() {\n+        final MultidimensionalCounter c = new MultidimensionalCounter(2, 4, 5);\n+        Assert.assertEquals(c.getCount(1, 2, 3), 33);\n+    }\n+\n+    @Test\n+    public void testAccessors() {\n+        final int[] originalSize = new int[] {2, 6, 5};\n+        final MultidimensionalCounter c = new MultidimensionalCounter(originalSize);\n+        final int nDim = c.getDimension();\n+        Assert.assertEquals(nDim, originalSize.length);\n+\n+        final int[] size = c.getSizes();\n+        for (int i = 0; i < nDim; i++) {\n+            Assert.assertEquals(originalSize[i], size[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testIterationConsistency() {\n+        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 2);\n+        final int[][] expected = new int[][] {\n+            { 0, 0, 0 },\n+            { 0, 0, 1 },\n+            { 0, 1, 0 },\n+            { 0, 1, 1 },\n+            { 0, 2, 0 },\n+            { 0, 2, 1 },\n+            { 1, 0, 0 },\n+            { 1, 0, 1 },\n+            { 1, 1, 0 },\n+            { 1, 1, 1 },\n+            { 1, 2, 0 },\n+            { 1, 2, 1 }\n+        };\n+\n+        final int totalSize = c.getSize();\n+        final int nDim = c.getDimension();\n+        final MultidimensionalCounter.Iterator iter = c.iterator();\n+        for (int i = 0; i < totalSize; i++) {\n+            if (!iter.hasNext()) {\n+                Assert.fail(\"Too short\");\n+            }\n+            final int uniDimIndex = iter.next();\n+            Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n+\n+            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n+                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n+                                    expected[i][dimIndex], iter.getCount(dimIndex));\n+            }\n+\n+            Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n+                                c.getCount(expected[i]), uniDimIndex);\n+\n+            final int[] indices = c.getCounts(uniDimIndex);\n+            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n+                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n+                                    expected[i][dimIndex], indices[dimIndex]);\n+            }\n+        }\n+\n+        if (iter.hasNext()) {\n+            Assert.fail(\"Too long\");\n+        }\n+    }\n+}", "timestamp": 1277726942, "metainfo": ""}