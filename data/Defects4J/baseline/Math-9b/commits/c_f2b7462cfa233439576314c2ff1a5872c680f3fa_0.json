{"sha": "f2b7462cfa233439576314c2ff1a5872c680f3fa", "log": "Added javadoc for StorelessCovariance, code cleanup. JIRA: MATH-449 patch provided by Patrick Meyer  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n      *\n      * @return number of observations\n      */\n-\n     public int getN() {\n         return n;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/StorelessBivariateCovariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/StorelessBivariateCovariance.java\n  */\n package org.apache.commons.math3.stat.correlation;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n  * Bivariate Covariance implementation that does not require input data to be\n  * stored in memory.\n  *\n+ * <p>This class is based on a paper written by Philippe Pbay:\n+ * <a href=\"http://prod.sandia.gov/techlib/access-control.cgi/2008/086212.pdf\">\n+ * Formulas for Robust, One-Pass Parallel Computation of Covariances and\n+ * Arbitrary-Order Statistical Moments</a>, 2008, Technical Report SAND2008-6212,\n+ * Sandia National Laboratories. It computes the covariance for a pair of variables.\n+ * Use {@link StorelessCovariance} to estimate an entire covariance matrix.</p>\n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n public class StorelessBivariateCovariance {\n \n-    private double deltaX = 0.0;\n+    /** the mean of variable x */\n+    private double meanX;\n \n-    private double deltaY = 0.0;\n+    /** the mean of variable y */\n+    private double meanY;\n \n-    private double meanX = 0.0;\n+    /** number of observations */\n+    private double n;\n \n-    private double meanY = 0.0;\n+    /** the running covariance estimate */\n+    private double covarianceNumerator;\n \n-    private double n = 0;\n+    /** flag for bias correction */\n+    private boolean biasCorrected;\n \n-    private double covarianceNumerator = 0.0;\n-\n-    private boolean biasCorrected = true;\n-\n+    /**\n+     * Create an empty {@link StorelessBivariateCovariance} instance with\n+     * bias correction.\n+     */\n     public StorelessBivariateCovariance() {\n+        this(true);\n     }\n \n-    public StorelessBivariateCovariance(boolean biasCorrected) {\n-        this.biasCorrected = biasCorrected;\n+    /**\n+     * Create an empty {@link StorelessBivariateCovariance} instance.\n+     *\n+     * @param biasCorrection if <code>true</code> the covariance estimate is corrected\n+     * for bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\n+     * i.e. n in the denominator.\n+     */\n+    public StorelessBivariateCovariance(final boolean biasCorrection) {\n+        meanX = meanY = 0.0;\n+        n = 0;\n+        covarianceNumerator = 0.0;\n+        biasCorrected = biasCorrection;\n     }\n \n-    public void increment(double x, double y) {\n+    /**\n+     * Update the covariance estimation with a pair of variables (x, y).\n+     *\n+     * @param x the x value\n+     * @param y the y value\n+     */\n+    public void increment(final double x, final double y) {\n         n++;\n-        deltaX = x - meanX;\n-        deltaY = y - meanY;\n+        final double deltaX = x - meanX;\n+        final double deltaY = y - meanY;\n         meanX += deltaX / n;\n         meanY += deltaY / n;\n         covarianceNumerator += ((n - 1.0) / n) * deltaX * deltaY;\n     }\n \n+    /**\n+     * Returns the number of observations.\n+     *\n+     * @return number of observations\n+     */\n     public double getN() {\n         return n;\n     }\n \n-    public double getResult() throws IllegalArgumentException {\n+    /**\n+     * Return the current covariance estimate.\n+     *\n+     * @return the current covariance\n+     * @throws NumberIsTooSmallException if the number of observations\n+     * is &lt; 2\n+     */\n+    public double getResult() throws NumberIsTooSmallException {\n         if (n < 2) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n-                                                   n, 2);\n+            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n+                                                n, 2, true);\n         }\n         if (biasCorrected) {\n             return covarianceNumerator / (n - 1d);\n             return covarianceNumerator / n;\n         }\n     }\n-\n }\n \n--- a/src/main/java/org/apache/commons/math3/stat/correlation/StorelessCovariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/StorelessCovariance.java\n  */\n package org.apache.commons.math3.stat.correlation;\n \n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.RealMatrix;\n \n /**\n  * Covariance implementation that does not require input data to be\n- * stored in memory.\n+ * stored in memory. The size of the covariance matrix is specified in the\n+ * constructor. Specific elements of the matrix are incrementally updated with\n+ * calls to incrementRow() or increment Covariance().\n+ *\n+ * <p>This class is based on a paper written by Philippe Pbay:\n+ * <a href=\"http://prod.sandia.gov/techlib/access-control.cgi/2008/086212.pdf\">\n+ * Formulas for Robust, One-Pass Parallel Computation of Covariances and\n+ * Arbitrary-Order Statistical Moments</a>, 2008, Technical Report SAND2008-6212,\n+ * Sandia National Laboratories.</p>\n  *\n  * @version $Id$\n  * @since 3.0\n  */\n public class StorelessCovariance extends Covariance {\n \n-    private StorelessBivariateCovariance[][] covMatrix = null;\n+    /** the two-dimensional covariance matrix */\n+    private StorelessBivariateCovariance[][] covMatrix;\n \n-    private int rowDimension = 1;\n+    /** row dimension of the covariance matrix */\n+    private int rowDimension;\n \n-    private int colDimension = 1;\n+    /** column dimension of the covariance matrix */\n+    private int colDimension;\n \n-    private boolean biasCorrected = true;\n+    /** flag for bias correction */\n+    private boolean biasCorrected;\n \n-    public StorelessCovariance(int rowDimension, int colDimension){\n-        this(rowDimension, colDimension, true);\n+    /**\n+     * Create a bias corrected covariance matrix with a given number of rows and columns.\n+     *\n+     * @param rows number of rows\n+     * @param cols number of columns\n+     */\n+    public StorelessCovariance(final int rows, final int cols) {\n+        this(rows, cols, true);\n     }\n \n-    public StorelessCovariance(int rowDimension, int colDimension, boolean biasCorrected){\n-        this.rowDimension = rowDimension;\n-        this.colDimension = colDimension;\n-        this.biasCorrected = biasCorrected;\n+    /**\n+     * Create a covariance matrix with a given number of rows and columns and the\n+     * indicated bias correction.\n+     *\n+     * @param rows number of variables in the rows\n+     * @param cols number of variables in the columns\n+     * @param biasCorrection if <code>true</code> the covariance estimate is corrected\n+     * for bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\n+     * i.e. n in the denominator.\n+     */\n+    public StorelessCovariance(final int rows, final int cols,\n+                               final boolean biasCorrection) {\n+        rowDimension = rows;\n+        colDimension = cols;\n+        biasCorrected = biasCorrection;\n         covMatrix = new StorelessBivariateCovariance[rowDimension][colDimension];\n         initializeMatrix();\n     }\n \n-    private void initializeMatrix(){\n+    /**\n+     * Initialize the internal two-dimensional array of\n+     * {@link StorelessBivariateCovariance} instances.\n+     */\n+    private void initializeMatrix() {\n         for(int i=0;i<rowDimension;i++){\n             for(int j=0;j<colDimension;j++){\n                 covMatrix[i][j] = new StorelessBivariateCovariance(biasCorrected);\n         }\n     }\n \n-    public StorelessBivariateCovariance getCovariance(int xIndex, int yIndex){\n+    /**\n+     * Get the covariance for an individual element of the covariance matrix.\n+     *\n+     * @param xIndex row index in the covariance matrix\n+     * @param yIndex column index in the covariance matrix\n+     * @return the covariance of the given element\n+     */\n+    public StorelessBivariateCovariance getCovariance(final int xIndex,\n+                                                      final int yIndex) {\n         return covMatrix[xIndex][yIndex];\n     }\n \n-    public void setCovariance(int xIndex, int yIndex, StorelessBivariateCovariance cov){\n+    /**\n+     * Set the covariance for an individual element of the covariance matrix.\n+     *\n+     * @param xIndex row index in the covariance matrix\n+     * @param yIndex column index in the covariance matrix\n+     * @param cov the covariance to be set\n+     */\n+    public void setCovariance(final int xIndex, final int yIndex,\n+                              final StorelessBivariateCovariance cov) {\n         covMatrix[xIndex][yIndex] = cov;\n     }\n \n-    public void incrementCovariance(int xIndex, int yIndex, double x, double y){\n+    /**\n+     * Increment one individual element of the covariance matrix.\n+     *\n+     * <p>The element is specified by the xIndex and yIndex and incremented with the\n+     * corresponding values of x and y.</p>\n+     *\n+     * @param xIndex row index in the covariance matrix\n+     * @param yIndex column index in the covariance matrix\n+     * @param x value of x\n+     * @param y value of y\n+     */\n+    public void incrementCovariance(final int xIndex, final int yIndex,\n+                                    final double x, final double y) {\n         covMatrix[xIndex][yIndex].increment(x, y);\n     }\n \n-    public void incrementRow(double[] rowData)throws IllegalArgumentException{\n+    /**\n+     * Increment the covariance matrix with one row of data.\n+     *\n+     * @param rowData array representing one row of data.\n+     * @throws DimensionMismatchException if the length of <code>rowData</code>\n+     * does not match with the covariance matrix\n+     */\n+    public void incrementRow(final double[] rowData)\n+        throws DimensionMismatchException {\n+\n         int length = rowData.length;\n         if (length != colDimension) {\n-            throw new MathIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, length, colDimension);\n+            throw new DimensionMismatchException(length, colDimension);\n         }\n-        for(int i=0;i<length;i++){\n-            for(int j=0;j<length;j++){\n+        for (int i = 0; i < length; i++){\n+            for (int j = 0; j < length; j++){\n                 covMatrix[i][j].increment(rowData[i], rowData[j]);\n             }\n         }\n+\n     }\n \n-    @Override\n-    public RealMatrix getCovarianceMatrix() throws IllegalArgumentException {\n-        RealMatrix matrix = new Array2DRowRealMatrix(rowDimension, colDimension);\n-        for(int i=0;i<rowDimension;i++){\n-            for(int j=0;j<colDimension;j++){\n-                matrix.setEntry(i, j, covMatrix[i][j].getResult());\n-            }\n-        }\n-        return matrix;\n+    /**\n+     * {@inheritDoc}\n+     * @throws NumberIsTooSmallException if the number of observations\n+     * in a cell is &lt; 2\n+     */\n+    public RealMatrix getCovarianceMatrix() throws NumberIsTooSmallException {\n+        return MatrixUtils.createRealMatrix(getData());\n     }\n \n-    public double[][] getData() throws IllegalArgumentException {\n-        double[][] data = new double[rowDimension][rowDimension];\n-        for(int i=0;i<rowDimension;i++){\n-            for(int j=0;j<colDimension;j++){\n+    /**\n+     * Return the covariance matrix as two-dimensional array.\n+     *\n+     * @return a two-dimensional double array of covariance values\n+     * @throws NumberIsTooSmallException if the number of observations\n+     * for a cell is &lt; 2\n+     */\n+    public double[][] getData() throws NumberIsTooSmallException {\n+        final double[][] data = new double[rowDimension][rowDimension];\n+        for (int i = 0; i < rowDimension; i++) {\n+            for (int j = 0; j < colDimension; j++) {\n                 data[i][j] = covMatrix[i][j].getResult();\n             }\n         }\n     }\n \n     /**\n-     * This {@link Covariance} method is not supported by StorelessCovariance, since\n-     * the number of bivariate observations does not have to be the same for different\n+     * This {@link Covariance} method is not supported by a {@link StorelessCovariance},\n+     * since the number of bivariate observations does not have to be the same for different\n      * pairs of covariates - i.e., N as defined in {@link Covariance#getN()} is undefined.\n-     * @return nothing as this implementation always throws a {@link MathUnsupportedOperationException}\n+     *\n+     * @return nothing as this implementation always throws a\n+     * {@link MathUnsupportedOperationException}\n      * @throws MathUnsupportedOperationException in all cases\n      */\n-    @Override\n     public int getN()\n         throws MathUnsupportedOperationException {\n         throw new MathUnsupportedOperationException();\n     }\n-\n }", "timestamp": 1329333779, "metainfo": ""}