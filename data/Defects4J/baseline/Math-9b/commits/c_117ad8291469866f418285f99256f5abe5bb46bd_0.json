{"sha": "117ad8291469866f418285f99256f5abe5bb46bd", "log": "added a base class for bits streams based modern pseudo random generators  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/** Base class for random number generators that generates bits streams.\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+\n+ */\n+public abstract class BitsStreamGenerator implements RandomGenerator {\n+\n+    /** Next gaussian. */\n+    private double nextGaussian;\n+\n+    /** Creates a new random number generator.\n+     */\n+    public BitsStreamGenerator() {\n+        nextGaussian = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(int seed);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(int[] seed);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(long seed);\n+\n+    /** Generate next pseudorandom number.\n+     * <p>This method is the core generation algorithm. It is used by all the\n+     * public generation methods for the various primitive types {@link\n+     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n+     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n+     * {@link #next(int)} and {@link #nextLong()}.</p>\n+     * @param bits number of random bits to produce\n+     */\n+    protected abstract int next(int bits);\n+\n+    /** {@inheritDoc} */\n+    public boolean nextBoolean() {\n+        return next(1) != 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void nextBytes(byte[] bytes) {\n+        int i = 0;\n+        final int iEnd = bytes.length - 3;\n+        while (i < iEnd) {\n+            final int random = next(32);\n+            bytes[i]     = (byte) (random & 0xff);\n+            bytes[i + 1] = (byte) ((random >>  8) & 0xff);\n+            bytes[i + 2] = (byte) ((random >> 16) & 0xff);\n+            bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n+            i += 4;\n+        }\n+        int random = next(32);\n+        while (i < bytes.length) {\n+            bytes[i++] = (byte) (random & 0xff); \n+            random     = random >> 8;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double nextDouble() {\n+        final long high = ((long) next(26)) << 26;\n+        final int  low  = next(26);\n+        return (high | low) * 0x1.0p-52d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public float nextFloat() {\n+        return next(23) * 0x1.0p-23f;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double nextGaussian() {\n+\n+        final double random;\n+        if (Double.isNaN(nextGaussian)) {\n+            // generate a new pair of gaussian numbers\n+            final double x = nextDouble();\n+            final double y = nextDouble();\n+            final double alpha = 2 * Math.PI * x;\n+            final double r      = Math.sqrt(-2 * Math.log(y));\n+            random       = r * Math.cos(alpha);\n+            nextGaussian = r * Math.sin(alpha);\n+        } else {\n+            // use the second element of the pair already generated\n+            random = nextGaussian;\n+            nextGaussian = Double.NaN;\n+        }\n+\n+        return random;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextInt() {\n+        return next(32);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextInt(int n) throws IllegalArgumentException {\n+\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound must be positive ({0})\", n);\n+        }\n+\n+        // find bit mask for n\n+        int mask = n;\n+        mask |= mask >> 1;\n+        mask |= mask >> 2;\n+        mask |= mask >> 4;\n+        mask |= mask >> 8;\n+        mask |= mask >> 16;\n+\n+        while (true) {\n+            final int random = next(32) & mask;\n+            if (random < n) {\n+                return random;\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public long nextLong() {\n+        final long high  = ((long) next(32)) << 32;\n+        final long  low  = ((long) next(32)) & 0xffffffffL;\n+        return high | low;\n+    }\n+\n+}", "timestamp": 1248212011, "metainfo": ""}