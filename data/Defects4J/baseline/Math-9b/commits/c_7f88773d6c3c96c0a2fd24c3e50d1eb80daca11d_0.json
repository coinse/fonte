{"sha": "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d", "log": "replaced Object[] parameters by variable arguments in exceptions constructors this allows simpler error declaration and removes the need for the strange null argument with fixed messages  ", "commit": "\n--- a/src/experimental/org/apache/commons/math/linear/RecursiveLayoutRealMatrix.java\n+++ b/src/experimental/org/apache/commons/math/linear/RecursiveLayoutRealMatrix.java\n         // create storage array\n         final int expectedLength = tileNumber * tileNumber * tileSizeRows * tileSizeColumns;\n         if (data.length != expectedLength) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"wrong array size (got {0}, expected {1})\",\n-                                                                      new Object[] {\n-                                                                          data.length,\n-                                                                          expectedLength\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"wrong array size (got {0}, expected {1})\",\n+                    data.length, expectedLength);\n         }\n \n         if (copyArray) {\n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        new Object[] { columns, length }); \n+                        columns, length); \n             }\n         }\n \n         checkSubMatrixIndex(row, endRow, column, endColumn);\n         for (final double[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n-                                                                          new Object[] {\n-                                                                              refLength, subRow.length\n-                                                                          }); \n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n             }\n         }\n \n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n         }\n \n         // a row matrix has always only one large tile,\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n         }\n \n         // a column matrix has always only one large tile,\n         } catch (ClassCastException cce) {\n             checkRowIndex(row);\n             if (vector.getDimension() != columns) {\n-                throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                                 new Object[] {\n-                                                     1, vector.getDimension(),\n-                                                     1, columns\n-                                                 });\n+                throw new InvalidMatrixException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        1, vector.getDimension(), 1, columns);\n             }\n \n             // perform copy tile-wise, to ensure good cache behavior\n         } catch (ClassCastException cce) {\n             checkColumnIndex(column);\n             if (vector.getDimension() != rows) {\n-                throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                                 new Object[] {\n-                                                     vector.getDimension(), 1,\n-                                                     rows, 1\n-                                                 });\n+                throw new InvalidMatrixException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        vector.getDimension(), 1, rows, 1);\n             }\n \n             // perform copy tile-wise, to ensure good cache behavior\n \n         checkRowIndex(row);\n         if (array.length != columns) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 1, array.length,\n-                                                 1, columns\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, columns);\n         }\n \n         // perform copy tile-wise, to ensure good cache behavior\n \n         checkColumnIndex(column);\n         if (array.length != rows) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 array.length, 1,\n-                                                 rows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, rows, 1);\n         }\n \n         // perform copy tile-wise, to ensure good cache behavior\n     public double getEntry(final int row, final int column)\n         throws MatrixIndexException {\n         if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n         return data[index(row, column)];\n     }\n     public void setEntry(final int row, final int column, final double value)\n         throws MatrixIndexException {\n         if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n         data[index(row, column)] = value;\n     }\n     public void addToEntry(final int row, final int column, final double increment)\n         throws MatrixIndexException {\n         if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n         data[index(row, column)] += increment;\n     }\n     public void multiplyEntry(final int row, final int column, final double factor)\n         throws MatrixIndexException {\n         if ((row < 0) || (row >= rows) || (column < 0) || (column >= columns)) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n         data[index(row, column)] *= factor;\n     }\n         throws IllegalArgumentException {\n \n         if (v.length != columns) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, columns\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n         }\n         final double[] out = new double[rows];\n \n         throws IllegalArgumentException {\n \n         if (v.length != rows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, rows\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n         }\n         final double[] out = new double[columns];\n \n--- a/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n      */\n     public ArgumentOutsideDomainException(double argument, double lower, double upper) {\n         super(argument,\n-              \"Argument {0} outside domain [{1} ; {2}]\",\n-              new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });\n+              \"Argument {0} outside domain [{1} ; {2}]\", argument, lower, upper);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/java/org/apache/commons/math/ConvergenceException.java\n public class ConvergenceException extends MathException {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4380655778005469702L;\n+    private static final long serialVersionUID = 4883703247677159141L;\n \n     /**\n      * Default constructor.\n      */\n     public ConvergenceException() {\n-        super(\"Convergence failed\", null);\n+        super(\"Convergence failed\");\n     }\n     \n     /**\n      * @param arguments format arguments\n      * @since 1.2\n      */\n-    public ConvergenceException(String pattern, Object[] arguments) {\n+    public ConvergenceException(String pattern, Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n     /**\n      * Constructs an exception with specified formatted detail message and root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param cause  the exception or error that caused this exception to be thrown\n      * @since 1.2\n      */\n-    public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {\n-        super(pattern, arguments, cause);\n+    public ConvergenceException(Throwable cause, String pattern, Object ... arguments) {\n+        super(cause, pattern, arguments);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/java/org/apache/commons/math/DimensionMismatchException.java\n      * @param dimension2 second dimension\n      */\n     public DimensionMismatchException(int dimension1, int dimension2) {\n-        super(\"dimension mismatch {0} != {1}\",\n-              new Object[] {\n-                Integer.valueOf(dimension1), Integer.valueOf(dimension2)\n-              });\n+        super(\"dimension mismatch {0} != {1}\", dimension1, dimension2);\n         this.dimension1 = dimension1;\n         this.dimension2 = dimension2;\n     }\n--- a/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n      */\n     public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n         super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n-              new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });\n+              abscissa, i1, i2);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n public class FunctionEvaluationException extends MathException  {\n     \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -2193260774031645876L;\n+    private static final long serialVersionUID = -7267500407292949362L;\n \n     /** Argument causing function evaluation failure */\n     private double argument = Double.NaN;\n      * @param argument  the failing function argument \n      */\n     public FunctionEvaluationException(double argument) {\n-        super(\"Evaluation failed for argument = {0}\",\n-              new Object[] { Double.valueOf(argument) });\n+        super(\"Evaluation failed for argument = {0}\", Double.valueOf(argument));\n         this.argument = argument;\n     }\n     \n      * @since 1.2\n      */\n     public FunctionEvaluationException(double argument,\n-                                       String pattern, Object[] arguments) {\n+                                       String pattern, Object ... arguments) {\n         super(pattern, arguments);\n         this.argument = argument;\n     }\n     /**\n      * Constructs an exception with specified root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n      * @param argument  the failing function argument \n-     * @param cause  the exception or error that caused this exception to be thrown\n      * @since 1.2\n      */\n-    public FunctionEvaluationException(double argument, Throwable cause) {\n+    public FunctionEvaluationException(Throwable cause, double argument) {\n         super(cause);\n         this.argument = argument;\n     }\n     /**\n      * Constructs an exception with specified formatted detail message and root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n      * @param argument  the failing function argument \n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param cause  the exception or error that caused this exception to be thrown\n      * @since 1.2\n      */\n-    public FunctionEvaluationException(double argument,\n-                                       String pattern, Object[] arguments,\n-                                       Throwable cause) {\n-        super(pattern, arguments, cause);\n+    public FunctionEvaluationException(Throwable cause,\n+                                       double argument, String pattern,\n+                                       Object ... arguments) {\n+        super(cause, pattern, arguments);\n         this.argument = argument;\n     }\n \n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n      * @param arguments format arguments\n      * @since 1.2\n      */\n-    public MathConfigurationException(String pattern, Object[] arguments) {\n+    public MathConfigurationException(String pattern, Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n     /**\n      * Constructs an exception with specified formatted detail message and root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param cause  the exception or error that caused this exception to be thrown\n      * @since 1.2\n      */\n-    public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {\n-        super(pattern, arguments, cause);\n+    public MathConfigurationException(Throwable cause, String pattern, Object ... arguments) {\n+        super(cause, pattern, arguments);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n public class MathException extends Exception {\n     \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 5924076008552401454L;\n+    private static final long serialVersionUID = -2803873247432645339L;\n \n     /** Cache for resources bundle. */\n     private static ResourceBundle cachedResources = null;\n \n     /**\n      * Builds a message string by from a pattern and its arguments.\n+     * @param locale Locale in which the message should be translated\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param locale Locale in which the message should be translated\n      * @return a message string\n      */\n-    private static String buildMessage(String pattern, Object[] arguments, Locale locale) {\n+    private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\n         return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n     }\n \n      * @param pattern format specifier\n      * @param arguments format arguments\n      */\n-    public MathException(String pattern, Object[] arguments) {\n-      super(buildMessage(pattern, arguments, Locale.US));\n+    public MathException(String pattern, Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments));\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      * Constructs a new <code>MathException</code> with specified\n      * formatted detail message and nested <code>Throwable</code> root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param rootCause the exception or error that caused this exception\n-     * to be thrown.\n-     * @since 1.2\n-     */\n-    public MathException(String pattern, Object[] arguments, Throwable rootCause) {\n-      super(buildMessage(pattern, arguments, Locale.US), rootCause);\n+     * @since 1.2\n+     */\n+    public MathException(Throwable rootCause, String pattern, Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      * @since 1.2\n      */\n     public String getMessage(Locale locale) {\n-        return buildMessage(pattern, arguments, locale);\n+        return buildMessage(locale, pattern, arguments);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n public class MathRuntimeException extends RuntimeException {\n     \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -143052521750625264L;\n+    private static final long serialVersionUID = 4184290229453587356L;\n \n     /** Cache for resources bundle. */\n     private static ResourceBundle cachedResources = null;\n \n     /**\n      * Builds a message string by from a pattern and its arguments.\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n      * @param locale Locale in which the message should be translated\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n      * @return a message string\n      */\n-    private static String buildMessage(final String pattern, final Object[] arguments,\n-                                       final Locale locale) {\n+    private static String buildMessage(final Locale locale, final String pattern,\n+                                       final Object ... arguments) {\n         return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n     }\n \n      * @param pattern format specifier\n      * @param arguments format arguments\n      */\n-    public MathRuntimeException(final String pattern, final Object[] arguments) {\n-      super(buildMessage(pattern, arguments, Locale.US));\n+    public MathRuntimeException(final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments));\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      * Constructs a new <code>MathRuntimeException</code> with specified\n      * formatted detail message and nested <code>Throwable</code> root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n      * @param rootCause the exception or error that caused this exception\n      * to be thrown.\n-     */\n-    public MathRuntimeException(final String pattern, final Object[] arguments,\n-                                final Throwable rootCause) {\n-      super(buildMessage(pattern, arguments, Locale.US), rootCause);\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final Throwable rootCause,\n+                                final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      * @return localized message\n      */\n     public String getMessage(final Locale locale) {\n-        return buildMessage(pattern, arguments, locale);\n+        return buildMessage(locale, pattern, arguments);\n     }\n \n     /** {@inheritDoc} */\n      * @return built exception\n      */\n     public static ArithmeticException createArithmeticException(final String pattern,\n-                                                                final Object[] arguments) {\n-        return new ArithmeticException(buildMessage(pattern, arguments, Locale.US)) {\n+                                                                final Object ... arguments) {\n+        return new ArithmeticException(buildMessage(Locale.US, pattern, arguments)) {\n \n             /** Serializable version identifier. */\n             private static final long serialVersionUID = 7705628723242533939L;\n \n             /** {@inheritDoc} */\n             public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final String pattern,\n-                                                                                      final Object[] arguments) {\n-        return new ArrayIndexOutOfBoundsException(buildMessage(pattern, arguments, Locale.US)) {\n-\n-            /** Serializable version identifier. */\n-            private static final long serialVersionUID = 8077627622976962141L;\n-\n-            /** {@inheritDoc} */\n-            public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                                                                                      final Object ... arguments) {\n+        return new ArrayIndexOutOfBoundsException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -3394748305449283486L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static EOFException createEOFException(final String pattern,\n-                                                  final Object[] arguments) {\n-        return new EOFException(buildMessage(pattern, arguments, Locale.US)) {\n+                                                  final Object ... arguments) {\n+        return new EOFException(buildMessage(Locale.US, pattern, arguments)) {\n \n             /** Serializable version identifier. */\n             private static final long serialVersionUID = 279461544586092584L;\n \n             /** {@inheritDoc} */\n             public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n-                                                                          final Object[] arguments) {\n-        return new IllegalArgumentException(buildMessage(pattern, arguments, Locale.US)) {\n-\n-            /** Serializable version identifier. */\n-            private static final long serialVersionUID = -7537852425838457684L;\n-\n-            /** {@inheritDoc} */\n-            public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                                                                          final Object ... arguments) {\n+        return new IllegalArgumentException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -6555453980658317913L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static IllegalStateException createIllegalStateException(final String pattern,\n-                                                                    final Object[] arguments) {\n-        return new IllegalStateException(buildMessage(pattern, arguments, Locale.US)) {\n-\n-            /** Serializable version identifier. */\n-            private static final long serialVersionUID = 5173599768297434381L;\n-\n-            /** {@inheritDoc} */\n-            public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                                                                    final Object ... arguments) {\n+        return new IllegalStateException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -95247648156277208L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static ConcurrentModificationException createConcurrentModificationException(final String pattern,\n-                                                                                        final Object[] arguments) {\n-        return new ConcurrentModificationException(buildMessage(pattern, arguments, Locale.US)) {\n+                                                                                        final Object ... arguments) {\n+        return new ConcurrentModificationException(buildMessage(Locale.US, pattern, arguments)) {\n \n             /** Serializable version identifier. */\n             private static final long serialVersionUID = 6134247282754009421L;\n \n             /** {@inheritDoc} */\n             public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * @return built exception\n      */\n     public static NoSuchElementException createNoSuchElementException(final String pattern,\n-                                                                      final Object[] arguments) {\n-        return new NoSuchElementException(buildMessage(pattern, arguments, Locale.US)) {\n+                                                                      final Object ... arguments) {\n+        return new NoSuchElementException(buildMessage(Locale.US, pattern, arguments)) {\n \n             /** Serializable version identifier. */\n             private static final long serialVersionUID = 7304273322489425799L;\n \n             /** {@inheritDoc} */\n             public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n      * Constructs a new <code>ParseException</code> with specified\n      * formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n      * @param offset offset at which error occurred\n-     * @return built exception\n-     */\n-    public static ParseException createParseException(final String pattern,\n-                                                      final Object[] arguments,\n-                                                      final int offset) {\n-        return new ParseException(buildMessage(pattern, arguments, Locale.US), offset) {\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static ParseException createParseException(final int offset,\n+                                                      final String pattern,\n+                                                      final Object ... arguments) {\n+        return new ParseException(buildMessage(Locale.US, pattern, arguments), offset) {\n \n             /** Serializable version identifier. */\n             private static final long serialVersionUID = -1103502177342465975L;\n \n             /** {@inheritDoc} */\n             public String getLocalizedMessage() {\n-                return buildMessage(pattern, arguments, Locale.getDefault());\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n             }\n \n         };\n--- a/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n public class MaxIterationsExceededException extends ConvergenceException {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -2154780004193976271L;\n+    private static final long serialVersionUID = -7821226672760574694L;\n \n     /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n+    private final int maxIterations;\n \n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param maxIterations maximal number of iterations allowed\n      */\n-    public MaxIterationsExceededException(int maxIterations) {\n-        super(\"Maximal number of iterations ({0}) exceeded\",\n-              new Object[] { Integer.valueOf(maxIterations) });\n+    public MaxIterationsExceededException(final int maxIterations) {\n+        super(\"Maximal number of iterations ({0}) exceeded\", maxIterations);\n         this.maxIterations = maxIterations;\n     }\n \n      * @param pattern format specifier\n      * @param arguments format arguments\n      */\n-    public MaxIterationsExceededException(int maxIterations,\n-                                          String pattern, Object[] arguments) {\n+    public MaxIterationsExceededException(final int maxIterations,\n+                                          final String pattern, final Object ... arguments) {\n         super(pattern, arguments);\n         this.maxIterations = maxIterations;\n     }\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.util.MathUtils\n     { \"overflow: gcd({0}, {1}) is 2^31\",\n       \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^31\" },\n-      \n+        \n     // org.apache.commons.math.FunctionEvaluationException\n     { \"Evaluation failed for argument = {0}\",\n       \"Erreur d''\\u00e9valuation pour l''argument {0}\" },\n      \"impossible de mettre un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n    { \"cannot substitute an element from an empty array\",\n      \"impossible de substituer un \\u00e9l\\u00e9ment dans un tableau vide\" },\n+   { \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n+     \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n+     \"internal storage array would immediately satisfy the criteria for contraction.\",\n+     \"crit\\u00e8re de contraction ({0}) inf\\u00e9rieur au facteur d''extension. Ceci \" +\n+     \"induit une boucle infinie d''extensions/contractions car tout tableau de stockage \" +\n+     \"fra\\u00eechement \\u00e9tendu respecte imm\\u00e9diatement le crit\\u00e8re de contraction.\"},\n+   { \"contraction criteria smaller than one ({0}).  This would lead to a never ending \" +\n+     \"loop of expansion and contraction as an internal storage array length equal \" +\n+     \"to the number of elements would satisfy the contraction criteria.\",\n+     \"crit\\u00e8re de contraction inf\\u00e9rieur \\u00e0 un ({0}). Ceci induit une boucle \" +\n+     \"infinie d''extensions/contractions car tout tableau de stockage de longueur \\u00e9gale \" +\n+     \"au nombre d''\\u00e9l\\u00e9ments respecte le crit\\u00e8re de contraction.\" },\n+   { \"expansion factor smaller than one ({0})\",\n+     \"facteur d''extension inf\\u00e9rieur \\u00e0 un ({0})\"},\n+   { \"cannot discard {0} elements from a {1} elements array\",\n+     \"impossible d''enlever {0} \\u00e9l\\u00e9ments d''un tableau en contenant {1}\"},\n+   { \"cannot discard a negative number of elements ({0})\",\n+     \"impossible d''enlever un nombre d''\\u00e9l\\u00e9ments{0} n\\u00e9gatif\"},\n+   { \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n+     \"mode d''extension {0} no support\\u00e9, les modes support\\u00e9s sont {1} ({2}) et {3} ({4})\" },\n+   { \"initial capacity ({0}) is not positive\",\n+     \"la capacit\\u00e9 initiale ({0}) n''est pas positive\" },\n+   { \"index ({0}) is not positive\",\n+     \"l''indice ({0}) n''est pas positif\" },\n \n    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n    { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n      \"mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})\" },\n    { \"digest not initialized\",\n      \"mod\\u00e8le empirique non initialis\\u00e9\" },\n+\n+   // org.apache.commons.math.stat.correlation.Covariance\n+   { \"arrays must have the same length and both must have at \" +\n+     \"least two elements. xArray has size {0}, yArray has {1} elements\",\n+     \"les tableaux doivent avoir la m\\u00eame taille et comporter au moins deux \\u00e9l\\u00e9ments. \" +\n+     \"xArray a une taille de {0}, yArray a {1} \\u00e9l\\u00e9ments\"},\n+   { \"insufficient data: only {0} rows and {1} columns.\",\n+     \"donn\\u00e9es insuffisantes : seulement {0} lignes et {1} colonnes.\" },\n+\n+   // org.apache.commons.math.stat.correlation.PearsonsCorrelation\n+   { \"covariance matrix is null\",\n+     \"la matrice de covariance est nulle\" },\n+   { \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n+     \"dimensions de tableaux invalides. xArray a une taille de {0}, yArray a {1} \\u00e9l\\u00e9ments\" },\n \n    // org.apache.commons.math.stat.descriptive.moment.GeometricMean\n    // org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics\n--- a/src/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"{0} points Legendre-Gauss integrator not supported, \" +\n                     \"number of points must be in the {1}-{2} range\",\n-                    new Object[] { n, 2, 5 });\n+                    n, 2, 5);\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n         if (maximalIterationCount > 32) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid iteration limits: min={0}, max={1}\",\n-                    new Object[] { 0, 32 });\n+                    0, 32);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n         if (maximalIterationCount > 64) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid iteration limits: min={0}, max={1}\",\n-                    new Object[] { 0, 64 });\n+                    0, 64);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n         if (maximalIterationCount > 64) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid iteration limits: min={0}, max={1}\",\n-                    new Object[] { 0, 64 });\n+                    0, 64);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n         if (resultComputed) {\n             return result;\n         } else {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n         }\n     }\n \n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    new Object[] { lower, upper });\n+                    lower, upper);\n         }       \n     }\n \n         if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid iteration limits: min={0}, max={1}\",\n-                    new Object[] { minimalIterationCount, maximalIterationCount });\n+                    minimalIterationCount, maximalIterationCount);\n         }       \n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizerImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizerImpl.java\n      */\n     protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n         try {\n             return evaluate(x, y, z);\n         } catch (DuplicateSampleAbscissaException e) {\n-            throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);\n+            throw new FunctionEvaluationException(e, z, e.getPattern(), e.getArguments());\n         }\n     }\n \n                 for (int k = 0; k < n; ++k) {\n                     if ((i != k) && (x[i] == x[k])) {\n                         throw MathRuntimeException.createArithmeticException(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n-                                                                             new Object[] {\n-                                                                                 i, k, x[i]\n-                                                                             });\n+                                                                             i, k, x[i]);\n                     }\n                 }\n             }\n--- a/src/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"function values at endpoints do not have different signs.  \" +\n                         \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                        new Object[] { min, max, yMin, yMax });       \n+                        min, max, yMin, yMax);       \n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n--- a/src/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n         if (f instanceof PolynomialFunction) {\n             p = (PolynomialFunction) f;\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n         }\n     }\n \n \n         // check function type\n         if (!(f instanceof PolynomialFunction)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n         }\n \n         // check for zeros before verifying bracketing\n--- a/src/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n             throw new MaxIterationsExceededException(maximalIterationCount);\n         } catch (ClassCastException cce) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\",\n-                                                                      null);\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\");\n         }\n     }\n     \n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n                                        final double defaultAbsoluteAccuracy) {\n         super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n         if (f == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\",\n-                                                                      null);\n+            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n         }\n         this.f = f;\n         this.defaultFunctionValueAccuracy = 1.0e-15;\n      */\n     protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n         }\n     }\n \n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n-                    new Object[] { lower, upper });\n+                    lower, upper);\n         }       \n     }\n     \n         if (!isSequence(lower, initial, upper)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n-                    new Object[] { lower, initial, upper });\n+                    lower, initial, upper);\n         }       \n     }\n     \n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"function values at endpoints do not have different signs.  \" +\n                     \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                    new Object[] { lower, upper, f.value(lower), f.value(upper) });       \n+                    lower, upper, f.value(lower), f.value(upper));       \n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException\n             (\"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n-             new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),\n-                            Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),\n-                            Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });\n+             numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n     public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n \n         if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"cannot compute nth root for null or negative n: {0}\",\n-                    new Object[] { n });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot compute nth root for null or negative n: {0}\",\n+                    n);\n         }\n         \n         List<Complex> result = new ArrayList<Complex>();\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n         ParsePosition parsePosition = new ParsePosition(0);\n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\"unparseable complex number: \\\"{0}\\\"\",\n-                                                            new Object[] { source },\n-                                                            parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable complex number: \\\"{0}\\\"\", source);\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n                 try {\n                     return cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n-                    throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);\n+                    throw new FunctionEvaluationException(ex, x, ex.getPattern(), ex.getArguments());\n                 }\n             }\n         };\n--- a/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n             return 0;\n         } else if (x == 0) {\n             if (alpha < 1) {\n-                throw new MathException(\"Cannot compute beta density at 0 when alpha = {0,number}\", new Double[]{alpha});\n+                throw new MathException(\"Cannot compute beta density at 0 when alpha = {0,number}\", alpha);\n             }\n             return 0;\n         } else if (x == 1) {\n             if (beta < 1) {\n-                throw new MathException(\"Cannot compute beta density at 1 when beta = %.3g\", new Double[]{beta});\n+                throw new MathException(\"Cannot compute beta density at 1 when beta = %.3g\", beta);\n             }\n             return 0;\n         } else {\n--- a/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n     public void setNumberOfElements(final int n)\n         throws IllegalArgumentException {\n         if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"invalid number of elements {0}\" +\n-                                                                      \" (must be positive)\",\n-                                                                      new Object[] { n });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid number of elements {0} (must be positive)\",\n+                    n);\n         }\n         this.numberOfElements = n;\n     }\n     public void setExponent(final double s)\n         throws IllegalArgumentException {\n         if (s <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"invalid exponent {0} (must be positive)\",\n-                                                                      new Object[] { s });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid exponent {0} (must be positive)\",\n+                    s);\n         }\n         this.exponent = s;\n     }\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n         if (++costEvaluations > maxCostEval) {\n             throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n-                                          new Object[] { Integer.valueOf(maxCostEval) });\n+                                          maxCostEval);\n         }\n \n         cost = 0;\n                 new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n             return inverse.getData();\n         } catch (InvalidMatrixException ime) {\n-            throw new EstimationException(\"unable to compute covariances: singular problem\",\n-                                          null);\n+            throw new EstimationException(\"unable to compute covariances: singular problem\");\n         }\n \n     }\n         int m = problem.getMeasurements().length;\n         int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n-            throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n-                                          new Object[] { Integer.valueOf(m), Integer.valueOf(p)});\n+            throw new EstimationException(\n+                    \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+                    m, p);\n         }\n         double[] errors = new double[problem.getUnboundParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n--- a/src/java/org/apache/commons/math/estimation/EstimationException.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimationException.java\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n      */\n-    public EstimationException(String specifier, Object[] parts) {\n+    public EstimationException(String specifier, Object ... parts) {\n         super(specifier, parts);\n     }\n \n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n                 }\n \n             } catch(InvalidMatrixException e) {\n-                throw new EstimationException(\"unable to solve: singular problem\", null);\n+                throw new EstimationException(\"unable to solve: singular problem\");\n             }\n \n \n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n           throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n                                         \" no further reduction in the\" +\n                                         \" sum of squares is possible\",\n-                                        new Object[] { Double.valueOf(costRelativeTolerance) });\n+                                        costRelativeTolerance);\n         } else if (delta <= 2.2204e-16 * xNorm) {\n           throw new EstimationException(\"parameters relative tolerance is too small\" +\n                                         \" ({0}), no further improvement in\" +\n                                         \" the approximate solution is possible\",\n-                                        new Object[] { Double.valueOf(parRelativeTolerance) });\n+                                        parRelativeTolerance);\n         } else if (maxCosine <= 2.2204e-16)  {\n           throw new EstimationException(\"orthogonality tolerance is too small ({0}),\" +\n                                         \" solution is orthogonal to the jacobian\",\n-                                        new Object[] { Double.valueOf(orthoTolerance) });\n+                                        orthoTolerance);\n         }\n \n       }\n           norm2 += aki * aki;\n         }\n         if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-            throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n-                                          new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n+            throw new EstimationException(\n+                    \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                    rows, cols);\n         }\n         if (norm2 > ak2) {\n           nextColumn = i;\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n         super();\n         if (den == 0) {\n             throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n-                                                                 new Object[] { num, den});\n+                                                                 num, den);\n         }\n         if (den < 0) {\n             if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                 throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n-                                                                     new Object[] { num, den});\n+                                                                     num, den);\n             }\n             num = -num;\n             den = -den;\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n             throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n-                                                                 new Object[] { numerator, denominator});\n+                                                                 numerator, denominator);\n         }\n         return new Fraction(-numerator, denominator);\n     }\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n             throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n-                                                                 new Object[] { w });\n+                                                                 w);\n         }\n         return new Fraction (w.intValue(), \n                 MathUtils.mulAndCheck(denominator/d1, \n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n         if (fraction.numerator == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"the fraction to divide by must not be zero: {0}/{1}\",\n-                                                                 new Object[] { fraction.numerator, fraction.denominator });\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"the fraction to divide by must not be zero: {0}/{1}\",\n+                    fraction.numerator, fraction.denominator);\n         }\n         return multiply(fraction.reciprocal());\n     }\n      */\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n-                                                                 new Object[] { numerator, denominator});\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"zero denominator in fraction {0}/{1}\",\n+                    numerator, denominator);\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n         if (denominator < 0) {\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n-                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n-                                                                     new Object[] { numerator, denominator});\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow in fraction {0}/{1}, cannot negate\",\n+                        numerator, denominator);\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n--- a/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n      * @param maxIterations maximal number of iterations allowed\n      */\n     public FractionConversionException(double value, int maxIterations) {\n-        super(\"Unable to convert {0} to fraction after {1} iterations\",\n-              new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });\n+        super(\"Unable to convert {0} to fraction after {1} iterations\", value, maxIterations);\n     }\n \n     /**\n      * @param q current denominator\n      */\n     public FractionConversionException(double value, long p, long q) {\n-        super(\"Overflow trying to convert {0} to fraction ({1}/{2})\",\n-              new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });\n+        super(\"Overflow trying to convert {0} to fraction ({1}/{2})\", value, p, q);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n         ParsePosition parsePosition = new ParsePosition(0);\n         Fraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\"unparseable fraction number: \\\"{0}\\\"\",\n-                                                            new Object[] { source },\n-                                                            parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable fraction number: \\\"{0}\\\"\", source);\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n    * if false it is related to EulerAngles\n    */\n   public CardanEulerSingularityException(boolean isCardan) {\n-    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\", null);\n+    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n   }\n \n   /** Serializable version identifier */\n--- a/src/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+++ b/src/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public NotARotationMatrixException(String specifier, Object[] parts) {\n+  public NotARotationMatrixException(String specifier, Object ... parts) {\n     super(specifier, parts);\n   }\n \n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n \n     double norm = axis.getNorm();\n     if (norm == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\",\n-                                                           null);\n+      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\");\n     }\n \n     double halfAngle = -0.5 * angle;\n     // dimension check\n     if ((m.length != 3) || (m[0].length != 3) ||\n         (m[1].length != 3) || (m[2].length != 3)) {\n-      throw new NotARotationMatrixException(\"a {0}x{1} matrix\" +\n-                                            \" cannot be a rotation matrix\",\n-                                            new Object[] {\n-                                              Integer.toString(m.length),\n-                                              Integer.toString(m[0].length)\n-                                            });\n+      throw new NotARotationMatrixException(\n+              \"a {0}x{1} matrix cannot be a rotation matrix\",\n+              m.length, m[0].length);\n     }\n \n     // compute a \"close\" orthogonal matrix\n                  ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n                  ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n     if (det < 0.0) {\n-      throw new NotARotationMatrixException(\"the closest orthogonal matrix\" +\n-                                            \" has a negative determinant {0}\",\n-                                            new Object[] {\n-                                              Double.toString(det)\n-                                            });\n+      throw new NotARotationMatrixException(\n+              \"the closest orthogonal matrix has a negative determinant {0}\",\n+              det);\n     }\n \n     // There are different ways to compute the quaternions elements\n     }\n \n     // the algorithm did not converge after 10 iterations\n-    throw new NotARotationMatrixException(\"unable to orthogonalize matrix\" +\n-                                          \" in {0} iterations\",\n-                                          new Object[] {\n-                                            Integer.toString(i - 1)\n-                                          });\n+    throw new NotARotationMatrixException(\n+            \"unable to orthogonalize matrix in {0} iterations\",\n+            i - 1);\n   }\n \n   /** Compute the <i>distance</i> between two rotations.\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n   public Vector3D normalize() {\n     double s = getNorm();\n     if (s == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n-                                                           null);\n+      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n     }\n     return scalarMultiply(1 / s);\n   }\n \n     double threshold = 0.6 * getNorm();\n     if (threshold == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n     }\n \n     if ((x >= -threshold) && (x <= threshold)) {\n \n     double normProduct = v1.getNorm() * v2.getNorm();\n     if (normProduct == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n     }\n \n     double dot = dotProduct(v1, v2);\n--- a/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\"unparseable 3D vector: \\\"{0}\\\"\",\n-                                                            new Object[] { source },\n-                                                            parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable 3D vector: \\\"{0}\\\"\", source);\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n         if (rowDimension <= 0 ) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"invalid row dimension {0}\" +\n-                                                                      \" (must be positive)\",\n-                                                                      new Object[] { rowDimension });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n         }\n         if (columnDimension <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"invalid column dimension {0}\" +\n-                                                                      \" (must be positive)\",\n-                                                                      new Object[] { columnDimension });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n         }\n         lu = null;\n     }\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                    new Object[] {\n-                        destination.length, destination[0].length,\n-                        rowsCount, columnsCount\n-                    });\n+                    destination.length, destination[0].length,\n+                    rowsCount, columnsCount);\n         }\n \n         // copy entries\n             (destination[0].length < selectedColumns.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                    new Object[] {\n-                        destination.length, destination[0].length,\n-                        selectedRows.length, selectedColumns.length\n-                    });\n+                    destination.length, destination[0].length,\n+                    selectedRows.length, selectedColumns.length);\n         }\n \n         // copy entries\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\",\n-                                                                      null); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n-                                                                      null); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n-                                                                          new Object[] {\n-                                                                              nCols, subMatrix[r].length\n-                                                                          }); \n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        nCols, subMatrix[r].length); \n             }\n         }\n \n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, matrix.getEntry(0, i));\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, matrix.getEntry(i, 0));\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 1, vector.getDimension(),\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, vector.getDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, vector.getEntry(i));\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 vector.getDimension(), 1,\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    vector.getDimension(), 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, vector.getEntry(i));\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 1, array.length,\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, array[i]);\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 array.length, 1,\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, array[i]);\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, nCols\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n         }\n \n         final double[] out = new double[nRows];\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                          \" got {0} but expected {1}\",\n-                                                                          new Object[] {\n-                                                                              v.getDimension(), nCols\n-                                                                          });\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nCols);\n             }\n \n             final double[] out = new double[nRows];\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, nRows\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                          \" got {0} but expected {1}\",\n-                                                                          new Object[] {\n-                                                                              v.getDimension(), nRows\n-                                                                          });\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nRows);\n             }\n \n             final double[] out = new double[nCols];\n     protected void checkRowIndex(final int row) {\n         if (row < 0 || row >= getRowDimension()) {\n             throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { row, 0, getRowDimension() - 1});\n+                                           row, 0, getRowDimension() - 1);\n         }\n     }\n \n         throws MatrixIndexException {\n         if (column < 0 || column >= getColumnDimension()) {\n             throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { column, 0, getColumnDimension() - 1});\n+                                           column, 0, getColumnDimension() - 1);\n         }\n     }\n \n         checkRowIndex(endRow);\n         if (startRow > endRow) {\n             throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n-                                           new Object[] { startRow, endRow });\n+                                           startRow, endRow);\n         }\n \n         checkColumnIndex(startColumn);\n         checkColumnIndex(endColumn);\n         if (startColumn > endColumn) {\n             throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n-                                           new Object[] { startColumn, endColumn });\n+                                           startColumn, endColumn);\n         }\n \n     \n     protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", null);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", null);\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n         }\n \n         for (final int row : selectedRows) {\n     protected void checkAdditionCompatible(final RealMatrix m) {\n         if ((getRowDimension()    != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" addition compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n         }\n     }\n \n     protected void checkSubtractionCompatible(final RealMatrix m) {\n         if ((getRowDimension()    != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" subtraction compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n         }\n     }\n \n      */\n     protected void checkMultiplicationCompatible(final RealMatrix m) {\n         if (getColumnDimension() != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0}x{1} and {2}x{3} matrices are not\" +\n-                                                                      \" multiplication compatible\",\n-                                                                      new Object[] {\n-                                                                          getRowDimension(),\n-                                                                          getColumnDimension(),\n-                                                                          m.getRowDimension(),\n-                                                                          m.getColumnDimension()\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n         checkRowIndex(endRow);\n         if (startRow > endRow) {\n             throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n-                                           new Object[] { startRow, endRow });\n+                                           startRow, endRow);\n         }\n \n         checkColumnIndex(startColumn);\n         checkColumnIndex(endColumn);\n         if (startColumn > endColumn) {\n             throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n-                                           new Object[] { startColumn, endColumn });\n+                                           startColumn, endColumn);\n         }\n \n         final BigDecimal[][] subMatrixData =\n \n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", null);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", null);\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n         }\n \n         final BigDecimal[][] subMatrixData =\n \n         if (data == null) {\n             if (row > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\"first {0} rows are not initialized yet\",\n-                                                                       new Object[] { row });\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n             }\n             if (column > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\"first {0} columns are not initialized yet\",\n-                                                                       new Object[] { column });\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n             }\n             data = new BigDecimal[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n         try {\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n     \n      */\n     public BigDecimal getTrace() throws IllegalArgumentException {\n         if (!isSquare()) {\n-            throw new IllegalArgumentException(\"matrix is not square\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         BigDecimal trace = data[0][0];\n         for (int i = 1; i < this.getRowDimension(); i++) {\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n     public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n-        if (v.length != this.getColumnDimension()) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n+        if (v.length != getColumnDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, getColumnDimension() );\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n     public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows );\n         }\n         final int nCols = this.getColumnDimension();\n         final BigDecimal[] out = new BigDecimal[nCols];\n     public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n         final int nRows = this.getRowDimension();\n         if (b.length != nRows) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    b.length, nRows);\n         }\n         final BigMatrix bMatrix = new BigMatrixImpl(b);\n         final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (b.getRowDimension() != this.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (!this.isSquare()) {\n+        if (b.getRowDimension() != getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    b.getRowDimension(), b.getColumnDimension(), getRowDimension(), \"n\");\n+        }\n+        if (!isSquare()) {\n             throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         if (this.isSingular()) { // side effect: compute LU decomp\n      */\n     private void checkRowIndex(final int row) {\n         if (row < 0 || row >= getRowDimension()) {\n-            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { row, 0, getRowDimension() - 1});\n+            throw new MatrixIndexException(\n+                    \"row index {0} out of allowed range [{1}, {2}]\",\n+                    row, 0, getRowDimension() - 1);\n         }\n     }\n \n     private void checkColumnIndex(final int column)\n         throws MatrixIndexException {\n         if (column < 0 || column >= getColumnDimension()) {\n-            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { column, 0, getColumnDimension() - 1});\n+            throw new MatrixIndexException(\n+                    \"column index {0} out of allowed range [{1}, {2}]\",\n+                    column, 0, getColumnDimension() - 1);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n             final int iHeight = blockHeight(iBlock);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                 if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\"wrong array shape (block length = {0}, expected {1})\",\n-                                                                              new Object[] {\n-                                                                                  blockData[index].length,\n-                                                                                  iHeight * blockWidth(jBlock)\n-                                                                              });\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n                 }\n                 if (copyArray) {\n                     blocks[index] = blockData[index].clone();\n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        new Object[] { columns, length }); \n+                        columns, length); \n             }\n         }\n \n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n-                                                                      null);             \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         checkSubMatrixIndex(row, endRow, column, endColumn);\n         for (final double[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n-                                                                          new Object[] {\n-                                                                              refLength, subRow.length\n-                                                                          }); \n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n             }\n         }\n \n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 matrix.getRowDimension(),\n-                                                 matrix.getColumnDimension(),\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 1, array.length,\n-                                                 1, nCols\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                                             new Object[] {\n-                                                 array.length, 1,\n-                                                 nRows, 1\n-                                             });\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                                (column - jBlock * BLOCK_SIZE);\n             return blocks[iBlock * blockColumns + jBlock][k];\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n                                (column - jBlock * BLOCK_SIZE);\n             blocks[iBlock * blockColumns + jBlock][k] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n                                (column - jBlock * BLOCK_SIZE);\n             blocks[iBlock * blockColumns + jBlock][k] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n                                (column - jBlock * BLOCK_SIZE);\n             blocks[iBlock * blockColumns + jBlock][k] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         throws IllegalArgumentException {\n \n         if (v.length != columns) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, columns\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n         }\n         final double[] out = new double[rows];\n \n         throws IllegalArgumentException {\n \n         if (v.length != rows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, rows\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n         }\n         final double[] out = new double[columns];\n \n--- a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n      * @param arguments format arguments\n      * @since 2.0\n      */\n-    public InvalidMatrixException(final String pattern, final Object[] arguments) {\n+    public InvalidMatrixException(final String pattern, final Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n--- a/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n      * @param pattern format specifier\n      * @param arguments format arguments\n      */\n-    public MatrixIndexException(final String pattern, final Object[] arguments) {\n+    public MatrixIndexException(final String pattern, final Object ... arguments) {\n       super(pattern, arguments);\n     }\n \n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n             }   \n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\",\n-                                                                          null); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n-                                                                          null); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while\" +\n-                                                                              \" others have length {1}\",\n-                                                                              new Object[] { nCols, d[r].length });\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n                 }\n             }       \n             data = d;\n     throws MatrixIndexException {\n         if (data == null) {\n             if (row > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\"first {0} rows are not initialized yet\",\n-                                                                       new Object[] { row });\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n             }\n             if (column > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\"first {0} columns are not initialized yet\",\n-                                                                       new Object[] { column });\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\",\n-                                                                          null); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\",\n-                                                                          null); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n-                                                                              new Object[] {\n-                                                                                  nCols, subMatrix[i].length\n-                                                                              }); \n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n         try {\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         try {\n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         try {\n             data[row][column] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }      \n     }\n \n         try {\n             data[row][column] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                                           new Object[] {\n-                                               row, column,\n-                                               getRowDimension(), getColumnDimension()\n-                                           });\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n         }      \n     }\n \n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, nCols\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n         }\n         final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch:\" +\n-                                                                      \" got {0} but expected {1}\",\n-                                                                      new Object[] {\n-                                                                          v.length, nRows\n-                                                                      });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n--- a/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n         ParsePosition parsePosition = new ParsePosition(0);\n         RealVectorImpl result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\"unparseable real vector: \\\"{0}\\\"\",\n-                                                            new Object[] { source },\n-                                                            parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable real vector: \\\"{0}\\\"\", source);\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n     public RealVector unitVector() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n+            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n         }\n         return mapDivide(getNorm());\n     }\n     public void unitize() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n-                                                                 null);\n+            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n         }\n         for (int i = 0; i < data.length; i++) {\n             data[i] /= norm;\n     private void checkIndex(final int index)\n         throws MatrixIndexException {\n         if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(\"index {0} out of allowed range [{1}, {2}]\",\n-                                           new Object[] { index, 0, getDimension() - 1});\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n     public void unitize() {\n         double norm = getNorm();\n         if(isZero(norm)){\n-            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n-                    null);\n+            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n             \n         }\n         Iterator iter = entries.iterator();\n         if (index < 0 || index >= getDimension()) {\n             throw new MatrixIndexException(\n                     \"index {0} out of allowed range [{1}, {2}]\",\n-                    new Object[] { index, 0, getDimension() - 1 });\n+                    index, 0, getDimension() - 1);\n         }\n     }\n \n         if (getDimension() != n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"vector length mismatch: got {0} but expected {1}\",\n-                    new Object[] { getDimension(), n });\n+                    getDimension(), n);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/decomposition/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/CholeskyDecompositionImpl.java\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.length, m });\n+                        b.length, m);\n             }\n \n             final double[] x = b.clone();\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                             \"vector length mismatch: got {0} but expected {1}\",\n-                            new Object[] { b.getDimension(), m });\n+                            b.getDimension(), m);\n                 }\n \n                 final double[] x = b.getData();\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        new Object[] { b.getRowDimension(), b.getColumnDimension(), m, \"n\"});\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n \n             final int nColB = b.getColumnDimension();\n--- a/src/java/org/apache/commons/math/linear/decomposition/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/EigenDecompositionImpl.java\n         } else {\n             // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported\n             // see issue https://issues.apache.org/jira/browse/MATH-235\n-            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\",\n-                                             null);\n+            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n         }\n     }\n \n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.length, m });\n+                        b.length, m);\n             }\n \n             final double[] bp = new double[m];\n             if (b.getDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.getDimension(), m });\n+                        b.getDimension(), m);\n             }\n \n             final double[] bp = new double[m];\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        new Object[] {\n-                                b.getRowDimension(), b.getColumnDimension(),\n-                                m, \"n\"\n-                        });\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n \n             final int nColB = b.getColumnDimension();\n         final double p     = q0 * q1 - e12;\n         final double delta = s * s - 4 * p;\n         if (delta < 0) {\n-            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 2 });\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n         }\n \n         final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n             // in fact, there are solutions to the equation, but in the context\n             // of symmetric realEigenvalues problem, there should be three distinct\n             // real roots, so we throw an error if this condition is not met\n-            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 3 });           \n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);           \n         }\n         final double sqrtMq = Math.sqrt(-q);\n         final double theta  = Math.acos(r / (-q * sqrtMq));\n--- a/src/java/org/apache/commons/math/linear/decomposition/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/LUDecompositionImpl.java\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.length, m });\n+                        b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                             \"vector length mismatch: got {0} but expected {1}\",\n-                            new Object[] { b.getDimension(), m });\n+                            b.getDimension(), m);\n                 }\n                 if (singular) {\n                     throw new SingularMatrixException();\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        new Object[] { b.getRowDimension(), b.getColumnDimension(), m, \"n\"});\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n--- a/src/java/org/apache/commons/math/linear/decomposition/NonSquareMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/NonSquareMatrixException.java\n      */\n     public NonSquareMatrixException(final int rows, final int columns) {\n         super(\"a {0}x{1} matrix was provided instead of a square matrix\",\n-              new Object[] { rows, columns });\n+              rows, columns);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/decomposition/NotPositiveDefiniteMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/NotPositiveDefiniteMatrixException.java\n      * build an exception with a default message.\n      */\n     public NotPositiveDefiniteMatrixException() {\n-        super(\"not positive definite matrix\", null);\n+        super(\"not positive definite matrix\");\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/decomposition/NotSymmetricMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/NotSymmetricMatrixException.java\n      * build an exception with a default message.\n      */\n     public NotSymmetricMatrixException() {\n-        super(\"not symmetric matrix\", null);\n+        super(\"not symmetric matrix\");\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/decomposition/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/QRDecompositionImpl.java\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.length, m });\n+                        b.length, m);\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        new Object[] { b.getRowDimension(), b.getColumnDimension(), m, \"n\"});\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n--- a/src/java/org/apache/commons/math/linear/decomposition/SingularMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/SingularMatrixException.java\n      * Construct an exception with a default message.\n      */\n     public SingularMatrixException() {\n-        super(\"matrix is singular\", null);\n+        super(\"matrix is singular\");\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/decomposition/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/SingularValueDecompositionImpl.java\n             if (b.length != singularValues.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.length, singularValues.length });\n+                        b.length, singularValues.length);\n             }\n \n             final double[] w = uT.operate(b);\n             if (b.getDimension() != singularValues.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"vector length mismatch: got {0} but expected {1}\",\n-                        new Object[] { b.getDimension(), singularValues.length });\n+                         b.getDimension(), singularValues.length);\n             }\n \n             final RealVector w = uT.operate(b);\n             if (b.getRowDimension() != singularValues.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        new Object[] {\n-                                b.getRowDimension(), b.getColumnDimension(),\n-                                singularValues.length, \"n\"\n-                        });\n+                        b.getRowDimension(), b.getColumnDimension(),\n+                        singularValues.length, \"n\");\n             }\n \n             final RealMatrix w = uT.multiply(b);\n--- a/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n         throws IntegratorException {\n \n         if (equations.getDimension() != y0.length) {\n-            throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n-                                          \" initial state vector has dimension {1}\",\n-                                          new Object[] {\n-                                              Integer.valueOf(equations.getDimension()),\n-                                              Integer.valueOf(y0.length)\n-                                          });\n+            throw new IntegratorException(\n+                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n+                    \" initial state vector has dimension {1}\",\n+                    equations.getDimension(), y0.length);\n         }\n \n         if (equations.getDimension() != y.length) {\n-            throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n-                                          \" final state vector has dimension {1}\",\n-                                          new Object[] {\n-                                              Integer.valueOf(equations.getDimension()),\n-                                              Integer.valueOf(y.length)\n-                                          });\n+            throw new IntegratorException(\n+                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n+                    \" final state vector has dimension {1}\",\n+                    equations.getDimension(), y.length);\n         }\n \n         if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n-            throw new IntegratorException(\"too small integration interval: length = {0}\",\n-                                          new Object[] {\n-                                              Double.valueOf(Math.abs(t - t0))\n-                                          });\n+            throw new IntegratorException(\n+                    \"too small integration interval: length = {0}\",\n+                    Math.abs(t - t0));\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n       steps.get(index).setInterpolatedTime(time);\n \n     } catch (DerivativeException de) {\n-      throw new MathRuntimeException(\"unexpected exception caught\", null, de);\n+      throw new MathRuntimeException(de, \"unexpected exception caught\");\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/java/org/apache/commons/math/ode/DerivativeException.java\n public class DerivativeException\n   extends MathException {\n     \n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 5666710788967425123L;\n+\n   /** Simple constructor.\n    * Build an exception by translating and formating a message\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public DerivativeException(final String specifier, final Object[] parts) {\n+  public DerivativeException(final String specifier, final Object ... parts) {\n     super(specifier, parts);\n   }\n \n     super(cause);\n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -4100440615830558122L;\n-\n }\n--- a/src/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n  */\n public class IntegratorException\n   extends MathException {\n-    \n+\n+  /** Serializable version identifier */\n+    private static final long serialVersionUID = -1607588949778036796L;\n+\n   /** Simple constructor.\n    * Build an exception by translating and formating a message\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public IntegratorException(final String specifier, final Object[] parts) {\n+  public IntegratorException(final String specifier, final Object ... parts) {\n     super(specifier, parts);\n   }\n \n     super(cause);\n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -1215318282266670558L;\n-\n }\n--- a/src/java/org/apache/commons/math/ode/events/EventException.java\n+++ b/src/java/org/apache/commons/math/ode/events/EventException.java\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n      */\n-    public EventException(final String specifier, final Object[] parts) {\n+    public EventException(final String specifier, final Object ... parts) {\n         super(specifier, parts);\n     }\n \n--- a/src/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/java/org/apache/commons/math/ode/events/EventState.java\n                                 interpolator.setInterpolatedTime(t);\n                                 return handler.g(t, interpolator.getInterpolatedState());\n                             } catch (DerivativeException e) {\n-                                throw new FunctionEvaluationException(t, e);\n+                                throw new FunctionEvaluationException(e, t);\n                             } catch (EventException e) {\n-                                throw new FunctionEvaluationException(t, e);\n+                                throw new FunctionEvaluationException(e, t);\n                             }\n                         }\n                     };\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n       super.sanityChecks(equations, t0, y0, t, y);\n \n       if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n-          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n-                                        \" absolute tolerance vector has dimension {1}\",\n-                                        new Object[] {\n-                                          Integer.valueOf(y0.length),\n-                                          Integer.valueOf(vecAbsoluteTolerance.length)\n-                                        });\n+          throw new IntegratorException(\n+                  \"dimensions mismatch: state vector has dimension {0},\" +\n+                  \" absolute tolerance vector has dimension {1}\",\n+                  y0.length, vecAbsoluteTolerance.length);\n       }\n \n       if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n-          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n-                                        \" relative tolerance vector has dimension {1}\",\n-                                        new Object[] {\n-                                          Integer.valueOf(y0.length),\n-                                          Integer.valueOf(vecRelativeTolerance.length)\n-                                        });\n+          throw new IntegratorException(\n+                  \"dimensions mismatch: state vector has dimension {0},\" +\n+                  \" relative tolerance vector has dimension {1}\",\n+                  y0.length, vecRelativeTolerance.length);\n       }\n \n   }\n           if (acceptSmall) {\n               filteredH = forward ? minStep : -minStep;\n           } else {\n-              throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n-                                            \" integration needs {1}\",\n-                                            new Object[] {\n-                                                Double.valueOf(minStep),\n-                                                Double.valueOf(Math.abs(h))\n-                                            });\n+              throw new IntegratorException(\n+                      \"minimal step size ({0}) reached, integration needs {1}\",\n+                      minStep, Math.abs(h));\n           }\n       }\n \n--- a/src/java/org/apache/commons/math/optimization/CostException.java\n+++ b/src/java/org/apache/commons/math/optimization/CostException.java\n      * @param pattern format specifier\n      * @param arguments format arguments\n      */\n-    public CostException(String pattern, Object[] arguments) {\n+    public CostException(String pattern, Object ... arguments) {\n       super(pattern, arguments);\n     }\n \n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n \n         } catch (DimensionMismatchException dme) {\n             // this should not happen\n-            throw new MathRuntimeException(\"unexpected exception caught\", null, dme);\n+            throw new MathRuntimeException(dme, \"unexpected exception caught\");\n         }\n \n     }\n \n         // return the found point given the lowest cost\n         if (minima[0] == null) {\n-            throw new ConvergenceException(\"none of the {0} start points\" +\n-                                           \" lead to convergence\",\n-                                           new Object[] {\n-                                             Integer.toString(starts)\n-                                           });\n+            throw new ConvergenceException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n         }\n         return minima[0];\n \n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n             }\n             if (sampleStats.getN() == 0) {\n                 throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n-                                                              new Object[] { url });\n+                                                              url);\n             }\n             in = new BufferedReader(new InputStreamReader(url.openStream()));\n             fillBinStats(in);\n     public double getNextValue() throws IllegalStateException {\n \n         if (!loaded) {\n-            throw MathRuntimeException.createIllegalStateException(\"distribution not loaded\",\n-                                                                   null);\n+            throw MathRuntimeException.createIllegalStateException(\"distribution not loaded\");\n         }\n \n         // Start with a uniformly distributed random number in (0,1)\n                }\n            }\n         }\n-        throw new MathRuntimeException(\"no bin selected\", null);\n+        throw new MathRuntimeException(\"no bin selected\");\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/random/RandomAdaptor.java\n+++ b/src/java/org/apache/commons/math/random/RandomAdaptor.java\n \n     /** Wrapped randomGenerator instance */\n     private RandomGenerator randomGenerator = null;\n-    \n+\n     /** \n      * Prevent instantiation without a generator argument\n      */ \n+    @SuppressWarnings(\"unused\")\n     private RandomAdaptor() { }\n     \n     /**\n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n             case EXPONENTIAL_MODE: return getNextExponential();\n             case GAUSSIAN_MODE: return getNextGaussian();\n             case CONSTANT_MODE: return mu;\n-            default: throw MathRuntimeException.createIllegalStateException(\"unknown mode {0}, known modes: \" +\n-                                                                            \"{1} ({2}), {3} ({4}), {5} ({6}), \" +\n-                                                                            \"{7} ({8}), {9} ({10}) and {11} ({12})\",\n-                                                                            new Object[] {\n-                                                                                mode,\n-                                                                                \"DIGEST_MODE\",      DIGEST_MODE,\n-                                                                                \"REPLAY_MODE\",      REPLAY_MODE,\n-                                                                                \"UNIFORM_MODE\",     UNIFORM_MODE,\n-                                                                                \"EXPONENTIAL_MODE\", EXPONENTIAL_MODE,\n-                                                                                \"GAUSSIAN_MODE\",    GAUSSIAN_MODE,\n-                                                                                \"CONSTANT_MODE\",    CONSTANT_MODE\n-                                                                            });\n+            default: throw MathRuntimeException.createIllegalStateException(\n+                    \"unknown mode {0}, known modes: \" +\n+                    \"{1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n+                    mode,\n+                    \"DIGEST_MODE\",   DIGEST_MODE,   \"REPLAY_MODE\",      REPLAY_MODE,\n+                    \"UNIFORM_MODE\",  UNIFORM_MODE,  \"EXPONENTIAL_MODE\", EXPONENTIAL_MODE,\n+                    \"GAUSSIAN_MODE\", GAUSSIAN_MODE, \"CONSTANT_MODE\",    CONSTANT_MODE);\n         }\n     }\n \n     private double getNextDigest() {\n         if ((empiricalDistribution == null) ||\n             (empiricalDistribution.getBinStats().size() == 0)) {\n-            throw MathRuntimeException.createIllegalStateException(\"digest not initialized\", null);\n+            throw MathRuntimeException.createIllegalStateException(\"digest not initialized\");\n         }\n         return empiricalDistribution.getNextValue();\n     }\n             resetReplayFile();\n             if ((str = filePointer.readLine()) == null) {\n                 throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n-                                                              new Object[] { valuesFileURL });\n+                                                              valuesFileURL);\n             }\n         }\n         return Double.valueOf(str).doubleValue();\n--- a/src/java/org/apache/commons/math/stat/correlation/Covariance.java\n+++ b/src/java/org/apache/commons/math/stat/correlation/Covariance.java\n         }\n         else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-               \"Arrays must have the same length and both must have at \" +\n+               \"arrays must have the same length and both must have at \" +\n                \"least two elements. xArray has size {0}, yArray has {1} elements\",\n-                    new Object[] {xArray.length, yArray.length});\n+                    xArray.length, yArray.length);\n         }\n         return biasCorrected ? result * ((double) length / (double)(length - 1)) : result;\n     }\n         int nCols = matrix.getColumnDimension();\n         if (nRows < 2 || nCols < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"Insufficient data:  only {0} rows and {1} columns.\",\n-                    new Object[]{nRows, nCols});\n+                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    nRows, nCols);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n     public PearsonsCorrelation(Covariance covariance) {\n         RealMatrix covarianceMatrix = covariance.getCovarianceMatrix();\n         if (covarianceMatrix == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"Covariance matrix is null\", null);\n+            throw MathRuntimeException.createIllegalArgumentException(\"covariance matrix is null\");\n         }\n         nObs = covariance.getN();\n         correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n         }\n         else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"Invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n-                    new Object[] {xArray.length, yArray.length});\n+                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n+                    xArray.length, yArray.length);\n         }\n     }\n     \n         int nCols = matrix.getColumnDimension();\n         if (nRows < 2 || nCols < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"Insufficient data: only {0} rows and {1} columns.\",\n-                    new Object[]{nRows, nCols});\n+                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    nRows, nCols);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n      */\n     private void checkEmpty() {\n         if (n > 0) {\n-            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n-                                                                   new Object[] { n });\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    n);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n      */\n     private void checkEmpty() {\n         if (n > 0) {\n-            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n-                                                                   new Object[] { n });\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    n);\n         }\n     }\n     \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n      */\n     private void checkEmpty() {\n         if (getN() > 0) {\n-            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n-                                                                   new Object[] { getN() });\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    getN());\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n         if (incMoment) {\n             moment.increment(d);\n         }  else  {\n-            throw MathRuntimeException.createIllegalStateException(\"statistics constructed from external \" +\n-                                                                   \"moments cannot be incremented\",\n-                                                                   null);\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"statistics constructed from external moments cannot be incremented\");\n         }\n     }\n \n         if (incMoment) {\n             moment.clear();\n         } else  {\n-            throw MathRuntimeException.createIllegalStateException(\"statistics constructed from external \" +\n-                                                                   \"moments cannot be cleared\",\n-                                                                   null);\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"statistics constructed from external moments cannot be cleared\");\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n \n         int N = f.length - 1;\n         if (!FastFourierTransformer.isPowerOf2(N)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2 plus one\",\n-                                                                      new Object[] { f.length });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2 plus one\",\n+                    f.length);\n         }\n         if (N == 1) {       // trivial case\n             F[0] = 0.5 * (f[0] + f[1]);\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n         throws FunctionEvaluationException, IllegalArgumentException {\n \n         if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"number of sample is not positive: {0}\",\n-                                                                      new Object[] { n });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"number of sample is not positive: {0}\",\n+                    n);\n         }\n         verifyInterval(min, max);\n \n      */\n     public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n         if (!isPowerOf2(d.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2, consider padding for fix\",\n-                                                                      new Object[] { d.length });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2, consider padding for fix\",\n+                    d.length);\n         }       \n     }\n \n      */\n     public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n         if (!isPowerOf2(o.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2, consider padding for fix\",\n-                                                                      new Object[] { o.length });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2, consider padding for fix\",\n+                    o.length);\n         }       \n     }\n \n         throws IllegalArgumentException {\n \n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",\n-                                                                     new Object[] { lower, upper });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    lower, upper);\n         }       \n     }\n     \n         public Complex get(int... vector)\n             throws IllegalArgumentException {\n             if (vector == null && dimensionSize.length > 1) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n-                                                                          new Object[] { 0, dimensionSize.length });\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some dimensions don't math: {0} != {1}\",\n+                        0, dimensionSize.length);\n             }\n             if (vector != null && vector.length != dimensionSize.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n-                                                                          new Object[] {\n-                                                                              vector.length,\n-                                                                              dimensionSize.length\n-                                                                          });\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some dimensions don't math: {0} != {1}\",\n+                        vector.length, dimensionSize.length);\n             }\n             \n             Object lastDimension = multiDimensionalComplexArray;\n             throws IllegalArgumentException {\n             if (vector == null) {\n                 if (dimensionSize.length > 1) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n-                                                                              new Object[] { 0, dimensionSize.length });\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some dimensions don't math: {0} != {1}\",\n+                            0, dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector != null && vector.length != dimensionSize.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n-                                                                          new Object[] {\n-                                                                              vector.length,\n-                                                                              dimensionSize.length\n-                                                                          });\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some dimensions don't math: {0} != {1}\",\n+                        vector.length,dimensionSize.length);\n             }\n \n             Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n           \n         if (omegaCount == 0) {\n           throw MathRuntimeException.createIllegalStateException(\n-                  \"roots of unity have not been computed yet\",\n-                  null);\n+                  \"roots of unity have not been computed yet\");\n         }        \n         return isForward;\n         \n \n         if (n == 0) {\n           throw MathRuntimeException.createIllegalArgumentException(\n-                  \"cannot compute 0-th root of unity, indefinite result\",\n-                  null);\n+                  \"cannot compute 0-th root of unity, indefinite result\");\n         }\n \n         isForward = (n > 0);\n         \n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"roots of unity have not been computed yet\",\n-                    null);\n+                    \"roots of unity have not been computed yet\");\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"out of range root of unity index {0} (must be in [{1};{2}])\",\n-                    new Object[] { k, 0, omegaCount - 1 });\n+                    k, 0, omegaCount - 1);\n         }\n         \n         return omegaReal[k];\n       \n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"roots of unity have not been computed yet\",\n-                    null);\n+                    \"roots of unity have not been computed yet\");\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n           throw MathRuntimeException.createIllegalArgumentException(\n                   \"out of range root of unity index {0} (must be in [{1};{2}])\",\n-                  new Object[] { k, 0, omegaCount - 1 });\n+                  k, 0, omegaCount - 1);\n         }\n \n         return (isForward) ?\n--- a/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n \n         // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2\",\n-                                                                      new Object[] { n });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2\",\n+                    n);\n         }\n \n         // Instead of creating a matrix with p+1 columns and n rows\n \n         // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2\",\n-                                                                      new Object[] { n });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2\",\n+                    n);\n         }\n \n         // Instead of creating a matrix with p+1 columns and n rows\n--- a/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n \n         FastFourierTransformer.verifyDataSet(f);\n         if (f[0] != 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"first element is not 0: {0}\",\n-                                                                      new Object[] { f[0] });\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"first element is not 0: {0}\",\n+                    f[0]);\n         }\n         int N = f.length;\n         if (N == 1) {       // trivial case\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n                     // can not scale an convergent is unbounded.\n                     throw new ConvergenceException(\n                         \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n-                        new Object[] { Double.valueOf(x) });\n+                        x);\n                 }\n             }\n             double r = p2 / q2;\n         if (n >= maxIterations) {\n             throw new MaxIterationsExceededException(maxIterations,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { Double.valueOf(x) });\n+                x);\n         }\n \n         return c;\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n     public double transform(Object o) throws MathException{\n \n         if (o == null) {\n-            throw new MathException(\"Conversion Exception in Transformation, Object is null\", null);\n+            throw new MathException(\"Conversion Exception in Transformation, Object is null\");\n         }\n \n         if (o instanceof Number) {\n         try {\n             return Double.valueOf(o.toString()).doubleValue();\n         } catch (Exception e) {\n-            throw new MathException(\"Conversion Exception in Transformation: {0}\",\n-                                    new Object[] { e.getMessage() }, e);\n+            throw new MathException(e,\n+                                    \"Conversion Exception in Transformation: {0}\", e.getMessage());\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n import java.math.BigDecimal;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n \n /**\n             if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                 throw MathRuntimeException.createArithmeticException(\n                         \"overflow: gcd({0}, {1}) is 2^31\",\n-                        new Object[] { p, q });\n+                        p, q);\n             }\n             return (Math.abs(u) + Math.abs(v));\n         }\n         if (k == 31) {\n             throw MathRuntimeException.createArithmeticException(\n                     \"overflow: gcd({0}, {1}) is 2^31\",\n-                    new Object[] { p, q });\n+                    p, q);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         // one is odd.\n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n         public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n-                                                                                 null);\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n             }\n             return keys[current];\n         }\n         public double value()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n-                                                                                 null);\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n             }\n             return values[current];\n         }\n             throws ConcurrentModificationException, NoSuchElementException {\n \n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\",\n-                                                                                 null);\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n             }\n \n             // advance on step\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 next = -2;\n                 if (current < 0) {\n-                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\", null);\n+                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n                 }\n             }\n \n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n     public synchronized double substituteMostRecentElement(double value) {\n         if (numElements < 1) {\n             throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n-                    \"cannot substitute an element from an empty array\", null);\n+                    \"cannot substitute an element from an empty array\");\n         }\n \n         double discarded = internalArray[startIndex + (numElements - 1)];\n         float expansionFactor) {\n \n         if (contractionCritera < expansionFactor) {\n-            String msg =\n-                \"Contraction criteria can never be smaller than \" +\n-                \"the expansion factor.  This would lead to a never \" +\n-                \"ending loop of expansion and contraction as a newly \" +\n-                \"expanded internal storage array would immediately \" +\n-                \"satisfy the criteria for contraction\";\n-            throw new IllegalArgumentException(msg);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n+                    \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n+                    \"internal storage array would immediately satisfy the criteria for contraction\",\n+                    contractionCritera, expansionFactor);\n         }\n \n         if (contractionCriteria <= 1.0) {\n-            String msg =\n-                \"The contraction criteria must be a number larger \" +\n-                \"than one.  If the contractionCriteria is less than or \" +\n-                \"equal to one an endless loop of contraction and \" +\n-                \"expansion would ensue as an internalArray.length \" +\n-                \"== numElements would satisfy the contraction criteria\";\n-            throw new IllegalArgumentException(msg);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"contraction criteria smaller than one ({0}).  This would lead to a never ending \" +\n+                    \"loop of expansion and contraction as an internal storage array length equal \" +\n+                    \"to the number of elements would satisfy the contraction criteria.\",\n+                    contractionCriteria);\n         }\n \n         if (expansionFactor <= 1.0) {\n-            String msg =\n-                \"The expansion factor must be a number greater than 1.0\";\n-            throw new IllegalArgumentException(msg);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"expansion factor smaller than one ({0})\",\n+                    contractionCriteria);\n         }\n     }\n     \n      */\n     private synchronized void discardExtremeElements(int i,boolean front) {\n         if (i > numElements) {\n-            String msg = \"Cannot discard more elements than are\" +\n-            \"contained in this array.\";\n-            throw new IllegalArgumentException(msg);\n-        } else if (i < 0) {\n-            String msg = \"Cannot discard a negative number of elements.\";\n-            throw new IllegalArgumentException(msg);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot discard {0} elements from a {1} elements array\",\n+                    i, numElements);\n+       } else if (i < 0) {\n+           throw MathRuntimeException.createIllegalArgumentException(\n+                   \"cannot discard a negative number of elements ({0})\",\n+                   i);\n         } else {\n             // \"Subtract\" this number of discarded from numElements \n             numElements -= i;\n      */\n     public synchronized double getElement(int index) {\n         if (index >= numElements) {\n-            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"the index specified: {0} is larger than the current maximal index {1}\",\n-                                                                            new Object[] { index, numElements - 1 });\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"the index specified: {0} is larger than the current maximal index {1}\",\n+                    index, numElements - 1);\n         } else if (index >= 0) {\n             return internalArray[startIndex + index];\n         } else {\n-            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"elements cannot be retrieved from a negative array index {0}\",\n-                                                                            new Object[] { index });\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"elements cannot be retrieved from a negative array index {0}\",\n+                    index);\n         }\n     }\n     \n      */\n     public synchronized void setElement(int index, double value) {\n         if (index < 0) {\n-            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"cannot set an element at a negative index {0}\",\n-                                                                            new Object[] { index });\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"cannot set an element at a negative index {0}\",\n+                    index);\n         }\n         if (index + 1 > numElements) {\n             numElements = index + 1;\n     public void setExpansionMode(int expansionMode) {\n         if (expansionMode != MULTIPLICATIVE_MODE && \n                 expansionMode != ADDITIVE_MODE) {\n-            throw new IllegalArgumentException(\"Illegal expansionMode setting.\");  \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n+                    expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n+                    ADDITIVE_MODE, \"ADDITIVE_MODE\");\n         }\n         this.expansionMode = expansionMode;\n     }\n             synchronized(this) {\n                 this.initialCapacity = initialCapacity;\n             }\n-            } else {\n-            String msg =\n-                \"The initial capacity supplied: \" + initialCapacity +\n-                \"must be a positive integer\";\n-            throw new IllegalArgumentException(msg);\n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"initial capacity ({0}) is not positive\",\n+                    initialCapacity);\n         }\n     }\n     \n \n         // If index is negative thrown an error\n         if (i < 0) {\n-            String msg =\n-                \"Number of elements must be zero or a positive \" + \"integer\";\n-            throw new IllegalArgumentException(msg);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"index ({0}) is not positive\",\n+                    i);\n         }\n \n         // Test the new num elements, check to see if the array needs to be \n--- a/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);\n+        ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n--- a/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n         Object[] arguments = { Double.valueOf(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);\n+        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n     public void testConstructorArgumentCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, cause);\n+        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0);\n         assertEquals(cause, ex.getCause());\n         assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n--- a/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);\n+        MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n--- a/src/test/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathExceptionTest.java\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        MathException ex = new MathException(pattern, arguments, cause);\n+        MathException ex = new MathException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n     public void testPrintStackTrace() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg, null);\n-        MathException ex = new MathException(outMsg, null, cause);\n+        MathException cause = new MathConfigurationException(inMsg);\n+        MathException ex = new MathException(cause, outMsg);\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos);\n         ex.printStackTrace(ps);\n     public void testSerialization() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg, null);\n-        MathException ex = new MathException(outMsg, null, cause);\n+        MathException cause = new MathConfigurationException(inMsg);\n+        MathException ex = new MathException(cause, outMsg);\n         MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n--- a/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n         MaxIterationsExceededException ex =\n             new MaxIterationsExceededException(1000000,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { Double.valueOf(1234567) });\n+                1234567);\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n         assertTrue(ex.getMessage().indexOf(\"1,000,000\") < 0);\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\", null);\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n--- a/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n  */\n public class InvalidMatrixExceptionTest extends TestCase {\n     \n-    /**\n-     * \n-     */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        InvalidMatrixException ex = new InvalidMatrixException(msg, null);\n+        InvalidMatrixException ex = new InvalidMatrixException(msg);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- a/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        MatrixIndexException ex = new MatrixIndexException(msg, null);\n+        MatrixIndexException ex = new MatrixIndexException(msg);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\", null);\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n--- a/src/test/org/apache/commons/math/linear/decomposition/CholeskySolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/CholeskySolverTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVectorImpl;\n import org.apache.commons.math.linear.RealVectorImplTest;\n-import org.apache.commons.math.linear.RealVectorImplTest.RealVectorTestImpl;\n-import org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl;\n-import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n \n public class CholeskySolverTest extends TestCase {\n \n--- a/src/test/org/apache/commons/math/linear/decomposition/EigenSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/EigenSolverTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVectorImpl;\n import org.apache.commons.math.linear.RealVectorImplTest;\n-import org.apache.commons.math.linear.RealVectorImplTest.RealVectorTestImpl;\n-import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n-import org.apache.commons.math.linear.decomposition.EigenDecompositionImpl;\n import org.apache.commons.math.util.MathUtils;\n \n public class EigenSolverTest extends TestCase {\n--- a/src/test/org/apache/commons/math/linear/decomposition/LUSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/LUSolverTest.java\n \n package org.apache.commons.math.linear.decomposition;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVectorImpl;\n import org.apache.commons.math.linear.RealVectorImplTest;\n-import org.apache.commons.math.linear.RealVectorImplTest.RealVectorTestImpl;\n-import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n-import org.apache.commons.math.linear.decomposition.LUDecompositionImpl;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n \n public class LUSolverTest extends TestCase {\n     private double[][] testData = {\n--- a/src/test/org/apache/commons/math/linear/decomposition/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/QRSolverTest.java\n \n import java.util.Random;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.DenseRealMatrix;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.RealVectorImpl;\n import org.apache.commons.math.linear.RealVectorImplTest;\n-import org.apache.commons.math.linear.RealVectorImplTest.RealVectorTestImpl;\n-import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n-import org.apache.commons.math.linear.decomposition.QRDecomposition;\n-import org.apache.commons.math.linear.decomposition.QRDecompositionImpl;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n \n public class QRSolverTest extends TestCase {\n     double[][] testData3x3NonSingular = { \n--- a/src/test/org/apache/commons/math/linear/decomposition/SingularValueSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/decomposition/SingularValueSolverTest.java\n \n package org.apache.commons.math.linear.decomposition;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVectorImpl;\n import org.apache.commons.math.linear.RealVectorImplTest;\n-import org.apache.commons.math.linear.RealVectorImplTest.RealVectorTestImpl;\n-import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n-import org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n \n public class SingularValueSolverTest extends TestCase {\n \n--- a/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n   private static class Equations\n     implements SecondOrderDifferentialEquations {\n       \n-      private int n;\n+    private static final long serialVersionUID = -7926271579508637558L;\n+\n+    private int n;\n \n       private double omega2;\n       \n--- a/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n             public void computeDerivatives(double t, double[] y, double[] dot)\n             throws DerivativeException {\n             if (t < -0.5) {\n-                throw new DerivativeException(\"{0}\", new String[] { \"oops\" });\n+                throw new DerivativeException(\"{0}\", \"oops\");\n             } else {\n                 throw new DerivativeException(new RuntimeException(\"oops\"));\n            }\n           double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n           double offset = t - middle;\n           if (offset > 0) {\n-            throw new EventException(\"Evaluation failed for argument = {0}\",\n-                                      new Object[] { Double.valueOf(t) });\n+            throw new EventException(\"Evaluation failed for argument = {0}\", t);\n           }\n           return offset;\n         }\n--- a/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n           new CostFunction() {\n             public double cost(double[] x) throws CostException {\n                 if (x[0] < 0) {\n-                    throw new CostException(\"{0}\", new Object[] { \"oops\"});\n+                    throw new CostException(\"{0}\", \"oops\");\n                 } else if (x[0] > 1) {\n                     throw new CostException(new RuntimeException(\"oops\"));\n                 } else {\n--- a/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n           new CostFunction() {\n             public double cost(double[] x) throws CostException {\n                 if (x[0] < 0) {\n-                    throw new CostException(\"{0}\", new Object[] { \"oops\"});\n+                    throw new CostException(\"{0}\", \"oops\");\n                 } else if (x[0] > 1) {\n                     throw new CostException(new RuntimeException(\"oops\"));\n                 } else {\n--- a/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n  */\n package org.apache.commons.math.stat.regression;\n \n+import static org.junit.Assert.assertEquals;\n+\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n import org.junit.Before;\n import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n \n public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {\n \n--- a/src/test/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/org/apache/commons/math/util/TestBean.java\n      * \n      */\n     public Double getZ() {\n-        throw new MathRuntimeException(\"?\", null);\n+        throw new MathRuntimeException(\"?\");\n     }\n \n     /**", "timestamp": 1235246474, "metainfo": ""}