{"sha": "8ce4c00c1e3570ddd637b3c0fe8c5190912f999f", "log": "added nth root computation for complex numbers JIRA: MATH-236  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    { \"URL {0} contains no data\",\n      \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n \n+   // org.apache.commons.math.complex.Complex\n+   { \"cannot compute nth root for null or negative n: {0}\",\n+     \"impossible de calculer la racine ni\\u00e8me pour n n\\u00e9gatif ou nul : {0}\" },\n+\n    // org.apache.commons.math.complex.ComplexFormat\n    { \"unparseable complex number: \\\"{0}\\\"\",\n      \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n package org.apache.commons.math.complex;\n \n import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         \n         return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n     }\n+    \n+    \n+    \n+    /**\n+     * Compute the angle phi of this complex number.\n+     * @return the angle phi of this complex number\n+     */\n+    public double getPhi() {\n+        return Math.atan2(getImaginary(), getReal());\n+    }\n+    \n+    /**\n+     * Compute the n-th root of this complex number.\n+     * <p>\n+     * For a given n it implements the formula: <pre>\n+     * <code> z_k = pow( abs , 1.0/n ) * (cos(phi + k * 2&pi;) + i * (sin(phi + k * 2&pi;)</code></pre></p>\n+     * with <i><code>k=0, 1, ..., n-1</code></i> and <i><code>pow(abs, 1.0 / n)</code></i> is the nth root of the absolute-value.\n+     * <p>\n+     * \n+     * @param n degree of root\n+     * @return Collection<Complex> all nth roots of this complex number as a Collection\n+     * @throws IllegalArgumentException if parameter n is negative\n+     * @since 2.0\n+     */\n+    public Collection<Complex> nthRoot(int n) throws IllegalArgumentException {\n+\n+        if (n <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot compute nth root for null or negative n: {0}\",\n+                    new Object[] { n });\n+        }\n+\n+        Collection<Complex> result = new ArrayList<Complex>();\n+\n+        // nth root of abs\n+        final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);\n+\n+        // Compute nth roots of complex number with k = 0, 1, ... n-1\n+        final double phi = getPhi();\n+        for (int k = 0; k < n ; k++) {\n+            // inner part\n+            final double innerPart     = (phi + k * 2 * Math.PI) / n;\n+            final double realPart      = nthRootOfAbs *  Math.cos(innerPart);\n+            final double imaginaryPart = nthRootOfAbs *  Math.sin(innerPart);\n+            result.add(createComplex(realPart, imaginaryPart));\n+        }\n+\n+        return result;\n+\n+    }\n \n     /**\n      * Create a complex number given the real and imaginary parts.\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n     public void testMath221() {\n         assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n     }\n+    \n+    /** \n+     * Test: computing <b>third roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = -2 + 2 * i</b>\n+     *   => z_0 =  1      +          i\n+     *   => z_1 = -1.3660 + 0.3660 * i\n+     *   => z_2 =  0.3660 - 1.3660 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_normal_thirdRoot() {\n+        // The complex number we want to compute all third-roots for.\n+        Complex z = new Complex(-2,2);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+\n+    /** \n+     * Test: computing <b>fourth roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = 5 - 2 * i</b>\n+     *   => z_0 =  1.5164 - 0.1446 * i\n+     *   => z_1 =  0.1446 + 1.5164 * i\n+     *   => z_2 = -1.5164 + 0.1446 * i\n+     *   => z_3 = -1.5164 - 0.1446 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_normal_fourthRoot() {\n+        // The complex number we want to compute all third-roots for.\n+        Complex z = new Complex(5,-2);\n+        // The List holding all fourth roots\n+        Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(4, fourthRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);\n+        // test z_3\n+        assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);\n+        assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);\n+    }\n+\n+    /** \n+     * Test: computing <b>third roots</b> of z.\n+     * <pre>\n+     * <code>\n+     * <b>z = 8</b>\n+     *   => z_0 =  2\n+     *   => z_1 = -1 + 1.73205 * i\n+     *   => z_2 = -1 - 1.73205 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {\n+        // The number 8 has three third roots. One we all already know is the number 2.\n+        // But there are two more complex roots.\n+        Complex z = new Complex(8,0);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+\n+    /** \n+     * Test: computing <b>third roots</b> of z with real part 0.\n+     * <pre>\n+     * <code>\n+     * <b>z = 2 * i</b>\n+     *   => z_0 =  1.0911 + 0.6299 * i\n+     *   => z_1 = -1.0911 + 0.6299 * i\n+     *   => z_2 = -2.3144 - 1.2599 * i\n+     * </code>\n+     * </pre>\n+     */\n+    public void testNthRoot_cornercase_thirdRoot_realPartEmpty() {\n+        // complex number with only imaginary part\n+        Complex z = new Complex(0,2);\n+        // The List holding all third roots\n+        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);\n+        // Returned Collection must not be empty!\n+        assertEquals(3, thirdRootsOfZ.length);\n+        // test z_0\n+        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n+        // test z_1\n+        assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);\n+        assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);\n+        // test z_2\n+        assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);\n+        assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);\n+    }\n+\n+    /**\n+     * Test cornercases with NaN and Infinity.\n+     */\n+    public void testNthRoot_cornercase_NAN_Inf() {\n+        // third root of z = 1 + NaN * i\n+        for (Complex c : oneNaN.nthRoot(3)) {\n+            // both parts should be nan\n+            assertEquals(nan, c.getReal());\n+            assertEquals(nan, c.getImaginary());\n+        }\n+        // third root of z = inf + NaN * i\n+        for (Complex c : infNaN.nthRoot(3)) {\n+            // both parts should be nan\n+            assertEquals(nan, c.getReal());\n+            assertEquals(nan, c.getImaginary());\n+        }\n+        // third root of z = neginf + 1 * i\n+        Complex[] zInfOne = negInfOne.nthRoot(2).toArray(new Complex[0]);\n+        // first root\n+        assertEquals(inf, zInfOne[0].getReal());\n+        assertEquals(inf, zInfOne[0].getImaginary());\n+        // second root\n+        assertEquals(neginf, zInfOne[1].getReal());\n+        assertEquals(neginf, zInfOne[1].getImaginary());\n+    }\n \n }", "timestamp": 1230395023, "metainfo": ""}