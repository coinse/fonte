{"sha": "1ac183419252ac503baa309df8de529907c2d406", "log": "Sparse Matrix/Vector refactoring with mostly return types changed.  Thought that getSparcity was meaninful for SparseRealVector, and added a marker for SparseRealMatrix shape.  Feel free to -1 either ;).  I found an error in the unit tests, so will commit the changes there shortly, after a review.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class OpenMapRealMatrix extends AbstractRealMatrix {\n+public class OpenMapRealMatrix extends AbstractRealMatrix implements SparseRealMatrix {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -5962461716457143437L;\n   \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix copy() {\n+    public OpenMapRealMatrix copy() {\n         return new OpenMapRealMatrix(this);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix createMatrix(int rowDimension, int columnDimension)\n+    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension)\n             throws IllegalArgumentException {\n         return new OpenMapRealMatrix(rowDimension, columnDimension);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix add(final RealMatrix m)\n+    public OpenMapRealMatrix add(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n             return add((OpenMapRealMatrix) m);\n         } catch (ClassCastException cce) {\n-            return super.add(m);\n+            return (OpenMapRealMatrix) super.add(m);\n         }\n     }\n \n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {\n+    public OpenMapRealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n-        final RealMatrix out = new OpenMapRealMatrix(this);\n+        final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n             iterator.advance();\n             final int row = iterator.key() / columnDimension;\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix subtract(final RealMatrix m)\n+    public OpenMapRealMatrix subtract(final RealMatrix m)\n         throws IllegalArgumentException {\n         try {\n             return subtract((OpenMapRealMatrix) m);\n         } catch (ClassCastException cce) {\n-            return super.add(m);\n+            return (OpenMapRealMatrix) super.subtract(m);\n         }\n     }\n \n      * @return     this - m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {\n+    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n-        final RealMatrix out = new OpenMapRealMatrix(this);\n+        final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n             iterator.advance();\n             final int row = iterator.key() / columnDimension;\n         return row * columnDimension + column;\n     }\n \n+    /** {@inheritDoc} */\n+    public MatrixShape getShape() {\n+        return MatrixShape.Any;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/OpenMapRealVector.java\n  * @version $Revision: 728186 $ $Date$\n  * @since 2.0\n */\n-public class OpenMapRealVector implements RealVector {\n+public class OpenMapRealVector implements SparseRealVector {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8772222695580707260L;\n      * Build a 0-length vector.\n      * <p>Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n-     * #SparseRealVector(OpenMapRealVector, int)} constructor\n+     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n      * or one of the <code>append</code> method ({@link #append(double)}, {@link\n      * #append(double[])}, {@link #append(RealVector)}) to gather data\n      * into this vector.</p>\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector add(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector add(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return add((OpenMapRealVector) v);\n     }\n \n     /**\n-     * Optimized method to add two SparseRealVectors.\n+     * Optimized method to add two OpenMapRealVectors.\n      * @param v Vector to add with\n      * @return The sum of <code>this</code> with <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector add(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector add(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(getDimension());\n         for (int i = 0; i < v.length; i++) {\n     }\n \n     /**\n-     * Optimized method to append a SparseRealVector.\n+     * Optimized method to append a OpenMapRealVector.\n      * @param v vector to append\n      * @return The result of appending <code>v</code> to self\n      */\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector append(RealVector v) {\n+    public OpenMapRealVector append(RealVector v) {\n         if (v instanceof OpenMapRealVector) {\n             return append((OpenMapRealVector) v);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector append(double d) {\n-        RealVector res = new OpenMapRealVector(this, 1);\n+    public OpenMapRealVector append(double d) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n         res.setEntry(virtualSize, d);\n         return res;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector append(double[] a) {\n-        RealVector res = new OpenMapRealVector(this, a.length);\n+    public OpenMapRealVector append(double[] a) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n         for (int i = 0; i < a.length; i++) {\n             res.setEntry(i + virtualSize, a[i]);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector copy() {\n+    public OpenMapRealVector copy() {\n         return new OpenMapRealVector(this);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index + n - 1);\n         OpenMapRealVector res = new OpenMapRealVector(n);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAbs() {\n+    public OpenMapRealVector mapAbs() {\n         return copy().mapAbsToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAbsToSelf() {\n+    public OpenMapRealVector mapAbsToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAcos() {\n+    public OpenMapRealVector mapAcos() {\n         return copy().mapAcosToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAcosToSelf() {\n+    public OpenMapRealVector mapAcosToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.acos(getEntry(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAdd(double d) {\n+    public OpenMapRealVector mapAdd(double d) {\n         return copy().mapAddToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAddToSelf(double d) {\n+    public OpenMapRealVector mapAddToSelf(double d) {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, getEntry(i) + d);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAsin() {\n+    public OpenMapRealVector mapAsin() {\n         return copy().mapAsinToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAsinToSelf() {\n+    public OpenMapRealVector mapAsinToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAtan() {\n+    public OpenMapRealVector mapAtan() {\n         return copy().mapAtanToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAtanToSelf() {\n+    public OpenMapRealVector mapAtanToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCbrt() {\n+    public OpenMapRealVector mapCbrt() {\n         return copy().mapCbrtToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCbrtToSelf() {\n+    public OpenMapRealVector mapCbrtToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCeil() {\n+    public OpenMapRealVector mapCeil() {\n         return copy().mapCeilToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCeilToSelf() {\n+    public OpenMapRealVector mapCeilToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCos() {\n+    public OpenMapRealVector mapCos() {\n         return copy().mapCosToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCosToSelf() {\n+    public OpenMapRealVector mapCosToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.cos(getEntry(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCosh() {\n+    public OpenMapRealVector mapCosh() {\n         return copy().mapCoshToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCoshToSelf() {\n+    public OpenMapRealVector mapCoshToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.cosh(getEntry(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapDivide(double d) {\n+    public OpenMapRealVector mapDivide(double d) {\n         return copy().mapDivideToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapDivideToSelf(double d) {\n+    public OpenMapRealVector mapDivideToSelf(double d) {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExp() {\n+    public OpenMapRealVector mapExp() {\n         return copy().mapExpToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExpToSelf() {\n+    public OpenMapRealVector mapExpToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             entries.put(i, Math.exp(entries.get(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExpm1() {\n+    public OpenMapRealVector mapExpm1() {\n         return copy().mapExpm1ToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExpm1ToSelf() {\n+    public OpenMapRealVector mapExpm1ToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapFloor() {\n+    public OpenMapRealVector mapFloor() {\n         return copy().mapFloorToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapFloorToSelf() {\n+    public OpenMapRealVector mapFloorToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapInv() {\n+    public OpenMapRealVector mapInv() {\n         return copy().mapInvToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapInvToSelf() {\n+    public OpenMapRealVector mapInvToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, 1.0/getEntry(i));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog() {\n+    public OpenMapRealVector mapLog() {\n         return copy().mapLogToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog10() {\n+    public OpenMapRealVector mapLog10() {\n         return copy().mapLog10ToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog10ToSelf() {\n+    public OpenMapRealVector mapLog10ToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.log10(getEntry(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog1p() {\n+    public OpenMapRealVector mapLog1p() {\n         return copy().mapLog1pToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog1pToSelf() {\n+    public OpenMapRealVector mapLog1pToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLogToSelf() {\n+    public OpenMapRealVector mapLogToSelf() {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, Math.log(getEntry(i)));\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapMultiply(double d) {\n+    public OpenMapRealVector mapMultiply(double d) {\n         return copy().mapMultiplyToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapMultiplyToSelf(double d) {\n+    public OpenMapRealVector mapMultiplyToSelf(double d) {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n         return this;\n     }\n     /** {@inheritDoc} */\n-    public RealVector mapPow(double d) {\n+    public OpenMapRealVector mapPow(double d) {\n         return copy().mapPowToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapPowToSelf(double d) {\n+    public OpenMapRealVector mapPowToSelf(double d) {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapRint() {\n+    public OpenMapRealVector mapRint() {\n         return copy().mapRintToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapRintToSelf() {\n+    public OpenMapRealVector mapRintToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSignum() {\n+    public OpenMapRealVector mapSignum() {\n         return copy().mapSignumToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSignumToSelf() {\n+    public OpenMapRealVector mapSignumToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSin() {\n+    public OpenMapRealVector mapSin() {\n         return copy().mapSinToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSinToSelf() {\n+    public OpenMapRealVector mapSinToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSinh() {\n+    public OpenMapRealVector mapSinh() {\n         return copy().mapSinhToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSinhToSelf() {\n+    public OpenMapRealVector mapSinhToSelf() {\n \n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSqrt() {\n+    public OpenMapRealVector mapSqrt() {\n         return copy().mapSqrtToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSqrtToSelf() {\n+    public OpenMapRealVector mapSqrtToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSubtract(double d) {\n+    public OpenMapRealVector mapSubtract(double d) {\n         return copy().mapSubtractToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSubtractToSelf(double d) {\n+    public OpenMapRealVector mapSubtractToSelf(double d) {\n         return mapAddToSelf(-d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTan() {\n+    public OpenMapRealVector mapTan() {\n         return copy().mapTanToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTanToSelf() {\n+    public OpenMapRealVector mapTanToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTanh() {\n+    public OpenMapRealVector mapTanh() {\n         return copy().mapTanhToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTanhToSelf() {\n+    public OpenMapRealVector mapTanhToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapUlp() {\n+    public OpenMapRealVector mapUlp() {\n         return copy().mapUlpToSelf();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapUlpToSelf() {\n+    public OpenMapRealVector mapUlpToSelf() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector projection(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n-        return projection(new OpenMapRealVector(v));\n+        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /**\n-     * Optimized method to subtract SparseRealVectors.\n+     * Optimized method to subtract OpenMapRealVectors.\n      * @param v The vector to subtract from <code>this</code>\n      * @return The difference of <code>this</code> and <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return subtract((OpenMapRealVector) v);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector subtract(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         for (int i = 0; i < v.length; i++) {\n \n \n     /** {@inheritDoc} */\n-    public RealVector unitVector() {\n-        RealVector res = copy();\n+    public OpenMapRealVector unitVector() {\n+        OpenMapRealVector res = copy();\n         res.unitize();\n         return res;\n     }\n         return true;\n     }\n \n+    /** {@inheritDoc} */\n+    public double getSparcity() {\n+        return (double)entries.size()/(double)getDimension();\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Marker interface for {@link RealMatrix} implementations that require sparse backing storage\n+ * \n+ * @version $Revision: 775768 $ $Date: 2009-05-17 15:12:50 -0700 (Sun, 17 May 2009) $\n+ * @since 2.0\n+ *\n+ */\n+public interface SparseRealMatrix extends RealMatrix {\n+\n+    /**\n+     * Type to identify the shape of the matrix \n+     */\n+    public static enum MatrixShape  {Any};\n+    \n+    /**\n+     * \n+     * @return the shape of the matrix\n+     */\n+    MatrixShape getShape();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Marker interface for RealVectors that require sparse backing storage\n+ * @version $Revision: 728186 $ $Date: 2009-05-17 15:12:50 -0700 (Sun, 17 May 2009) $\n+ * @since 2.0\n+ *\n+ */\n+public interface SparseRealVector extends RealVector {\n+    \n+    /**\n+     * \n+     * @return the percentage of none zero elements as a decimal percent.\n+     */\n+    double getSparcity ();\n+\n+}", "timestamp": 1242607361, "metainfo": ""}