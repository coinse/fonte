{"sha": "09fd185dcad24877a19a6318b2cd1845e8b36c22", "log": "MATH-707 Removed \"Real\" from class names in package \"o.a.c.m.analysis.solvers\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolverUtils;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n         // Checks.\n         MathUtils.checkNotNull(f);\n-        UnivariateRealSolverUtils.verifyInterval(lower, upper);\n+        UnivariateSolverUtils.verifyInterval(lower, upper);\n \n         // Reset.\n         this.min = lower;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class AbstractDifferentiableUnivariateSolver\n+    extends BaseAbstractUnivariateSolver<DifferentiableUnivariateFunction>\n+    implements DifferentiableUnivariateSolver {\n+    /** Derivative of the function to solve. */\n+    private UnivariateFunction functionDerivative;\n+\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractDifferentiableUnivariateSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected AbstractDifferentiableUnivariateSolver(final double relativeAccuracy,\n+                                                         final double absoluteAccuracy,\n+                                                         final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     */\n+    protected double computeDerivativeObjectiveValue(double point) {\n+        incrementEvaluationCount();\n+        return functionDerivative.value(point);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void setup(int maxEval, DifferentiableUnivariateFunction f,\n+                         double min, double max, double startValue) {\n+        super.setup(maxEval, f, min, max, startValue);\n+        functionDerivative = f.derivative();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AbstractPolynomialSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractPolynomialSolver.java\n  * @since 3.0\n  */\n public abstract class AbstractPolynomialSolver\n-    extends BaseAbstractUnivariateRealSolver<PolynomialFunction>\n+    extends BaseAbstractUnivariateSolver<PolynomialFunction>\n     implements PolynomialSolver {\n     /** Function. */\n     private PolynomialFunction polynomialFunction;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+/**\n+ * Base class for solvers.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class AbstractUnivariateSolver\n+    extends BaseAbstractUnivariateSolver<UnivariateFunction>\n+    implements UnivariateSolver {\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractUnivariateSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractUnivariateSolver(final double relativeAccuracy,\n+                                           final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected AbstractUnivariateSolver(final double relativeAccuracy,\n+                                           final double absoluteAccuracy,\n+                                           final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolution.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolution.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-/** The kinds of solutions that a {@link BracketedUnivariateRealSolver\n+/** The kinds of solutions that a {@link BracketedUnivariateSolver\n  * (bracketed univariate real) root-finding algorithm} may accept as solutions.\n  * This basically controls whether or not under-approximations and\n  * over-approximations are allowed.\n  * may be necessary to guarantee that a solution is returned that lies on a\n  * specific side the solution.</p>\n  *\n- * @see BracketedUnivariateRealSolver\n+ * @see BracketedUnivariateSolver\n  * @since 3.0\n  * @version $Id$\n  */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *\n+ * @param <FUNC> Type of function to solve.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public abstract class BaseAbstractUnivariateSolver<FUNC extends UnivariateFunction>\n+    implements BaseUnivariateSolver<FUNC> {\n+    /** Default relative accuracy. */\n+    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n+    /** Default function value accuracy. */\n+    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n+    /** Function value accuracy. */\n+    private final double functionValueAccuracy;\n+    /** Absolute accuracy. */\n+    private final double absoluteAccuracy;\n+    /** Relative accuracy. */\n+    private final double relativeAccuracy;\n+    /** Evaluations counter. */\n+    private final Incrementor evaluations = new Incrementor();\n+    /** Lower end of search interval. */\n+    private double searchMin;\n+    /** Higher end of search interval. */\n+    private double searchMax;\n+    /** Initial guess. */\n+    private double searchStart;\n+    /** Function to solve. */\n+    private FUNC function;\n+\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\n+        this(DEFAULT_RELATIVE_ACCURACY,\n+             absoluteAccuracy,\n+             DEFAULT_FUNCTION_VALUE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\n+                                               final double absoluteAccuracy) {\n+        this(relativeAccuracy,\n+             absoluteAccuracy,\n+             DEFAULT_FUNCTION_VALUE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\n+                                               final double absoluteAccuracy,\n+                                               final double functionValueAccuracy) {\n+        this.absoluteAccuracy = absoluteAccuracy;\n+        this.relativeAccuracy = relativeAccuracy;\n+        this.functionValueAccuracy = functionValueAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+    /**\n+     * @return the lower end of the search interval.\n+     */\n+    public double getMin() {\n+        return searchMin;\n+    }\n+    /**\n+     * @return the higher end of the search interval.\n+     */\n+    public double getMax() {\n+        return searchMax;\n+    }\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double getStartValue() {\n+        return searchStart;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected double computeObjectiveValue(double point)\n+        throws TooManyEvaluationsException {\n+        incrementEvaluationCount();\n+        return function.value(point);\n+    }\n+\n+    /**\n+     * Prepare for computation.\n+     * Subclasses must call this method if they override any of the\n+     * {@code solve} methods.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param maxEval Maximum number of evaluations.\n+     */\n+    protected void setup(int maxEval,\n+                         FUNC f,\n+                         double min, double max,\n+                         double startValue) {\n+        // Checks.\n+        MathUtils.checkNotNull(f);\n+\n+        // Reset.\n+        searchMin = min;\n+        searchMax = max;\n+        searchStart = startValue;\n+        function = f;\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n+        // Initialization.\n+        setup(maxEval, f, min, max, startValue);\n+\n+        // Perform computation.\n+        return doSolve();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, FUNC f, double min, double max) {\n+        return solve(maxEval, f, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, FUNC f, double startValue) {\n+        return solve(maxEval, f, Double.NaN, Double.NaN, startValue);\n+    }\n+\n+    /**\n+     * Method for implementing actual optimization algorithms in derived\n+     * classes.\n+     *\n+     * @return the root.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     * @throws NoBracketingException if the initial search interval does not bracket\n+     * a root and the solver requires it.\n+     */\n+    protected abstract double doSolve()\n+        throws TooManyEvaluationsException, NoBracketingException;\n+\n+    /**\n+     * Check whether the function takes opposite signs at the endpoints.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @return {@code true} if the function values have opposite signs at the\n+     * given points.\n+     */\n+    protected boolean isBracketing(final double lower,\n+                                   final double upper) {\n+        return UnivariateSolverUtils.isBracketing(function, lower, upper);\n+    }\n+\n+    /**\n+     * Check whether the arguments form a (strictly) increasing sequence.\n+     *\n+     * @param start First number.\n+     * @param mid Second number.\n+     * @param end Third number.\n+     * @return {@code true} if the arguments form an increasing sequence.\n+     */\n+    protected boolean isSequence(final double start,\n+                                 final double mid,\n+                                 final double end) {\n+        return UnivariateSolverUtils.isSequence(start, mid, end);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if {@code lower >= upper}.\n+     */\n+    protected void verifyInterval(final double lower,\n+                                  final double upper) {\n+        UnivariateSolverUtils.verifyInterval(lower, upper);\n+    }\n+\n+    /**\n+     * Check that {@code lower < initial < upper}.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param initial Initial value.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if {@code lower >= initial} or {@code initial >= upper}.\n+     */\n+    protected void verifySequence(final double lower,\n+                                  final double initial,\n+                                  final double upper) {\n+        UnivariateSolverUtils.verifySequence(lower, initial, upper);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval and the function takes\n+     * opposite signs at the endpoints.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NoBracketingException if\n+     * the function has the same sign at the endpoints.\n+     */\n+    protected void verifyBracketing(final double lower,\n+                                    final double upper) {\n+        UnivariateSolverUtils.verifyBracketing(function, lower, upper);\n+    }\n+\n+    /**\n+     * Increment the evaluation count by one.\n+     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n+     * It is provided for subclasses that do not exclusively use\n+     * {@code computeObjectiveValue} to solve the function.\n+     * See e.g. {@link AbstractDifferentiableUnivariateSolver}.\n+     */\n+    protected void incrementEvaluationCount() {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n  * @version $Id$\n  */\n public abstract class BaseSecantSolver\n-    extends AbstractUnivariateRealSolver\n-    implements BracketedUnivariateRealSolver<UnivariateFunction> {\n+    extends AbstractUnivariateSolver\n+    implements BracketedUnivariateSolver<UnivariateFunction> {\n \n     /** Default absolute accuracy. */\n     protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * This class is not intended for use outside of the Apache Commons Math\n+ * library, regular user should rely on more specific interfaces like\n+ * {@link UnivariateSolver}, {@link PolynomialSolver} or {@link\n+ * DifferentiableUnivariateSolver}.\n+ * @param <FUNC> Type of function to solve.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ * @see UnivariateSolver\n+ * @see PolynomialSolver\n+ * @see DifferentiableUnivariateSolver\n+ */\n+public interface BaseUnivariateSolver<FUNC extends UnivariateFunction> {\n+    /**\n+     * Get the maximum number of function evaluations.\n+     *\n+     * @return the maximum number of function evaluations.\n+     */\n+    int getMaxEvaluations();\n+\n+    /**\n+     * Get the number of evaluations of the objective function.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * Get the absolute accuracy of the solver.  Solutions returned by the\n+     * solver should be accurate to this tolerance, i.e., if &epsilon; is the\n+     * absolute accuracy of the solver and {@code v} is a value returned by\n+     * one of the {@code solve} methods, then a root of the function should\n+     * exist somewhere in the interval ({@code v} - &epsilon;, {@code v} + &epsilon;).\n+     *\n+     * @return the absolute accuracy.\n+     */\n+    double getAbsoluteAccuracy();\n+\n+    /**\n+     * Get the relative accuracy of the solver.  The contract for relative\n+     * accuracy is the same as {@link #getAbsoluteAccuracy()}, but using\n+     * relative, rather than absolute error.  If &rho; is the relative accuracy\n+     * configured for a solver and {@code v} is a value returned, then a root\n+     * of the function should exist somewhere in the interval\n+     * ({@code v} - &rho; {@code v}, {@code v} + &rho; {@code v}).\n+     *\n+     * @return the relative accuracy.\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Get the function value accuracy of the solver.  If {@code v} is\n+     * a value returned by the solver for a function {@code f},\n+     * then by contract, {@code |f(v)|} should be less than or equal to\n+     * the function value accuracy configured for the solver.\n+     *\n+     * @return the function value accuracy.\n+     */\n+    double getFunctionValueAccuracy();\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max);\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max, double startValue);\n+\n+    /**\n+     * Solve for a zero in the vicinity of {@code startValue}.\n+     *\n+     * @param f Function to solve.\n+     * @param startValue Start value to use.\n+     * @return a value where the function is zero.\n+     * @param maxEval Maximum number of evaluations.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double startValue);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n  *\n  * @version $Id$\n  */\n-public class BisectionSolver extends AbstractUnivariateRealSolver {\n+public class BisectionSolver extends AbstractUnivariateSolver {\n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n         double fmin;\n \n         while (true) {\n-            m = UnivariateRealSolverUtils.midpoint(min, max);\n+            m = UnivariateSolverUtils.midpoint(min, max);\n             fmin = computeObjectiveValue(min);\n             fm = computeObjectiveValue(m);\n \n             }\n \n             if (FastMath.abs(max - min) <= absoluteAccuracy) {\n-                m = UnivariateRealSolverUtils.midpoint(min, max);\n+                m = UnivariateSolverUtils.midpoint(min, max);\n                 return m;\n             }\n         }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+/** Interface for {@link UnivariateSolver (univariate real) root-finding\n+ * algorithms} that maintain a bracketed solution. There are several advantages\n+ * to having such root-finding algorithms:\n+ * <ul>\n+ *  <li>The bracketed solution guarantees that the root is kept within the\n+ *      interval. As such, these algorithms generally also guarantee\n+ *      convergence.</li>\n+ *  <li>The bracketed solution means that we have the opportunity to only\n+ *      return roots that are greater than or equal to the actual root, or\n+ *      are less than or equal to the actual root. That is, we can control\n+ *      whether under-approximations and over-approximations are\n+ *      {@link AllowedSolution allowed solutions}. Other root-finding\n+ *      algorithms can usually only guarantee that the solution (the root that\n+ *      was found) is around the actual root.</li>\n+ * </ul>\n+ *\n+ * <p>For backwards compatibility, all root-finding algorithms must have\n+ * {@link AllowedSolution#ANY_SIDE ANY_SIDE} as default for the allowed\n+ * solutions.</p>\n+ * @param <FUNC> Type of function to solve.\n+ *\n+ * @see AllowedSolution\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface BracketedUnivariateSolver<FUNC extends UnivariateFunction>\n+    extends BaseUnivariateSolver<FUNC> {\n+\n+    /**\n+     * Solve for a zero in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return A value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max,\n+                 AllowedSolution allowedSolution);\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return A value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max, double startValue,\n+                 AllowedSolution allowedSolution);\n+\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n  * @version $Id$\n  */\n public class BracketingNthOrderBrentSolver\n-    extends AbstractUnivariateRealSolver\n-    implements BracketedUnivariateRealSolver<UnivariateFunction> {\n+    extends AbstractUnivariateSolver\n+    implements BracketedUnivariateSolver<UnivariateFunction> {\n \n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n  *\n  * @version $Id$\n  */\n-public class BrentSolver extends AbstractUnivariateRealSolver {\n+public class BrentSolver extends AbstractUnivariateSolver {\n \n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/DifferentiableUnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * @version $Id$\n+ */\n+public interface DifferentiableUnivariateSolver\n+    extends BaseUnivariateSolver<DifferentiableUnivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n  * @since 1.2\n  * @see MullerSolver2\n  */\n-public class MullerSolver extends AbstractUnivariateRealSolver {\n+public class MullerSolver extends AbstractUnivariateSolver {\n \n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver2.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver2.java\n  * @since 1.2\n  * @see MullerSolver\n  */\n-public class MullerSolver2 extends AbstractUnivariateRealSolver {\n+public class MullerSolver2 extends AbstractUnivariateSolver {\n \n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n  *\n  * @version $Id$\n  */\n-public class NewtonSolver extends AbstractDifferentiableUnivariateRealSolver {\n+public class NewtonSolver extends AbstractDifferentiableUnivariateSolver {\n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     @Override\n     public double solve(int maxEval, final DifferentiableUnivariateFunction f,\n                         final double min, final double max) {\n-        return super.solve(maxEval, f, UnivariateRealSolverUtils.midpoint(min, max));\n+        return super.solve(maxEval, f, UnivariateSolverUtils.midpoint(min, max));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/PolynomialSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PolynomialSolver.java\n  * @since 3.0\n  */\n public interface PolynomialSolver\n-    extends BaseUnivariateRealSolver<PolynomialFunction> {}\n+    extends BaseUnivariateSolver<PolynomialFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n  * @version $Id$\n  * @since 1.2\n  */\n-public class RiddersSolver extends AbstractUnivariateRealSolver {\n+public class RiddersSolver extends AbstractUnivariateSolver {\n     /** Default absolute accuracy. */\n     private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n  *\n  * @version $Id$\n  */\n-public class SecantSolver extends AbstractUnivariateRealSolver {\n+public class SecantSolver extends AbstractUnivariateSolver {\n \n     /** Default absolute accuracy. */\n     protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) root-finding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * @version $Id$\n+ */\n+public interface UnivariateSolver\n+    extends BaseUnivariateSolver<UnivariateFunction> {}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateSolverUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Utility routines for {@link UnivariateSolver} objects.\n+ *\n+ * @version $Id$\n+ */\n+public class UnivariateSolverUtils {\n+    /**\n+     * Class contains only static methods.\n+     */\n+    private UnivariateSolverUtils() {}\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used.\n+     *\n+     * @param function Function.\n+     * @param x0 Lower bound for the interval.\n+     * @param x1 Upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if f is null or the endpoints do not\n+     * specify a valid interval.\n+     */\n+    public static double solve(UnivariateFunction function, double x0, double x1) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final UnivariateSolver solver = new BrentSolver();\n+        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n+    }\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used.\n+     *\n+     * @param function Function.\n+     * @param x0 Lower bound for the interval.\n+     * @param x1 Upper bound for the interval.\n+     * @param absoluteAccuracy Accuracy to be used by the solver.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if {@code function} is {@code null},\n+     * the endpoints do not specify a valid interval, or the absolute accuracy\n+     * is not valid for the default solver.\n+     */\n+    public static double solve(UnivariateFunction function,\n+                               double x0, double x1,\n+                               double absoluteAccuracy) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n+        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n+    }\n+\n+    /** Force a root found by a non-bracketing solver to lie on a specified side,\n+     * as if the solver was a bracketing one.\n+     * @param maxEval maximal number of new evaluations of the function\n+     * (evaluations already done for finding the root should have already been subtracted\n+     * from this number)\n+     * @param f function to solve\n+     * @param bracketing bracketing solver to use for shifting the root\n+     * @param baseRoot original root found by a previous non-bracketing solver\n+     * @param min minimal bound of the search interval\n+     * @param max maximal bound of the search interval\n+     * @param allowedSolution the kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return a root approximation, on the specified side of the exact root\n+     */\n+    public static double forceSide(final int maxEval, final UnivariateFunction f,\n+                                   final BracketedUnivariateSolver<UnivariateFunction> bracketing,\n+                                   final double baseRoot, final double min, final double max,\n+                                   final AllowedSolution allowedSolution) {\n+\n+        if (allowedSolution == AllowedSolution.ANY_SIDE) {\n+            // no further bracketing required\n+            return baseRoot;\n+        }\n+\n+        // find a very small interval bracketing the root\n+        final double step = FastMath.max(bracketing.getAbsoluteAccuracy(),\n+                                         FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n+        double xLo        = FastMath.max(min, baseRoot - step);\n+        double fLo        = f.value(xLo);\n+        double xHi        = FastMath.min(max, baseRoot + step);\n+        double fHi        = f.value(xHi);\n+        int remainingEval = maxEval - 2;\n+        while (remainingEval > 0) {\n+\n+            if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n+                // compute the root on the selected side\n+                return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n+            }\n+\n+            // try increasing the interval\n+            boolean changeLo = false;\n+            boolean changeHi = false;\n+            if (fLo < fHi) {\n+                // increasing function\n+                if (fLo >= 0) {\n+                    changeLo = true;\n+                } else {\n+                    changeHi = true;\n+                }\n+            } else if (fLo > fHi) {\n+                // decreasing function\n+                if (fLo <= 0) {\n+                    changeLo = true;\n+                } else {\n+                    changeHi = true;\n+                }\n+            } else {\n+                // unknown variation\n+                changeLo = true;\n+                changeHi = true;\n+            }\n+\n+            // update the lower bound\n+            if (changeLo) {\n+                xLo = FastMath.max(min, xLo - step);\n+                fLo  = f.value(xLo);\n+                remainingEval--;\n+            }\n+\n+            // update the higher bound\n+            if (changeHi) {\n+                xHi = FastMath.min(max, xHi + step);\n+                fHi  = f.value(xHi);\n+                remainingEval--;\n+            }\n+\n+        }\n+\n+        throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING,\n+                                        xLo, xHi, fLo, fHi,\n+                                        maxEval - remainingEval, maxEval, baseRoot,\n+                                        min, max);\n+\n+    }\n+\n+    /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code></li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting\n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates\n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code>\n+     * -- NoBracketingException </li>\n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse\n+     * -- NoBracketingException </li>\n+     * </ul></p>\n+     * <p>\n+     * <strong>Note: </strong> this method can take\n+     * <code>Integer.MAX_VALUE</code> iterations to throw a\n+     * <code>ConvergenceException.</code>  Unless you are confident that there\n+     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n+     * near <code>initial,</code> it is better to use\n+     * {@link #bracket(UnivariateFunction, double, double, double, int)},\n+     * explicitly specifying the maximum number of iterations.</p>\n+     *\n+     * @param function Function.\n+     * @param initial Initial midpoint of interval being expanded to\n+     * bracket a root.\n+     * @param lowerBound Lower bound (a is never lower than this value)\n+     * @param upperBound Upper bound (b never is greater than this\n+     * value).\n+     * @return a two-element array holding a and b.\n+     * @throws NoBracketingException if a root cannot be bracketted.\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound.\n+     */\n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound, double upperBound) {\n+        return bracket(function, initial, lowerBound, upperBound, Integer.MAX_VALUE);\n+    }\n+\n+     /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting\n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates\n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code>\n+     * -- NoBracketingException </li>\n+     * <li> <code> maximumIterations</code> iterations elapse\n+     * -- NoBracketingException </li></ul></p>\n+     *\n+     * @param function Function.\n+     * @param initial Initial midpoint of interval being expanded to\n+     * bracket a root.\n+     * @param lowerBound Lower bound (a is never lower than this value).\n+     * @param upperBound Upper bound (b never is greater than this\n+     * value).\n+     * @param maximumIterations Maximum number of iterations to perform\n+     * @return a two element array holding a and b.\n+     * @throws NoBracketingException if the algorithm fails to find a and b\n+     * satisfying the desired conditions.\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound.\n+     */\n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound, double upperBound,\n+                                   int maximumIterations)  {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        if (maximumIterations <= 0)  {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n+        }\n+        verifySequence(lowerBound, initial, upperBound);\n+\n+        double a = initial;\n+        double b = initial;\n+        double fa;\n+        double fb;\n+        int numIterations = 0;\n+\n+        do {\n+            a = FastMath.max(a - 1.0, lowerBound);\n+            b = FastMath.min(b + 1.0, upperBound);\n+            fa = function.value(a);\n+\n+            fb = function.value(b);\n+            ++numIterations;\n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&\n+                ((a > lowerBound) || (b < upperBound)));\n+\n+        if (fa * fb > 0.0) {\n+            throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING,\n+                                            a, b, fa, fb,\n+                                            numIterations, maximumIterations, initial,\n+                                            lowerBound, upperBound);\n+        }\n+\n+        return new double[] {a, b};\n+    }\n+\n+    /**\n+     * Compute the midpoint of two values.\n+     *\n+     * @param a first value.\n+     * @param b second value.\n+     * @return the midpoint.\n+     */\n+    public static double midpoint(double a, double b) {\n+        return (a + b) * 0.5;\n+    }\n+\n+    /**\n+     * Check whether the interval bounds bracket a root. That is, if the\n+     * values at the endpoints are not equal to zero, then the function takes\n+     * opposite signs at the endpoints.\n+     *\n+     * @param function Function.\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @return {@code true} if the function values have opposite signs at the\n+     * given points.\n+     */\n+    public static boolean isBracketing(UnivariateFunction function,\n+                                       final double lower,\n+                                       final double upper) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final double fLo = function.value(lower);\n+        final double fHi = function.value(upper);\n+        return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n+    }\n+\n+    /**\n+     * Check whether the arguments form a (strictly) increasing sequence.\n+     *\n+     * @param start First number.\n+     * @param mid Second number.\n+     * @param end Third number.\n+     * @return {@code true} if the arguments form an increasing sequence.\n+     */\n+    public static boolean isSequence(final double start,\n+                                     final double mid,\n+                                     final double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    public static void verifyInterval(final double lower,\n+                                      final double upper) {\n+        if (lower >= upper) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n+                                                lower, upper, false);\n+        }\n+    }\n+\n+    /**\n+     * Check that {@code lower < initial < upper}.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param initial Initial value.\n+     * @param upper Upper endpoint.\n+     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n+     * {@code initial >= upper}.\n+     */\n+    public static void verifySequence(final double lower,\n+                                      final double initial,\n+                                      final double upper) {\n+        verifyInterval(lower, initial);\n+        verifyInterval(initial, upper);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval and the end points\n+     * bracket a root.\n+     *\n+     * @param function Function.\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws NoBracketingException if function has the same sign at the\n+     * endpoints.\n+     */\n+    public static void verifyBracketing(UnivariateFunction function,\n+                                        final double lower,\n+                                        final double upper) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        verifyInterval(lower, upper);\n+        if (!isBracketing(function, lower, upper)) {\n+            throw new NoBracketingException(lower, upper,\n+                                            function.value(lower),\n+                                            function.value(upper));\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n import java.io.Serializable;\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolverUtils;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n             }\n         };\n \n-        double x = UnivariateRealSolverUtils.solve(toSolve,\n+        double x = UnivariateSolverUtils.solve(toSolve,\n                                                    lowerBound,\n                                                    upperBound,\n                                                    getSolverAbsoluteAccuracy());\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.TreeSet;\n \n import org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount,\n-                                final UnivariateRealSolver solver) {\n+                                final UnivariateSolver solver) {\n         eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                         maxIterationCount, solver));\n     }\n--- a/src/main/java/org/apache/commons/math/ode/ODEIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/ODEIntegrator.java\n \n import java.util.Collection;\n \n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n     void clearStepHandlers();\n \n     /** Add an event handler to the integrator.\n-     * Uses a default {@link UnivariateRealSolver}\n+     * Uses a default {@link UnivariateSolver}\n      * with an absolute accuracy equal to the given convergence threshold,\n      * as root-finding algorithm to detect the state events.\n      * @param handler event handler\n      */\n     void addEventHandler(EventHandler handler, double maxCheckInterval,\n                          double convergence, int maxIterationCount,\n-                         UnivariateRealSolver solver);\n+                         UnivariateSolver solver);\n \n     /** Get all the event handlers that have been added to the integrator.\n      * @return an unmodifiable collection of the added events handlers\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.AllowedSolution;\n-import org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.BracketedUnivariateSolver;\n import org.apache.commons.math.analysis.solvers.PegasusSolver;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolverUtils;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n     private EventHandler.Action nextAction;\n \n     /** Root-finding algorithm to use to detect state events. */\n-    private final UnivariateRealSolver solver;\n+    private final UnivariateSolver solver;\n \n     /** Simple constructor.\n      * @param handler event handler\n      */\n     public EventState(final EventHandler handler, final double maxCheckInterval,\n                       final double convergence, final int maxIterationCount,\n-                      final UnivariateRealSolver solver) {\n+                      final UnivariateSolver solver) {\n         this.handler           = handler;\n         this.maxCheckInterval  = maxCheckInterval;\n         this.convergence       = FastMath.abs(convergence);\n \n                     // find the event time making sure we select a solution just at or past the exact root\n                     final double root;\n-                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n+                    if (solver instanceof BracketedUnivariateSolver<?>) {\n                         @SuppressWarnings(\"unchecked\")\n-                        BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n-                                (BracketedUnivariateRealSolver<UnivariateFunction>) solver;\n+                        BracketedUnivariateSolver<UnivariateFunction> bracketing =\n+                                (BracketedUnivariateSolver<UnivariateFunction>) solver;\n                         root = forward ?\n                                bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                                bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                                                 solver.solve(maxIterationCount, f, ta, tb) :\n                                                 solver.solve(maxIterationCount, f, tb, ta);\n                         final int remainingEval = maxIterationCount - solver.getEvaluations();\n-                        BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n+                        BracketedUnivariateSolver<UnivariateFunction> bracketing =\n                                 new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                         root = forward ?\n-                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n+                               UnivariateSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                    baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n-                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n+                               UnivariateSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                    baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.ode.ExpandableStatefulODE;\n                               final double maxCheckInterval,\n                               final double convergence,\n                               final int maxIterationCount,\n-                              final UnivariateRealSolver solver) {\n+                              final UnivariateSolver solver) {\n     super.addEventHandler(function, maxCheckInterval, convergence,\n                           maxIterationCount, solver);\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n-import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateSolver;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n     /** Preconditioner (may be null). */\n     private final Preconditioner preconditioner;\n     /** solver to use in the line search (may be null). */\n-    private final UnivariateRealSolver solver;\n+    private final UnivariateSolver solver;\n     /** Initial step used to bracket the optimum in line search. */\n     private double initialStep;\n     /** Current point. */\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n                                                ConvergenceChecker<RealPointValuePair> checker,\n-                                               final UnivariateRealSolver lineSearchSolver) {\n+                                               final UnivariateSolver lineSearchSolver) {\n         this(updateFormula,\n              checker,\n              lineSearchSolver,\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,\n                                                ConvergenceChecker<RealPointValuePair> checker,\n-                                               final UnivariateRealSolver lineSearchSolver,\n+                                               final UnivariateSolver lineSearchSolver,\n                                                final Preconditioner preconditioner) {\n         super(checker);\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n     /** Returns the solver to use to perform the tests.\n      * @return the solver to use to perform the tests\n      */\n-    protected abstract UnivariateRealSolver getSolver();\n+    protected abstract UnivariateSolver getSolver();\n \n     /** Returns the expected number of evaluations for the\n      * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that\n         // still converge quadratically.\n         UnivariateFunction f = new SinFunction();\n         double result;\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n \n         result = solver.solve(100, f, 3, 4);\n         //System.out.println(\n         // the solvers.\n         UnivariateFunction f = new QuinticFunction();\n         double result;\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         double atol = solver.getAbsoluteAccuracy();\n         int[] counts = getQuinticEvalCounts();\n \n     @Test\n     public void testRootEndpoints() {\n         UnivariateFunction f = new XMinus5Function();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n \n         // End-point is root. This should be a special case in the solver, and\n         // the initial end-point should be returned exactly.\n     @Test\n     public void testBadEndpoints() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         try {  // bad interval\n             solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n     @Test\n     public void testSolutionLeftSide() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n     @Test\n     public void testSolutionRightSide() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n     @Test\n     public void testSolutionBelowSide() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n     @Test\n     public void testSolutionAboveSide() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = getSolver();\n+        UnivariateSolver solver = getSolver();\n         double left = -1.5;\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n         }\n     }\n \n-    private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateFunction f,\n+    private double getSolution(UnivariateSolver solver, int maxEval, UnivariateFunction f,\n                                double left, double right, AllowedSolution allowedSolution) {\n         try {\n             @SuppressWarnings(\"unchecked\")\n-            BracketedUnivariateRealSolver<UnivariateFunction> bracketing =\n-            (BracketedUnivariateRealSolver<UnivariateFunction>) solver;\n+            BracketedUnivariateSolver<UnivariateFunction> bracketing =\n+            (BracketedUnivariateSolver<UnivariateFunction>) solver;\n             return bracketing.solve(100, f, left, right, allowedSolution);\n         } catch (ClassCastException cce) {\n             double baseRoot = solver.solve(maxEval, f, left, right);\n             PegasusSolver bracketing =\n                     new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy(),\n                                       solver.getFunctionValueAccuracy());\n-            return UnivariateRealSolverUtils.forceSide(maxEval - solver.getEvaluations(),\n+            return UnivariateSolverUtils.forceSide(maxEval - solver.getEvaluations(),\n                                                        f, bracketing, baseRoot, left, right,\n                                                        allowedSolution);\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n public final class BracketingNthOrderBrentSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealSolver getSolver() {\n+    protected UnivariateSolver getSolver() {\n         return new BracketingNthOrderBrentSolver();\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n         // still converge quadratically.\n         UnivariateFunction f = new SinFunction();\n         double result;\n-        UnivariateRealSolver solver = new BrentSolver();\n+        UnivariateSolver solver = new BrentSolver();\n         // Somewhat benign interval. The function is monotone.\n         result = solver.solve(100, f, 3, 4);\n         // System.out.println(\n         UnivariateFunction f = new QuinticFunction();\n         double result;\n         // Brent-Dekker solver.\n-        UnivariateRealSolver solver = new BrentSolver();\n+        UnivariateSolver solver = new BrentSolver();\n         // Symmetric bracket around 0. Test whether solvers can handle hitting\n         // the root in the first iteration.\n         result = solver.solve(100, f, -0.2, 0.2);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n public final class IllinoisSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealSolver getSolver() {\n+    protected UnivariateSolver getSolver() {\n         return new IllinoisSolver();\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver2();\n+        UnivariateSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new MullerSolver2();\n+        UnivariateSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     @Test\n     public void testExpm1Function() {\n         UnivariateFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new MullerSolver2();\n+        UnivariateSolver solver = new MullerSolver2();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     @Test\n     public void testParameters() throws Exception {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver2();\n+        UnivariateSolver solver = new MullerSolver2();\n \n         try {\n             // bad interval\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver();\n+        UnivariateSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new MullerSolver();\n+        UnivariateSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     @Test\n     public void testExpm1Function() {\n         UnivariateFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new MullerSolver();\n+        UnivariateSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     @Test\n     public void testParameters() throws Exception {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver();\n+        UnivariateSolver solver = new MullerSolver();\n \n         try {\n             // bad interval\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n public final class PegasusSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealSolver getSolver() {\n+    protected UnivariateSolver getSolver() {\n         return new PegasusSolver();\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealSolver getSolver() {\n+    protected UnivariateSolver getSolver() {\n         return new RegulaFalsiSolver();\n     }\n \n                 }\n             };\n \n-        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n+        final UnivariateSolver solver = new RegulaFalsiSolver();\n         final double root = solver.solve(3624, f, 1, 10);\n         Assert.assertEquals(3.4341896575482003, root, 1e-15);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver();\n+        UnivariateSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     @Test\n     public void testQuinticFunction() {\n         UnivariateFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new RiddersSolver();\n+        UnivariateSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     @Test\n     public void testExpm1Function() {\n         UnivariateFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new RiddersSolver();\n+        UnivariateSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     @Test\n     public void testParameters() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver();\n+        UnivariateSolver solver = new RiddersSolver();\n \n         try {\n             // bad interval\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n public final class SecantSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealSolver getSolver() {\n+    protected UnivariateSolver getSolver() {\n         return new SecantSolver();\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateSolverUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * @version $Id$\n+ */\n+public class UnivariateSolverUtilsTest {\n+\n+    protected UnivariateFunction sin = new SinFunction();\n+\n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testSolveNull() {\n+        UnivariateSolverUtils.solve(null, 0.0, 4.0);\n+    }\n+\n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testSolveBadEndpoints() {\n+        double root = UnivariateSolverUtils.solve(sin, 4.0, -0.1, 1e-6);\n+        System.out.println(\"root=\" + root);\n+    }\n+\n+    @Test\n+    public void testSolveBadAccuracy() {\n+        try { // bad accuracy\n+            UnivariateSolverUtils.solve(sin, 0.0, 4.0, 0.0);\n+//             Assert.fail(\"Expecting MathIllegalArgumentException\"); // TODO needs rework since convergence behaviour was changed\n+        } catch (MathIllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testSolveSin() {\n+        double x = UnivariateSolverUtils.solve(sin, 1.0, 4.0);\n+        Assert.assertEquals(FastMath.PI, x, 1.0e-4);\n+    }\n+\n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testSolveAccuracyNull()  {\n+        double accuracy = 1.0e-6;\n+        UnivariateSolverUtils.solve(null, 0.0, 4.0, accuracy);\n+    }\n+\n+    @Test\n+    public void testSolveAccuracySin() {\n+        double accuracy = 1.0e-6;\n+        double x = UnivariateSolverUtils.solve(sin, 1.0,\n+                4.0, accuracy);\n+        Assert.assertEquals(FastMath.PI, x, accuracy);\n+    }\n+\n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testSolveNoRoot() {\n+        UnivariateSolverUtils.solve(sin, 1.0, 1.5);\n+    }\n+\n+    @Test\n+    public void testBracketSin() {\n+        double[] result = UnivariateSolverUtils.bracket(sin,\n+                0.0, -2.0, 2.0);\n+        Assert.assertTrue(sin.value(result[0]) < 0);\n+        Assert.assertTrue(sin.value(result[1]) > 0);\n+    }\n+\n+    @Test\n+    public void testBracketEndpointRoot() {\n+        double[] result = UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0);\n+        Assert.assertEquals(0.0, sin.value(result[0]), 1.0e-15);\n+        Assert.assertTrue(sin.value(result[1]) > 0);\n+    }\n+\n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testNullFunction() {\n+        UnivariateSolverUtils.bracket(null, 1.5, 0, 2.0);\n+    }\n+    \n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testBadInitial() {\n+        UnivariateSolverUtils.bracket(sin, 2.5, 0, 2.0);\n+    }\n+    \n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testBadEndpoints() {\n+        // endpoints not valid\n+        UnivariateSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n+    }\n+    \n+    @Test(expected=MathIllegalArgumentException.class)\n+    public void testBadMaximumIterations() {\n+        // bad maximum iterations\n+        UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n+    }\n+\n+    @Test\n+    public void testMisc() {\n+        UnivariateFunction f = new QuinticFunction();\n+        double result;\n+        // Static solve method\n+        result = UnivariateSolverUtils.solve(f, -0.2, 0.2);\n+        Assert.assertEquals(result, 0, 1E-8);\n+        result = UnivariateSolverUtils.solve(f, -0.1, 0.3);\n+        Assert.assertEquals(result, 0, 1E-8);\n+        result = UnivariateSolverUtils.solve(f, -0.3, 0.45);\n+        Assert.assertEquals(result, 0, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.3, 0.7);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.2, 0.6);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.05, 0.95);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.85, 1.25);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.8, 1.2);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.85, 1.75);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.55, 1.45);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateSolverUtils.solve(f, 0.85, 5);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+    }\n+}", "timestamp": 1327325610, "metainfo": ""}