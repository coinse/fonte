{"sha": "d0d685f3f3c180d1e1fd75f5bd8071806d1c3005", "log": "MATH-874 Simple bounds expressed as a kind of \"0ptimizationData\". The specification of simple bounds is handled in \"BaseAbstractMultivariateOptimizer\"; hence \"BaseAbstractMultivariateSimpleBoundsOptimizer\" is deprecated.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimpleBounds.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.optimization;\n+\n+/**\n+ * Simple optimization constraints: lower and upper bounds.\n+ * The valid range of the parameters is an interval that can be infinite\n+ * (in one or both directions).\n+ * <br/>\n+ * Immutable class.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class SimpleBounds implements OptimizationData {\n+    /** Lower bounds. */\n+    private final double[] lower;\n+    /** Upper bounds. */\n+    private final double[] upper;\n+\n+    /**\n+     * @param lB Lower bounds.\n+     * @param uB Upper bounds.\n+     */\n+    public SimpleBounds(double[] lB,\n+                        double[] uB) {\n+        lower = lB.clone();\n+        upper = uB.clone();\n+    }\n+\n+    /**\n+     * Gets the lower bounds.\n+     *\n+     * @return the initial guess.\n+     */\n+    public double[] getLower() {\n+        return lower.clone();\n+    }\n+    /**\n+     * Gets the lower bounds.\n+     *\n+     * @return the initial guess.\n+     */\n+    public double[] getUpper() {\n+        return upper.clone();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java\n import org.apache.commons.math3.optimization.OptimizationData;\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.SimpleBounds;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n import org.apache.commons.math3.optimization.PointValuePair;\n import org.apache.commons.math3.optimization.SimpleValueChecker;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar functions.\n- * This base class handles the boiler-plate methods associated to thresholds\n- * settings, iterations and evaluations counting.\n+ * This base class handles the boiler-plate methods associated to thresholds,\n+ * evaluations counting, initial guess and simple bounds settings.\n  *\n  * @param <FUNC> Type of the objective function to be optimized.\n  *\n     private GoalType goal;\n     /** Initial guess. */\n     private double[] start;\n+    /** Lower bounds. */\n+    private double[] lowerBound;\n+    /** Upper bounds. */\n+    private double[] upperBound;\n     /** Objective function. */\n     private MultivariateFunction function;\n \n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n      *  <li>{@link InitialGuess}</li>\n+     *  <li>{@link SimpleBounds}</li>\n      * </ul>\n      * @return the point/value pair giving the optimal value of the objective\n      * function.\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n      *  <li>{@link InitialGuess}</li>\n+     *  <li>{@link SimpleBounds}</li>\n      * </ul>\n      * @return the point/value pair giving the optimal value of the objective\n      * function.\n                                               GoalType goalType,\n                                               OptimizationData... optData)\n         throws TooManyEvaluationsException {\n+        // Set internal state.\n         evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n         function = f;\n         goal = goalType;\n+        // Retrieve other settings.\n         parseOptimizationData(optData);\n-\n+        // Check input consistency.\n+        checkParameters();\n         // Perform computation.\n         return doOptimize();\n     }\n      * @param optData Optimization data. The following data will be looked for:\n      * <ul>\n      *  <li>{@link InitialGuess}</li>\n+     *  <li>{@link SimpleBounds}</li>\n      * </ul>\n      */\n     private void parseOptimizationData(OptimizationData... optData) {\n                 start = ((InitialGuess) data).getInitialGuess();\n                 continue;\n             }\n+            if (data instanceof SimpleBounds) {\n+                final SimpleBounds bounds = (SimpleBounds) data;\n+                lowerBound = bounds.getLower();\n+                upperBound = bounds.getUpper();\n+                continue;\n+            }\n         }\n     }\n \n      * @return the initial guess.\n      */\n     public double[] getStartPoint() {\n-        return start.clone();\n+        return start == null ? null : start.clone();\n+    }\n+    /**\n+     * @return the lower bounds.\n+     */\n+    public double[] getLowerBound() {\n+        return lowerBound == null ? null : lowerBound.clone();\n+    }\n+    /**\n+     * @return the upper bounds.\n+     */\n+    public double[] getUpperBound() {\n+        return upperBound == null ? null : upperBound.clone();\n     }\n \n     /**\n      * objective function.\n      */\n     protected abstract PointValuePair doOptimize();\n+\n+    /**\n+     * Check parameters consistency.\n+     */\n+    private void checkParameters() {\n+        if (start != null) {\n+            final int dim = start.length;\n+            if (lowerBound != null) {\n+                if (lowerBound.length != dim) {\n+                    throw new DimensionMismatchException(lowerBound.length, dim);\n+                }\n+                for (int i = 0; i < dim; i++) {\n+                    final double v = start[i];\n+                    final double lo = lowerBound[i];\n+                    if (v < lo) {\n+                        throw new NumberIsTooSmallException(v, lo, true);\n+                    }\n+                }\n+            }\n+            if (upperBound != null) {\n+                if (upperBound.length != dim) {\n+                    throw new DimensionMismatchException(upperBound.length, dim);\n+                }\n+                for (int i = 0; i < dim; i++) {\n+                    final double v = start[i];\n+                    final double hi = upperBound[i];\n+                    if (v > hi) {\n+                        throw new NumberIsTooLargeException(v, hi, true);\n+                    }\n+                }\n+            }\n+\n+            // If the bounds were not specified, the allowed interval is\n+            // assumed to be [-inf, +inf].\n+            if (lowerBound == null) {\n+                lowerBound = new double[dim];\n+                for (int i = 0; i < dim; i++) {\n+                    lowerBound[i] = Double.NEGATIVE_INFINITY;\n+                }\n+            }\n+            if (upperBound == null) {\n+                upperBound = new double[dim];\n+                for (int i = 0; i < dim; i++) {\n+                    upperBound[i] = Double.POSITIVE_INFINITY;\n+                }\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n import org.apache.commons.math3.optimization.BaseMultivariateOptimizer;\n import org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer;\n import org.apache.commons.math3.optimization.GoalType;\n+import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.SimpleBounds;\n import org.apache.commons.math3.optimization.PointValuePair;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n-import org.apache.commons.math3.exception.NumberIsTooLargeException;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar functions,\n  *\n  * @version $Id$\n  * @since 3.0\n+ * @deprecated As of 3.1 since the {@link BaseAbstractMultivariateSimpleBoundsOptimizer\n+ * base class} contains similar functionality.\n  */\n+@Deprecated\n public abstract class BaseAbstractMultivariateSimpleBoundsOptimizer<FUNC extends MultivariateFunction>\n     extends BaseAbstractMultivariateOptimizer<FUNC>\n     implements BaseMultivariateOptimizer<FUNC>,\n                BaseMultivariateSimpleBoundsOptimizer<FUNC> {\n-    /** Lower bounds. */\n-    private double[] lowerBound;\n-    /** Upper bounds. */\n-    private double[] upperBound;\n-\n     /**\n      * Simple constructor with default settings.\n      * The convergence checker is set to a\n      * @return the lower bounds.\n      */\n     public double[] getLowerBound() {\n-        return lowerBound.clone();\n+        return super.getLowerBound();\n     }\n \n     /**\n      * @return the upper bounds.\n      */\n     public double[] getUpperBound() {\n-        return upperBound.clone();\n+        return super.getUpperBound();\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n-                                       double[] startPoint) {\n-        return optimize(maxEval, f, goalType, startPoint, null, null);\n+                                   double[] startPoint) {\n+        return super.optimizeInternal(maxEval, f, goalType,\n+                                      new InitialGuess(startPoint));\n     }\n \n     /** {@inheritDoc} */\n     public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n-                                       double[] startPoint,\n-                                       double[] lower, double[] upper) {\n-        // Checks.\n-        final int dim = startPoint.length;\n-        if (lower != null) {\n-            if (lower.length != dim) {\n-                throw new DimensionMismatchException(lower.length, dim);\n-            }\n-            for (int i = 0; i < dim; i++) {\n-                final double v = startPoint[i];\n-                final double lo = lower[i];\n-                if (v < lo) {\n-                    throw new NumberIsTooSmallException(v, lo, true);\n-                }\n-            }\n-        }\n-        if (upper != null) {\n-            if (upper.length != dim) {\n-                throw new DimensionMismatchException(upper.length, dim);\n-            }\n-            for (int i = 0; i < dim; i++) {\n-                final double v = startPoint[i];\n-                final double hi = upper[i];\n-                if (v > hi) {\n-                    throw new NumberIsTooLargeException(v, hi, true);\n-                }\n-            }\n-        }\n-\n-        // Initialization.\n-        if (lower == null) {\n-            lowerBound = new double[dim];\n-            for (int i = 0; i < dim; i++) {\n-                lowerBound[i] = Double.NEGATIVE_INFINITY;\n-            }\n-        } else {\n-            lowerBound = lower.clone();\n-        }\n-        if (upper == null) {\n-            upperBound = new double[dim];\n-            for (int i = 0; i < dim; i++) {\n-                upperBound[i] = Double.POSITIVE_INFINITY;\n-            }\n-        } else {\n-            upperBound = upper.clone();\n-        }\n-\n-        // Base class method performs the non bound-specific initializations.\n-        return super.optimize(maxEval, f, goalType, startPoint);\n+                                   double[] startPoint,\n+                                   double[] lower, double[] upper) {\n+        return super.optimizeInternal(maxEval, f, goalType,\n+                                      new InitialGuess(startPoint),\n+                                      new SimpleBounds(lower, upper));\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizerTest.java\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.PointValuePair;\n+import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.SimpleBounds;\n import org.junit.Assert;\n import org.junit.Test;\n \n         final double[] uB = boundaries == null ? null : boundaries[1];\n         final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints;\n         BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints);\n-        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n+        PointValuePair result = boundaries == null ?\n+            optim.optimize(maxEvaluations, func, goal,\n+                           new InitialGuess(startPoint)) :\n+            optim.optimize(maxEvaluations, func, goal,\n+                           new InitialGuess(startPoint),\n+                           new SimpleBounds(lB, uB));\n //        System.out.println(func.getClass().getName() + \" = \" \n //              + optim.getEvaluations() + \" f(\");\n //        for (double x: result.getPoint())  System.out.print(x + \" \");\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.PointValuePair;\n+import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.SimpleBounds;\n import org.apache.commons.math3.random.MersenneTwister;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n                                                   0, new MersenneTwister(), false);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n-        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n+        PointValuePair result = boundaries == null ?\n+            optim.optimize(maxEvaluations, func, goal,\n+                           new InitialGuess(startPoint)) :\n+            optim.optimize(maxEvaluations, func, goal,\n+                           new InitialGuess(startPoint),\n+                           new SimpleBounds(lB, uB));\n         // System.out.println(\"sol=\" + Arrays.toString(result.getPoint()));\n         Assert.assertEquals(expected.getValue(), result.getValue(), fTol);\n         for (int i = 0; i < dim; i++) {", "timestamp": 1350303413, "metainfo": ""}