{"sha": "19ceb4431cd859caa6dcd2593ba44af7a63580a2", "log": "implemented solver as an internal class to avoid building decomposed matrices  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n  *   <li>the <code>getRealEigenvalues</code> method has been renamed as {@link\n  *   #getEigenValues() getEigenValues},</li>\n  *   <li>the <code>getImagEigenvalues</code> method has been removed</li>\n+ *   <li>a {@link #getDeterminant() getDeterminant} method has been added.</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  * </ul>\n  * @see <a href=\"http://mathworld.wolfram.com/EigenDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix\">Wikipedia</a>\n      */\n     RealVector getEigenvector(int i);\n \n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for A &times; X = B.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n }\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n public class EigenDecompositionImpl implements EigenDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 3125911889630623276L;\n+    private static final long serialVersionUID = 1625101476333719659L;\n \n     /** Tolerance. */\n     private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n             findEigenVectors();\n         }\n         return eigenvectors[i].copy();\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    public double getDeterminant() {\n+        double determinant = 1;\n+        for (double lambda : eigenvalues) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+        return new Solver(eigenvalues, eigenvectors);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -8965845906036558410L;\n+\n+        /** Eigenvalues. */\n+        private final double[] eigenvalues;\n+\n+        /** Eigenvectors. */\n+        private final RealVectorImpl[] eigenvectors;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param eigenvalues eigenvalues\n+         * @param eigenvectors eigenvectors\n+         */\n+        private Solver(final double[] eigenvalues, final RealVectorImpl[] eigenvectors) {\n+            this.eigenvalues  = eigenvalues;\n+            this.eigenvectors = eigenvectors; \n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public double[] solve(final double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = eigenvalues.length;\n+            if (b.length != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final RealVectorImpl v = eigenvectors[i];\n+                final double[] vData = v.getDataRef();\n+                final double s = v.dotProduct(b) / eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVector solve(final RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = eigenvalues.length;\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final RealVectorImpl v = eigenvectors[i];\n+                final double[] vData = v.getDataRef();\n+                final double s = v.dotProduct(b) / eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix solve(final RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = eigenvalues.length;\n+            if (b.getRowDimension() != m) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            final double[][] bp = new double[m][nColB];\n+            for (int k = 0; k < nColB; ++k) {\n+                for (int i = 0; i < m; ++i) {\n+                    final RealVectorImpl v = eigenvectors[i];\n+                    final double[] vData = v.getDataRef();\n+                    double s = 0;\n+                    for (int j = 0; j < m; ++j) {\n+                        s += v.getEntry(j) * b.getEntry(j, k);\n+                    }\n+                    s /= eigenvalues[i];\n+                    for (int j = 0; j < m; ++j) {\n+                        bp[j][k] += s * vData[j];\n+                    }\n+                }\n+            }\n+\n+            return MatrixUtils.createRealMatrix(bp);\n+\n+        }\n+\n+        /**\n+         * Check if the decomposed matrix is non-singular.\n+         * @return true if the decomposed matrix is non-singular\n+         */\n+        public boolean isNonSingular() {\n+            for (double lambda : eigenvalues) {\n+                if (lambda == 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        /** Get the inverse of the decomposed matrix.\n+         * @return inverse matrix\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix getInverse()\n+            throws InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = eigenvalues.length;\n+            final double[][] invData = new double[m][m];\n+\n+            for (int i = 0; i < m; ++i) {\n+                final double[] invI = invData[i];\n+                for (int j = 0; j < m; ++j) {\n+                    double invIJ = 0;\n+                    for (int k = 0; k < m; ++k) {\n+                        final double[] vK = eigenvectors[k].getDataRef();\n+                        invIJ += vK[i] * vK[j] / eigenvalues[k];\n+                    }\n+                    invI[j] = invIJ;\n+                }\n+            }\n+            return MatrixUtils.createRealMatrix(invData);\n+\n+        }\n+\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/EigenSolver.java\n+++ b/src/java/org/apache/commons/math/linear/EigenSolver.java\n public class EigenSolver implements DecompositionSolver {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 4339008311386325953L;\n+    private static final long serialVersionUID = -74798755223915020L;\n \n-    /** Underlying decomposition. */\n-    private final EigenDecomposition decomposition;\n+    /** Underlying solver. */\n+    private final DecompositionSolver solver;\n+\n+    /** Determinant. */\n+    private final double determinant;\n \n     /**\n      * Simple constructor.\n      * @param decomposition decomposition to use\n      */\n     public EigenSolver(final EigenDecomposition decomposition) {\n-        this.decomposition = decomposition;\n+        this.solver      = decomposition.getSolver();\n+        this.determinant = decomposition.getDeterminant();\n     }\n \n     /** Solve the linear equation A &times; X = B for symmetric matrices A.\n      */\n     public double[] solve(final double[] b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] bp = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-            final RealVector v = decomposition.getEigenvector(i);\n-            final double s = v.dotProduct(b) / eigenvalues[i];\n-            for (int j = 0; j < m; ++j) {\n-                bp[j] += s * v.getEntry(j);\n-            }\n-        }\n-\n-        return bp;\n-\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B for symmetric matrices A.\n      */\n     public RealVector solve(final RealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.getDimension() != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] bp = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-            final RealVector v = decomposition.getEigenvector(i);\n-            final double s = v.dotProduct(b) / eigenvalues[i];\n-            for (int j = 0; j < m; ++j) {\n-                bp[j] += s * v.getEntry(j);\n-            }\n-        }\n-\n-        return new RealVectorImpl(bp, false);\n-\n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B for symmetric matrices A.\n      */\n     public RealMatrix solve(final RealMatrix b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-        final double[][] bp = new double[m][nColB];\n-        for (int k = 0; k < nColB; ++k) {\n-            for (int i = 0; i < m; ++i) {\n-                final RealVector v = decomposition.getEigenvector(i);\n-                double s = 0;\n-                for (int j = 0; j < m; ++j) {\n-                    s += v.getEntry(j) * b.getEntry(j, k);\n-                }\n-                s /= eigenvalues[i];\n-                for (int j = 0; j < m; ++j) {\n-                    bp[j][k] += s * v.getEntry(j);\n-                }\n-            }\n-        }\n-\n-        return MatrixUtils.createRealMatrix(bp);\n-\n+        return solver.solve(b);\n     }\n \n     /**\n      * @see #isNonSingular()\n      */\n     public double getDeterminant() {\n-        double determinant = 1;\n-        for (double lambda : decomposition.getEigenvalues()) {\n-            determinant *= lambda;\n-        }\n         return determinant;\n     }\n \n      * @return true if the decomposed matrix is non-singular\n      */\n     public boolean isNonSingular() {\n-        for (double lambda : decomposition.getEigenvalues()) {\n-            if (lambda == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        return solver.isNonSingular();\n     }\n \n     /** Get the inverse of the decomposed matrix.\n      */\n     public RealMatrix getInverse()\n         throws InvalidMatrixException {\n-\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        final double[][] invData = new double[m][m];\n-\n-        for (int i = 0; i < m; ++i) {\n-            final double[] invI = invData[i];\n-            for (int j = 0; j < m; ++j) {\n-                double invIJ = 0;\n-                for (int k = 0; k < m; ++k) {\n-                    final RealVector vK = decomposition.getEigenvector(k);\n-                    invIJ += vK.getEntry(i) * vK.getEntry(j) / eigenvalues[k];\n-                }\n-                invI[j] = invIJ;\n-            }\n-        }\n-        return MatrixUtils.createRealMatrix(invData);\n-\n+        return solver.getInverse();\n     }\n \n }", "timestamp": 1229952610, "metainfo": ""}