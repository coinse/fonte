{"sha": "ca850ee0de21fe95a3b840c66b8b9d409ef9f1ef", "log": "MATH-227.  fixed F distribution inverse CDF computation for small denominator degrees of freedom.  ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n /**\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.FDistribution}.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2008-02-08 09:44:11 -0600 (Fri, 08 Feb\n+ *          2008) $\n  */\n-public class FDistributionImpl\n-    extends AbstractContinuousDistribution\n-    implements FDistribution, Serializable  {\n-\n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -8516354193418641566L;\n-\n-    /** The numerator degrees of freedom*/\n-    private double numeratorDegreesOfFreedom;\n-\n-    /** The numerator degrees of freedom*/\n-    private double denominatorDegreesOfFreedom;\n-    \n-    /**\n-     * Create a F distribution using the given degrees of freedom.\n-     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n-     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n-     */\n-    public FDistributionImpl(double numeratorDegreesOfFreedom,\n-            double denominatorDegreesOfFreedom) {\n-        super();\n-        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n-        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n-    }\n-    \n-    /**\n-     * For this distribution, X, this method returns P(X &lt; x).\n-     * \n-     * The implementation of this method is based on:\n-     * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n-     * F-Distribution</a>, equation (4).</li>\n-     * </ul>\n-     * \n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n-        double ret;\n-        if (x <= 0.0) {\n-            ret = 0.0;\n-        } else {\n-            double n = getNumeratorDegreesOfFreedom();\n-            double m = getDenominatorDegreesOfFreedom();\n-            \n-            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n-                0.5 * n,\n-                0.5 * m);\n-        }\n-        return ret;\n-    }\n-    \n-    /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n-     */\n-    public double inverseCumulativeProbability(final double p) \n-        throws MathException {\n-        if (p == 0) {\n-            return 0d;\n-        }\n-        if (p == 1) {\n-            return Double.POSITIVE_INFINITY;\n-        }\n-        return super.inverseCumulativeProbability(p);\n-    }\n-        \n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-     */\n-    protected double getDomainLowerBound(double p) {\n-        return 0.0;\n-    }\n-\n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-     */\n-    protected double getDomainUpperBound(double p) {\n-        return Double.MAX_VALUE;\n-    }\n-\n-    /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n-     */\n-    protected double getInitialDomain(double p) {\n-        return getDenominatorDegreesOfFreedom() /\n-            (getDenominatorDegreesOfFreedom() - 2.0);\n-    }\n-    \n-    /**\n-     * Modify the numerator degrees of freedom.\n-     * @param degreesOfFreedom the new numerator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     */\n-    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n-        if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"degrees of freedom must be positive.\");\n-        }\n-        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n-    }\n-    \n-    /**\n-     * Access the numerator degrees of freedom.\n-     * @return the numerator degrees of freedom.\n-     */\n-    public double getNumeratorDegreesOfFreedom() {\n-        return numeratorDegreesOfFreedom;\n-    }\n-    \n-    /**\n-     * Modify the denominator degrees of freedom.\n-     * @param degreesOfFreedom the new denominator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     */\n-    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n-        if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"degrees of freedom must be positive.\");\n-        }\n-        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n-    }\n-    \n-    /**\n-     * Access the denominator degrees of freedom.\n-     * @return the denominator degrees of freedom.\n-     */\n-    public double getDenominatorDegreesOfFreedom() {\n-        return denominatorDegreesOfFreedom;\n-    }\n+public class FDistributionImpl extends AbstractContinuousDistribution implements\n+\t\tFDistribution, Serializable {\n+\n+\t/** Serializable version identifier */\n+\tprivate static final long serialVersionUID = -8516354193418641566L;\n+\n+\t/** The numerator degrees of freedom */\n+\tprivate double numeratorDegreesOfFreedom;\n+\n+\t/** The numerator degrees of freedom */\n+\tprivate double denominatorDegreesOfFreedom;\n+\n+\t/**\n+\t * Create a F distribution using the given degrees of freedom.\n+\t * \n+\t * @param numeratorDegreesOfFreedom\n+\t *            the numerator degrees of freedom.\n+\t * @param denominatorDegreesOfFreedom\n+\t *            the denominator degrees of freedom.\n+\t */\n+\tpublic FDistributionImpl(double numeratorDegreesOfFreedom,\n+\t\t\tdouble denominatorDegreesOfFreedom) {\n+\t\tsuper();\n+\t\tsetNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+\t\tsetDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+\t}\n+\n+\t/**\n+\t * For this distribution, X, this method returns P(X &lt; x).\n+\t * \n+\t * The implementation of this method is based on:\n+\t * <ul>\n+\t * <li>\n+\t * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+\t * F-Distribution</a>, equation (4).</li>\n+\t * </ul>\n+\t * \n+\t * @param x\n+\t *            the value at which the CDF is evaluated.\n+\t * @return CDF for this distribution.\n+\t * @throws MathException\n+\t *             if the cumulative probability can not be computed due to\n+\t *             convergence or other numerical errors.\n+\t */\n+\tpublic double cumulativeProbability(double x) throws MathException {\n+\t\tdouble ret;\n+\t\tif (x <= 0.0) {\n+\t\t\tret = 0.0;\n+\t\t} else {\n+\t\t\tdouble n = getNumeratorDegreesOfFreedom();\n+\t\t\tdouble m = getDenominatorDegreesOfFreedom();\n+\n+\t\t\tret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\t/**\n+\t * For this distribution, X, this method returns the critical point x, such\n+\t * that P(X &lt; x) = <code>p</code>.\n+\t * <p>\n+\t * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.\n+\t * </p>\n+\t * \n+\t * @param p\n+\t *            the desired probability\n+\t * @return x, such that P(X &lt; x) = <code>p</code>\n+\t * @throws MathException\n+\t *             if the inverse cumulative probability can not be computed due\n+\t *             to convergence or other numerical errors.\n+\t * @throws IllegalArgumentException\n+\t *             if <code>p</code> is not a valid probability.\n+\t */\n+\tpublic double inverseCumulativeProbability(final double p)\n+\t\t\tthrows MathException {\n+\t\tif (p == 0) {\n+\t\t\treturn 0d;\n+\t\t}\n+\t\tif (p == 1) {\n+\t\t\treturn Double.POSITIVE_INFINITY;\n+\t\t}\n+\t\treturn super.inverseCumulativeProbability(p);\n+\t}\n+\n+\t/**\n+\t * Access the domain value lower bound, based on <code>p</code>, used to\n+\t * bracket a CDF root. This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p\n+\t *            the desired probability for the critical value\n+\t * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n+\t *         <code>p</code>\n+\t */\n+\tprotected double getDomainLowerBound(double p) {\n+\t\treturn 0.0;\n+\t}\n+\n+\t/**\n+\t * Access the domain value upper bound, based on <code>p</code>, used to\n+\t * bracket a CDF root. This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p\n+\t *            the desired probability for the critical value\n+\t * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n+\t *         <code>p</code>\n+\t */\n+\tprotected double getDomainUpperBound(double p) {\n+\t\treturn Double.MAX_VALUE;\n+\t}\n+\n+\t/**\n+\t * Access the initial domain value, based on <code>p</code>, used to bracket\n+\t * a CDF root. This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p\n+\t *            the desired probability for the critical value\n+\t * @return initial domain value\n+\t */\n+\tprotected double getInitialDomain(double p) {\n+\t\tdouble ret = 1.0;\n+\t\tdouble d = getDenominatorDegreesOfFreedom();\n+\t\tif (d > 2.0) {\n+\t\t\t// use mean\n+\t\t\tret = d / (d - 2.0);\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\t/**\n+\t * Modify the numerator degrees of freedom.\n+\t * \n+\t * @param degreesOfFreedom\n+\t *            the new numerator degrees of freedom.\n+\t * @throws IllegalArgumentException\n+\t *             if <code>degreesOfFreedom</code> is not positive.\n+\t */\n+\tpublic void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n+\t\tif (degreesOfFreedom <= 0.0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"degrees of freedom must be positive.\");\n+\t\t}\n+\t\tthis.numeratorDegreesOfFreedom = degreesOfFreedom;\n+\t}\n+\n+\t/**\n+\t * Access the numerator degrees of freedom.\n+\t * \n+\t * @return the numerator degrees of freedom.\n+\t */\n+\tpublic double getNumeratorDegreesOfFreedom() {\n+\t\treturn numeratorDegreesOfFreedom;\n+\t}\n+\n+\t/**\n+\t * Modify the denominator degrees of freedom.\n+\t * \n+\t * @param degreesOfFreedom\n+\t *            the new denominator degrees of freedom.\n+\t * @throws IllegalArgumentException\n+\t *             if <code>degreesOfFreedom</code> is not positive.\n+\t */\n+\tpublic void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n+\t\tif (degreesOfFreedom <= 0.0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"degrees of freedom must be positive.\");\n+\t\t}\n+\t\tthis.denominatorDegreesOfFreedom = degreesOfFreedom;\n+\t}\n+\n+\t/**\n+\t * Access the denominator degrees of freedom.\n+\t * \n+\t * @return the denominator degrees of freedom.\n+\t */\n+\tpublic double getDenominatorDegreesOfFreedom() {\n+\t\treturn denominatorDegreesOfFreedom;\n+\t}\n }\n--- a/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n         double x = fd.inverseCumulativeProbability(p);\n         assertEquals(.999, x, 1.0e-5);\n     }\n+\n+    public void testSmallDegreesOfFreedom() throws Exception {\n+        org.apache.commons.math.distribution.FDistributionImpl fd =\n+            new org.apache.commons.math.distribution.FDistributionImpl(\n+                1.0, 1.0);\n+        double p = fd.cumulativeProbability(0.975);\n+        double x = fd.inverseCumulativeProbability(p);\n+        assertEquals(0.975, x, 1.0e-5);\n+\n+        fd.setDenominatorDegreesOfFreedom(2.0);\n+        p = fd.cumulativeProbability(0.975);\n+        x = fd.inverseCumulativeProbability(p);\n+        assertEquals(0.975, x, 1.0e-5);\n+    }\n }", "timestamp": 1222398593, "metainfo": ""}