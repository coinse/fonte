{"sha": "3bbddff0bb4e9550f9c13df1e9190e61c57aef2e", "log": "Added a way to compute sub-lines intersections, considering sub-lines either as open sets or closed sets.  JIRA: MATH-591   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.Region.Location;\n import org.apache.commons.math.geometry.partitioning.Side;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.util.FastMath;\n         }\n \n         return segments;\n+\n+    }\n+\n+    /** Get the intersection of the instance and another sub-line.\n+     * <p>\n+     * This method is related to the {@link Line#intersection(Hyperplane)\n+     * intersection} method in the {@link Line Line} class, but in addition\n+     * to compute the point along infinite lines, it also checks the point\n+     * lies on both sub-line ranges.\n+     * </p>\n+     * @param subLine other sub-line which may intersect instance\n+     * @param includeEndPoints if true, endpoints are considered to belong to\n+     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n+     * are considered to not belong to instance (i.e. they are open sets) and intersection\n+     * occurring on endpoints lead to null being returned\n+     * @return the intersection point if there is one, null if the sub-lines don't intersect\n+     */\n+    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n+\n+        // retrieve the underlying lines\n+        Line line1 = (Line) getHyperplane();\n+        Line line2 = (Line) subLine.getHyperplane();\n+\n+        // compute the intersection on infinite line\n+        Vector2D v2D = line1.intersection(line2);\n+\n+        // check location of point with respect to first sub-line\n+        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+\n+        // check location of point with respect to second sub-line\n+        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n+\n+        if (includeEndPoints) {\n+            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n+        } else {\n+            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n+        }\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/twod/SubLineTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twod/SubLineTest.java\n                           segments.get(0)[1].getY() > 0);\n     }\n \n+    @Test\n+    public void testIntersectionInsideInside() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 2));\n+        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testIntersectionInsideBoundary() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1));\n+        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionInsideOutside() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionBoundaryBoundary() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1));\n+        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionBoundaryOutside() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionOutsideOutside() {\n+        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(1.5, 1));\n+        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n }", "timestamp": 1308595213, "metainfo": ""}