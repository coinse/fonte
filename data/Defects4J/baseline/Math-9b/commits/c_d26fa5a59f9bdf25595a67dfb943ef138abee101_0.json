{"sha": "d26fa5a59f9bdf25595a67dfb943ef138abee101", "log": "improved javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n  */\n package org.apache.commons.math.util;\n \n+import org.apache.commons.math.exception.DimensionMismatchException;\n+\n /**\n  * Faster, more accurate, portable alternative to {@link Math} and\n  * {@link StrictMath} for large scale computation.\n  * <p>\n+ * FastMath is a drop-in replacement for both Math and StrictMath. This\n+ * means that for any method in Math (say {@code Math.sin(x)} or\n+ * {@code Math.cbrt(y)}), user can directly change the class and use the\n+ * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}\n+ * in the previous example).\n+ * </p>\n+ * <p>\n  * FastMath speed is achieved by relying heavily on optimizing compilers\n- * to native code present in many JVM todays and use of large tables that\n- * are computed once at class loading (regardless of the number of subsequent\n- * calls to computation methods). This implies that FastMath is targeted\n- * more towards large scale computation (i.e. computation that take at least\n- * a handful of seconds to complete) on desktop or server machines rather\n- * than very small utilities on devices with limited power (i.e. computation\n- * that should return a result almost instantly). Note that FastMath is\n+ * to native code present in many JVM todays and use of large tables.\n+ * Precomputed literal arrays are provided in this class to speed up load\n+ * time. If users prefer to compute the tables automatically at load time,\n+ * they can change the compile-time constant {@code USE_PRECOMPUTED_TABLES}\n+ * and set it to {@code false}. This will increase class load time at first\n+ * use, but this overhead will occur only once per run, regardless of the\n+ * number of subsequent calls to computation methods. Note that FastMath is\n  * extensively used inside Apache Commons Math, so by calling some algorithms,\n- * the one-shot overhead will occur regardless of the end-user calling FastMath\n- * methods directly or not. Performance figures for a specific JVM and hardware\n- * can be evaluated by running the FastMathTestPerformance tests in the test\n- * directory of the source distribution.\n+ * the one-shot overhead when the constant is set to false will occur\n+ * regardless of the end-user calling FastMath methods directly or not.\n+ * Performance figures for a specific JVM and hardware can be evaluated by\n+ * running the FastMathTestPerformance tests in the test directory of the source\n+ * distribution.\n  * </p>\n  * <p>\n  * FastMath accuracy should be mostly independent of the JVM as it relies only\n  * Maker's Dilemma</a>).\n  * </p>\n  * <p>\n- * Additionally implements the following methods not found in StrictMath:\n+ * FastMath additionally implements the following methods not found in Math/StrictMath:\n  * <ul>\n  * <li>{@link #asinh(double)}</li>\n  * <li>{@link #acosh(double)}</li>\n  * <li>{@link #atanh(double)}</li>\n  * </ul>\n- * The following methods are found in StrictMath since 1.6 only\n+ * The following methods are found in Math/StrictMath since 1.6 only, they are provided\n+ * by FastMath even in 1.5 Java virtual machines\n  * <ul>\n  * <li>{@link #copySign(double, double)}</li>\n  * <li>{@link #getExponent(double)}</li>\n  * <li>{@link #nextUp(float)}</li>\n  * <li>{@link #scalb(float, int)}</li>\n  * </ul>\n+ * </p>\n  * @version $Id$\n  * @since 2.2\n  */\n     /** Napier's constant e, base of the natural logarithm. */\n     public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n \n+    /** Index of exp(0) in the array of integer exponentials. */\n     private static final int EXP_INT_TABLE_MAX_INDEX = 750;\n+\n+    /** Length of the array of integer exponentials. */\n     private static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n \n-    private static final boolean INIT_TABLES = false;\n+    /** Indicator for precomputed tables.\n+     * <p>\n+     * This compile-time constant should be set to true only if one explicitly\n+     * wants to compute the tables at class loading time instead of using the\n+     * already computed ones provided as literal arrays below.\n+     * </p>\n+     */\n+    private static final boolean USE_PRECOMPUTED_TABLES = false;\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n     private static class ExpIntTable {\n         private static final double[] EXP_INT_TABLE_B;\n \n         static {\n-            if (FastMath.INIT_TABLES) {\n+            if (FastMath.USE_PRECOMPUTED_TABLES) {\n                 EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                 EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n \n           private static final double[] EXP_FRAC_TABLE_B;\n \n           static {\n-              if (FastMath.INIT_TABLES) {\n+              if (FastMath.USE_PRECOMPUTED_TABLES) {\n                   EXP_FRAC_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                   EXP_FRAC_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n \n           private static final double[][] LN_MANT;\n \n           static {\n-              if (FastMath.INIT_TABLES) {\n+              if (FastMath.USE_PRECOMPUTED_TABLES) {\n                   LN_MANT = new double[FastMath.LN_MANT_LEN][];\n \n                   // Populate lnMant table\n     \n     // Initialize tables\n     // static {\n-    //   if (INIT_TABLES) { // suppress table initialisation as now hard-coded\n+    //   if (USE_PRECOMPUTED_TABLES) { // suppress table initialisation as now hard-coded\n     //     int i;\n \n     //     // Generate an array of factorials\n             System.out.print(\"        {\");\n             for(double d : array) { // assume inner array has very few entries\n                 String ds = d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n-                System.out.printf(\"%-25.25s\",ds); // mulitple entries per line\n+                System.out.printf(\"%-25.25s\",ds); // multiple entries per line\n             }\n             System.out.println(\"}, // \"+i++);\n         }\n \n     private static void checkLen(int expectedLen, int actual) {\n         if (expectedLen != actual) {\n-            System.out.println(\"Error - expected length \"+expectedLen+\" actual \"+actual);\n+            throw new DimensionMismatchException(actual, expectedLen);\n         }\n     }\n \n \n     /** Build the sine and cosine tables.\n      */\n+    @SuppressWarnings(\"unused\")\n     private static void buildSinCosTables() {\n         final double result[] = new double[2];\n ", "timestamp": 1315744533, "metainfo": ""}