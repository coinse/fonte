{"sha": "804309e5c5726ad22b0c74dfccdb1ed318f0a108", "log": "MATH-566 Created \"ExceptionContext\" class. Made \"MathIllegalArgumentException\" inherit from the Java standard \"IllegalArgumentException\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n package org.apache.commons.math.exception;\n \n import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.ExceptionContext;\n+import org.apache.commons.math.exception.util.ExceptionContextProvider;\n \n /**\n  * Base class for all preconditions violation exceptions.\n  * In most cases, this class should not be instantiated directly: it should\n- * serve as a base class to create all the exceptions that share the semantics\n- * of the standard {@link IllegalArgumentException}, but must also provide a\n- * localized message.\n+ * serve as a base class to create all the exceptions that have the semantics\n+ * of the standard {@link IllegalArgumentException}.\n  *\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class MathIllegalArgumentException extends MathRuntimeException {\n+public class MathIllegalArgumentException extends IllegalArgumentException\n+    implements ExceptionContextProvider {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n+    /** Context. */\n+    private final ExceptionContext context = new ExceptionContext();\n \n     /**\n      * @param pattern Message pattern explaining the cause of the error.\n      */\n     public MathIllegalArgumentException(Localizable pattern,\n                                         Object ... args) {\n-        addMessage(pattern, args);\n+        context.addMessage(pattern, args);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ExceptionContext getContext() {\n+        return context;\n+    }\n+\n+   /** {@inheritDoc} */\n+    @Override\n+    public String getMessage() {\n+        return context.getMessage();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getLocalizedMessage() {\n+        return context.getLocalizedMessage();\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/util/ExceptionContext.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception.util;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.util.HashMap;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+\n+/**\n+ * Class that contains the actual implementation of the functionality mandated\n+ * by the {@link ExceptionContext} interface.\n+ * All Commons Math exceptions delegate the interface's methods to this class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ExceptionContext implements Serializable {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -6024911025449780478L;\n+    /**\n+     * Various informations that enrich the informative message.\n+     */\n+    private List<Localizable> msgPatterns = new ArrayList<Localizable>();\n+    /**\n+     * Various informations that enrich the informative message.\n+     * The arguments will replace the corresponding place-holders in\n+     * {@link #msgPatterns}.\n+     */\n+    private List<Object[]> msgArguments = new ArrayList<Object[]>();\n+    /**\n+     * Arbitrary context information.\n+     */\n+    private Map<String, Object> context = new HashMap<String, Object>();\n+\n+    /**\n+     * Sets a message.\n+     *\n+     * @param pattern Message pattern.\n+     * @param arguments Values for replacing the placeholders in the message\n+     * pattern.\n+     */\n+    public void addMessage(Localizable pattern,\n+                           Object ... arguments) {\n+        msgPatterns.add(pattern);\n+        msgArguments.add(ArgUtils.flatten(arguments));\n+    }\n+\n+    /**\n+     * Sets the context (key, value) pair.\n+     * Keys are assumed to be unique within an instance. If the same key is\n+     * assigned a new value, the previous one will be lost.\n+     *\n+     * @param key Context key (not null).\n+     * @param value Context value.\n+     */\n+    public void setValue(String key, Object value) {\n+        context.put(key, value);\n+    }\n+\n+    /**\n+     * Gets the value associated to the given context key.\n+     *\n+     * @param key Context key.\n+     * @return the context value or {@code null} if the key does not exist.\n+     */\n+    public Object getValue(String key) {\n+        return context.get(key);\n+    }\n+\n+    /**\n+     * Gets all the keys stored in the exception\n+     *\n+     * @return the set of keys.\n+     */\n+    public Set<String> getKeys() {\n+        return context.keySet();\n+    }\n+\n+    /**\n+     * Gets the default message.\n+     *\n+     * @return the message.\n+     */\n+    public String getMessage() {\n+        return getMessage(Locale.US);\n+    }\n+\n+    /**\n+     * Gets the message in the default locale.\n+     *\n+     * @return the localized message.\n+     */\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     * @return the localized message.\n+     */\n+    public String getMessage(final Locale locale) {\n+        return buildMessage(locale, \": \");\n+    }\n+\n+    /**\n+     * Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     * @param separator Separator inserted between the message parts.\n+     * @return the localized message.\n+     */\n+    public String getMessage(final Locale locale,\n+                             final String separator) {\n+        return buildMessage(locale, separator);\n+    }\n+\n+    /**\n+     * Builds a message string.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     * @param separator Message separator.\n+     * @return a localized message string.\n+     */\n+    private String buildMessage(Locale locale,\n+                                String separator) {\n+        final StringBuilder sb = new StringBuilder();\n+        int count = 0;\n+        final int len = msgPatterns.size();\n+        for (int i = 0; i < len; i++) {\n+            final Localizable pat = msgPatterns.get(i);\n+            final Object[] args = msgArguments.get(i);\n+            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n+                                                        locale);\n+            sb.append(fmt.format(args));\n+            if (++count < len) {\n+                // Add a separator if there are other messages.\n+                sb.append(separator);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Serialize this object to the given stream.\n+     *\n+     * @param out Stream.\n+     * @throws IOException This should never happen.\n+     */\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException {\n+        serializeMessages(out);\n+        serializeContext(out);\n+    }\n+    /**\n+     * Deserialize this object from the given stream.\n+     *\n+     * @param in Stream.\n+     * @throws IOException This should never happen.\n+     * @throws ClassNotFoundException This should never happen.\n+     */\n+    private void readObject(ObjectInputStream in)\n+        throws IOException,\n+               ClassNotFoundException {\n+        deSerializeMessages(in);\n+        deSerializeContext(in);\n+    }\n+\n+    /**\n+     * Serialize  {@link #msgPatterns} and {@link #msgArguments}.\n+     *\n+     * @param out Stream.\n+     * @throws IOException This should never happen.\n+     */\n+    private void serializeMessages(ObjectOutputStream out)\n+        throws IOException {\n+        // Step 1.\n+        final int len = msgPatterns.size();\n+        out.writeInt(len);\n+        // Step 2.\n+        for (int i = 0; i < len; i++) {\n+            final Localizable pat = msgPatterns.get(i);\n+            // Step 3.\n+            out.writeObject(pat);\n+            final Object[] args = msgArguments.get(i);\n+            final int aLen = args.length;\n+            // Step 4.\n+            out.writeInt(aLen);\n+            for (int j = 0; j < aLen; j++) {\n+                if (args[j] instanceof Serializable) {\n+                    // Step 5a.\n+                    out.writeObject(args[j]);\n+                } else {\n+                    // Step 5b.\n+                    out.writeObject(nonSerializableReplacement(args[j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deserialize {@link #msgPatterns} and {@link #msgArguments}.\n+     *\n+     * @param in Stream.\n+     * @throws IOException This should never happen.\n+     * @throws ClassNotFoundException This should never happen.\n+     */\n+    private void deSerializeMessages(ObjectInputStream in)\n+        throws IOException,\n+               ClassNotFoundException {\n+        // Step 1.\n+        final int len = in.readInt();\n+        msgPatterns = new ArrayList<Localizable>(len);\n+        msgArguments = new ArrayList<Object[]>(len);\n+        // Step 2.\n+        for (int i = 0; i < len; i++) {\n+            // Step 3.\n+            final Localizable pat = (Localizable) in.readObject();\n+            msgPatterns.add(pat);\n+            // Step 4.\n+            final int aLen = in.readInt();\n+            final Object[] args = new Object[aLen];\n+            for (int j = 0; j < aLen; j++) {\n+                // Step 5.\n+                args[j] = in.readObject();\n+            }\n+            msgArguments.add(args);\n+        }\n+    }\n+\n+    /**\n+     * Serialize {@link #context}.\n+     *\n+     * @param out Stream.\n+     * @throws IOException This should never happen.\n+     */\n+    private void serializeContext(ObjectOutputStream out)\n+        throws IOException {\n+        // Step 1.\n+        final int len = context.keySet().size();\n+        out.writeInt(len);\n+        for (String key : context.keySet()) {\n+            // Step 2.\n+            out.writeObject(key);\n+            final Object value = context.get(key);\n+            if (value instanceof Serializable) {\n+                // Step 3a.\n+                out.writeObject(value);\n+            } else {\n+                // Step 3b.\n+                out.writeObject(nonSerializableReplacement(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deserialize {@link #context}.\n+     *\n+     * @param in Stream.\n+     * @throws IOException This should never happen.\n+     * @throws ClassNotFoundException This should never happen.\n+     */\n+    private void deSerializeContext(ObjectInputStream in)\n+        throws IOException,\n+               ClassNotFoundException {\n+        // Step 1.\n+        final int len = in.readInt();\n+        context = new HashMap<String, Object>();\n+        for (int i = 0; i < len; i++) {\n+            // Step 2.\n+            final String key = (String) in.readObject();\n+            // Step 3.\n+            final Object value = in.readObject();\n+            context.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Replaces a non-serializable object with an error message string.\n+     *\n+     * @param obj Object that does not implement the {@code Serializable\n+     * interface.\n+     * @return a string that mentions which class could not be serialized.\n+     */\n+    private String nonSerializableReplacement(Object obj) {\n+        return \"[Object could not be serialized: \" + obj.getClass().getName() + \"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/util/ExceptionContextProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception.util;\n+\n+/**\n+ * Interface for accessing the context data structure stored in Commons Math\n+ * exceptions.\n+ *\n+ * @version $Id$\n+ */\n+public interface ExceptionContextProvider {\n+    /**\n+     * Gets a reference to the \"rich context\" data structure that allows to\n+     * customize error messages and store key, value pairs in exceptions.\n+     *\n+     * @return a reference to the exception context.\n+     */\n+    ExceptionContext getContext();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/util/ExceptionContextTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception.util;\n+\n+import java.util.Locale;\n+import java.util.Arrays;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link ExceptionContext}.\n+ * \n+ * @version $Id$\n+ */\n+public class ExceptionContextTest {\n+    @Test\n+    public void testMessageChain() {\n+        final ExceptionContext c = new ExceptionContext();\n+        final String sep = \" | \"; // Non-default separator.\n+        final String m1 = \"column index (0)\";\n+        c.addMessage(LocalizedFormats.COLUMN_INDEX, 0);\n+        final String m2 = \"got 1x2 but expected 3x4\";\n+        c.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2, 1, 2, 3, 4);\n+        final String m3 = \"It didn't work out\";\n+        c.addMessage(LocalizedFormats.SIMPLE_MESSAGE, m3);\n+\n+        Assert.assertEquals(c.getMessage(Locale.US, sep),\n+                            m1 + sep + m2 + sep + m3);\n+    }\n+\n+    @Test\n+    public void testNoArgAddMessage() {\n+        final ExceptionContext c = new ExceptionContext();\n+        c.addMessage(LocalizedFormats.SIMPLE_MESSAGE);\n+        Assert.assertEquals(c.getMessage(), \"{0}\");\n+    }\n+\n+    @Test\n+    public void testContext() {\n+        final ExceptionContext c = new ExceptionContext();\n+\n+        final String[] keys = {\"Key 1\", \"Key 2\"};\n+        final Object[] values = {\"Value 1\", Integer.valueOf(2)};\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            c.setValue(keys[i], values[i]);\n+        }\n+\n+        // Check that all keys are present.\n+        Assert.assertTrue(c.getKeys().containsAll(Arrays.asList(keys)));\n+\n+        // Check that all values are correctly stored.\n+        for (int i = 0; i < keys.length; i++) {\n+            Assert.assertEquals(values[i], c.getValue(keys[i]));\n+        }\n+\n+        // Check behaviour on missing key.\n+        Assert.assertNull(c.getValue(\"xyz\"));\n+    }\n+\n+    @Test\n+    public void testSerialize()\n+        throws IOException,\n+               ClassNotFoundException {\n+        final ExceptionContext cOut = new ExceptionContext();\n+        cOut.addMessage(LocalizedFormats.COLUMN_INDEX, 0);\n+        cOut.setValue(\"Key 1\", Integer.valueOf(0));\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(bos);\n+        oos.writeObject(cOut);\n+\n+        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(bis);\n+        ExceptionContext cIn = (ExceptionContext) ois.readObject();\n+\n+        Assert.assertTrue(cOut.getMessage().equals(cIn.getMessage()));\n+        for (String key : cIn.getKeys()) {\n+            Assert.assertTrue(cOut.getValue(key).equals(cIn.getValue(key)));\n+        }\n+    }\n+\n+    @Test\n+    public void testSerializeUnserializable() {\n+        final ExceptionContext cOut = new ExceptionContext();\n+        cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, \"OK\");\n+        cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, new Unserializable());\n+        String key = \"Key 1\";\n+        cOut.setValue(key, new Unserializable());\n+\n+        try {\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream oos = new ObjectOutputStream(bos);\n+            oos.writeObject(cOut);\n+\n+            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+            ObjectInputStream ois = new ObjectInputStream(bis);\n+            ExceptionContext cIn = (ExceptionContext) ois.readObject();\n+\n+            String nsObjStr = (String) cIn.getValue(key);\n+            Assert.assertTrue(nsObjStr.matches(\".*could not be serialized.*\"));\n+        } catch (Exception e) {\n+            Assert.fail(e.toString());\n+        }\n+    }\n+\n+    /**\n+     * Class used by {@link #testSerializeUnserializable()}.\n+     */\n+    private static class Unserializable {\n+        Unserializable() {}\n+    }\n+}", "timestamp": 1304599051, "metainfo": ""}