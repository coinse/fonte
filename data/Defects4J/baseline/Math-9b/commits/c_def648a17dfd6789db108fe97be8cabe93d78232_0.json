{"sha": "def648a17dfd6789db108fe97be8cabe93d78232", "log": "updated direct algorithms with latest interfaces definitions  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.optimization.ScalarConvergenceChecker;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.ScalarOptimizer;\n-import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /** \n  * before optimization is attempted, an explicit call to the first method\n  * with all steps set to +1 is triggered, thus building a default\n  * configuration from a unit hypercube. Each call to {@link\n- * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize} will reuse\n+ * #optimize(MultivariateRealFunction, GoalType, double[]) optimize} will reuse\n  * the current start configuration and move it such that its first vertex\n  * is at the provided start point of the optimization. If the same optimizer\n  * is used to solve different problems and the number of parameters change,\n  * the start configuration <em>must</em> be reset or a dimension mismatch\n  * will occur.</p>\n  *\n- * <p>If {@link #setConvergenceChecker(ScalarConvergenceChecker)} is not called,\n+ * <p>If {@link #setConvergenceChecker(RealConvergenceChecker)} is not called,\n  * a default {@link SimpleScalarValueChecker} is used.</p>\n  *\n  * <p>Convergence is checked by providing the <em>worst</em> points of\n  * performed by the derived classes according to the implemented\n  * algorithms.</p>\n  *\n- * @see ScalarObjectiveFunction\n+ * @see MultivariateRealFunction\n  * @see NelderMead\n  * @see MultiDirectional\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public abstract class DirectSearchOptimizer implements ScalarOptimizer {\n+public abstract class DirectSearchOptimizer implements MultivariateRealOptimizer {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4299910390345933369L;\n \n     /** Simplex. */\n-    protected ScalarPointValuePair[] simplex;\n+    protected RealPointValuePair[] simplex;\n \n     /** Objective function. */\n-    private ScalarObjectiveFunction f;\n+    private MultivariateRealFunction f;\n \n     /** Convergence checker. */\n-    private ScalarConvergenceChecker checker;\n+    private RealConvergenceChecker checker;\n \n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ScalarConvergenceChecker checker) {\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n         this.checker = checker;\n     }\n \n     /** {@inheritDoc} */\n-    public ScalarConvergenceChecker getConvergenceChecker() {\n+    public RealConvergenceChecker getConvergenceChecker() {\n         return checker;\n     }\n \n     /** {@inheritDoc} */\n-    public ScalarPointValuePair optimize(final ScalarObjectiveFunction f, final GoalType goalType,\n+    public RealPointValuePair optimize(final MultivariateRealFunction f,\n+                                         final GoalType goalType,\n                                          final double[] startPoint)\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException, OptimizationException,\n+        IllegalArgumentException {\n \n         if (startConfiguration == null) {\n             // no initial configuration has been set up for simplex\n         }\n \n         this.f = f;\n-        final Comparator<ScalarPointValuePair> comparator = new Comparator<ScalarPointValuePair>() {\n-            public int compare(final ScalarPointValuePair o1, final ScalarPointValuePair o2) {\n-                final double v1 = o1.getValue();\n-                final double v2 = o2.getValue();\n-                return (goalType == GoalType.MINIMIZE) ?\n-                        Double.compare(v1, v2) : Double.compare(v2, v1);\n-            }\n-        };\n+        final Comparator<RealPointValuePair> comparator =\n+            new Comparator<RealPointValuePair>() {\n+                public int compare(final RealPointValuePair o1,\n+                                   final RealPointValuePair o2) {\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goalType == GoalType.MINIMIZE) ?\n+                            Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            };\n \n         // initialize search\n         iterations  = 0;\n         buildSimplex(startPoint);\n         evaluateSimplex(comparator);\n \n-        ScalarPointValuePair[] previous = new ScalarPointValuePair[simplex.length];\n+        RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\n         while (true) {\n \n             if (iterations > 0) {\n \n     /** Compute the next simplex of the algorithm.\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n-     * @exception ObjectiveException if the function cannot be evaluated at\n+     * @exception FunctionEvaluationException if the function cannot be evaluated at\n      * some point\n      * @exception OptimizationException if the algorithm fails to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n-    protected abstract void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+    protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n     /** Evaluate the objective function on one point.\n      * <p>A side effect of this method is to count the number of\n      * function evaluations</p>\n      * @param x point on which the objective function should be evaluated\n      * @return objective function value at the given point\n-     * @exception ObjectiveException if no value can be computed for the parameters\n+     * @exception FunctionEvaluationException if no value can be computed for the parameters\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n     protected double evaluate(final double[] x)\n-        throws ObjectiveException, IllegalArgumentException {\n+        throws FunctionEvaluationException, IllegalArgumentException {\n         evaluations++;\n-        return f.objective(x);\n+        return f.value(x);\n     }\n \n     /** Build an initial simplex.\n         }\n \n         // set first vertex\n-        simplex = new ScalarPointValuePair[n + 1];\n-        simplex[0] = new ScalarPointValuePair(startPoint, Double.NaN);\n+        simplex = new RealPointValuePair[n + 1];\n+        simplex[0] = new RealPointValuePair(startPoint, Double.NaN);\n \n         // set remaining vertices\n         for (int i = 0; i < n; ++i) {\n             for (int k = 0; k < n; ++k) {\n                 vertexI[k] = startPoint[k] + confI[k];\n             }\n-            simplex[i + 1] = new ScalarPointValuePair(vertexI, Double.NaN);\n+            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);\n         }\n \n     }\n \n     /** Evaluate all the non-evaluated points of the simplex.\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n-     * @exception ObjectiveException if no value can be computed for the parameters\n-     */\n-    protected void evaluateSimplex(final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException {\n+     * @exception FunctionEvaluationException if no value can be computed for the parameters\n+     */\n+    protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n \n         // evaluate the objective function at all non-evaluated simplex points\n         for (int i = 0; i < simplex.length; ++i) {\n-            final ScalarPointValuePair vertex = simplex[i];\n+            final RealPointValuePair vertex = simplex[i];\n             final double[] point = vertex.getPointRef();\n             if (Double.isNaN(vertex.getValue())) {\n-                simplex[i] = new ScalarPointValuePair(point, evaluate(point), false);\n+                simplex[i] = new RealPointValuePair(point, evaluate(point), false);\n             }\n         }\n \n      * @param pointValuePair point to insert\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n      */\n-    protected void replaceWorstPoint(ScalarPointValuePair pointValuePair,\n-                                     final Comparator<ScalarPointValuePair> comparator) {\n+    protected void replaceWorstPoint(RealPointValuePair pointValuePair,\n+                                     final Comparator<RealPointValuePair> comparator) {\n         int n = simplex.length - 1;\n         for (int i = 0; i < n; ++i) {\n             if (comparator.compare(simplex[i], pointValuePair) > 0) {\n-                ScalarPointValuePair tmp = simplex[i];\n+                RealPointValuePair tmp = simplex[i];\n                 simplex[i]         = pointValuePair;\n                 pointValuePair     = tmp;\n             }\n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n \n /** \n  * This class implements the multi-directional direct search method.\n     }\n \n     /** {@inheritDoc} */\n-    protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         while (true) {\n \n             incrementIterationsCounter();\n \n             // save the original vertex\n-            final ScalarPointValuePair[] original = simplex;\n-            final ScalarPointValuePair best = original[0];\n+            final RealPointValuePair[] original = simplex;\n+            final RealPointValuePair best = original[0];\n \n             // perform a reflection step\n-            final ScalarPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n+            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n             if (comparator.compare(reflected, best) < 0) {\n \n                 // compute the expanded simplex\n-                final ScalarPointValuePair[] reflectedSimplex = simplex;\n-                final ScalarPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n+                final RealPointValuePair[] reflectedSimplex = simplex;\n+                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                 if (comparator.compare(reflected, expanded) <= 0) {\n                     // accept the reflected simplex\n                     simplex = reflectedSimplex;\n             }\n \n             // compute the contracted simplex\n-            final ScalarPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n                 return;\n      * @param coeff linear coefficient\n      * @param comparator comparator to use to sort simplex vertices from best to poorest\n      * @return best point in the transformed simplex\n-     * @exception ObjectiveException if the function cannot be evaluated at\n+     * @exception FunctionEvaluationException if the function cannot be evaluated at\n      * some point\n      */\n-    private ScalarPointValuePair evaluateNewSimplex(final ScalarPointValuePair[] original,\n+    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n                                               final double coeff,\n-                                              final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException {\n+                                              final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException {\n \n         final double[] xSmallest = original[0].getPointRef();\n         final int n = xSmallest.length;\n \n         // create the linearly transformed simplex\n-        simplex = new ScalarPointValuePair[n + 1];\n+        simplex = new RealPointValuePair[n + 1];\n         simplex[0] = original[0];\n         for (int i = 1; i <= n; ++i) {\n             final double[] xOriginal    = original[i].getPointRef();\n             for (int j = 0; j < n; ++j) {\n                 xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n             }\n-            simplex[i] = new ScalarPointValuePair(xTransformed, Double.NaN, false);\n+            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n         }\n \n         // evaluate it\n--- a/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n \n /** \n  * This class implements the Nelder-Mead direct search method.\n     }\n \n     /** {@inheritDoc} */\n-    protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException, OptimizationException {\n+    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException {\n \n         incrementIterationsCounter();\n \n         final int n = simplex.length - 1;\n \n         // interesting values\n-        final ScalarPointValuePair best       = simplex[0];\n-        final ScalarPointValuePair secondBest = simplex[n-1];\n-        final ScalarPointValuePair worst      = simplex[n];\n+        final RealPointValuePair best       = simplex[0];\n+        final RealPointValuePair secondBest = simplex[n-1];\n+        final RealPointValuePair worst      = simplex[n];\n         final double[] xWorst = worst.getPointRef();\n \n         // compute the centroid of the best vertices\n         for (int j = 0; j < n; ++j) {\n             xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n         }\n-        final ScalarPointValuePair reflected = new ScalarPointValuePair(xR, evaluate(xR), false);\n+        final RealPointValuePair reflected = new RealPointValuePair(xR, evaluate(xR), false);\n \n         if ((comparator.compare(best, reflected) <= 0) &&\n             (comparator.compare(reflected, secondBest) < 0)) {\n             for (int j = 0; j < n; ++j) {\n                 xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n             }\n-            final ScalarPointValuePair expanded = new ScalarPointValuePair(xE, evaluate(xE), false);\n+            final RealPointValuePair expanded = new RealPointValuePair(xE, evaluate(xE), false);\n \n             if (comparator.compare(expanded, reflected) < 0) {\n                 // accept the expansion point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                 }\n-                final ScalarPointValuePair outContracted = new ScalarPointValuePair(xC, evaluate(xC), false);\n+                final RealPointValuePair outContracted = new RealPointValuePair(xC, evaluate(xC), false);\n \n                 if (comparator.compare(outContracted, reflected) <= 0) {\n                     // accept the contraction point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                 }\n-                final ScalarPointValuePair inContracted = new ScalarPointValuePair(xC, evaluate(xC), false);\n+                final RealPointValuePair inContracted = new RealPointValuePair(xC, evaluate(xC), false);\n \n                 if (comparator.compare(inContracted, worst) < 0) {\n                     // accept the contraction point\n                 for (int j = 0; j < n; ++j) {\n                     x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n                 }\n-                simplex[i] = new ScalarPointValuePair(x, Double.NaN, false);\n+                simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n             }\n             evaluateSimplex(comparator);\n \n--- a/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n-import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class MultiDirectionalTest\n     super(name);\n   }\n \n-  public void testObjectiveExceptions() throws ConvergenceException {\n-      ScalarObjectiveFunction wrong =\n-          new ScalarObjectiveFunction() {\n+  public void testFunctionEvaluationExceptions() throws ConvergenceException {\n+      MultivariateRealFunction wrong =\n+          new MultivariateRealFunction() {\n             private static final long serialVersionUID = 4751314470965489371L;\n-            public double objective(double[] x) throws ObjectiveException {\n+            public double value(double[] x) throws FunctionEvaluationException {\n                 if (x[0] < 0) {\n-                    throw new ObjectiveException(\"{0}\", \"oops\");\n+                    throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n                 } else if (x[0] > 1) {\n-                    throw new ObjectiveException(new RuntimeException(\"oops\"));\n+                    throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n                 } else {\n                     return x[0] * (1 - x[0]);\n                 }\n           MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n           fail(\"an exception should have been thrown\");\n-      } catch (ObjectiveException ce) {\n+      } catch (FunctionEvaluationException ce) {\n           // expected behavior\n           assertNull(ce.getCause());\n       } catch (Exception e) {\n           MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           fail(\"an exception should have been thrown\");\n-      } catch (ObjectiveException ce) {\n+      } catch (FunctionEvaluationException ce) {\n           // expected behavior\n           assertNotNull(ce.getCause());\n       } catch (Exception e) {\n   }\n \n   public void testMinimizeMaximize()\n-      throws ObjectiveException, ConvergenceException, NotPositiveDefiniteMatrixException {\n+      throws FunctionEvaluationException, ConvergenceException, NotPositiveDefiniteMatrixException {\n \n       // the following function has 4 local extrema:\n       final double xM        = -3.841947088256863675365;\n       final double valueXmYp = -valueXmYm;                // local  minimum\n       final double valueXpYm = -0.7290400707055187115322; // global minimum\n       final double valueXpYp = -valueXpYm;                // global maximum\n-      ScalarObjectiveFunction fourExtrema = new ScalarObjectiveFunction() {\n+      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n           private static final long serialVersionUID = -7039124064449091152L;\n-          public double objective(double[] variables) {\n+          public double value(double[] variables) throws FunctionEvaluationException {\n               final double x = variables[0];\n               final double y = variables[1];\n               return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n       optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n       optimizer.setMaxIterations(200);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n-      ScalarPointValuePair optimum;\n+      RealPointValuePair optimum;\n \n       // minimization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n   }\n \n   public void testRosenbrock()\n-    throws ObjectiveException, ConvergenceException {\n-\n-    ScalarObjectiveFunction rosenbrock =\n-      new ScalarObjectiveFunction() {\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction rosenbrock =\n+      new MultivariateRealFunction() {\n         private static final long serialVersionUID = -9044950469615237490L;\n-        public double objective(double[] x) {\n+        public double value(double[] x) throws FunctionEvaluationException {\n           ++count;\n           double a = x[1] - x[0] * x[0];\n           double b = 1.0 - x[0];\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n-    ScalarPointValuePair optimum =\n+    RealPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n     assertEquals(count, optimizer.getEvaluations());\n   }\n \n   public void testPowell()\n-    throws ObjectiveException, ConvergenceException {\n-\n-    ScalarObjectiveFunction powell =\n-      new ScalarObjectiveFunction() {\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction powell =\n+      new MultivariateRealFunction() {\n         private static final long serialVersionUID = -832162886102041840L;\n-        public double objective(double[] x) {\n+        public double value(double[] x) throws FunctionEvaluationException {\n           ++count;\n           double a = x[0] + 10 * x[1];\n           double b = x[2] - x[3];\n     MultiDirectional optimizer = new MultiDirectional();\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n     optimizer.setMaxIterations(1000);\n-    ScalarPointValuePair optimum =\n+    RealPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n     assertTrue(optimizer.getEvaluations() > 800);\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n-import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class NelderMeadTest\n     super(name);\n   }\n \n-  public void testObjectiveExceptions() throws ConvergenceException {\n-      ScalarObjectiveFunction wrong =\n-          new ScalarObjectiveFunction() {\n+  public void testFunctionEvaluationExceptions() throws ConvergenceException {\n+      MultivariateRealFunction wrong =\n+          new MultivariateRealFunction() {\n             private static final long serialVersionUID = 4751314470965489371L;\n-            public double objective(double[] x) throws ObjectiveException {\n+            public double value(double[] x) throws FunctionEvaluationException {\n                 if (x[0] < 0) {\n-                    throw new ObjectiveException(\"{0}\", \"oops\");\n+                    throw new FunctionEvaluationException(x, \"{0}\", \"oops\");\n                 } else if (x[0] > 1) {\n-                    throw new ObjectiveException(new RuntimeException(\"oops\"));\n+                    throw new FunctionEvaluationException(new RuntimeException(\"oops\"), x);\n                 } else {\n                     return x[0] * (1 - x[0]);\n                 }\n           NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n           fail(\"an exception should have been thrown\");\n-      } catch (ObjectiveException ce) {\n+      } catch (FunctionEvaluationException ce) {\n           // expected behavior\n           assertNull(ce.getCause());\n       } catch (Exception e) {\n           NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           fail(\"an exception should have been thrown\");\n-      } catch (ObjectiveException ce) {\n+      } catch (FunctionEvaluationException ce) {\n           // expected behavior\n           assertNotNull(ce.getCause());\n       } catch (Exception e) {\n   }\n \n   public void testMinimizeMaximize()\n-      throws ObjectiveException, ConvergenceException, NotPositiveDefiniteMatrixException {\n+      throws FunctionEvaluationException, ConvergenceException, NotPositiveDefiniteMatrixException {\n \n       // the following function has 4 local extrema:\n       final double xM        = -3.841947088256863675365;\n       final double valueXmYp = -valueXmYm;                // local  minimum\n       final double valueXpYm = -0.7290400707055187115322; // global minimum\n       final double valueXpYp = -valueXpYm;                // global maximum\n-      ScalarObjectiveFunction fourExtrema = new ScalarObjectiveFunction() {\n+      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n           private static final long serialVersionUID = -7039124064449091152L;\n-          public double objective(double[] variables) {\n+          public double value(double[] variables) throws FunctionEvaluationException {\n               final double x = variables[0];\n               final double y = variables[1];\n               return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n       optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n       optimizer.setMaxIterations(100);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n-      ScalarPointValuePair optimum;\n+      RealPointValuePair optimum;\n \n       // minimization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n   }\n \n   public void testRosenbrock()\n-    throws ObjectiveException, ConvergenceException {\n-\n-    ScalarObjectiveFunction rosenbrock =\n-      new ScalarObjectiveFunction() {\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction rosenbrock =\n+      new MultivariateRealFunction() {\n         private static final long serialVersionUID = -9044950469615237490L;\n-        public double objective(double[] x) {\n+        public double value(double[] x) throws FunctionEvaluationException {\n           ++count;\n           double a = x[1] - x[0] * x[0];\n           double b = 1.0 - x[0];\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n-    ScalarPointValuePair optimum =\n+    RealPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n     assertEquals(count, optimizer.getEvaluations());\n   }\n \n   public void testPowell()\n-    throws ObjectiveException, ConvergenceException {\n-\n-    ScalarObjectiveFunction powell =\n-      new ScalarObjectiveFunction() {\n+    throws FunctionEvaluationException, ConvergenceException {\n+\n+    MultivariateRealFunction powell =\n+      new MultivariateRealFunction() {\n         private static final long serialVersionUID = -832162886102041840L;\n-        public double objective(double[] x) {\n+        public double value(double[] x) throws FunctionEvaluationException {\n           ++count;\n           double a = x[0] + 10 * x[1];\n           double b = x[2] - x[3];\n     NelderMead optimizer = new NelderMead();\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n     optimizer.setMaxIterations(200);\n-    ScalarPointValuePair optimum =\n+    RealPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n     assertTrue(optimizer.getEvaluations() > 110);", "timestamp": 1237932807, "metainfo": ""}