{"sha": "1a7b59636210bfe45ec61df8f0e1ae5376122066", "log": "MATH-795: moved minimal implementation of RealVector, ArrayRealVectorTest.RealVectorTestImpl to RealVectorAbstractTest.RealVectorTestImpl. This minimal implementation is now used by RealVectorTest and ArrayRealVectorTest.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/ArrayRealVectorTest.java\n  */\n public class ArrayRealVectorTest extends RealVectorAbstractTest {\n \n-    /**\n-     * Minimal implementation of the {@link RealVector} abstract class, for\n-     * mixed types unit tests.\n-     */\n-    public static class RealVectorTestImpl extends RealVector\n-        implements Serializable {\n-\n-        /** Serializable version identifier. */\n-        private static final long serialVersionUID = 20120706L;\n-\n-        /** Entries of the vector. */\n-        protected double data[];\n-\n-        public RealVectorTestImpl(double[] d) {\n-            data = d.clone();\n-        }\n-\n-        private UnsupportedOperationException unsupported() {\n-            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n-        }\n-\n-        @Override\n-        public RealVector mapToSelf(UnivariateFunction function) {\n-            for (int i = 0; i < data.length; i++) {\n-                data[i] = function.value(data[i]);\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public RealVector copy() {\n-            return new RealVectorTestImpl(data);\n-        }\n-\n-        @Override\n-        public RealVector ebeMultiply(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector ebeDivide(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getEntry(int index) {\n-            return data[index];\n-        }\n-\n-        @Override\n-        public int getDimension() {\n-            return data.length;\n-        }\n-\n-        @Override\n-        public RealVector append(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector append(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector getSubVector(int index, int n) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void setEntry(int index, double value) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void setSubVector(int index, RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void set(double value) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double[] toArray() {\n-            return data.clone();\n-        }\n-\n-        @Override\n-        public boolean isNaN() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public boolean isInfinite() {\n-            throw unsupported();\n-        }\n-    }\n \n     @Override\n     public RealVector create(final double[] data) {\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n  */\n package org.apache.commons.math3.linear;\n \n+import java.io.Serializable;\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n             Assert.assertEquals(\"entry \" + i, i + data[i], v.getEntry(i), 0.0);\n         }\n     }\n+\n+    /**\n+     * Minimal implementation of the {@link RealVector} abstract class, for\n+     * mixed types unit tests.\n+     */\n+    public static class RealVectorTestImpl extends RealVector\n+        implements Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 20120706L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public RealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        @Override\n+        public RealVector mapToSelf(UnivariateFunction function) {\n+            for (int i = 0; i < data.length; i++) {\n+                data[i] = function.value(data[i]);\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public RealVector copy() {\n+            return new RealVectorTestImpl(data);\n+        }\n+\n+        @Override\n+        public RealVector ebeMultiply(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public RealVector ebeDivide(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double getEntry(int index) {\n+            checkIndex(index);\n+            return data[index];\n+        }\n+\n+        @Override\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        @Override\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public RealVector getSubVector(int index, int n) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public void setEntry(int index, double value) {\n+            checkIndex(index);\n+            data[index] = value;\n+        }\n+\n+        @Override\n+        public void setSubVector(int index, RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double[] toArray() {\n+            return data.clone();\n+        }\n+\n+        @Override\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n \n package org.apache.commons.math3.linear;\n \n+import java.util.Iterator;\n+import java.util.Random;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.linear.RealVector.Entry;\n+import org.junit.Assert;\n import org.junit.Ignore;\n import org.junit.Test;\n-import org.junit.Assert;\n-import org.apache.commons.math3.analysis.UnivariateFunction;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.linear.RealVector.Entry;\n-import org.apache.commons.math3.util.MathArrays;\n-\n-import java.util.Iterator;\n-import java.util.Random;\n \n /**\n  * Tests for {@link RealVector}.\n     private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n     private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };\n \n-    private static class TestVectorImpl extends RealVector {\n-        private double[] values;\n-\n-        TestVectorImpl(double[] values) {\n-            this.values = MathArrays.copyOf(values);\n-        }\n-\n-        @Override\n-        public double[] toArray() { return values; }\n-\n-        @Override\n-        public RealVector copy() {\n-            return new TestVectorImpl(values.clone());\n-        }\n-\n-        UnsupportedOperationException unsupported() {\n-            return new UnsupportedOperationException(\"Test implementation only supports methods necessary for testing\");\n-        }\n-\n-        @Override\n-        public RealVector mapAddToSelf(double d) {\n-            for(int i=0; i<values.length; i++) {\n-                values[i] += d;\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public RealVector mapSubtractToSelf(double d) {\n-            for(int i=0; i<values.length; i++) {\n-                values[i] -= d;\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public RealVector mapMultiplyToSelf(double d) {\n-            for(int i=0; i<values.length; i++) {\n-                values[i] *= d;\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public RealVector mapDivideToSelf(double d) {\n-            for(int i=0; i<values.length; i++) {\n-                values[i] /= d;\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public RealVector ebeMultiply(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector ebeDivide(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getL1Norm() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getLInfNorm() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getEntry(int index) {\n-            try {\n-                return values[index];\n-            } catch (IndexOutOfBoundsException e) {\n-                throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n-                    getDimension() - 1);\n-            }\n-        }\n-\n-        @Override\n-        public void setEntry(int index, double value) {\n-            try {\n-                values[index] = value;\n-            } catch (IndexOutOfBoundsException e) {\n-                throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n-                    getDimension() - 1);\n-            }\n-        }\n-\n-        @Override\n-        public int getDimension() {\n-            return values.length;\n-        }\n-\n-        @Override\n-        public RealVector append(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector append(double d) {\n-            throw unsupported();\n-        }\n-\n-        public RealVector append(double[] a) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector getSubVector(int index, int n) {\n-            throw unsupported();\n-        }\n-\n-        public void setSubVector(int index, double[] v) {\n-            throw unsupported();\n-        }\n-        @Override\n-        public void setSubVector(int index, RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public boolean isNaN() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public boolean isInfinite() {\n-            throw unsupported();\n-        }\n-    }\n-\n     @Override\n     public RealVector create(final double[] data) {\n-        return new TestVectorImpl(data);\n+        return new RealVectorTestImpl(data);\n     }\n \n     @Override\n     public RealVector createAlien(double[] data) {\n-        return new TestVectorImpl(data);\n+        return new RealVectorTestImpl(data);\n     }\n \n     @Test\n \n     @Test\n     public void testSparseIterator() throws Exception {\n-        RealVector v = new TestVectorImpl(vec2.clone());\n+        RealVector v = new RealVectorTestImpl(vec2.clone());\n         Entry e;\n         int i = 0;\n         double[] nonDefaultV2 = { -3d, 2d, 1d };\n             Assert.assertEquals(nonDefaultV2[i], e.getValue(), 0);\n         }\n         double [] onlyOne = {0d, 1.0, 0d};\n-        v = new TestVectorImpl(onlyOne);\n+        v = new RealVectorTestImpl(onlyOne);\n         for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {\n             Assert.assertEquals(onlyOne[1], e.getValue(), 0);\n         }\n         final double a = 1d;\n         final double b = 2d;\n         double[] aux = new double[] { 3d, 4d, 5d };\n-        final TestVectorImpl x = new TestVectorImpl(aux);\n+        final RealVector x = new RealVectorTestImpl(aux);\n         aux = new double[] { 6d, 7d };\n-        final TestVectorImpl y = new TestVectorImpl(aux);\n+        final RealVector y = new RealVectorTestImpl(aux);\n         x.combineToSelf(a, b, y);\n     }\n \n         final int dim = 10;\n         final double a = (2 * random.nextDouble() - 1);\n         final double b = (2 * random.nextDouble() - 1);\n-        final RealVector x = new TestVectorImpl(new double[dim]);\n-        final RealVector y = new TestVectorImpl(new double[dim]);\n+        final RealVector x = new RealVectorTestImpl(new double[dim]);\n+        final RealVector y = new RealVectorTestImpl(new double[dim]);\n         final double[] expected = new double[dim];\n         for (int i = 0; i < dim; i++) {\n             final double xi = 2 * random.nextDouble() - 1;\n     @Test\n     public void testAddToEntry() {\n         final double[] v = new double[] { 1, 2, 3 };\n-        final RealVector x = new TestVectorImpl(v.clone());\n+        final RealVector x = new RealVectorTestImpl(v.clone());\n         final double inc = 7;\n         for (int i = 0; i < x.getDimension(); i++) {\n             x.addToEntry(i, inc);", "timestamp": 1341599090, "metainfo": ""}