{"sha": "e5dd34bab7ed5f654f0a04632481d2341f896cce", "log": "Code cleanup.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n      */\n     @Override\n     public double doSolve() {\n-        double min = getMin();\n-        double max = getMax();\n-        double initial = getStartValue();\n+        final double min = getMin();\n+        final double max = getMax();\n+        final double initial = getStartValue();\n         final double functionValueAccuracy = getFunctionValueAccuracy();\n \n         verifySequence(min, initial, max);\n \n         // Return the initial guess if it is good enough.\n-        double yInitial = computeObjectiveValue(initial);\n+        final double yInitial = computeObjectiveValue(initial);\n         if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n             return initial;\n         }\n \n         // Return the first endpoint if it is good enough.\n-        double yMin = computeObjectiveValue(min);\n+        final double yMin = computeObjectiveValue(min);\n         if (FastMath.abs(yMin) <= functionValueAccuracy) {\n             return min;\n         }\n         }\n \n         // Return the second endpoint if it is good enough.\n-        double yMax = computeObjectiveValue(max);\n+        final double yMax = computeObjectiveValue(max);\n         if (FastMath.abs(yMax) <= functionValueAccuracy) {\n             return max;\n         }\n                            double fLo, double fHi) {\n         final Complex c[] = ComplexUtils.convertToComplex(getCoefficients());\n \n-        Complex initial = new Complex(0.5 * (lo + hi), 0);\n-        Complex z = complexSolver.solve(c, initial);\n+        final Complex initial = new Complex(0.5 * (lo + hi), 0);\n+        final Complex z = complexSolver.solve(c, initial);\n         if (complexSolver.isRoot(lo, hi, z)) {\n             return z.getReal();\n         } else {\n             if (coefficients == null) {\n                 throw new NullArgumentException();\n             }\n-            int n = coefficients.length - 1;\n+            final int n = coefficients.length - 1;\n             if (n == 0) {\n                 throw new NoDataException(LocalizedFormats.POLYNOMIAL);\n             }\n                 throw new NullArgumentException();\n             }\n \n-            int n = coefficients.length - 1;\n+            final int n = coefficients.length - 1;\n             if (n == 0) {\n                 throw new NoDataException(LocalizedFormats.POLYNOMIAL);\n             }\n             final double relativeAccuracy = getRelativeAccuracy();\n             final double functionValueAccuracy = getFunctionValueAccuracy();\n \n-            final Complex N  = new Complex(n, 0);\n-            final Complex N1 = new Complex(n - 1, 0);\n+            final Complex nC  = new Complex(n, 0);\n+            final Complex n1C = new Complex(n - 1, 0);\n \n             Complex z = initial;\n             Complex oldz = new Complex(Double.POSITIVE_INFINITY,\n                 }\n                 d2v = d2v.multiply(new Complex(2.0, 0.0));\n \n-                // check for convergence\n+                // Check for convergence.\n                 final double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n                                                       absoluteAccuracy);\n                 if ((z.subtract(oldz)).abs() <= tolerance) {\n                     return z;\n                 }\n \n-                // now pv != 0, calculate the new approximation\n+                // Now pv != 0, calculate the new approximation.\n                 final Complex G = dv.divide(pv);\n                 final Complex G2 = G.multiply(G);\n                 final Complex H = G2.subtract(d2v.divide(pv));\n-                final Complex delta = N1.multiply((N.multiply(H)).subtract(G2));\n-                // choose a denominator larger in magnitude\n+                final Complex delta = n1C.multiply((nC.multiply(H)).subtract(G2));\n+                // Choose a denominator larger in magnitude.\n                 final Complex deltaSqrt = delta.sqrt();\n                 final Complex dplus = G.add(deltaSqrt);\n                 final Complex dminus = G.subtract(deltaSqrt);\n                                        Double.POSITIVE_INFINITY);\n                 } else {\n                     oldz = z;\n-                    z = z.subtract(N.divide(denominator));\n+                    z = z.subtract(nC.divide(denominator));\n                 }\n                 incrementEvaluationCount();\n             }", "timestamp": 1342445892, "metainfo": ""}