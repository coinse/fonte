{"sha": "b4d3b7129bafdb5d3f9b81e001b314129d7177c2", "log": "MATH-872 Sigma values expressed as a kind of \"OptimizationData\". Deprecated constructors that were passed an \"inputSigma\" argument.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n+import org.apache.commons.math3.optimization.OptimizationData;\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.MultivariateOptimizer;\n import org.apache.commons.math3.optimization.PointValuePair;\n      */\n     private int checkFeasableCount;\n     /**\n-     * Values in \"inputSigma\" define the initial coordinate-wise\n-     * standard deviations for sampling new search points around the\n-     * initial guess.\n-     * It is appropriate to set \"inputSigma\" to the estimated distance\n-     * from the initial to the desired optimum.\n-     * Small values for \"inputSigma\" induce the search to be more local\n-     * (and very small values are more likely to find a local optimum \n-     * close to the initial guess).\n-     * Too small values might however lead to early termination.\n+     * @see Sigma\n      */\n     private double[] inputSigma;\n     /** Number of objective variables/problem dimension */\n      * @param lambda Population size.\n      */\n     public CMAESOptimizer(int lambda) {\n-        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n+        this(lambda, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n              DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n-             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n+             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR,\n+             false, null);\n     }\n \n     /**\n      * @param lambda Population size.\n      * @param inputSigma Initial standard deviations to sample new points\n      * around the initial guess.\n-     */\n+     * @deprecated As of version 3.1: Parameter {@code inputSigma} must be\n+     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])\n+     * optimize}.\n+     */\n+    @Deprecated\n     public CMAESOptimizer(int lambda, double[] inputSigma) {\n         this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n              DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n      * @param random Random generator.\n      * @param generateStatistics Whether statistic data is collected.\n      * @param checker Convergence checker.\n-     */\n+     * @deprecated As of version 3.1: Parameter {@code inputSigma} must be\n+     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])\n+     * optimize}.\n+     */\n+    @Deprecated\n     public CMAESOptimizer(int lambda, double[] inputSigma,\n                           int maxIterations, double stopFitness,\n                           boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n     }\n \n     /**\n+     * @param lambda Population size.\n+     * @param maxIterations Maximal number of iterations.\n+     * @param stopFitness Whether to stop if objective function value is smaller than\n+     * {@code stopFitness}.\n+     * @param isActiveCMA Chooses the covariance matrix update method.\n+     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n+     * remains diagonal.\n+     * @param checkFeasableCount Determines how often new random objective variables are\n+     * generated in case they are out of bounds.\n+     * @param random Random generator.\n+     * @param generateStatistics Whether statistic data is collected.\n+     * @param checker Convergence checker.\n+     */\n+    public CMAESOptimizer(int lambda,\n+                          int maxIterations,\n+                          double stopFitness,\n+                          boolean isActiveCMA,\n+                          int diagonalOnly,\n+                          int checkFeasableCount,\n+                          RandomGenerator random,\n+                          boolean generateStatistics,\n+                          ConvergenceChecker<PointValuePair> checker) {\n+        super(checker);\n+        this.lambda = lambda;\n+        this.maxIterations = maxIterations;\n+        this.stopFitness = stopFitness;\n+        this.isActiveCMA = isActiveCMA;\n+        this.diagonalOnly = diagonalOnly;\n+        this.checkFeasableCount = checkFeasableCount;\n+        this.random = random;\n+        this.generateStatistics = generateStatistics;\n+    }\n+\n+    /**\n      * @return History of sigma values.\n      */\n     public List<Double> getStatisticsSigmaHistory() {\n      */\n     public List<RealMatrix> getStatisticsDHistory() {\n         return statisticsDHistory;\n+    }\n+\n+    /**\n+     * Input sigma values.\n+     * They define the initial coordinate-wise standard deviations for\n+     * sampling new search points around the initial guess.\n+     * It is suggested to set them to the estimated distance from the\n+     * initial to the desired optimum.\n+     * Small values induce the search to be more local (and very small\n+     * values are more likely to find a local optimum close to the initial\n+     * guess).\n+     * Too small values might however lead to early termination.\n+     */\n+    public class Sigma implements OptimizationData {\n+        /** Sigma values. */\n+        private final double[] sigma;\n+\n+        /**\n+         * @param s Sigma values.\n+         */\n+        public Sigma(double[] s) {\n+            sigma = s.clone();\n+        }\n+\n+        /**\n+         * @return the sigma values.\n+         */\n+        public double[] getSigma() {\n+            return sigma.clone();\n+        }\n+    }\n+\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param maxEval Allowed number of evaluations of the objective function.\n+     * @param f Objective function.\n+     * @param goalType Optimization type.\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>\n+     *  <li>{@link Sigma}</li>\n+     * </ul>\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     */\n+    @Override\n+    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f,\n+                                              GoalType goalType,\n+                                              OptimizationData... optData) {\n+        // Scan \"optData\" for the input specific to this optimizer.\n+        parseOptimizationData(optData);\n+\n+        // The parent's method will retrieve the common parameters from\n+        // \"optData\" and call \"doOptimize\".\n+        return super.optimizeInternal(maxEval, f, goalType, optData);\n     }\n \n     /** {@inheritDoc} */\n                 }\n             }\n         return optimum;\n+    }\n+\n+    /**\n+     * Scans the list of (required and optional) optimization data that\n+     * characterize the problem.\n+     *\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link Sigma}</li>\n+     * </ul>\n+     */\n+    private void parseOptimizationData(OptimizationData... optData) {\n+        // The existing values (as set by the previous call) are reused if\n+        // not provided in the argument list.\n+        for (OptimizationData data : optData) {\n+            if (data instanceof Sigma) {\n+                inputSigma = ((Sigma) data).getSigma();\n+                continue;\n+            }\n+        }\n     }\n \n     /**", "timestamp": 1350306735, "metainfo": ""}