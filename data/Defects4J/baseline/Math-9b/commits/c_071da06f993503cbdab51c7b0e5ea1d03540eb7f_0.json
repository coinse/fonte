{"sha": "071da06f993503cbdab51c7b0e5ea1d03540eb7f", "log": "Bitten again by \"Arrays.copyOf\". Added more general methods in \"MathUtils\". Replaced call to \"Arrays\" by the equivalent from \"MathUtils\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.random.MersenneTwister;\n import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * CMA-ES algorithm. This code is translated and adapted from the Matlab version\n                 int[] arindex = sortedIndices(fitness);\n                 // Calculate new xmean, this is selection and recombination\n                 RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n-                RealMatrix bestArx = selectColumns(arx,Arrays.copyOf(arindex, mu));\n+                RealMatrix bestArx = selectColumns(arx, MathUtils.copyOf(arindex, mu));\n                 xmean = bestArx.multiply(weights);\n-                RealMatrix bestArz = selectColumns(arz,Arrays.copyOf(arindex, mu));\n+                RealMatrix bestArz = selectColumns(arz, MathUtils.copyOf(arindex, mu));\n                 RealMatrix zmean = bestArz.multiply(weights);\n                 boolean hsig = updateEvolutionPaths(zmean, xold);\n                 if (diagonalOnly <= 0)\n                                           // loss,\n                 // prepare vectors, compute negative updating matrix Cneg\n                 int[] arReverseIndex = reverse(arindex);\n-                RealMatrix arzneg = selectColumns(arz,\n-                        Arrays.copyOf(arReverseIndex, mu));\n+                RealMatrix arzneg\n+                    = selectColumns(arz, MathUtils.copyOf(arReverseIndex, mu));\n                 RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                 int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                 RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * @return the copied array.\n      */\n      public static int[] copyOf(int[] source) {\n-         final int len = source.length;\n+         return copyOf(source, source.length);\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @return the copied array.\n+     */\n+     public static double[] copyOf(double[] source) {\n+         return copyOf(source, source.length);\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @param len Number of entries to copy. If smaller then the source\n+     * length, the copy will be truncated, if larger it will padded with\n+     * zeroes.\n+     * @return the copied array.\n+     */\n+    public static int[] copyOf(int[] source, int len) {\n          final int[] output = new int[len];\n-         System.arraycopy(source, 0, output, 0, len);\n+         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n          return output;\n      }\n \n      * Creates a copy of the {@code source} array.\n      *\n      * @param source Array to be copied.\n+     * @param len Number of entries to copy. If smaller then the source\n+     * length, the copy will be truncated, if larger it will padded with\n+     * zeroes.\n      * @return the copied array.\n      */\n-     public static double[] copyOf(double[] source) {\n-         final int len = source.length;\n+    public static double[] copyOf(double[] source, int len) {\n          final double[] output = new double[len];\n-         System.arraycopy(source, 0, output, 0, len);\n+         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n          return output;\n      }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         }\n     }\n \n+    public void testCopyOfInt2() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int offset = 3;\n+        final int[] dest = MathUtils.copyOf(source, source.length - offset);\n+\n+        assertEquals(dest.length, source.length - offset);\n+        for (int i = 0; i < source.length - offset; i++) {\n+            assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    public void testCopyOfInt3() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int offset = 3;\n+        final int[] dest = MathUtils.copyOf(source, source.length + offset);\n+\n+        assertEquals(dest.length, source.length + offset);\n+        for (int i = 0; i < source.length; i++) {\n+            assertEquals(source[i], dest[i]);\n+        }\n+        for (int i = source.length; i < source.length + offset; i++) {\n+            assertEquals(0, dest[i], 0);\n+        }\n+    }\n+\n     public void testCopyOfDouble() {\n         final double[] source = { Double.NEGATIVE_INFINITY,\n                                   -Double.MAX_VALUE,\n             assertEquals(source[i], dest[i], 0);\n         }\n     }\n+\n+    public void testCopyOfDouble2() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final int offset = 3;\n+        final double[] dest = MathUtils.copyOf(source, source.length - offset);\n+\n+        assertEquals(dest.length, source.length - offset);\n+        for (int i = 0; i < source.length - offset; i++) {\n+            assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n+\n+    public void testCopyOfDouble3() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final int offset = 3;\n+        final double[] dest = MathUtils.copyOf(source, source.length + offset);\n+\n+        assertEquals(dest.length, source.length + offset);\n+        for (int i = 0; i < source.length; i++) {\n+            assertEquals(source[i], dest[i], 0);\n+        }\n+        for (int i = source.length; i < source.length + offset; i++) {\n+            assertEquals(0, dest[i], 0);\n+        }\n+    }\n }", "timestamp": 1296842909, "metainfo": ""}