{"sha": "4f2a4383b3d59d3859d2ea7c91713e797fb1df9d", "log": "Variable visibility: \"protected\" -> \"private\". Added \"protected\" getter methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/BaseAbstractUnivariateIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/BaseAbstractUnivariateIntegrator.java\n     public static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;\n \n     /** Maximum absolute error. */\n-    protected double absoluteAccuracy;\n+    private final double absoluteAccuracy;\n \n     /** Maximum relative error. */\n-    protected double relativeAccuracy;\n+    private final double relativeAccuracy;\n \n     /** minimum number of iterations */\n-    protected int minimalIterationCount;\n+    private final int minimalIterationCount;\n \n     /** The iteration count. */\n-    protected Incrementor iterations;\n+    protected final Incrementor iterations;\n \n     /** The functions evaluation count. */\n-    protected Incrementor evaluations;\n+    private final Incrementor evaluations;\n \n     /** Function to integrate. */\n-    protected UnivariateFunction function;\n+    private UnivariateFunction function;\n \n     /** Lower bound for the interval. */\n-    protected double min;\n+    private double min;\n \n     /** Upper bound for the interval. */\n-    protected double max;\n+    private double max;\n \n     /**\n      * Construct an integrator with given accuracies and iteration counts.\n     }\n \n     /**\n+     * @return the lower bound.\n+     */\n+    protected double getMin() {\n+        return min;\n+    }\n+    /**\n+     * @return the upper bound.\n+     */\n+    protected double getMax() {\n+        return max;\n+    }\n+\n+    /**\n      * Compute the objective function value.\n      *\n      * @param point Point at which the objective function must be evaluated.\n         UnivariateSolverUtils.verifyInterval(lower, upper);\n \n         // Reset.\n-        this.min = lower;\n-        this.max = upper;\n+        min = lower;\n+        max = upper;\n         function = f;\n         evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.java\n             // estimate error\n             final double delta = FastMath.abs(t - oldt);\n             final double limit =\n-                FastMath.max(absoluteAccuracy,\n-                         relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n+                FastMath.max(getAbsoluteAccuracy(),\n+                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n \n             // check convergence\n-            if ((iterations.getCount() + 1 >= minimalIterationCount) && (delta <= limit)) {\n+            if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n                 return t;\n             }\n \n         throws TooManyEvaluationsException {\n \n         // set up the step for the current stage\n-        final double step     = (max - min) / n;\n+        final double step     = (getMax() - getMin()) / n;\n         final double halfStep = step / 2.0;\n \n         // integrate over all elementary steps\n-        double midPoint = min + halfStep;\n+        double midPoint = getMin() + halfStep;\n         double sum = 0.0;\n         for (int i = 0; i < n; ++i) {\n             for (int j = 0; j < abscissas.length; ++j) {\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/RombergIntegrator.java\n                 currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r;\n             }\n             final double s = currentRow[i];\n-            if (i >= minimalIterationCount) {\n+            if (i >= getMinimalIterationCount()) {\n                 final double delta  = FastMath.abs(s - olds);\n-                final double rLimit = relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n-                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                final double rLimit = getRelativeAccuracy() * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n+                if ((delta <= rLimit) || (delta <= getAbsoluteAccuracy())) {\n                     return s;\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.java\n         throws TooManyEvaluationsException, MaxCountExceededException {\n \n         TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n-        if (minimalIterationCount == 1) {\n+        if (getMinimalIterationCount() == 1) {\n             return (4 * qtrap.stage(this, 1) - qtrap.stage(this, 0)) / 3.0;\n         }\n \n             final double t = qtrap.stage(this, iterations.getCount());\n             iterations.incrementCount();\n             final double s = (4 * t - oldt) / 3.0;\n-            if (iterations.getCount() >= minimalIterationCount) {\n+            if (iterations.getCount() >= getMinimalIterationCount()) {\n                 final double delta = FastMath.abs(s - olds);\n                 final double rLimit =\n-                    relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n-                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                    getRelativeAccuracy() * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n+                if ((delta <= rLimit) || (delta <= getAbsoluteAccuracy())) {\n                     return s;\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.java\n         throws TooManyEvaluationsException {\n \n         if (n == 0) {\n-            s = 0.5 * (baseIntegrator.max - baseIntegrator.min) *\n-                      (baseIntegrator.computeObjectiveValue(baseIntegrator.min) +\n-                       baseIntegrator.computeObjectiveValue(baseIntegrator.max));\n+            final double max = baseIntegrator.getMax();\n+            final double min = baseIntegrator.getMin();\n+            s = 0.5 * (max - min) *\n+                      (baseIntegrator.computeObjectiveValue(min) +\n+                       baseIntegrator.computeObjectiveValue(max));\n             return s;\n         } else {\n             final long np = 1L << (n-1);           // number of new points in this stage\n             double sum = 0;\n+            final double max = baseIntegrator.getMax();\n+            final double min = baseIntegrator.getMin();\n             // spacing between adjacent new points\n-            final double spacing = (baseIntegrator.max - baseIntegrator.min) / np;\n-            double x = baseIntegrator.min + 0.5 * spacing;    // the first new point\n+            final double spacing = (max - min) / np;\n+            double x = min + 0.5 * spacing;    // the first new point\n             for (long i = 0; i < np; i++) {\n                 sum += baseIntegrator.computeObjectiveValue(x);\n                 x += spacing;\n         while (true) {\n             final int i = iterations.getCount();\n             final double t = stage(this, i);\n-            if (i >= minimalIterationCount) {\n+            if (i >= getMinimalIterationCount()) {\n                 final double delta = FastMath.abs(t - oldt);\n                 final double rLimit =\n-                    relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n-                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                    getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n+                if ((delta <= rLimit) || (delta <= getAbsoluteAccuracy())) {\n                     return t;\n                 }\n             }", "timestamp": 1330746924, "metainfo": ""}