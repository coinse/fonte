{"sha": "605055103ac5d748602f521d1cf9fd329e814f00", "log": "replace string concatenation with StringBuffer.append calls.  ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n      */\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n-        outBuffer.append(\"DescriptiveStatistics:\\n\");\n-        outBuffer.append(\"n: \" + getN() + \"\\n\");\n-        outBuffer.append(\"min: \" + getMin() + \"\\n\");\n-        outBuffer.append(\"max: \" + getMax() + \"\\n\");\n-        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n-        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n-        outBuffer.append(\"median: \" + getPercentile(50) + \"\\n\");\n-        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n-        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+        String endl = \"\\n\";\n+        outBuffer.append(\"DescriptiveStatistics:\").append(endl);\n+        outBuffer.append(\"n: \").append(getN()).append(endl);\n+        outBuffer.append(\"min: \").append(getMin()).append(endl);\n+        outBuffer.append(\"max: \").append(getMax()).append(endl);\n+        outBuffer.append(\"mean: \").append(getMean()).append(endl);\n+        outBuffer.append(\"std dev: \").append(getStandardDeviation())\n+            .append(endl);\n+        outBuffer.append(\"median: \").append(getPercentile(50)).append(endl);\n+        outBuffer.append(\"skewness: \").append(getSkewness()).append(endl);\n+        outBuffer.append(\"kurtosis: \").append(getKurtosis()).append(endl);\n         return outBuffer.toString();\n     }\n     \n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.stat.descriptive;\n \n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * <p>Computes summary statistics for a stream of data values added using the \n+ * <p>\n+ * Computes summary statistics for a stream of data values added using the\n  * {@link #addValue(double) addValue} method. The data values are not stored in\n- * memory, so this class can be used to compute statistics for very large\n- * data streams.</p>\n- * \n- * <p>The {@link StorelessUnivariateStatistic} instances used to maintain\n- * summary state and compute statistics are configurable via setters.\n- * For example, the default implementation for the variance can be overridden by\n- * calling {@link #setVarianceImpl(StorelessUnivariateStatistic)}. Actual\n- * parameters to these methods must implement the \n- * {@link StorelessUnivariateStatistic} interface and configuration must be\n- * completed before <code>addValue</code> is called. No configuration is\n- * necessary to use the default, commons-math provided implementations.</p>\n- * \n- * <p>Note: This class is not thread-safe. Use \n+ * memory, so this class can be used to compute statistics for very large data\n+ * streams.\n+ * </p>\n+ * <p>\n+ * The {@link StorelessUnivariateStatistic} instances used to maintain summary\n+ * state and compute statistics are configurable via setters. For example, the\n+ * default implementation for the variance can be overridden by calling\n+ * {@link #setVarianceImpl(StorelessUnivariateStatistic)}. Actual parameters to\n+ * these methods must implement the {@link StorelessUnivariateStatistic}\n+ * interface and configuration must be completed before <code>addValue</code>\n+ * is called. No configuration is necessary to use the default, commons-math\n+ * provided implementations.\n+ * </p>\n+ * <p>\n+ * Note: This class is not thread-safe. Use\n  * {@link SynchronizedSummaryStatistics} if concurrent access from multiple\n- * threads is required.</p>\n- *\n- * @version $Revision$ $Date$\n+ * threads is required.\n+ * </p>\n+ * @version $Revision$ $Date: 2008-02-10 13:28:59 -0600 (Sun, 10 Feb\n+ *          2008) $\n  */\n public class SummaryStatistics implements StatisticalSummary, Serializable {\n \n     /** Serialization UID */\n     private static final long serialVersionUID = -3346512372447011854L;\n-     \n+\n     /**\n      * Create an instance of a <code>SummaryStatistics</code>\n-     * \n-     * @param cls the type of <code>SummaryStatistics</code> object to\n-     *        create. \n-     * @return a new instance. \n+     * @param cls the type of <code>SummaryStatistics</code> object to create.\n+     * @return a new instance.\n      * @deprecated to be removed in commons-math 2.0\n      * @throws InstantiationException is thrown if the object can not be\n-     *            created.\n+     *         created.\n      * @throws IllegalAccessException is thrown if the type's default\n-     *            constructor is not accessible.\n-     */\n-    public static SummaryStatistics newInstance(Class cls) throws \n-        InstantiationException, IllegalAccessException {\n+     *         constructor is not accessible.\n+     */\n+    public static SummaryStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {\n         return (SummaryStatistics)cls.newInstance();\n     }\n-    \n+\n     /**\n      * Create an instance of a <code>SummaryStatistics</code>\n-     * \n      * @return a new SummaryStatistics instance.\n-     * @deprecated to be removed in commons-math 2.0 \n+     * @deprecated to be removed in commons-math 2.0\n      */\n     public static SummaryStatistics newInstance() {\n         SummaryStatistics instance = null;\n         try {\n             DiscoverClass dc = new DiscoverClass();\n-            instance = (SummaryStatistics) dc.newInstance(\n-                SummaryStatistics.class,\n-                \"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl\");\n-        } catch(Throwable t) {\n+            instance = (SummaryStatistics)dc.newInstance(SummaryStatistics.class, \"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl\");\n+        } catch (Throwable t) {\n             return new SummaryStatisticsImpl();\n         }\n         return instance;\n     }\n-    \n+\n     /**\n      * Construct a SummaryStatistics instance\n      */\n     public SummaryStatistics() {\n     }\n-    \n+\n     /** count of values that have been added */\n     protected long n = 0;\n-    \n+\n     /** SecondMoment is used to compute the mean and variance */\n     protected SecondMoment secondMoment = new SecondMoment();\n-    \n+\n     /** sum of values that have been added */\n     protected Sum sum = new Sum();\n \n \n     /** variance of values that have been added */\n     protected Variance variance = new Variance();\n-    \n+\n     /** Sum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic sumImpl = sum;\n-    \n+\n     /** Sum of squares statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic sumsqImpl = sumsq;\n-    \n+\n     /** Minimum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic minImpl = min;\n-    \n+\n     /** Maximum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic maxImpl = max;\n-    \n+\n     /** Sum of log statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic sumLogImpl = sumLog;\n-    \n+\n     /** Geometric mean statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic geoMeanImpl = geoMean;\n-    \n+\n     /** Mean statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic meanImpl = mean;\n-    \n+\n     /** Variance statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic varianceImpl = variance;\n \n     /**\n      * Return a {@link StatisticalSummaryValues} instance reporting current\n      * statistics.\n-     * \n-     * @return Current values of statistics \n+     * @return Current values of statistics\n      */\n     public StatisticalSummary getSummary() {\n-        return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n-                getMax(), getMin(), getSum());\n-    }\n-    \n+        return new StatisticalSummaryValues(getMean(), getVariance(), getN(), getMax(), getMin(), getSum());\n+    }\n+\n     /**\n      * Add a value to the data\n-     * \n-     * @param value  the value to add\n+     * @param value the value to add\n      */\n     public void addValue(double value) {\n         sumImpl.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n         if (!(meanImpl instanceof Mean)) {\n-                meanImpl.increment(value);\n+            meanImpl.increment(value);\n         }\n         if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         n++;\n     }\n \n-    /** \n+    /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n     /**\n      * Returns the sum of the squares of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     * \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n      * @return The sum of squares\n      */\n     public double getSumsq() {\n     /**\n      * Returns the mean of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     * \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n      * @return the mean\n      */\n     public double getMean() {\n-      if (mean == meanImpl) {\n-          return new Mean(secondMoment).getResult();\n-      } else {\n-          return meanImpl.getResult();\n-      }\n+        if (mean == meanImpl) {\n+            return new Mean(secondMoment).getResult();\n+        } else {\n+            return meanImpl.getResult();\n+        }\n     }\n \n     /**\n      * Returns the standard deviation of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     * \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n      * @return the standard deviation\n      */\n     public double getStandardDeviation() {\n     /**\n      * Returns the variance of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     *\n-     * @return the variance \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the variance\n      */\n     public double getVariance() {\n         if (varianceImpl == variance) {\n     /**\n      * Returns the maximum of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     *\n-     * @return the maximum  \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the maximum\n      */\n     public double getMax() {\n         return maxImpl.getResult();\n     /**\n      * Returns the minimum of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     *\n-     * @return the minimum  \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the minimum\n      */\n     public double getMin() {\n         return minImpl.getResult();\n     /**\n      * Returns the geometric mean of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     *\n-     * @return the geometric mean  \n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the geometric mean\n      */\n     public double getGeometricMean() {\n         return geoMeanImpl.getResult();\n     }\n-    \n+\n     /**\n      * Returns the sum of the logs of the values that have been added.\n      * <p>\n-     *  Double.NaN is returned if no values have been added.</p>\n-     *\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n      * @return the sum of logs\n      * @since 1.2\n      */\n     public double getSumOfLogs() {\n         return sumLogImpl.getResult();\n     }\n-    \n-    /**\n-     * Generates a text report displaying\n-     * summary statistics from values that\n+\n+    /**\n+     * Generates a text report displaying summary statistics from values that\n      * have been added.\n      * @return String with line feeds displaying statistics\n      * @since 1.2\n      */\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n-        outBuffer.append(\"SummaryStatistics:\\n\");\n-        outBuffer.append(\"n: \" + getN() + \"\\n\");\n-        outBuffer.append(\"min: \" + getMin() + \"\\n\");\n-        outBuffer.append(\"max: \" + getMax() + \"\\n\");\n-        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n-        outBuffer.append(\"geometric mean: \" + getGeometricMean() + \"\\n\");\n-        outBuffer.append(\"variance: \" + getVariance() + \"\\n\");\n-        outBuffer.append(\"sum of squares: \" + getSumsq() + \"\\n\");\n-        outBuffer.append(\"standard deviation: \" + getStandardDeviation() + \"\\n\");\n-        outBuffer.append(\"sum of logs: \" + getSumOfLogs() + \"\\n\");\n+        String endl = \"\\n\";\n+        outBuffer.append(\"SummaryStatistics:\").append(endl);\n+        outBuffer.append(\"n: \").append(getN()).append(endl);\n+        outBuffer.append(\"min: \").append(getMin()).append(endl);\n+        outBuffer.append(\"max: \").append(getMax()).append(endl);\n+        outBuffer.append(\"mean: \").append(getMean()).append(endl);\n+        outBuffer.append(\"geometric mean: \").append(getGeometricMean())\n+            .append(endl);\n+        outBuffer.append(\"variance: \").append(getVariance()).append(endl);\n+        outBuffer.append(\"sum of squares: \").append(getSumsq()).append(endl);\n+        outBuffer.append(\"standard deviation: \").append(getStandardDeviation())\n+            .append(endl);\n+        outBuffer.append(\"sum of logs: \").append(getSumOfLogs()).append(endl);\n         return outBuffer.toString();\n     }\n \n-    /** \n+    /**\n      * Resets all statistics and storage\n      */\n     public void clear() {\n             varianceImpl.clear();\n         }\n     }\n-    \n-    /**\n-     * Returns true iff <code>object</code> is a <code>SummaryStatistics</code>\n-     * instance and all statistics have the same values as this.\n+\n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>SummaryStatistics</code> instance and all statistics have the\n+     * same values as this.\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n     public boolean equals(Object object) {\n-        if (object == this ) {\n+        if (object == this) {\n             return true;\n         }\n         if (object instanceof SummaryStatistics == false) {\n             return false;\n         }\n-        SummaryStatistics stat = (SummaryStatistics) object;\n-        return (MathUtils.equals(stat.getGeometricMean(), \n-                this.getGeometricMean()) &&\n-                MathUtils.equals(stat.getMax(), this.getMax()) && \n-                MathUtils.equals(stat.getMean(),this.getMean()) &&\n-                MathUtils.equals(stat.getMin(),this.getMin()) &&\n-                MathUtils.equals(stat.getN(), this.getN()) &&\n-                MathUtils.equals(stat.getSum(), this.getSum()) &&\n-                MathUtils.equals(stat.getSumsq(),this.getSumsq()) &&\n-                MathUtils.equals(stat.getVariance(),this.getVariance()));\n-    }\n-    \n+        SummaryStatistics stat = (SummaryStatistics)object;\n+        return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())\n+            && MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())\n+            && MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),\n+            this.getVariance()));\n+    }\n+\n     /**\n      * Returns hash code based on values of statistics\n-     * \n      * @return hash code\n      */\n     public int hashCode() {\n     // Getters and setters for statistics implementations\n     /**\n      * Returns the currently configured Sum implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the sum\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the Sum.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param sumImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the Sum\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n+     * <p>\n+     * Sets the implementation for the Sum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the Sum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n      * @since 1.2\n      */\n     public void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n \n     /**\n      * Returns the currently configured sum of squares implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the sum of squares\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the sum of squares.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param sumsqImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the sum of squares\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n-     * @since 1.2\n-     */\n-    public void setSumsqImpl(\n-            StorelessUnivariateStatistic sumsqImpl) {\n+     * <p>\n+     * Sets the implementation for the sum of squares.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumsqImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the sum of squares\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n         checkEmpty();\n         this.sumsqImpl = sumsqImpl;\n     }\n \n     /**\n      * Returns the currently configured minimum implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the minimum\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the minimum.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param minImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the minimum\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n+     * <p>\n+     * Sets the implementation for the minimum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param minImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the minimum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n      * @since 1.2\n      */\n     public void setMinImpl(StorelessUnivariateStatistic minImpl) {\n \n     /**\n      * Returns the currently configured maximum implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the maximum\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the maximum.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param maxImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the maximum\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n+     * <p>\n+     * Sets the implementation for the maximum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param maxImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the maximum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n      * @since 1.2\n      */\n     public void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n \n     /**\n      * Returns the currently configured sum of logs implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the log sum\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the sum of logs.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the log sum\n-     * @throws IllegalStateException if data has already been added \n-     *  (i.e if n > 0)\n-     * @since 1.2\n-     */\n-    public void setSumLogImpl(\n-            StorelessUnivariateStatistic sumLogImpl) {\n+     * <p>\n+     * Sets the implementation for the sum of logs.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumLogImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the log sum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n         checkEmpty();\n         this.sumLogImpl = sumLogImpl;\n         geoMean.setSumLogImpl(sumLogImpl);\n \n     /**\n      * Returns the currently configured geometric mean implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the geometric mean\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the geometric mean.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the geometric mean\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n-     * @since 1.2\n-     */\n-    public void setGeoMeanImpl(\n-            StorelessUnivariateStatistic geoMeanImpl) {\n+     * <p>\n+     * Sets the implementation for the geometric mean.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the geometric mean\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n         checkEmpty();\n         this.geoMeanImpl = geoMeanImpl;\n     }\n \n     /**\n      * Returns the currently configured mean implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the mean\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the mean.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param meanImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the mean\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n-     * @since 1.2\n-     */\n-    public void setMeanImpl(\n-            StorelessUnivariateStatistic meanImpl) {\n+     * <p>\n+     * Sets the implementation for the mean.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param meanImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the mean\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n         checkEmpty();\n         this.meanImpl = meanImpl;\n     }\n \n     /**\n      * Returns the currently configured variance implementation\n-     * \n      * @return the StorelessUnivariateStatistic implementing the variance\n      * @since 1.2\n      */\n     }\n \n     /**\n-     * <p>Sets the implementation for the variance.</p>\n-     * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double) addValue} has been used to add data; \n-     * otherwise an IllegalStateException will be thrown.</p>\n-     * \n-     * @param varianceImpl the StorelessUnivariateStatistic instance to use\n-     * for computing the variance\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n-     * @since 1.2\n-     */\n-    public void setVarianceImpl(\n-            StorelessUnivariateStatistic varianceImpl) {\n+     * <p>\n+     * Sets the implementation for the variance.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param varianceImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the variance\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n         checkEmpty();\n         this.varianceImpl = varianceImpl;\n     }\n-    \n+\n     /**\n      * Throws IllegalStateException if n > 0.\n      */\n     private void checkEmpty() {\n         if (n > 0) {\n-            throw new IllegalStateException(\n-                \"Implementations must be configured before values are added.\");\n+            throw new IllegalStateException(\"Implementations must be configured before values are added.\");\n         }\n     }\n ", "timestamp": 1205033430, "metainfo": ""}