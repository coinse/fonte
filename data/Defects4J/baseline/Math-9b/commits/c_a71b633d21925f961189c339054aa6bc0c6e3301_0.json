{"sha": "a71b633d21925f961189c339054aa6bc0c6e3301", "log": "Fixed definition of remainder and added missing copySign signature.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ExtendedFieldElement.java\n+++ b/src/main/java/org/apache/commons/math3/ExtendedFieldElement.java\n      */\n     T divide(double a);\n \n-    /** '%' operator.\n+    /** IEEE remainder operator.\n      * @param a right hand side parameter of the operator\n-     * @return this%a\n+     * @return this - n &times; a where n is the closest integer to this/a\n+     * (the even integer is chosen for n if this/a is halfway between two integers)\n      */\n     T remainder(double a);\n \n-    /** '%' operator.\n+    /** IEEE remainder operator.\n      * @param a right hand side parameter of the operator\n-     * @return this%a\n+     * @return this - n &times; a where n is the closest integer to this/a\n+     * (the even integer is chosen for n if this/a is halfway between two integers)\n      * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n      */\n     T remainder(T a)\n      * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n      */\n     T signum();\n+\n+    /**\n+     * Returns the instance with the sign of the argument.\n+     * A NaN {@code sign} argument is treated as positive.\n+     *\n+     * @param sign the sign for the returned value\n+     * @return the instance with the same sign as the {@code sign} argument\n+     */\n+    T copySign(T sign);\n \n     /**\n      * Returns the instance with the sign of the argument.\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n                           final double[] result, final int resultOffset) {\n \n         // compute k such that lhs % rhs = lhs - k rhs\n-        final double rem = lhs[lhsOffset] % rhs[rhsOffset];\n+        final double rem = FastMath.IEEEremainder(lhs[lhsOffset], rhs[rhsOffset]);\n         final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);\n \n         // set up value\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n     /** {@inheritDoc} */\n     public DerivativeStructure remainder(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n-        ds.data[0] = ds.data[0] % a;\n+        ds.data[0] = FastMath.IEEEremainder(ds.data[0], a);\n         return ds;\n     }\n \n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.signum(data[0]));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure copySign(final DerivativeStructure sign){\n+        long m = Double.doubleToLongBits(data[0]);\n+        long s = Double.doubleToLongBits(sign.data[0]);\n+        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n+            return this;\n+        }\n+        return negate(); // flip sign\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n     /** {@inheritDoc}\n      * @since 3.2\n      */\n-    public Dfp copySign(final double sign) {\n-        long s = Double.doubleToLongBits(sign);\n-        if ((sign >= 0 && s >= 0) || (sign < 0 && s < 0)) { // Sign is currently OK\n+    public Dfp copySign(final Dfp s) {\n+        if ((sign >= 0 && s.sign >= 0) || (sign < 0 && s.sign < 0)) { // Sign is currently OK\n+            return this;\n+        }\n+        return negate(); // flip sign\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp copySign(final double s) {\n+        long sb = Double.doubleToLongBits(s);\n+        if ((sign >= 0 && sb >= 0) || (sign < 0 && sb < 0)) { // Sign is currently OK\n             return this;\n         }\n         return negate(); // flip sign\n      * @since 3.2\n      */\n     public Dfp rootN(final int n) {\n-        return DfpMath.pow(this, getOne().divide(n));\n+        return (sign >= 0) ?\n+               DfpMath.pow(this, getOne().divide(n)) :\n+               DfpMath.pow(negate(), getOne().divide(n)).negate();\n     }\n \n     /** {@inheritDoc}\n     public Dfp tanh() {\n         final Dfp ePlus  = DfpMath.exp(this);\n         final Dfp eMinus = DfpMath.exp(negate());\n-        return ePlus.add(eMinus).divide(ePlus.subtract(eMinus));\n+        return ePlus.subtract(eMinus).divide(ePlus.add(eMinus));\n     }\n \n     /** {@inheritDoc}\n--- a/src/main/java/org/apache/commons/math3/util/Decimal64.java\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64.java\n \n     /** {@inheritDoc} */\n     public Decimal64 remainder(final double a) {\n-        return new Decimal64(value % a);\n+        return new Decimal64(FastMath.IEEEremainder(value, a));\n     }\n \n     /** {@inheritDoc} */\n     public Decimal64 remainder(final Decimal64 a) {\n-        return new Decimal64(value % a.value);\n+        return new Decimal64(FastMath.IEEEremainder(value, a.value));\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n+    public Decimal64 copySign(final Decimal64 sign) {\n+        return new Decimal64(FastMath.copySign(value, sign.value));\n+    }\n+\n+    /** {@inheritDoc} */\n     public Decimal64 copySign(final double sign) {\n         return new Decimal64(FastMath.copySign(value, sign));\n     }\n \n     /** {@inheritDoc} */\n     public Decimal64 rootN(final int n) {\n-        return new Decimal64(FastMath.pow(value, 1.0 / n));\n+        if (value < 0) {\n+            return new Decimal64(-FastMath.pow(-value, 1.0 / n));\n+        } else {\n+            return new Decimal64(FastMath.pow(value, 1.0 / n));\n+        }\n     }\n \n     /** {@inheritDoc} */", "timestamp": 1361802833, "metainfo": ""}