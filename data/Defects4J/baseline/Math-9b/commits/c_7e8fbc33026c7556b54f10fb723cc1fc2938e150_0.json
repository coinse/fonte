{"sha": "7e8fbc33026c7556b54f10fb723cc1fc2938e150", "log": "Fixed null handling in varargs for sortInPlace, improved javadoc, addeed tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n-     * Sort an array in increasing order, performing the same reordering of\n-     * entries on other arrays.\n-     *\n-     * @param x Array to be sorted.\n-     * @param yList Set of arrays whose permutations of entries must follow\n+     * Sort an array in ascending order in place and perform the same reordering\n+     * of entries on other arrays. For example, if\n+     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then \n+     * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},\n+     * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n+     *\n+     * @param x Array to be sorted and used as a pattern for permutation\n+     * of the other arrays.\n+     * @param yList Set of arrays whose permutations of entries will follow\n      * those performed on {@code x}.\n-     * @throws DimensionMismatchException if any {@code y} has not the same\n+     * @throws DimensionMismatchException if any {@code y} is not the same\n      * size as {@code x}.\n+     * @throws NullArgumentException if {@code x} or any {@code y} is null.\n+     * @since 3.0\n      */\n     public static void sortInPlace(double[] x,\n                                    double[] ... yList) {\n     }\n \n     /**\n-     * Sort an array, performing the same reordering of entries on other arrays.\n-     *\n-     * @param x Array to be sorted.\n+     * Sort an array in place and perform the same reordering of entries on\n+     * other arrays.  This method works the same as\n+     * {@link #sortInPlace(double[], double[]...)}, but allows the order of the\n+     * sort to be provided in the {@code dir} parameter.\n+     * \n+     * @param x Array to be sorted and used as a pattern for permutation\n+     * of the other arrays.\n      * @param dir Order direction.\n-     * @param yList Set of arrays whose permutations of entries must follow\n+     * @param yList Set of arrays whose permutations of entries will follow\n      * those performed on {@code x}.\n-     * @throws DimensionMismatchException if any {@code y} has not the same\n+     * @throws DimensionMismatchException if any {@code y} is not the same\n      * size as {@code x}.\n+     * @throws NullArgumentException if {@code x} or any {@code y} is null\n+     * @since 3.0\n      */\n     public static void sortInPlace(double[] x,\n                                    final OrderDirection dir,\n                                    double[] ... yList) {\n-        if (x == null ||\n-            yList == null) {\n+        if (x == null) {\n             throw new NullArgumentException();\n         }\n \n             final double[] yValues = new double[yListLen];\n             for (int j = 0; j < yListLen; j++) {\n                 double[] y = yList[j];\n+                if (y == null) {\n+                    throw new NullArgumentException();\n+                }\n                 if (y.length != len) {\n                     throw new DimensionMismatchException(y.length, len);\n                 }\n                                            final double a2, final double b2) {\n \n         // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they shoud NOT be simplified, as they\n-        // do use IEEE754 floating point arithmetic rouding properties.\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // use IEEE754 floating point arithmetic rounding properties.\n         // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n-        // The variables naming conventions are that xyzHigh contains the most significant\n+        // The variable naming conventions are that xyzHigh contains the most significant\n         // bits of xyz and xyzLow contains its least significant bits. So theoretically\n         // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n         // be represented in only one double precision number so we preserve two numbers\n                                            final double a3, final double b3) {\n \n         // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they shoud NOT be simplified, as they\n-        // do use IEEE754 floating point arithmetic rouding properties.\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // do use IEEE754 floating point arithmetic rounding properties.\n         // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n         // The variables naming conventions are that xyzHigh contains the most significant\n         // bits of xyz and xyzLow contains its least significant bits. So theoretically\n                                            final double a4, final double b4) {\n \n         // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they shoud NOT be simplified, as they\n-        // do use IEEE754 floating point arithmetic rouding properties.\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // do use IEEE754 floating point arithmetic rounding properties.\n         // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n         // The variables naming conventions are that xyzHigh contains the most significant\n         // bits of xyz and xyzLow contains its least significant bits. So theoretically\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathArithmeticException;\n         Assert.assertEquals(25,  x2[4], Math.ulp(1d));\n         Assert.assertEquals(125, x3[4], Math.ulp(1d));\n     }\n+    \n+    @Test\n+    /** Example in javadoc */\n+    public void testSortInPlaceExample() {\n+        final double[] x = {3, 1, 2};\n+        final double[] y = {1, 2, 3};\n+        final double[] z = {0, 5, 7};\n+        MathUtils.sortInPlace(x, y, z);\n+        final double[] sx = {1, 2, 3};\n+        final double[] sy = {2, 3, 1};\n+        final double[] sz = {5, 7, 0};\n+        Assert.assertTrue(Arrays.equals(sx, x));\n+        Assert.assertTrue(Arrays.equals(sy, y));\n+        Assert.assertTrue(Arrays.equals(sz, z));\n+    }\n+    \n+    @Test\n+    public void testSortInPlaceFaliures() {\n+        final double[] nullArray = null;\n+        final double[] one = {1};\n+        final double[] two = {1, 2};\n+        final double[] onep = {2};\n+        try {\n+            MathUtils.sortInPlace(one, two);\n+            Assert.fail(\"Expecting DimensionMismatchException\");\n+        } catch (DimensionMismatchException ex) {\n+            // expected\n+        }\n+        try {\n+            MathUtils.sortInPlace(one, nullArray);\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MathUtils.sortInPlace(one, onep, nullArray);\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n \n     @Test\n     public void testCopyOfInt() {", "timestamp": 1318050234, "metainfo": ""}