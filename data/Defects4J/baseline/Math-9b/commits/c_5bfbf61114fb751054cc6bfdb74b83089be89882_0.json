{"sha": "5bfbf61114fb751054cc6bfdb74b83089be89882", "log": "separate discrete event detection from adaptive step size handling in ODE solvers, thus improving robustness, maintainability and speed JIRA: MATH-484   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-\n+import java.util.List;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventException;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Base class managing common boilerplate for all integrators.\n     /** Current stepsize. */\n     protected double stepSize;\n \n-    /** Events handlers manager. */\n-    protected CombinedEventsManager eventsHandlersManager;\n+    /** Indicator for last step. */\n+    protected boolean isLastStep;\n+\n+    /** Indicator that a state or derivative reset was triggered by some event. */\n+    protected boolean resetOccurred;\n+\n+    /** Events states. */\n+    protected Collection<EventState> eventsStates;\n+\n+    /** Initialization indicator of events states. */\n+    protected boolean statesInitialized;\n \n     /** Name of the method. */\n     private final String name;\n         stepHandlers = new ArrayList<StepHandler>();\n         stepStart = Double.NaN;\n         stepSize  = Double.NaN;\n-        eventsHandlersManager = new CombinedEventsManager();\n+        eventsStates = new ArrayList<EventState>();\n+        statesInitialized = false;\n         setMaxEvaluations(-1);\n         resetEvaluations();\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public void addEventHandler(final EventHandler function,\n+    public void addEventHandler(final EventHandler handler,\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount) {\n-        eventsHandlersManager.addEventHandler(function, maxCheckInterval,\n-                                              convergence, maxIterationCount);\n+        eventsStates.add(new EventState(handler, maxCheckInterval, convergence, maxIterationCount));\n     }\n \n     /** {@inheritDoc} */\n     public Collection<EventHandler> getEventHandlers() {\n-        return eventsHandlersManager.getEventsHandlers();\n+        final List<EventHandler> list = new ArrayList<EventHandler>();\n+        for (EventState state : eventsStates) {\n+            list.add(state.getEventHandler());\n+        }\n+        return Collections.unmodifiableCollection(list);\n     }\n \n     /** {@inheritDoc} */\n     public void clearEventHandlers() {\n-        eventsHandlersManager.clearEventsHandlers();\n+        eventsStates.clear();\n     }\n \n     /** Check if one of the step handlers requires dense output.\n             throw new MathUserException(new MaxEvaluationsExceededException(maxEvaluations));\n         }\n         equations.computeDerivatives(t, y, yDot);\n+    }\n+\n+    /** Accept a step, triggering events and step handlers.\n+     * @param interpolator step interpolator\n+     * @param handlers step handlers\n+     * @param y state vector at step end time, must be reset if an event\n+     * asks for resetting or if an events stops integration during the step\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @param tEnd final integration time\n+     * @return time at end of step\n+     * @exception IntegratorException if the value of one event state cannot be evaluated\n+     */\n+    protected double acceptStep(final AbstractStepInterpolator interpolator,\n+                                final Collection<StepHandler> handlers,\n+                                final double[] y,\n+                                final double[] yDot, final double tEnd)\n+        throws IntegratorException {\n+\n+        try {\n+            double previousT = interpolator.getGlobalPreviousTime();\n+            final double currentT = interpolator.getGlobalCurrentTime();\n+            resetOccurred = false;\n+\n+            // initialize the events states if needed\n+            if (! statesInitialized) {\n+                for (EventState state : eventsStates) {\n+                    state.reinitializeBegin(interpolator);\n+                }\n+                statesInitialized = true;\n+            }\n+\n+            // find all events that occur during the step\n+            SortedSet<EventState> occuringEvents = new TreeSet<EventState>();\n+            for (final EventState state : eventsStates) {\n+                if (state.evaluateStep(interpolator)) {\n+                    // the event occurs during the current step\n+                    occuringEvents.add(state);\n+                }\n+            }\n+\n+            // handle the events chronologically\n+            for (final EventState state : occuringEvents) {\n+\n+                // restrict the interpolator to the first part of the step, up to the event\n+                final double eventT = state.getEventTime();\n+                interpolator.setSoftBounds(previousT, eventT);\n+\n+                // trigger the event\n+                interpolator.setInterpolatedTime(eventT);\n+                final double[] eventY = interpolator.getInterpolatedState();\n+                state.stepAccepted(eventT, eventY);\n+                isLastStep = state.stop();\n+\n+                // handle the first part of the step, up to the event\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(interpolator, isLastStep);\n+                }\n+\n+                if (isLastStep) {\n+                    // the event asked to stop integration\n+                    System.arraycopy(eventY, 0, y, 0, y.length);\n+                    return eventT;\n+                }\n+\n+                if (state.reset(eventT, eventY)) {\n+                    // some event handler has triggered changes that\n+                    // invalidate the derivatives, we need to recompute them\n+                    System.arraycopy(eventY, 0, y, 0, y.length);\n+                    computeDerivatives(eventT, y, yDot);\n+                    resetOccurred = true;\n+                    return eventT;\n+                }\n+\n+                // prepare handling of the remaining part of the step\n+                previousT = eventT;\n+                interpolator.setSoftBounds(eventT, currentT);\n+\n+            }\n+\n+            interpolator.setInterpolatedTime(currentT);\n+            final double[] currentY = interpolator.getInterpolatedState();\n+            for (final EventState state : eventsStates) {\n+                state.stepAccepted(currentT, currentY);\n+                isLastStep = isLastStep || state.stop();\n+            }\n+            isLastStep = isLastStep || MathUtils.equals(currentT, tEnd, 1);\n+\n+            // handle the remaining part of the step, after all events if any\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, isLastStep);\n+            }\n+\n+            return currentT;\n+        } catch (EventException se) {\n+            final Throwable cause = se.getCause();\n+            if ((cause != null) && (cause instanceof MathUserException)) {\n+                throw (MathUserException) cause;\n+            }\n+            throw new IntegratorException(se);\n+        } catch (ConvergenceException ce) {\n+            throw new IntegratorException(ce);\n+        }\n+\n     }\n \n     /** Perform some sanity checks on the integration parameters.\n \n     }\n \n-    /** Add an event handler for end time checking.\n-     * <p>This method can be used to simplify handling of integration end time.\n-     * It leverages the nominal stop condition with the exceptional stop\n-     * conditions.</p>\n-     * @param startTime integration start time\n-     * @param endTime desired end time\n-     * @param manager manager containing the user-defined handlers\n-     * @return a new manager containing all the user-defined handlers plus a\n-     * dedicated manager triggering a stop event at entTime\n-     */\n-    protected CombinedEventsManager addEndTimeChecker(final double startTime,\n-                                                      final double endTime,\n-                                                      final CombinedEventsManager manager) {\n-        CombinedEventsManager newManager = new CombinedEventsManager();\n-        for (final EventState state : manager.getEventsStates()) {\n-            newManager.addEventHandler(state.getEventHandler(),\n-                                       state.getMaxCheckInterval(),\n-                                       state.getConvergence(),\n-                                       state.getMaxIterationCount());\n-        }\n-        newManager.addEventHandler(new EndTimeChecker(endTime),\n-                                   Double.POSITIVE_INFINITY,\n-                                   FastMath.ulp(FastMath.max(FastMath.abs(startTime), FastMath.abs(endTime))),\n-                                   100);\n-        return newManager;\n-    }\n-\n-    /** Specialized event handler to stop integration. */\n-    private static class EndTimeChecker implements EventHandler {\n-\n-        /** Desired end time. */\n-        private final double endTime;\n-\n-        /** Build an instance.\n-         * @param endTime desired time\n-         */\n-        public EndTimeChecker(final double endTime) {\n-            this.endTime = endTime;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public int eventOccurred(double t, double[] y, boolean increasing) {\n-            return STOP;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double g(double t, double[] y) {\n-            return t - endTime;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void resetState(double t, double[] y) {\n-        }\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/ODEIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/ODEIntegrator.java\n      * @see #getEventHandlers()\n      * @see #clearEventHandlers()\n      */\n-    void addEventHandler(EventHandler handler,\n-                                         double maxCheckInterval,\n-                                         double convergence,\n-                                         int maxIterationCount);\n+    void addEventHandler(EventHandler handler, double maxCheckInterval,\n+                         double convergence, int maxIterationCount);\n \n     /** Get all the event handlers that have been added to the integrator.\n      * @return an unmodifiable collection of the added events handlers\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n package org.apache.commons.math.ode.events;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n \n  * of one handler during one integration step, with references to the\n  * state at the end of the preceding step. This information is used to\n  * decide if the handler should trigger an event or not during the\n- * proposed step (and hence the step should be reduced to ensure the\n- * event occurs at a bound rather than inside the step).</p>\n+ * proposed step.</p>\n  *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class EventState {\n+public class EventState implements Comparable<EventState> {\n \n     /** Event handler. */\n     private final EventHandler handler;\n     /** Evaluate the impact of the proposed step on the event handler.\n      * @param interpolator step interpolator for the proposed step\n      * @return true if the event handler triggers an event before\n-     * the end of the proposed step (this implies the step should be\n-     * rejected)\n+     * the end of the proposed step\n      * @exception MathUserException if the interpolator fails to\n      * compute the switching function somewhere within the step\n      * @exception EventException if the switching function\n \n             forward = interpolator.isForward();\n             final double t1 = interpolator.getCurrentTime();\n-            final int    n  = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(t1 - t0) / maxCheckInterval));\n-            final double h  = (t1 - t0) / n;\n+            if (FastMath.abs(t1 - t0) < convergence) {\n+                // we cannot do anything on such a small step, don't trigger any events\n+                return false;\n+            }\n+            final double start = forward ? (t0 + convergence) : t0 - convergence;\n+            final double dt    = t1 - start;\n+            final int    n     = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n+            final double h     = dt / n;\n \n             double ta = t0;\n             double ga = g0;\n-            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n             for (int i = 0; i < n; ++i) {\n \n                 // evaluate handler value at the end of the substep\n-                tb += h;\n+                final double tb = start + (i + 1) * h;\n                 interpolator.setInterpolatedTime(tb);\n                 final double gb = handler.g(tb, interpolator.getInterpolatedState());\n \n                 // check events occurrence\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n-\n-                    if (ga * gb > 0) {\n-                        // this is a corner case:\n-                        // - there was an event near ta,\n-                        // - there is another event between ta and tb\n-                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n-                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n-                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n-                        // about bracketing\n-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n-                            ta += epsilon;\n-                            interpolator.setInterpolatedTime(ta);\n-                            ga = handler.g(ta, interpolator.getInterpolatedState());\n-                        }\n-                        if (ga * gb > 0) {\n-                            // this should never happen\n-                            throw MathRuntimeException.createInternalError(null);\n-                        }\n-                    }\n \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n                         }\n                     };\n                     final BrentSolver solver = new BrentSolver(convergence);\n+\n+                    if (ga * gb >= 0) {\n+                        // this is a corner case:\n+                        // - there was an event near ta,\n+                        // - there is another event between ta and tb\n+                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n+                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n+                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n+                        // about bracketing\n+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+                            ta += epsilon;\n+                            ga = f.value(ta);\n+                        }\n+                        if (ga * gb > 0) {\n+                            // this should never happen\n+                            throw new MathInternalError();\n+                        }\n+                    }\n+\n                     final double root = (ta <= tb) ?\n-                        solver.solve(maxIterationCount, f, ta, tb) :\n-                        solver.solve(maxIterationCount, f, tb, ta);\n-                    if ((FastMath.abs(root - ta) <= convergence) &&\n-                         (FastMath.abs(root - previousEventTime) <= convergence)) {\n+                                        solver.solve(maxIterationCount, f, ta, tb) :\n+                                        solver.solve(maxIterationCount, f, tb, ta);\n+\n+                    if ((!Double.isNaN(previousEventTime)) &&\n+                        (FastMath.abs(root - ta) <= convergence) &&\n+                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (FastMath.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (FastMath.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n                         pendingEvent = true;\n                         return true;\n+                    } else {\n+                        // no sign change: there is no event for now\n+                        ta = tb;\n+                        ga = gb;\n                     }\n \n                 } else {\n         t0 = t;\n         g0 = handler.g(t, y);\n \n-        if (pendingEvent) {\n+        if (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\n             // force the sign to its value \"just after the event\"\n             previousEventTime = t;\n             g0Positive        = increasing;\n     public boolean reset(final double t, final double[] y)\n         throws EventException {\n \n-        if (! pendingEvent) {\n+        if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\n             return false;\n         }\n \n \n     }\n \n+    /** Compare the instance with another event state.\n+     * <p>\n+     * Event state ordering is based on occurrence time within the last\n+     * evaluated step. If no event occurs during the step, a time arbitrarily\n+     * set to positive infinity is used.\n+     * </p>\n+     * @param state other event state to compare the instance to\n+     * @return a negative integer, zero, or a positive integer as the event\n+     * occurs before, simultaneous, or after the specified event of the\n+     * specified state.\n+     */\n+    public int compareTo(final EventState state) {\n+        final double instanceTime = pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;\n+        final double otherTime = state.pendingEvent ? state.pendingEventTime : Double.POSITIVE_INFINITY;\n+        return Double.compare(instanceTime, otherTime);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n             System.arraycopy(y0, 0, y, 0, n);\n         }\n         final double[] yDot = new double[n];\n-        final double[] yTmp = new double[y0.length];\n \n         // set up an interpolator sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n         interpolator.reinitialize(y, forward);\n-        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n-        interpolatorTmp.reinitialize(yTmp, forward);\n \n         // set up integration control objects\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n-        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+        statesInitialized = false;\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n         start(t0, y, t);\n         double hNew = stepSize;\n         interpolator.rescale(hNew);\n \n-        boolean lastStep = false;\n-        while (!lastStep) {\n-\n-            // shift all data\n-            interpolator.shift();\n-\n-            double error = 0;\n-            for (boolean loop = true; loop;) {\n+        // main integration loop\n+        isLastStep = false;\n+        do {\n+\n+            double error = 10;\n+            while (error >= 1.0) {\n \n                 stepSize = hNew;\n \n                 }\n                 error = FastMath.sqrt(error / mainSetDimension);\n \n-                if (error <= 1.0) {\n-\n-                    // predict a first estimate of the state at step end\n-                    final double stepEnd = stepStart + stepSize;\n-                    interpolator.setInterpolatedTime(stepEnd);\n-                    System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n-\n-                    // evaluate the derivative\n-                    computeDerivatives(stepEnd, yTmp, yDot);\n-\n-                    // update Nordsieck vector\n-                    final double[] predictedScaled = new double[y0.length];\n-                    for (int j = 0; j < y0.length; ++j) {\n-                        predictedScaled[j] = stepSize * yDot[j];\n-                    }\n-                    final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n-                    updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n-\n-                    // discrete events handling\n-                    interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n-                    interpolatorTmp.storeTime(stepStart);\n-                    interpolatorTmp.shift();\n-                    interpolatorTmp.storeTime(stepEnd);\n-                    if (manager.evaluateStep(interpolatorTmp)) {\n-                        final double dt = manager.getEventTime() - stepStart;\n-                        if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n-                            // we cannot simply truncate the step, reject the current computation\n-                            // and let the loop compute another state with the truncated step.\n-                            // it is so small (much probably exactly 0 due to limited accuracy)\n-                            // that the code above would fail handling it.\n-                            // So we set up an artificial 0 size step by copying states\n-                            interpolator.storeTime(stepStart);\n-                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                            hNew     = 0;\n-                            stepSize = 0;\n-                            loop     = false;\n-                        } else {\n-                            // reject the step to match exactly the next switch time\n-                            hNew = dt;\n-                            interpolator.rescale(hNew);\n-                        }\n-                    } else {\n-                        // accept the step\n-                        scaled    = predictedScaled;\n-                        nordsieck = nordsieckTmp;\n-                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n-                        loop = false;\n-                    }\n-\n-                } else {\n+                if (error >= 1.0) {\n                     // reject the step and attempt to reduce error by stepsize control\n                     final double factor = computeStepGrowShrinkFactor(error);\n                     hNew = filterStep(stepSize * factor, forward, false);\n                     interpolator.rescale(hNew);\n+\n                 }\n-\n             }\n \n-            // the step has been accepted (may have been truncated)\n-            final double nextStep = stepStart + stepSize;\n-            System.arraycopy(yTmp, 0, y, 0, n);\n-            interpolator.storeTime(nextStep);\n-            manager.stepAccepted(nextStep, y);\n-            lastStep = manager.stop();\n-\n-            // provide the step data to the step handler\n-            for (StepHandler handler : stepHandlers) {\n-                interpolator.setInterpolatedTime(nextStep);\n-                handler.handleStep(interpolator, lastStep);\n+            // predict a first estimate of the state at step end\n+            final double stepEnd = stepStart + stepSize;\n+            interpolator.shift();\n+            interpolator.setInterpolatedTime(stepEnd);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+\n+            // evaluate the derivative\n+            computeDerivatives(stepEnd, y, yDot);\n+\n+            // update Nordsieck vector\n+            final double[] predictedScaled = new double[y0.length];\n+            for (int j = 0; j < y0.length; ++j) {\n+                predictedScaled[j] = stepSize * yDot[j];\n             }\n-            stepStart = nextStep;\n-\n-            if (!lastStep && manager.reset(stepStart, y)) {\n-\n-                // some events handler has triggered changes that\n-                // invalidate the derivatives, we need to restart from scratch\n-                start(stepStart, y, t);\n-                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n-\n-            }\n-\n-            if (! lastStep) {\n-                // in some rare cases we may get here with stepSize = 0, for example\n-                // when an event occurs at integration start, reducing the first step\n-                // to zero; we have to reset the step to some safe non zero value\n-                stepSize = filterStep(stepSize, forward, true);\n+            final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+            updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+            interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepEnd);\n+            stepStart = acceptStep(interpolator, stepHandlers, y, yDot, t);\n+            scaled    = predictedScaled;\n+            nordsieck = nordsieckTmp;\n+            interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n+\n+            if (!isLastStep) {\n+\n+                // prepare next step\n+                interpolator.storeTime(stepStart);\n+\n+                if (resetOccurred) {\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    start(stepStart, y, t);\n+                    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+                }\n \n                 // stepsize control for next step\n                 final double  factor     = computeStepGrowShrinkFactor(error);\n                 final double  nextT      = stepStart + scaledH;\n                 final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                 hNew = filterStep(scaledH, forward, nextIsLast);\n+\n+                final double  filteredNextT      = stepStart + hNew;\n+                final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n+                if (filteredNextIsLast) {\n+                    hNew = t - stepStart;\n+                }\n+\n                 interpolator.rescale(hNew);\n+\n             }\n \n-        }\n-\n-        final double stopTime  = stepStart;\n-        stepStart = Double.NaN;\n-        stepSize  = Double.NaN;\n+        } while (!isLastStep);\n+\n+        final double stopTime = stepStart;\n+        resetInternalState();\n         return stopTime;\n \n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n         }\n         final double[] yDot = new double[y0.length];\n         final double[] yTmp = new double[y0.length];\n+        final double[] predictedScaled = new double[y0.length];\n+        Array2DRowRealMatrix nordsieckTmp = null;\n \n         // set up two interpolators sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n         interpolator.reinitialize(y, forward);\n-        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n-        interpolatorTmp.reinitialize(yTmp, forward);\n \n         // set up integration control objects\n         for (StepHandler handler : stepHandlers) {\n             handler.reset();\n         }\n-        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n-\n+        statesInitialized = false;\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n         start(t0, y, t);\n         double hNew = stepSize;\n         interpolator.rescale(hNew);\n \n-        boolean lastStep = false;\n-        while (!lastStep) {\n-\n-            // shift all data\n-            interpolator.shift();\n-\n-            double error = 0;\n-            for (boolean loop = true; loop;) {\n+        isLastStep = false;\n+        do {\n+\n+            double error = 10;\n+            while (error >= 1.0) {\n \n                 stepSize = hNew;\n \n                 computeDerivatives(stepEnd, yTmp, yDot);\n \n                 // update Nordsieck vector\n-                final double[] predictedScaled = new double[y0.length];\n                 for (int j = 0; j < y0.length; ++j) {\n                     predictedScaled[j] = stepSize * yDot[j];\n                 }\n-                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+                nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                 updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n \n                 // apply correction (C in the PECE sequence)\n                 error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n \n-                if (error <= 1.0) {\n-\n-                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n-                    computeDerivatives(stepEnd, yTmp, yDot);\n-\n-                    // update Nordsieck vector\n-                    final double[] correctedScaled = new double[y0.length];\n-                    for (int j = 0; j < y0.length; ++j) {\n-                        correctedScaled[j] = stepSize * yDot[j];\n-                    }\n-                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n-\n-                    // discrete events handling\n-                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n-                    interpolatorTmp.storeTime(stepStart);\n-                    interpolatorTmp.shift();\n-                    interpolatorTmp.storeTime(stepEnd);\n-                    if (manager.evaluateStep(interpolatorTmp)) {\n-                        final double dt = manager.getEventTime() - stepStart;\n-                        if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n-                            // we cannot simply truncate the step, reject the current computation\n-                            // and let the loop compute another state with the truncated step.\n-                            // it is so small (much probably exactly 0 due to limited accuracy)\n-                            // that the code above would fail handling it.\n-                            // So we set up an artificial 0 size step by copying states\n-                            interpolator.storeTime(stepStart);\n-                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                            hNew     = 0;\n-                            stepSize = 0;\n-                            loop     = false;\n-                        } else {\n-                            // reject the step to match exactly the next switch time\n-                            hNew = dt;\n-                            interpolator.rescale(hNew);\n-                        }\n-                    } else {\n-                        // accept the step\n-                        scaled    = correctedScaled;\n-                        nordsieck = nordsieckTmp;\n-                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n-                        loop = false;\n-                    }\n-\n-                } else {\n+                if (error >= 1.0) {\n                     // reject the step and attempt to reduce error by stepsize control\n                     final double factor = computeStepGrowShrinkFactor(error);\n                     hNew = filterStep(stepSize * factor, forward, false);\n                     interpolator.rescale(hNew);\n                 }\n-\n             }\n \n-            // the step has been accepted (may have been truncated)\n-            final double nextStep = stepStart + stepSize;\n+            // evaluate a final estimate of the derivative (second E in the PECE sequence)\n+            final double stepEnd = stepStart + stepSize;\n+            computeDerivatives(stepEnd, yTmp, yDot);\n+\n+            // update Nordsieck vector\n+            final double[] correctedScaled = new double[y0.length];\n+            for (int j = 0; j < y0.length; ++j) {\n+                correctedScaled[j] = stepSize * yDot[j];\n+            }\n+            updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n+\n+            // discrete events handling\n             System.arraycopy(yTmp, 0, y, 0, n);\n-            interpolator.storeTime(nextStep);\n-            manager.stepAccepted(nextStep, y);\n-            lastStep = manager.stop();\n-\n-            // provide the step data to the step handler\n-            for (StepHandler handler : stepHandlers) {\n-                interpolator.setInterpolatedTime(nextStep);\n-                handler.handleStep(interpolator, lastStep);\n-            }\n-            stepStart = nextStep;\n-\n-            if (!lastStep && manager.reset(stepStart, y)) {\n-\n-                // some events handler has triggered changes that\n-                // invalidate the derivatives, we need to restart from scratch\n-                start(stepStart, y, t);\n-                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n-\n-            }\n-\n-            if (! lastStep) {\n-                // in some rare cases we may get here with stepSize = 0, for example\n-                // when an event occurs at integration start, reducing the first step\n-                // to zero; we have to reset the step to some safe non zero value\n-                stepSize = filterStep(stepSize, forward, true);\n+            interpolator.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n+            interpolator.storeTime(stepStart);\n+            interpolator.shift();\n+            interpolator.storeTime(stepEnd);\n+            stepStart = acceptStep(interpolator, stepHandlers, y, yDot, t);\n+            scaled    = correctedScaled;\n+            nordsieck = nordsieckTmp;\n+\n+            if (!isLastStep) {\n+\n+                // prepare next step\n+                interpolator.storeTime(stepStart);\n+\n+                if (resetOccurred) {\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    start(stepStart, y, t);\n+                    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+\n+                }\n \n                 // stepsize control for next step\n                 final double  factor     = computeStepGrowShrinkFactor(error);\n                 final double  nextT      = stepStart + scaledH;\n                 final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                 hNew = filterStep(scaledH, forward, nextIsLast);\n+\n+                final double  filteredNextT      = stepStart + hNew;\n+                final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n+                if (filteredNextIsLast) {\n+                    hNew = t - stepStart;\n+                }\n+\n                 interpolator.rescale(hNew);\n             }\n \n-        }\n+        } while (!isLastStep);\n \n         final double stopTime  = stepStart;\n         stepStart = Double.NaN;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n     double s;\n     final double[] yTmp = new double[currentState.length];\n+    final double pT = getGlobalPreviousTime();\n \n     // k14\n     for (int j = 0; j < currentState.length; ++j) {\n           K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\n+    integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n \n     // k15\n     for (int j = 0; j < currentState.length; ++j) {\n          K15_14 * yDotKLast[0][j];\n      yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\n+    integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n \n     // k16\n     for (int j = 0; j < currentState.length; ++j) {\n           K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n+    integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n \n   }\n \n       // save the local attributes\n       finalizeStep();\n     } catch (MathUserException e) {\n-      throw MathRuntimeException.createIOException(e);\n+        IOException ioe = new IOException(e.getLocalizedMessage());\n+        ioe.initCause(e);\n+        throw ioe;\n     }\n     final int dimension = (currentState == null) ? -1 : currentState.length;\n     out.writeInt(dimension);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n       System.arraycopy(y0, 0, y, 0, y0.length);\n     }\n     final double[][] yDotK = new double[stages][y0.length];\n-    final double[] yTmp = new double[y0.length];\n+    final double[] yTmp    = new double[y0.length];\n+    final double[] yDotTmp = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+    if (requiresDenseOutput() || (! eventsStates.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n-    boolean lastStep = false;\n+    statesInitialized = false;\n \n     // main integration loop\n-    while (!lastStep) {\n+    isLastStep = false;\n+    do {\n \n       interpolator.shift();\n \n-      double error = 0;\n-      for (boolean loop = true; loop;) {\n+      // iterate over step size, ensuring local normalized error is smaller than 1\n+      double error = 10;\n+      while (error >= 1.0) {\n \n         if (firstTime || !fsal) {\n           // first stage\n               for (int i = 0; i < scale.length; ++i) {\n                 scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n               }\n-            } else {\n+          } else {\n               for (int i = 0; i < scale.length; ++i) {\n                 scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n               }\n-            }\n+          }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n \n         // estimate the error at the end of the step\n         error = estimateError(yDotK, y, yTmp, stepSize);\n-        if (error <= 1.0) {\n-\n-          // discrete events handling\n-          interpolator.storeTime(stepStart + stepSize);\n-          if (manager.evaluateStep(interpolator)) {\n-              final double dt = manager.getEventTime() - stepStart;\n-              if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n-                  // we cannot simply truncate the step, reject the current computation\n-                  // and let the loop compute another state with the truncated step.\n-                  // it is so small (much probably exactly 0 due to limited accuracy)\n-                  // that the code above would fail handling it.\n-                  // So we set up an artificial 0 size step by copying states\n-                  interpolator.storeTime(stepStart);\n-                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                  hNew     = 0;\n-                  stepSize = 0;\n-                  loop     = false;\n-              } else {\n-                  // reject the step to match exactly the next switch time\n-                  hNew = dt;\n-              }\n-          } else {\n-            // accept the step\n-            loop = false;\n-          }\n-\n-        } else {\n+        if (error >= 1.0) {\n           // reject the step and attempt to reduce error by stepsize control\n           final double factor =\n               FastMath.min(maxGrowth,\n-                       FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n           hNew = filterStep(stepSize * factor, forward, false);\n         }\n \n       }\n \n-      // the step has been accepted\n-      final double nextStep = stepStart + stepSize;\n+      // local error is small enough: accept the step, trigger events and step handlers\n+      interpolator.storeTime(stepStart + stepSize);\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      manager.stepAccepted(nextStep, y);\n-      lastStep = manager.stop();\n-\n-      // provide the step data to the step handler\n-      interpolator.storeTime(nextStep);\n-      for (StepHandler handler : stepHandlers) {\n-          handler.handleStep(interpolator, lastStep);\n+      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n+      stepStart = acceptStep(interpolator, stepHandlers, y, yDotTmp, t);\n+\n+      if (!isLastStep) {\n+\n+          // prepare next step\n+          interpolator.storeTime(stepStart);\n+\n+          if (fsal) {\n+              // save the last evaluation for the next step\n+              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+          }\n+\n+          // stepsize control for next step\n+          final double factor =\n+              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+          final double  scaledH    = stepSize * factor;\n+          final double  nextT      = stepStart + scaledH;\n+          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+          hNew = filterStep(scaledH, forward, nextIsLast);\n+\n+          final double  filteredNextT      = stepStart + hNew;\n+          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n+          if (filteredNextIsLast) {\n+              hNew = t - stepStart;\n+          }\n+\n       }\n-      stepStart = nextStep;\n-\n-      if (fsal) {\n-        // save the last evaluation for the next step\n-        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n-      }\n-\n-      if (manager.reset(stepStart, y) && ! lastStep) {\n-        // some event handler has triggered changes that\n-        // invalidate the derivatives, we need to recompute them\n-        computeDerivatives(stepStart, y, yDotK[0]);\n-      }\n-\n-      if (! lastStep) {\n-        // in some rare cases we may get here with stepSize = 0, for example\n-        // when an event occurs at integration start, reducing the first step\n-        // to zero; we have to reset the step to some safe non zero value\n-          stepSize = filterStep(stepSize, forward, true);\n-\n-        // stepsize control for next step\n-        final double factor = FastMath.min(maxGrowth,\n-                                       FastMath.max(minReduction,\n-                                                safety * FastMath.pow(error, exp)));\n-        final double  scaledH    = stepSize * factor;\n-        final double  nextT      = stepStart + scaledH;\n-        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n-        hNew = filterStep(scaledH, forward, nextIsLast);\n-      }\n-\n-    }\n+\n+    } while (!isLastStep);\n \n     final double stopTime = stepStart;\n     resetInternalState();\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n                                       final double scalRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           scalAbsoluteTolerance, scalRelativeTolerance);\n-    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n                                       final double[] vecRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           vecAbsoluteTolerance, vecRelativeTolerance);\n-    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n   public void addStepHandler (final StepHandler handler) {\n \n     super.addStepHandler(handler);\n-    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n                               final double convergence,\n                               final int maxIterationCount) {\n     super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n-    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n   @Override\n   public double integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0, final double t, final double[] y)\n-  throws MathUserException, IntegratorException {\n+      throws MathUserException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n       System.arraycopy(y0, 0, y, 0, y0.length);\n     }\n \n-    double[] yDot1      = null;\n+    double[] yDot1      = new double[y0.length];\n     double[][] yMidDots = null;\n     if (denseOutput) {\n-      yDot1    = new double[y0.length];\n       yMidDots = new double[1 + 2 * sequence.length][];\n       for (int j = 0; j < yMidDots.length; ++j) {\n         yMidDots[j] = new double[y0.length];\n     // initial order selection\n     final double tol =\n         (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n-    final double log10R = FastMath.log(FastMath.max(1.0e-10, tol)) / FastMath.log(10.0);\n+    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n     int targetIter = FastMath.max(1,\n                               FastMath.min(sequence.length - 2,\n                                        (int) FastMath.floor(0.5 - 0.6 * log10R)));\n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator = null;\n-    if (denseOutput || (! eventsHandlersManager.isEmpty())) {\n+    if (denseOutput || (! eventsStates.isEmpty())) {\n       interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                             y1, yDot1,\n                                                             yMidDots, forward);\n     boolean previousRejected = false;\n     boolean firstTime        = true;\n     boolean newStep          = true;\n-    boolean lastStep         = false;\n     boolean firstStepAlreadyComputed = false;\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n+    statesInitialized = false;\n     costPerTimeUnit[0] = 0;\n-    while (! lastStep) {\n+    isLastStep = false;\n+    do {\n \n       double error;\n       boolean reject = false;\n         }\n \n         if (firstTime) {\n-\n           hNew = initializeStep(equations, forward,\n                                 2 * targetIter + 1, scale,\n                                 stepStart, y, yDot0, yTmp, yTmpDot);\n-\n-          if (! forward) {\n-            hNew = -hNew;\n-          }\n-\n         }\n \n         newStep = false;\n         stepSize = t - stepStart;\n       }\n       final double nextT = stepStart + stepSize;\n-      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n \n       // iterate over several substep sizes\n       int k = -1;\n                 break;\n \n               default :\n-                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                   loop = false;\n                 }\n                 break;\n         }\n       }\n \n+      if (! reject) {\n+          // derivatives at end of step\n+          computeDerivatives(stepStart + stepSize, y1, yDot1);\n+      }\n+\n       // dense output handling\n       double hInt = getMaxStep();\n       if (denseOutput && ! reject) {\n         for (int j = 1; j <= k; ++j) {\n           extrapolate(0, j, diagonal, yMidDots[0]);\n         }\n-\n-        // derivative at end of step\n-        computeDerivatives(stepStart + stepSize, y1, yDot1);\n \n         final int mu = 2 * k - mudif + 3;\n \n             }\n           }\n \n-          // Discrete events handling\n-          if (!reject) {\n-            interpolator.storeTime(stepStart + stepSize);\n-            if (eventsHandlersManager.evaluateStep(interpolator)) {\n-                final double dt = eventsHandlersManager.getEventTime() - stepStart;\n-                if (FastMath.abs(dt) > FastMath.ulp(stepStart)) {\n-                    // reject the step to match exactly the next switch time\n-                    hNew = FastMath.abs(dt);\n-                    reject = true;\n-                }\n-            }\n-          }\n-\n-        }\n-\n-        if (!reject) {\n-          // we will reuse the slope for the beginning of next step\n-          firstStepAlreadyComputed = true;\n-          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n         }\n \n       }\n \n       if (! reject) {\n \n-        // store end of step state\n-        final double nextStep = stepStart + stepSize;\n+        // Discrete events handling\n+        interpolator.storeTime(stepStart + stepSize);\n+        stepStart = acceptStep(interpolator, stepHandlers, y1, yDot1, t);\n+\n+        // prepare next step\n+        interpolator.storeTime(stepStart);\n         System.arraycopy(y1, 0, y, 0, y0.length);\n-\n-        eventsHandlersManager.stepAccepted(nextStep, y);\n-        if (eventsHandlersManager.stop()) {\n-          lastStep = true;\n-        }\n-\n-        // provide the step data to the step handler\n-        interpolator.storeTime(nextStep);\n-        for (StepHandler handler : stepHandlers) {\n-            handler.handleStep(interpolator, lastStep);\n-        }\n-        stepStart = nextStep;\n-\n-        if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n-          // some switching function has triggered changes that\n-          // invalidate the derivatives, we need to recompute them\n-          firstStepAlreadyComputed = false;\n-        }\n+        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        firstStepAlreadyComputed = true;\n \n         int optimalIter;\n         if (k == 1) {\n       firstTime = false;\n \n       if (reject) {\n-        lastStep = false;\n+        isLastStep = false;\n         previousRejected = true;\n       } else {\n         previousRejected = false;\n       }\n \n-    }\n-\n-    return stepStart;\n+    } while (!isLastStep);\n+\n+    final double stopTime = stepStart;\n+    resetInternalState();\n+    return stopTime;\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n   /** {@inheritDoc} */\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n-                                          final double oneMinusThetaH)\n-    throws MathUserException {\n+                                          final double oneMinusThetaH) {\n \n     final int dimension = currentState.length;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n     for (int i = 0; i < stages; ++i) {\n       yDotK [i] = new double[y0.length];\n     }\n-    final double[] yTmp = new double[y0.length];\n+    final double[] yTmp    = new double[y0.length];\n+    final double[] yDotTmp = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+    if (requiresDenseOutput() || (! eventsStates.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n     }\n-    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n-    boolean lastStep = false;\n+    statesInitialized = false;\n \n     // main integration loop\n-    while (!lastStep) {\n+    isLastStep = false;\n+    do {\n \n       interpolator.shift();\n \n-      for (boolean loop = true; loop;) {\n+      // first stage\n+      computeDerivatives(stepStart, y, yDotK[0]);\n \n-        // first stage\n-        computeDerivatives(stepStart, y, yDotK[0]);\n-\n-        // next stages\n-        for (int k = 1; k < stages; ++k) {\n+      // next stages\n+      for (int k = 1; k < stages; ++k) {\n \n           for (int j = 0; j < y0.length; ++j) {\n-            double sum = a[k-1][0] * yDotK[0][j];\n-            for (int l = 1; l < k; ++l) {\n-              sum += a[k-1][l] * yDotK[l][j];\n-            }\n-            yTmp[j] = y[j] + stepSize * sum;\n+              double sum = a[k-1][0] * yDotK[0][j];\n+              for (int l = 1; l < k; ++l) {\n+                  sum += a[k-1][l] * yDotK[l][j];\n+              }\n+              yTmp[j] = y[j] + stepSize * sum;\n           }\n \n           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n \n-        }\n+      }\n \n-        // estimate the state at the end of the step\n-        for (int j = 0; j < y0.length; ++j) {\n+      // estimate the state at the end of the step\n+      for (int j = 0; j < y0.length; ++j) {\n           double sum    = b[0] * yDotK[0][j];\n           for (int l = 1; l < stages; ++l) {\n-            sum    += b[l] * yDotK[l][j];\n+              sum    += b[l] * yDotK[l][j];\n           }\n           yTmp[j] = y[j] + stepSize * sum;\n-        }\n-\n-        // discrete events handling\n-        interpolator.storeTime(stepStart + stepSize);\n-        if (manager.evaluateStep(interpolator)) {\n-            final double dt = manager.getEventTime() - stepStart;\n-            if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n-                // we cannot simply truncate the step, reject the current computation\n-                // and let the loop compute another state with the truncated step.\n-                // it is so small (much probably exactly 0 due to limited accuracy)\n-                // that the code above would fail handling it.\n-                // So we set up an artificial 0 size step by copying states\n-                interpolator.storeTime(stepStart);\n-                System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                stepSize = 0;\n-                loop     = false;\n-            } else {\n-                // reject the step to match exactly the next switch time\n-                stepSize = dt;\n-            }\n-        } else {\n-          loop = false;\n-        }\n-\n       }\n \n-      // the step has been accepted\n-      final double nextStep = stepStart + stepSize;\n+      // discrete events handling\n+      interpolator.storeTime(stepStart + stepSize);\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      manager.stepAccepted(nextStep, y);\n-      lastStep = manager.stop();\n+      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n+      stepStart = acceptStep(interpolator, stepHandlers, y, yDotTmp, t);\n \n-      // provide the step data to the step handler\n-      interpolator.storeTime(nextStep);\n-      for (StepHandler handler : stepHandlers) {\n-          handler.handleStep(interpolator, lastStep);\n-      }\n-      stepStart = nextStep;\n+      if (!isLastStep) {\n \n-      if (manager.reset(stepStart, y) && ! lastStep) {\n-        // some events handler has triggered changes that\n-        // invalidate the derivatives, we need to recompute them\n-        computeDerivatives(stepStart, y, yDotK[0]);\n+          // prepare next step\n+          interpolator.storeTime(stepStart);\n+\n+          // stepsize control for next step\n+          final double  nextT      = stepStart + stepSize;\n+          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+          if (nextIsLast) {\n+              stepSize = t - stepStart;\n+          }\n       }\n \n-      // make sure step size is set to default before next step\n-      stepSize = forward ? step : -step;\n-\n-    }\n+    } while (!isLastStep);\n \n     final double stopTime = stepStart;\n     stepStart = Double.NaN;\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.MathUserException;\n \n /** This abstract class represents an interpolator over the last step\n public abstract class AbstractStepInterpolator\n   implements StepInterpolator {\n \n-  /** previous time */\n-  protected double previousTime;\n-\n-  /** current time */\n-  protected double currentTime;\n+  /** global previous time */\n+  private double globalPreviousTime;\n+\n+  /** global current time */\n+  private double globalCurrentTime;\n+\n+  /** soft previous time */\n+  private double softPreviousTime;\n+\n+  /** soft current time */\n+  private double softCurrentTime;\n \n   /** current time step */\n   protected double h;\n    * initializing the copy.\n    */\n   protected AbstractStepInterpolator() {\n-    previousTime            = Double.NaN;\n-    currentTime             = Double.NaN;\n+    globalPreviousTime      = Double.NaN;\n+    globalCurrentTime       = Double.NaN;\n+    softPreviousTime        = Double.NaN;\n+    softCurrentTime         = Double.NaN;\n     h                       = Double.NaN;\n     interpolatedTime        = Double.NaN;\n     currentState            = null;\n    */\n   protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n \n-    previousTime      = Double.NaN;\n-    currentTime       = Double.NaN;\n-    h                 = Double.NaN;\n-    interpolatedTime  = Double.NaN;\n+    globalPreviousTime = Double.NaN;\n+    globalCurrentTime  = Double.NaN;\n+    softPreviousTime   = Double.NaN;\n+    softCurrentTime    = Double.NaN;\n+    h                  = Double.NaN;\n+    interpolatedTime   = Double.NaN;\n \n     currentState            = y;\n     interpolatedState       = new double[y.length];\n    */\n   protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n \n-    previousTime      = interpolator.previousTime;\n-    currentTime       = interpolator.currentTime;\n-    h                 = interpolator.h;\n-    interpolatedTime  = interpolator.interpolatedTime;\n+    globalPreviousTime = interpolator.globalPreviousTime;\n+    globalCurrentTime  = interpolator.globalCurrentTime;\n+    softPreviousTime   = interpolator.softPreviousTime;\n+    softCurrentTime    = interpolator.softCurrentTime;\n+    h                  = interpolator.h;\n+    interpolatedTime   = interpolator.interpolatedTime;\n \n     if (interpolator.currentState != null) {\n       currentState            = interpolator.currentState.clone();\n    */\n   protected void reinitialize(final double[] y, final boolean isForward) {\n \n-    previousTime      = Double.NaN;\n-    currentTime       = Double.NaN;\n-    h                 = Double.NaN;\n-    interpolatedTime  = Double.NaN;\n+    globalPreviousTime = Double.NaN;\n+    globalCurrentTime  = Double.NaN;\n+    softPreviousTime   = Double.NaN;\n+    softCurrentTime    = Double.NaN;\n+    h                  = Double.NaN;\n+    interpolatedTime   = Double.NaN;\n \n     currentState            = y;\n     interpolatedState       = new double[y.length];\n    * interpolator for future calls to {@link #storeTime storeTime}\n    */\n   public void shift() {\n-    previousTime = currentTime;\n+    globalPreviousTime = globalCurrentTime;\n+    softPreviousTime   = globalPreviousTime;\n+    softCurrentTime    = globalCurrentTime;\n   }\n \n   /** Store the current step time.\n    */\n   public void storeTime(final double t) {\n \n-    currentTime = t;\n-    h           = currentTime - previousTime;\n+    globalCurrentTime = t;\n+    softCurrentTime   = globalCurrentTime;\n+    h                 = globalCurrentTime - globalPreviousTime;\n     setInterpolatedTime(t);\n \n     // the step is not finalized anymore\n \n   }\n \n-  /** {@inheritDoc} */\n+  /** Restrict step range to a limited part of the global step.\n+   * <p>\n+   * This method can be used to restrict a step and make it appear\n+   * as if the original step was smaller. Calling this method\n+   * <em>only</em> changes the value returned by {@link #getPreviousTime()}\n+   * and {@link #getCurrentTime()}, it does not change any\n+   * </p>\n+   * @param softPreviousTime start of the restricted step\n+   * @param softCurrentTime end of the restricted step\n+   */\n+  public void setSoftBounds(final double softPreviousTime, final double softCurrentTime) {\n+      this.softPreviousTime = softPreviousTime;\n+      this.softCurrentTime  = softCurrentTime;\n+  }\n+\n+  /**\n+   * Get the previous global grid point time.\n+   * @return previous global grid point time\n+   */\n+  public double getGlobalPreviousTime() {\n+    return globalPreviousTime;\n+  }\n+\n+  /**\n+   * Get the current global grid point time.\n+   * @return current global grid point time\n+   */\n+  public double getGlobalCurrentTime() {\n+    return globalCurrentTime;\n+  }\n+\n+  /**\n+   * Get the previous soft grid point time.\n+   * @return previous soft grid point time\n+   * @see #setSoftBounds(double, double)\n+   */\n   public double getPreviousTime() {\n-    return previousTime;\n-  }\n-\n-  /** {@inheritDoc} */\n+    return softPreviousTime;\n+  }\n+\n+  /**\n+   * Get the current soft grid point time.\n+   * @return current soft grid point time\n+   * @see #setSoftBounds(double, double)\n+   */\n   public double getCurrentTime() {\n-    return currentTime;\n+    return softCurrentTime;\n   }\n \n   /** {@inheritDoc} */\n \n       // lazy evaluation of the state\n       if (dirtyState) {\n-          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n           final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n           computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n           dirtyState = false;\n \n       // lazy evaluation of the state\n       if (dirtyState) {\n-          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n           final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n           computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n           dirtyState = false;\n     } else {\n         out.writeInt(currentState.length);\n     }\n-    out.writeDouble(previousTime);\n-    out.writeDouble(currentTime);\n+    out.writeDouble(globalPreviousTime);\n+    out.writeDouble(globalCurrentTime);\n+    out.writeDouble(softPreviousTime);\n+    out.writeDouble(softCurrentTime);\n     out.writeDouble(h);\n     out.writeBoolean(forward);\n \n     try {\n       finalizeStep();\n     } catch (MathUserException e) {\n-      throw MathRuntimeException.createIOException(e);\n+        IOException ioe = new IOException(e.getLocalizedMessage());\n+        ioe.initCause(e);\n+        throw ioe;\n     }\n \n   }\n     throws IOException {\n \n     final int dimension = in.readInt();\n-    previousTime  = in.readDouble();\n-    currentTime   = in.readDouble();\n-    h             = in.readDouble();\n-    forward       = in.readBoolean();\n-    dirtyState    = true;\n+    globalPreviousTime  = in.readDouble();\n+    globalCurrentTime   = in.readDouble();\n+    softPreviousTime    = in.readDouble();\n+    softCurrentTime     = in.readDouble();\n+    h                   = in.readDouble();\n+    forward             = in.readBoolean();\n+    dirtyState          = true;\n \n     if (dimension < 0) {\n         currentState = null;\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n     return new EventHandler[] { new Bounce(), new Stop() };\n   }\n \n+  /**\n+   * Get the theoretical events times.\n+   * @return theoretical events times\n+   */\n+  public double[] getTheoreticalEventsTimes() {\n+      return new double[] {\n+          1 * FastMath.PI - a,\n+          2 * FastMath.PI - a,\n+          3 * FastMath.PI - a,\n+          4 * FastMath.PI - a,\n+          12.0\n+      };\n+  }\n+\n   @Override\n   public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n     yDot[0] =  y[1];\n--- a/src/test/java/org/apache/commons/math/ode/TestProblemAbstract.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemAbstract.java\n   }\n \n   /**\n+   * Get the theoretical events times.\n+   * @return theoretical events times\n+   */\n+  public double[] getTheoreticalEventsTimes() {\n+      return new double[0];\n+  }\n+\n+  /**\n    * Get the number of calls.\n    * @return nuber of calls\n    */\n--- a/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n         // multistep integrators do not handle the first steps themselves\n         // so we have to make sure the integrator we look at has really started its work\n         if (!Double.isNaN(expectedStepStart)) {\n-            maxTimeError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));\n+            // the step should either start at the end of the integrator step\n+            // or at an event if the step is split into several substeps\n+            double stepError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));\n+            for (double eventTime : problem.getTheoreticalEventsTimes()) {\n+                stepError = FastMath.min(stepError, FastMath.abs(start - eventTime));\n+            }\n+            maxTimeError = FastMath.max(maxTimeError, stepError);\n         }\n         expectedStepStart = start + integrator.getCurrentSignedStepsize();\n     }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (nSteps < 4) {\n-                assertTrue(integ.getEvaluations() > 160);\n+                assertTrue(integ.getEvaluations() > 150);\n             } else {\n-                assertTrue(integ.getEvaluations() < 80);\n+                assertTrue(integ.getEvaluations() < 70);\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n-      double previousError = Double.NaN;\n+      double previousValueError = Double.NaN;\n+      double previousTimeError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n         TestProblemAbstract pb = problems[k].copy();\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousValueError));\n         }\n-        previousError = error;\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        previousValueError = error;\n+\n+        double timeError = handler.getMaximalTimeError();\n+        if (i > 4) {\n+          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+        }\n+        previousTimeError = timeError;\n+\n         integ.clearEventHandlers();\n         assertEquals(0, integ.getEventHandlers().size());\n       }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 700000);\n-    assertTrue(bos.size () < 701000);\n+    assertTrue(bos.size () > 753000);\n+    assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n+    double convergence = 1.0e-8 * maxStep;\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+                                 Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n     assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getMaximalValueError() < 5.0e-6);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n     assertEquals(0, integ.getEventHandlers().size());\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 119500);\n-    assertTrue(bos.size () < 120500);\n+    assertTrue(bos.size () > 126000);\n+    assertTrue(bos.size () < 127000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 8.1e-8);\n+      assertTrue(handler.getLastError() < 1.1e-7);\n       assertTrue(handler.getMaximalValueError() < 1.1e-7);\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n+    double convergence = 1.0e-8 * maxStep;\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+                                 Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n     assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertEquals(0, handler.getMaximalValueError(), 1.1e-7);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n     assertEquals(0, integ.getEventHandlers().size());\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 86000);\n-    assertTrue(bos.size () < 87000);\n+    assertTrue(bos.size () > 88000);\n+    assertTrue(bos.size () < 89000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n-      double previousError = Double.NaN;\n-      for (int i = 4; i < 10; ++i) {\n+      double previousValueError = Double.NaN;\n+      double previousTimeError = Double.NaN;\n+      for (int i = 4; i < 8; ++i) {\n \n         TestProblemAbstract pb  = problems[k].copy();\n-        double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * FastMath.pow(2.0, -i);\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new EulerIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n-        double error = handler.getMaximalValueError();\n+        double valueError = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousError));\n+          assertTrue(valueError < FastMath.abs(previousValueError));\n         }\n-        previousError = error;\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        previousValueError = valueError;\n+\n+        double timeError = handler.getMaximalTimeError();\n+        if (i > 4) {\n+          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+        }\n+        previousTimeError = timeError;\n \n       }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n-      double previousError = Double.NaN;\n+      double previousValueError = Double.NaN;\n+      double previousTimeError = Double.NaN;\n       for (int i = 5; i < 10; ++i) {\n \n         TestProblemAbstract pb = problems[k].copy();\n-        double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * FastMath.pow(2.0, -i);\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new GillIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n-        double error = handler.getMaximalValueError();\n+        double valueError = handler.getMaximalValueError();\n         if (i > 5) {\n-          assertTrue(error < FastMath.abs(previousError));\n-        }\n-        previousError = error;\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+          assertTrue(valueError < FastMath.abs(previousValueError));\n+        }\n+        previousValueError = valueError;\n+\n+        double timeError = handler.getMaximalTimeError();\n+        if (i > 5) {\n+          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+        }\n+        previousTimeError = timeError;\n \n       }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 700000);\n-    assertTrue(bos.size () < 701000);\n+    assertTrue(bos.size () > 753000);\n+    assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n       integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n \n-      assertTrue(handler.getLastError() < 9.0e-10);\n-      assertTrue(handler.getMaximalValueError() < 9.0e-10);\n+      assertTrue(handler.getLastError() < 7.5e-9);\n+      assertTrue(handler.getMaximalValueError() < 8.1e-9);\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n   }\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n+    double convergence = 1.0e-8 * maxStep;\n     for (int l = 0; l < functions.length; ++l) {\n-      integ.addEventHandler(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+      integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n     assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getMaximalValueError() < 5.0e-8);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n     assertEquals(0, integ.getEventHandlers().size());\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 33000);\n-    assertTrue(bos.size () < 34000);\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n import org.apache.commons.math.ode.TestProblemHandler;\n import org.apache.commons.math.ode.events.EventException;\n import org.apache.commons.math.ode.events.EventHandler;\n-import org.apache.commons.math.ode.sampling.StepHandler;\n-import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n \n public class HighamHall54IntegratorTest\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n+    double convergence = 1.0e-8 * maxStep;\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+                                 Double.POSITIVE_INFINITY, convergence, 1000);\n     }\n     assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     assertTrue(handler.getMaximalValueError() < 1.0e-7);\n-    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    assertEquals(0, handler.getMaximalTimeError(), convergence);\n+    assertEquals(12.0, handler.getLastTime(), convergence);\n     integ.clearEventHandlers();\n     assertEquals(0, integ.getEventHandlers().size());\n \n     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                             vecAbsoluteTolerance,\n                                                             vecRelativeTolerance);\n-    integ.addStepHandler(new KeplerHandler(pb));\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ); \n+    integ.addStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4);\n     assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n   }\n \n-  private static class KeplerHandler implements StepHandler {\n-    public KeplerHandler(TestProblem3 pb) {\n-      this.pb = pb;\n-      nbSteps = 0;\n-      maxError = 0;\n-    }\n-    public boolean requiresDenseOutput() {\n-      return false;\n-    }\n-    public void reset() {\n-      nbSteps = 0;\n-      maxError = 0;\n-    }\n-    public void handleStep(StepInterpolator interpolator,\n-                           boolean isLast) throws MathUserException {\n-\n-      ++nbSteps;\n-      double[] interpolatedY = interpolator.getInterpolatedState();\n-      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n-      double dx = interpolatedY[0] - theoreticalY[0];\n-      double dy = interpolatedY[1] - theoreticalY[1];\n-      double error = dx * dx + dy * dy;\n-      if (error > maxError) {\n-        maxError = error;\n-      }\n-      if (isLast) {\n-        assertTrue(maxError < 4.2e-11);\n-        assertTrue(nbSteps < 670);\n-      }\n-    }\n-    private TestProblem3 pb;\n-    private int nbSteps;\n-    private double maxError;\n-  }\n-\n }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 158000);\n-    assertTrue(bos.size () < 159000);\n+    assertTrue(bos.size () > 167000);\n+    assertTrue(bos.size () < 168000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n-      double previousError = Double.NaN;\n+      double previousValueError = Double.NaN;\n+      double previousTimeError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n         TestProblemAbstract pb = problems[k].copy();\n-        double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * FastMath.pow(2.0, -i);\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);\n         FirstOrderIntegrator integ = new MidpointIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n             assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n         }\n \n-        double error = handler.getMaximalValueError();\n+        double valueError = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousError));\n+          assertTrue(valueError < FastMath.abs(previousValueError));\n         }\n-        previousError = error;\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        previousValueError = valueError;\n+\n+        double timeError = handler.getMaximalTimeError();\n+        if (i > 4) {\n+          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+        }\n+        previousTimeError = timeError;\n \n       }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 98000);\n-    assertTrue(bos.size () < 99000);\n+    assertTrue(bos.size () > 114000);\n+    assertTrue(bos.size () < 115000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n-      double previousError = Double.NaN;\n+      double previousValueError = Double.NaN;\n+      double previousTimeError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n         TestProblemAbstract pb = problems[k].copy();\n-        double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * FastMath.pow(2.0, -i);\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < FastMath.abs(previousError));\n-        }\n-        previousError = error;\n-        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+          assertTrue(error < FastMath.abs(previousValueError));\n+        }\n+        previousValueError = error;\n+\n+        double timeError = handler.getMaximalTimeError();\n+        if (i > 4) {\n+          assertTrue(timeError <= FastMath.abs(previousTimeError));\n+        }\n+        previousTimeError = timeError;\n \n       }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    assertTrue(bos.size () > 700000);\n-    assertTrue(bos.size () < 701000);\n+    assertTrue(bos.size () > 753000);\n+    assertTrue(bos.size () < 754000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n     oos.writeObject(interpolator);\n \n-    assertTrue(bos.size () > 150);\n-    assertTrue(bos.size () < 250);\n+    assertTrue(bos.size () > 200);\n+    assertTrue(bos.size () < 300);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n     throws MathUserException, IntegratorException {\n         TestProblem3 pb = new TestProblem3();\n         AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);\n-        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);\n+        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 5e-9);\n     }\n \n     @Test\n             oos.writeObject(handler);\n         }\n \n-        assertTrue(bos.size () >  20000);\n-        assertTrue(bos.size () <  25000);\n+        assertTrue(bos.size () >  25500);\n+        assertTrue(bos.size () <  26500);\n \n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);", "timestamp": 1295557031, "metainfo": ""}