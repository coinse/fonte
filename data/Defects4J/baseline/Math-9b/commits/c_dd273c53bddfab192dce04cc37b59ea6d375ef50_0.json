{"sha": "dd273c53bddfab192dce04cc37b59ea6d375ef50", "log": "Tab police  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n             if (reference != null) {\n                 assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-            \tassertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n         try {\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             if (reference != null) {\n-            \t assertEquals(new BlockRealMatrix(reference), sub);\n+                assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n         try {\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n             if (reference != null) {\n-            \tassertEquals(new BlockRealMatrix(reference), sub);\n+                assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                              new double[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                     new double[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-            \tassertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n     public void testMathpbx02() {\n \n         double[] mainTridiagonal = {\n-        \t  7484.860960227216, 18405.28129035345, 13855.225609560746,\n-        \t 10016.708722343366, 559.8117399576674, 6750.190788301587, \n-        \t    71.21428769782159\n+              7484.860960227216, 18405.28129035345, 13855.225609560746,\n+             10016.708722343366, 559.8117399576674, 6750.190788301587, \n+                71.21428769782159\n         };\n         double[] secondaryTridiagonal = {\n-        \t -4175.088570476366,1975.7955858241994,5193.178422374075, \n-        \t  1995.286659169179,75.34535882933804,-234.0808002076056\n+             -4175.088570476366,1975.7955858241994,5193.178422374075, \n+              1995.286659169179,75.34535882933804,-234.0808002076056\n         };\n \n         // the reference values have been computed using routine DSTEMR\n         // from the fortran library LAPACK version 3.2.1\n         double[] refEigenValues = {\n-        \t\t20654.744890306974412,16828.208208485466457,\n-        \t\t6893.155912634994820,6757.083016675340332,\n-        \t\t5887.799885688558788,64.309089923240379,\n-        \t\t57.992628792736340\n+                20654.744890306974412,16828.208208485466457,\n+                6893.155912634994820,6757.083016675340332,\n+                5887.799885688558788,64.309089923240379,\n+                57.992628792736340\n         };\n         RealVector[] refEigenVectors = {\n-        \t\tnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n-        \t\tnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n-        \t\tnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n-        \t\tnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n-        \t\tnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n-        \t\tnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n-        \t\tnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n+                new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n+                new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n+                new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n+                new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n+                new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n+                new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n+                new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n         };\n \n         // the following line triggers the exception\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             if (reference != null) {\n-            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n             if (reference != null) {\n-            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n+                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             if (reference != null) {\n-            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             if (reference != null) {\n-            \tassertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n+                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-            \tfail(\"Expecting MatrixIndexException\");\n+                fail(\"Expecting MatrixIndexException\");\n             }\n         } catch (MatrixIndexException e) {\n             if (reference != null) {\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n   }\n \n   private static class BadStepInterpolator extends DummyStepInterpolator {\n-\t  @SuppressWarnings(\"unused\")\n-\t  public BadStepInterpolator() {\n-\t  }\n-\t  public BadStepInterpolator(double[] y, boolean forward) {\n-\t\t  super(y, forward);\n-\t  }\n-\t  @Override\n-\t  protected void doFinalize()\n-\t  throws DerivativeException {\n+      @SuppressWarnings(\"unused\")\n+      public BadStepInterpolator() {\n+      }\n+      public BadStepInterpolator(double[] y, boolean forward) {\n+          super(y, forward);\n+      }\n+      @Override\n+      protected void doFinalize()\n+      throws DerivativeException {\n           throw new DerivativeException(null);\n       }\n   }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n \n public class RandomDataTest extends RetryTestCase {\n \n-\tpublic RandomDataTest(String name) {\n-\t\tsuper(name);\n-\t\trandomData = new RandomDataImpl();\n-\t}\n-\n-\tprotected long smallSampleSize = 1000;\n-\tprotected double[] expected = { 250, 250, 250, 250 };\n-\tprotected int largeSampleSize = 10000;\n-\tprivate String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n-\t\t\t\"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n-\tprotected RandomDataImpl randomData = null;\n-\tprotected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n-\n-\tpublic static Test suite() {\n-\t\tTestSuite suite = new TestSuite(RandomDataTest.class);\n-\t\tsuite.setName(\"RandomData Tests\");\n-\t\treturn suite;\n-\t}\n-\n-\tpublic void testNextIntExtremeValues() {\n-\t\tint x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-\t\tint y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-\t\tassertFalse(x == y);\n-\t}\n-\n-\tpublic void testNextLongExtremeValues() {\n-\t\tlong x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n-\t\tlong y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n-\t\tassertFalse(x == y);\n-\t}\n-\n-\t/** test dispersion and failure modes for nextInt() */\n-\tpublic void testNextInt() {\n-\t\ttry {\n-\t\t\trandomData.nextInt(4, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tFrequency freq = new Frequency();\n-\t\tint value = 0;\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\tvalue = randomData.nextInt(0, 3);\n-\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n-\t\t\tfreq.addValue(value);\n-\t\t}\n-\t\tlong[] observed = new long[4];\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tobserved[i] = freq.getCount(i);\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n-\t}\n-\n-\t/** test dispersion and failure modes for nextLong() */\n-\tpublic void testNextLong() {\n-\t\ttry {\n-\t\t\trandomData.nextLong(4, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tFrequency freq = new Frequency();\n-\t\tlong value = 0;\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\tvalue = randomData.nextLong(0, 3);\n-\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n-\t\t\tfreq.addValue(value);\n-\t\t}\n-\t\tlong[] observed = new long[4];\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tobserved[i] = freq.getCount(i);\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n-\t}\n-\n-\t/** test dispersion and failure modes for nextSecureLong() */\n-\tpublic void testNextSecureLong() {\n-\t\ttry {\n-\t\t\trandomData.nextSecureLong(4, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tFrequency freq = new Frequency();\n-\t\tlong value = 0;\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\tvalue = randomData.nextSecureLong(0, 3);\n-\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n-\t\t\tfreq.addValue(value);\n-\t\t}\n-\t\tlong[] observed = new long[4];\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tobserved[i] = freq.getCount(i);\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n-\t}\n-\n-\t/** test dispersion and failure modes for nextSecureInt() */\n-\tpublic void testNextSecureInt() {\n-\t\ttry {\n-\t\t\trandomData.nextSecureInt(4, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tFrequency freq = new Frequency();\n-\t\tint value = 0;\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\tvalue = randomData.nextSecureInt(0, 3);\n-\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n-\t\t\tfreq.addValue(value);\n-\t\t}\n-\t\tlong[] observed = new long[4];\n-\t\tfor (int i = 0; i < 4; i++) {\n-\t\t\tobserved[i] = freq.getCount(i);\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n-\t}\n-\n-\t/**\n-\t * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n-\t * 5) close to actual cumulative Poisson probablity and that nextPoisson\n-\t * fails when mean is non-positive TODO: replace with statistical test,\n-\t * adding test stat to TestStatistic\n-\t */\n-\tpublic void testNextPoisson() {\n-\t\ttry {\n-\t\t\trandomData.nextPoisson(0);\n-\t\t\tfail(\"zero mean -- expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tFrequency f = new Frequency();\n-\t\tfor (int i = 0; i < largeSampleSize; i++) {\n-\t\t\ttry {\n-\t\t\t\tf.addValue(randomData.nextPoisson(4.0d));\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\tfail(ex.getMessage());\n-\t\t\t}\n-\t\t}\n-\t\tlong cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)\n-\t\t\t\t+ f.getCount(3) + f.getCount(4) + f.getCount(5);\n-\t\tlong sumFreq = f.getSumFreq();\n-\t\tdouble cumPct = Double.valueOf(cumFreq).doubleValue()\n-\t\t\t\t/ Double.valueOf(sumFreq).doubleValue();\n-\t\tassertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n-\t\ttry {\n-\t\t\trandomData.nextPoisson(-1);\n-\t\t\tfail(\"negative mean supplied -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\ttry {\n-\t\t\trandomData.nextPoisson(0);\n-\t\t\tfail(\"0 mean supplied -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\n-\t}\n-\t\n-\tpublic void testNextPoissonConsistency() throws Exception {\n-\t    // Small integral means\n-\t    for (int i = 1; i < 100; i++) {\n-\t        checkNextPoissonConsistency(i);\n-\t    }\n-\t    // non-integer means\n-\t    RandomData randomData = new RandomDataImpl();\n-\t    for (int i = 1; i < 10; i++) {\n-\t        checkNextPoissonConsistency(randomData.nextUniform(1, 1000));\n-\t    }\n-\t    // large means \n-\t    // TODO: When MATH-282 is resolved, s/3000/10000 below\n-\t    for (int i = 1; i < 10; i++) {\n+    public RandomDataTest(String name) {\n+        super(name);\n+        randomData = new RandomDataImpl();\n+    }\n+\n+    protected long smallSampleSize = 1000;\n+    protected double[] expected = { 250, 250, 250, 250 };\n+    protected int largeSampleSize = 10000;\n+    private String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n+            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n+    protected RandomDataImpl randomData = null;\n+    protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomDataTest.class);\n+        suite.setName(\"RandomData Tests\");\n+        return suite;\n+    }\n+\n+    public void testNextIntExtremeValues() {\n+        int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        assertFalse(x == y);\n+    }\n+\n+    public void testNextLongExtremeValues() {\n+        long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+        long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+        assertFalse(x == y);\n+    }\n+\n+    /** test dispersion and failure modes for nextInt() */\n+    public void testNextInt() {\n+        try {\n+            randomData.nextInt(4, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency freq = new Frequency();\n+        int value = 0;\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            value = randomData.nextInt(0, 3);\n+            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            freq.addValue(value);\n+        }\n+        long[] observed = new long[4];\n+        for (int i = 0; i < 4; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 16.27);\n+    }\n+\n+    /** test dispersion and failure modes for nextLong() */\n+    public void testNextLong() {\n+        try {\n+            randomData.nextLong(4, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency freq = new Frequency();\n+        long value = 0;\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            value = randomData.nextLong(0, 3);\n+            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            freq.addValue(value);\n+        }\n+        long[] observed = new long[4];\n+        for (int i = 0; i < 4; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 16.27);\n+    }\n+\n+    /** test dispersion and failure modes for nextSecureLong() */\n+    public void testNextSecureLong() {\n+        try {\n+            randomData.nextSecureLong(4, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency freq = new Frequency();\n+        long value = 0;\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            value = randomData.nextSecureLong(0, 3);\n+            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            freq.addValue(value);\n+        }\n+        long[] observed = new long[4];\n+        for (int i = 0; i < 4; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 16.27);\n+    }\n+\n+    /** test dispersion and failure modes for nextSecureInt() */\n+    public void testNextSecureInt() {\n+        try {\n+            randomData.nextSecureInt(4, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency freq = new Frequency();\n+        int value = 0;\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            value = randomData.nextSecureInt(0, 3);\n+            assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            freq.addValue(value);\n+        }\n+        long[] observed = new long[4];\n+        for (int i = 0; i < 4; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 16.27);\n+    }\n+\n+    /**\n+     * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n+     * 5) close to actual cumulative Poisson probablity and that nextPoisson\n+     * fails when mean is non-positive TODO: replace with statistical test,\n+     * adding test stat to TestStatistic\n+     */\n+    public void testNextPoisson() {\n+        try {\n+            randomData.nextPoisson(0);\n+            fail(\"zero mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            try {\n+                f.addValue(randomData.nextPoisson(4.0d));\n+            } catch (Exception ex) {\n+                fail(ex.getMessage());\n+            }\n+        }\n+        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)\n+                + f.getCount(3) + f.getCount(4) + f.getCount(5);\n+        long sumFreq = f.getSumFreq();\n+        double cumPct = Double.valueOf(cumFreq).doubleValue()\n+                / Double.valueOf(sumFreq).doubleValue();\n+        assertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n+        try {\n+            randomData.nextPoisson(-1);\n+            fail(\"negative mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextPoisson(0);\n+            fail(\"0 mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+    }\n+    \n+    public void testNextPoissonConsistency() throws Exception {\n+        // Small integral means\n+        for (int i = 1; i < 100; i++) {\n+            checkNextPoissonConsistency(i);\n+        }\n+        // non-integer means\n+        RandomData randomData = new RandomDataImpl();\n+        for (int i = 1; i < 10; i++) {\n+            checkNextPoissonConsistency(randomData.nextUniform(1, 1000));\n+        }\n+        // large means \n+        // TODO: When MATH-282 is resolved, s/3000/10000 below\n+        for (int i = 1; i < 10; i++) {\n             checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));\n         }\n-\t}\n-\t\n-\t/** \n-\t * Verifies that nextPoisson(mean) generates an empirical distribution of values\n-\t * consistent with PoissonDistributionImpl by generating 1000 values, computing a\n-\t * grouped frequency distribution of the observed values and comparing this distribution\n-\t * to the corresponding expected distribution computed using PoissonDistributionImpl.\n-\t * Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the\n-\t * distributions are the same. If the null hypothesis can be rejected with confidence\n-\t * 1 - alpha, the check fails.  This check will fail randomly with probability alpha.\n-\t */\n-\tpublic void checkNextPoissonConsistency(double mean) throws Exception {\n-\t    // Generate sample values\n-\t    int sampleSize = 1000;        // Number of deviates to generate\n-\t    int minExpectedCount = 7;     // Minimum size of expected bin count \n-\t    long maxObservedValue = 0;   \n-\t    double alpha = 0.001;         // Probability of false failure         \n-\t    Frequency frequency = new Frequency();\n-\t    for (int i = 0; i < sampleSize; i++) {\n-\t        long value = randomData.nextPoisson(mean);\n-\t        if (value > maxObservedValue) {\n-\t            maxObservedValue = value;\n-\t        }\n-\t        frequency.addValue(value);\n-\t    }\n-\t    \n-\t    /*\n-\t     *  Set up bins for chi-square test.  \n-\t     *  Ensure expected counts are all at least minExpectedCount.\n-\t     *  Start with upper and lower tail bins.\n-\t     *  Lower bin = [0, lower); Upper bin = [upper, +inf).\n-\t     */\n-\t    PoissonDistribution poissonDistribution = new PoissonDistributionImpl(mean);\n-\t    int lower = 1;\n-\t    while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n-\t        lower++;\n-\t    }\n-\t    int upper = (int) (5 * mean);  // Even for mean = 1, not much mass beyond 5\n-\t    while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n-\t        upper--;\n-\t    }\n-\t    \n-\t    // Set bin width for interior bins.  For poisson, only need to look at end bins.\n-\t    int binWidth = 1;\n-\t    boolean widthSufficient = false;\n-\t    double lowerBinMass = 0;\n-\t    double upperBinMass = 0;\n-\t    while (!widthSufficient) {\n-\t        lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);\n-\t        upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);\n-\t        widthSufficient = Math.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n-\t        binWidth++;\n-\t    }\n-\t   \n-\t    /*\n-\t     *  Determine interior bin bounds.  Bins are\n-\t     *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... , \n-\t     *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)\n-\t     *  \n-\t     */\n-\t    List<Integer> binBounds = new ArrayList<Integer>();\n-\t    binBounds.add(lower);\n-\t    int bound = lower + binWidth;\n-\t    while (bound < upper - binWidth) {\n-\t        binBounds.add(bound);\n-\t        bound += binWidth;\n-\t    }\n-\t    binBounds.add(bound);\n-\t    binBounds.add(upper);\n-\t    \n-\t    // Compute observed and expected bin counts\n-\t    final int binCount = binBounds.size() + 1; \n-\t    long[] observed = new long[binCount];\n-\t    double[] expected = new double[binCount];\n-\t    \n-\t    // Bottom bin\n-\t    observed[0] = 0;\n-\t    for (int i = 0; i < lower; i++) {\n-\t        observed[0] += frequency.getCount(i);\n-\t    }\n-\t    expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n-\t    \n-\t    // Top bin\n-\t    observed[binCount - 1] = 0;\n-\t    for (int i = upper; i <= maxObservedValue; i++) {\n-\t        observed[binCount - 1] += frequency.getCount(i);\n-\t    }\n-\t    expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n-\t    \n-\t    // Interior bins\n-\t    for (int i = 1; i < binCount - 1; i++) {\n-\t        observed[i] = 0;\n-\t        for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {\n-\t            observed[i] += frequency.getCount(j);\n-\t        } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize\n-\t        expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -\n-\t            poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;\n-\t    }\n-\t    \n-\t    // Use chisquare test to verify that generated values are poisson(mean)-distributed\n-\t    ChiSquareTest chiSquareTest = new ChiSquareTestImpl();\n-\t    try {\n-\t        // Fail if we can reject null hypothesis that distributions are the same\n-\t        assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));\n-\t    } catch (AssertionFailedError ex) {\n-\t        StringBuffer msgBuffer = new StringBuffer();\n-\t        DecimalFormat df = new DecimalFormat(\"#.##\");\n-\t        msgBuffer.append(\"Chisquare test failed for mean = \");\n-\t        msgBuffer.append(mean);\n-\t        msgBuffer.append(\" p-value = \");\n-\t        msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));\n-\t        msgBuffer.append(\" chisquare statistic = \");\n-\t        msgBuffer.append(chiSquareTest.chiSquare(expected, observed));\n-\t        msgBuffer.append(\". \\n\");\n-\t        msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n-\t        for (int i = 0; i < expected.length; i++) {\n-\t            msgBuffer.append(\"[\");\n-\t            msgBuffer.append(i == 0 ? 1: binBounds.get(i - 1));\n-\t            msgBuffer.append(\",\");\n-\t            msgBuffer.append(i == binBounds.size() ? \"inf\": binBounds.get(i));\n-\t            msgBuffer.append(\")\");\n-\t            msgBuffer.append(\"\\t\\t\");\n-\t            msgBuffer.append(df.format(expected[i]));\n-\t            msgBuffer.append(\"\\t\\t\");\n-\t            msgBuffer.append(observed[i]);\n-\t            msgBuffer.append(\"\\n\");\n-\t        }\n-\t        msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n-\t        msgBuffer.append(alpha);\n-\t        msgBuffer.append(\".\");\n-\t        fail(msgBuffer.toString());\n-\t    }  \n-\t}\n-\n-\t/** test dispersion and failute modes for nextHex() */\n-\tpublic void testNextHex() {\n-\t\ttry {\n-\t\t\trandomData.nextHexString(-1);\n-\t\t\tfail(\"negative length supplied -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\ttry {\n-\t\t\trandomData.nextHexString(0);\n-\t\t\tfail(\"zero length supplied -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tString hexString = randomData.nextHexString(3);\n-\t\tif (hexString.length() != 3) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\thexString = randomData.nextHexString(1);\n-\t\tif (hexString.length() != 1) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\ttry {\n-\t\t\thexString = randomData.nextHexString(0);\n-\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tif (hexString.length() != 1) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\tFrequency f = new Frequency();\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\thexString = randomData.nextHexString(100);\n-\t\t\tif (hexString.length() != 100) {\n-\t\t\t\tfail(\"incorrect length for generated string\");\n-\t\t\t}\n-\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n-\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n-\t\t\t}\n-\t\t}\n-\t\tdouble[] expected = new double[16];\n-\t\tlong[] observed = new long[16];\n-\t\tfor (int i = 0; i < 16; i++) {\n-\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n-\t\t\tobserved[i] = f.getCount(hex[i]);\n-\t\t}\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n-\t}\n-\n-\t/** test dispersion and failute modes for nextHex() */\n-\tpublic void testNextSecureHex() {\n-\t\ttry {\n-\t\t\trandomData.nextSecureHexString(-1);\n-\t\t\tfail(\"negative length -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\ttry {\n-\t\t\trandomData.nextSecureHexString(0);\n-\t\t\tfail(\"zero length -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tString hexString = randomData.nextSecureHexString(3);\n-\t\tif (hexString.length() != 3) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\thexString = randomData.nextSecureHexString(1);\n-\t\tif (hexString.length() != 1) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\ttry {\n-\t\t\thexString = randomData.nextSecureHexString(0);\n-\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tif (hexString.length() != 1) {\n-\t\t\tfail(\"incorrect length for generated string\");\n-\t\t}\n-\t\tFrequency f = new Frequency();\n-\t\tfor (int i = 0; i < smallSampleSize; i++) {\n-\t\t\thexString = randomData.nextSecureHexString(100);\n-\t\t\tif (hexString.length() != 100) {\n-\t\t\t\tfail(\"incorrect length for generated string\");\n-\t\t\t}\n-\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n-\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n-\t\t\t}\n-\t\t}\n-\t\tdouble[] expected = new double[16];\n-\t\tlong[] observed = new long[16];\n-\t\tfor (int i = 0; i < 16; i++) {\n-\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n-\t\t\tobserved[i] = f.getCount(hex[i]);\n-\t\t}\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n-\t}\n-\n-\t/** test failure modes and dispersion of nextUniform() */\n-\tpublic void testNextUniform() {\n-\t\ttry {\n-\t\t\trandomData.nextUniform(4, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\ttry {\n-\t\t\trandomData.nextUniform(3, 3);\n-\t\t\tfail(\"IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tdouble[] expected = { 500, 500 };\n-\t\tlong[] observed = { 0, 0 };\n-\t\tdouble lower = -1d;\n-\t\tdouble upper = 20d;\n-\t\tdouble midpoint = (lower + upper) / 2d;\n-\t\tdouble result = 0;\n-\t\tfor (int i = 0; i < 1000; i++) {\n-\t\t\tresult = randomData.nextUniform(lower, upper);\n-\t\t\tif ((result == lower) || (result == upper)) {\n-\t\t\t\tfail(\"generated value equal to an endpoint: \" + result);\n-\t\t\t}\n-\t\t\tif (result < midpoint) {\n-\t\t\t\tobserved[0]++;\n-\t\t\t} else {\n-\t\t\t\tobserved[1]++;\n-\t\t\t}\n-\t\t}\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n-\t\t * alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 10.83);\n-\t}\n-\n-\t/** test exclusive endpoints of nextUniform **/\n-\tpublic void testNextUniformExclusiveEndpoints() {\n-\t\tfor (int i = 0; i < 1000; i++) {\n-\t\t\tdouble u = randomData.nextUniform(0.99, 1);\n-\t\t\tassertTrue(u > 0.99 && u < 1);\n-\t\t}\n-\t}\n-\n-\t/** test failure modes and distribution of nextGaussian() */\n-\tpublic void testNextGaussian() {\n-\t\ttry {\n-\t\t\trandomData.nextGaussian(0, 0);\n-\t\t\tfail(\"zero sigma -- IllegalArgumentException expected\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t\tSummaryStatistics u = new SummaryStatistics();\n-\t\tfor (int i = 0; i < largeSampleSize; i++) {\n-\t\t\tu.addValue(randomData.nextGaussian(0, 1));\n-\t\t}\n-\t\tdouble xbar = u.getMean();\n-\t\tdouble s = u.getStandardDeviation();\n-\t\tdouble n = u.getN();\n-\t\t/*\n-\t\t * t-test at .001-level TODO: replace with externalized t-test, with\n-\t\t * test statistic defined in TestStatistic\n-\t\t */\n-\t\tassertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);\n-\t}\n-\n-\t/** test failure modes and distribution of nextExponential() */\n-\tpublic void testNextExponential() {\n-\t\ttry {\n-\t\t\trandomData.nextExponential(-1);\n-\t\t\tfail(\"negative mean -- expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n+    }\n+    \n+    /** \n+     * Verifies that nextPoisson(mean) generates an empirical distribution of values\n+     * consistent with PoissonDistributionImpl by generating 1000 values, computing a\n+     * grouped frequency distribution of the observed values and comparing this distribution\n+     * to the corresponding expected distribution computed using PoissonDistributionImpl.\n+     * Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the\n+     * distributions are the same. If the null hypothesis can be rejected with confidence\n+     * 1 - alpha, the check fails.  This check will fail randomly with probability alpha.\n+     */\n+    public void checkNextPoissonConsistency(double mean) throws Exception {\n+        // Generate sample values\n+        int sampleSize = 1000;        // Number of deviates to generate\n+        int minExpectedCount = 7;     // Minimum size of expected bin count \n+        long maxObservedValue = 0;   \n+        double alpha = 0.001;         // Probability of false failure         \n+        Frequency frequency = new Frequency();\n+        for (int i = 0; i < sampleSize; i++) {\n+            long value = randomData.nextPoisson(mean);\n+            if (value > maxObservedValue) {\n+                maxObservedValue = value;\n+            }\n+            frequency.addValue(value);\n+        }\n+        \n+        /*\n+         *  Set up bins for chi-square test.  \n+         *  Ensure expected counts are all at least minExpectedCount.\n+         *  Start with upper and lower tail bins.\n+         *  Lower bin = [0, lower); Upper bin = [upper, +inf).\n+         */\n+        PoissonDistribution poissonDistribution = new PoissonDistributionImpl(mean);\n+        int lower = 1;\n+        while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n+            lower++;\n+        }\n+        int upper = (int) (5 * mean);  // Even for mean = 1, not much mass beyond 5\n+        while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n+            upper--;\n+        }\n+        \n+        // Set bin width for interior bins.  For poisson, only need to look at end bins.\n+        int binWidth = 1;\n+        boolean widthSufficient = false;\n+        double lowerBinMass = 0;\n+        double upperBinMass = 0;\n+        while (!widthSufficient) {\n+            lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);\n+            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);\n+            widthSufficient = Math.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n+            binWidth++;\n+        }\n+       \n+        /*\n+         *  Determine interior bin bounds.  Bins are\n+         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... , \n+         *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)\n+         *  \n+         */\n+        List<Integer> binBounds = new ArrayList<Integer>();\n+        binBounds.add(lower);\n+        int bound = lower + binWidth;\n+        while (bound < upper - binWidth) {\n+            binBounds.add(bound);\n+            bound += binWidth;\n+        }\n+        binBounds.add(bound);\n+        binBounds.add(upper);\n+        \n+        // Compute observed and expected bin counts\n+        final int binCount = binBounds.size() + 1; \n+        long[] observed = new long[binCount];\n+        double[] expected = new double[binCount];\n+        \n+        // Bottom bin\n+        observed[0] = 0;\n+        for (int i = 0; i < lower; i++) {\n+            observed[0] += frequency.getCount(i);\n+        }\n+        expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n+        \n+        // Top bin\n+        observed[binCount - 1] = 0;\n+        for (int i = upper; i <= maxObservedValue; i++) {\n+            observed[binCount - 1] += frequency.getCount(i);\n+        }\n+        expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n+        \n+        // Interior bins\n+        for (int i = 1; i < binCount - 1; i++) {\n+            observed[i] = 0;\n+            for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {\n+                observed[i] += frequency.getCount(j);\n+            } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize\n+            expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -\n+                poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;\n+        }\n+        \n+        // Use chisquare test to verify that generated values are poisson(mean)-distributed\n+        ChiSquareTest chiSquareTest = new ChiSquareTestImpl();\n+        try {\n+            // Fail if we can reject null hypothesis that distributions are the same\n+            assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));\n+        } catch (AssertionFailedError ex) {\n+            StringBuffer msgBuffer = new StringBuffer();\n+            DecimalFormat df = new DecimalFormat(\"#.##\");\n+            msgBuffer.append(\"Chisquare test failed for mean = \");\n+            msgBuffer.append(mean);\n+            msgBuffer.append(\" p-value = \");\n+            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));\n+            msgBuffer.append(\" chisquare statistic = \");\n+            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));\n+            msgBuffer.append(\". \\n\");\n+            msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n+            for (int i = 0; i < expected.length; i++) {\n+                msgBuffer.append(\"[\");\n+                msgBuffer.append(i == 0 ? 1: binBounds.get(i - 1));\n+                msgBuffer.append(\",\");\n+                msgBuffer.append(i == binBounds.size() ? \"inf\": binBounds.get(i));\n+                msgBuffer.append(\")\");\n+                msgBuffer.append(\"\\t\\t\");\n+                msgBuffer.append(df.format(expected[i]));\n+                msgBuffer.append(\"\\t\\t\");\n+                msgBuffer.append(observed[i]);\n+                msgBuffer.append(\"\\n\");\n+            }\n+            msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n+            msgBuffer.append(alpha);\n+            msgBuffer.append(\".\");\n+            fail(msgBuffer.toString());\n+        }  \n+    }\n+\n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextHex() {\n+        try {\n+            randomData.nextHexString(-1);\n+            fail(\"negative length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextHexString(0);\n+            fail(\"zero length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        String hexString = randomData.nextHexString(3);\n+        if (hexString.length() != 3) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextHexString(1);\n+        if (hexString.length() != 1) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        if (hexString.length() != 1) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j, j + 1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        long[] observed = new long[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double) smallSampleSize * 100 / 16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /*\n+         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 37.70);\n+    }\n+\n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextSecureHex() {\n+        try {\n+            randomData.nextSecureHexString(-1);\n+            fail(\"negative length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextSecureHexString(0);\n+            fail(\"zero length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        String hexString = randomData.nextSecureHexString(3);\n+        if (hexString.length() != 3) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextSecureHexString(1);\n+        if (hexString.length() != 1) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextSecureHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        if (hexString.length() != 1) {\n+            fail(\"incorrect length for generated string\");\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextSecureHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j, j + 1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        long[] observed = new long[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double) smallSampleSize * 100 / 16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /*\n+         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 37.70);\n+    }\n+\n+    /** test failure modes and dispersion of nextUniform() */\n+    public void testNextUniform() {\n+        try {\n+            randomData.nextUniform(4, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(3, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        double[] expected = { 500, 500 };\n+        long[] observed = { 0, 0 };\n+        double lower = -1d;\n+        double upper = 20d;\n+        double midpoint = (lower + upper) / 2d;\n+        double result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result = randomData.nextUniform(lower, upper);\n+            if ((result == lower) || (result == upper)) {\n+                fail(\"generated value equal to an endpoint: \" + result);\n+            }\n+            if (result < midpoint) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /*\n+         * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n+         * alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 10.83);\n+    }\n+\n+    /** test exclusive endpoints of nextUniform **/\n+    public void testNextUniformExclusiveEndpoints() {\n+        for (int i = 0; i < 1000; i++) {\n+            double u = randomData.nextUniform(0.99, 1);\n+            assertTrue(u > 0.99 && u < 1);\n+        }\n+    }\n+\n+    /** test failure modes and distribution of nextGaussian() */\n+    public void testNextGaussian() {\n+        try {\n+            randomData.nextGaussian(0, 0);\n+            fail(\"zero sigma -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+        SummaryStatistics u = new SummaryStatistics();\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            u.addValue(randomData.nextGaussian(0, 1));\n+        }\n+        double xbar = u.getMean();\n+        double s = u.getStandardDeviation();\n+        double n = u.getN();\n+        /*\n+         * t-test at .001-level TODO: replace with externalized t-test, with\n+         * test statistic defined in TestStatistic\n+         */\n+        assertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);\n+    }\n+\n+    /** test failure modes and distribution of nextExponential() */\n+    public void testNextExponential() {\n+        try {\n+            randomData.nextExponential(-1);\n+            fail(\"negative mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n         try {\n             randomData.nextExponential(0);\n             fail(\"zero mean -- expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n         }\n-\t\tlong cumFreq = 0;\n-\t\tdouble v = 0;\n-\t\tfor (int i = 0; i < largeSampleSize; i++) {\n-\t\t\tv = randomData.nextExponential(1);\n-\t\t\tassertTrue(\"exponential deviate postive\", v > 0);\n-\t\t\tif (v < 2)\n-\t\t\t\tcumFreq++;\n-\t\t}\n-\t\t/*\n-\t\t * TODO: Replace with a statistical test, with statistic added to\n-\t\t * TestStatistic. Check below compares observed cumulative distribution\n-\t\t * evaluated at 2 with exponential CDF\n-\t\t */\n-\t\tassertEquals(\"exponential cumulative distribution\", (double) cumFreq\n-\t\t\t\t/ (double) largeSampleSize, 0.8646647167633873, .2);\n-\t}\n-\n-\t/** test reseeding, algorithm/provider games */\n-\tpublic void testConfig() {\n-\t\trandomData.reSeed(1000);\n-\t\tdouble v = randomData.nextUniform(0, 1);\n-\t\trandomData.reSeed();\n-\t\tassertTrue(\"different seeds\", Math\n-\t\t\t\t.abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n-\t\trandomData.reSeed(1000);\n-\t\tassertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n-\t\trandomData.reSeedSecure(1000);\n-\t\tString hex = randomData.nextSecureHexString(40);\n-\t\trandomData.reSeedSecure();\n-\t\tassertTrue(\"different seeds\", !hex.equals(randomData\n-\t\t\t\t.nextSecureHexString(40)));\n-\t\trandomData.reSeedSecure(1000);\n-\t\tassertTrue(\"same seeds\", !hex\n-\t\t\t\t.equals(randomData.nextSecureHexString(40)));\n-\n-\t\t/*\n-\t\t * remove this test back soon, since it takes about 4 seconds\n-\t\t *\n-\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n-\t\t * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n-\t\t * !hex.equals(randomData.nextSecureHexString(40))); try {\n-\t\t * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n-\t\t * fail(\"expecting NoSuchAlgorithmException\"); } catch\n-\t\t * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n-\t\t * ex) { ; }\n-\t\t *\n-\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n-\t\t * fail(\"expecting NoSuchProviderException\"); } catch\n-\t\t * (NoSuchProviderException ex) { ; }\n-\t\t */\n-\n-\t\t// test reseeding without first using the generators\n-\t\tRandomDataImpl rd = new RandomDataImpl();\n-\t\trd.reSeed(100);\n-\t\trd.nextLong(1, 2);\n-\t\tRandomDataImpl rd2 = new RandomDataImpl();\n-\t\trd2.reSeedSecure(2000);\n-\t\trd2.nextSecureLong(1, 2);\n-\t\trd = new RandomDataImpl();\n-\t\trd.reSeed();\n-\t\trd.nextLong(1, 2);\n-\t\trd2 = new RandomDataImpl();\n-\t\trd2.reSeedSecure();\n-\t\trd2.nextSecureLong(1, 2);\n-\t}\n-\n-\t/** tests for nextSample() sampling from Collection */\n-\tpublic void testNextSample() {\n-\t\tObject[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n-\t\t\t\t{ \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n-\t\t\t\t{ \"2\", \"3\" }, { \"2\", \"4\" }, { \"3\", \"4\" } };\n-\t\tlong[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n-\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };\n-\n-\t\tHashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}\n-\t\tfor (int i = 0; i < 5; i++) {\n-\t\t\tcPop.add(Integer.toString(i));\n-\t\t}\n-\n-\t\tObject[] sets = new Object[10]; // 2-sets from 5\n-\t\tfor (int i = 0; i < 10; i++) {\n-\t\t\tHashSet<Object> hs = new HashSet<Object>();\n-\t\t\ths.add(c[i][0]);\n-\t\t\ths.add(c[i][1]);\n-\t\t\tsets[i] = hs;\n-\t\t}\n-\n-\t\tfor (int i = 0; i < 1000; i++) {\n-\t\t\tObject[] cSamp = randomData.nextSample(cPop, 2);\n-\t\t\tobserved[findSample(sets, cSamp)]++;\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 27.88);\n-\n-\t\t// Make sure sample of size = size of collection returns same collection\n-\t\tHashSet<Object> hs = new HashSet<Object>();\n-\t\ths.add(\"one\");\n-\t\tObject[] one = randomData.nextSample(hs, 1);\n-\t\tString oneString = (String) one[0];\n-\t\tif ((one.length != 1) || !oneString.equals(\"one\")) {\n-\t\t\tfail(\"bad sample for set size = 1, sample size = 1\");\n-\t\t}\n-\n-\t\t// Make sure we fail for sample size > collection size\n-\t\ttry {\n-\t\t\tone = randomData.nextSample(hs, 2);\n-\t\t\tfail(\"sample size > set size, expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\n-\t\t// Make sure we fail for empty collection\n-\t\ttry {\n-\t\t\ths = new HashSet<Object>();\n-\t\t\tone = randomData.nextSample(hs, 0);\n-\t\t\tfail(\"n = k = 0, expecting IllegalArgumentException\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// ignored\n-\t\t}\n-\t}\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate int findSample(Object[] u, Object[] samp) {\n-\t\tfor (int i = 0; i < u.length; i++) {\n-\t\t\tHashSet<Object> set = (HashSet<Object>) u[i];\n-\t\t\tHashSet<Object> sampSet = new HashSet<Object>();\n-\t\t\tfor (int j = 0; j < samp.length; j++) {\n-\t\t\t\tsampSet.add(samp[j]);\n-\t\t\t}\n-\t\t\tif (set.equals(sampSet)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\tfail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n-\t\treturn -1;\n-\t}\n-\n-\t/** tests for nextPermutation */\n-\tpublic void testNextPermutation() {\n-\t\tint[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n-\t\t\t\t{ 2, 0, 1 }, { 2, 1, 0 } };\n-\t\tlong[] observed = { 0, 0, 0, 0, 0, 0 };\n-\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100 };\n-\n-\t\tfor (int i = 0; i < 600; i++) {\n-\t\t\tint[] perm = randomData.nextPermutation(3, 3);\n-\t\t\tobserved[findPerm(p, perm)]++;\n-\t\t}\n-\n-\t\t/*\n-\t\t * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09\n-\t\t * for alpha = .01\n-\t\t */\n-\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-\t\t\t\ttestStatistic.chiSquare(expected, observed) < 20.52);\n-\n-\t\t// Check size = 1 boundary case\n-\t\tint[] perm = randomData.nextPermutation(1, 1);\n-\t\tif ((perm.length != 1) || (perm[0] != 0)) {\n-\t\t\tfail(\"bad permutation for n = 1, sample k = 1\");\n-\n-\t\t\t// Make sure we fail for k size > n\n-\t\t\ttry {\n-\t\t\t\tperm = randomData.nextPermutation(2, 3);\n-\t\t\t\tfail(\"permutation k > n, expecting IllegalArgumentException\");\n-\t\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t\t// ignored\n-\t\t\t}\n-\n-\t\t\t// Make sure we fail for n = 0\n-\t\t\ttry {\n-\t\t\t\tperm = randomData.nextPermutation(0, 0);\n-\t\t\t\tfail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n-\t\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t\t// ignored\n-\t\t\t}\n-\n-\t\t\t// Make sure we fail for k < n < 0\n-\t\t\ttry {\n-\t\t\t\tperm = randomData.nextPermutation(-1, -3);\n-\t\t\t\tfail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n-\t\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t\t// ignored\n-\t\t\t}\n-\n-\t\t}\n-\t}\n-\t\n-\t// Disable until we have equals\n-\t//public void testSerial() {\n-\t//    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n-\t//}\n-\t\n-\tprivate int findPerm(int[][] p, int[] samp) {\n-\t\tfor (int i = 0; i < p.length; i++) {\n-\t\t\tboolean good = true;\n-\t\t\tfor (int j = 0; j < samp.length; j++) {\n-\t\t\t\tif (samp[j] != p[i][j]) {\n-\t\t\t\t\tgood = false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (good) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\tfail(\"permutation not found\");\n-\t\treturn -1;\n-\t}\n+        long cumFreq = 0;\n+        double v = 0;\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            v = randomData.nextExponential(1);\n+            assertTrue(\"exponential deviate postive\", v > 0);\n+            if (v < 2)\n+                cumFreq++;\n+        }\n+        /*\n+         * TODO: Replace with a statistical test, with statistic added to\n+         * TestStatistic. Check below compares observed cumulative distribution\n+         * evaluated at 2 with exponential CDF\n+         */\n+        assertEquals(\"exponential cumulative distribution\", (double) cumFreq\n+                / (double) largeSampleSize, 0.8646647167633873, .2);\n+    }\n+\n+    /** test reseeding, algorithm/provider games */\n+    public void testConfig() {\n+        randomData.reSeed(1000);\n+        double v = randomData.nextUniform(0, 1);\n+        randomData.reSeed();\n+        assertTrue(\"different seeds\", Math\n+                .abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n+        randomData.reSeed(1000);\n+        assertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n+        randomData.reSeedSecure(1000);\n+        String hex = randomData.nextSecureHexString(40);\n+        randomData.reSeedSecure();\n+        assertTrue(\"different seeds\", !hex.equals(randomData\n+                .nextSecureHexString(40)));\n+        randomData.reSeedSecure(1000);\n+        assertTrue(\"same seeds\", !hex\n+                .equals(randomData.nextSecureHexString(40)));\n+\n+        /*\n+         * remove this test back soon, since it takes about 4 seconds\n+         *\n+         * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n+         * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n+         * !hex.equals(randomData.nextSecureHexString(40))); try {\n+         * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+         * fail(\"expecting NoSuchAlgorithmException\"); } catch\n+         * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n+         * ex) { ; }\n+         *\n+         * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+         * fail(\"expecting NoSuchProviderException\"); } catch\n+         * (NoSuchProviderException ex) { ; }\n+         */\n+\n+        // test reseeding without first using the generators\n+        RandomDataImpl rd = new RandomDataImpl();\n+        rd.reSeed(100);\n+        rd.nextLong(1, 2);\n+        RandomDataImpl rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure(2000);\n+        rd2.nextSecureLong(1, 2);\n+        rd = new RandomDataImpl();\n+        rd.reSeed();\n+        rd.nextLong(1, 2);\n+        rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure();\n+        rd2.nextSecureLong(1, 2);\n+    }\n+\n+    /** tests for nextSample() sampling from Collection */\n+    public void testNextSample() {\n+        Object[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n+                { \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n+                { \"2\", \"3\" }, { \"2\", \"4\" }, { \"3\", \"4\" } };\n+        long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+        double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+        HashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}\n+        for (int i = 0; i < 5; i++) {\n+            cPop.add(Integer.toString(i));\n+        }\n+\n+        Object[] sets = new Object[10]; // 2-sets from 5\n+        for (int i = 0; i < 10; i++) {\n+            HashSet<Object> hs = new HashSet<Object>();\n+            hs.add(c[i][0]);\n+            hs.add(c[i][1]);\n+            sets[i] = hs;\n+        }\n+\n+        for (int i = 0; i < 1000; i++) {\n+            Object[] cSamp = randomData.nextSample(cPop, 2);\n+            observed[findSample(sets, cSamp)]++;\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 27.88);\n+\n+        // Make sure sample of size = size of collection returns same collection\n+        HashSet<Object> hs = new HashSet<Object>();\n+        hs.add(\"one\");\n+        Object[] one = randomData.nextSample(hs, 1);\n+        String oneString = (String) one[0];\n+        if ((one.length != 1) || !oneString.equals(\"one\")) {\n+            fail(\"bad sample for set size = 1, sample size = 1\");\n+        }\n+\n+        // Make sure we fail for sample size > collection size\n+        try {\n+            one = randomData.nextSample(hs, 2);\n+            fail(\"sample size > set size, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        // Make sure we fail for empty collection\n+        try {\n+            hs = new HashSet<Object>();\n+            one = randomData.nextSample(hs, 0);\n+            fail(\"n = k = 0, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private int findSample(Object[] u, Object[] samp) {\n+        for (int i = 0; i < u.length; i++) {\n+            HashSet<Object> set = (HashSet<Object>) u[i];\n+            HashSet<Object> sampSet = new HashSet<Object>();\n+            for (int j = 0; j < samp.length; j++) {\n+                sampSet.add(samp[j]);\n+            }\n+            if (set.equals(sampSet)) {\n+                return i;\n+            }\n+        }\n+        fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+        return -1;\n+    }\n+\n+    /** tests for nextPermutation */\n+    public void testNextPermutation() {\n+        int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n+                { 2, 0, 1 }, { 2, 1, 0 } };\n+        long[] observed = { 0, 0, 0, 0, 0, 0 };\n+        double[] expected = { 100, 100, 100, 100, 100, 100 };\n+\n+        for (int i = 0; i < 600; i++) {\n+            int[] perm = randomData.nextPermutation(3, 3);\n+            observed[findPerm(p, perm)]++;\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09\n+         * for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 20.52);\n+\n+        // Check size = 1 boundary case\n+        int[] perm = randomData.nextPermutation(1, 1);\n+        if ((perm.length != 1) || (perm[0] != 0)) {\n+            fail(\"bad permutation for n = 1, sample k = 1\");\n+\n+            // Make sure we fail for k size > n\n+            try {\n+                perm = randomData.nextPermutation(2, 3);\n+                fail(\"permutation k > n, expecting IllegalArgumentException\");\n+            } catch (IllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+            // Make sure we fail for n = 0\n+            try {\n+                perm = randomData.nextPermutation(0, 0);\n+                fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n+            } catch (IllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+            // Make sure we fail for k < n < 0\n+            try {\n+                perm = randomData.nextPermutation(-1, -3);\n+                fail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n+            } catch (IllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+        }\n+    }\n+    \n+    // Disable until we have equals\n+    //public void testSerial() {\n+    //    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n+    //}\n+    \n+    private int findPerm(int[][] p, int[] samp) {\n+        for (int i = 0; i < p.length; i++) {\n+            boolean good = true;\n+            for (int j = 0; j < samp.length; j++) {\n+                if (samp[j] != p[i][j]) {\n+                    good = false;\n+                }\n+            }\n+            if (good) {\n+                return i;\n+            }\n+        }\n+        fail(\"permutation not found\");\n+        return -1;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n \n     @Override\n     public void setUp() throws Exception {\n-    \tsuper.setUp();\n+        super.setUp();\n         testStatistic = TestUtils.getUnknownDistributionChiSquareTest();\n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n \n     @Override\n     public void setUp() {\n-    \tsuper.setUp();\n+        super.setUp();\n         testStatistic = TestUtils.getTTest();\n     }\n ", "timestamp": 1260326051, "metainfo": ""}