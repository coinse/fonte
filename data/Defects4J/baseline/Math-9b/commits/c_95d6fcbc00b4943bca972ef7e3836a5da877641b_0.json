{"sha": "95d6fcbc00b4943bca972ef7e3836a5da877641b", "log": "fixed various minor bugs identified by checkstyle and findbugs  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/minimization/BrentMinimizer.java\n+++ b/src/java/org/apache/commons/math/analysis/minimization/BrentMinimizer.java\n  */\n package org.apache.commons.math.analysis.minimization;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n      * @param max the upper bound for the interval.\n      * @param startValue this parameter is <em>not</em> used at all\n      * @return a value where the function is minimum\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the minimizer detects convergence problems otherwise.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n         throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n         clearResult();\n-        return localmin(min, max, relativeAccuracy, absoluteAccuracy, f);\n+        return localMin(min, max, relativeAccuracy, absoluteAccuracy, f);\n     }\n     \n     /**\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function. \n      */\n-    private double localmin(double a, double b, final double eps,\n+    private double localMin(double a, double b, final double eps,\n                             final double t, final UnivariateRealFunction f)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         double x = a + c * (b - a);\n--- a/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizerImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizerImpl.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4543031162377070699L;\n \n-//    /** Maximum error of function. */\n-//    protected double functionValueAccuracy;\n-//\n-//    /** Default maximum error of function. */\n-//    protected double defaultFunctionValueAccuracy;\n-\n     /** Indicates where a root has been computed. */\n     protected boolean resultComputed = false;\n \n     protected UnivariateRealMinimizerImpl(int defaultMaximalIterationCount,\n                                           double defaultAbsoluteAccuracy) {\n         super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n-//        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n     }\n \n     /** Check if a result has been computed.\n      * @exception IllegalStateException if no result has been computed\n      */\n-    protected void checkResultComputed() throws IllegalArgumentException {\n+    protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n             throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n         return functionValue;\n     }\n \n-//    /** {@inheritDoc} */\n-//    public void setFunctionValueAccuracy(double accuracy) {\n-//        functionValueAccuracy = accuracy;\n-//    }\n-//\n-//    /** {@inheritDoc} */\n-//    public double getFunctionValueAccuracy() {\n-//        return functionValueAccuracy;\n-//    }\n-//\n-//    /** {@inheritDoc} */\n-//    public void resetFunctionValueAccuracy() {\n-//        functionValueAccuracy = defaultFunctionValueAccuracy;\n-//    }\n-    \n     /**\n      * Convenience function for implementations.\n      * \n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n      */\n     @Deprecated\n     double solve(double min, double max, double startValue)\n-        throws ConvergenceException, FunctionEvaluationException;\n+        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n \n     /**\n      * Solve for a zero in the given interval, start at startValue.\n      * @since 2.0\n      */\n     double solve(UnivariateRealFunction f, double min, double max, double startValue)\n-        throws ConvergenceException, FunctionEvaluationException;\n+        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n \n     /**\n      * Get the result of the last run of the solver.\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n     /** Check if a result has been computed.\n      * @exception IllegalStateException if no result has been computed\n      */\n-    protected void checkResultComputed() throws IllegalArgumentException {\n+    protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n             throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n--- a/src/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n \n /** This interface represents a second order differential equations set.\n \n  * @since 1.2\n  */\n \n-public interface SecondOrderDifferentialEquations {\n+public interface SecondOrderDifferentialEquations extends Serializable {\n \n   /** Get the dimension of the problem.\n    * @return dimension of the problem\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n          */\n         public Complex set(Complex magnitude, int... vector)\n             throws IllegalArgumentException {\n-            if (vector == null && dimensionSize.length > 1) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n-                                                                          new Object[] { 0, dimensionSize.length });\n+            if (vector == null) {\n+                if (dimensionSize.length > 1) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n+                                                                              new Object[] { 0, dimensionSize.length });\n+                }\n+                return null;\n             }\n             if (vector != null && vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n                                                                               dimensionSize.length\n                                                                           });\n             }\n-            \n-            Object lastDimension = multiDimensionalComplexArray;\n-            \n+\n+            Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n             for (int i = 0; i < dimensionSize.length - 1; i++) {\n-                lastDimension = ((Object[]) lastDimension)[vector[i]];\n-            }\n-            \n-            Complex lastValue = (Complex) ((Object[])\n-                    lastDimension)[vector[dimensionSize.length - 1]];\n-            ((Object[]) lastDimension)[vector[dimensionSize.length - 1]] =\n-                    magnitude;\n+                lastDimension = (Object[]) lastDimension[vector[i]];\n+            }\n+\n+            Complex lastValue = (Complex) lastDimension[vector[dimensionSize.length - 1]];\n+            lastDimension[vector[dimensionSize.length - 1]] = magnitude;\n+\n             return lastValue;\n         }\n \n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n \n package org.apache.commons.math.util;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n import java.io.Serializable;\n import java.util.ConcurrentModificationException;\n import java.util.NoSuchElementException;\n \n     }\n \n+    /**\n+     * Read a serialized object.\n+     * @param stream input stream\n+     * @throws IOException if object cannot be read\n+     * @throws ClassNotFoundException if the class corresponding\n+     * to the serialized object cannot be found\n+     */\n+    private void readObject(final ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        count = 0;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      */\n     public int hashCode() {\n         int[] hashData = new int[7];\n-        hashData[0] = Arrays.hashCode(internalArray);\n-        hashData[1] = new Float(expansionFactor).hashCode();\n-        hashData[2] = new Float(contractionCriteria).hashCode();\n-        hashData[3] = initialCapacity;\n-        hashData[4] = expansionMode;\n-        hashData[5] = numElements;\n-        hashData[6] = startIndex;\n+        hashData[0] = new Float(expansionFactor).hashCode();\n+        hashData[1] = new Float(contractionCriteria).hashCode();\n+        hashData[2] = expansionMode;\n+        synchronized(this) {\n+            hashData[3] = Arrays.hashCode(internalArray);\n+            hashData[4] = initialCapacity;\n+            hashData[5] = numElements;\n+            hashData[6] = startIndex;\n+        }\n         return Arrays.hashCode(hashData);\n     }\n          ", "timestamp": 1232297849, "metainfo": ""}