{"sha": "6c1283dd46b91317ab2297a27b7a274c87f62e86", "log": "added a decompose method to the base DecompositionSolver interface to allow a solver to decompose a matrix after construction.  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n /**\n  * A base interface to decomposition algorithms that can solve A &times; X = B.\n  * <p>This interface is the common base of decomposition algorithms like\n- * {@link QRDecomposition} or {@link LUDecomposition}. All these algorithms\n- * decompose an A matrix has a product of several specific matrices from\n- * which they can solve A &times; X = B.</p>\n- * <p>Depending on the solver, the solution is either an exact linear solution\n- * or a least squares solution. When an exact linear solution exist, both the\n- * linear and the least squares solution are equal. When no exact linear solution\n- * exist, a least square solution gives an X which such that A &times; X is the\n- * closest possible to B.</p>\n+ * {@link QRDecomposition}, {@link LUDecomposition} or {@link\n+ * SingularValueDecomposition}. All these algorithms decompose an A matrix has a\n+ * product of several specific matrices from which they can solve A &times; X = B\n+ * in least squares sense: they find X such that ||A &times; X - B|| is minimal.</p>\n+ * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n+ * square matrices and when the solution is an exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n+ * with non-square matrix A and with non-null minimal norm. If an exact linear\n+ * solution exists it is also the minimal norm solution.</p>\n  *   \n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface DecompositionSolver extends Serializable {\n \n+    /**\n+     * Decompose a matrix.\n+     * @param matrix\n+     * @exception InvalidMatrixException if matrix does not fulfill\n+     * the decomposition requirements (for example non-square matrix\n+     * for {@link LUDecomposition})\n+     */\n+    void decompose(RealMatrix matrix)\n+      throws InvalidMatrixException;\n+\n     /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n     double[] solve(double[] b)\n-      throws IllegalArgumentException, InvalidMatrixException;\n+      throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n \n     /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n     RealVector solve(RealVector b)\n-      throws IllegalArgumentException, InvalidMatrixException;\n+      throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n \n     /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n     RealMatrix solve(RealMatrix b)\n-      throws IllegalArgumentException, InvalidMatrixException;\n+      throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n \n }\n--- a/src/java/org/apache/commons/math/linear/LUDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecomposition.java\n  * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n  * to rearrange the rows of A before so that it can be decomposed. L is a lower\n  * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n- * <p>This interface is similar to the class with similar name from the now defunct\n+ * <p>This interface is based on the class with similar name from the now defunct\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n- * exception of the <code>det</code> method which has been renamed as {@link\n- * #getDeterminant() getDeterminant}.</p>\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>several signatures have been added for the <code>solve</code> methods (in the superinterface),</code>\n+ *   <li>a <code>decompose</code> method has been added (in the superinterface),</code>\n+ *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant() getDeterminant}.</li>\n+ * </ul>\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n public interface LUDecomposition extends DecompositionSolver {\n \n     /**\n+     * Computes a new\n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algorithm</a>, with partial pivoting.</p>\n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    void decompose(RealMatrix matrix, double singularityThreshold);\n+\n+    /**\n      * Returns the matrix L of the decomposition. \n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getL();\n+    RealMatrix getL() throws IllegalStateException;\n \n     /**\n      * Returns the matrix U of the decomposition. \n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getU();\n+    RealMatrix getU() throws IllegalStateException;\n \n     /**\n      * Returns the P rows permutation matrix.\n      * <p>The positions of the 1 elements are given by the {@link #getPivot()\n      * pivot permutation vector}.</p>\n      * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getPivot()\n      */\n-    RealMatrix getP();\n+    RealMatrix getP() throws IllegalStateException;\n \n     /**\n      * Returns the pivot permutation vector.\n      * @return the pivot permutation vector\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getPermutation()\n      */\n-    int[] getPivot();\n+    int[] getPivot() throws IllegalStateException;\n \n     /**\n      * Check if the decomposed matrix is non-singular.\n      * @return true if the decomposed matrix is non-singular\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getDeterminant()\n      */\n-    boolean isNonSingular();\n+    boolean isNonSingular() throws IllegalStateException;\n \n     /**\n      * Return the determinant of the matrix\n      * @return determinant of the matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #isNonSingular()\n      */\n-    double getDeterminant();\n+    double getDeterminant() throws IllegalStateException;\n \n }\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n public class LUDecompositionImpl implements LUDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -1606789599960880183L;\n-\n-    /** Bound to determine effective singularity in LU decomposition */\n-    private final double singularityThreshold;\n-\n-    /** Size of the matrix. */\n-    private final int m;\n+    private static final long serialVersionUID = -9052751605297201067L;\n \n     /** Entries of LU decomposition. */\n-    private final double lu[][];\n+    private double lu[][];\n \n     /** Pivot permutation associated with LU decomposition */\n-    private final int[] pivot;\n+    private int[] pivot;\n \n     /** Parity of the permutation associated with the LU decomposition */\n     private int parity;\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n \n     /**\n+     * Build a new instance.\n+     * <p>Note that either {@link #decompose(RealMatrix)} or\n+     * {@link #decompose(RealMatrix, double)} <strong>must</strong> be called\n+     * before any of the {@link #getP()}, {@link #getPivot()}, {@link #getL()},\n+     * {@link #getU()}, {@link #getDeterminant()}, {@link #isNonSingular()},\n+     * {@link #solve(double[])}, {@link #solve(RealMatrix)}, {@link #solve(RealVector)}\n+     * or {@link #solve(RealVectorImpl)} methods can be called.</p>\n+     * @see #decompose(RealMatrix)\n+     * @see #decompose(RealMatrix, double)\n+     */\n+    public LUDecompositionImpl() {\n+    }\n+\n+    /**\n      * Calculates the LU-decomposition of the given matrix. \n-     * \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n      * @param matrix The matrix to decompose.\n      * @exception InvalidMatrixException if matrix is not square\n      */\n     public LUDecompositionImpl(RealMatrix matrix)\n         throws InvalidMatrixException {\n-        this(matrix, DEFAULT_TOO_SMALL);\n+        decompose(matrix);\n     }\n \n     /**\n      * Calculates the LU-decomposition of the given matrix. \n-     * \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix, double)}.</p>\n      * @param matrix The matrix to decompose.\n      * @param singularityThreshold threshold (based on partial row norm)\n      * under which a matrix is considered singular\n      */\n     public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n         throws InvalidMatrixException {\n+        decompose(matrix, singularityThreshold);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix, DEFAULT_TOO_SMALL);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix, double singularityThreshold)\n+        throws InvalidMatrixException {\n         if (!matrix.isSquare()) {\n             throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n         }\n-        this.singularityThreshold = singularityThreshold;\n-        m = matrix.getColumnDimension();\n+        final int m = matrix.getColumnDimension();\n         lu = matrix.getData();\n         pivot = new int[m];\n         cachedL = null;\n         cachedU = null;\n         cachedP = null;\n \n-        // perform decomposition\n-        luDecompose();\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getL() {\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        parity = 1;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            double sum = 0;\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = Double.NEGATIVE_INFINITY;\n+            for (int row = col; row < m; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+\n+                // maintain best permutation choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < singularityThreshold) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                parity = -parity;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                lu[row][col] /= luDiag;\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n             final double[][] lData = new double[m][m];\n             for (int i = 0; i < m; ++i) {\n                 System.arraycopy(lu[i], 0, lData[i], 0, i);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getU() {\n+    public RealMatrix getU()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n             final double[][] uData = new double[m][m];\n             for (int i = 0; i < m; ++i) {\n                 System.arraycopy(lu[i], i, uData[i], i, m - i);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getP() {\n+    public RealMatrix getP()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n             final double[][] pData = new double[m][m];\n             for (int i = 0; i < m; ++i) {\n                 pData[i][pivot[i]] = 1.0;\n     }\n \n     /** {@inheritDoc} */\n-    public int[] getPivot() {\n+    public int[] getPivot()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         return pivot.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public boolean isNonSingular() {\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         return !singular;\n     }\n \n     /** {@inheritDoc} */\n-    public double getDeterminant() {\n+    public double getDeterminant()\n+        throws IllegalStateException {\n+        checkDecomposed();\n         if (singular) {\n             return 0;\n         } else {\n+            final int m = pivot.length;\n             double determinant = parity;\n             for (int i = 0; i < m; i++) {\n                 determinant *= lu[i][i];\n \n     /** {@inheritDoc} */\n     public double[] solve(double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+        final int m = pivot.length;\n         if (b.length != m) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n \n     /** {@inheritDoc} */\n     public RealVector solve(RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n         try {\n             return solve((RealVectorImpl) b);\n         } catch (ClassCastException cce) {\n \n+            checkDecomposed();\n+            final int m = pivot.length;\n             if (b.getDimension() != m) {\n                 throw new IllegalArgumentException(\"constant vector has wrong length\");\n             }\n      * @throws InvalidMatrixException if decomposed matrix is singular\n      */\n     public RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n         return new RealVectorImpl(solve(b.getDataRef()), false);\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix solve(RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+        final int m = pivot.length;\n         if (b.getRowDimension() != m) {\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n     }\n \n     /**\n-     * Computes a new\n-     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n-     * <p>\n-     * <strong>Implementation Note</strong>:<br>\n-     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n-     * Crout's algorithm</a>, with partial pivoting.</p>\n-     * <p>\n-     * <strong>Usage Note</strong>:<br>\n-     * This method should rarely be invoked directly. Its only use is\n-     * to force recomputation of the LU decomposition when changes have been\n-     * made to the underlying data using direct array references. Changes\n-     * made using setXxx methods will trigger recomputation when needed\n-     * automatically.</p>\n+     * Check if either {@link #decompose(RealMatrix)} or {@link\n+     * #decompose(RealMatrix, double) has been called.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n      */\n-    private void luDecompose() {\n-\n-        // Initialize permutation array and parity\n-        for (int row = 0; row < m; row++) {\n-            pivot[row] = row;\n-        }\n-        parity = 1;\n-        singular = false;\n-\n-        // Loop over columns\n-        for (int col = 0; col < m; col++) {\n-\n-            double sum = 0;\n-\n-            // upper\n-            for (int row = 0; row < col; row++) {\n-                final double[] luRow = lu[row];\n-                sum = luRow[col];\n-                for (int i = 0; i < row; i++) {\n-                    sum -= luRow[i] * lu[i][col];\n-                }\n-                luRow[col] = sum;\n-            }\n-\n-            // lower\n-            int max = col; // permutation row\n-            double largest = Double.NEGATIVE_INFINITY;\n-            for (int row = col; row < m; row++) {\n-                final double[] luRow = lu[row];\n-                sum = luRow[col];\n-                for (int i = 0; i < col; i++) {\n-                    sum -= luRow[i] * lu[i][col];\n-                }\n-                luRow[col] = sum;\n-\n-                // maintain best permutation choice\n-                if (Math.abs(sum) > largest) {\n-                    largest = Math.abs(sum);\n-                    max = row;\n-                }\n-            }\n-\n-            // Singularity check\n-            if (Math.abs(lu[max][col]) < singularityThreshold) {\n-                singular = true;\n-                return;\n-            }\n-\n-            // Pivot if necessary\n-            if (max != col) {\n-                double tmp = 0;\n-                for (int i = 0; i < m; i++) {\n-                    tmp = lu[max][i];\n-                    lu[max][i] = lu[col][i];\n-                    lu[col][i] = tmp;\n-                }\n-                int temp = pivot[max];\n-                pivot[max] = pivot[col];\n-                pivot[col] = temp;\n-                parity = -parity;\n-            }\n-\n-            // Divide the lower elements by the \"winning\" diagonal elt.\n-            final double luDiag = lu[col][col];\n-            for (int row = col + 1; row < m; row++) {\n-                lu[row][col] /= luDiag;\n-            }\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (lu == null) {\n+            throw new IllegalStateException(\"no matrix have been decomposed yet\");\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n /**\n  * An interface to classes that implement a algorithm to calculate the \n  * QR-decomposition of a real matrix.\n- * <p>This interface is similar to the class with similar name from the now defunct\n- * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>several signatures have been added for the <code>solve</code> methods (in the superinterface),</code>\n+ *   <li>a <code>decompose</code> method has been added (in the superinterface),</code>\n+ * </ul>\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n      * Returns the matrix R of the decomposition. \n      * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getR();\n+    RealMatrix getR() throws IllegalStateException;\n \n     /**\n      * Returns the matrix Q of the decomposition.\n      * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getQ();\n+    RealMatrix getQ() throws IllegalStateException;\n \n     /**\n      * Returns the Householder reflector vectors.\n      * each successive Householder reflector vector. This matrix is used\n      * to compute Q.</p>\n      * @return a matrix containing the Householder reflector vectors\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getH();\n+    RealMatrix getH() throws IllegalStateException;\n \n     /**\n      * Check if the decomposed matrix is full rank.\n      * @return true if the decomposed matrix is full rank\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    boolean isFullRank();\n+    boolean isFullRank() throws IllegalStateException;\n \n }\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n public class QRDecompositionImpl implements QRDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 3965943878043764074L;\n+    private static final long serialVersionUID = 7125583145349720380L;\n \n     /**\n      * A packed representation of the QR decomposition. The elements above the \n      * are the Householder reflector vectors of which an explicit form of Q can\n      * be calculated. \n      */\n-    private final double[][] qr;\n-\n-    /**\n-     * The diagonal elements of R.\n-     */\n-    private final double[] rDiag;\n+    private double[][] qr;\n+\n+    /** The diagonal elements of R. */\n+    private double[] rDiag;\n \n     /** Cached value of Q. */\n     private RealMatrix cachedQ;\n     private RealMatrix cachedH;\n \n     /**\n-     * The row dimension of the given matrix. The size of Q will be m x m, the \n-     * size of R will be m x n. \n+     * Build a new instance.\n+     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n+     * before any of the {@link #getQ()}, {@link #getR()}, {@link #getH()},\n+     * {@link #isFullRank()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n+     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n+     * called.</p>\n+     * @see #decompose(RealMatrix)\n      */\n-    private final int m;\n+    public QRDecompositionImpl() {\n+    }\n \n     /**\n-     * The column dimension of the given matrix. The size of R will be m x n. \n+     * Calculates the QR-decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException if matrix is not square\n      */\n-    private final int n;\n-\n-    /**\n-     * Calculates the QR decomposition of the given matrix. \n-     * \n-     * @param matrix The matrix to decompose.\n-     */\n-    public QRDecompositionImpl(RealMatrix matrix) {\n-        m = matrix.getRowDimension();\n-        n = matrix.getColumnDimension();\n+    public QRDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix) {\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n         qr = matrix.getData();\n         rDiag = new double[n];\n         cachedQ = null;\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getR() {\n+    public RealMatrix getR()\n+        throws IllegalStateException {\n \n         if (cachedR == null) {\n \n+            checkDecomposed();\n+\n             // R is supposed to be m x n\n+            final int m = qr.length;\n+            final int n = qr[0].length;\n             double[][] r = new double[m][n];\n \n             // copy the diagonal from rDiag and the upper triangle of qr\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getQ() {\n+    public RealMatrix getQ()\n+        throws IllegalStateException {\n \n         if (cachedQ == null) {\n \n+            checkDecomposed();\n+\n             // Q is supposed to be m x m\n+            final int m = qr.length;\n+            final int n = qr[0].length;\n             double[][] Q = new double[m][m];\n \n             /* \n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getH() {\n+    public RealMatrix getH()\n+        throws IllegalStateException {\n+\n         if (cachedH == null) {\n \n+            checkDecomposed();\n+\n+            final int m = qr.length;\n+            final int n = qr[0].length;\n             double[][] hData = new double[m][n];\n             for (int i = 0; i < m; ++i) {\n                 for (int j = 0; j < Math.min(i + 1, n); ++j) {\n     }\n \n     /** {@inheritDoc} */\n-    public boolean isFullRank() {\n+    public boolean isFullRank()\n+        throws IllegalStateException {\n+\n+        checkDecomposed();\n+\n         for (double diag : rDiag) {\n             if (diag == 0) {\n                 return false;\n             }\n         }\n         return true;\n+\n     }\n \n     /** {@inheritDoc} */\n     public double[] solve(double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n  \n-            if (b.length != m) {\n-                throw new IllegalArgumentException(\"Incorrect row dimension\");\n-            }\n-            if (!isFullRank()) {\n-                throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n-            }\n-\n-            final double[] x = new double[n];\n-            final double[] y = b.clone();\n-\n-            // apply Householder transforms to solve Q.y = b\n-            for (int minor = 0; minor < Math.min(m, n); minor++) {\n-\n-                double dotProduct = 0;\n-                for (int row = minor; row < m; row++) {\n-                    dotProduct += y[row] * qr[row][minor];\n-                }\n-                dotProduct /= rDiag[minor] * qr[minor][minor];\n-\n-                for (int row = minor; row < m; row++) {\n-                    y[row] += dotProduct * qr[row][minor];\n-                }\n-\n-            }\n-\n-            // solve triangular system R.x = y\n-            for (int row = n - 1; row >= 0; --row) {\n-                y[row] /= rDiag[row];\n-                final double yRow = y[row];\n-                x[row] = yRow;\n-                for (int i = 0; i < row; i++) {\n-                    y[i] -= yRow * qr[i][row];\n-                }\n-            }\n-\n-            return x;\n+        checkDecomposed();\n+\n+        final int m = qr.length;\n+        final int n = qr[0].length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!isFullRank()) {\n+            throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n+        }\n+\n+        final double[] x = new double[n];\n+        final double[] y = b.clone();\n+\n+        // apply Householder transforms to solve Q.y = b\n+        for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+            double dotProduct = 0;\n+            for (int row = minor; row < m; row++) {\n+                dotProduct += y[row] * qr[row][minor];\n+            }\n+            dotProduct /= rDiag[minor] * qr[minor][minor];\n+\n+            for (int row = minor; row < m; row++) {\n+                y[row] += dotProduct * qr[row][minor];\n+            }\n+\n+        }\n+\n+        // solve triangular system R.x = y\n+        for (int row = n - 1; row >= 0; --row) {\n+            y[row] /= rDiag[row];\n+            final double yRow = y[row];\n+            x[row] = yRow;\n+            for (int i = 0; i < row; i++) {\n+                y[i] -= yRow * qr[i][row];\n+            }\n+        }\n+\n+        return x;\n \n     }\n \n     /** {@inheritDoc} */\n     public RealVector solve(RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n         try {\n             return solve((RealVectorImpl) b);\n         } catch (ClassCastException cce) {\n+            checkDecomposed();\n             return new RealVectorImpl(solve(b.getData()), false);\n         }\n     }\n      * <p>The A matrix is implicit here. It is </p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n      * @throws IllegalArgumentException if matrices dimensions don't match\n      * @throws InvalidMatrixException if decomposed matrix is singular\n      */\n     public RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n         return new RealVectorImpl(solve(b.getDataRef()), false);\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix solve(RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+\n+        final int m = qr.length;\n+        final int n = qr[0].length;\n         if (b.getRowDimension() != m) {\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n \n     }\n \n+    /**\n+     * Check if {@link #decompose(RealMatrix)} has been called.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     */\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (qr == null) {\n+            throw new IllegalStateException(\"no matrix have been decomposed yet\");\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n         }\n     }\n \n+    /** test no call to decompose */\n+    public void testNoDecompose() {\n+        try {\n+            new LUDecompositionImpl().getPivot();\n+            fail(\"an exception should have been caught\");\n+        } catch (IllegalStateException ise) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test threshold impact */\n+    public void testThreshold() {\n+        final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n+                                                       { 1.0, 2.0, 3.0},\n+                                                       { 2.0, 5.0, 3.0},\n+                                                       { 4.000001, 9.0, 9.0}\n+                                                     }, false);\n+        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).isNonSingular());\n+        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).isNonSingular());\n+    }\n+\n     /** test PA = LU */\n     public void testPAEqualLU() {\n         RealMatrix matrix = new RealMatrixImpl(testData, false);\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n         \n     }\n \n+    /** test no call to decompose */\n+    public void testNoDecompose() {\n+        try {\n+            new QRDecompositionImpl().isFullRank();\n+            fail(\"an exception should have been caught\");\n+        } catch (IllegalStateException ise) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n }", "timestamp": 1220221735, "metainfo": ""}