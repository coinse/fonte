{"sha": "7dcff7b38d6d987aef7307bd0ae775224020e251", "log": "added (at least!) a first implementation of singular value decomposition. JIRA: MATH-157, MATH-220, MATH-233  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.ConvergenceException;\n \n /**\n  * An interface to classes that implement an algorithm to calculate the \n  *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n  *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n  *   method has been added (in the superinterface),</li>\n- *   <li>a {@link #decompose(RealMatrix, int) decompose(RealMatrix), int)} method\n- *   has been added,</li>\n  *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n  *   been added (in the superinterface),</li>\n  *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n public interface SingularValueDecomposition extends DecompositionSolver {\n \n     /**\n-     * Decompose a matrix to find its largest singular values.\n-     * @param matrix matrix to decompose\n-     * @param maxSingularValues maximal number of singular values to compute\n-     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n-     * if algorithm fails to converge\n-     */\n-    void decompose(RealMatrix matrix, int maxSingularValues)\n-      throws InvalidMatrixException;\n-\n-    /**\n      * Returns the matrix U of the decomposition. \n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getUT()\n      */\n     RealMatrix getU() throws IllegalStateException;\n \n     /**\n+     * Returns the transpose of the matrix U of the decomposition. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getU()\n+     */\n+    RealMatrix getUT() throws IllegalStateException;\n+\n+    /**\n      * Returns the diagonal matrix &Sigma; of the decomposition. \n-     * <p>&Sigma; is a diagonal matrix.</p>\n+     * <p>&Sigma; is a diagonal matrix. The singular values are provided in\n+     * non-increasing order, for compatibility with Jama.</p>\n      * @return the &Sigma; matrix\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     RealMatrix getS() throws IllegalStateException;\n \n     /**\n-     * Returns the diagonal elements of the matrix &Sigma; of the decomposition. \n+     * Returns the diagonal elements of the matrix &Sigma; of the decomposition.\n+     * <p>The singular values are provided in non-increasing order, for\n+     * compatibility with Jama.</p>\n      * @return the diagonal elements of the &Sigma; matrix\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     double[] getSingularValues() throws IllegalStateException;\n \n      * Returns the matrix V of the decomposition. \n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getVT()\n      */\n     RealMatrix getV() throws IllegalStateException;\n+\n+    /**\n+     * Returns the transpose of the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getV()\n+     */\n+    RealMatrix getVT() throws IllegalStateException;\n \n     /**\n      * Returns the L<sub>2</sub> norm of the matrix.\n      * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm\n      * (i.e. the traditional euclidian norm).</p>\n      * @return norm\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     double getNorm() throws IllegalStateException;\n \n     /**\n      * Return the condition number of the matrix.\n      * @return condition number of the matrix\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     double getConditionNumber() throws IllegalStateException;\n \n      * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)\n      * is the least significant bit of the largest singular value.</p>\n      * @return effective numerical matrix rank\n-     * @exception IllegalStateException if neither {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n-     * #decompose(RealMatrix, int)} have not been called\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     int getRank() throws IllegalStateException;\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Calculates the Singular Value Decomposition of a matrix.\n+ * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n+ * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then U is an m &times; m orthogonal matrix,\n+ * &Sigma; is a m &times; n diagonal matrix with positive diagonal elements,\n+ * and V is an n &times; n orthogonal matrix.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2357152028714378552L;\n+\n+    /** Number of rows of the initial matrix. */\n+    private int m;\n+\n+    /** Number of columns of the initial matrix. */\n+    private int n;\n+\n+    /** Transformer to bidiagonal. */\n+    private BiDiagonalTransformer transformer;\n+\n+    /** Main diagonal of the bidiagonal matrix. */\n+    private double[] mainBidiagonal;\n+\n+    /** Secondary diagonal of the bidiagonal matrix. */\n+    private double[] secondaryBidiagonal;\n+\n+    /** Main diagonal of the tridiagonal matrix. */\n+    double[] mainTridiagonal;\n+\n+    /** Secondary diagonal of the tridiagonal matrix. */\n+    double[] secondaryTridiagonal;\n+\n+    /** Eigen decomposition of the tridiagonal matrix. */\n+    private EigenDecomposition eigenDecomposition;\n+\n+    /** Singular values. */\n+    private double[] singularValues;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of U<sup>T</sup>. */\n+    private RealMatrix cachedUt;\n+\n+    /** Cached value of S. */\n+    private RealMatrix cachedS;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /** Cached value of V<sup>T</sup>. */\n+    private RealMatrix cachedVt;\n+\n+    /**\n+     * Build a new instance.\n+     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n+     * before any of the {@link #getU()}, {@link #getS()}, {@link #getV()},\n+     * {@link #getSingularValues()}, {@link #getNorm()}, {@link #getConditionNumber()},\n+     * {@link #getRank()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n+     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n+     * called.</p>\n+     * @see #decompose(RealMatrix)\n+     */\n+    public SingularValueDecompositionImpl() {\n+    }\n+\n+    /**\n+     * Calculates the Singular Value Decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(final RealMatrix matrix) {\n+\n+        m = matrix.getRowDimension();\n+        n = matrix.getColumnDimension();\n+\n+        cachedU  = null;\n+        cachedS  = null;\n+        cachedV  = null;\n+        cachedVt = null;\n+\n+        // transform the matrix to bidiagonal\n+        transformer         = new BiDiagonalTransformer(matrix);\n+        mainBidiagonal      = transformer.getMainDiagonalRef();\n+        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n+\n+        // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)\n+        mainTridiagonal      = new double[mainBidiagonal.length];\n+        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n+        double a = mainBidiagonal[0];\n+        mainTridiagonal[0] = a * a;\n+        for (int i = 1; i < mainBidiagonal.length; ++i) {\n+            final double b  = secondaryBidiagonal[i - 1];\n+            secondaryTridiagonal[i - 1] = a * b;\n+            a = mainBidiagonal[i];\n+            mainTridiagonal[i] = a * a + b * b;\n+        }\n+\n+        // compute singular values\n+        eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal);\n+        singularValues = eigenDecomposition.getEigenvalues();\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            singularValues[i] = Math.sqrt(singularValues[i]);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getU()\n+        throws InvalidMatrixException {\n+\n+        if (cachedU == null) {\n+\n+            checkDecomposed();\n+\n+            if (m >= n) {\n+                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n+                final double[][] eData = eigenDecomposition.getV().getData();\n+                final double[][] iData = new double[m][];\n+                double[] ei1 = eData[0];\n+                iData[0] = ei1;\n+                for (int i = 0; i < n - 1; ++i) {\n+                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n+                    // we reuse the array from matrix E to store the result \n+                    final double[] ei0 = ei1;\n+                    ei1 = eData[i + 1];\n+                    iData[i + 1] = ei1;\n+                    for (int j = 0; j < n; ++j) {\n+                        ei0[j] = (mainBidiagonal[i] * ei0[j] +\n+                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];\n+                    }\n+                }\n+                // last row\n+                final double lastMain = mainBidiagonal[n - 1];\n+                for (int j = 0; j < n; ++j) {\n+                    ei1[j] *= lastMain / singularValues[j];\n+                }\n+                for (int i = n; i < m; ++i) {\n+                    iData[i] = new double[n];\n+                }\n+                cachedU =\n+                    transformer.getU().multiply(new RealMatrixImpl(iData, false));\n+            } else {\n+                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n+                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getUT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedUt == null) {\n+            cachedUt = getU().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedUt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getS()\n+        throws InvalidMatrixException {\n+\n+        if (cachedS == null) {\n+\n+            checkDecomposed();\n+\n+            final int p = singularValues.length;\n+            final double[][] sData = new double[p][p];\n+            for (int i = 0; i < p; ++i) {\n+                sData[i][i] = singularValues[i];\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedS = new RealMatrixImpl(sData, false);\n+\n+        }\n+        return cachedS;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getSingularValues()\n+        throws InvalidMatrixException {\n+        checkDecomposed();\n+        return singularValues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getV()\n+        throws InvalidMatrixException {\n+\n+        if (cachedV == null) {\n+\n+            checkDecomposed();\n+\n+            if (m >= n) {\n+                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n+                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+            } else {\n+                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n+                final double[][] eData = eigenDecomposition.getV().getData();\n+                final double[][] iData = new double[n][];\n+                double[] ei1 = eData[0];\n+                iData[0] = ei1;\n+                for (int i = 0; i < m - 1; ++i) {\n+                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n+                    // we reuse the array from matrix E to store the result \n+                    final double[] ei0 = ei1;\n+                    ei1 = eData[i + 1];\n+                    iData[i + 1] = ei1;\n+                    for (int j = 0; j < m; ++j) {\n+                        ei0[j] = (mainBidiagonal[i] * ei0[j] +\n+                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];\n+                    }\n+                }\n+                // last row\n+                final double lastMain = mainBidiagonal[m - 1];\n+                for (int j = 0; j < m; ++j) {\n+                    ei1[j] *= lastMain / singularValues[j];\n+                }\n+                for (int i = m; i < n; ++i) {\n+                    iData[i] = new double[m];\n+                }\n+                cachedV =\n+                    transformer.getV().multiply(new RealMatrixImpl(iData, false));\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getVT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedVt == null) {\n+            cachedVt = getV().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedVt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm()\n+        throws InvalidMatrixException {\n+        checkDecomposed();\n+        return singularValues[0];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getConditionNumber()\n+        throws InvalidMatrixException {\n+        checkDecomposed();\n+        return singularValues[0] / singularValues[singularValues.length - 1];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getRank()\n+        throws IllegalStateException {\n+\n+        checkDecomposed();\n+\n+        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n+\n+        for (int i = singularValues.length - 1; i >= 0; --i) {\n+           if (singularValues[i] > threshold) {\n+              return i + 1;\n+           }\n+        }\n+        return 0;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+        return getRank() == singularValues.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] w = getUT().operate(b);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            w[i] /= si;\n+        }\n+        return getV().operate(w);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            checkDecomposed();\n+\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final RealVector w = getUT().operate(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                w.set(i, w.getEntry(i) / si);\n+            }\n+            return getV().operate(w);\n+\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X such that A &times; X = B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(final RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final RealMatrixImpl w = (RealMatrixImpl) getUT().multiply(b);\n+        final double[][] wData = w.getDataRef();\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si  = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            final double inv = 1.0 / si;\n+            final double[] wi = wData[i];\n+            for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                wi[j] *= inv;\n+            }\n+        }\n+        return getV().multiply(w);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+        checkDecomposed();\n+        return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n+    }\n+\n+    /**\n+     * Check if {@link #decompose(RealMatrix)} has been called.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     */\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (singularValues == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class SingularValueDecompositionImplTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public SingularValueDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SingularValueDecompositionImplTest.class);\n+        suite.setName(\"SingularValueDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testMoreRows() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length + 2;\n+        final int columns = singularValues.length;\n+        Random r = new Random(15338437322523l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testMoreColumns() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length;\n+        final int columns = singularValues.length + 2;\n+        Random r = new Random(732763225836210l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testSquare, false);\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n+        assertEquals(m, svd.getU().getRowDimension());\n+        assertEquals(m, svd.getU().getColumnDimension());\n+        assertEquals(m, svd.getS().getColumnDimension());\n+        assertEquals(n, svd.getS().getColumnDimension());\n+        assertEquals(n, svd.getV().getRowDimension());\n+        assertEquals(n, svd.getV().getColumnDimension());\n+\n+    }\n+\n+    /** test A = USVt */\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(new RealMatrixImpl(testSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());\n+    }\n+\n+    public void checkAEqualUSVt(final RealMatrix matrix) {\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);\n+        RealMatrix u = svd.getU();\n+        RealMatrix s = svd.getS();\n+        RealMatrix v = svd.getV();\n+        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+    }\n+\n+    /** test that U is orthogonal */\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false)).getU());\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false).transpose()).getU());\n+    }\n+\n+    /** test that V is orthogonal */\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false)).getV());\n+        checkOrthogonal(new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false).transpose()).getV());\n+    }\n+\n+    public void checkOrthogonal(final RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+        try {\n+            svd.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            svd.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            svd.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(new double[][] {\n+                                                                      { 1.0, 0.0 },\n+                                                                      { 0.0, 0.0 }\n+                                                                  }, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            svd.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            svd.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            svd.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            svd.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1, 2, 3 }, { 0, -5, 1 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },\n+                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, svd.solve(b).subtract(xRef).getNorm(), normTolerance);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(svd.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealMatrixImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         svd.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         svd.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                { 3.0 / 5.0, -4.0 / 5.0 },\n+                { 4.0 / 5.0,  3.0 / 5.0 }\n+        });\n+        RealMatrix sRef = new RealMatrixImpl(new double[][] {\n+                { 3.0, 0.0 },\n+                { 0.0, 1.0 }\n+        });\n+        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+                { 4.0 / 5.0,  3.0 / 5.0 },\n+                { 3.0 / 5.0, -4.0 / 5.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = svd.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == svd.getU());\n+        assertTrue(s == svd.getS());\n+        assertTrue(v == svd.getV());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },\n+            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },\n+            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },\n+            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }\n+        });\n+        RealMatrix sRef = new RealMatrixImpl(new double[][] {\n+            { 4.0, 0.0, 0.0 },\n+            { 0.0, 3.0, 0.0 },\n+            { 0.0, 0.0, 2.0 }\n+        });\n+        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },\n+            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },\n+            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }\n+        });\n+\n+        // check values against known references\n+        SingularValueDecomposition svd = new SingularValueDecompositionImpl();\n+        svd.decompose(new RealMatrixImpl(testNonSquare, false));\n+        RealMatrix u = svd.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == svd.getU());\n+        assertTrue(s == svd.getS());\n+        assertTrue(v == svd.getV());\n+\n+    }\n+\n+    /** test condition number */\n+    public void testConditionNumber() {\n+        SingularValueDecompositionImpl svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,\n+                                        final double[] singularValues) {\n+        final RealMatrix u =\n+            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);\n+        final RealMatrix d =\n+            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);\n+        final RealMatrix v =\n+            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);\n+        return u.multiply(d).multiply(v);\n+    }\n+\n+}", "timestamp": 1228405604, "metainfo": ""}