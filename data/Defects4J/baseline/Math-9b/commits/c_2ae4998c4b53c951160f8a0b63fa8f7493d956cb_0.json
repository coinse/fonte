{"sha": "2ae4998c4b53c951160f8a0b63fa8f7493d956cb", "log": "Changed implementation to use TreeMap directly, eliminating [collections] depenency.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n package org.apache.commons.math.stat;\n \n import java.io.Serializable;\n+import java.text.NumberFormat;\n import java.util.Iterator;\n import java.util.Comparator;\n-import java.text.NumberFormat;\n-\n-import org.apache.commons.collections.ComparatorUtils;\n-import org.apache.commons.collections.SortedBag;\n-import org.apache.commons.collections.bag.TreeBag;\n+import java.util.TreeMap;\n \n /** \n  * Maintains a frequency distribution.\n  * <p>\n- * Accepts int, long, char or Object values.  New values added must be comparable to \n- * those that have been added, otherwise the add method will throw an IllegalArgumentException.\n- * The values are ordered using the default (natural order), unless a  <code>Comparator</code>\n- * is supplied in the constructor.\n+ * Accepts int, long, char or Object values.  New values added must be \n+ * comparable to those that have been added, otherwise the add method will \n+ * throw an IllegalArgumentException.  \n+ * <p>\n+ * Integer values (int, long, Integer, Long) are not distinguished by type -- \n+ * i.e. <code>addValue(new Long(2)), addValue(2), addValue(2l)</code> all have\n+ * the same effect (similarly for arguments to <code>getCount,</code> etc.).\n+ * <p>\n+ * The values are ordered using the default (natural order), unless a  \n+ * <code>Comparator</code>is supplied in the constructor.\n  * \n- * @version $Revision: 1.22 $ $Date: 2004/06/02 00:24:52 $\n+ * @version $Revision: 1.23 $ $Date: 2004/06/20 16:53:17 $\n  */\n public class Frequency implements Serializable {\n     \n     static final long serialVersionUID = -3845586908418844111L;\n \n     /** underlying collection */\n-    private SortedBag freqTable = null;\n+    private TreeMap freqTable = null;\n \n     /**\n      * Default constructor.\n      */\n     public Frequency() {\n-        freqTable = new TreeBag();\n+        freqTable = new TreeMap();\n     }\n     \n     /**\n      * Constructor allowing values Comparator to be specified.\n+     * \n      * @param comparator Comparator used to order values\n      */\n     public Frequency(Comparator comparator) {\n-        freqTable = new TreeBag(comparator);\n+        freqTable = new TreeMap(comparator);\n     }\n \n     /**\n      * Return a string representation of this frequency\n      * distribution.\n+     * \n      * @return a string representation.\n      */\n     public String toString() {\n         NumberFormat nf = NumberFormat.getPercentInstance();\n         StringBuffer outBuffer = new StringBuffer();\n         outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n-        Iterator iter = freqTable.uniqueSet().iterator();\n+        Iterator iter = freqTable.keySet().iterator();\n         while (iter.hasNext()) {\n             Object value = iter.next();\n             outBuffer.append(value);\n     }\n \n     /**\n-     * Adds 1 to the frequency count for v\n+     * Adds 1 to the frequency count for v.\n+     * \n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable.\n      */\n     public void addValue(Object v) {\n         try {\n-            freqTable.add(v);\n+            Long count = (Long) freqTable.get(v);\n+            if (count == null) {\n+                freqTable.put(v, new Long(1));\n+            } else {\n+                freqTable.put(v, new Long(count.longValue() + 1));\n+            }\n         } catch (ClassCastException ex) {   \n-            //TreeBag will throw ClassCastException if v is not comparable\n+            //TreeMap will throw ClassCastException if v is not comparable\n             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n         }\n     }\n \n     /**\n-     * Adds 1 to the frequency count for v\n+     * Adds 1 to the frequency count for v.\n+     * \n      * @param v the value to add.\n      */\n     public void addValue(int v) {\n \n     /**\n      * Adds 1 to the frequency count for v.\n+     * \n      * @param v the value to add.\n      */\n     public void addValue(long v) {\n     \n     /**\n      * Adds 1 to the frequency count for v.\n+     * \n      * @param v the value to add.\n      */\n     public void addValue(char v) {\n     \n     /**\n      * Returns an Iterator over the set of values that have been added.\n+     * \n      * @return values Iterator\n      */\n     public Iterator valuesIterator() {\n-        return freqTable.uniqueSet().iterator();\n+        return freqTable.keySet().iterator();\n     }\n     \n     //-------------------------------------------------------------------------\n     \n     /**\n-     * Returns the sum of all frequencies\n+     * Returns the sum of all frequencies.\n+     * \n      * @return the total frequency count.\n      */\n     public long getSumFreq() {\n-        return freqTable.size();\n-    }\n-\n-    /**\n-     * Returns the number of values = v\n+        long result = 0;\n+        Iterator iterator = freqTable.values().iterator();\n+        while (iterator.hasNext())  {\n+            result += ((Long) iterator.next()).longValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the number of values = v.\n+     * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(Object v) {\n         long result = 0;\n         try { \n-            result = freqTable.getCount(v);\n+            Long count =  (Long) freqTable.get(v);\n+            if (count != null) {\n+                result = count.longValue();\n+            }\n         } catch (ClassCastException ex) {\n             // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n         }\n     }\n \n     /**\n-     * Returns the number of values = v\n+     * Returns the number of values = v.\n+     * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(int v) {\n-        long result = 0;\n-        try { \n-            result = freqTable.getCount(new Long(v));\n-        } catch (ClassCastException ex) {\n-            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n-        }\n-        return result;\n-    }\n-    \n-    /**\n-     * Returns the number of values = v\n+        return getCount(new Long(v));\n+    }\n+    \n+    /**\n+     * Returns the number of values = v.\n+     * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(long v) {\n-        long result = 0;\n-        try { \n-            result = freqTable.getCount(new Long(v));\n-        } catch (ClassCastException ex) {\n-            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n-        }\n-        return result;\n-    }\n-    \n-    /**\n-     * Returns the number of values = v\n+        return getCount(new Long(v));\n+    }\n+    \n+    /**\n+     * Returns the number of values = v.\n+     * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(char v) {\n-        long result = 0;\n-        try { \n-            result = freqTable.getCount(new Character(v));\n-        } catch (ClassCastException ex) {\n-            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n-        }\n-        return result;\n+        return getCount(new Character(v));\n     }\n     \n     //-------------------------------------------------------------\n     /**\n       * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * @param v the value to lookup.\n+     * \n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(Object v) {\n     /**\n       * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * @param v the value to lookup.\n+     * \n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(int v) {\n     /**\n       * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * @param v the value to lookup.\n+     * \n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(long v) {\n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * @param v the value to lookup.\n+     * \n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(char v) {\n     public long getCumFreq(Object v) {\n         Comparator c = freqTable.comparator();\n         if (c == null) {\n-            c = ComparatorUtils.NATURAL_COMPARATOR;\n+            c = new NaturalComparator();\n         }\n         long result = 0;\n+        \n         try {\n-            result = freqTable.getCount(v);\n+            Long value = (Long) freqTable.get(v);\n+            if (value != null) {\n+                result = value.longValue();\n+            }\n         } catch (ClassCastException ex) {\n             return result;   // v is not comparable\n         }\n-        if (c.compare(v, freqTable.first()) < 0) {\n+        \n+        if (c.compare(v, freqTable.firstKey()) < 0) {\n             return 0;  // v is comparable, but less than first value\n         }\n-        if (c.compare(v, freqTable.last()) >= 0) {\n+        \n+        if (c.compare(v, freqTable.lastKey()) >= 0) {\n             return getSumFreq();    // v is comparable, but greater than the last value\n         }\n+        \n         Iterator values = valuesIterator();\n         while (values.hasNext()) {\n             Object nextValue = values.next();\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(int v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(long v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(char v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(Object v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(int v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(long v) {\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n-     * @param v the value to lookup.\n+     * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(char v) {\n         return getCumPct(new Character(v));         \n     }\n+    \n+    /**\n+     * A Comparator that compares comparable objects using the\n+     * natural order.  Copied from Commons Collections ComparableComparator.\n+     */\n+    private class NaturalComparator implements Comparator {\n+        /**\n+         * Compare the two {@link Comparable Comparable} arguments.\n+         * This method is equivalent to:\n+         * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n+         * \n+         * @param  o1 the first object \n+         * @param  o2 the second object\n+         * @return  result of comparison\n+         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n+         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n+         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n+         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n+         */\n+        public int compare(Object o1, Object o2) {\n+            return ((Comparable)o1).compareTo(o2);\n+        }\n+    }\n }", "timestamp": 1087750397, "metainfo": ""}