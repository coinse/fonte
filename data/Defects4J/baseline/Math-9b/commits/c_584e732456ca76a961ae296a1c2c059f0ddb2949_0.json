{"sha": "584e732456ca76a961ae296a1c2c059f0ddb2949", "log": "Greatly improved multiplication speed for sparse matrices Jira: MATH-248  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n \n     /** {@inheritDoc} */\n     @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((SparseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final int outCols = m.getColumnDimension();\n+            final DenseRealMatrix out = new DenseRealMatrix(rowDimension, outCols);\n+            for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+                iterator.advance();\n+                final double value = iterator.value();\n+                final int key      = iterator.key();\n+                final int i        = key / columnDimension;\n+                final int k        = key % columnDimension;\n+                for (int j = 0; j < outCols; ++j) {\n+                    out.addToEntry(i, j, value * m.getEntry(k, j));\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public SparseRealMatrix multiply(SparseRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int outCols = m.getColumnDimension();\n+        SparseRealMatrix out = new SparseRealMatrix(rowDimension, outCols);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final double value = iterator.value();\n+            final int key      = iterator.key();\n+            final int i        = key / columnDimension;\n+            final int k        = key % columnDimension;\n+            for (int j = 0; j < outCols; ++j) {\n+                final int rightKey = m.computeKey(k, j);\n+                if (m.entries.containsKey(rightKey)) {\n+                    final int outKey = out.computeKey(i, j);\n+                    final double outValue =\n+                        out.entries.get(outKey) + value * m.entries.get(rightKey);\n+                    if (outValue == 0.0) {\n+                        out.entries.remove(outKey);\n+                    } else {\n+                        out.entries.put(outKey, outValue);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n     public double getEntry(int row, int column) throws MatrixIndexException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n--- a/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n  */\n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.linear.decomposition.LUDecompositionImpl;\n-import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n-\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.decomposition.LUDecompositionImpl;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link SparseRealMatrix} class.\n         SparseRealMatrix m2 = createSparseMatrix(testData2);\n         assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n                 entryTolerance);\n+        assertClose(\"inverse multiply\", m.multiply(new DenseRealMatrix(testDataInv)), identity,\n+                    entryTolerance);\n         assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n                 entryTolerance);\n         assertClose(\"identity multiply\", m.multiply(identity), m,", "timestamp": 1238950415, "metainfo": ""}