{"sha": "8b72006be46b68085b3cac5c65b810bc273bf5df", "log": "- Changed enum FastFourierTransformer.DftNormalization to top-level enumeration (MATH-743). - Moved part of the Javadoc of FastFourierTransformer to this new enum.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/DftNormalization.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+/**\n+ * This enumeration defines the various types of normalizations that can be\n+ * applied to discrete Fourier transforms (DFT). The exact definition of these\n+ * normalizations is detailed below.\n+ *\n+ * @see FastFourierTransformer\n+ * @version $Id Revision$\n+ * @since 3.0\n+ */\n+public enum DftNormalization {\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of e.g.\n+     * {@link FastFourierTransformer} to use the <em>standard</em> normalization\n+     * convention. This normalization convention is defined as follows\n+     * <ul>\n+     * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n+     * <li>inverse transform: x<sub>k</sub> = N<sup>-1</sup>\n+     * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n+     * </ul>\n+     * where N is the size of the data sample.\n+     * </p>\n+     */\n+    STANDARD,\n+\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of e.g.\n+     * {@link FastFourierTransformer} to use the <em>unitary</em> normalization\n+     * convention. This normalization convention is defined as follows\n+     * <ul>\n+     * <li>forward transform: y<sub>n</sub> = (1 / &radic;N)\n+     * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub>\n+     * exp(-2&pi;i n k / N),</li>\n+     * <li>inverse transform: x<sub>k</sub> = (1 / &radic;N)\n+     * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n+     * </ul>\n+     * which makes the transform unitary. N is the size of the data sample.\n+     * </p>\n+     */\n+    UNITARY;\n+}\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  * </p>\n  * <p>\n  * There are several variants of the discrete Fourier transform, with various\n- * normalization conventions, which are described below.\n+ * normalization conventions, which are specified by the parameter\n+ * {@link DftNormalization}.\n  * </p>\n  * <p>\n  * The current implementation of the discrete Fourier transform as a fast\n  * <i>On computing the discrete Fourier transform</i>, Mathematics of\n  * Computation, 32 (1978), 175 - 199.\n  * </p>\n- * <h3><a id=\"standard\">Standard DFT</a></h3>\n- * <p>\n- * The standard normalization convention is defined as follows\n- * <ul>\n- * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n- * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n- * <li>inverse transform: x<sub>k</sub> = N<sup>-1</sup>\n- * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n- * </ul>\n- * where N is the size of the data sample.\n- * </p>\n- * <p>\n- * {@link FastFourierTransformer}s following this convention are returned by the\n- * factory method {@link #create()}.\n- * </p>\n- * <h3><a id=\"unitary\">Unitary DFT</a></h3>\n- * <p>\n- * The unitary normalization convention is defined as follows\n- * <ul>\n- * <li>forward transform: y<sub>n</sub> = (1 / &radic;N)\n- * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n- * <li>inverse transform: x<sub>k</sub> = (1 / &radic;N)\n- * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n- * </ul>\n- * which makes the transform unitary. N is the size of the data sample.\n- * </p>\n- * <p>\n- * {@link FastFourierTransformer}s following this convention are returned by the\n- * factory method {@link #createUnitary()}.\n- * </p>\n  *\n+ * @see DftNormalization\n  * @version $Id$\n  * @since 1.2\n  */\n public class FastFourierTransformer implements Serializable {\n-\n-    /**\n-     * The various types of normalizations that can be applied to discrete\n-     * Fourier transforms.\n-     *\n-     * @see FastFourierTransformer\n-     */\n-    public static enum DftNormalization {\n-        /** The normalization to be specified for standard DFT. */\n-        STANDARD,\n-\n-        /** The normalization to be specified for unitary DFT. */\n-        UNITARY;\n-    }\n \n     /** Serializable version identifier. */\n     static final long serialVersionUID = 20120210L;\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n-import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     public void testTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n     public void testTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n     public void testTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n     public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n     public void testTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n     }\n \n     private static void doTestTransformComplex(final int n, final double tol,\n-        final FastFourierTransformer.DftNormalization normalization,\n+        final DftNormalization normalization,\n         final TransformType type) {\n         final FastFourierTransformer fft;\n         fft = new FastFourierTransformer(normalization);\n         final double s;\n         if (type==TransformType.FORWARD) {\n             expected = dft(x, -1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD){\n+            if (normalization == DftNormalization.STANDARD){\n                 s = 1.0;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n             }\n         } else {\n             expected = dft(x, 1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+            if (normalization == DftNormalization.STANDARD) {\n                 s = 1.0 / n;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n     }\n \n     private static void doTestTransformReal(final int n, final double tol,\n-        final FastFourierTransformer.DftNormalization normalization,\n+        final DftNormalization normalization,\n         final TransformType type) {\n         final FastFourierTransformer fft;\n         fft = new FastFourierTransformer(normalization);\n         final double s;\n         if (type == TransformType.FORWARD) {\n             expected = dft(xc, -1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+            if (normalization == DftNormalization.STANDARD) {\n                 s = 1.0;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n             }\n         } else {\n             expected = dft(xc, 1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+            if (normalization == DftNormalization.STANDARD) {\n                 s = 1.0 / n;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n \n     private static void doTestTransformFunction(final UnivariateFunction f,\n         final double min, final double max, int n, final double tol,\n-        final FastFourierTransformer.DftNormalization normalization,\n+        final DftNormalization normalization,\n         final TransformType type) {\n         final FastFourierTransformer fft;\n         fft = new FastFourierTransformer(normalization);\n         final double s;\n         if (type == TransformType.FORWARD) {\n             expected = dft(x, -1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+            if (normalization == DftNormalization.STANDARD) {\n                 s = 1.0;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n             }\n         } else {\n             expected = dft(x, 1);\n-            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+            if (normalization == DftNormalization.STANDARD) {\n                 s = 1.0 / n;\n             } else {\n                 s = 1.0 / FastMath.sqrt(n);\n \n     @Test\n     public void testTransformComplex() {\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n \n     @Test\n     public void testStandardTransformReal() {\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {\n         final UnivariateFunction f = new Sinc();\n         final double min = -FastMath.PI;\n         final double max = FastMath.PI;\n-        final FastFourierTransformer.DftNormalization[] norm;\n-        norm = FastFourierTransformer.DftNormalization.values();\n+        final DftNormalization[] norm;\n+        norm = DftNormalization.values();\n         final TransformType[] type;\n         type = TransformType.values();\n         for (int i = 0; i < norm.length; i++) {", "timestamp": 1328941455, "metainfo": ""}