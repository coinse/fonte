{"sha": "7ec3424a828f5619df7eeb40f7d2f35cda3c015a", "log": "MATH-406 corrected  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n     /** Current residuals. */\n     protected double[] residuals;\n+    \n+    /** Weighted Jacobian */\n+    protected double[][] wjacobian;\n+    \n+    /** Weighted residuals */\n+    protected double[] wresiduals;\n \n     /** Cost value (square root of the sum of the residuals). */\n     protected double cost;\n         }\n         for (int i = 0; i < rows; i++) {\n             final double[] ji = jacobian[i];\n-            final double factor = -Math.sqrt(residualsWeights[i]);\n+            double wi = Math.sqrt(residualsWeights[i]);\n             for (int j = 0; j < cols; ++j) {\n-                ji[j] *= factor;\n+                ji[j] *=  -1.0;\n+                wjacobian[i][j] = ji[j]*wi;\n             }\n         }\n     }\n         for (int i = 0; i < rows; i++) {\n             final double residual = targetValues[i] - objective[i];\n             residuals[i] = residual;\n+            wresiduals[i]= residual*Math.sqrt(residualsWeights[i]);\n             cost += residualsWeights[i] * residual * residual;\n             index += cols;\n         }\n             for (int j = i; j < cols; ++j) {\n                 double sum = 0;\n                 for (int k = 0; k < rows; ++k) {\n-                    sum += jacobian[k][i] * jacobian[k][j];\n+                    sum += wjacobian[k][i] * wjacobian[k][j];\n                 }\n                 jTj[i][j] = sum;\n                 jTj[j][i] = sum;\n         cols      = point.length;\n         jacobian  = new double[rows][cols];\n \n+        wjacobian = new double[rows][cols];\n+        wresiduals = new double[rows];\n+        \n         cost = Double.POSITIVE_INFINITY;\n \n         return doOptimize();\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n             for (int i=0;i<rows;i++) {\n-                qtf[i]=residuals[i];\n+                qtf[i]=wresiduals[i];\n             }\n             incrementIterationsCounter();\n \n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n                 int pk = permutation[k];\n-                jacobian[k][pk] = diagR[pk];\n+                wjacobian[k][pk] = diagR[pk];\n             }\n \n             if (firstIteration) {\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * qtf[i];\n+                            sum += wjacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n                     double dirJ = lmDir[pj];\n                     work1[j] = 0;\n                     for (int i = 0; i <= j; ++i) {\n-                        work1[i] += jacobian[i][pj] * dirJ;\n+                        work1[i] += wjacobian[i][pj] * dirJ;\n                     }\n                 }\n                 double coeff1 = 0;\n             int pk = permutation[k];\n             double ypk = lmDir[pk] / diagR[pk];\n             for (int i = 0; i < k; ++i) {\n-                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n+                lmDir[permutation[i]] -= ypk * wjacobian[i][pk];\n             }\n             lmDir[pk] = ypk;\n         }\n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = 0; i < j; ++i) {\n-                    sum += jacobian[i][pj] * work1[permutation[i]];\n+                    sum += wjacobian[i][pj] * work1[permutation[i]];\n                 }\n                 double s = (work1[pj] - sum) / diagR[pj];\n                 work1[pj] = s;\n             int pj = permutation[j];\n             double sum = 0;\n             for (int i = 0; i <= j; ++i) {\n-                sum += jacobian[i][pj] * qy[i];\n+                sum += wjacobian[i][pj] * qy[i];\n             }\n             sum /= diag[pj];\n             sum2 += sum * sum;\n                 work1[pj] /= work2[j];\n                 double tmp = work1[pj];\n                 for (int i = j + 1; i < solvedCols; ++i) {\n-                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n+                    work1[permutation[i]] -= wjacobian[i][pj] * tmp;\n                 }\n             }\n             sum2 = 0;\n         for (int j = 0; j < solvedCols; ++j) {\n             int pj = permutation[j];\n             for (int i = j + 1; i < solvedCols; ++i) {\n-                jacobian[i][pj] = jacobian[j][permutation[i]];\n+                wjacobian[i][pj] = wjacobian[j][permutation[i]];\n             }\n             lmDir[j] = diagR[pj];\n             work[j]  = qy[j];\n \n                     final double sin;\n                     final double cos;\n-                    double rkk = jacobian[k][pk];\n+                    double rkk = wjacobian[k][pk];\n                     if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n                         final double cotan = rkk / lmDiag[k];\n                         sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n \n                     // compute the modified diagonal element of R and\n                     // the modified element of (Qty,0)\n-                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n+                    wjacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                     final double temp = cos * work[k] + sin * qtbpj;\n                     qtbpj = -sin * work[k] + cos * qtbpj;\n                     work[k] = temp;\n \n                     // accumulate the tranformation in the row of s\n                     for (int i = k + 1; i < solvedCols; ++i) {\n-                        double rik = jacobian[i][pk];\n+                        double rik = wjacobian[i][pk];\n                         final double temp2 = cos * rik + sin * lmDiag[i];\n                         lmDiag[i] = -sin * rik + cos * lmDiag[i];\n-                        jacobian[i][pk] = temp2;\n+                        wjacobian[i][pk] = temp2;\n                     }\n \n                 }\n \n             // store the diagonal element of s and restore\n             // the corresponding diagonal element of R\n-            lmDiag[j] = jacobian[j][permutation[j]];\n-            jacobian[j][permutation[j]] = lmDir[j];\n+            lmDiag[j] = wjacobian[j][permutation[j]];\n+            wjacobian[j][permutation[j]] = lmDir[j];\n \n         }\n \n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = j + 1; i < nSing; ++i) {\n-                    sum += jacobian[i][pj] * work[i];\n+                    sum += wjacobian[i][pj] * work[i];\n                 }\n                 work[j] = (work[j] - sum) / lmDiag[j];\n             }\n         for (int k = 0; k < cols; ++k) {\n             permutation[k] = k;\n             double norm2 = 0;\n-            for (int i = 0; i < jacobian.length; ++i) {\n-                double akk = jacobian[i][k];\n+            for (int i = 0; i < wjacobian.length; ++i) {\n+                double akk = wjacobian[i][k];\n                 norm2 += akk * akk;\n             }\n             jacNorm[k] = Math.sqrt(norm2);\n             double ak2 = Double.NEGATIVE_INFINITY;\n             for (int i = k; i < cols; ++i) {\n                 double norm2 = 0;\n-                for (int j = k; j < jacobian.length; ++j) {\n-                    double aki = jacobian[j][permutation[i]];\n+                for (int j = k; j < wjacobian.length; ++j) {\n+                    double aki = wjacobian[j][permutation[i]];\n                     norm2 += aki * aki;\n                 }\n                 if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n             permutation[k]          = pk;\n \n             // choose alpha such that Hk.u = alpha ek\n-            double akk   = jacobian[k][pk];\n+            double akk   = wjacobian[k][pk];\n             double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n             double betak = 1.0 / (ak2 - akk * alpha);\n             beta[pk]     = betak;\n \n             // transform the current column\n             diagR[pk]        = alpha;\n-            jacobian[k][pk] -= alpha;\n+            wjacobian[k][pk] -= alpha;\n \n             // transform the remaining columns\n             for (int dk = cols - 1 - k; dk > 0; --dk) {\n                 double gamma = 0;\n-                for (int j = k; j < jacobian.length; ++j) {\n-                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n+                for (int j = k; j < wjacobian.length; ++j) {\n+                    gamma += wjacobian[j][pk] * wjacobian[j][permutation[k + dk]];\n                 }\n                 gamma *= betak;\n-                for (int j = k; j < jacobian.length; ++j) {\n-                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n+                for (int j = k; j < wjacobian.length; ++j) {\n+                    wjacobian[j][permutation[k + dk]] -= gamma * wjacobian[j][pk];\n                 }\n             }\n \n             int pk = permutation[k];\n             double gamma = 0;\n             for (int i = k; i < rows; ++i) {\n-                gamma += jacobian[i][pk] * y[i];\n+                gamma += wjacobian[i][pk] * y[i];\n             }\n             gamma *= beta[pk];\n             for (int i = k; i < rows; ++i) {\n-                y[i] -= gamma * jacobian[i][pk];\n+                y[i] -= gamma * wjacobian[i][pk];\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n \n         VectorialPointValuePair optimum =\n             optimizer.optimize(circle, target, weights, new double[] { 0, 0 });\n-        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-8);\n-        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-8);\n+        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n+        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n         assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n \n     }", "timestamp": 1281823147, "metainfo": ""}