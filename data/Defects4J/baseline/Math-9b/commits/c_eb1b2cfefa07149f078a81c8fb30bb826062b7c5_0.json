{"sha": "eb1b2cfefa07149f078a81c8fb30bb826062b7c5", "log": "Improved Percentile performance by using a selection algorithm instead of a complete sort, and by allowing caching data array and pivots when several different percentiles are desired JIRA: MATH-417  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n package org.apache.commons.math.stat.descriptive;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NotPositiveException;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Abstract base class for all implementations of the\n public abstract class AbstractUnivariateStatistic\n     implements UnivariateStatistic {\n \n+    /** Stored data. */\n+    private double[] storedData;\n+\n+    /**\n+     * Set the data array.\n+     * <p>\n+     * The stored value is a copy of the parameter array, not the array itself\n+     * </p>\n+     * @param values data array to store (may be null to remove stored data)\n+     * @see #evaluate()\n+     */\n+    public void setData(final double[] values) {\n+        storedData = (values == null) ? null : values.clone();\n+    }\n+\n+    /**\n+     * Get a copy of the stored data array.\n+     * @return copy of the stored data array (may be null)\n+     */\n+    public double[] getData() {\n+        return (storedData == null) ? null : storedData.clone();\n+    }\n+\n+    /**\n+     * Get a reference to the stored data array.\n+     * @return reference to the stored data array (may be null)\n+     */\n+    protected double[] getDataRef() {\n+        return storedData;\n+    }\n+\n+    /**\n+     * Set the data array.\n+     * @param values data array to store\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @see #evaluate()\n+     */\n+    public void setData(final double[] values, final int begin, final int length) {\n+        storedData = new double[length];\n+        System.arraycopy(values, begin, storedData, 0, length);\n+    }\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the stored data.\n+     * <p>\n+     * The stored array is the one which was set by previous calls to\n+     * </p>\n+     * @return the value of the statistic applied to the stored data\n+     */\n+    public double evaluate() {\n+        return evaluate(storedData);\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(FirstMoment source, FirstMoment dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.m1 = source.m1;\n         dest.dev = source.dev;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(GeometricMean source, GeometricMean dest) {\n+        dest.setData(source.getDataRef());\n         dest.sumOfLogs = source.sumOfLogs.copy();\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Kurtosis source, Kurtosis dest) {\n+        dest.setData(source.getDataRef());\n         dest.moment = source.moment.copy();\n         dest.incMoment = source.incMoment;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Mean source, Mean dest) {\n+        dest.setData(source.getDataRef());\n         dest.incMoment = source.incMoment;\n         dest.moment = source.moment.copy();\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/SemiVariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/SemiVariance.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(final SemiVariance source, SemiVariance dest) {\n+        dest.setData(source.getDataRef());\n         dest.biasCorrected = source.biasCorrected;\n         dest.varianceDirection = source.varianceDirection;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Skewness source, Skewness dest) {\n+        dest.setData(source.getDataRef());\n         dest.moment = new ThirdMoment(source.moment.copy());\n         dest.incMoment = source.incMoment;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(StandardDeviation source, StandardDeviation dest) {\n+        dest.setData(source.getDataRef());\n         dest.variance = source.variance.copy();\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n             dest == null) {\n             throw new NullArgumentException();\n         }\n+        dest.setData(source.getDataRef());\n         dest.moment = source.moment.copy();\n         dest.isBiasCorrected = source.isBiasCorrected;\n         dest.incMoment = source.incMoment;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Max source, Max dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Min source, Min dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n  * </li>\n  * </ol></p>\n  * <p>\n- * To compute percentiles, the data must be (totally) ordered.  Input arrays\n- * are copied and then sorted using  {@link java.util.Arrays#sort(double[])}.\n+ * To compute percentiles, the data must be at least partially ordered.  Input\n+ * arrays are copied and recursively partitioned using an ordering definition.\n  * The ordering used by <code>Arrays.sort(double[])</code> is the one determined\n  * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes\n  * <code>Double.NaN</code> larger than any other value (including\n  * elements, arrays containing  <code>NaN</code> or infinite values will often\n  * result in <code>NaN<code> or infinite values returned.</p>\n  * <p>\n+ * Since 2.2, Percentile implementation uses only selection instead of complete\n+ * sorting and caches selection algorithm state between calls to the various\n+ * {@code evaluate} methods when several percentiles are to be computed on the same data.\n+ * This greatly improves efficiency, both for single percentile and multiple\n+ * percentiles computations. However, it also induces a need to be sure the data\n+ * at one call to {@code evaluate} is the same as the data with the cached algorithm\n+ * state from the previous calls. Percentile does this by checking the array reference\n+ * itself and a checksum of its content by default. If the user already knows he calls\n+ * {@code evaluate} on an immutable array, he can save the checking time by calling the\n+ * {@code evaluate} methods that do <em>not</em>\n+ * </p>\n+ * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n  * one of the threads invokes the <code>increment()</code> or\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8091216485095130416L;\n \n+    /** Minimum size under which we use a simple insertion sort rather than Hoare's select. */\n+    private static final int MIN_SELECT_SIZE = 15;\n+\n+    /** Maximum number of partitioning pivots cached (each level double the number of pivots). */\n+    private static final int MAX_CACHED_LEVELS = 10;\n+\n     /** Determines what percentile is computed when evaluate() is activated\n      * with no quantile argument */\n     private double quantile = 0.0;\n+\n+    /** Cached pivots. */\n+    private int[] cachedPivots;\n \n     /**\n      * Constructs a Percentile with a default quantile\n      */\n     public Percentile(final double p) {\n         setQuantile(p);\n+        cachedPivots = null;\n     }\n \n     /**\n      */\n     public Percentile(Percentile original) {\n         copy(original, this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setData(final double[] values) {\n+        if (values == null) {\n+            cachedPivots = null;\n+        } else {\n+            cachedPivots = new int[(0x1 << MAX_CACHED_LEVELS) - 1];\n+            Arrays.fill(cachedPivots, -1);\n+        }\n+        super.setData(values);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setData(final double[] values, final int begin, final int length) {\n+        if (values == null) {\n+            cachedPivots = null;\n+        } else {\n+            cachedPivots = new int[(0x1 << MAX_CACHED_LEVELS) - 1];\n+            Arrays.fill(cachedPivots, -1);\n+        }\n+        super.setData(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the stored data.\n+     * <p>\n+     * The stored array is the one which was set by previous calls to\n+     * </p>\n+     * @param p the percentile value to compute\n+     * @return the value of the statistic applied to the stored data\n+     */\n+    public double evaluate(final double p) {\n+        return evaluate(getDataRef(), p);\n     }\n \n     /**\n         double fpos = FastMath.floor(pos);\n         int intPos = (int) fpos;\n         double dif = pos - fpos;\n-        double[] sorted = new double[length];\n-        System.arraycopy(values, begin, sorted, 0, length);\n-        Arrays.sort(sorted);\n+        double[] work;\n+        int[] pivotsHeap;\n+        if (values == getDataRef()) {\n+            work = getDataRef();\n+            pivotsHeap = cachedPivots;\n+        } else {\n+            work = new double[length];\n+            System.arraycopy(values, begin, work, 0, length);\n+            pivotsHeap = new int[(0x1 << MAX_CACHED_LEVELS) - 1];\n+            Arrays.fill(pivotsHeap, -1);\n+        }\n \n         if (pos < 1) {\n-            return sorted[0];\n+            return select(work, pivotsHeap, 0);\n         }\n         if (pos >= n) {\n-            return sorted[length - 1];\n-        }\n-        double lower = sorted[intPos - 1];\n-        double upper = sorted[intPos];\n+            return select(work, pivotsHeap, length - 1);\n+        }\n+        double lower = select(work, pivotsHeap, intPos - 1);\n+        double upper = select(work, pivotsHeap, intPos);\n         return lower + dif * (upper - lower);\n+    }\n+\n+    /**\n+     * Select the k<sup>th</sup> smallest element from work array\n+     * @param work work array (will be reorganized during the call)\n+     * @param pivotsHeap set of pivot index corresponding to elements that\n+     * are already at their sorted location, stored as an implicit heap\n+     * (i.e. a sorted binary tree stored in a flat array, where the\n+     * children of a node at index n are at indices 2n+1 for the left\n+     * child and 2n+2 for the right child, with 0-based indices)\n+     * @param k index of the desired element\n+     * @return k<sup>th</sup> smallest element\n+     */\n+    private double select(final double[] work, final int[] pivotsHeap, final int k) {\n+\n+        int begin = 0;\n+        int end   = work.length;\n+        int node  = 0;\n+\n+        while (end - begin > MIN_SELECT_SIZE) {\n+\n+            final int pivot;\n+            if ((node < pivotsHeap.length) && (pivotsHeap[node] >= 0)) {\n+                // the pivot has already been found in a previous call\n+                // and the array has already been partitioned around it\n+                pivot = pivotsHeap[node];\n+            } else {\n+                // select a pivot and partition work array around it\n+                pivot = partition(work, begin, end, medianOf3(work, begin, end));\n+                if (node < pivotsHeap.length) {\n+                    pivotsHeap[node] =  pivot;\n+                }\n+            }\n+\n+            if (k == pivot) {\n+                // the pivot was exactly the element we wanted\n+                return work[k];\n+            } else if (k < pivot) {\n+                // the element is in the left partition\n+                end  = pivot;\n+                node = Math.min(2 * node + 1, pivotsHeap.length); // the min is here to avoid integer overflow\n+            } else {\n+                // the element is in the right partition\n+                begin = pivot + 1;\n+                node  = Math.min(2 * node + 2, pivotsHeap.length); // the min is here to avoid integer overflow\n+            }\n+\n+        }\n+\n+        // the element is somewhere in the small sub-array\n+        // sort the sub-array using insertion sort\n+        insertionSort(work, begin, end);\n+        return work[k];\n+\n+    }\n+\n+    /** Select a pivot index as the median of three\n+     * @param work data array\n+     * @param begin index of the first element of the slice\n+     * @param end index after the last element of the slice\n+     * @return the index of the median element chosen between the\n+     * first, the middle and the last element of the array slice\n+     */\n+    int medianOf3(final double[] work, final int begin, final int end) {\n+\n+        final int inclusiveEnd = end - 1;\n+        final int    middle    = begin + (inclusiveEnd - begin) / 2;\n+        final double wBegin    = work[begin];\n+        final double wMiddle   = work[middle];\n+        final double wEnd      = work[inclusiveEnd];\n+\n+        if (wBegin < wMiddle) {\n+            if (wMiddle < wEnd) {\n+                return middle;\n+            } else {\n+                return (wBegin < wEnd) ? inclusiveEnd : begin;\n+            }\n+        } else {\n+            if (wBegin < wEnd) {\n+                return begin;\n+            } else {\n+                return (wMiddle < wEnd) ? inclusiveEnd : middle;\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Partition an array slice around a pivot\n+     * <p>\n+     * Partitioning exchanges array elements such that all elements\n+     * smaller than pivot are before it and all elements larger than\n+     * pivot are after it\n+     * </p>\n+     * @param work data array\n+     * @param begin index of the first element of the slice\n+     * @param end index after the last element of the slice\n+     * @param pivot initial index of the pivot\n+     * @return index of the pivot after partition\n+     */\n+    private int partition(final double[] work, final int begin, final int end, final int pivot) {\n+\n+        final double value = work[pivot];\n+        work[pivot] = work[begin];\n+\n+        int i = begin + 1;\n+        int j = end - 1;\n+        while (i < j) {\n+            while ((i < j) && (work[j] >= value)) {\n+                --j;\n+            }\n+            while ((i < j) && (work[i] <= value)) {\n+                ++i;\n+            }\n+\n+            if (i < j) {\n+                final double tmp = work[i];\n+                work[i++] = work[j];\n+                work[j--] = tmp;\n+            }\n+        }\n+\n+        if ((i >= end) || (work[i] > value)) {\n+            --i;\n+        }\n+        work[begin] = work[i];\n+        work[i]     = value;\n+        return i;\n+\n+    }\n+\n+    /**\n+     * Sort in place a (small) array slice using insertion sort\n+     * @param work array to sort\n+     * @param begin index of the first element of the slice to sort\n+     * @param end index after the last element of the slice to sort\n+     */\n+    private void insertionSort(final double[] work, final int begin, final int end) {\n+        for (int j = begin + 1; j < end; j++) {\n+            final double saved = work[j];\n+            int i = j - 1;\n+            while ((i >= begin) && (saved < work[i])) {\n+                work[i + 1] = work[i];\n+                i--;\n+            }\n+            work[i + 1] = saved;\n+        }\n     }\n \n     /**\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Percentile source, Percentile dest) {\n+        dest.setData(source.getDataRef());\n+        if (source.cachedPivots != null) {\n+            System.arraycopy(source.cachedPivots, 0, dest.cachedPivots, 0, source.cachedPivots.length);\n+        }\n         dest.quantile = source.quantile;\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Product source, Product dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Sum source, Sum dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(SumOfLogs source, SumOfLogs dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(SumOfSquares source, SumOfSquares dest) {\n+        dest.setData(source.getDataRef());\n         dest.n = source.n;\n         dest.value = source.value;\n     }", "timestamp": 1286722256, "metainfo": ""}