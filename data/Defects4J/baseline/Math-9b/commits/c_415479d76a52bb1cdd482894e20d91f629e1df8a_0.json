{"sha": "415479d76a52bb1cdd482894e20d91f629e1df8a", "log": "added a new DenseRealMatrix class intended to replace RealMatrixImpl this class is more cache-friendly as it stores data from squares blocks in flattened arrays. This allows algorithms that need cross-direction navigation like multiplication or transpose) to be more efficient on modern processors.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of RealMatrix using a flat arrays to store square blocks of the matrix.\n+ * <p>\n+ * This implementation is cache-friendly. Square blocks are stored as small arrays and allow\n+ * efficient traversal of data both in row major direction and columns major direction. This\n+ * greatly increases performances for algorithms that use crossed directions loops like\n+ * multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DenseRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5536250491728216579L;\n+\n+    /** Block size. */\n+    private static final int BLOCK_SIZE = 32;\n+\n+    /** Blocks of matrix entries. */\n+    private final double blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public DenseRealMatrix(final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // number of lines in smaller blocks at the bottom side of the matrix\n+        final int lastLines = rows - (blockRows - 1) * BLOCK_SIZE;\n+\n+        // number of columns in smaller blocks at the right side of the matrix\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks       = new double[blockRows * blockColumns][];\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < (blockRows - 1); ++iBlock) {\n+            for (int jBlock = 0; jBlock < (blockColumns - 1); ++jBlock) {\n+                blocks[blockIndex++] = new double[BLOCK_SIZE * BLOCK_SIZE];\n+            }\n+            blocks[blockIndex++] = new double[BLOCK_SIZE * lastColumns];\n+        }\n+        for (int jBlock = 0; jBlock < (blockColumns - 1); ++jBlock) {\n+            blocks[blockIndex++] = new double[lastLines * BLOCK_SIZE];\n+        }\n+        blocks[blockIndex++] = new double[lastLines * lastColumns];\n+\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied (and data rearranged), it is not referenced.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length)\n+     */\n+    public DenseRealMatrix(final double[][] d)\n+        throws IllegalArgumentException {\n+\n+        // build empty instance\n+        this(d.length, d[0].length);\n+\n+        // fill in instance\n+        for (int i = 0; i < d.length; ++i) {\n+            final double[] rowI = d[i];\n+            if (rowI.length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n+                                                                          new Object[] {\n+                                                                              columns, rowI.length\n+                                                                          }); \n+            }\n+            for (int j = 0; j < rowI.length; ++j) {\n+                setEntry(i, j, rowI[j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new DenseRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix copy() {\n+\n+        // create an empty matrix\n+        DenseRealMatrix copied = new DenseRealMatrix(rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((DenseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkAdditionCompatible(m);\n+\n+            final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] + m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public DenseRealMatrix add(final DenseRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((DenseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkSubtractionCompatible(m);\n+\n+            final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] - m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public DenseRealMatrix subtract(final DenseRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] - mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarAdd(final double d)\n+        throws IllegalArgumentException {\n+\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarMultiply(final double d)\n+        throws IllegalArgumentException {\n+\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] * d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((DenseRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final DenseRealMatrix out = new DenseRealMatrix(rows, m.getColumnDimension());\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                double sum = 0;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum += tBlock[l] * m.getEntry(r, q);\n+                                }\n+                                outBlock[k++] += sum;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    DenseRealMatrix multiply(DenseRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final DenseRealMatrix out = new DenseRealMatrix(rows, m.columns);\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // select current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            double sum = 0;\n+                            for (int l = lStart, n = nStart; l < lEnd; ++l, n += jWidth) {\n+                                sum += tBlock[l] * mBlock[n];\n+                            }\n+                            outBlock[k++] += sum;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[][] getData() {\n+\n+        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final double[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        final double[] colSums = new double[BLOCK_SIZE];\n+        double maxColSum = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; jBlock++) {\n+            final int jWidth = blockWidth(jBlock);\n+            Arrays.fill(colSums, 0, jWidth, 0.0);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final int iHeight = blockHeight(iBlock);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int j = 0; j < jWidth; ++j) {\n+                    double sum = 0;\n+                    for (int i = 0; i < iHeight; ++i) {\n+                        sum += Math.abs(block[i * jWidth + j]);\n+                    }\n+                    colSums[j] += sum;\n+                }\n+            }\n+            for (int j = 0; j < jWidth; ++j) {\n+                maxColSum = Math.max(maxColSum, colSums[j]);\n+            }\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double getFrobeniusNorm() {\n+        double sum2 = 0;\n+        for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {\n+            for (final double entry : blocks[blockIndex]) {\n+                sum2 += entry * entry;\n+            }\n+        }\n+        return Math.sqrt(sum2);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final DenseRealMatrix out =\n+            new DenseRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final double[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(index);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(index + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(index + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final double[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final double[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final DenseRealMatrix out = new DenseRealMatrix(nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        final double[] out = new double[nRows];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final double[] block  = blocks[blockIndex];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    double sum = 0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n+                        sum += block[k++] * v[q];\n+                    }\n+                    out[p] += sum;\n+                }\n+                ++blockIndex;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector operate(final RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return operate((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            return super.operate(v);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public RealVectorImpl operate(final RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return new RealVectorImpl(operate(v.getDataRef()), false);\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n     }\n     \n     /**\n+     * Returns a {@link RealMatrix} with specified dimensions.\n+     * <p>The matrix elements are all set to 0.0.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @return  RealMatrix with specified dimensions\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n+        return new DenseRealMatrix(rows, columns);\n+    }\n+\n+    /**\n      * Returns a {@link RealMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n      * \n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>data</code> is null\n-     * @see #createRealMatrix(double[][], boolean)\n+     * @see #createRealMatrix(int, int)\n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n-        return new RealMatrixImpl(data);\n-    }\n-\n-    /**\n-     * Returns a {@link RealMatrix} whose entries are the the values in the\n-     * the input array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * RealMatrix and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * @param data data for new matrix\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>data</code> is null\n-     * @see #createRealMatrix(double[][])\n-     */\n-    public static RealMatrix createRealMatrix(double[][] data, boolean copyArray) {\n-        return new RealMatrixImpl(data, copyArray);\n+        return new DenseRealMatrix(data);\n     }\n \n     /**\n      * @since 1.1\n      */\n     public static RealMatrix createRealIdentityMatrix(int dimension) {\n-        double[][] d = new double[dimension][dimension];\n-        for (int row = 0; row < dimension; row++) {\n-            d[row][row] = 1d;\n-        }\n-        return new RealMatrixImpl(d, false);\n+        final RealMatrix m = createRealMatrix(dimension, dimension);\n+        for (int i = 0; i < dimension; ++i) {\n+            m.setEntry(i, i, 1.0);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Returns a diagonal matrix with specified elements.\n+     *\n+     * @param diagonal diagonal elements of the matrix (the array elements\n+     * will be copied)\n+     * @return diagonal matrix\n+     * @since 2.0\n+     */\n+    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n+        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n+        for (int i = 0; i < diagonal.length; ++i) {\n+            m.setEntry(i, i, diagonal[i]);\n+        }\n+        return m;\n     }\n     \n     /**\n      */\n     public static RealMatrix createRowRealMatrix(double[] rowData) {\n         final int nCols = rowData.length;\n-        final double[][] data = new double[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new RealMatrixImpl(data, false);\n+        final RealMatrix m = createRealMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            m.setEntry(0, i, rowData[i]);\n+        }\n+        return m;\n     }\n     \n     /**\n      */\n     public static RealMatrix createColumnRealMatrix(double[] columnData) {\n         final int nRows = columnData.length;\n-        final double[][] data = new double[nRows][1];\n-        for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new RealMatrixImpl(data, false);\n+        final RealMatrix m = createRealMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            m.setEntry(i, 0, columnData[i]);\n+        }\n+        return m;\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link DenseRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class DenseRealMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public DenseRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+        \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DenseRealMatrixTest.class);\n+        suite.setName(\"DenseRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        DenseRealMatrix m1 = createRandomMatrix(r, 47, 83);\n+        DenseRealMatrix m2 = new DenseRealMatrix(m1.getData());\n+        assertEquals(m1, m2);\n+        DenseRealMatrix m3 = new DenseRealMatrix(testData);\n+        DenseRealMatrix m4 = new DenseRealMatrix(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testDataInv);\n+        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n+        try {\n+            m.subtract(new DenseRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n+        DenseRealMatrix identity = new DenseRealMatrix(id);\n+        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        assertClose(m.multiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.multiply(m), identity, entryTolerance);\n+        assertClose(m.multiply(identity), m, entryTolerance);\n+        assertClose(identity.multiply(mInv), mInv, entryTolerance);\n+        assertClose(m2.multiply(identity), m2, entryTolerance); \n+        try {\n+            m.multiply(new DenseRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        RealMatrix m = new DenseRealMatrix(35, 71);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, i + j / 1024.0);\n+            }\n+        }\n+\n+        RealMatrix mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum += (k + i / 1024.0) * (k + j / 1024.0);\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum += (i + k / 1024.0) * (j + k / 1024.0);\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for DenseRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new DenseRealMatrix(d3);   \n+       RealMatrix m4 = new DenseRealMatrix(d4);\n+       RealMatrix m5 = new DenseRealMatrix(d5);\n+       assertClose(m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new DenseRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new DenseRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new DenseRealMatrix(testData);\n+        assertClose(new DenseRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new DenseRealMatrix(id);\n+        assertClose(testVector, m.operate(testVector), entryTolerance);\n+        assertClose(testVector, m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n+        m = new DenseRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new DenseRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new DenseRealMatrix(testData); \n+        RealMatrix mIT = new LUSolver(new LUDecompositionImpl(m)).getInverse().transpose();\n+        RealMatrix mTI = new LUSolver(new LUDecompositionImpl(m.transpose())).getInverse();\n+        assertClose(mIT, mTI, normTolerance);\n+        m = new DenseRealMatrix(testData2);\n+        RealMatrix mt = new DenseRealMatrix(testData2T);\n+        assertClose(mt, m.transpose(), normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new DenseRealMatrix(testData);\n+        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n+        assertClose(m.preMultiply(new RealVectorImpl(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new DenseRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new DenseRealMatrix(d3);   \n+        RealMatrix m4 = new DenseRealMatrix(d4);\n+        RealMatrix m5 = new DenseRealMatrix(d5);\n+        assertClose(m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n+        DenseRealMatrix identity = new DenseRealMatrix(id);\n+        assertClose(m.preMultiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.preMultiply(m), identity, entryTolerance);\n+        assertClose(m.preMultiply(identity), m, entryTolerance);\n+        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n+        try {\n+            m.preMultiply(new DenseRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new DenseRealMatrix(testData);\n+        assertClose(m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new DenseRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new DenseRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new DenseRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUSolver(new LUDecompositionImpl(p)).getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new DenseRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUSolver(new LUDecompositionImpl(coefficients)).solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testSubMatrix() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix mRows23Cols00 = new DenseRealMatrix(subRows23Cols00);\n+        RealMatrix mRows00Cols33 = new DenseRealMatrix(subRows00Cols33);\n+        RealMatrix mRows01Cols23 = new DenseRealMatrix(subRows01Cols23);\n+        RealMatrix mRows02Cols13 = new DenseRealMatrix(subRows02Cols13);\n+        RealMatrix mRows03Cols12 = new DenseRealMatrix(subRows03Cols12);\n+        RealMatrix mRows03Cols123 = new DenseRealMatrix(subRows03Cols123);\n+        RealMatrix mRows20Cols123 = new DenseRealMatrix(subRows20Cols123);\n+        RealMatrix mRows31Cols31 = new DenseRealMatrix(subRows31Cols31);\n+        assertEquals(mRows23Cols00, m.getSubMatrix(2 , 3 , 0, 0));\n+        assertEquals(mRows00Cols33, m.getSubMatrix(0 , 0 , 3, 3));\n+        assertEquals(mRows01Cols23, m.getSubMatrix(0 , 1 , 2, 3));   \n+        assertEquals(mRows02Cols13, m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  \n+        assertEquals(mRows03Cols12, m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  \n+        assertEquals(mRows03Cols123, m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); \n+        assertEquals(mRows20Cols123, m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); \n+        assertEquals(mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n+        assertEquals(mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n+        \n+        try {\n+            m.getSubMatrix(1,0,2,4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1,1,2,2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1,0,2,2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1,0,2,4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] {0});\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {0}, new int[] {4});\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetRowMatrix() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix mRow0 = new DenseRealMatrix(subRow0);\n+        RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new DenseRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new DenseRealMatrix(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new DenseRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new RealVectorImpl(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new RealVectorImpl(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new RealVectorImpl(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new DenseRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        DenseRealMatrix m1 = (DenseRealMatrix) m.copy();\n+        DenseRealMatrix mt = (DenseRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new DenseRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        assertEquals(\"DenseRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = new DenseRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new DenseRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new DenseRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        DenseRealMatrix matrix = new DenseRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n+        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n+        expected = new DenseRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+    \n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n+        assertTrue(m.subtract(n).getNorm() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(double[] m, double[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(m[i], n[i], tolerance);\n+        }\n+    }\n+\n+    private DenseRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n+        DenseRealMatrix m = new DenseRealMatrix(rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                m.setEntry(i, j, 200 * r.nextDouble() - 100);\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n     }\n     \n     public void testCreateRealMatrix() {\n-        assertEquals(new RealMatrixImpl(testData), \n+        assertEquals(new DenseRealMatrix(testData), \n                 MatrixUtils.createRealMatrix(testData));\n-        assertEquals(new RealMatrixImpl(testData, false), \n-                MatrixUtils.createRealMatrix(testData, true));\n-        assertEquals(new RealMatrixImpl(testData, true), \n-                MatrixUtils.createRealMatrix(testData, false));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n     }\n         \n     public void testCreateRowRealMatrix() {\n-        assertEquals((RealMatrixImpl) MatrixUtils.createRowRealMatrix(row),\n-               new RealMatrixImpl(rowMatrix));\n+        assertEquals(MatrixUtils.createRowRealMatrix(row),\n+                     new DenseRealMatrix(rowMatrix));\n         try {\n             MatrixUtils.createRowRealMatrix(new double[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");\n     }\n     \n     public void testCreateColumnRealMatrix() {\n-        assertEquals((RealMatrixImpl) MatrixUtils.createColumnRealMatrix(col),\n-                new RealMatrixImpl(colMatrix));\n+        assertEquals(MatrixUtils.createColumnRealMatrix(col),\n+                     new DenseRealMatrix(colMatrix));\n         try {\n             MatrixUtils.createColumnRealMatrix(new double[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");", "timestamp": 1229731178, "metainfo": ""}