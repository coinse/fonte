{"sha": "21199763cb19ebcfb07ca4ac01bd5b9c6d309506", "log": "Fixed about 90 checkstyle errors.  The errors were mainly trailing blanks, missing javadoc, wrong javadoc parameters, hidden variables ...  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/Field.java\n+++ b/src/main/java/org/apache/commons/math/Field.java\n     T getOne();\n \n     /**\n-     * Returns the runtime class of the FieldElement. \n-     * \n+     * Returns the runtime class of the FieldElement.\n+     *\n      * @return The {@code Class} object that represents the runtime\n      *         class of this object.\n      */\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n      *\n      * @param maxEval Maximum number of evaluations.\n      * @param f the integrand function\n-     * @param min the min bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param lower the min bound for the interval\n+     * @param upper the upper bound for the interval\n      * @throws NullArgumentException if {@code f} is {@code null}.\n      * @throws MathIllegalArgumentException if {@code min >= max}.\n      */\n     protected void setup(final int maxEval,\n                          final UnivariateRealFunction f,\n-                         final double min, final double max)\n+                         final double lower, final double upper)\n         throws NullArgumentException, MathIllegalArgumentException {\n \n         // Checks.\n         MathUtils.checkNotNull(f);\n-        UnivariateRealSolverUtils.verifyInterval(min, max);\n+        UnivariateRealSolverUtils.verifyInterval(lower, upper);\n \n         // Reset.\n-        this.min = min;\n-        this.max = max;\n+        this.min = lower;\n+        this.max = upper;\n         function = f;\n         evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n \n     /** {@inheritDoc} */\n     public double integrate(final int maxEval, final UnivariateRealFunction f,\n-                            final double min, final double max)\n+                            final double lower, final double upper)\n         throws TooManyEvaluationsException, MaxCountExceededException,\n                MathIllegalArgumentException, NullArgumentException {\n \n         // Initialization.\n-        setup(maxEval, f, min, max);\n+        setup(maxEval, f, lower, upper);\n \n         // Perform computation.\n         return doIntegrate();\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n     }\n \n     /** Interface for recurrence coefficients generation. */\n-    private static interface RecurrenceCoefficientsGenerator {\n+    private interface RecurrenceCoefficientsGenerator {\n         /**\n          * Generate recurrence coefficients.\n          * @param k highest degree of the polynomials used in the recurrence\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private FieldMatrix<BigFraction> createH(double d)\n-            throws MathArithmeticException {\n+            throws NumberIsTooLargeException, FractionConversionException {\n \n         int k = (int) Math.ceil(n * d);\n \n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n      * @param value the double value to convert to a fraction.\n      * @exception MathIllegalArgumentException if value is NaN or infinite\n      */\n-    public BigFraction(final double value) throws IllegalArgumentException {\n+    public BigFraction(final double value) throws MathIllegalArgumentException {\n         if (Double.isNaN(value)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n      * difference and symmetric difference (exclusive or).</p>\n      * @param <S> Type of the space.\n      */\n-    public static interface LeafMerger<S extends Space> {\n+    public interface LeafMerger<S extends Space> {\n \n         /** Merge a leaf node and a tree node.\n          * <p>This method is called at the end of a recursive merging\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n     /** Counter for number of evaluations. */\n     private Incrementor evaluations;\n \n-    /** Differential equations to integrate. */\n-    private transient ExpandableStatefulODE equations;\n+    /** Differential expandable to integrate. */\n+    private transient ExpandableStatefulODE expandable;\n \n     /** Build an instance.\n      * @param name name of the method\n      * @param equations equations to set\n      */\n     protected void setEquations(final ExpandableStatefulODE equations) {\n-        this.equations = equations;\n+        this.expandable = equations;\n     }\n \n     /** {@inheritDoc} */\n             throw new DimensionMismatchException(y.length, equations.getDimension());\n         }\n \n-        // prepare expandable stateful equations\n-        final ExpandableStatefulODE expandable = new ExpandableStatefulODE(equations);\n-        expandable.setTime(t0);\n-        expandable.setPrimaryState(y0);\n+        // prepare expandable stateful expandable\n+        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n+        expandableODE.setTime(t0);\n+        expandableODE.setPrimaryState(y0);\n \n         // perform integration\n-        integrate(expandable, t);\n-\n-        // extract results back from the stateful equations\n-        System.arraycopy(expandable.getPrimaryState(), 0, y, 0, y.length);\n-        return expandable.getTime();\n-\n-    }\n-\n-    /** Integrate a set of differential equations up to the given time.\n+        integrate(expandableODE, t);\n+\n+        // extract results back from the stateful expandable\n+        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n+        return expandableODE.getTime();\n+\n+    }\n+\n+    /** Integrate a set of differential expandable up to the given time.\n      * <p>This method solves an Initial Value Problem (IVP).</p>\n-     * <p>The set of differential equations is composed of a main set, which\n-     * can be extended by some sets of secondary equations. The set of\n-     * equations must be already set up with initial time and partial states.\n+     * <p>The set of differential expandable is composed of a main set, which\n+     * can be extended by some sets of secondary expandable. The set of\n+     * expandable must be already set up with initial time and partial states.\n      * At integration completion, the final time and partial states will be\n      * available in the same object.</p>\n      * <p>Since this method stores some internal state variables made\n      * available in its public interface during integration ({@link\n      * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n-     * @param equations complete set of differential equations to integrate\n+     * @param equations complete set of differential expandable to integrate\n      * @param t target time for the integration\n      * (can be set to a value smaller than <code>t0</code> for backward integration)\n      * @throws MathIllegalStateException if the integrator cannot perform integration\n     public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n         throws MaxCountExceededException {\n         evaluations.incrementCount();\n-        equations.computeDerivatives(t, y, yDot);\n+        expandable.computeDerivatives(t, y, yDot);\n     }\n \n     /** Set the stateInitialized flag.\n     }\n \n     /** Check the integration span.\n+     * @param equations set of differential equations\n      * @param t target time for the integration\n      * @exception NumberIsTooSmallException if integration span is too small\n      */\n--- a/src/main/java/org/apache/commons/math/ode/EquationsMapper.java\n+++ b/src/main/java/org/apache/commons/math/ode/EquationsMapper.java\n     private static final long serialVersionUID = 20110925L;\n \n     /** Index of the first equation element in complete state arrays. */\n-    final int firstIndex;\n+    private final int firstIndex;\n \n     /** Dimension of the secondary state parameters. */\n-    final int dimension;\n+    private final int dimension;\n \n     /** simple constructor.\n      * @param firstIndex index of the first equation element in complete state arrays\n--- a/src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java\n+++ b/src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java\n     /** Components of the compound stateful ODE. */\n     private static class SecondaryComponent {\n \n-        \n         /** Secondary differential equation. */\n         private final SecondaryEquations equation;\n \n \n         /** Simple constructor.\n          * @param equation secondary differential equation\n-         * @param first index index to use for the first element in the complete arrays\n+         * @param firstIndex index to use for the first element in the complete arrays\n          */\n         public SecondaryComponent(final SecondaryEquations equation, final int firstIndex) {\n             final int n   = equation.getDimension();\n--- a/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n+++ b/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n     }\n \n     /** Register the variational equations for the Jacobians matrices to the expandable set.\n+     * @param expandable expandable set into which variational equations should be registered\n      * @exception MathIllegalArgumentException if the primary set of the expandable set does\n      * not match the one used to build the instance\n      * @see ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)\n     }\n \n     /** Add a parameter Jacobian provider.\n-     * @param pode the parameterized ODE to compute the parameter Jacobian matrix using finite differences \n-     */\n-    public void setParameterizedODE(final ParameterizedODE pode) {\n-        this.pode = pode;\n+     * @param parameterizedOde the parameterized ODE to compute the parameter Jacobian matrix using finite differences\n+     */\n+    public void setParameterizedODE(final ParameterizedODE parameterizedOde) {\n+        this.pode = parameterizedOde;\n         dirtyParameter = true;\n     }\n \n      * matrix with respect to state is set to identity.\n      * </p>\n      * @param dYdY0 initial Jacobian matrix w.r.t. state\n-     * @exception IllegalArgumentException if matrix dimensions are incorrect\n+     * @exception DimensionMismatchException if matrix dimensions are incorrect\n      */\n     public void setInitialMainStateJacobian(final double[][] dYdY0)\n-        throws MathIllegalArgumentException {\n+        throws DimensionMismatchException {\n \n         // Check dimensions\n         checkDimension(stateDim, dYdY0);\n         // get current state for this set of equations from the expandable fode\n         double[] p = efode.getSecondaryState(index);\n \n-        int index = 0;\n+        int j = 0;\n         for (int i = 0; i < stateDim; i++) {\n-            System.arraycopy(p, index, dYdY0[i], 0, stateDim);\n-            index += stateDim;\n+            System.arraycopy(p, j, dYdY0[i], 0, stateDim);\n+            j += stateDim;\n         }\n \n     }\n \n     /** Get the current value of the Jacobian matrix with respect to one parameter.\n-     * @param pName name of the parameter for the computed Jacobian matrix \n+     * @param pName name of the parameter for the computed Jacobian matrix\n      * @param dYdP current Jacobian matrix with respect to the named parameter\n      */\n     public void getCurrentParameterJacobian(String pName, final double[] dYdP) {\n         // get current state for this set of equations from the expandable fode\n         double[] p = efode.getSecondaryState(index);\n \n-        int index = stateDim * stateDim;\n+        int i = stateDim * stateDim;\n         for (ParameterConfiguration param: selectedParameters) {\n             if (param.getParameterName().equals(pName)) {\n-                System.arraycopy(p, index, dYdP, 0, stateDim);\n-                break;\n-            }\n-            index += stateDim;\n+                System.arraycopy(p, i, dYdP, 0, stateDim);\n+                return;\n+            }\n+            i += stateDim;\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/math/ode/MainStateJacobianProvider.java\n+++ b/src/main/java/org/apache/commons/math/ode/MainStateJacobianProvider.java\n /** Interface expanding {@link FirstOrderDifferentialEquations first order\n  *  differential equations} in order to compute exactly the main state jacobian\n  *  matrix for {@link JacobianMatrices partial derivatives equations}.\n- * \n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n     }\n \n     /** Transformer used to convert the first step to Nordsieck representation. */\n-    public static interface NordsieckTransformer {\n+    public interface NordsieckTransformer {\n         /** Initialize the high order scaled derivatives at step start.\n          * @param h step size to use for scaling\n          * @param t first steps times\n--- a/src/main/java/org/apache/commons/math/ode/ParameterConfiguration.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterConfiguration.java\n import java.io.Serializable;\n \n /** Simple container pairing a parameter name with a step in order to compute\n- *  the associated jacobian matrix by finite difference.\n- * \n+ *  the associated Jacobian matrix by finite difference.\n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math/ode/ParameterJacobianProvider.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianProvider.java\n \n /** Interface to compute exactly Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n- * \n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math/ode/ParameterJacobianWrapper.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianWrapper.java\n \n /** Wrapper class to compute Jacobian matrices by finite differences for ODE\n  *  which do not compute them by themselves.\n- *  \n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n             dFdP[i] = (tmpDot[i] - yDot[i]) / hP;\n         }\n         pode.setParameter(paramName, p);\n-       \n+\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/ParameterizedODE.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedODE.java\n \n /** Interface to compute by finite difference Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n- * \n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math/ode/ParameterizedWrapper.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedWrapper.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n-\n /** Wrapper class enabling {@link FirstOrderDifferentialEquations basic simple}\n  *  ODE instances to be used when processing {@link JacobianMatrices}.\n- *  \n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.ExpandableStatefulODE;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * </p>\n  * <p>\n  * If the Ordinary Differential Equations is an {@link ExpandableStatefulODE\n- * extended ODE} rather than a {@link FirstOrderDifferentialEquations basic ODE}, then\n+ * extended ODE} rather than a {@link\n+ * org.apache.commons.math.ode.FirstOrderDifferentialEquations basic ODE}, then\n  * <em>only</em> the {@link ExpandableStatefulODE#getPrimaryState() primary part}\n  * of the state vector is used for stepsize control, not the complete state vector.\n  * </p>\n    * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false\n    */\n   protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n-    throws MathIllegalArgumentException {\n+    throws NumberIsTooSmallException {\n \n       double filteredH = h;\n       if (FastMath.abs(h) < minStep) {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n   public void writeExternal(final ObjectOutput out)\n     throws IOException {\n \n-    try {\n-      // save the local attributes\n-      finalizeStep();\n-    } catch (Exception e) {\n-        IOException ioe = new IOException(e.getLocalizedMessage());\n-        ioe.initCause(e);\n-        throw ioe;\n-    }\n+    // save the local attributes\n+    finalizeStep();\n+\n     final int dimension = (currentState == null) ? -1 : currentState.length;\n     out.writeInt(dimension);\n     for (int i = 0; i < dimension; ++i) {\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n     this.dirtyState    = true;\n     primaryMapper      = null;\n     secondaryMappers   = null;\n-    allocateInterpolatedArrays(-1, null, null);\n+    allocateInterpolatedArrays(-1);\n   }\n \n   /** Simple constructor.\n     this.dirtyState       = true;\n     this.primaryMapper    = primaryMapper;\n     this.secondaryMappers = (secondaryMappers == null) ? null : secondaryMappers.clone();\n-    allocateInterpolatedArrays(y.length, primaryMapper, secondaryMappers);\n+    allocateInterpolatedArrays(y.length);\n \n   }\n \n     interpolatedTime   = interpolator.interpolatedTime;\n \n     if (interpolator.currentState == null) {\n-        currentState = null;\n-        allocateInterpolatedArrays(-1, null, null);\n+        currentState     = null;\n+        primaryMapper    = null;\n+        secondaryMappers = null;\n+        allocateInterpolatedArrays(-1);\n     } else {\n       currentState                     = interpolator.currentState.clone();\n       interpolatedState                = interpolator.interpolatedState.clone();\n \n   /** Allocate the various interpolated states arrays.\n    * @param dimension total dimension (negative if arrays should be set to null)\n-   * @param primaryMapper equations mapper for the primary equations set\n-   * @param secondaryMappers equations mappers for the secondary equations sets\n-   */\n-  private void allocateInterpolatedArrays(final int dimension,\n-                                          final EquationsMapper primaryMapper,\n-                                          final EquationsMapper[] secondaryMappers) {\n+   */\n+  private void allocateInterpolatedArrays(final int dimension) {\n       if (dimension < 0) {\n           interpolatedState                = null;\n           interpolatedDerivatives          = null;\n   /** Reinitialize the instance\n    * @param y reference to the integrator array holding the state at the end of the step\n    * @param isForward integration direction indicator\n-   * @param primaryMapper equations mapper for the primary equations set\n-   * @param secondaryMappers equations mappers for the secondary equations sets\n+   * @param primary equations mapper for the primary equations set\n+   * @param secondary equations mappers for the secondary equations sets\n    */\n   protected void reinitialize(final double[] y, final boolean isForward,\n-                              final EquationsMapper primaryMapper,\n-                              final EquationsMapper[] secondaryMappers) {\n+                              final EquationsMapper primary,\n+                              final EquationsMapper[] secondary) {\n \n     globalPreviousTime    = Double.NaN;\n     globalCurrentTime     = Double.NaN;\n     finalized             = false;\n     this.forward          = isForward;\n     this.dirtyState       = true;\n-    this.primaryMapper    = primaryMapper;\n-    this.secondaryMappers = secondaryMappers.clone();\n-    allocateInterpolatedArrays(y.length, primaryMapper, secondaryMappers);\n+    this.primaryMapper    = primary;\n+    this.secondaryMappers = secondary.clone();\n+    allocateInterpolatedArrays(y.length);\n \n   }\n \n     // it will be recomputed as needed after reading\n \n     // finalize the step (and don't bother saving the now true flag)\n-    try {\n-      finalizeStep();\n-    } catch (Exception e) {\n-        IOException ioe = new IOException(e.getLocalizedMessage());\n-        ioe.initCause(e);\n-        throw ioe;\n-    }\n+    finalizeStep();\n \n   }\n \n    * @param in stream where to read the state from\n    * @return interpolated time to be set later by the caller\n    * @exception IOException in case of read error\n+   * @exception ClassNotFoundException if an equation mapper class\n+   * cannot be found\n    */\n   protected double readBaseExternal(final ObjectInput in)\n     throws IOException, ClassNotFoundException {\n \n     // we do NOT handle the interpolated time and state here\n     interpolatedTime = Double.NaN;\n-    allocateInterpolatedArrays(dimension, primaryMapper, secondaryMappers);\n+    allocateInterpolatedArrays(dimension);\n \n     finalized = true;\n \n--- a/src/main/java/org/apache/commons/math/stat/correlation/StorelessBivariateCovariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/StorelessBivariateCovariance.java\n \n     private boolean biasCorrected = true;\n \n-    public StorelessBivariateCovariance(){ \n+    public StorelessBivariateCovariance() {\n     }\n \n-    public StorelessBivariateCovariance(boolean biasCorrected){\n+    public StorelessBivariateCovariance(boolean biasCorrected) {\n         this.biasCorrected = biasCorrected;\n     }\n \n-    public void increment(double x, double y){\n+    public void increment(double x, double y) {\n         n++;\n         deltaX = x - meanX;\n         deltaY = y - meanY;\n         meanX += deltaX / n;\n         meanY += deltaY / n;\n-        covarianceNumerator += ((n-1.0) / n) * deltaX * deltaY;\n+        covarianceNumerator += ((n - 1.0) / n) * deltaX * deltaY;\n     }\n \n-    public double getN(){\n+    public double getN() {\n         return n;\n     }\n \n-    public double getResult()throws IllegalArgumentException{\n-        if (n < 2) throw new MathIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n-        if(biasCorrected){\n+    public double getResult() throws IllegalArgumentException {\n+        if (n < 2) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n+                                                   n, 2);\n+        }\n+        if (biasCorrected) {\n             return covarianceNumerator / (n - 1d);\n-        }else{\n+        } else {\n             return covarianceNumerator / n;\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/correlation/StorelessCovariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/StorelessCovariance.java\n      * This {@link Covariance} method is not supported by StorelessCovariance, since\n      * the number of bivariate observations does not have to be the same for different\n      * pairs of covariates - i.e., N as defined in {@link Covariance#getN()} is undefined.\n+     * @return nothing as this implementation always throws a {@link MathUnsupportedOperationException}\n+     * @throws MathUnsupportedOperationException in all cases\n      */\n     @Override\n-    public int getN() {\n+    public int getN()\n+        throws MathUnsupportedOperationException {\n         throw new MathUnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/package-info.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/package-info.java\n  *        <code>/&lowast; evaluation approach &lowast;/<br/>\n  *          double[] values = new double[] { 1, 2, 3, 4, 5 };<br/>\n  *          <span style=\"font-weight: bold;\">UnivariateStatistic stat = new Mean();</span><br/>\n- *          System.out.println(\"mean = \" + <span style=\"font-weight: bold;\">stat.evaluate(values)</span>);<br/>\n+ *          out.println(\"mean = \" + <span style=\"font-weight: bold;\">stat.evaluate(values)</span>);<br/>\n  *        </code>\n  *\n  *        <h4>StorelessUnivariateStatistic:</h4>\n  *        <code>/&lowast; incremental approach &lowast;/<br/>\n  *          double[] values = new double[] { 1, 2, 3, 4, 5 };<br/>\n  *          <span style=\"font-weight: bold;\">StorelessUnivariateStatistic stat = new Mean();</span><br/>\n- *          System.out.println(\"mean before adding a value is NaN = \" + <span style=\"font-weight: bold;\">stat.getResult()</span>);<br/>\n+ *          out.println(\"mean before adding a value is NaN = \" + <span style=\"font-weight: bold;\">stat.getResult()</span>);<br/>\n  *          for (int i = 0; i &lt; values.length; i++) {<br/>\n  *            &nbsp;&nbsp;&nbsp; <span style=\"font-weight: bold;\">stat.increment(values[i]);</span><br/>\n- *            &nbsp;&nbsp;&nbsp; System.out.println(\"current mean = \" + <span style=\"font-weight: bold;\">stat2.getResult()</span>);<br/>\n+ *            &nbsp;&nbsp;&nbsp; out.println(\"current mean = \" + <span style=\"font-weight: bold;\">stat2.getResult()</span>);<br/>\n  *          }<br/>\n  *          <span style=\"font-weight: bold;\"> stat.clear();</span><br/>\n- *          System.out.println(\"mean after clear is NaN = \" + <span style=\"font-weight: bold;\">stat.getResult()</span>);\n+ *          out.println(\"mean after clear is NaN = \" + <span style=\"font-weight: bold;\">stat.getResult()</span>);\n  *        </code>\n  *\n  */\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n  */\n package org.apache.commons.math.util;\n \n+import java.io.PrintStream;\n+\n /**\n  * Faster, more accurate, portable alternative to {@link Math} and\n  * {@link StrictMath} for large scale computation.\n  * FastMath speed is achieved by relying heavily on optimizing compilers\n  * to native code present in many JVMs today and use of large tables.\n  * The larger tables are lazily initialised on first use, so that the setup\n- * time does not penalise methods that don't need them. \n+ * time does not penalise methods that don't need them.\n  * </p>\n  * <p>\n  * Note that FastMath is\n     /** Napier's constant e, base of the natural logarithm. */\n     public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n \n+    /** Constant 2<sup>10</sup>. */\n     private static final int TWO_POWER_10 = 1024;\n \n     /** Indicator for tables initialization.\n \n     /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */\n     private static final int SINE_TABLE_LEN = 14;\n-    \n+\n     /** Sine table (high bits). */\n     private static final double SINE_TABLE_A[] =\n         {\n \n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n-    \n+\n     /**\n      * Private Constructor\n      */\n \n       // cosh[z] = (exp(z) + exp(-z))/2\n \n-      // for numbers with magnitude 20 or so, \n+      // for numbers with magnitude 20 or so,\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20.0) {\n       }\n \n       // sinh[z] = (exp(z) - exp(-z) / 2\n-      \n-      // for values of z larger than about 20, \n+\n+      // for values of z larger than about 20,\n       // exp(-z) can be ignored in comparison with exp(z)\n-      \n+\n       if (x > 20.0) {\n           return exp(x)/2.0;\n       }\n           return x;\n       }\n \n-      // tanh[z] = sinh[z] / cosh[z] \n+      // tanh[z] = sinh[z] / cosh[z]\n       // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n       // = (exp(2x) - 1) / (exp(2x) + 1)\n-      \n+\n       // for magnitude > 20, sinh[z] == cosh[z] in double precision\n \n       if (x > 20.0) {\n         return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n     }\n \n-    // print out contents of arrays, and check the length\n-    // used to generate the preset arrays originally\n-    public static void main(String[] a){\n-        FastMathCalc.printarray(\"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n-        FastMathCalc.printarray(\"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n-        FastMathCalc.printarray(\"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n-        FastMathCalc.printarray(\"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n-        FastMathCalc.printarray(\"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n-        FastMathCalc.printarray(\"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n-        FastMathCalc.printarray(\"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n-        FastMathCalc.printarray(\"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n-        FastMathCalc.printarray(\"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n-        FastMathCalc.printarray(\"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n-        FastMathCalc.printarray(\"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n+    /**\n+     * Print out contents of arrays, and check the length.\n+     * <p>used to generate the preset arrays originally.</p>\n+     * @param a unused\n+     */\n+    public static void main(String[] a) {\n+        PrintStream out = System.out;\n+        FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n+        FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n+        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n+        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n+        FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n+        FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n+        FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n+        FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n+        FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n+        FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n+        FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n     }\n \n \n     /** Length of the array of integer exponentials. */\n     static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n \n-    // Enclose large data table in nested static class so it's only loaded on first access\n+    /** Enclose large data table in nested static class so it's only loaded on first access. */\n     private static class ExpIntTable {\n         /** Exponential evaluated at integer values,\n          * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n         }\n     }\n \n+    /** Exponential fractions table length. */\n     static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n \n-    // Enclose large data table in nested static class so it's only loaded on first access\n+    /** Enclose large data table in nested static class so it's only loaded on first access. */\n     private static class ExpFracTable {\n         /** Exponential over the range of 0 - 1 in increments of 2^-10\n          * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n         }\n     }\n \n+    /** Logarithm table length. */\n     static final int LN_MANT_LEN = TWO_POWER_10; // (see LN_MANT comment below)\n \n-    // Enclose large data table in nested static class so it's only loaded on first access\n+    /** Enclose large data table in nested static class so it's only loaded on first access. */\n     private static class lnMant {\n         /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n         private static final double[][] LN_MANT;\n             } else if (LOAD_RESOURCES) {\n                 LN_MANT = FastMathResources.loadLnMant();\n             } else {\n-                LN_MANT = new double[][] { \n+                LN_MANT = new double[][] {\n       {+0.0d,                   +0.0d,                   }, // 0\n       {+9.760860120877624E-4d,  -3.903230345984362E-11d, }, // 1\n       {+0.0019512202125042677d, -8.124251825289188E-11d, }, // 2\n--- a/src/main/java/org/apache/commons/math/util/FastMathCalc.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMathCalc.java\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n  *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- * \n  */\n-\n package org.apache.commons.math.util;\n \n+import java.io.PrintStream;\n+\n import org.apache.commons.math.exception.DimensionMismatchException;\n \n+/** Class used to compute the classical functions tables.\n+ * @version $Id$\n+ * @since 3.0\n+ */\n class FastMathCalc {\n \n     /**\n     private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n \n     /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n-    private static final double FACT[] = new double[] \n+    private static final double FACT[] = new double[]\n         {\n-        +1.0d,                        // 0               \n+        +1.0d,                        // 0\n         +1.0d,                        // 1\n         +2.0d,                        // 2\n         +6.0d,                        // 3\n         {0.14982303977012634, 1.225743062930824E-8},\n     };\n \n+    /** Table start declaration. */\n+    private static final String TABLE_START_DECL = \"    {\";\n+\n+    /** Table end declaration. */\n+    private static final String TABLE_END_DECL   = \"    };\";\n+\n+    /**\n+     * Private Constructor.\n+     */\n+    private FastMathCalc() {\n+    }\n+\n     /** Build the sine and cosine tables.\n-     * @param SINE_TABLE_A \n-     * @param SINE_TABLE_B \n-     * @param COSINE_TABLE_A \n-     * @param COSINE_TABLE_B \n-     * @param SINE_TABLE_LEN \n-     * @param TANGENT_TABLE_A \n-     * @param TANGENT_TABLE_B \n+     * @param SINE_TABLE_A table of the most significant part of the sines\n+     * @param SINE_TABLE_B table of the least significant part of the sines\n+     * @param COSINE_TABLE_A table of the most significant part of the cosines\n+     * @param COSINE_TABLE_B table of the most significant part of the cosines\n+     * @param SINE_TABLE_LEN length of the tables\n+     * @param TANGENT_TABLE_A table of the most significant part of the tangents\n+     * @param TANGENT_TABLE_B table of the most significant part of the tangents\n      */\n     @SuppressWarnings(\"unused\")\n-    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n+    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,\n+                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,\n+                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n         final double result[] = new double[2];\n \n         /* Use taylor series for 0 <= x <= 6/8 */\n     }\n \n \n-    static void printarray(String string, int expectedLen, double[][] array2d) {\n-        System.out.println(string);\n+    /**\n+     * Print an array.\n+     * @param out text output stream where output should be printed\n+     * @param name array name\n+     * @param expectedLen expected length of the array\n+     * @param array2d array data\n+     */\n+    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n+        out.println(name);\n         checkLen(expectedLen, array2d.length);\n-        System.out.println(\"    { \");\n+        out.println(TABLE_START_DECL + \" \");\n         int i = 0;\n         for(double array[] : array2d) {\n-            System.out.print(\"        {\");\n+            out.print(\"        {\");\n             for(double d : array) { // assume inner array has very few entries\n-                String ds = d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n-                System.out.printf(\"%-25.25s\",ds); // multiple entries per line\n+                out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n             }\n-            System.out.println(\"}, // \"+i++);\n-        }\n-        System.out.println(\"    };\");\n-    }\n-\n-    static void printarray(String string, int expectedLen, double[] array) {\n-        System.out.println(string+\"=\");\n+            out.println(\"}, // \" + i++);\n+        }\n+        out.println(TABLE_END_DECL);\n+    }\n+\n+    /**\n+     * Print an array.\n+     * @param out text output stream where output should be printed\n+     * @param name array name\n+     * @param expectedLen expected length of the array\n+     * @param array array data\n+     */\n+    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {\n+        out.println(name + \"=\");\n         checkLen(expectedLen, array.length);\n-        System.out.println(\"    {\");\n+        out.println(TABLE_START_DECL);\n         for(double d : array){\n-            String ds = d!=d ? \"Double.NaN,\" : d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n-            System.out.printf(\"        %s%n\",ds); // one entry per line\n-        }\n-        System.out.println(\"    };\");\n-    }\n-\n-    private static void checkLen(int expectedLen, int actual) {\n+            out.printf(\"        %s%n\", format(d)); // one entry per line\n+        }\n+        out.println(TABLE_END_DECL);\n+    }\n+\n+    /** Format a double.\n+     * @param d double number to format\n+     * @return formatted number\n+     */\n+    static String format(double d) {\n+        if (d != d) {\n+            return \"Double.NaN,\";\n+        } else {\n+            return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n+        }\n+    }\n+\n+    /**\n+     * Check two lengths are equal.\n+     * @param expectedLen expected length\n+     * @param actual actual length\n+     * @exception DimensionMismatchException if the two lengths are not equal\n+     */\n+    private static void checkLen(int expectedLen, int actual)\n+        throws DimensionMismatchException {\n         if (expectedLen != actual) {\n             throw new DimensionMismatchException(actual, expectedLen);\n         }\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n     try {\n         oos.writeObject(interpolator);\n         Assert.fail(\"an exception should have been thrown\");\n-    } catch (IOException ioe) {\n+    } catch (MathIllegalStateException mise) {\n         // expected behavior\n-        Assert.assertEquals(0, ioe.getMessage().length());\n+        Assert.assertEquals(0, mise.getMessage().length());\n     }\n   }\n ", "timestamp": 1317584597, "metainfo": ""}