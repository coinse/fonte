{"sha": "04c3ab9b355b2c52e0178533068dd22586c0eabf", "log": "Improved Javadoc and fixed comparison error in indicator(short). Contributed by: Christopher Schuck Pr #28194   ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n  *\n- * @version $Revision: 1.12 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/05 03:47:49 $\n  */\n public final class MathUtils {\n-\n-\tprivate static final byte ZB = (byte) 0;\n-\t\n-\tprivate static final byte NB = (byte) -1;\n-\t\n-\tprivate static final byte PB = (byte) 1;\n-\t\n-\tprivate static final short ZS = (short) 0;\n-\t\n-\tprivate static final short NS = (short) -1;\n-\t\n-\tprivate static final short PS = (short) 1;\n-\t\n+    \n+    private static final byte ZB = (byte) 0;\n+    \n+    private static final byte NB = (byte) -1;\n+    \n+    private static final byte PB = (byte) 1;\n+    \n+    private static final short ZS = (short) 0;\n+    \n+    private static final short NS = (short) -1;\n+    \n+    private static final short PS = (short) 1;\n+    \n     /**\n      * Private Constructor\n      */\n     private MathUtils() {\n     }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * +1.0 : x < 0.0\n-     *  0.0 : x = 0.0\n-     * -1.0 : x > 0.0\n-     * \n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for double precision <code>x</code>.\n+     *\n+     * <p>\n+     * For a double value <code>x</code>, this method returns <code>+1.0</code>\n+     * if <code>x > 0</code>, <code>0.0</code> if <code>x = 0.0</code>,\n+     * and <code>-1.0</code> if <code>x < 0</code>.  Returns <code>NaN</code> \n+     * if <code>x</code> is <code>NaN</code>.\n+     *\n      * @param x the value, a double\n-     * @return +1.0, 0.0 or -1.0, depending on the the value of x\n+     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n      */\n     public static double sign(final double x) {\n-    \tif (Double.isNaN(x)) {\n-    \t\treturn Double.NaN;\n-    \t}\n-    \treturn (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n-    }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * +1.0F : x < 0.0F\n-     *  0.0F : x = 0.0F\n-     * -1.0F : x > 0.0F\n-     * \n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for float value <code>x</code>.\n+     *\n+     * <p>\n+     * For a float value x, this method returns +1.0F if x > 0, 0.0F if\n+     * x = 0.0F, and -1.0F if x < 0.  Returns <code>NaN</code> \n+     * if <code>x</code> is <code>NaN</code>.\n+     *\n+     * @param x the value, a float\n+     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n+     */\n+    public static float sign(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for byte value <code>x</code>.\n+     *\n+     * <p>\n+     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0)\n+     * if x = 0, and (byte)(-1) if x < 0.\n+     *\n+     * @param x the value, a byte\n+     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte sign(final byte x) {\n+        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for short value <code>x</code>.\n+     *\n+     * <p>\n+     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n+     * if x = 0, and (short)(-1) if x < 0.\n+     *\n+     * @param x the value, a short\n+     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign\n+     * of x\n+     */\n+    public static short sign(final short x) {\n+        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for int value <code>x</code>.\n+     *\n+     * <p>\n+     * For an int value x, this method returns +1 if x > 0, 0 if x = 0,\n+     * and -1 if x < 0.\n+     *\n+     * @param x the value, an int\n+     * @return +1, 0, or -1, depending on the sign of x\n+     */\n+    public static int sign(final int x) {\n+        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n+     * sign</a> for long value <code>x</code>.\n+     *\n+     * <p>\n+     * For a long value x, this method returns +1L if x > 0, 0L if x = 0,\n+     * and -1L if x < 0.\n+     *\n+     * @param x the value, a long\n+     * @return +1L, 0L, or -1L, depending on the sign of x\n+     */\n+    public static long sign(final long x) {\n+        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n+    }\n+    \n+    /**\n+     * For a double precision value x, this method returns +1.0 if x >= 0\n+     * and -1.0 if x < 0.   Returns <code>NaN</code> \n+     * if <code>x</code> is <code>NaN</code>.\n+     *\n+     * @param x the value, a double\n+     * @return +1.0 or -1.0, depending on the sign of x\n+     */\n+    public static double indicator(final double x) {\n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x >= 0.0) ? 1.0 : -1.0;\n+    }\n+    \n+    /**\n      * For a float value x, this method returns +1.0F if x >= 0\n-     * and -1.0F if x < 0.\n+     * and -1.0F if x < 0.   Returns <code>NaN</code> \n+     * if <code>x</code> is <code>NaN</code>.\n+     *\n      * @param x the value, a float\n-     * @return +1.0F or -1.0F, depending on the the sign of x\n-     */\n-    public static float sign(final float x) {\n-    \tif (Float.isNaN(x)) {\n-    \t\treturn Float.NaN;\n-    \t}\n-    \treturn (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n-    }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * (byte)+1.0 : x < (byte)0.0\n-     * (byte) 0.0 : x = (byte)0.0\n-     * (byte)-1.0 : x > (byte)0.0\n-     * \n+     * @return +1.0F or -1.0F, depending on the sign of x\n+     */\n+    public static float indicator(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x >= 0.0F) ? 1.0F : -1.0F;\n+    }\n+    \n+    /**\n      * For a byte value x, this method returns (byte)(+1) if x >= 0\n      * and (byte)(-1) if x < 0.\n+     *\n      * @param x the value, a byte\n-     * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n-     */\n-    public static byte sign(final byte x) {\n-    \treturn (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n-    }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * (short)+1.0 : x < (short)0.0\n-     * (short) 0.0 : x = (short)0.0\n-     * (short)-1.0 : x > (short)0.0\n-     * \n+     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte indicator(final byte x) {\n+        return (x >= ZB) ? PB : NB;\n+    }\n+    \n+    /**\n      * For a short value x, this method returns (short)(+1) if x >= 0\n      * and (short)(-1) if x < 0.\n      *\n      * @param x the value, a short\n-     * @return (short)(+1) or (short)(-1), depending on the the sign of x\n-     */\n-    public static short sign(final short x) {\n-    \treturn (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n-    }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * +1.0 : x < 0.0\n-     *  0.0 : x = 0.0\n-     * -1.0 : x > 0.0\n-     * \n+     * @return (short)(+1) or (short)(-1), depending on the sign of x\n+     */\n+    public static short indicator(final short x) {\n+        return (x >= ZS) ? PS : NS;\n+    }\n+    \n+    /**\n      * For an int value x, this method returns +1 if x >= 0\n      * and -1 if x < 0.\n      *\n      * @param x the value, an int\n-     * @return +1 or -1, depending on the the sign of x\n-     */\n-    public static int sign(final int x) {\n-    \treturn (x == 0) ? 0 : (x > 0) ? 1 : -1;\n-    }\n-\n-    /**\n-     * Based on rules for sign function as defined in\n-     * http://mathworld.wolfram.com/Sign.html\n-     * \n-     * +1L : x < 0L\n-     *  0L : x = 0L\n-     * -1L : x > 0L\n-     * \n+     * @return +1 or -1, depending on the sign of x\n+     */\n+    public static int indicator(final int x) {\n+        return (x >= 0) ? 1 : -1;\n+    }\n+    \n+    /**\n      * For a long value x, this method returns +1L if x >= 0\n      * and -1L if x < 0.\n      *\n      * @param x the value, a long\n-     * @return +1L or -1L, depending on the the sign of x\n-     */\n-    public static long sign(final long x) {\n-    \treturn (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n-    }\n-    \n-    /**\n-     * For a double precision value x, this method returns +1.0 if x >= 0\n-     * and -1.0 if x < 0.\n-     * @param x the value, a double\n-     * @return +1.0 or -1.0, depending on the the sign of x\n-     */\n-    public static double indicator(final double x) {\n-    \tif (Double.isNaN(x)) {\n-    \t\treturn Double.NaN;\n-    \t}\n-    \treturn (x >= 0.0) ? 1.0 : -1.0;\n-    }\n-\n-    /**\n-     * For a float value x, this method returns +1.0F if x >= 0\n-     * and -1.0F if x < 0.\n-     * @param x the value, a float\n-     * @return +1.0F or -1.0F, depending on the the sign of x\n-     */\n-    public static float indicator(final float x) {\n-    \tif (Float.isNaN(x)) {\n-    \t\treturn Float.NaN;\n-    \t}\n-    \treturn (x >= 0.0F) ? 1.0F : -1.0F;\n-    }\n-\n-    /**\n-     * For a byte value x, this method returns (byte)(+1) if x >= 0\n-     * and (byte)(-1) if x < 0.\n-     * @param x the value, a byte\n-     * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n-     */\n-    public static byte indicator(final byte x) {\n-    \treturn (x >= ZB) ? PB : NB;\n-    }\n-\n-    /**\n-     * For a short value x, this method returns (short)(+1) if x >= 0\n-     * and (short)(-1) if x < 0.\n-     *\n-     * @param x the value, a short\n-     * @return (short)(+1) or (short)(-1), depending on the the sign of x\n-     */\n-    public static short indicator(final short x) {\n-        return (x > ZS) ? PS : NS;\n-    }\n-\n-    /**\n-     * For an int value x, this method returns +1 if x >= 0\n-     * and -1 if x < 0.\n-     *\n-     * @param x the value, an int\n-     * @return +1 or -1, depending on the the sign of x\n-     */\n-    public static int indicator(final int x) {\n-    \treturn (x >= 0) ? 1 : -1;\n-    }\n-\n-    /**\n-     * For a long value x, this method returns +1L if x >= 0\n-     * and -1L if x < 0.\n-     *\n-     * @param x the value, a long\n-     * @return +1L or -1L, depending on the the sign of x\n+     * @return +1L or -1L, depending on the sign of x\n      */\n     public static long indicator(final long x) {\n         return (x >= 0L) ? 1L : -1L;\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n      * <li> <code>0 < k <= n </code> (otherwise\n-     * <li> <code>0 < k <= n </code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>. The\n-     *      largest value of <code>n</code> for which all coefficients are\n-     *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n      * <li> The result is small enough to fit into a <code>long</code>.  The\n      *      largest value of <code>n</code> for which all coefficients are\n      *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n      *      </code> is thrown.</li>\n      * </ul>\n      *\n-     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n     public static long binomialCoefficient(final int n, final int k) {\n         if (n < k) {\n             throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n+            \"must have n >= k for binomial coefficient (n,k)\");\n         }\n         if (n <= 0) {\n             throw new IllegalArgumentException(\n-                \"must have n > 0 for binomial coefficient (n,k)\");\n+            \"must have n > 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 1;\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-\n+        \n         long result = Math.round(binomialCoefficientDouble(n, k));\n         if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n-                \"result too large to represent in a long integer\");\n+            \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n-\n+    \n     /**\n      * Returns a <code>double</code> representation of the\n      * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n     public static double binomialCoefficientDouble(final int n, final int k) {\n         return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n     }\n-\n+    \n     /**\n      * Returns the natural <code>log</code> of the\n      * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n     public static double binomialCoefficientLog(final int n, final int k) {\n         if (n < k) {\n             throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n+            \"must have n >= k for binomial coefficient (n,k)\");\n         }\n         if (n <= 0) {\n             throw new IllegalArgumentException(\n-                \"must have n > 0 for binomial coefficient (n,k)\");\n+            \"must have n > 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 0;\n             return Math.log((double) n);\n         }\n         double logSum = 0;\n-\n+        \n         // n!/k!\n         for (int i = k + 1; i <= n; i++) {\n             logSum += Math.log((double) i);\n         }\n-\n+        \n         // divide by (n-k)!\n         for (int i = 2; i <= n - k; i++) {\n             logSum -= Math.log((double) i);\n         }\n-\n+        \n         return logSum;\n     }\n-\n+    \n     /**\n      * Returns n!.  Shorthand for <code>n</code>\n      * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n      * Factorial</a>, the product of the numbers <code>1,...,n</code>.\n-     * \n+     *\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n      * <li> <code>n > 0</code> (otherwise\n      *      </code> is thrown.</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      */\n         long result = Math.round(factorialDouble(n));\n         if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n-                \"result too large to represent in a long integer\");\n+            \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n-\n+    \n     /**\n      * Returns n!.  Shorthand for <code>n</code>\n      * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n      * Factorial</a>, the product of the numbers <code>1,...,n</code> as a\n      * <code>double</code>.\n-     * \n+     *\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n      * <li> <code>n > 0</code> (otherwise\n      *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      */\n         }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n-\n-    /**\n-      * Returns the natural logarithm of n!.\n-      * <p>\n-      * <Strong>Preconditions</strong>:<ul>\n-      * <li> <code>n > 0</code> (otherwise\n-      *      <code>IllegalArgumentException</code> is thrown)</li>\n-      * </ul>\n-      *\n-      * @param n argument\n-      * @return <code>n!</code>\n-      */\n+    \n+    /**\n+     * Returns the natural logarithm of n!.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul>\n+     *\n+     * @param n argument\n+     * @return <code>n!</code>\n+     */\n     public static double factorialLog(final int n) {\n         if (n <= 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n     }\n     \n     /**\n-     * \n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n+     * hyperbolic cosine</a> of x.\n+     *\n+     * @param x double value for which to find the hyperbolic cosine\n+     * @return hyperbolic cosine of x\n      */\n     public static double cosh(double x) {\n         return (Math.exp(x) + Math.exp(-x)) / 2.0;\n     }\n     \n     /**\n-     * \n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * hyperbolic sine</a> of x.\n+     *\n+     * @param x double value for which to find the hyperbolic sine\n+     * @return hyperbolic sine of x\n      */\n     public static double sinh(double x) {\n         return (Math.exp(x) - Math.exp(-x)) / 2.0;\n     }\n-}\n+}", "timestamp": 1081136869, "metainfo": ""}