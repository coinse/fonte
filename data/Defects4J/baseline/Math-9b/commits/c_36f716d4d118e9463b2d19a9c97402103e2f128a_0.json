{"sha": "36f716d4d118e9463b2d19a9c97402103e2f128a", "log": "fixed nextAfter implementations for handling of some special values fixed the signature of the float version, as the spec is to have a double second argument moved the existing tests that were used in the former implementation in MathUtils, fixing them also as two of them were not compliant with the spec for equal numbers Jira: MATH-478  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n  * <li>{@link #asinh(double)}</li>\n  * <li>{@link #acosh(double)}</li>\n  * <li>{@link #atanh(double)}</li>\n- * <li>{@link #nextAfter(float,float)}</li>\n  * </ul>\n  * The following methods are found in StrictMath since 1.6 only\n  * <ul>\n  * <li>{@link #nextUp(double)}</li>\n  * <li>{@link #copySign(float, float)}</li>\n  * <li>{@link #getExponent(float)}</li>\n+ * <li>{@link #nextAfter(float,double)}</li>\n  * <li>{@link #nextUp(float)}</li>\n  * </ul>\n  * @version $Revision$ $Date$\n     public static double nextAfter(double d, double direction) {\n \n         // handling of some important special cases\n-        if (Double.isNaN(d)) {\n-            return d;\n+        if (Double.isNaN(d) || Double.isNaN(direction)) {\n+            return Double.NaN;\n+        } else if (d == direction) {\n+            return direction;\n         } else if (Double.isInfinite(d)) {\n-            if (d < direction) {\n-                return -Double.MAX_VALUE;\n-            } else if (direction < d) {\n-                return Double.MAX_VALUE;\n-            } else {\n-                return d;\n-            }\n+            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n         } else if (d == 0) {\n             return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n         }\n         // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n         // are handled just as normal numbers\n \n-        // split the double in raw components\n-        long bits     = Double.doubleToLongBits(d);\n-        long sign     = bits & 0x8000000000000000L;\n-        long exponent = bits & 0x7ff0000000000000L;\n-        long mantissa = bits & 0x000fffffffffffffL;\n-\n-        if (d * (direction - d) >= 0) {\n-            // we should increase the mantissa\n-            if (mantissa == 0x000fffffffffffffL) {\n-                return Double.longBitsToDouble(sign |\n-                                               (exponent + 0x0010000000000000L));\n-            } else {\n-                return Double.longBitsToDouble(sign |\n-                                               exponent | (mantissa + 1));\n-            }\n+        final long bits = Double.doubleToLongBits(d);\n+        final long sign = bits & 0x8000000000000000L;\n+        if ((direction < d) ^ (sign == 0L)) {\n+            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n         } else {\n-            // we should decrease the mantissa\n-            if (mantissa == 0L) {\n-                return Double.longBitsToDouble(sign |\n-                                               (exponent - 0x0010000000000000L) |\n-                                               0x000fffffffffffffL);\n-            } else {\n-                return Double.longBitsToDouble(sign |\n-                                               exponent | (mantissa - 1));\n-            }\n+            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n         }\n \n     }\n      * direction is greater or smaller than f)\n      * @return the next machine representable number in the specified direction\n      */\n-    public static float nextAfter(float f, float direction) {\n+    public static float nextAfter(final float f, final double direction) {\n \n         // handling of some important special cases\n-        if (Float.isNaN(f)) {\n-            return f;\n+        if (Double.isNaN(f) || Double.isNaN(direction)) {\n+            return Float.NaN;\n+        } else if (f == direction) {\n+            return (float) direction;\n         } else if (Float.isInfinite(f)) {\n-            if (f < direction) {\n-                return -Float.MAX_VALUE;\n-            } else if (direction < f) {\n-                return Float.MAX_VALUE;\n-            } else {\n-                return f;\n-            }\n+            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n         } else if (f == 0f) {\n-            return (direction < 0f) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n+            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n         }\n         // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n         // are handled just as normal numbers\n \n-        // split the double in raw components\n-        int bits     = Float.floatToIntBits(f);\n-        int sign     = bits & 0x80000000;\n-        int exponent = bits & 0x7f800000;\n-        int mantissa = bits & 0x007fffff;\n-\n-        if (f * (direction - f) >= 0f) {\n-            // we should increase the mantissa\n-            if (mantissa == 0x000fffff) {\n-                return Float.intBitsToFloat(sign | (exponent + 0x00800000));\n-            } else {\n-                return Float.intBitsToFloat(sign | exponent | (mantissa + 1));\n-            }\n+        final int bits = Float.floatToIntBits(f);\n+        final int sign = bits & 0x80000000;\n+        if ((direction < f) ^ (sign == 0)) {\n+            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n         } else {\n-            // we should decrease the mantissa\n-            if (mantissa == 0) {\n-                return Float.intBitsToFloat(sign | (exponent - 0x00800000) | 0x007fffff);\n-            } else {\n-                return Float.intBitsToFloat(sign | exponent | (mantissa - 1));\n-            }\n+            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n \n     }\n \n+    @Test\n+    public void testNextAfter() {\n+        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n+        Assert.assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n+        Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n+\n+        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n+        Assert.assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n+        Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n+\n+        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n+        Assert.assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);\n+\n+        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n+        Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);\n+\n+        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n+        Assert.assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);\n+\n+        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n+        Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n+        Assert.assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a223\n+        Assert.assertEquals(2.3089223996676606E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n+        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n+        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n+        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n+        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n+        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n+        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n+        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n+        Assert.assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a223\n+        Assert.assertEquals(-2.3089223996676606E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+\n+        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n+        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+\n+    }\n+\n+    @Test\n+    public void testDoubleNextAfterSpecialCases() {\n+        Assert.assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D), 0D);\n+        Assert.assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D), 0D);\n+        Assert.assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D), 0D);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY), 0D);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), 0D);\n+        Assert.assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D);\n+        Assert.assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D);\n+        Assert.assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D);\n+        Assert.assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D);\n+    }\n+\n+    @Test\n+    public void testFloatNextAfterSpecialCases() {\n+        Assert.assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F), 0F);\n+        Assert.assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F), 0F);\n+        Assert.assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN, 0F), 0F);\n+        Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY), 0F);\n+        Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY), 0F);\n+        Assert.assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F);\n+        Assert.assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F);\n+        Assert.assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F);\n+        Assert.assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);\n+    }\n+\n     private static void reportError(String message) {\n         final boolean fatal = false;\n         if (fatal) {\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         }\n     }\n \n-    public void testNextAfter() {\n-        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n-        assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n-\n-        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n-        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n-\n-        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n-        assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n-\n-        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n-        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n-\n-        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n-        assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);\n-\n-        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n-        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);\n-\n-        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n-        assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);\n-\n-        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n-        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);\n-\n-        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n-        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n-\n-        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224\n-        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n-\n-        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n-\n-        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n-\n-        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n-\n-        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n-        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224\n-        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n-\n-        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n-\n-    }\n-\n-    public void testDoubleNextAfterSpecialCases() {\n-        assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D));\n-        assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D));\n-        assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D));\n-        assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY));\n-        assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY));\n-        assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D);\n-        assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D);\n-        assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D);\n-        assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D);\n-    }\n-\n-    public void testFloatNextAfterSpecialCases() {\n-        assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F));\n-        assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F));\n-        assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN, 0F));\n-        assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY));\n-        assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY));\n-        assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F);\n-        assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F);\n-        assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F);\n-        assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);\n-    }\n-\n     public void testScalb() {\n         assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n         assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);", "timestamp": 1295780784, "metainfo": ""}