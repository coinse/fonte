{"sha": "875bdf01c34ff76004b174c8c2e594d7558fc64e", "log": "Made pseudo-inverse consistent with rank computation in SingularValueDecompositionImpl. JIRA: MATH-601 Reported by Chris Nix Patched by Chris Nix and Greg Sterijevxki  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Calculates the compact Singular Value Decomposition of a matrix.\n     private final RealMatrix cachedV;\n     /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n+    /** Tolerance value for small singular values, calculated once we have populated singularValues **/\n+    private final double tol;\n \n     /**\n      * Calculates the compact Singular Value Decomposition of the given matrix.\n             m = matrix.getRowDimension();\n             n = matrix.getColumnDimension();\n         }\n- \n+\n         singularValues = new double[n];\n         final double[][] U = new double[m][n];\n         final double[][] V = new double[n][n];\n             }\n         }\n \n+        // Set the small value tolerance used to calculate rank and pseudo-inverse\n+        tol = FastMath.max(FastMath.max(m, n) * singularValues[0] * EPS,\n+                FastMath.sqrt( MathUtils.SAFE_MIN));\n+\n         if (!transposed) {\n             cachedU = MatrixUtils.createRealMatrix(U);\n             cachedV = MatrixUtils.createRealMatrix(V);\n \n     /** {@inheritDoc} */\n     public int getRank() {\n-        final double tol = m * singularValues[0] * EPS;\n         int r = 0;\n         for (int i = 0; i < singularValues.length; i++) {\n             if (singularValues[i] > tol) {\n \n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n-        return new Solver(singularValues, getUT(), getV(), getRank() == m);\n+        return new Solver(singularValues, getUT(), getV(), getRank() == m, tol);\n     }\n \n     /** Specialized solver. */\n          * @param uT U<sup>T</sup> matrix of the decomposition.\n          * @param v V matrix of the decomposition.\n          * @param nonSingular Singularity indicator.\n+         * @param tol tolerance for singular values\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT,\n-                       final RealMatrix v, final boolean nonSingular) {\n+                       final RealMatrix v, final boolean nonSingular, final double tol) {\n             final double[][] suT = uT.getData();\n             for (int i = 0; i < singularValues.length; ++i) {\n                 final double a;\n-                if (singularValues[i] > 0) {\n+                if (singularValues[i] > tol) {\n                     a = 1 / singularValues[i];\n                 } else {\n                     a = 0;", "timestamp": 1313216412, "metainfo": ""}