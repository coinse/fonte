{"sha": "87ccced5653a90bbd8f05e918298e4ea24aff875", "log": "improved test coverage  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.junit.Assert;\n import org.junit.Test;\n         // this test does not really test FirstOrderIntegratorWithJacobians,\n         // it only shows that WITHOUT this class, attempting to recover\n         // the jacobians from external differentiation on simple integration\n-        // results with loo accuracy gives very poor results. In fact,\n+        // results with low accuracy gives very poor results. In fact,\n         // the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are\n         // essentially noise.\n         // This test is taken from Hairer, Norsett and Wanner book\n             double hY = 1.0e-12;\n             FirstOrderIntegratorWithJacobians extInt =\n                 new FirstOrderIntegratorWithJacobians(integ, brusselator, new double[] { b },\n-                                                 new double[] { hY, hY }, new double[] { hP });\n+                                                      new double[] { hY, hY }, new double[] { hP });\n             extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n             residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());\n             residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());\n \n     @Test\n     public void testAnalyticalDifferentiation()\n-        throws IntegratorException, DerivativeException, OptimizationException {\n+        throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         Assert.assertTrue(residualsP1.getStandardDeviation() < 0.0010);\n     }\n \n+    @Test\n+    public void testFinalResult() throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+        double[] y = new double[] { 0.0, 1.0 };\n+        Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n+        double[][] dydy0 = new double[2][2];\n+        double[][] dydp  = new double[2][3];\n+        double t = 18 * Math.PI;\n+        FirstOrderIntegratorWithJacobians extInt =\n+            new FirstOrderIntegratorWithJacobians(integ, circle);\n+        extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n+        for (int i = 0; i < y.length; ++i) {\n+            Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-10);\n+        }\n+        for (int i = 0; i < dydy0.length; ++i) {\n+            for (int j = 0; j < dydy0[i].length; ++j) {\n+                Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-10);\n+            }\n+        }\n+        for (int i = 0; i < dydp.length; ++i) {\n+            for (int j = 0; j < dydp[i].length; ++j) {\n+                Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-8);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStepHandlerResult() throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+        double[] y = new double[] { 0.0, 1.0 };\n+        final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n+        double[][] dydy0 = new double[2][2];\n+        double[][] dydp  = new double[2][3];\n+        double t = 18 * Math.PI;\n+        FirstOrderIntegratorWithJacobians extInt =\n+            new FirstOrderIntegratorWithJacobians(integ, circle);\n+        extInt.addStepHandler(new StepHandlerWithJacobians() {\n+            \n+            public void reset() {\n+            }\n+            \n+            public boolean requiresDenseOutput() {\n+                return false;\n+            }\n+            \n+            public void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast)\n+                throws DerivativeException {\n+                double     t     = interpolator.getCurrentTime();\n+                double[]   y     = interpolator.getInterpolatedY();\n+                double[][] dydy0 = interpolator.getInterpolatedDyDy0();\n+                double[][] dydp  = interpolator.getInterpolatedDyDp();\n+                for (int i = 0; i < y.length; ++i) {\n+                    Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-10);\n+                }\n+                for (int i = 0; i < dydy0.length; ++i) {\n+                    for (int j = 0; j < dydy0[i].length; ++j) {\n+                        Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-10);\n+                    }\n+                }\n+                for (int i = 0; i < dydp.length; ++i) {\n+                    for (int j = 0; j < dydp[i].length; ++j) {\n+                        Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-8);\n+                    }\n+                }\n+\n+                double[]   yDot     = interpolator.getInterpolatedYDot();\n+                double[][] dydy0Dot = interpolator.getInterpolatedDyDy0Dot();\n+                double[][] dydpDot  = interpolator.getInterpolatedDyDpDot();\n+\n+                for (int i = 0; i < yDot.length; ++i) {\n+                    Assert.assertEquals(circle.exactYDot(t)[i], yDot[i], 1.0e-11);\n+                }\n+                for (int i = 0; i < dydy0Dot.length; ++i) {\n+                    for (int j = 0; j < dydy0Dot[i].length; ++j) {\n+                        Assert.assertEquals(circle.exactDyDy0Dot(t)[i][j], dydy0Dot[i][j], 1.0e-11);\n+                    }\n+                }\n+                for (int i = 0; i < dydpDot.length; ++i) {\n+                    for (int j = 0; j < dydpDot[i].length; ++j) {\n+                        Assert.assertEquals(circle.exactDyDpDot(t)[i][j], dydpDot[i][j], 1.0e-9);\n+                    }\n+                }\n+            }\n+        });\n+        extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n+    }\n+\n     private static class Brusselator implements ParameterizedODEWithJacobians {\n \n         private double b;\n \n     };\n \n+    /** ODE representing a point moving on a circle with provided center and angular rate. */\n+    private static class Circle implements ParameterizedODEWithJacobians {\n+\n+        private final double[] y0;\n+        private double cx;\n+        private double cy;\n+        private double omega;\n+\n+        public Circle(double[] y0, double cx, double cy, double omega) {\n+            this.y0    = y0.clone();\n+            this.cx    = cx;\n+            this.cy    = cy;\n+            this.omega = omega;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void setParameter(int i, double p) {\n+            if (i == 0) {\n+                cx = p;\n+            } else if (i == 1) {\n+                cy = p;\n+            } else {\n+                omega = p;\n+            }\n+        }\n+\n+        public int getParametersDimension() {\n+            return 3;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            yDot[0] = omega * (cy - y[1]);\n+            yDot[1] = omega * (y[0] - cx);\n+        }\n+\n+        public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {\n+\n+            dFdY[0][0] = 0;\n+            dFdY[0][1] = -omega;\n+            dFdY[1][0] = omega;\n+            dFdY[1][1] = 0;\n+\n+            dFdP[0][0] = 0;\n+            dFdP[0][1] = omega;\n+            dFdP[0][2] = cy - y[1];\n+            dFdP[1][0] = -omega;\n+            dFdP[1][1] = 0;\n+            dFdP[1][2] = y[0] - cx;\n+ \n+        }\n+\n+        public double[] exactY(double t) {\n+            double cos = Math.cos(omega * t);\n+            double sin = Math.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] {\n+                cx + cos * dx0 - sin * dy0,\n+                cy + sin * dx0 + cos * dy0\n+            };\n+        }\n+\n+        public double[][] exactDyDy0(double t) {\n+            double cos = Math.cos(omega * t);\n+            double sin = Math.sin(omega * t);\n+            return new double[][] {\n+                { cos, -sin },\n+                { sin,  cos }\n+            };\n+        }\n+\n+        public double[][] exactDyDp(double t) {\n+            double cos = Math.cos(omega * t);\n+            double sin = Math.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[][] {\n+                { 1 - cos, sin,    -t * (sin * dx0 + cos * dy0) },\n+                { -sin,    1 - cos, t * (cos * dx0 - sin * dy0) }\n+            };\n+        }\n+\n+        public double[] exactYDot(double t) {\n+            double oCos = omega * Math.cos(omega * t);\n+            double oSin = omega * Math.sin(omega * t);\n+            double dx0 = y0[0] - cx;\n+            double dy0 = y0[1] - cy;\n+            return new double[] {\n+                -oSin * dx0 - oCos * dy0,\n+                 oCos * dx0 - oSin * dy0\n+            };\n+        }\n+\n+        public double[][] exactDyDy0Dot(double t) {\n+            double oCos = omega * Math.cos(omega * t);\n+            double oSin = omega * Math.sin(omega * t);\n+            return new double[][] {\n+                { -oSin, -oCos },\n+                {  oCos, -oSin }\n+            };\n+        }\n+\n+        public double[][] exactDyDpDot(double t) {\n+            double cos  = Math.cos(omega * t);\n+            double sin  = Math.sin(omega * t);\n+            double oCos = omega * cos;\n+            double oSin = omega * sin;\n+            double dx0  = y0[0] - cx;\n+            double dy0  = y0[1] - cy;\n+            return new double[][] {\n+                {  oSin, oCos, -sin * dx0 - cos * dy0 - t * ( oCos * dx0 - oSin * dy0) },\n+                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0)}\n+            };\n+        }\n+\n+    };\n+\n }", "timestamp": 1267807150, "metainfo": ""}