{"sha": "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b", "log": "Fixed \"checkstyle\" errors.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n  * @see ConvergenceException\n  * @version $Revision$ $Date$\n  * @since 2.0\n- * @deprecated in 2.2 (to be removed in 3.0). Please use\n- * {@link IterativeAlgorithm} instead.\n+ * @deprecated in 2.2 (to be removed in 3.0).\n  */\n public interface ConvergingAlgorithm {\n \n--- a/src/main/java/org/apache/commons/math/exception/util/ArgUtils.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/ArgUtils.java\n import java.util.List;\n import java.util.ArrayList;\n \n+/**\n+ * Utility class for trensforming the list of arguments passed to\n+ * constructors of exceptions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n public class ArgUtils {\n+    /**\n+     * Class contains only static methods.\n+     */\n+    private ArgUtils() {}\n+\n     /**\n      * Transform a multidimensional array into a one-dimensional list.\n      *\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n      * Check if instance dimension is equal to some expected value.\n      *\n      * @param n expected dimension.\n-     * @exception IllegalArgumentException if the dimension is\n+     * @throws DimensionMismatchException if the dimension is\n      * inconsistent with vector size\n      */\n     protected void checkVectorDimensions(int n)\n--- a/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n /**\n  * Base class for all convergence checker implementations.\n  *\n- * <PAIR> Type of (point, value) pair.\n+ * @param <PAIR> Type of (point, value) pair.\n  *\n  * @version $Revision$ $Date$\n  * @since 3.0\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n     }\n \n     /**\n-     * @param f Function to optimize.\n-     * @param goal Goal type ({@link GoalType#MINIMIZE} or\n-     * {@link GoalType#MAXIMIZE}).\n-     * @param startPoint Start point.\n+     * {@inheritDoc}\n      */\n     public RealPointValuePair optimize(final FUNC f,\n                                        final GoalType goal,\n \n             try {\n                 optima[i] = optimizer.optimize(f, goal,\n-                                               (i == 0 ? startPoint :\n-                                                generator.nextVector()));\n+                                               i == 0 ? startPoint : generator.nextVector());\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException oe) {\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n \n             try {\n                 optima[i] = optimizer.optimize(f, target, weights,\n-                                               (i == 0 ? startPoint :\n-                                                generator.nextVector()));\n+                                               i == 0 ? startPoint : generator.nextVector());\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException oe) {\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n      * @param startPoint Start point for optimization.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n-     * @throws FunctionEvaluationException if the objective function throws one\n-     * during the search.\n-     * @throws DimensionMismatchException if the start point dimension is wrong.\n-     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n-     * exceeded.\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.FunctionEvaluationException if the\n+     * objective function throws one during the search.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the start point dimension is wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n      */\n     RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint)\n         throws FunctionEvaluationException;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n      * function.\n      * @throws FunctionEvaluationException if the objective function throws one\n      * during the search.\n-     * @throws DimensionMismatchException if the start point dimension is wrong.\n-     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n-     * exceeded.\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the start point dimension is wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n      */\n     VectorialPointValuePair optimize(FUNC f, double[] target, double[] weight,\n                                      double[] startPoint)\n--- a/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n  */\n \n package org.apache.commons.math.optimization;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n \n /**\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import java.util.Arrays;\n-import java.util.Comparator;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n  * only point coordinates.\n- * \n+ *\n  * Convergence is considered to have been reached if either the relative\n  * difference between each point coordinate are smaller than a threshold\n  * or if either the absolute difference between the point coordinates are\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         final double c = current.getValue();\n         final double difference = FastMath.abs(p - c);\n         final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n-        return (difference <= size * getRelativeThreshold() ||\n-                difference <= getAbsoluteThreshold());\n+        return difference <= size * getRelativeThreshold() ||\n+            difference <= getAbsoluteThreshold();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n  */\n \n package org.apache.commons.math.optimization;\n-\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n             Arrays.fill(unit, 1.0);\n             setStartConfiguration(unit);\n         }\n-        \n-        final boolean isMinim = (getGoalType() == GoalType.MINIMIZE);\n+\n+        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final Comparator<RealPointValuePair> comparator\n             = new Comparator<RealPointValuePair>() {\n             public int compare(final RealPointValuePair o1,\n      * @param comparator Comparator to use to sort simplex vertices from best to worst.\n      * @throws FunctionEvaluationException if the function cannot be evaluated at\n      * some point.\n-     * @throws TooManyEvaluationsException if the algorithm fails to converge.\n-     * @throws DimensionMismatchException if the start point dimension is wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the algorithm fails to converge.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException if\n+     * the start point dimension is wrong.\n      */\n     protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException;\n      *\n      * @param comparator Comparator to use to sort simplex vertices from best to worst.\n      * @throws FunctionEvaluationException if no value can be computed for the parameters.\n-     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n      */\n     protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n      * @param comparator Comparator to use to sort simplex vertices from best\n      * to poorest.\n      * @return the best point in the transformed simplex.\n-     * @exception FunctionEvaluationException if the function cannot be\n+     * @throws FunctionEvaluationException if the function cannot be\n      * evaluated at some point.\n-     * @exception TooManyEvaluationsException if the maximal number of\n-     * evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n      */\n     private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n-                                              final double coeff,\n-                                              final Comparator<RealPointValuePair> comparator)\n+                                                  final double coeff,\n+                                                  final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException {\n \n         final double[] xSmallest = original[0].getPointRef();\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n      * @return fitted parameters\n      * @exception FunctionEvaluationException if the objective function throws one during\n      * the search\n-     * @exception ConvergenceException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong.\n+     * @exception org.apache.commons.math.exception.ConvergenceException\n+     * if the algorithm failed to converge.\n+     * @exception org.apache.commons.math.exception.DimensionMismatchException\n+     * if the start point dimension is wrong.\n      */\n     public double[] fit(final ParametricRealFunction f,\n                         final double[] initialGuess)\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n import java.io.Serializable;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n import java.io.Serializable;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.exception.ConvergenceException;\n \n /** This class implements a curve fitting specialized for polynomials.\n  * <p>Polynomial fitting is a very simple case of curve fitting. The\n  */\n \n public class PolynomialFitter {\n-\n     /** Fitter for the coefficients. */\n     private final CurveFitter fitter;\n-\n     /** Polynomial degree. */\n     private final int degree;\n \n-    /** Simple constructor.\n+    /**\n+     * Simple constructor.\n+     *\n      * <p>The polynomial fitter built this way are complete polynomials,\n      * ie. a n-degree polynomial has n+1 coefficients.</p>\n      * @param degree maximal degree of the polynomial\n         this.degree = degree;\n     }\n \n-    /** Add an observed weighted (x,y) point to the sample.\n+    /**\n+     * Add an observed weighted (x,y) point to the sample.\n+     *\n      * @param weight weight of the observed point in the fit\n      * @param x abscissa of the point\n      * @param y observed value of the point at x, after fitting we should\n         fitter.clearObservations();\n     }\n \n-    /** Get the polynomial fitting the weighted (x, y) points.\n+    /**\n+     * Get the polynomial fitting the weighted (x, y) points.\n+     *\n      * @return polynomial function best fitting the observed points\n-     * @exception ConvergenceException if the algorithm failed to converge\n+     * @throws org.apache.commons.math.exception.ConvergenceException\n+     * if the algorithm failed to converge.\n      */\n     public PolynomialFunction fit() {\n         try {\n         }\n     }\n \n-    /** Dedicated parametric polynomial class. */\n+    /**\n+     * Dedicated parametric polynomial class.\n+     */\n     private static class ParametricPolynomial implements ParametricRealFunction {\n \n         /** {@inheritDoc} */\n             }\n             return y;\n         }\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n      * @return the gradient at the specified point.\n      * @throws FunctionEvaluationException if the function gradient cannot be\n      * evaluated.\n-     * @throws TooManyEvaluationsException if the allowed number of evaluations\n-     * is exceeded.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the allowed number of evaluations is exceeded.\n      */\n     protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n         throws FunctionEvaluationException {\n--- a/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at the specified point.\n      * @throws FunctionEvaluationException if the function cannot be evaluated.\n-     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n-     * exceeded.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n      */\n     protected double computeObjectiveValue(double[] point)\n         throws FunctionEvaluationException {\n--- a/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractVectorialOptimizer.java\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.BaseMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n \n     /** {@inheritDoc} */\n     public VectorialPointValuePair optimize(FUNC f,\n-                                            double[] target, double[] weight,\n+                                            double[] t, double[] w,\n                                             double[] startPoint)\n         throws FunctionEvaluationException {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         }\n-        if (target == null) {\n+        if (t == null) {\n             throw new NullArgumentException();\n         }\n-        if (weight == null) {\n+        if (w == null) {\n             throw new NullArgumentException();\n         }\n         if (startPoint == null) {\n             throw new NullArgumentException();\n         }\n-        if (target.length != weight.length) {\n-            throw new DimensionMismatchException(target.length, weight.length);\n+        if (t.length != w.length) {\n+            throw new DimensionMismatchException(t.length, w.length);\n         }\n \n         // Reset.\n \n         // Store optimization problem characteristics.\n         function = f;\n-        this.target = target.clone();\n-        this.weight = weight.clone();\n+        target = t.clone();\n+        weight = w.clone();\n         start = startPoint.clone();\n \n         // Perform computation.\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n \n /**\n  * Gauss-Newton least-squares solver.\n     @Override\n     public VectorialPointValuePair doOptimize()\n         throws FunctionEvaluationException {\n+\n+        final ConvergenceChecker<VectorialPointValuePair> checker\n+            = getConvergenceChecker();\n \n         // iterate until convergence is reached\n         VectorialPointValuePair current = null;\n             }\n \n             // check convergence\n-            if (previous != null) {\n-                converged = getConvergenceChecker().converged(iter, previous, current);\n+            if (checker != null) {\n+                if (previous != null) {\n+                    converged = checker.converged(iter, previous, current);\n+                }\n             }\n         }\n         // we have converged\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                    \tif (checker.converged(iter, previous, current)) {\n-                    \t\treturn current;\n-                    \t}\n+                        if (checker.converged(iter, previous, current)) {\n+                            return current;\n+                        }\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer;\n import org.apache.commons.math.optimization.univariate.BracketFinder;\n import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n import org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair;\n         super.setMaxEvaluations(maxEvaluations);\n \n         // We must allow at least as many iterations to the underlying line\n-        // search optimizer. Because the line search inner class will call \n+        // search optimizer. Because the line search inner class will call\n         // \"computeObjectiveValue\" in this class, we ensure that this class\n         // will be the first to eventually throw \"TooManyEvaluationsException\".\n         line.setMaxEvaluations(maxEvaluations);\n             }\n \n             // Default convergence check.\n-            boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX)\n-                                                                    + FastMath.abs(fVal))\n-                                               + absoluteThreshold);\n+            boolean stop = 2 * (fX - fVal) <=\n+                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n+                 absoluteThreshold);\n \n             final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n             final RealPointValuePair current = new RealPointValuePair(x, fVal);\n \n         /**\n          * @param rel Relative threshold.\n-         * @param rel Absolute threshold.\n+         * @param abs Absolute threshold.\n          */\n         LineSearch(double rel,\n                    double abs) {\n          * @return the optimum.\n          * @throws FunctionEvaluationException if the function evaluation\n          * fails.\n-         * @throws TooManyEvaluationsException if the number of evaluations is\n-         * exceeded.\n+         * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+         * if the number of evaluations is exceeded.\n          */\n         public UnivariateRealPointValuePair search(final double[] p,\n                                                    final double[] d)\n             final UnivariateRealFunction f = new UnivariateRealFunction() {\n                     public double value(double alpha)\n                         throws FunctionEvaluationException {\n-                        \n                         final double[] x = new double[n];\n                         for (int i = 0; i < n; i++) {\n                             x[i] = p[i] + alpha * d[i];\n                         return obj;\n                     }\n                 };\n-            \n+\n             final GoalType goal = PowellOptimizer.this.getGoalType();\n             bracket.search(f, goal, 0, 1);\n             return optimize(f, goal, bracket.getLo(), bracket.getHi(),\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n \n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n-                                                 GoalType goal,\n+                                                 GoalType goalType,\n                                                  double min, double max)\n         throws FunctionEvaluationException {\n-        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+        return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n-        this.checker = checker;\n+    public void setConvergenceChecker(ConvergenceChecker<UnivariateRealPointValuePair> c) {\n+        checker = c;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n \n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @return a (point, value) pair where the function is optimum.\n-     * @throws {@link org.apache.commons.math.exception.TooManyEvaluationsException}\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximum evaluation count is exceeded.\n-     * @throws {@link org.apache.commons.math.exception.ConvergenceException}\n+     * @throws org.apache.commons.math.exception.ConvergenceException\n      * if the optimizer detects a convergence problem.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n      * @return a (point, value) pair where the function is optimum.\n-     * @throws {@link org.apache.commons.math.exception.TooManyEvaluationsException}\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximum evaluation count is exceeded.\n-     * @throws {@link org.apache.commons.math.exception.ConvergenceException}\n-     * if the optimizer detects a convergence problem.\n+     * @throws org.apache.commons.math.exception.ConvergenceException if the\n+     * optimizer detects a convergence problem.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if any\n+     * argument is {@code null}.\n      */\n     UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n                                           double min, double max,\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.AbstractConvergenceChecker;\n import org.apache.commons.math.optimization.GoalType;\n \n /**\n     /** {@inheritDoc} */\n     protected UnivariateRealPointValuePair doOptimize()\n         throws FunctionEvaluationException {\n-        final boolean isMinim = (getGoalType() == GoalType.MINIMIZE);\n+        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();\n         final double hi = getMax();\n \n         UnivariateRealPointValuePair previous = null;\n         UnivariateRealPointValuePair current\n-            = new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+            = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n \n         int iter = 0;\n         while (true) {\n                 }\n \n                 previous = current;\n-                current = new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+                current = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n \n                 // User-defined convergence checker.\n                 if (checker != null) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n  * @version $Revision$ $Date$\n  * @since 3.0\n  */\n-public interface UnivariateRealOptimizer \n+public interface UnivariateRealOptimizer\n     extends BaseUnivariateRealOptimizer<UnivariateRealFunction> {}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n      * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n      * </ul></p>\n      *\n-     * @param values the input array\n-     * @param weights the weights array\n-     * @param begin index of the first array element to include\n-     * @param length the number of elements to include\n-     * @param allowEmpty if <code>true</code> than allow zero length arrays to pass\n-     * @return true if the parameters are valid \n-     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @param values the input array.\n+     * @param weights the weights array.\n+     * @param begin index of the first array element to include.\n+     * @param length the number of elements to include.\n+     * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n+     * @return {@code true} if the parameters are valid.\n+     * @throws IllegalArgumentException if the indices are invalid or the array\n+     * is {@code null}.\n      * @since 3.0\n      */\n     protected boolean test(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty){\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n /**\n   * Returns the sum of the available values.\n  * <p>\n- * If there are no values in the dataset, then 0 is returned. \n+ * If there are no values in the dataset, then 0 is returned.\n  * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n--- a/src/main/java/org/apache/commons/math/util/Incrementor.java\n+++ b/src/main/java/org/apache/commons/math/util/Incrementor.java\n     /**\n      * Set the upper limit for the counter.\n      *\n-     * @param count Upper limit of the counter.\n+     * @param max Upper limit of the counter.\n      */\n-    public void setMaximalCount(int count) {\n-        maximalCount = count;\n+    public void setMaximalCount(int max) {\n+        maximalCount = max;\n     }\n \n     /**", "timestamp": 1283944961, "metainfo": ""}