{"sha": "a717386116e3d69fb9df72e9935b990ea87a0737", "log": "All step interpolators for ODE integrators now provide interpolation for both the state and its time derivatives. The interpolated derivatives are the exact derivatives of the interpolated state, thus preserving consistency. The general step handlers hence do not need to call the derivation function anymore. The fixed step handlers also get the time derivative of the state as an additional argument along with the state when they are called.   ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n                                             final double oneMinusThetaH)\n         throws DerivativeException {\n \n-        final double fourTheta = 4 * theta;\n-        final double s         = oneMinusThetaH / 6.0;\n-        final double coeff1    = s * ((-fourTheta + 5) * theta - 1);\n-        final double coeff23   = s * (( fourTheta - 2) * theta - 2);\n-        final double coeff4    = s * ((-fourTheta - 1) * theta - 1);\n-\n+        final double fourTheta      = 4 * theta;\n+        final double oneMinusTheta  = 1 - theta;\n+        final double oneMinus2Theta = 1 - 2 * theta;\n+        final double s             = oneMinusThetaH / 6.0;\n+        final double coeff1        = s * ((-fourTheta + 5) * theta - 1);\n+        final double coeff23       = s * (( fourTheta - 2) * theta - 2);\n+        final double coeff4        = s * ((-fourTheta - 1) * theta - 1);\n+        final double coeffDot1     = oneMinusTheta * oneMinus2Theta;\n+        final double coeffDot23    = 2 * theta * oneMinusTheta;\n+        final double coeffDot4     = -theta * oneMinus2Theta;\n         for (int i = 0; i < interpolatedState.length; ++i) {\n-            interpolatedState[i] = currentState[i] +\n-            coeff1  * yDotK[0][i] +\n-            coeff23 * (yDotK[1][i] + yDotK[2][i]) +\n-            coeff4  * yDotK[3][i];\n+            final double yDot1  = yDotK[0][i];\n+            final double yDot23 = yDotK[1][i] + yDotK[2][i];\n+            final double yDot4  = yDotK[3][i];\n+            interpolatedState[i] =\n+                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n+            interpolatedDerivatives[i] =\n+                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n \n       // we need to compute the interpolation vectors for this time step\n       for (int i = 0; i < interpolatedState.length; ++i) {\n-        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +\n-                     a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n-        v2[i] = h * yDotK[0][i] - v1[i];\n-        v3[i] = v1[i] - v2[i] - h * yDotK[6][i];\n-        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +\n-                     d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n+          final double yDot0 = yDotK[0][i];\n+          final double yDot2 = yDotK[2][i];\n+          final double yDot3 = yDotK[3][i];\n+          final double yDot4 = yDotK[4][i];\n+          final double yDot5 = yDotK[5][i];\n+          final double yDot6 = yDotK[6][i];\n+          v1[i] = h * (a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5);\n+          v2[i] = h * yDot0 - v1[i];\n+          v3[i] = v1[i] - v2[i] - h * yDot6;\n+          v4[i] = h * (d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6);\n       }\n \n       vectorsInitialized = true;\n \n     // interpolate\n     final double eta = oneMinusThetaH / h;\n+    final double twoTheta = 2 * theta;\n+    final double dot2 = 1 - twoTheta;\n+    final double dot3 = theta * (2 - 3 * theta);\n+    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] -\n-          eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n-    }\n+      interpolatedState[i] =\n+          currentState[i] - eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+      interpolatedDerivatives[i] = \n+          (v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i]) / h;\n+      }\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n \n       // compute the interpolation vectors for this time step\n       for (int i = 0; i < interpolatedState.length; ++i) {\n-        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +\n-                       b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +\n-                       b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n-        v[1][i] = h * yDotK[0][i] - v[0][i];\n-        v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n-        for (int k = 0; k < d.length; ++k) {\n-          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +\n-                           d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +\n-                           d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +\n-                           d[k][9]  * yDotKLast[0][i] +\n-                           d[k][10] * yDotKLast[1][i] +\n-                           d[k][11] * yDotKLast[2][i]);\n-        }\n+          final double yDot1  = yDotK[0][i];\n+          final double yDot6  = yDotK[5][i];\n+          final double yDot7  = yDotK[6][i];\n+          final double yDot8  = yDotK[7][i];\n+          final double yDot9  = yDotK[8][i];\n+          final double yDot10 = yDotK[9][i];\n+          final double yDot11 = yDotK[10][i];\n+          final double yDot12 = yDotK[11][i];\n+          final double yDot13 = yDotK[12][i];\n+          final double yDot14 = yDotKLast[0][i];\n+          final double yDot15 = yDotKLast[1][i];\n+          final double yDot16 = yDotKLast[2][i];\n+          v[0][i] = h * (b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +\n+                         b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +\n+                         b_11 * yDot11 + b_12 * yDot12);\n+          v[1][i] = h * yDot1 - v[0][i];\n+          v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n+          for (int k = 0; k < d.length; ++k) {\n+              v[k+3][i] = h * (d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +\n+                               d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +\n+                               d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +\n+                               d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16);\n+          }\n       }\n \n       vectorsInitialized = true;\n \n     }\n \n-    final double eta = oneMinusThetaH / h;\n+    final double eta      = oneMinusThetaH / h;\n+    final double twoTheta = 2 * theta;\n+    final double theta2   = theta * theta;\n+    final double dot1 = 1 - twoTheta;\n+    final double dot2 = theta * (2 - 3 * theta);\n+    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n+    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n+    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n+    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n       interpolatedState[i] =\n           currentState[i] - eta * (v[0][i] - theta * (v[1][i] +\n                   theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] +\n                           eta * (v[5][i] + theta * (v[6][i])))))));\n+      interpolatedDerivatives[i] = \n+          (v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] + dot3 * v[3][i] +\n+                     dot4 * v[4][i] + dot5 * v[5][i] + dot6 * v[6][i]) / h;\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n /**\n  * This class implements a linear interpolator for step.\n  *\n- * <p>This interpolator allow to compute dense output inside the last\n+ * <p>This interpolator computes dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n  *\n \n class EulerStepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -7179861704951334960L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n     for (int i = 0; i < interpolatedState.length; ++i) {\n       interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n     }\n+    System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -7179861704951334960L;\n-\n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n \n+    final double twoTheta  = 2 * theta;\n     final double fourTheta = 4 * theta;\n     final double s         = oneMinusThetaH / 6.0;\n-    final double soMt      = s * (1 - theta);\n-    final double c23       = soMt * (1 + 2 * theta);\n+    final double oMt       = 1 - theta;\n+    final double soMt      = s * oMt;\n+    final double c23       = soMt * (1 + twoTheta);\n     final double coeff1    = soMt * (1 - fourTheta);\n     final double coeff2    = c23  * tMq;\n     final double coeff3    = c23  * tPq;\n     final double coeff4    = s * (1 + theta * (1 + fourTheta));\n+    final double coeffDot1 = theta * (twoTheta - 3) + 1;\n+    final double cDot23    = theta * oMt;\n+    final double coeffDot2 = cDot23  * tMq;\n+    final double coeffDot3 = cDot23  * tPq;\n+    final double coeffDot4 = theta * (twoTheta - 1);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] -\n-                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n-                             coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+        final double yDot1 = yDotK[0][i];\n+        final double yDot2 = yDotK[1][i];\n+        final double yDot3 = yDotK[2][i];\n+        final double yDot4 = yDotK[3][i];\n+        interpolatedState[i] =\n+            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+        interpolatedDerivatives[i] =\n+            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n      }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n \n     final double oneMinusTheta = 1.0 - theta;\n     final double theta05       = theta - 0.5;\n-    double t4                  = theta * oneMinusTheta;\n-    t4 = t4 * t4;\n+    final double tOmT          = theta * oneMinusTheta;\n+    final double t4            = tOmT * tOmT;\n+    final double t4Dot         = 2 * tOmT * (1 - 2 * theta);\n+    final double dot1          = 1.0 / h;\n+    final double dot2          = theta * (2 - 3 * theta) / h;\n+    final double dot3          = ((3 * theta - 4) * theta + 1) / h;\n \n     for (int i = 0; i < dimension; ++i) {\n-      interpolatedState[i] = polynoms[0][i] +\n-        theta * (polynoms[1][i] +\n-                 oneMinusTheta * (polynoms[2][i] * theta +\n-                                  polynoms[3][i] * oneMinusTheta));\n-\n-      if (currentDegree > 3) {\n-        double c = polynoms[currentDegree][i];\n-        for (int j = currentDegree - 1; j > 3; --j) {\n-          c = polynoms[j][i] + c * theta05 / (j - 3);\n-        }\n-        interpolatedState[i] += t4 * c;\n-      }\n+\n+        final double p0 = polynoms[0][i];\n+        final double p1 = polynoms[1][i];\n+        final double p2 = polynoms[2][i];\n+        final double p3 = polynoms[3][i];\n+        interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));\n+        interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;\n+\n+        if (currentDegree > 3) {\n+            double cDot = 0;\n+            double c = polynoms[currentDegree][i];\n+            for (int j = currentDegree - 1; j > 3; --j) {\n+                final double d = 1.0 / (j - 3);\n+                cDot = d * (theta05 * cDot + c);\n+                c = polynoms[j][i] + c * d * theta05;\n+            }\n+            interpolatedState[i]       += t4 * c;\n+            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;\n+        }\n+\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n     final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n     final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n     final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+    final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));\n+    final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));\n+    final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));\n+    final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));\n+    final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] +\n-                             b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +\n-                             b4 * yDotK[4][i] + b5 * yDotK[5][i];\n+        final double yDot0 = yDotK[0][i];\n+        final double yDot2 = yDotK[2][i];\n+        final double yDot3 = yDotK[3][i];\n+        final double yDot4 = yDotK[4][i];\n+        final double yDot5 = yDotK[5][i];\n+        interpolatedState[i] =\n+            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n+        interpolatedDerivatives[i] =\n+            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n  * This class implements a step interpolator for second order\n  * Runge-Kutta integrator.\n  *\n- * <p>This interpolator allow to compute dense output inside the last\n+ * <p>This interpolator computes dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n  *\n                                           final double oneMinusThetaH)\n     throws DerivativeException {\n \n-    final double coeff1 = oneMinusThetaH * theta;\n-    final double coeff2 = oneMinusThetaH * (1.0 + theta);\n+    final double coeff1    = oneMinusThetaH * theta;\n+    final double coeff2    = oneMinusThetaH * (1.0 + theta);\n+    final double coeffDot2 = 2 * theta;\n+    final double coeffDot1 = 1 - coeffDot2;\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] +\n-                             coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n+      final double yDot1 = yDotK[0][i];\n+      final double yDot2 = yDotK[1][i];\n+      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;\n+      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n    * instance in order to initialize the internal arrays. This\n    * constructor is used only in order to delay the initialization in\n    * some cases. The {@link RungeKuttaIntegrator} and {@link\n-   * EmbeddedRungeKuttaIntegrator} classes uses the prototyping design\n+   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n    * pattern to create the step interpolators by cloning an\n    * uninitialized model and latter initializing the copy.\n    */\n   /** Slopes at the intermediate points */\n   protected double[][] yDotK;\n \n-  /** Reference to the differential equations beeing integrated. */\n+  /** Reference to the differential equations being integrated. */\n   protected FirstOrderDifferentialEquations equations;\n \n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n       final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n       final double coeff3     = 3 * s * (1 + theta);\n       final double coeff4     = s * (1 + theta + fourTheta2);\n+      final double coeffDot3  = 0.75 * theta;\n+      final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;\n+      final double coeffDot2  = coeffDot3 * (5 - 6 * theta);\n+      final double coeffDot4  = coeffDot3 * (2 * theta - 1);\n \n       for (int i = 0; i < interpolatedState.length; ++i) {\n-          interpolatedState[i] = currentState[i] -\n-          coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -\n-          coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+          final double yDot1 = yDotK[0][i];\n+          final double yDot2 = yDotK[1][i];\n+          final double yDot3 = yDotK[2][i];\n+          final double yDot4 = yDotK[3][i];\n+          interpolatedState[i] =\n+              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+          interpolatedDerivatives[i] =\n+              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+\n       }\n \n   }\n--- a/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n \n   /** interpolated state */\n   protected double[] interpolatedState;\n+\n+  /** interpolated derivatives */\n+  protected double[] interpolatedDerivatives;\n \n   /** indicate if the step has been finalized or not. */\n   private boolean finalized;\n    * model and latter initializing the copy.\n    */\n   protected AbstractStepInterpolator() {\n+    previousTime            = Double.NaN;\n+    currentTime             = Double.NaN;\n+    h                       = Double.NaN;\n+    interpolatedTime        = Double.NaN;\n+    currentState            = null;\n+    interpolatedState       = null;\n+    interpolatedDerivatives = null;\n+    finalized               = false;\n+    this.forward            = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n+\n     previousTime      = Double.NaN;\n     currentTime       = Double.NaN;\n     h                 = Double.NaN;\n     interpolatedTime  = Double.NaN;\n-    currentState      = null;\n-    interpolatedState = null;\n-    finalized         = false;\n-    this.forward      = true;\n-  }\n-\n-  /** Simple constructor.\n-   * @param y reference to the integrator array holding the state at\n-   * the end of the step\n-   * @param forward integration direction indicator\n-   */\n-  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n-\n-    previousTime      = Double.NaN;\n-    currentTime       = Double.NaN;\n-    h                 = Double.NaN;\n-    interpolatedTime  = Double.NaN;\n-\n-    currentState      = y;\n-    interpolatedState = new double[y.length];\n+\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n \n     finalized         = false;\n     this.forward      = forward;\n     interpolatedTime  = interpolator.interpolatedTime;\n \n     if (interpolator.currentState != null) {\n-      currentState      = (double[]) interpolator.currentState.clone();\n-      interpolatedState = (double[]) interpolator.interpolatedState.clone();\n+      currentState            = (double[]) interpolator.currentState.clone();\n+      interpolatedState       = (double[]) interpolator.interpolatedState.clone();\n+      interpolatedDerivatives = (double[]) interpolator.interpolatedDerivatives.clone();\n     } else {\n-      currentState      = null;\n-      interpolatedState = null;\n+      currentState            = null;\n+      interpolatedState       = null;\n+      interpolatedDerivatives = null;\n     }\n \n     finalized = interpolator.finalized;\n     h                 = Double.NaN;\n     interpolatedTime  = Double.NaN;\n \n-    currentState      = y;\n-    interpolatedState = new double[y.length];\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n \n     finalized         = false;\n     this.forward      = forward;\n \n   }\n \n-  /** Copy the instance.\n-   * <p>The copied instance is guaranteed to be independent from the\n-   * original one. Both can be used with different settings for\n-   * interpolated time without any side effect.</p>\n-   * @return a deep copy of the instance, which can be used independently.\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n-   * @see #setInterpolatedTime(double)\n-   */\n+  /** {@inheritDoc} */\n    public StepInterpolator copy() throws DerivativeException {\n \n      // finalize the step before performing copy\n \n   }\n \n-  /**\n-   * Get the previous grid point time.\n-   * @return previous grid point time\n-   */\n+  /** {@inheritDoc} */\n   public double getPreviousTime() {\n     return previousTime;\n   }\n     \n-  /**\n-   * Get the current grid point time.\n-   * @return current grid point time\n-   */\n+  /** {@inheritDoc} */\n   public double getCurrentTime() {\n     return currentTime;\n   }\n     \n-  /**\n-   * Get the time of the interpolated point.\n-   * If {@link #setInterpolatedTime} has not been called, it returns\n-   * the current grid point time.\n-   * @return interpolation point time\n-   */\n+  /** {@inheritDoc} */\n   public double getInterpolatedTime() {\n     return interpolatedTime;\n   }\n     \n-  /**\n-   * Set the time of the interpolated point.\n-   * <p>Setting the time outside of the current step is now allowed\n-   * (it was not allowed up to version 5.4 of Mantissa), but should be\n-   * used with care since the accuracy of the interpolator will\n-   * probably be very poor far from this step. This allowance has been\n-   * added to simplify implementation of search algorithms near the\n-   * step endpoints.</p>\n-   * @param time time of the interpolated point\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n-   */\n+  /** {@inheritDoc} */\n   public void setInterpolatedTime(final double time)\n       throws DerivativeException {\n       interpolatedTime = time;\n       computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);\n   }\n \n-  /** Check if the natural integration direction is forward.\n-   * <p>This method provides the integration direction as specified by the\n-   * integrator itself, it avoid some nasty problems in degenerated\n-   * cases like null steps due to cancellation at step initialization,\n-   * step control or discrete events triggering.</p>\n-   * @return true if the integration variable (time) increases during\n-   * integration\n-   */\n+  /** {@inheritDoc} */\n   public boolean isForward() {\n     return forward;\n   }\n                                                    double oneMinusThetaH)\n     throws DerivativeException;\n     \n-  /**\n-   * Get the state vector of the interpolated point.\n-   * @return state vector at time {@link #getInterpolatedTime}\n-   */\n+  /** {@inheritDoc} */\n   public double[] getInterpolatedState() {\n-    return (double[]) interpolatedState.clone();\n-  }\n-\n+    return interpolatedState;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedDerivatives() {\n+    return interpolatedDerivatives;\n+  }\n \n   /**\n    * Finalize the step.\n     throws DerivativeException {\n   }\n \n-  /** Write the instance to an output channel.\n-   * @param out output channel\n-   * @exception IOException if the instance cannot be written\n-   */\n+  /** {@inheritDoc} */\n   public abstract void writeExternal(ObjectOutput out)\n     throws IOException;\n \n-  /** Read the instance from an input channel.\n-   * @param in input channel\n-   * @exception IOException if the instance cannot be read\n-   */\n+  /** {@inheritDoc} */\n   public abstract void readExternal(ObjectInput in)\n     throws IOException;\n \n     }\n \n     // we do NOT handle the interpolated time and state here\n-    interpolatedTime  = Double.NaN;\n-    interpolatedState = new double[dimension];\n+    interpolatedTime        = Double.NaN;\n+    interpolatedState       = new double[dimension];\n+    interpolatedDerivatives = new double[dimension];\n \n     finalized = true;\n \n--- a/src/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n  */\n \n package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n \n /**\n  * This interface represents a handler that should be called after\n   /**\n    * Handle the last accepted step\n    * @param t time of the current step\n-\n    * @param y state vector at t. For efficiency purposes, the {@link\n-   * StepNormalizer} class reuse the same array on each call, so if\n+   * StepNormalizer} class reuses the same array on each call, so if\n    * the instance wants to keep it across all calls (for example to\n    * provide at the end of the integration a complete array of all\n    * steps), it should build a local copy store this copy.\n+   * @param yDot derivatives of the state vector state vector at t.\n+   * For efficiency purposes, the {@link StepNormalizer} class reuses\n+   * the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException if some error condition is encountered\n+   */\n+  public void handleStep(double t, double[] y, double[] yDot, boolean isLast)\n+      throws DerivativeException;\n \n-   * @param isLast true if the step is the last one\n-   */\n-  public void handleStep(double t, double[] y, boolean isLast);\n-    \n }\n--- a/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n \n   /**\n    * Get the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n    * @return state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedDerivatives()\n    */\n   public double[] getInterpolatedState();\n+\n+  /**\n+   * Get the derivatives of the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedState()\n+   */\n+  public double[] getInterpolatedDerivatives();\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n--- a/src/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n public class StepNormalizer implements StepHandler {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -973517244031912577L;\n+    private static final long serialVersionUID = -789699939659144654L;\n \n     /** Fixed time step. */\n     private double h;\n \n     /** Last State vector. */\n     private double[] lastState;\n+\n+    /** Last Derivatives vector. */\n+    private double[] lastDerivatives;\n \n     /** Integration direction indicator. */\n     private boolean forward;\n      * handled.\n      */\n     public void reset() {\n-        lastTime  = Double.NaN;\n-        lastState = null;\n-        forward   = true;\n+        lastTime        = Double.NaN;\n+        lastState       = null;\n+        lastDerivatives = null;\n+        forward         = true;\n     }\n \n     /**\n \n             lastTime = interpolator.getPreviousTime();\n             interpolator.setInterpolatedTime(lastTime);\n-\n-            final double[] state = interpolator.getInterpolatedState();\n-            lastState = (double[]) state.clone();\n+            lastState = interpolator.getInterpolatedState().clone();\n+            lastDerivatives = interpolator.getInterpolatedDerivatives().clone();\n \n             // take the integration direction into account\n             forward = (interpolator.getCurrentTime() >= lastTime);\n         while (nextInStep) {\n \n             // output the stored previous step\n-            handler.handleStep(lastTime, lastState, false);\n+            handler.handleStep(lastTime, lastState, lastDerivatives, false);\n \n             // store the next step\n             lastTime = nextTime;\n             interpolator.setInterpolatedTime(lastTime);\n             System.arraycopy(interpolator.getInterpolatedState(), 0,\n                              lastState, 0, lastState.length);\n+            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                             lastDerivatives, 0, lastDerivatives.length);\n \n             nextTime  += h;\n             nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n         if (isLast) {\n             // there will be no more steps,\n             // the stored one should be flagged as being the last\n-            handler.handleStep(lastTime, lastState, true);\n+            handler.handleStep(lastTime, lastState, lastDerivatives, true);\n         }\n \n     }\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Random;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectInputStream;\n-import java.io.IOException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n \n public class ClassicalRungeKuttaStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public ClassicalRungeKuttaStepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class DormandPrince54StepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public DormandPrince54StepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class DormandPrince853StepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public DormandPrince853StepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Random;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectInputStream;\n-import java.io.IOException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n-import org.apache.commons.math.ode.nonstiff.EulerStepInterpolator;\n \n public class EulerStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public EulerStepInterpolatorTest(String name) {\n     super(name);\n   }\n \n   public void testInterpolationInside()\n-    throws DerivativeException {\n+  throws DerivativeException {\n \n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n     assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n \n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n \n public class GillStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public GillStepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class GraggBulirschStoerStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public GraggBulirschStoerStepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-8);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class HighamHall54StepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public HighamHall54StepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Random;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectInputStream;\n-import java.io.IOException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n \n public class MidpointStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public MidpointStepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import junit.framework.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Random;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectInputStream;\n-import java.io.IOException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n \n public class ThreeEighthesStepInterpolatorTest\n-  extends TestCase {\n+  extends AbstractStepInterpolatorTest {\n \n   public ThreeEighthesStepInterpolatorTest(String name) {\n     super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n   }\n \n   public void testSerialization()\n--- a/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n                                          private boolean firstCall = true;\n                                          public void handleStep(double t,\n                                                                 double[] y,\n+                                                                double[] yDot,\n                                                                 boolean isLast) {\n                                            if (firstCall) {\n                                              checkValue(t, pb.getInitialTime());\n                                        new FixedStepHandler() {\n                                          public void handleStep(double t,\n                                                                 double[] y,\n+                                                                double[] yDot,\n                                                                 boolean isLast) {\n                                            if (isLast) {\n                                              setLastSeen(true);", "timestamp": 1215111116, "metainfo": ""}