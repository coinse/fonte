{"sha": "1909dbe0ca1fc678d9baf1388f8efcf4c65b2a54", "log": "Minor clean-up (to avoid changing a method arguments in-place).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n             int bigInd = 0;\n             double alphaMin = 0;\n \n-            double[] direc1 = null;\n             for (int i = 0; i < n; i++) {\n-                direc1 = Arrays.copyOf(direc[i], n);\n+                final double[] d = Arrays.copyOf(direc[i], n);\n \n                 fX2 = fVal;\n \n-                line.search(x, direc1);\n+                line.search(x, d);\n                 fVal = line.getValueAtOptimum();\n                 alphaMin = line.getOptimum();\n-                setNewPointAndDirection(x, direc1, alphaMin);\n+                final double[][] result = newPointAndDirection(x, d, alphaMin);\n+                x = result[0];\n \n                 if ((fX2 - fVal) > delta) {\n                     delta = fX2 - fVal;\n                 }\n             }\n \n-            double[] x2 = new double[n];\n+            final double[] d = new double[n];\n+            final double[] x2 = new double[n];\n             for (int i = 0; i < n; i++) {\n-                direc1[i] = x[i] - x1[i];\n+                d[i] = x[i] - x1[i];\n                 x2[i] = 2 * x[i] - x1[i];\n             }\n \n                 t -= delta * temp * temp;\n \n                 if (t < 0.0) {\n-                    line.search(x, direc1);\n+                    line.search(x, d);\n                     fVal = line.getValueAtOptimum();\n                     alphaMin = line.getOptimum();\n-                    setNewPointAndDirection(x, direc1, alphaMin);\n+                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n+                    x = result[0];\n \n                     final int lastInd = n - 1;\n                     direc[bigInd] = direc[lastInd];\n-                    direc[lastInd] = direc1;\n+                    direc[lastInd] = result[1];\n                 }\n             }\n         }\n      * @param p Point used in the line search.\n      * @param d Direction used in the line search.\n      * @param optimum Optimum found by the line search.\n-     */\n-    private void setNewPointAndDirection(double[] p,\n-                                         double[] d,\n-                                         double optimum) {\n+     * @return a 2-element array containing the new point (at index 0) and\n+     * the new direction (at index 1).\n+     */\n+    private double[][] newPointAndDirection(double[] p,\n+                                            double[] d,\n+                                            double optimum) {\n         final int n = p.length;\n+        final double[][] result = new double[2][n];\n+        final double[] nP = result[0];\n+        final double[] nD = result[1];\n         for (int i = 0; i < n; i++) {\n-            d[i] *= optimum;\n-            p[i] += d[i];\n-        }\n+            nD[i] = d[i] * optimum;\n+            nP[i] = p[i] + nD[i];\n+        }\n+        return result;\n     }\n \n     /**", "timestamp": 1281444310, "metainfo": ""}