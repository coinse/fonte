{"sha": "8c2d5d1f491fe3a1d696bce6efae1543f1d58a48", "log": "MATH-697 New interface and abstract base class for separate support of unconstrained and simple bounds constraints optimizers.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n     public RealPointValuePair optimize(int maxEval, final FUNC f,\n                                        final GoalType goal,\n                                        double[] startPoint) {\n-        return optimize(maxEval, f, goal, startPoint, null, null);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public RealPointValuePair optimize(int maxEval, final FUNC f,\n-                                       final GoalType goal,\n-                                       double[] startPoint,\n-                                       double[] lowerBound, double[] upperBound) {\n         maxEvaluations = maxEval;\n         RuntimeException lastException = null;\n         optima = new RealPointValuePair[starts];\n             // CHECKSTYLE: stop IllegalCatch\n             try {\n                 optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal,\n-                                               i == 0 ? startPoint : generator.nextVector(),\n-                                               lowerBound, upperBound);\n+                                               i == 0 ? startPoint : generator.nextVector());\n             } catch (RuntimeException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n      */\n     RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                 double[] startPoint);\n-\n-    /**\n-     * Optimize an objective function.\n-     *\n-     * @param f Objective function.\n-     * @param goalType Type of optimization goal: either\n-     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n-     * @param startPoint Start point for optimization.\n-     * @param maxEval Maximum number of function evaluations.\n-     * @param lowerBound Lower bound for each of the parameters.\n-     * @param upperBound Upper bound for each of the parameters.\n-     * @return the point/value pair giving the optimal value for objective\n-     * function.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if the array sizes are wrong.\n-     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n-     * if the maximal number of evaluations is exceeded.\n-     * @throws org.apache.commons.math.exception.NullArgumentException if\n-     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n-     * @throws org.apache.commons.math.exception.NumberIsTooSmallException if any\n-     * of the initial values is less than its lower bound.\n-     * @throws org.apache.commons.math.exception.NumberIsTooLargeException if any\n-     * of the initial values is greater than its upper bound.\n-     */\n-    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n-                                double[] startPoint,\n-                                double[] lowerBound, double[] upperBound);\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseSimpleBoundsMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-FastMath. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface BaseSimpleBoundsMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+    extends BaseMultivariateRealOptimizer<FUNC> {\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param f Objective function.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param startPoint Start point for optimization.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param lowerBound Lower bound for each of the parameters.\n+     * @param upperBound Upper bound for each of the parameters.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array sizes are wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n+     * @throws org.apache.commons.math.exception.NumberIsTooSmallException if any\n+     * of the initial values is less than its lower bound.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException if any\n+     * of the initial values is greater than its upper bound.\n+     */\n+    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                double[] startPoint,\n+                                double[] lowerBound, double[] upperBound);\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.BaseSimpleBoundsMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n-import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n  * Powell's BOBYQA algorithm. This implementation is translated and\n  * @since 3.0\n  */\n public class BOBYQAOptimizer\n-    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    extends BaseAbstractSimpleBoundsScalarOptimizer<MultivariateRealFunction>\n     implements MultivariateRealOptimizer {\n     /** Minimum dimension of the problem: {@value} */\n     public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n  * This base class handles the boiler-plate methods associated to thresholds\n  * settings, iterations and evaluations counting.\n  *\n- * @param <FUNC> Type of the objective function to be optimized\n+ * @param <FUNC> Type of the objective function to be optimized.\n  *\n  * @version $Id$\n  * @since 2.2\n     private GoalType goal;\n     /** Initial guess. */\n     private double[] start;\n-    /** Lower bounds. */\n-    private double[] lowerBound;\n-    /** Upper bounds. */\n-    private double[] upperBound;\n     /** Objective function. */\n     private MultivariateRealFunction function;\n \n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                        double[] startPoint) {\n-        return optimize(maxEval, f, goalType, startPoint, null, null);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n-                                       double[] startPoint,\n-                                       double[] lower, double[] upper) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         if (startPoint == null) {\n             throw new NullArgumentException();\n         }\n-        final int dim = startPoint.length;\n-        if (lower != null) {\n-            if (lower.length != dim) {\n-                throw new DimensionMismatchException(lower.length, dim);\n-            }\n-            for (int i = 0; i < dim; i++) {\n-                final double v = startPoint[i];\n-                final double lo = lower[i];\n-                if (v < lo) {\n-                    throw new NumberIsTooSmallException(v, lo, true);\n-                }\n-            }\n-        }\n-        if (upper != null) {\n-            if (upper.length != dim) {\n-                throw new DimensionMismatchException(upper.length, dim);\n-            }\n-            for (int i = 0; i < dim; i++) {\n-                final double v = startPoint[i];\n-                final double hi = upper[i];\n-                if (v > hi) {\n-                    throw new NumberIsTooLargeException(v, hi, true);\n-                }\n-            }\n-        }\n \n         // Reset.\n         evaluations.setMaximalCount(maxEval);\n         function = f;\n         goal = goalType;\n         start = startPoint.clone();\n-\n-        if (lower == null) {\n-            lowerBound = new double[dim];\n-            for (int i = 0; i < dim; i++) {\n-                lowerBound[i] = Double.NEGATIVE_INFINITY;\n-            }\n-        } else {\n-            lowerBound = lower.clone();\n-        }\n-        if (upper == null) {\n-            upperBound = new double[dim];\n-            for (int i = 0; i < dim; i++) {\n-                upperBound[i] = Double.POSITIVE_INFINITY;\n-            }\n-        } else {\n-            upperBound = upper.clone();\n-        }\n \n         // Perform computation.\n         return doOptimize();\n     }\n \n     /**\n-     * @return the lower bounds.\n-     */\n-    public double[] getLowerBound() {\n-        return lowerBound.clone();\n-    }\n-\n-    /**\n-     * @return the upper bounds.\n-     */\n-    public double[] getUpperBound() {\n-        return upperBound.clone();\n-    }\n-\n-    /**\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for the\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractSimpleBoundsScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.BaseSimpleBoundsMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions,\n+ * subject to simple bounds: The valid range of the parameters is an interval.\n+ * The interval can possibly be infinite (in one or both directions).\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class BaseAbstractSimpleBoundsScalarOptimizer<FUNC extends MultivariateRealFunction>\n+    extends BaseAbstractScalarOptimizer<FUNC>\n+    implements BaseMultivariateRealOptimizer<FUNC>,\n+               BaseSimpleBoundsMultivariateRealOptimizer<FUNC> {\n+    /** Lower bounds. */\n+    private double[] lowerBound;\n+    /** Upper bounds. */\n+    private double[] upperBound;\n+\n+    /**\n+     * @return the lower bounds.\n+     */\n+    public double[] getLowerBound() {\n+        return lowerBound.clone();\n+    }\n+\n+    /**\n+     * @return the upper bounds.\n+     */\n+    public double[] getUpperBound() {\n+        return upperBound.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint) {\n+        return optimize(maxEval, f, goalType, startPoint, null, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint,\n+                                       double[] lower, double[] upper) {\n+        // Checks.\n+        final int dim = startPoint.length;\n+        if (lower != null) {\n+            if (lower.length != dim) {\n+                throw new DimensionMismatchException(lower.length, dim);\n+            }\n+            for (int i = 0; i < dim; i++) {\n+                final double v = startPoint[i];\n+                final double lo = lower[i];\n+                if (v < lo) {\n+                    throw new NumberIsTooSmallException(v, lo, true);\n+                }\n+            }\n+        }\n+        if (upper != null) {\n+            if (upper.length != dim) {\n+                throw new DimensionMismatchException(upper.length, dim);\n+            }\n+            for (int i = 0; i < dim; i++) {\n+                final double v = startPoint[i];\n+                final double hi = upper[i];\n+                if (v > hi) {\n+                    throw new NumberIsTooLargeException(v, hi, true);\n+                }\n+            }\n+        }\n+\n+        // Initialization.\n+        if (lower == null) {\n+            lowerBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                lowerBound[i] = Double.NEGATIVE_INFINITY;\n+            }\n+        } else {\n+            lowerBound = lower.clone();\n+        }\n+        if (upper == null) {\n+            upperBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                upperBound[i] = Double.POSITIVE_INFINITY;\n+            }\n+        } else {\n+            upperBound = upper.clone();\n+        }\n+\n+        // Base class method performs the non bound-specific initializations.\n+        return super.optimize(maxEval, f, goalType, startPoint);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n                                        final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint) {\n-        return optimize(maxEval, f, goalType, startPoint, null, null);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealPointValuePair optimize(int maxEval,\n-                                       final DifferentiableMultivariateRealFunction f,\n-                                       final GoalType goalType,\n-                                       final double[] startPoint,\n-                                       double[] lowerBound, double[] upperBound) {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n-        return super.optimize(maxEval, f, goalType,\n-                              startPoint,\n-                              lowerBound, upperBound);\n+        return super.optimize(maxEval, f, goalType, startPoint);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n //        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n-        MultivariateRealOptimizer optim = new BOBYQAOptimizer(2 * dim + 1);\n+        BOBYQAOptimizer optim = new BOBYQAOptimizer(2 * dim + 1);\n         RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n //        System.out.println(func.getClass().getName() + \" = \" \n //              + optim.getEvaluations() + \" f(\");", "timestamp": 1321357645, "metainfo": ""}