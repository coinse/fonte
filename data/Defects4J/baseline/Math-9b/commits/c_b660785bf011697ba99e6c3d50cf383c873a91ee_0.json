{"sha": "b660785bf011697ba99e6c3d50cf383c873a91ee", "log": "MATH-451 Removed the \"solve\" methods lacking the \"maxEval\" parameter.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n  */\n public abstract class BaseAbstractUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n     implements BaseUnivariateRealSolver<FUNC> {\n-    /** Default maximum number of evaluations */\n-    public static final int DEFAULT_MAX_EVALUATIONS = 100;\n     /** Default absolute accuracy */\n     public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     /** Default relative accuracy. */\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(FUNC f, double min, double max, double startValue) {\n-        return solve(DEFAULT_MAX_EVALUATIONS, f, min, max, startValue);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double solve(FUNC f, double min, double max) {\n-        return solve(DEFAULT_MAX_EVALUATIONS, f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double solve(FUNC f, double startValue) {\n-        return solve(DEFAULT_MAX_EVALUATIONS, f, startValue);\n-    }\n-\n-    /** {@inheritDoc} */\n     public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n         // Initialization.\n         setup(maxEval, f, min, max, startValue);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n-     * @return a value where the function is zero.\n-     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n-     * if the arguments do not satisfy the requirements specified by the solver.\n-     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n-     * the default allowed number of evaluations is exceeded.\n-     */\n-    double solve(FUNC f, double min, double max);\n-\n-    /**\n-     * Solve for a zero in the given interval, start at {@code startValue}.\n-     * A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.\n-     *\n-     * @param f Function to solve.\n-     * @param min Lower bound for the interval.\n-     * @param max Upper bound for the interval.\n-     * @param startValue Start value to use.\n-     * @return a value where the function is zero.\n-     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n-     * if the arguments do not satisfy the requirements specified by the solver.\n-     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n-     * the default allowed number of evaluations is exceeded.\n-     */\n-    double solve(FUNC f, double min, double max, double startValue);\n-\n-    /**\n-     * Solve for a zero in the vicinity of {@code startValue}.\n-     *\n-     * @param f Function to solve.\n-     * @param startValue Start value to use.\n-     * @return a value where the function is zero.\n-     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n-     * if the arguments do not satisfy the requirements specified by the solver.\n-     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n-     * the default allowed number of evaluations is exceeded.\n-     */\n-    double solve(FUNC f, double startValue);\n-\n-    /**\n-     * Solve for a zero root in the given interval.\n-     * A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.\n-     *\n-     * @param f Function to solve.\n-     * @param min Lower bound for the interval.\n-     * @param max Upper bound for the interval.\n      * @param maxEval Maximum number of evaluations.\n      * @return a value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n      * @param f Function to solve.\n      * @param min Lower bound for the interval?\n      * @param max Upper bound for the interval.\n+     * @param maxEval Maximum number of evaluations.\n      * @return the value where the function is zero.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximum evaluation count is exceeded.\n-     * @throws IllegalArgumentException if {@code min >= max}.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if {@code min >= max}.\n      */\n-    public double solve(final DifferentiableUnivariateRealFunction f,\n+    @Override\n+    public double solve(int maxEval, final DifferentiableUnivariateRealFunction f,\n                         final double min, final double max) {\n-        return super.solve(f, UnivariateRealSolverUtils.midpoint(min, max));\n+        return super.solve(maxEval, f, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n-        result = solver.solve(f, 3, 4);\n+        result = solver.solve(100, f, 3, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 1, 4);\n+        result = solver.solve(100, f, 1, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n     }\n \n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n-        result = solver.solve(f, -0.2, 0.2);\n+        result = solver.solve(100, f, -0.2, 0.2);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, -0.1, 0.3);\n+        result = solver.solve(100, f, -0.1, 0.3);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, -0.3, 0.45);\n+        result = solver.solve(100, f, -0.3, 0.45);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.3, 0.7);\n+        result = solver.solve(100, f, 0.3, 0.7);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.2, 0.6);\n+        result = solver.solve(100, f, 0.2, 0.6);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.05, 0.95);\n+        result = solver.solve(100, f, 0.05, 0.95);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 1.25);\n+        result = solver.solve(100, f, 0.85, 1.25);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.8, 1.2);\n+        result = solver.solve(100, f, 0.8, 1.2);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 1.75);\n+        result = solver.solve(100, f, 0.85, 1.75);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.55, 1.45);\n+        result = solver.solve(100, f, 0.55, 1.45);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 5);\n+        result = solver.solve(100, f, 0.85, 5);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         Assert.assertTrue(solver.getEvaluations() > 0);\n     public void testMath369() {\n         UnivariateRealFunction f = new SinFunction();\n         BisectionSolver solver = new BisectionSolver();\n-        Assert.assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(FastMath.PI, solver.solve(100, f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n         double result;\n         UnivariateRealSolver solver = new BrentSolver();\n         // Somewhat benign interval. The function is monotone.\n-        result = solver.solve(f, 3, 4);\n+        result = solver.solve(100, f, 3, 4);\n         // System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 7);\n         // Larger and somewhat less benign interval. The function is grows first.\n-        result = solver.solve(f, 1, 4);\n+        result = solver.solve(100, f, 1, 4);\n         // System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         UnivariateRealSolver solver = new BrentSolver();\n         // Symmetric bracket around 0. Test whether solvers can handle hitting\n         // the root in the first iteration.\n-        result = solver.solve(f, -0.2, 0.2);\n+        result = solver.solve(100, f, -0.2, 0.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 3);\n         // 1 iterations on i586 JDK 1.4.1.\n         // Asymmetric bracket around 0, just for fun. Contains extremum.\n-        result = solver.solve(f, -0.1, 0.3);\n+        result = solver.solve(100, f, -0.1, 0.3);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         Assert.assertTrue(solver.getEvaluations() <= 7);\n         // Large bracket around 0. Contains two extrema.\n-        result = solver.solve(f, -0.3, 0.45);\n+        result = solver.solve(100, f, -0.3, 0.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n         Assert.assertTrue(solver.getEvaluations() <= 8);\n         // Benign bracket around 0.5, function is monotonous.\n-        result = solver.solve(f, 0.3, 0.7);\n+        result = solver.solve(100, f, 0.3, 0.7);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n         Assert.assertTrue(solver.getEvaluations() <= 9);\n         // Less benign bracket around 0.5, contains one extremum.\n-        result = solver.solve(f, 0.2, 0.6);\n+        result = solver.solve(100, f, 0.2, 0.6);\n         // System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 10);\n         // Large, less benign bracket around 0.5, contains both extrema.\n-        result = solver.solve(f, 0.05, 0.95);\n+        result = solver.solve(100, f, 0.05, 0.95);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n         // is still a problem.\n-        result = solver.solve(f, 0.85, 1.25);\n+        result = solver.solve(100, f, 0.85, 1.25);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Less benign bracket around 1 with extremum.\n-        result = solver.solve(f, 0.8, 1.2);\n+        result = solver.solve(100, f, 0.8, 1.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Large bracket around 1. Monotonous.\n-        result = solver.solve(f, 0.85, 1.75);\n+        result = solver.solve(100, f, 0.85, 1.75);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 13);\n         // Large bracket around 1. Interval contains extremum.\n-        result = solver.solve(f, 0.55, 1.45);\n+        result = solver.solve(100, f, 0.55, 1.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 10);\n         // Very large bracket around 1 for testing fast growth behaviour.\n-        result = solver.solve(f, 0.85, 5);\n+        result = solver.solve(100, f, 0.85, 5);\n         //System.out.println(\n        //     \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         BrentSolver solver = new BrentSolver();\n \n         // endpoint is root\n-        double result = solver.solve(f, FastMath.PI, 4);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, 3, FastMath.PI);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, FastMath.PI, 4, 3.5);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, 3, FastMath.PI, 3.07);\n+        double result = solver.solve(100, f, FastMath.PI, 4);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(100, f, 3, FastMath.PI);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(100, f, FastMath.PI, 4, 3.5);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(100, f, 3, FastMath.PI, 3.07);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n     }\n \n         UnivariateRealFunction f = new SinFunction();\n         BrentSolver solver = new BrentSolver();\n         try {  // bad interval\n-            solver.solve(f, 1, -1);\n+            solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {  // no bracket\n-            solver.solve(f, 1, 1.5);\n+            solver.solve(100, f, 1, 1.5);\n             Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         }\n         try {  // no bracket\n-            solver.solve(f, 1, 1.5, 1.2);\n+            solver.solve(100, f, 1, 1.5, 1.2);\n             Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         double result;\n \n         // no guess\n-        result = solver.solve(f, 0.6, 7.0);\n+        result = solver.solve(100, f, 0.6, 7.0);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         int referenceCallsCount = f.getCallsCount();\n         Assert.assertTrue(referenceCallsCount >= 13);\n \n         // invalid guess (it *is* a root, but outside of the range)\n         try {\n-          result = solver.solve(f, 0.6, 7.0, 0.0);\n+          result = solver.solve(100, f, 0.6, 7.0, 0.0);\n           Assert.fail(\"a NumberIsTooLargeException was expected\");\n         } catch (NumberIsTooLargeException iae) {\n             // expected behaviour\n \n         // bad guess\n         f.setCallsCount(0);\n-        result = solver.solve(f, 0.6, 7.0, 0.61);\n+        result = solver.solve(100, f, 0.6, 7.0, 0.61);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(f.getCallsCount() > referenceCallsCount);\n \n         // good guess\n         f.setCallsCount(0);\n-        result = solver.solve(f, 0.6, 7.0, 0.999999);\n+        result = solver.solve(100, f, 0.6, 7.0, 0.999999);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(f.getCallsCount() < referenceCallsCount);\n \n         // perfect guess\n         f.setCallsCount(0);\n-        result = solver.solve(f, 0.6, 7.0, 1.0);\n+        result = solver.solve(100, f, 0.6, 7.0, 1.0);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertEquals(1, solver.getEvaluations());\n         Assert.assertEquals(1, f.getCallsCount());\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n         min = 0.0; max = 1.0; expected = 0.25;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = 0.0; max = 2.0; expected = 0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -4.0; max = -1.0; expected = -3.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -2.0; max = 2.0; expected = -1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -5.0; max = -2.5; expected = -3.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 3.0; max = 6.0; expected = 4.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         try {\n             // bad interval\n-            solver.solve(f, 1, -1);\n+            solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(f, 2, 3);\n+            solver.solve(100, f, 2, 3);\n             Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n         min = 3.0; max = 4.0; expected = FastMath.PI;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         try {\n             // bad interval\n-            solver.solve(f, 1, -1);\n+            solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(f, 2, 3);\n+            solver.solve(100, f, 2, 3);\n             Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n         min = 3.0; max = 4.0; expected = FastMath.PI;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         try {\n             // bad interval\n-            double root = solver.solve(f, 1, -1);\n+            double root = solver.solve(100, f, 1, -1);\n             System.out.println(\"root=\" + root);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n         }\n         try {\n             // no bracketing\n-            solver.solve(f, 2, 3);\n+            solver.solve(100, f, 2, 3);\n             Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n-        result = solver.solve(f, 3, 4);\n+        result = solver.solve(100, f, 3, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 1, 4);\n+        result = solver.solve(100, f, 1, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         Assert.assertTrue(solver.getEvaluations() > 0);\n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n-        result = solver.solve(f, -0.2, 0.2);\n+        result = solver.solve(100, f, -0.2, 0.2);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, -0.1, 0.3);\n+        result = solver.solve(100, f, -0.1, 0.3);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, -0.3, 0.45);\n+        result = solver.solve(100, f, -0.3, 0.45);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.3, 0.7);\n+        result = solver.solve(100, f, 0.3, 0.7);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.2, 0.6);\n+        result = solver.solve(100, f, 0.2, 0.6);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.05, 0.95);\n+        result = solver.solve(100, f, 0.05, 0.95);\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 1.25);\n+        result = solver.solve(100, f, 0.85, 1.25);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.8, 1.2);\n+        result = solver.solve(100, f, 0.8, 1.2);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 1.75);\n+        result = solver.solve(100, f, 0.85, 1.75);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.55, 1.45);\n+        result = solver.solve(100, f, 0.55, 1.45);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 0.85, 5);\n+        result = solver.solve(100, f, 0.85, 5);\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n         min = 3.0; max = 4.0; expected = FastMath.PI;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(f, min, max);\n+        result = solver.solve(100, f, min, max);\n         Assert.assertEquals(expected, result, tolerance);\n     }\n \n \n         try {\n             // bad interval\n-            solver.solve(f, 1, -1);\n+            solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(f, 2, 3);\n+            solver.solve(100, f, 2, 3);\n             Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n         double result;\n         UnivariateRealSolver solver = new SecantSolver();\n \n-        result = solver.solve(f, 3, 4);\n+        result = solver.solve(100, f, 3, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 6);\n-        result = solver.solve(f, 1, 4);\n+        result = solver.solve(100, f, 1, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         double result;\n         // Brent-Dekker solver.\n         UnivariateRealSolver solver = new SecantSolver();\n-        result = solver.solve(f, -0.2, 0.2);\n+        result = solver.solve(100, f, -0.2, 0.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 3);\n-        result = solver.solve(f, -0.1, 0.3);\n+        result = solver.solve(100, f, -0.1, 0.3);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 7);\n-        result = solver.solve(f, -0.3, 0.45);\n+        result = solver.solve(100, f, -0.3, 0.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 8);\n-        result = solver.solve(f, 0.3, 0.7);\n+        result = solver.solve(100, f, 0.3, 0.7);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 9);\n-        result = solver.solve(f, 0.2, 0.6);\n+        result = solver.solve(100, f, 0.2, 0.6);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 8);\n-        result = solver.solve(f, 0.05, 0.95);\n+        result = solver.solve(100, f, 0.05, 0.95);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 10);\n-        result = solver.solve(f, 0.85, 1.25);\n+        result = solver.solve(100, f, 0.85, 1.25);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 12);\n-        result = solver.solve(f, 0.8, 1.2);\n+        result = solver.solve(100, f, 0.8, 1.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 10);\n-        result = solver.solve(f, 0.85, 1.75);\n+        result = solver.solve(100, f, 0.85, 1.75);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 16);\n         // The followig is especially slow because the solver first has to reduce\n         // the bracket to exclude the extremum. After that, convergence is rapide.\n-        result = solver.solve(f, 0.55, 1.45);\n+        result = solver.solve(100, f, 0.55, 1.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 9);\n-        result = solver.solve(f, 0.85, 5);\n+        result = solver.solve(100, f, 0.85, 5);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         SecantSolver solver = new SecantSolver();\n \n         // endpoint is root\n-        double result = solver.solve(f, FastMath.PI, 4);\n+        double result = solver.solve(100, f, FastMath.PI, 4);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 3, FastMath.PI);\n+        result = solver.solve(100, f, 3, FastMath.PI);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, FastMath.PI, 4, 3.5);\n+        result = solver.solve(100, f, FastMath.PI, 4, 3.5);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(f, 3, FastMath.PI, 3.07);\n+        result = solver.solve(100, f, 3, FastMath.PI, 3.07);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n     }\n         UnivariateRealFunction f = new SinFunction();\n         SecantSolver solver = new SecantSolver();\n         try {  // bad interval\n-            solver.solve(f, 1, -1);\n+            solver.solve(100, f, 1, -1);\n             Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {  // no bracket\n-            solver.solve(f, 1, 1.5);\n+            solver.solve(100, f, 1, 1.5);\n             Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         }\n         try {  // no bracket\n-            solver.solve(f, 1, 1.5, 1.2);\n+            solver.solve(100, f, 1, 1.5, 1.2);\n             Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected", "timestamp": 1291596839, "metainfo": ""}