{"sha": "e038f286fc8c16904fdb7ddf808069cabd6739fd", "log": "MATH-707 Renamed \"VectorialPointValuePair\" to \"PointVectorValuePair\" and made it a subclass of \"Pair<double[], double[]>\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorMultiStartOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorMultiStartOptimizer.java\n     /** Random generator for multi-start. */\n     private RandomVectorGenerator generator;\n     /** Found optima. */\n-    private VectorialPointValuePair[] optima;\n+    private PointVectorValuePair[] optima;\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n      * #optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} has not been\n      * called.\n      */\n-    public VectorialPointValuePair[] getOptima() {\n+    public PointVectorValuePair[] getOptima() {\n         if (optima == null) {\n             throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<PointVectorValuePair> getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public VectorialPointValuePair optimize(int maxEval, final FUNC f,\n+    public PointVectorValuePair optimize(int maxEval, final FUNC f,\n                                             double[] target, double[] weights,\n                                             double[] startPoint) {\n         maxEvaluations = maxEval;\n         RuntimeException lastException = null;\n-        optima = new VectorialPointValuePair[starts];\n+        optima = new PointVectorValuePair[starts];\n         totalEvaluations = 0;\n \n         // Multi-start loop.\n      */\n     private void sortPairs(final double[] target,\n                            final double[] weights) {\n-        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n-                public int compare(final VectorialPointValuePair o1,\n-                                   final VectorialPointValuePair o2) {\n+        Arrays.sort(optima, new Comparator<PointVectorValuePair>() {\n+                public int compare(final PointVectorValuePair o1,\n+                                   final PointVectorValuePair o2) {\n                     if (o1 == null) {\n                         return (o2 == null) ? 0 : 1;\n                     } else if (o2 == null) {\n                     }\n                     return Double.compare(weightedResidual(o1), weightedResidual(o2));\n                 }\n-                private double weightedResidual(final VectorialPointValuePair pv) {\n+                private double weightedResidual(final PointVectorValuePair pv) {\n                     final double[] value = pv.getValueRef();\n                     double sum = 0;\n                     for (int i = 0; i < value.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorOptimizer.java\n  * @since 3.0\n  */\n public interface BaseMultivariateVectorOptimizer<FUNC extends MultivariateVectorFunction>\n-    extends BaseOptimizer<VectorialPointValuePair> {\n+    extends BaseOptimizer<PointVectorValuePair> {\n     /**\n      * Optimize an objective function.\n      * Optimization is considered to be a weighted least-squares minimization.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n      */\n-    VectorialPointValuePair optimize(int maxEval, FUNC f, double[] target,\n+    PointVectorValuePair optimize(int maxEval, FUNC f, double[] target,\n                                      double[] weight, double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/PointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/PointValuePair.java\n  * This class holds a point and the value of an objective function at\n  * that point.\n  *\n+ * @see PointVectorValuePair\n  * @see org.apache.commons.math.analysis.MultivariateFunction\n  * @version $Id$\n  * @since 3.0\n     /**\n      * Builds a point/objective function value pair.\n      *\n-     * @param point Point coordinates (this instance will store\n-     * a copy of the array, not the array passed as argument).\n+     * @param point Point coordinates. This instance will store\n+     * a copy of the array, not the array passed as argument.\n      * @param value Value of the objective function at the point.\n      */\n     public PointValuePair(final double[] point,\n      * @return a copy of the stored point.\n      */\n     public double[] getPoint() {\n-        return getKey().clone();\n+        final double[] p = getKey();\n+        return p == null ? null : p.clone();\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/PointVectorValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.Pair;\n+\n+/**\n+ * This class holds a point and the vectorial value of an objective function at\n+ * that point.\n+ *\n+ * @see PointValuePair\n+ * @see org.apache.commons.math.analysis.MultivariateVectorFunction\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class PointVectorValuePair extends Pair<double[], double[]> {\n+    /**\n+     * Builds a point/objective function value pair.\n+     *\n+     * @param point Point coordinates. This instance will store\n+     * a copy of the array, not the array passed as argument.\n+     * @param value Value of the objective function at the point.\n+     */\n+    public PointVectorValuePair(final double[] point,\n+                                final double[] value) {\n+        this(point, value, true);\n+    }\n+\n+    /**\n+     * Build a point/objective function value pair.\n+     *\n+     * @param point Point coordinates.\n+     * @param value Value of the objective function at the point.\n+     * @param copyArray if {@code true}, the input arrays will be copied,\n+     * otherwise they will be referenced.\n+     */\n+    public PointVectorValuePair(final double[] point,\n+                                final double[] value,\n+                                final boolean copyArray) {\n+        super(copyArray ?\n+              ((point == null) ? null :\n+               point.clone()) :\n+              point,\n+              copyArray ?\n+              ((value == null) ? null :\n+               value.clone()) :\n+              value);\n+    }\n+\n+    /**\n+     * Gets the point.\n+     *\n+     * @return a copy of the stored point.\n+     */\n+    public double[] getPoint() {\n+        final double[] p = getKey();\n+        return p == null ? null : p.clone();\n+    }\n+\n+    /**\n+     * Gets a reference to the point.\n+     *\n+     * @return a reference to the internal array storing the point.\n+     */\n+    public double[] getPointRef() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the value of the objective function.\n+     *\n+     * @return a copy of the stored value of the objective function.\n+     */\n+    @Override\n+    public double[] getValue() {\n+        final double[] v = super.getValue();\n+        return v == null ? null : v.clone();\n+    }\n+\n+    /**\n+     * Gets a reference to the value of the objective function.\n+     *\n+     * @return a reference to the internal array storing the value of\n+     * the objective function.\n+     */\n+    public double[] getValueRef() {\n+        return super.getValue();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n  * @since 3.0\n  */\n public class SimpleVectorialPointChecker\n-    extends AbstractConvergenceChecker<VectorialPointValuePair> {\n+    extends AbstractConvergenceChecker<PointVectorValuePair> {\n     /**\n      * Build an instance with default threshold.\n      */\n      */\n     @Override\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair previous,\n-                             final VectorialPointValuePair current) {\n+                             final PointVectorValuePair previous,\n+                             final PointVectorValuePair current) {\n         final double[] p = previous.getPointRef();\n         final double[] c = current.getPointRef();\n         for (int i = 0; i < p.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n  * @since 3.0\n  */\n public class SimpleVectorialValueChecker\n-    extends AbstractConvergenceChecker<VectorialPointValuePair> {\n+    extends AbstractConvergenceChecker<PointVectorValuePair> {\n     /**\n      * Build an instance with default thresholds.\n      */\n      */\n     @Override\n     public boolean converged(final int iteration,\n-                             final VectorialPointValuePair previous,\n-                             final VectorialPointValuePair current) {\n+                             final PointVectorValuePair previous,\n+                             final PointVectorValuePair current) {\n         final double[] p = previous.getValueRef();\n         final double[] c = current.getValueRef();\n         for (int i = 0; i < p.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n    * @param current point from current iteration\n    * @return true if the algorithm is considered to have converged\n    */\n-  boolean converged(int iteration, VectorialPointValuePair previous, VectorialPointValuePair current);\n+  boolean converged(int iteration, PointVectorValuePair previous, PointVectorValuePair current);\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n import org.apache.commons.math.analysis.MultivariateVectorFunction;\n import org.apache.commons.math.optimization.BaseMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n \n /**\n     /** Evaluations counter. */\n     protected final Incrementor evaluations = new Incrementor();\n     /** Convergence checker. */\n-    private ConvergenceChecker<VectorialPointValuePair> checker;\n+    private ConvergenceChecker<PointVectorValuePair> checker;\n     /** Target value for the objective functions at optimum. */\n     private double[] target;\n     /** Weight for the least squares cost computation. */\n     /**\n      * @param checker Convergence checker.\n      */\n-    protected BaseAbstractMultivariateVectorOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+    protected BaseAbstractMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n         this.checker = checker;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker<VectorialPointValuePair> getConvergenceChecker() {\n+    public ConvergenceChecker<PointVectorValuePair> getConvergenceChecker() {\n         return checker;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public VectorialPointValuePair optimize(int maxEval, FUNC f, double[] t, double[] w,\n+    public PointVectorValuePair optimize(int maxEval, FUNC f, double[] t, double[] w,\n                                             double[] startPoint) {\n         // Checks.\n         if (f == null) {\n      * @return the point/value pair giving the optimal value for the\n      * objective function.\n      */\n-    protected abstract VectorialPointValuePair doOptimize();\n+    protected abstract PointVectorValuePair doOptimize();\n \n     /**\n      * @return a reference to the {@link #target array}.\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import org.apache.commons.math.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n \n /** Fitter for parametric univariate real functions y = f(x).\n  * <p>When a univariate real function y = f(x) does depend on some\n         }\n \n         // perform the fit\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(maxEval, new TheoreticalValuesFunction(f),\n                                target, weights, initialGuess);\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorOptimizer;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.optimization.direct.BaseAbstractMultivariateVectorOptimizer;\n import org.apache.commons.math.util.FastMath;\n \n     /**\n      * @param checker Convergence checker.\n      */\n-    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n         super(checker);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair optimize(int maxEval,\n+    public PointVectorValuePair optimize(int maxEval,\n                                             final DifferentiableMultivariateVectorFunction f,\n                                             final double[] target, final double[] weights,\n                                             final double[] startPoint) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n \n /**\n  * Gauss-Newton least-squares solver.\n      *\n      * @param checker Convergence checker.\n      */\n-    public GaussNewtonOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+    public GaussNewtonOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n         this(true, checker);\n     }\n \n      * @param checker Convergence checker.\n      */\n     public GaussNewtonOptimizer(final boolean useLU,\n-                                ConvergenceChecker<VectorialPointValuePair> checker) {\n+                                ConvergenceChecker<PointVectorValuePair> checker) {\n         super(checker);\n         this.useLU = useLU;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair doOptimize() {\n+    public PointVectorValuePair doOptimize() {\n \n-        final ConvergenceChecker<VectorialPointValuePair> checker\n+        final ConvergenceChecker<PointVectorValuePair> checker\n             = getConvergenceChecker();\n \n         // iterate until convergence is reached\n-        VectorialPointValuePair current = null;\n+        PointVectorValuePair current = null;\n         int iter = 0;\n         for (boolean converged = false; !converged;) {\n             ++iter;\n \n             // evaluate the objective function and its jacobian\n-            VectorialPointValuePair previous = current;\n+            PointVectorValuePair previous = current;\n             updateResidualsAndCost();\n             updateJacobian();\n-            current = new VectorialPointValuePair(point, objective);\n+            current = new PointVectorValuePair(point, objective);\n \n             final double[] targetValues = getTargetRef();\n             final double[] residualsWeights = getWeightRef();\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n \n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n      *\n      * @param checker Convergence checker.\n      */\n-    public LevenbergMarquardtOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+    public LevenbergMarquardtOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n         this(100, checker, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n     }\n \n      * of the matrix is reduced.\n      */\n     public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\n-                                       ConvergenceChecker<VectorialPointValuePair> checker,\n+                                       ConvergenceChecker<PointVectorValuePair> checker,\n                                        double costRelativeTolerance,\n                                        double parRelativeTolerance,\n                                        double orthoTolerance,\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize() {\n+    protected PointVectorValuePair doOptimize() {\n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n-        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n+        PointVectorValuePair current = new PointVectorValuePair(point, objective);\n         int iter = 0;\n-        final ConvergenceChecker<VectorialPointValuePair> checker = getConvergenceChecker();\n+        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n             ++iter;\n \n             }\n \n             // compute the Q.R. decomposition of the jacobian matrix\n-            VectorialPointValuePair previous = current;\n+            PointVectorValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n+                current = new PointVectorValuePair(point, objective);\n                 return current;\n             }\n \n                         xNorm += xK * xK;\n                     }\n                     xNorm = FastMath.sqrt(xNorm);\n-                    current = new VectorialPointValuePair(point, objective);\n+                    current = new PointVectorValuePair(point, objective);\n \n                     // tests for convergence.\n                     if (checker != null) {\n--- a/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizerTest.java\n         } catch (MathIllegalStateException ise) {\n             // expected\n         }\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n-        VectorialPointValuePair[] optima = optimizer.getOptima();\n+        PointVectorValuePair[] optima = optimizer.getOptima();\n         Assert.assertEquals(10, optima.length);\n         for (int i = 0; i < optima.length; ++i) {\n             Assert.assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum1 =\n+        PointVectorValuePair optimum1 =\n             optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n                 {  8.00, 5.98, 9.89, 9.00 },\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n-        VectorialPointValuePair optimum2 =\n+        PointVectorValuePair optimum2 =\n             optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n         GaussNewtonOptimizer optimizer\n             = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n         Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n         Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         try {\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n                 { 0, 0, 0, 0, 0, 2 }\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n                 {  0, -1, 1 }\n         }, new double[] { 1, 1, 1});\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n                 {  7.0, 5.0,  9.0, 10.0 }\n         }, new double[] { 32, 23, 33, 31 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum1 =\n+        PointVectorValuePair optimum1 =\n             optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n                 {  8.00, 5.98, 9.89, 9.00 },\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n-        VectorialPointValuePair optimum2 =\n+        PointVectorValuePair optimum2 =\n             optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n \n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n         Assert.assertTrue(optimizer.getEvaluations() < 10);\n         }\n         LevenbergMarquardtOptimizer optimizer\n             = new LevenbergMarquardtOptimizer(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n-        VectorialPointValuePair optimum =\n+        PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         Assert.assertTrue(optimizer.getEvaluations() < 25);\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n                                             2.22044604926e-16);\n //      Assert.assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n       try {\n-          VectorialPointValuePair optimum =\n+          PointVectorValuePair optimum =\n               optimizer.optimize(400 * (function.getN() + 1), function,\n                                  function.getTarget(), function.getWeight(),\n                                  function.getStartPoint());\n           Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);\n       }\n \n-      public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n+      public void checkTheoreticalMinParams(PointVectorValuePair optimum) {\n           double[] params = optimum.getPointRef();\n           if (theoreticalMinParams != null) {\n               for (int i = 0; i < theoreticalMinParams.length; ++i) {", "timestamp": 1329076831, "metainfo": ""}