{"sha": "5e90090787f39c77ecf540c21069241c2e30db24", "log": "Added a new ExtendedFieldElement interface.  This interface represents anything that is real number like. It is implemented by Decimal64, Dfp and DerivativeStructure. The purpose of this interface is to be able to set up general algorithms that apply on real numbers (maybe complex too) and use genericity.  A first use case corresponds to 3D geometry objects (Vector3D and Rotation).  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ExtendedFieldElement.java\n+package org.apache.commons.math3;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+\n+/**\n+ * Interface representing a <a href=\"http://mathworld.wolfram.com/RealNumber.html\">real</a>\n+ * <a href=\"http://mathworld.wolfram.com/Field.html\">field</a>.\n+ * <p>\n+ * Classes implementing this interface will often be singletons.\n+ * </p>\n+ * @param <T> the type of the field elements\n+ * @see FieldElement\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public interface ExtendedFieldElement<T> extends FieldElement<T> {\n+\n+    /** Get the real value of the number.\n+     * @return real value\n+     */\n+    double getReal();\n+\n+    /** '+' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this+a\n+     */\n+    T add(double a);\n+\n+    /** '-' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this-a\n+     */\n+    T subtract(double a);\n+\n+    /** '&times;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&times;a\n+     */\n+    T multiply(double a);\n+\n+    /** '&divides;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&divides;a\n+     */\n+    T divide(double a);\n+\n+    /** '%' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this%a\n+     */\n+    T remainder(double a);\n+\n+    /** '%' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this%a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T remainder(T a)\n+        throws DimensionMismatchException;\n+\n+    /** absolute value.\n+     * @return abs(this)\n+     */\n+    T abs();\n+\n+    /** Get the smallest whole number larger than instance.\n+     * @return ceil(this)\n+     */\n+    T ceil();\n+\n+    /** Get the largest whole number smaller than instance.\n+     * @return floor(this)\n+     */\n+    T floor();\n+\n+    /** Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.\n+     * @return a double number r such that r is an integer r - 0.5 <= this <= r + 0.5\n+     */\n+    T rint();\n+\n+    /** Get the closest long to instance value.\n+     * @return closest long to {@link #getValue()}\n+     */\n+    long round();\n+\n+    /** Compute the signum of the instance.\n+     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n+     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n+     */\n+    T signum();\n+\n+    /**\n+     * Returns the instance with the sign of the argument.\n+     * A NaN {@code sign} argument is treated as positive.\n+     *\n+     * @param sign the sign for the returned value\n+     * @return the instance with the same sign as the {@code sign} argument\n+     */\n+    T copySign(double sign);\n+\n+    /**\n+     * Multiply the instance by a power of 2.\n+     * @param n power of 2\n+     * @return this &times; 2<sup>n</sup>\n+     */\n+    T scalb(int n);\n+\n+    /**\n+     * Returns the hypotenuse of a triangle with sides {@code this} and {@code y}\n+     * - sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n+     * avoiding intermediate overflow or underflow.\n+     *\n+     * <ul>\n+     * <li> If either argument is infinite, then the result is positive infinity.</li>\n+     * <li> else, if either argument is NaN then the result is NaN.</li>\n+     * </ul>\n+     *\n+     * @param y a value\n+     * @return sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T hypot(T y)\n+        throws DimensionMismatchException;\n+\n+    /** {@inheritDoc} */\n+    T reciprocal();\n+\n+    /** Square root.\n+     * @return square root of the instance\n+     */\n+    T sqrt();\n+\n+    /** Cubic root.\n+     * @return cubic root of the instance\n+     */\n+    T cbrt();\n+\n+    /** N<sup>th</sup> root.\n+     * @param n order of the root\n+     * @return n<sup>th</sup> root of the instance\n+     */\n+    T rootN(int n);\n+\n+    /** Power operation.\n+     * @param p power to apply\n+     * @return this<sup>p</sup>\n+     */\n+    T pow(double p);\n+\n+    /** Integer power operation.\n+     * @param n power to apply\n+     * @return this<sup>n</sup>\n+     */\n+    T pow(int n);\n+\n+    /** Power operation.\n+     * @param e exponent\n+     * @return this<sup>e</sup>\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T pow(T e)\n+        throws DimensionMismatchException;\n+\n+    /** Exponential.\n+     * @return exponential of the instance\n+     */\n+    T exp();\n+\n+    /** Exponential minus 1.\n+     * @return exponential minus one of the instance\n+     */\n+    T expm1();\n+\n+    /** Natural logarithm.\n+     * @return logarithm of the instance\n+     */\n+    T log();\n+\n+    /** Shifted natural logarithm.\n+     * @return logarithm of one plus the instance\n+     */\n+    T log1p();\n+\n+    /** Base 10 logarithm.\n+     * @return base 10 logarithm of the instance\n+     */\n+    T log10();\n+\n+    /** Cosine operation.\n+     * @return cos(this)\n+     */\n+    T cos();\n+\n+    /** Sine operation.\n+     * @return sin(this)\n+     */\n+    T sin();\n+\n+    /** Tangent operation.\n+     * @return tan(this)\n+     */\n+    T tan();\n+\n+    /** Arc cosine operation.\n+     * @return acos(this)\n+     */\n+    T acos();\n+\n+    /** Arc sine operation.\n+     * @return asin(this)\n+     */\n+    T asin();\n+\n+    /** Arc tangent operation.\n+     * @return atan(this)\n+     */\n+    T atan();\n+\n+    /** Two arguments arc tangent operation.\n+     * @param x second argument of the arc tangent\n+     * @return atan2(this, x)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T atan2(T x)\n+        throws DimensionMismatchException;\n+\n+    /** Hyperbolic cosine operation.\n+     * @return cosh(this)\n+     */\n+    T cosh();\n+\n+    /** Hyperbolic sine operation.\n+     * @return sinh(this)\n+     */\n+    T sinh();\n+\n+    /** Hyperbolic tangent operation.\n+     * @return tanh(this)\n+     */\n+    T tanh();\n+\n+    /** Inverse hyperbolic cosine operation.\n+     * @return acosh(this)\n+     */\n+    T acosh();\n+\n+    /** Inverse hyperbolic sine operation.\n+     * @return asin(this)\n+     */\n+    T asinh();\n+\n+    /** Inverse hyperbolic  tangent operation.\n+     * @return atanh(this)\n+     */\n+    T atanh();\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     * @since 3.2\n+     */\n+    T linearCombination(T[] a, T[] b)\n+        throws DimensionMismatchException;\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     */\n+    public T linearCombination(double[] a, T[] b)\n+        throws DimensionMismatchException;\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(T, T, T, T, T, T)\n+     * @see #linearCombination(T, T, T, T, T, T, T, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(T a1, T b1, T a2, T b2);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(double, T, double, T, double, T)\n+     * @see #linearCombination(double, T, double, T, double, T, double, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(double a1, T b1, double a2, T b2);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(T, T, T, T)\n+     * @see #linearCombination(T, T, T, T, T, T, T, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(double, T, double, T)\n+     * @see #linearCombination(double, T, double, T, double, T, double, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(double a1, T b1,  double a2, T b2, double a3, T b3);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(T, T, T, T)\n+     * @see #linearCombination(T, T, T, T, T, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3, T a4, T b4);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(double, T, double, T)\n+     * @see #linearCombination(double, T, double, T, double, T)\n+     * @since 3.2\n+     */\n+    public T linearCombination(double a1, T b1, double a2, T b2, double a3, T b3, double a4, T b4);\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.ExtendedFieldElement;\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.MathUtils;\n \n /** Class representing both the value and the differentials of a function.\n  * <p>This class is the workhorse of the differentiation package.</p>\n  * @version $Id$\n  * @since 3.1\n  */\n-public class DerivativeStructure implements FieldElement<DerivativeStructure>, Serializable {\n+public class DerivativeStructure implements ExtendedFieldElement<DerivativeStructure>, Serializable {\n \n     /** Serializable UID. */\n     private static final long serialVersionUID = 20120730L;\n         return compiler.getOrder();\n     }\n \n+    /***/\n+    public double getReal() {\n+        return data[0];\n+    }\n+\n     /** Get the value part of the derivative structure.\n      * @return value part of the derivative structure\n      * @see #getPartialDerivative(int...)\n         return data.clone();\n     }\n \n-    /** '+' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this+a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure add(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         ds.data[0] += a;\n         return ds;\n     }\n \n-    /** '+' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this+a\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure add(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return ds;\n     }\n \n-    /** '-' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this-a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure subtract(final double a) {\n         return add(-a);\n     }\n \n-    /** '-' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this-a\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure subtract(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return multiply((double) n);\n     }\n \n-    /** '&times;' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this&times;a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure multiply(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         for (int i = 0; i < ds.data.length; ++i) {\n         return ds;\n     }\n \n-    /** '&times;' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this&times;a\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure multiply(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return result;\n     }\n \n-    /** '&divides;' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this&divides;a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure divide(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         for (int i = 0; i < ds.data.length; ++i) {\n         return ds;\n     }\n \n-    /** '&divides;' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this&divides;a\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure divide(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return result;\n     }\n \n-    /** '%' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this%a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure remainder(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         ds.data[0] = ds.data[0] % a;\n         return ds;\n     }\n \n-    /** '%' operator.\n-     * @param a right hand side parameter of the operator\n-     * @return this%a\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure remainder(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return result;\n     }\n \n-    /** unary '-' operator.\n-     * @return -this\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure negate() {\n         final DerivativeStructure ds = new DerivativeStructure(compiler);\n         for (int i = 0; i < ds.data.length; ++i) {\n         return ds;\n     }\n \n-    /** absolute value.\n-     * @return abs(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure abs() {\n         if (Double.doubleToLongBits(data[0]) < 0) {\n             // we use the bits representation to also handle -0.0\n         }\n     }\n \n-    /** Get the smallest whole number larger than instance.\n-     * @return ceil(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure ceil() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.ceil(data[0]));\n     }\n \n-    /** Get the largest whole number smaller than instance.\n-     * @return floor(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure floor() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.floor(data[0]));\n     }\n \n-    /** Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.\n-     * @return a double number r such that r is an integer r - 0.5 <= this <= r + 0.5\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure rint() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.rint(data[0]));\n     }\n \n-    /** Get the closest long to instance value.\n-     * @return closest long to {@link #getValue()}\n-     */\n+    /** {@inheritDoc} */\n     public long round() {\n         return FastMath.round(data[0]);\n     }\n \n-    /** Compute the signum of the instance.\n-     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n-     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure signum() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.signum(data[0]));\n     }\n \n-    /**\n-     * Returns the instance with the sign of the argument.\n-     * A NaN {@code sign} argument is treated as positive.\n-     *\n-     * @param sign the sign for the returned value\n-     * @return the instance with the same sign as the {@code sign} argument\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure copySign(final double sign){\n         long m = Double.doubleToLongBits(data[0]);\n         long s = Double.doubleToLongBits(sign);\n         return FastMath.getExponent(data[0]);\n     }\n \n-    /**\n-     * Multiply the instance by a power of 2.\n-     * @param n power of 2\n-     * @return this &times; 2<sup>n</sup>\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure scalb(final int n) {\n         final DerivativeStructure ds = new DerivativeStructure(compiler);\n         for (int i = 0; i < ds.data.length; ++i) {\n             ds.data[i] = FastMath.scalb(data[i], n);\n         }\n         return ds;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure hypot(final DerivativeStructure y)\n+        throws DimensionMismatchException {\n+\n+        compiler.checkCompatibility(y.compiler);\n+\n+        if (Double.isInfinite(data[0]) || Double.isInfinite(y.data[0])) {\n+            return new DerivativeStructure(compiler.getFreeParameters(),\n+                                           compiler.getFreeParameters(),\n+                                           Double.POSITIVE_INFINITY);\n+        } else if (Double.isNaN(data[0]) || Double.isNaN(y.data[0])) {\n+            return new DerivativeStructure(compiler.getFreeParameters(),\n+                                           compiler.getFreeParameters(),\n+                                           Double.NaN);\n+        } else {\n+\n+            final int expX = getExponent();\n+            final int expY = y.getExponent();\n+            if (expX > expY + 27) {\n+                // y is neglectible with respect to x\n+                return abs();\n+            } else if (expY > expX + 27) {\n+                // x is neglectible with respect to y\n+                return y.abs();\n+            } else {\n+\n+                // find an intermediate scale to avoid both overflow and underflow\n+                final int middleExp = (expX + expY) / 2;\n+\n+                // scale parameters without losing precision\n+                final DerivativeStructure scaledX = scalb(-middleExp);\n+                final DerivativeStructure scaledY = y.scalb(-middleExp);\n+\n+                // compute scaled hypotenuse\n+                final DerivativeStructure scaledH =\n+                        scaledX.multiply(scaledX).add(scaledY.multiply(scaledY)).sqrt();\n+\n+                // remove scaling\n+                return scaledH.scalb(middleExp);\n+\n+            }\n+\n+        }\n     }\n \n     /**\n      */\n     public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)\n         throws DimensionMismatchException {\n-\n-        x.compiler.checkCompatibility(y.compiler);\n-\n-        if (Double.isInfinite(x.data[0]) || Double.isInfinite(y.data[0])) {\n-            return new DerivativeStructure(x.compiler.getFreeParameters(),\n-                                           x.compiler.getFreeParameters(),\n-                                           Double.POSITIVE_INFINITY);\n-        } else if (Double.isNaN(x.data[0]) || Double.isNaN(y.data[0])) {\n-            return new DerivativeStructure(x.compiler.getFreeParameters(),\n-                                           x.compiler.getFreeParameters(),\n-                                           Double.NaN);\n-        } else {\n-\n-            final int expX = x.getExponent();\n-            final int expY = y.getExponent();\n-            if (expX > expY + 27) {\n-                // y is neglectible with respect to x\n-                return x.abs();\n-            } else if (expY > expX + 27) {\n-                // x is neglectible with respect to y\n-                return y.abs();\n-            } else {\n-\n-                // find an intermediate scale to avoid both overflow and underflow\n-                final int middleExp = (expX + expY) / 2;\n-\n-                // scale parameters without losing precision\n-                final DerivativeStructure scaledX = x.scalb(-middleExp);\n-                final DerivativeStructure scaledY = y.scalb(-middleExp);\n-\n-                // compute scaled hypotenuse\n-                final DerivativeStructure scaledH =\n-                        scaledX.multiply(scaledX).add(scaledY.multiply(scaledY)).sqrt();\n-\n-                // remove scaling\n-                return scaledH.scalb(middleExp);\n-\n-            }\n-\n-        }\n+        return x.hypot(y);\n     }\n \n     /** Compute composition of the instance by a univariate function.\n         return result;\n     }\n \n-    /** Square root.\n-     * @return square root of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure sqrt() {\n         return rootN(2);\n     }\n \n-    /** Cubic root.\n-     * @return cubic root of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure cbrt() {\n         return rootN(3);\n     }\n \n-    /** N<sup>th</sup> root.\n-     * @param n order of the root\n-     * @return n<sup>th</sup> root of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure rootN(final int n) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.rootN(data, 0, n, result.data, 0);\n         };\n     }\n \n-    /** Power operation.\n-     * @param p power to apply\n-     * @return this<sup>p</sup>\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure pow(final double p) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.pow(data, 0, p, result.data, 0);\n         return result;\n     }\n \n-    /** Integer power operation.\n-     * @param n power to apply\n-     * @return this<sup>n</sup>\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure pow(final int n) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.pow(data, 0, n, result.data, 0);\n         return result;\n     }\n \n-    /** Power operation.\n-     * @param e exponent\n-     * @return this<sup>e</sup>\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure pow(final DerivativeStructure e)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(e.compiler);\n         return result;\n     }\n \n-    /** Exponential.\n-     * @return exponential of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure exp() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.exp(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Exponential minus 1.\n-     * @return exponential minus one of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure expm1() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.expm1(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Natural logarithm.\n-     * @return logarithm of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure log() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Shifted natural logarithm.\n-     * @return logarithm of one plus the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure log1p() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log1p(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Base 10 logarithm.\n-     * @return base 10 logarithm of the instance\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure log10() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log10(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Cosine operation.\n-     * @return cos(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure cos() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.cos(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Sine operation.\n-     * @return sin(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure sin() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.sin(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Tangent operation.\n-     * @return tan(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure tan() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.tan(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Arc cosine operation.\n-     * @return acos(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure acos() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.acos(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Arc sine operation.\n-     * @return asin(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure asin() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.asin(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Arc tangent operation.\n-     * @return atan(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure atan() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.atan(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure atan2(final DerivativeStructure x)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(x.compiler);\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.atan2(data, 0, x.data, 0, result.data, 0);\n         return result;\n     }\n \n      */\n     public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\n         throws DimensionMismatchException {\n-        y.compiler.checkCompatibility(x.compiler);\n-        final DerivativeStructure result = new DerivativeStructure(y.compiler);\n-        y.compiler.atan2(y.data, 0, x.data, 0, result.data, 0);\n-        return result;\n-    }\n-\n-    /** Hyperbolic cosine operation.\n-     * @return cosh(this)\n-     */\n+        return y.atan2(x);\n+    }\n+\n+    /** {@inheritDoc} */\n     public DerivativeStructure cosh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.cosh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Hyperbolic sine operation.\n-     * @return sinh(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure sinh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.sinh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Hyperbolic tangent operation.\n-     * @return tanh(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure tanh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.tanh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Inverse hyperbolic cosine operation.\n-     * @return acosh(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure acosh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.acosh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Inverse hyperbolic sine operation.\n-     * @return asin(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure asinh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.asinh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** Inverse hyperbolic  tangent operation.\n-     * @return atanh(this)\n-     */\n+    /** {@inheritDoc} */\n     public DerivativeStructure atanh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.atanh(data, 0, result.data, 0);\n      */\n     public double taylor(final double ... delta) {\n         return compiler.taylor(data, 0, delta);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n+        throws DimensionMismatchException {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double[] aDouble = new double[a.length];\n+        for (int i = 0; i < a.length; ++i) {\n+            aDouble[i] = a[i].getValue();\n+        }\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < b.length; ++i) {\n+            bDouble[i] = b[i].getValue();\n+        }\n+        final double accurateValue = MathArrays.linearCombination(aDouble, bDouble);\n+\n+        // compute a simple value, with all partial derivatives\n+        DerivativeStructure simpleValue = a[0].getField().getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            simpleValue = simpleValue.add(a[i].multiply(b[i]));\n+        }\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n+        throws DimensionMismatchException {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < b.length; ++i) {\n+            bDouble[i] = b[i].getValue();\n+        }\n+        final double accurateValue = MathArrays.linearCombination(a, bDouble);\n+\n+        // compute a simple value, with all partial derivatives\n+        DerivativeStructure simpleValue = b[0].getField().getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            simpleValue = simpleValue.add(b[i].multiply(a[i]));\n+        }\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                 final DerivativeStructure a2, final DerivativeStructure b2) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                 final double a2, final DerivativeStructure b2) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                 final DerivativeStructure a2, final DerivativeStructure b2,\n+                                                 final DerivativeStructure a3, final DerivativeStructure b3) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue(),\n+                                                                  a3.getValue(), b3.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                 final double a2, final DerivativeStructure b2,\n+                                                 final double a3, final DerivativeStructure b3) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue(),\n+                                                                  a3, b3.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n+                                                 final DerivativeStructure a2, final DerivativeStructure b2,\n+                                                 final DerivativeStructure a3, final DerivativeStructure b3,\n+                                                 final DerivativeStructure a4, final DerivativeStructure b4) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n+                                                                  a2.getValue(), b2.getValue(),\n+                                                                  a3.getValue(), b3.getValue(),\n+                                                                  a4.getValue(), b4.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n+                                                 final double a2, final DerivativeStructure b2,\n+                                                 final double a3, final DerivativeStructure b3,\n+                                                 final double a4, final DerivativeStructure b4) {\n+\n+        // compute an accurate value, taking care of cancellations\n+        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n+                                                                  a2, b2.getValue(),\n+                                                                  a3, b3.getValue(),\n+                                                                  a4, b4.getValue());\n+\n+        // compute a simple value, with all partial derivatives\n+        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));\n+\n+        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n+        final double[] data = simpleValue.getAllDerivatives();\n+        data[0] = accurateValue;\n+        return new DerivativeStructure(getFreeParameters(), getOrder(), data);\n+\n+    }\n+\n+    /**\n+     * Test for the equality of two derivative structures.\n+     * <p>\n+     * Derivative structures are considered equal if they have the same number\n+     * of free parameters, the same derivation order, and the same derivatives.\n+     * </p>\n+     * @param other Object to test for equality to this\n+     * @return true if two derivative structures are equal\n+     * @since 3.2\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof DerivativeStructure) {\n+            final DerivativeStructure rhs = (DerivativeStructure)other;\n+            return (getFreeParameters() == rhs.getFreeParameters()) &&\n+                   (getOrder() == rhs.getOrder()) &&\n+                   MathArrays.equals(data, rhs.data);\n+        }\n+\n+        return false;\n+\n+    }\n+\n+    /**\n+     * Get a hashCode for the derivative structure.\n+     * @return a hash code value for this object\n+     * @since 3.2\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 227 + 229 * getFreeParameters() + 233 * getOrder() + 239 * MathUtils.hash(data);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.util.FastMath;\n \n /**\n  *  Decimal floating point library for Java\n  * @version $Id$\n  * @since 2.2\n  */\n-public class Dfp implements FieldElement<Dfp> {\n+public class Dfp implements ExtendedFieldElement<Dfp> {\n \n     /** The radix, or base of this system.  Set to 10000 */\n     public static final int RADIX = 10000;\n     /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n      *  @return integer base 10 logarithm\n      */\n-    public int log10()  {\n+    public int intLog10()  {\n         if (mant[mant.length-1] > 1000) {\n             return exp * 4 - 1;\n         }\n \n         /* Find the exponent, first estimate by integer log10, then adjust.\n          Should be faster than doing a natural logarithm.  */\n-        int exponent = (int)(y.log10() * 3.32);\n+        int exponent = (int)(y.intLog10() * 3.32);\n         if (exponent < 0) {\n             exponent--;\n         }\n         return split;\n     }\n \n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public double getReal() {\n+        return toDouble();\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp add(final double a) {\n+        return add(newInstance(a));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp subtract(final double a) {\n+        return subtract(newInstance(a));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp multiply(final double a) {\n+        return multiply(newInstance(a));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp divide(final double a) {\n+        return divide(newInstance(a));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp remainder(final double a) {\n+        return remainder(newInstance(a));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public long round() {\n+        return FastMath.round(toDouble());\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp signum() {\n+        if (isNaN() || isZero()) {\n+            return this;\n+        } else {\n+            return newInstance(sign > 0 ? +1 : -1);\n+        }\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp copySign(final double sign) {\n+        long s = Double.doubleToLongBits(sign);\n+        if ((sign >= 0 && s >= 0) || (sign < 0 && s < 0)) { // Sign is currently OK\n+            return this;\n+        }\n+        return negate(); // flip sign\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp scalb(final int n) {\n+        return multiply(DfpMath.pow(getTwo(), n));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp hypot(final Dfp y) {\n+        return multiply(this).add(y.multiply(y)).sqrt();\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp cbrt() {\n+        return rootN(3);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp rootN(final int n) {\n+        return DfpMath.pow(this, getOne().divide(n));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp pow(final double p) {\n+        return DfpMath.pow(this, newInstance(p));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp pow(final int n) {\n+        return DfpMath.pow(this, n);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp pow(final Dfp e) {\n+        return DfpMath.pow(this, e);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp exp() {\n+        return DfpMath.exp(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp expm1() {\n+        return DfpMath.exp(this).subtract(getOne());\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp log() {\n+        return DfpMath.log(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp log1p() {\n+        return DfpMath.log(this.add(getOne()));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp log10() {\n+        return DfpMath.log(this).divide(DfpMath.log(newInstance(10)));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp cos() {\n+        return DfpMath.cos(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp sin() {\n+        return DfpMath.sin(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp tan() {\n+        return DfpMath.tan(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp acos() {\n+        return DfpMath.acos(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp asin() {\n+        return DfpMath.asin(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp atan() {\n+        return DfpMath.atan(this);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp atan2(final Dfp x)\n+        throws DimensionMismatchException {\n+\n+        // compute r = sqrt(x^2+y^2)\n+        final Dfp r = x.multiply(x).add(multiply(this)).sqrt();\n+\n+        if (x.sign >= 0) {\n+\n+            // compute atan2(y, x) = 2 atan(y / (r + x))\n+            return getTwo().multiply(divide(r.add(x)).atan());\n+\n+        } else {\n+\n+            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n+            final Dfp tmp = getTwo().multiply(divide(r.subtract(x)).atan());\n+            final Dfp pmPi = newInstance((tmp.sign <= 0) ? -FastMath.PI : FastMath.PI);\n+            return pmPi.subtract(tmp);\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp cosh() {\n+        return DfpMath.exp(this).add(DfpMath.exp(negate())).divide(2);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp sinh() {\n+        return DfpMath.exp(this).subtract(DfpMath.exp(negate())).divide(2);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp tanh() {\n+        final Dfp ePlus  = DfpMath.exp(this);\n+        final Dfp eMinus = DfpMath.exp(negate());\n+        return ePlus.add(eMinus).divide(ePlus.subtract(eMinus));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp acosh() {\n+        return multiply(this).subtract(getOne()).sqrt().add(this).log();\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp asinh() {\n+        return multiply(this).add(getOne()).sqrt().add(this).log();\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp atanh() {\n+        return getOne().add(this).divide(getOne().subtract(this)).log().divide(2);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final Dfp[] a, final Dfp[] b)\n+        throws DimensionMismatchException {\n+        if (a.length != b.length) {\n+            throw new DimensionMismatchException(a.length, b.length);\n+        }\n+        Dfp r = getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            r = r.add(a[i].multiply(b[i]));\n+        }\n+        return r;\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final double[] a, final Dfp[] b)\n+        throws DimensionMismatchException {\n+        if (a.length != b.length) {\n+            throw new DimensionMismatchException(a.length, b.length);\n+        }\n+        Dfp r = getZero();\n+        for (int i = 0; i < a.length; ++i) {\n+            r = r.add(b[i].multiply(a[i]));\n+        }\n+        return r;\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final Dfp a1, final Dfp b1, final Dfp a2, final Dfp b2) {\n+        return a1.multiply(b1).add(a2.multiply(b2));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final double a1, final Dfp b1, final double a2, final Dfp b2) {\n+        return b1.multiply(a1).add(b2.multiply(a2));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final Dfp a1, final Dfp b1,\n+                                 final Dfp a2, final Dfp b2,\n+                                 final Dfp a3, final Dfp b3) {\n+        return a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final double a1, final Dfp b1,\n+                                 final double a2, final Dfp b2,\n+                                 final double a3, final Dfp b3) {\n+        return b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final Dfp a1, final Dfp b1, final Dfp a2, final Dfp b2,\n+                                 final Dfp a3, final Dfp b3, final Dfp a4, final Dfp b4) {\n+        return a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n+    public Dfp linearCombination(final double a1, final Dfp b1, final double a2, final Dfp b2,\n+                                 final double a3, final Dfp b3, final double a4, final Dfp b4) {\n+        return b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math3/dfp/DfpDec.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/DfpDec.java\n         }\n \n         if (up) {\n-            inc = power10(log10() - getDecimalDigits() + 1);\n+            inc = power10(intLog10() - getDecimalDigits() + 1);\n             inc = copysign(inc, this);\n \n             if (this.equals(getZero())) {\n                 result = add(inc);\n             }\n         } else {\n-            inc = power10(log10());\n+            inc = power10(intLog10());\n             inc = copysign(inc, this);\n \n             if (this.equals(inc)) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.Field;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * This class is a re-implementation of {@link Rotation} using {@link ExtendedFieldElement}.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Id$\n+ * @see Vector3DDSDS\n+ * @see RotationOrder\n+ * @since 3.2\n+ */\n+\n+public class FieldRotation<T extends ExtendedFieldElement<T>> implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 20130224l;\n+\n+    /** Scalar coordinate of the quaternion. */\n+    private final T q0;\n+\n+    /** First coordinate of the vectorial part of the quaternion. */\n+    private final T q1;\n+\n+    /** Second coordinate of the vectorial part of the quaternion. */\n+    private final T q2;\n+\n+    /** Third coordinate of the vectorial part of the quaternion. */\n+    private final T q3;\n+\n+    /** Build a rotation from the quaternion coordinates.\n+     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+     * the constructor can normalize it in a preprocessing step.</p>\n+     * <p>Note that some conventions put the scalar part of the quaternion\n+     * as the 4<sup>th</sup> component and the vector part as the first three\n+     * components. This is <em>not</em> our convention. We put the scalar part\n+     * as the first component.</p>\n+     * @param q0 scalar part of the quaternion\n+     * @param q1 first coordinate of the vectorial part of the quaternion\n+     * @param q2 second coordinate of the vectorial part of the quaternion\n+     * @param q3 third coordinate of the vectorial part of the quaternion\n+     * @param needsNormalization if true, the coordinates are considered\n+     * not to be normalized, a normalization preprocessing step is performed\n+     * before using them\n+     */\n+    public FieldRotation(final T q0, final T q1, final T q2, final T q3, final boolean needsNormalization) {\n+\n+        if (needsNormalization) {\n+            // normalization preprocessing\n+            final T inv =\n+                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n+            this.q0 = inv.multiply(q0);\n+            this.q1 = inv.multiply(q1);\n+            this.q2 = inv.multiply(q2);\n+            this.q3 = inv.multiply(q3);\n+        } else {\n+            this.q0 = q0;\n+            this.q1 = q1;\n+            this.q2 = q2;\n+            this.q3 = q3;\n+        }\n+\n+    }\n+\n+    /** Build a rotation from an axis and an angle.\n+     * <p>We use the convention that angles are oriented according to\n+     * the effect of the rotation on vectors around the axis. That means\n+     * that if (i, j, k) is a direct frame and if we first provide +k as\n+     * the axis and &pi;/2 as the angle to this constructor, and then\n+     * {@link #applyTo(FieldVector3D) apply} the instance to +i, we will get\n+     * +j.</p>\n+     * <p>Another way to represent our convention is to say that a rotation\n+     * of angle &theta; about the unit vector (x, y, z) is the same as the\n+     * rotation build from quaternion components { cos(-&theta;/2),\n+     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n+     * Note the minus sign on the angle!</p>\n+     * <p>On the one hand this convention is consistent with a vectorial\n+     * perspective (moving vectors in fixed frames), on the other hand it\n+     * is different from conventions with a frame perspective (fixed vectors\n+     * viewed from different frames) like the ones used for example in spacecraft\n+     * attitude community or in the graphics community.</p>\n+     * @param axis axis around which to rotate\n+     * @param angle rotation angle.\n+     * @exception MathIllegalArgumentException if the axis norm is zero\n+     */\n+    public FieldRotation(final FieldVector3D<T> axis, final T angle)\n+        throws MathIllegalArgumentException {\n+\n+        final T norm = axis.getNorm();\n+        if (norm.getReal() == 0) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n+        }\n+\n+        final T halfAngle = angle.multiply(-0.5);\n+        final T coeff = halfAngle.sin().divide(norm);\n+\n+        q0 = halfAngle.cos();\n+        q1 = coeff.multiply(axis.getX());\n+        q2 = coeff.multiply(axis.getY());\n+        q3 = coeff.multiply(axis.getZ());\n+\n+    }\n+\n+    /** Build a rotation from a 3X3 matrix.\n+\n+     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+     * (which are matrices for which m.m<sup>T</sup> = I) with real\n+     * coefficients. The module of the determinant of unit matrices is\n+     * 1, among the orthogonal 3X3 matrices, only the ones having a\n+     * positive determinant (+1) are rotation matrices.</p>\n+\n+     * <p>When a rotation is defined by a matrix with truncated values\n+     * (typically when it is extracted from a technical sheet where only\n+     * four to five significant digits are available), the matrix is not\n+     * orthogonal anymore. This constructor handles this case\n+     * transparently by using a copy of the given matrix and applying a\n+     * correction to the copy in order to perfect its orthogonality. If\n+     * the Frobenius norm of the correction needed is above the given\n+     * threshold, then the matrix is considered to be too far from a\n+     * true rotation matrix and an exception is thrown.<p>\n+\n+     * @param m rotation matrix\n+     * @param threshold convergence threshold for the iterative\n+     * orthogonality correction (convergence is reached when the\n+     * difference between two steps of the Frobenius norm of the\n+     * correction is below this threshold)\n+\n+     * @exception NotARotationMatrixException if the matrix is not a 3X3\n+     * matrix, or if it cannot be transformed into an orthogonal matrix\n+     * with the given threshold, or if the determinant of the resulting\n+     * orthogonal matrix is negative\n+\n+     */\n+    public FieldRotation(final T[][] m, final double threshold)\n+        throws NotARotationMatrixException {\n+\n+        // dimension check\n+        if ((m.length != 3) || (m[0].length != 3) ||\n+                (m[1].length != 3) || (m[2].length != 3)) {\n+            throw new NotARotationMatrixException(\n+                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n+                                                  m.length, m[0].length);\n+        }\n+\n+        // compute a \"close\" orthogonal matrix\n+        final T[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+        // check the sign of the determinant\n+        final T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n+        final T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n+        final T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n+        final T det =\n+                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n+        if (det.getReal() < 0.0) {\n+            throw new NotARotationMatrixException(\n+                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n+                                                  det);\n+        }\n+\n+        final T[] quat = mat2quat(ort);\n+        q0 = quat[0];\n+        q1 = quat[1];\n+        q2 = quat[2];\n+        q3 = quat[3];\n+\n+    }\n+\n+    /** Build the rotation that transforms a pair of vector into another pair.\n+\n+     * <p>Except for possible scale factors, if the instance were applied to\n+     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+     * not the same as the angular separation between v<sub>1</sub> and\n+     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+     * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+     * v<sub>2</sub>) plane.</p>\n+\n+     * @param u1 first vector of the origin pair\n+     * @param u2 second vector of the origin pair\n+     * @param v1 desired image of u1 by the rotation\n+     * @param v2 desired image of u2 by the rotation\n+     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n+     * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n+     */\n+    public FieldRotation(FieldVector3D<T> u1, FieldVector3D<T> u2, FieldVector3D<T> v1, FieldVector3D<T> v2)\n+        throws MathArithmeticException {\n+\n+        // build orthonormalized base from u1, u2\n+        // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+        final FieldVector3D<T> u3 = u1.crossProduct(u2).normalize();\n+        u2 = u3.crossProduct(u1).normalize();\n+        u1 = u1.normalize();\n+\n+        // build an orthonormalized base from v1, v2\n+        // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+        final FieldVector3D<T> v3 = v1.crossProduct(v2).normalize();\n+        v2 = v3.crossProduct(v1).normalize();\n+        v1 = v1.normalize();\n+\n+        // buid a matrix transforming the first base into the second one\n+        final T[][] array = MathArrays.buildArray(u1.getX().getField(), 3, 3);\n+        array[0][0] = u1.getX().multiply(v1.getX()).add(u2.getX().multiply(v2.getX())).add(u3.getX().multiply(v3.getX()));\n+        array[0][1] = u1.getY().multiply(v1.getX()).add(u2.getY().multiply(v2.getX())).add(u3.getY().multiply(v3.getX()));\n+        array[0][2] = u1.getZ().multiply(v1.getX()).add(u2.getZ().multiply(v2.getX())).add(u3.getZ().multiply(v3.getX()));\n+        array[1][0] = u1.getX().multiply(v1.getY()).add(u2.getX().multiply(v2.getY())).add(u3.getX().multiply(v3.getY()));\n+        array[1][1] = u1.getY().multiply(v1.getY()).add(u2.getY().multiply(v2.getY())).add(u3.getY().multiply(v3.getY()));\n+        array[1][2] = u1.getZ().multiply(v1.getY()).add(u2.getZ().multiply(v2.getY())).add(u3.getZ().multiply(v3.getY()));\n+        array[2][0] = u1.getX().multiply(v1.getZ()).add(u2.getX().multiply(v2.getZ())).add(u3.getX().multiply(v3.getZ()));\n+        array[2][1] = u1.getY().multiply(v1.getZ()).add(u2.getY().multiply(v2.getZ())).add(u3.getY().multiply(v3.getZ()));\n+        array[2][2] = u1.getZ().multiply(v1.getZ()).add(u2.getZ().multiply(v2.getZ())).add(u3.getZ().multiply(v3.getZ()));\n+\n+        T[] quat = mat2quat(array);\n+        q0 = quat[0];\n+        q1 = quat[1];\n+        q2 = quat[2];\n+        q3 = quat[3];\n+\n+    }\n+\n+    /** Build one of the rotations that transform one vector into another one.\n+\n+     * <p>Except for a possible scale factor, if the instance were\n+     * applied to the vector u it will produce the vector v. There is an\n+     * infinite number of such rotations, this constructor choose the\n+     * one with the smallest associated angle (i.e. the one whose axis\n+     * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+     * arbitrary rotation axis is chosen.</p>\n+\n+     * @param u origin vector\n+     * @param v desired image of u by the rotation\n+     * @exception MathArithmeticException if the norm of one of the vectors is zero\n+     */\n+    public FieldRotation(final FieldVector3D<T> u, final FieldVector3D<T> v) throws MathArithmeticException {\n+\n+        final T normProduct = u.getNorm().multiply(v.getNorm());\n+        if (normProduct.getReal() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+        }\n+\n+        final T dot = u.dotProduct(v);\n+\n+        if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n+            // special case u = -v: we select a PI angle rotation around\n+            // an arbitrary vector orthogonal to u\n+            final FieldVector3D<T> w = u.orthogonal();\n+            q0 = normProduct.getField().getZero();\n+            q1 = w.getX().negate();\n+            q2 = w.getY().negate();\n+            q3 = w.getZ().negate();\n+        } else {\n+            // general case: (u, v) defines a plane, we select\n+            // the shortest possible rotation: axis orthogonal to this plane\n+            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n+            final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n+            final FieldVector3D<T> q = v.crossProduct(u);\n+            q1 = coeff.multiply(q.getX());\n+            q2 = coeff.multiply(q.getY());\n+            q3 = coeff.multiply(q.getZ());\n+        }\n+\n+    }\n+\n+    /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+     * <p>Cardan rotations are three successive rotations around the\n+     * canonical axes X, Y and Z, each axis being used once. There are\n+     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+     * rotations are three successive rotations around the canonical\n+     * axes X, Y and Z, the first and last rotations being around the\n+     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+     * <p>Beware that many people routinely use the term Euler angles even\n+     * for what really are Cardan angles (this confusion is especially\n+     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+     * are often wrongly tagged as Euler angles).</p>\n+\n+     * @param order order of rotations to use\n+     * @param alpha1 angle of the first elementary rotation\n+     * @param alpha2 angle of the second elementary rotation\n+     * @param alpha3 angle of the third elementary rotation\n+     */\n+    public FieldRotation(final RotationOrder order, final T alpha1, final T alpha2, final T alpha3) {\n+        final T one = alpha1.getField().getOne();\n+        final FieldRotation<T> r1 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA1()), alpha1);\n+        final FieldRotation<T> r2 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA2()), alpha2);\n+        final FieldRotation<T> r3 = new FieldRotation<T>(new FieldVector3D<T>(one, order.getA3()), alpha3);\n+        final FieldRotation<T> composed = r1.applyTo(r2.applyTo(r3));\n+        q0 = composed.q0;\n+        q1 = composed.q1;\n+        q2 = composed.q2;\n+        q3 = composed.q3;\n+    }\n+\n+    /** Convert an orthogonal rotation matrix to a quaternion.\n+     * @param ort orthogonal rotation matrix\n+     * @return quaternion corresponding to the matrix\n+     */\n+    private T[] mat2quat(final T[][] ort) {\n+\n+        final T[] quat = MathArrays.buildArray(ort[0][0].getField(), 4);\n+\n+        // There are different ways to compute the quaternions elements\n+        // from the matrix. They all involve computing one element from\n+        // the diagonal of the matrix, and computing the three other ones\n+        // using a formula involving a division by the first element,\n+        // which unfortunately can be zero. Since the norm of the\n+        // quaternion is 1, we know at least one element has an absolute\n+        // value greater or equal to 0.5, so it is always possible to\n+        // select the right formula and avoid division by zero and even\n+        // numerical inaccuracy. Checking the elements in turn and using\n+        // the first one greater than 0.45 is safe (this leads to a simple\n+        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n+        if (s.getReal() > -0.19) {\n+            // compute q0 and deduce q1, q2 and q3\n+            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n+            T inv = quat[0].reciprocal().multiply(0.25);\n+            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n+            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n+            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n+        } else {\n+            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n+            if (s.getReal() > -0.19) {\n+                // compute q1 and deduce q0, q2 and q3\n+                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n+                T inv = quat[1].reciprocal().multiply(0.25);\n+                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n+                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n+                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n+            } else {\n+                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n+                if (s.getReal() > -0.19) {\n+                    // compute q2 and deduce q0, q1 and q3\n+                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n+                    T inv = quat[2].reciprocal().multiply(0.25);\n+                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n+                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n+                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n+                } else {\n+                    // compute q3 and deduce q0, q1 and q2\n+                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n+                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n+                    T inv = quat[3].reciprocal().multiply(0.25);\n+                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n+                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n+                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n+                }\n+            }\n+        }\n+\n+        return quat;\n+\n+    }\n+\n+    /** Revert a rotation.\n+     * Build a rotation which reverse the effect of another\n+     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n+     * instance is not changed.\n+     * @return a new rotation whose effect is the reverse of the effect\n+     * of the instance\n+     */\n+    public FieldRotation<T> revert() {\n+        return new FieldRotation<T>(q0.negate(), q1, q2, q3, false);\n+    }\n+\n+    /** Get the scalar coordinate of the quaternion.\n+     * @return scalar coordinate of the quaternion\n+     */\n+    public T getQ0() {\n+        return q0;\n+    }\n+\n+    /** Get the first coordinate of the vectorial part of the quaternion.\n+     * @return first coordinate of the vectorial part of the quaternion\n+     */\n+    public T getQ1() {\n+        return q1;\n+    }\n+\n+    /** Get the second coordinate of the vectorial part of the quaternion.\n+     * @return second coordinate of the vectorial part of the quaternion\n+     */\n+    public T getQ2() {\n+        return q2;\n+    }\n+\n+    /** Get the third coordinate of the vectorial part of the quaternion.\n+     * @return third coordinate of the vectorial part of the quaternion\n+     */\n+    public T getQ3() {\n+        return q3;\n+    }\n+\n+    /** Get the normalized axis of the rotation.\n+     * @return normalized axis of the rotation\n+     * @see #Rotation(FieldVector3D, T)\n+     */\n+    public FieldVector3D<T> getAxis() {\n+        final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n+        if (squaredSine.getReal() == 0) {\n+            final Field<T> field = squaredSine.getField();\n+            return new FieldVector3D<T>(field.getOne(), field.getZero(), field.getZero());\n+        } else if (q0.getReal() < 0) {\n+            T inverse = squaredSine.sqrt().reciprocal();\n+            return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n+        }\n+        final T inverse = squaredSine.sqrt().reciprocal().negate();\n+        return new FieldVector3D<T>(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n+    }\n+\n+    /** Get the angle of the rotation.\n+     * @return angle of the rotation (between 0 and &pi;)\n+     * @see #Rotation(FieldVector3D, T)\n+     */\n+    public T getAngle() {\n+        if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n+            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n+        } else if (q0.getReal() < 0) {\n+            return q0.negate().acos().multiply(2);\n+        }\n+        return q0.acos().multiply(2);\n+    }\n+\n+    /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+     * <p>The equations show that each rotation can be defined by two\n+     * different values of the Cardan or Euler angles set. For example\n+     * if Cardan angles are used, the rotation defined by the angles\n+     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+     * the following arbitrary choices:</p>\n+     * <ul>\n+     *   <li>for Cardan angles, the chosen set is the one for which the\n+     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n+     *   positive),</li>\n+     *   <li>for Euler angles, the chosen set is the one for which the\n+     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n+     * </ul>\n+\n+     * <p>Cardan and Euler angle have a very disappointing drawback: all\n+     * of them have singularities. This means that if the instance is\n+     * too close to the singularities corresponding to the given\n+     * rotation order, it will be impossible to retrieve the angles. For\n+     * Cardan angles, this is often called gimbal lock. There is\n+     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n+     * with Cardan and Euler representation (but not a problem with the\n+     * rotation itself, which is perfectly well defined). For Cardan\n+     * angles, singularities occur when the second angle is close to\n+     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+     * second angle is close to 0 or &pi;, this implies that the identity\n+     * rotation is always singular for Euler angles!</p>\n+\n+     * @param order rotation order to use\n+     * @return an array of three angles, in the order specified by the set\n+     * @exception CardanEulerSingularityException if the rotation is\n+     * singular with respect to the angles set specified\n+     */\n+    public T[] getAngles(final RotationOrder order)\n+        throws CardanEulerSingularityException {\n+\n+        if (order == RotationOrder.XYZ) {\n+\n+            // r (+K) coordinates are :\n+            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+            // (-r) (+I) coordinates are :\n+            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n+            if  ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n+                              v2.getZ().asin(),\n+                              v2.getY().negate().atan2(v2.getX()));\n+\n+        } else if (order == RotationOrder.XZY) {\n+\n+            // r (+J) coordinates are :\n+            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+            // (-r) (+I) coordinates are :\n+            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getZ().atan2(v1.getY()),\n+                              v2.getY().asin().negate(),\n+                              v2.getZ().atan2(v2.getX()));\n+\n+        } else if (order == RotationOrder.YXZ) {\n+\n+            // r (+K) coordinates are :\n+            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getX().atan2(v1.getZ()),\n+                              v2.getZ().asin().negate(),\n+                              v2.getX().atan2(v2.getY()));\n+\n+        } else if (order == RotationOrder.YZX) {\n+\n+            // r (+I) coordinates are :\n+            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n+                              v2.getX().asin(),\n+                              v2.getZ().negate().atan2(v2.getY()));\n+\n+        } else if (order == RotationOrder.ZXY) {\n+\n+            // r (+J) coordinates are :\n+            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getX().negate().atan2(v1.getY()),\n+                              v2.getY().asin(),\n+                              v2.getX().negate().atan2(v2.getZ()));\n+\n+        } else if (order == RotationOrder.ZYX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return buildArray(v1.getY().atan2(v1.getX()),\n+                              v2.getX().asin().negate(),\n+                              v2.getY().atan2(v2.getZ()));\n+\n+        } else if (order == RotationOrder.XYX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+            // (-r) (+I) coordinates are :\n+            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+            // and we can choose to have theta in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n+                              v2.getX().acos(),\n+                              v2.getY().atan2(v2.getZ()));\n+\n+        } else if (order == RotationOrder.XZX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+            // (-r) (+I) coordinates are :\n+            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+            // and we can choose to have psi in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getZ().atan2(v1.getY()),\n+                              v2.getX().acos(),\n+                              v2.getZ().atan2(v2.getY().negate()));\n+\n+        } else if (order == RotationOrder.YXY) {\n+\n+            // r (+J) coordinates are :\n+            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+            // (-r) (+J) coordinates are :\n+            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+            // and we can choose to have phi in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getX().atan2(v1.getZ()),\n+                              v2.getY().acos(),\n+                              v2.getX().atan2(v2.getZ().negate()));\n+\n+        } else if (order == RotationOrder.YZY) {\n+\n+            // r (+J) coordinates are :\n+            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+            // and we can choose to have psi in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n+                              v2.getY().acos(),\n+                              v2.getZ().atan2(v2.getX()));\n+\n+        } else if (order == RotationOrder.ZXZ) {\n+\n+            // r (+K) coordinates are :\n+            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+            // (-r) (+K) coordinates are :\n+            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+            // and we can choose to have phi in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getX().atan2(v1.getY().negate()),\n+                              v2.getZ().acos(),\n+                              v2.getX().atan2(v2.getY()));\n+\n+        } else { // last possibility is ZYZ\n+\n+            // r (+K) coordinates are :\n+            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+            // and we can choose to have theta in the interval [0 ; PI]\n+            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n+            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return buildArray(v1.getY().atan2(v1.getX()),\n+                              v2.getZ().acos(),\n+                              v2.getY().atan2(v2.getX().negate()));\n+\n+        }\n+\n+    }\n+\n+    /** Create a dimension 3 array.\n+     * @param a0 first array element\n+     * @param a1 second array element\n+     * @param a2 third array element\n+     * @return new array\n+     */\n+    private T[] buildArray(final T a0, final T a1, final T a2) {\n+        final T[] array = MathArrays.buildArray(a0.getField(), 3);\n+        array[0] = a0;\n+        array[1] = a1;\n+        array[2] = a2;\n+        return array;\n+    }\n+\n+    /** Create a constant vector.\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @return a constant vector\n+     */\n+    private FieldVector3D<T> vector(final double x, final double y, final double z) {\n+        final T zero = q0.getField().getZero();\n+        return new FieldVector3D<T>(zero.add(x), zero.add(y), zero.add(z));\n+    }\n+\n+    /** Get the 3X3 matrix corresponding to the instance\n+     * @return the matrix corresponding to the instance\n+     */\n+    public T[][] getMatrix() {\n+\n+        // products\n+        final T q0q0  = q0.multiply(q0);\n+        final T q0q1  = q0.multiply(q1);\n+        final T q0q2  = q0.multiply(q2);\n+        final T q0q3  = q0.multiply(q3);\n+        final T q1q1  = q1.multiply(q1);\n+        final T q1q2  = q1.multiply(q2);\n+        final T q1q3  = q1.multiply(q3);\n+        final T q2q2  = q2.multiply(q2);\n+        final T q2q3  = q2.multiply(q3);\n+        final T q3q3  = q3.multiply(q3);\n+\n+        // create the matrix\n+        final T[][] m = MathArrays.buildArray(q0.getField(), 3, 3);\n+\n+        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n+        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n+        m [2][0] = q1q3.add(q0q2).multiply(2);\n+\n+        m [0][1] = q1q2.add(q0q3).multiply(2);\n+        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n+        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n+\n+        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n+        m [1][2] = q2q3.add(q0q1).multiply(2);\n+        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n+\n+        return m;\n+\n+    }\n+\n+    /** Convert to a constant vector without derivatives.\n+     * @return a constant vector\n+     */\n+    public Rotation toRotation() {\n+        return new Rotation(q0.getReal(), q1.getReal(), q2.getReal(), q3.getReal(), false);\n+    }\n+\n+    /** Apply the rotation to a vector.\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public FieldVector3D<T> applyTo(final FieldVector3D<T> u) {\n+\n+        final T x = u.getX();\n+        final T y = u.getY();\n+        final T z = u.getZ();\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        return new FieldVector3D<T>(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                                    q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                                    q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the rotation to a vector.\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public FieldVector3D<T> applyTo(final Vector3D u) {\n+\n+        final double x = u.getX();\n+        final double y = u.getY();\n+        final double z = u.getZ();\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        return new FieldVector3D<T>(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                                    q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                                    q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to (it can be the same\n+     * array as in)\n+     */\n+    public void applyTo(final T[] in, final T[] out) {\n+\n+        final T x = in[0];\n+        final T y = in[1];\n+        final T z = in[2];\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to\n+     */\n+    public void applyTo(final double[] in, final T[] out) {\n+\n+        final double x = in[0];\n+        final double y = in[1];\n+        final double z = in[2];\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply a rotation to a vector.\n+     * @param r rotation to apply\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n+\n+        final T x = u.getX();\n+        final T y = u.getY();\n+        final T z = u.getZ();\n+\n+        final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n+\n+        return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n+                                    y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n+                                    z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector.\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public FieldVector3D<T> applyInverseTo(final FieldVector3D<T> u) {\n+\n+        final T x = u.getX();\n+        final T y = u.getY();\n+        final T z = u.getZ();\n+\n+        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final T m0 = q0.negate();\n+\n+        return new FieldVector3D<T>(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                                    m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                                    m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector.\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public FieldVector3D<T> applyInverseTo(final Vector3D u) {\n+\n+        final double x = u.getX();\n+        final double y = u.getY();\n+        final double z = u.getZ();\n+\n+        final T s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final T m0 = q0.negate();\n+\n+        return new FieldVector3D<T>(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                                    m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                                    m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to (it can be the same\n+     * array as in)\n+     */\n+    public void applyInverseTo(final T[] in, final T[] out) {\n+\n+        final T x = in[0];\n+        final T y = in[1];\n+        final T z = in[2];\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final T m0 = q0.negate();\n+\n+        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to\n+     */\n+    public void applyInverseTo(final double[] in, final T[] out) {\n+\n+        final double x = in[0];\n+        final double y = in[1];\n+        final double z = in[2];\n+\n+        final T s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final T m0 = q0.negate();\n+\n+        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the inverse of a rotation to a vector.\n+     * @param r rotation to apply\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n+\n+        final T x = u.getX();\n+        final T y = u.getY();\n+        final T z = u.getZ();\n+\n+        final T s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n+        final double m0 = -r.getQ0();\n+\n+        return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n+                                    y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n+                                    z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the instance to another rotation.\n+     * Applying the instance to a rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+     * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public FieldRotation<T> applyTo(final FieldRotation<T> r) {\n+        return new FieldRotation<T>(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n+                                    r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n+                                    r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n+                                    r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n+                                    false);\n+    }\n+\n+    /** Apply the instance to another rotation.\n+     * Applying the instance to a rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+     * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public FieldRotation<T> applyTo(final Rotation r) {\n+        return new FieldRotation<T>(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n+                                    q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n+                                    q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n+                                    q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n+                                    false);\n+    }\n+\n+    /** Apply a rotation to another rotation.\n+     * Applying a rotation to another rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n+     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(rOuter, rInner).\n+     * @param r1 rotation to apply\n+     * @param rInner rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n+        return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n+                                    rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n+                                    rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n+                                    rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n+                                    false);\n+    }\n+\n+    /** Apply the inverse of the instance to another rotation.\n+     * Applying the inverse of the instance to a rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+     * let w be the inverse image of v by the instance\n+     * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public FieldRotation<T> applyInverseTo(final FieldRotation<T> r) {\n+        return new FieldRotation<T>(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n+                                    r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n+                                    r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n+                                    r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n+                                    false);\n+    }\n+\n+    /** Apply the inverse of the instance to another rotation.\n+     * Applying the inverse of the instance to a rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+     * let w be the inverse image of v by the instance\n+     * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public FieldRotation<T> applyInverseTo(final Rotation r) {\n+        return new FieldRotation<T>(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n+                                    q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n+                                    q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n+                                    q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n+                                    false);\n+    }\n+\n+    /** Apply the inverse of a rotation to another rotation.\n+     * Applying the inverse of a rotation to another rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n+     * let w be the inverse image of v by rOuter\n+     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(rOuter, rInner).\n+     * @param rOuter rotation to apply the rotation to\n+     * @param rInner rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n+        return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n+                                    rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n+                                    rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n+                                    rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n+                                    false);\n+    }\n+\n+    /** Perfect orthogonality on a 3X3 matrix.\n+     * @param m initial matrix (not exactly orthogonal)\n+     * @param threshold convergence threshold for the iterative\n+     * orthogonality correction (convergence is reached when the\n+     * difference between two steps of the Frobenius norm of the\n+     * correction is below this threshold)\n+     * @return an orthogonal matrix close to m\n+     * @exception NotARotationMatrixException if the matrix cannot be\n+     * orthogonalized with the given threshold after 10 iterations\n+     */\n+    private T[][] orthogonalizeMatrix(final T[][] m, final double threshold)\n+        throws NotARotationMatrixException {\n+\n+        T x00 = m[0][0];\n+        T x01 = m[0][1];\n+        T x02 = m[0][2];\n+        T x10 = m[1][0];\n+        T x11 = m[1][1];\n+        T x12 = m[1][2];\n+        T x20 = m[2][0];\n+        T x21 = m[2][1];\n+        T x22 = m[2][2];\n+        double fn = 0;\n+        double fn1;\n+\n+        final T[][] o = MathArrays.buildArray(m[0][0].getField(), 3, 3);\n+\n+        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+        int i = 0;\n+        while (++i < 11) {\n+\n+            // Mt.Xn\n+            final T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n+            final T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n+            final T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n+            final T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n+            final T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n+            final T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n+            final T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n+            final T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n+            final T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n+\n+            // Xn+1\n+            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n+            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n+            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n+            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n+            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n+            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n+            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n+            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n+            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n+\n+            // correction on each elements\n+            final double corr00 = o[0][0].getReal() - m[0][0].getReal();\n+            final double corr01 = o[0][1].getReal() - m[0][1].getReal();\n+            final double corr02 = o[0][2].getReal() - m[0][2].getReal();\n+            final double corr10 = o[1][0].getReal() - m[1][0].getReal();\n+            final double corr11 = o[1][1].getReal() - m[1][1].getReal();\n+            final double corr12 = o[1][2].getReal() - m[1][2].getReal();\n+            final double corr20 = o[2][0].getReal() - m[2][0].getReal();\n+            final double corr21 = o[2][1].getReal() - m[2][1].getReal();\n+            final double corr22 = o[2][2].getReal() - m[2][2].getReal();\n+\n+            // Frobenius norm of the correction\n+            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n+                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n+                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+            // convergence test\n+            if (FastMath.abs(fn1 - fn) <= threshold) {\n+                return o;\n+            }\n+\n+            // prepare next iteration\n+            x00 = o[0][0];\n+            x01 = o[0][1];\n+            x02 = o[0][2];\n+            x10 = o[1][0];\n+            x11 = o[1][1];\n+            x12 = o[1][2];\n+            x20 = o[2][0];\n+            x21 = o[2][1];\n+            x22 = o[2][2];\n+            fn  = fn1;\n+\n+        }\n+\n+        // the algorithm did not converge after 10 iterations\n+        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n+                                              i - 1);\n+\n+    }\n+\n+    /** Compute the <i>distance</i> between two rotations.\n+     * <p>The <i>distance</i> is intended here as a way to check if two\n+     * rotations are almost similar (i.e. they transform vectors the same way)\n+     * or very different. It is mathematically defined as the angle of\n+     * the rotation r that prepended to one of the rotations gives the other\n+     * one:</p>\n+     * <pre>\n+     *        r<sub>1</sub>(r) = r<sub>2</sub>\n+     * </pre>\n+     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+     * reached for some v. The distance is equal to 0 if and only if the two\n+     * rotations are identical.</p>\n+     * <p>Comparing two rotations should always be done using this value rather\n+     * than for example comparing the components of the quaternions. It is much\n+     * more stable, and has a geometric meaning. Also comparing quaternions\n+     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+     * their components are different (they are exact opposites).</p>\n+     * @param r1 first rotation\n+     * @param r2 second rotation\n+     * @return <i>distance</i> between r1 and r2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n+        return r1.applyInverseTo(r2).getAngle();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.io.Serializable;\n+import java.text.NumberFormat;\n+\n+import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * This class is a re-implementation of {@link Vector3D} using {@link ExtendedFieldElement}.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @param <T> the type of the field elements\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class FieldVector3D<T extends ExtendedFieldElement<T>> implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20130224L;\n+\n+    /** Abscissa. */\n+    private final T x;\n+\n+    /** Ordinate. */\n+    private final T y;\n+\n+    /** Height. */\n+    private final T z;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @see #getX()\n+     * @see #getY()\n+     * @see #getZ()\n+     */\n+    public FieldVector3D(final T x, final T y, final T z) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param v coordinates array\n+     * @exception DimensionMismatchException if array does not have 3 elements\n+     * @see #toArray()\n+     */\n+    public FieldVector3D(final T[] v) throws DimensionMismatchException {\n+        if (v.length != 3) {\n+            throw new DimensionMismatchException(v.length, 3);\n+        }\n+        this.x = v[0];\n+        this.y = v[1];\n+        this.z = v[2];\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its azimuthal coordinates\n+     * @param alpha azimuth (&alpha;) around Z\n+     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+     * @see #getAlpha()\n+     * @see #getDelta()\n+     */\n+    public FieldVector3D(final T alpha, final T delta) {\n+        T cosDelta = delta.cos();\n+        this.x = alpha.cos().multiply(cosDelta);\n+        this.y = alpha.sin().multiply(cosDelta);\n+        this.z = delta.sin();\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a, final FieldVector3D<T>u) {\n+        this.x = a.multiply(u.x);\n+        this.y = a.multiply(u.y);\n+        this.z = a.multiply(u.z);\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a, final Vector3D u) {\n+        this.x = a.multiply(u.getX());\n+        this.y = a.multiply(u.getY());\n+        this.z = a.multiply(u.getZ());\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public FieldVector3D(final double a, final FieldVector3D<T> u) {\n+        this.x = u.x.multiply(a);\n+        this.y = u.y.multiply(a);\n+        this.z = u.z.multiply(a);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final FieldVector3D<T> u1,\n+                         final T a2, final FieldVector3D<T> u2) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ());\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final Vector3D u1,\n+                         final T a2, final Vector3D u2) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2);\n+        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2);\n+        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public FieldVector3D(final double a1, final FieldVector3D<T> u1,\n+                         final double a2, final FieldVector3D<T> u2) {\n+        final T prototype = u1.getX();\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ());\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final FieldVector3D<T> u1,\n+                         final T a2, final FieldVector3D<T> u2,\n+                         final T a3, final FieldVector3D<T> u3) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ());\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final Vector3D u1,\n+                         final T a2, final Vector3D u2,\n+                         final T a3, final Vector3D u3) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3);\n+        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3);\n+        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2, u3.getZ(), a3);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public FieldVector3D(final double a1, final FieldVector3D<T> u1,\n+                         final double a2, final FieldVector3D<T> u2,\n+                         final double a3, final FieldVector3D<T> u3) {\n+        final T prototype = u1.getX();\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ());\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final FieldVector3D<T> u1,\n+                         final T a2, final FieldVector3D<T> u2,\n+                         final T a3, final FieldVector3D<T> u3,\n+                         final T a4, final FieldVector3D<T> u4) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX(), a4, u4.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY(), a4, u4.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ(), a4, u4.getZ());\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public FieldVector3D(final T a1, final Vector3D u1,\n+                         final T a2, final Vector3D u2,\n+                         final T a3, final Vector3D u3,\n+                         final T a4, final Vector3D u4) {\n+        final T prototype = a1;\n+        this.x = prototype.linearCombination(u1.getX(), a1, u2.getX(), a2, u3.getX(), a3, u4.getX(), a4);\n+        this.y = prototype.linearCombination(u1.getY(), a1, u2.getY(), a2, u3.getY(), a3, u4.getY(), a4);\n+        this.z = prototype.linearCombination(u1.getZ(), a1, u2.getZ(), a2, u3.getZ(), a3, u4.getZ(), a4);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public FieldVector3D(final double a1, final FieldVector3D<T> u1,\n+                         final double a2, final FieldVector3D<T> u2,\n+                         final double a3, final FieldVector3D<T> u3,\n+                         final double a4, final FieldVector3D<T> u4) {\n+        final T prototype = u1.getX();\n+        this.x = prototype.linearCombination(a1, u1.getX(), a2, u2.getX(), a3, u3.getX(), a4, u4.getX());\n+        this.y = prototype.linearCombination(a1, u1.getY(), a2, u2.getY(), a3, u3.getY(), a4, u4.getY());\n+        this.z = prototype.linearCombination(a1, u1.getZ(), a2, u2.getZ(), a3, u3.getZ(), a4, u4.getZ());\n+    }\n+\n+    /** Get the abscissa of the vector.\n+     * @return abscissa of the vector\n+     * @see #Vector3D(T, T, T)\n+     */\n+    public T getX() {\n+        return x;\n+    }\n+\n+    /** Get the ordinate of the vector.\n+     * @return ordinate of the vector\n+     * @see #Vector3D(T, T, T)\n+     */\n+    public T getY() {\n+        return y;\n+    }\n+\n+    /** Get the height of the vector.\n+     * @return height of the vector\n+     * @see #Vector3D(T, T, T)\n+     */\n+    public T getZ() {\n+        return z;\n+    }\n+\n+    /** Get the vector coordinates as a dimension 3 array.\n+     * @return vector coordinates\n+     * @see #Vector3D(T[])\n+     */\n+    public T[] toArray() {\n+        final T[] array = MathArrays.buildArray(x.getField(), 3);\n+        array[0] = x;\n+        array[1] = y;\n+        array[2] = z;\n+        return array;\n+    }\n+\n+    /** Convert to a constant vector without derivatives.\n+     * @return a constant vector\n+     */\n+    public Vector3D toVector3D() {\n+        return new Vector3D(x.getReal(), y.getReal(), z.getReal());\n+    }\n+\n+    /** Get the L<sub>1</sub> norm for the vector.\n+     * @return L<sub>1</sub> norm for the vector\n+     */\n+    public T getNorm1() {\n+        return x.abs().add(y.abs()).add(z.abs());\n+    }\n+\n+    /** Get the L<sub>2</sub> norm for the vector.\n+     * @return Euclidean norm for the vector\n+     */\n+    public T getNorm() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n+        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\n+    }\n+\n+    /** Get the square of the norm for the vector.\n+     * @return square of the Euclidean norm for the vector\n+     */\n+    public T getNormSq() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n+        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\n+    }\n+\n+    /** Get the L<sub>&infin;</sub> norm for the vector.\n+     * @return L<sub>&infin;</sub> norm for the vector\n+     */\n+    public T getNormInf() {\n+        final T xAbs = x.abs();\n+        final T yAbs = y.abs();\n+        final T zAbs = z.abs();\n+        if (xAbs.getReal() <= yAbs.getReal()) {\n+            if (yAbs.getReal() <= zAbs.getReal()) {\n+                return zAbs;\n+            } else {\n+                return yAbs;\n+            }\n+        } else {\n+            if (xAbs.getReal() <= zAbs.getReal()) {\n+                return zAbs;\n+            } else {\n+                return xAbs;\n+            }\n+        }\n+    }\n+\n+    /** Get the azimuth of the vector.\n+     * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+     * @see #Vector3D(T, T)\n+     */\n+    public T getAlpha() {\n+        return y.atan2(x);\n+    }\n+\n+    /** Get the elevation of the vector.\n+     * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+     * @see #Vector3D(T, T)\n+     */\n+    public T getDelta() {\n+        return z.divide(getNorm()).asin();\n+    }\n+\n+    /** Add a vector to the instance.\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(x.add(v.x), y.add(v.y), z.add(v.z));\n+    }\n+\n+    /** Add a vector to the instance.\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final Vector3D v) {\n+        return new FieldVector3D<T>(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final T factor, final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(x.getField().getOne(), this, factor, v);\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final T factor, final Vector3D v) {\n+        return new FieldVector3D<T>(x.add(factor.multiply(v.getX())),\n+                                    y.add(factor.multiply(v.getY())),\n+                                    z.add(factor.multiply(v.getZ())));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final double factor, final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(1.0, this, factor, v);\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> add(final double factor, final Vector3D v) {\n+        return new FieldVector3D<T>(x.add(factor * v.getX()),\n+                                    y.add(factor * v.getY()),\n+                                    z.add(factor * v.getZ()));\n+    }\n+\n+    /** Subtract a vector from the instance.\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));\n+    }\n+\n+    /** Subtract a vector from the instance.\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final Vector3D v) {\n+        return new FieldVector3D<T>(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final T factor, final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(x.getField().getOne(), this, factor.negate(), v);\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final T factor, final Vector3D v) {\n+        return new FieldVector3D<T>(x.subtract(factor.multiply(v.getX())),\n+                                    y.subtract(factor.multiply(v.getY())),\n+                                    z.subtract(factor.multiply(v.getZ())));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final double factor, final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(1.0, this, -factor, v);\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> subtract(final double factor, final Vector3D v) {\n+        return new FieldVector3D<T>(x.subtract(factor * v.getX()),\n+                                    y.subtract(factor * v.getY()),\n+                                    z.subtract(factor * v.getZ()));\n+    }\n+\n+    /** Get a normalized vector aligned with the instance.\n+     * @return a new normalized vector\n+     * @exception MathArithmeticException if the norm is zero\n+     */\n+    public FieldVector3D<T> normalize() throws MathArithmeticException {\n+        final T s = getNorm();\n+        if (s.getReal() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+        }\n+        return scalarMultiply(s.reciprocal());\n+    }\n+\n+    /** Get a vector orthogonal to the instance.\n+     * <p>There are an infinite number of normalized vectors orthogonal\n+     * to the instance. This method picks up one of them almost\n+     * arbitrarily. It is useful when one needs to compute a reference\n+     * frame with one of the axes in a predefined direction. The\n+     * following example shows how to build a frame having the k axis\n+     * aligned with the known vector u :\n+     * <pre><code>\n+     *   Vector3D k = u.normalize();\n+     *   Vector3D i = k.orthogonal();\n+     *   Vector3D j = Vector3D.crossProduct(k, i);\n+     * </code></pre></p>\n+     * @return a new normalized vector orthogonal to the instance\n+     * @exception MathArithmeticException if the norm of the instance is null\n+     */\n+    public FieldVector3D<T> orthogonal() throws MathArithmeticException {\n+\n+        final double threshold = 0.6 * getNorm().getReal();\n+        if (threshold == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        if (FastMath.abs(x.getReal()) <= threshold) {\n+            final T inverse  = y.multiply(y).add(z.multiply(z)).sqrt().reciprocal();\n+            return new FieldVector3D<T>(inverse.getField().getZero(), inverse.multiply(z), inverse.multiply(y).negate());\n+        } else if (FastMath.abs(y.getReal()) <= threshold) {\n+            final T inverse  = x.multiply(x).add(z.multiply(z)).sqrt().reciprocal();\n+            return new FieldVector3D<T>(inverse.multiply(z).negate(), inverse.getField().getZero(), inverse.multiply(x));\n+        } else {\n+            final T inverse  = x.multiply(x).add(y.multiply(y)).sqrt().reciprocal();\n+            return new FieldVector3D<T>(inverse.multiply(y), inverse.multiply(x).negate(), inverse.getField().getZero());\n+        }\n+\n+    }\n+\n+    /** Compute the angular separation between the instance and another vector.\n+     * <p>This method computes the angular separation between two\n+     * vectors using the dot product for well separated vectors and the\n+     * cross product for almost aligned vectors. This allows to have a\n+     * good accuracy in all cases, even for vectors very close to each\n+     * other.</p>\n+     * @param v second vector\n+     * @return angular separation between the instance and v\n+     * @exception MathArithmeticException if either vector has a null norm\n+     */\n+    public T angle(FieldVector3D<T> v) throws MathArithmeticException {\n+\n+        final T normProduct = getNorm().multiply(v.getNorm());\n+        if (normProduct.getReal() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        final T dot = dotProduct(v);\n+        final double threshold = normProduct.getReal() * 0.9999;\n+        if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n+            // the vectors are almost aligned, compute using the sine\n+            FieldVector3D<T> v3 = crossProduct(v);\n+            if (dot.getReal() >= 0) {\n+                return v3.getNorm().divide(normProduct).asin();\n+            }\n+            return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n+        }\n+\n+        // the vectors are sufficiently separated to use the cosine\n+        return dot.divide(normProduct).acos();\n+\n+    }\n+\n+    /** Get the opposite of the instance.\n+     * @return a new vector which is opposite to the instance\n+     */\n+    public FieldVector3D<T> negate() {\n+        return new FieldVector3D<T>(x.negate(), y.negate(), z.negate());\n+    }\n+\n+    /** Multiply the instance by a scalar.\n+     * @param a scalar\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> scalarMultiply(final T a) {\n+        return new FieldVector3D<T>(x.multiply(a), y.multiply(a), z.multiply(a));\n+    }\n+\n+    /** Multiply the instance by a scalar.\n+     * @param a scalar\n+     * @return a new vector\n+     */\n+    public FieldVector3D<T> scalarMultiply(final double a) {\n+        return new FieldVector3D<T>(x.multiply(a), y.multiply(a), z.multiply(a));\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(x.getReal()) || Double.isNaN(y.getReal()) || Double.isNaN(z.getReal());\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+        return !isNaN() && (Double.isInfinite(x.getReal()) || Double.isInfinite(y.getReal()) || Double.isInfinite(z.getReal()));\n+    }\n+\n+    /**\n+     * Test for the equality of two 3D vectors.\n+     * <p>\n+     * If all coordinates of two 3D vectors are exactly the same, and none are\n+     * <code>T.NaN</code>, the two 3D vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * 3D vector are equal to <code>T.NaN</code>, the 3D vector is equal to\n+     * {@link #NaN}.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     *\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof FieldVector3D) {\n+            @SuppressWarnings(\"unchecked\")\n+            final FieldVector3D<T> rhs = (FieldVector3D<T>) other;\n+            if (rhs.isNaN()) {\n+                return this.isNaN();\n+            }\n+\n+            return x.equals(rhs.x) && y.equals(rhs.y) && z.equals(rhs.z);\n+\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get a hashCode for the 3D vector.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 409;\n+        }\n+        return 311 * (107 * x.hashCode() + 83 * y.hashCode() +  z.hashCode());\n+    }\n+\n+    /** Compute the dot-product of the instance and another vector.\n+     * <p>\n+     * The implementation uses specific multiplication and addition\n+     * algorithms to preserve accuracy and reduce cancellation effects.\n+     * It should be very accurate even for nearly orthogonal vectors.\n+     * </p>\n+     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n+     * @param v second vector\n+     * @return the dot product this.v\n+     */\n+    public T dotProduct(final FieldVector3D<T> v) {\n+        return x.linearCombination(x, v.x, y, v.y, z, v.z);\n+    }\n+\n+    /** Compute the dot-product of the instance and another vector.\n+     * <p>\n+     * The implementation uses specific multiplication and addition\n+     * algorithms to preserve accuracy and reduce cancellation effects.\n+     * It should be very accurate even for nearly orthogonal vectors.\n+     * </p>\n+     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n+     * @param v second vector\n+     * @return the dot product this.v\n+     */\n+    public T dotProduct(final Vector3D v) {\n+        return x.linearCombination(v.getX(), x, v.getY(), y, v.getZ(), z);\n+    }\n+\n+    /** Compute the cross-product of the instance with another vector.\n+     * @param v other vector\n+     * @return the cross product this ^ v as a new Vector3D\n+     */\n+    public FieldVector3D<T> crossProduct(final FieldVector3D<T> v) {\n+        return new FieldVector3D<T>(x.linearCombination(y, v.z, z.negate(), v.y),\n+                                    y.linearCombination(z, v.x, x.negate(), v.z),\n+                                    z.linearCombination(x, v.y, y.negate(), v.x));\n+    }\n+\n+    /** Compute the cross-product of the instance with another vector.\n+     * @param v other vector\n+     * @return the cross product this ^ v as a new Vector3D\n+     */\n+    public FieldVector3D<T> crossProduct(final Vector3D v) {\n+        return new FieldVector3D<T>(x.linearCombination(v.getZ(), y, -v.getY(), z),\n+                                    y.linearCombination(v.getX(), z, -v.getZ(), x),\n+                                    z.linearCombination(v.getY(), x, -v.getX(), y));\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>1</sub> norm\n+     */\n+    public T distance1(final FieldVector3D<T> v) {\n+        final T dx = v.x.subtract(x).abs();\n+        final T dy = v.y.subtract(y).abs();\n+        final T dz = v.z.subtract(z).abs();\n+        return dx.add(dy).add(dz);\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>1</sub> norm\n+     */\n+    public T distance1(final Vector3D v) {\n+        final T dx = x.subtract(v.getX()).abs();\n+        final T dy = y.subtract(v.getY()).abs();\n+        final T dz = z.subtract(v.getZ()).abs();\n+        return dx.add(dy).add(dz);\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>2</sub> norm\n+     */\n+    public T distance(final FieldVector3D<T> v) {\n+        final T dx = v.x.subtract(x);\n+        final T dy = v.y.subtract(y);\n+        final T dz = v.z.subtract(z);\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>2</sub> norm\n+     */\n+    public T distance(final Vector3D v) {\n+        final T dx = x.subtract(v.getX());\n+        final T dy = y.subtract(v.getY());\n+        final T dz = z.subtract(v.getZ());\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\n+     */\n+    public T distanceInf(final FieldVector3D<T> v) {\n+        final T dx = v.x.subtract(x).abs();\n+        final T dy = v.y.subtract(y).abs();\n+        final T dz = v.z.subtract(z).abs();\n+        if (dx.getReal() <= dy.getReal()) {\n+            if (dy.getReal() <= dz.getReal()) {\n+                return dz;\n+            } else {\n+                return dy;\n+            }\n+        } else {\n+            if (dx.getReal() <= dz.getReal()) {\n+                return dz;\n+            } else {\n+                return dx;\n+            }\n+        }\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\n+     */\n+    public T distanceInf(final Vector3D v) {\n+        final T dx = x.subtract(v.getX()).abs();\n+        final T dy = y.subtract(v.getY()).abs();\n+        final T dz = z.subtract(v.getZ()).abs();\n+        if (dx.getReal() <= dy.getReal()) {\n+            if (dy.getReal() <= dz.getReal()) {\n+                return dz;\n+            } else {\n+                return dy;\n+            }\n+        } else {\n+            if (dx.getReal() <= dz.getReal()) {\n+                return dz;\n+            } else {\n+                return dx;\n+            }\n+        }\n+    }\n+\n+    /** Compute the square of the distance between the instance and another vector.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the square of the distance between the instance and p\n+     */\n+    public T distanceSq(final FieldVector3D<T> v) {\n+        final T dx = v.x.subtract(x);\n+        final T dy = v.y.subtract(y);\n+        final T dz = v.z.subtract(z);\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+    }\n+\n+    /** Compute the square of the distance between the instance and another vector.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the square of the distance between the instance and p\n+     */\n+    public T distanceSq(final Vector3D v) {\n+        final T dx = x.subtract(v.getX());\n+        final T dy = y.subtract(v.getY());\n+        final T dz = z.subtract(v.getZ());\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+    }\n+\n+    /** Get a string representation of this vector.\n+     * @return a string representation of this vector\n+     */\n+    @Override\n+    public String toString() {\n+        return Vector3DFormat.getInstance().format(toVector3D());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(final NumberFormat format) {\n+        return new Vector3DFormat(format).format(toVector3D());\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n package org.apache.commons.math3.linear;\n \n import java.io.Serializable;\n-import java.lang.reflect.Array;\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.OpenIntToFieldHashMap;\n \n /**\n \n     /** {@inheritDoc} */\n     public T[] toArray() {\n-        T[] res = buildArray(virtualSize);\n+        T[] res = MathArrays.buildArray(field, virtualSize);\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n         }\n     }\n \n-    /**\n-     * Build an array of elements.\n-     *\n-     * @param length Size of the array to build.\n-     * @return a new array.\n-     */\n-    @SuppressWarnings(\"unchecked\") // field is type T\n-    private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n-    }\n-\n-\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/math3/util/Decimal64.java\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64.java\n  */\n package org.apache.commons.math3.util;\n \n+import org.apache.commons.math3.ExtendedFieldElement;\n import org.apache.commons.math3.Field;\n-import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n \n /**\n  * This class wraps a {@code double} value in an object. It is similar to the\n  * standard class {@link Double}, while also implementing the\n- * {@link FieldElement} interface.\n+ * {@link ExtendedFieldElement} interface.\n  *\n  * @since 3.1\n  * @version $Id$\n  */\n-public class Decimal64 extends Number implements FieldElement<Decimal64>,\n-Comparable<Decimal64> {\n+public class Decimal64 extends Number\n+                       implements ExtendedFieldElement<Decimal64>, Comparable<Decimal64> {\n \n     /** The constant value of {@code 0d} as a {@code Decimal64}. */\n     public static final Decimal64 ZERO;\n     public boolean isNaN() {\n         return Double.isNaN(value);\n     }\n+\n+    /** {@inheritDoc} */\n+    public double getReal() {\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 add(final double a) {\n+        return new Decimal64(value + a);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 subtract(final double a) {\n+        return new Decimal64(value - a);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 multiply(final double a) {\n+        return new Decimal64(value * a);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 divide(final double a) {\n+        return new Decimal64(value / a);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 remainder(final double a) {\n+        return new Decimal64(value % a);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 remainder(final Decimal64 a) {\n+        return new Decimal64(value % a.value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 abs() {\n+        return new Decimal64(FastMath.abs(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 ceil() {\n+        return new Decimal64(FastMath.ceil(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 floor() {\n+        return new Decimal64(FastMath.floor(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 rint() {\n+        return new Decimal64(FastMath.rint(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public long round() {\n+        return FastMath.round(value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 signum() {\n+        return new Decimal64(FastMath.signum(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 copySign(final double sign) {\n+        return new Decimal64(FastMath.copySign(value, sign));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 scalb(final int n) {\n+        return new Decimal64(FastMath.scalb(value, n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 hypot(final Decimal64 y) {\n+        return new Decimal64(FastMath.hypot(value, y.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 sqrt() {\n+        return new Decimal64(FastMath.sqrt(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 cbrt() {\n+        return new Decimal64(FastMath.cbrt(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 rootN(final int n) {\n+        return new Decimal64(FastMath.pow(value, 1.0 / n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 pow(final double p) {\n+        return new Decimal64(FastMath.pow(value, p));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 pow(final int n) {\n+        return new Decimal64(FastMath.pow(value, n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 pow(final Decimal64 e) {\n+        return new Decimal64(FastMath.pow(value, e.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 exp() {\n+        return new Decimal64(FastMath.exp(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 expm1() {\n+        return new Decimal64(FastMath.expm1(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 log() {\n+        return new Decimal64(FastMath.log(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 log1p() {\n+        return new Decimal64(FastMath.log1p(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 log10() {\n+        return new Decimal64(FastMath.log10(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 cos() {\n+        return new Decimal64(FastMath.cos(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 sin() {\n+        return new Decimal64(FastMath.sin(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 tan() {\n+        return new Decimal64(FastMath.tan(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 acos() {\n+        return new Decimal64(FastMath.acos(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 asin() {\n+        return new Decimal64(FastMath.asin(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 atan() {\n+        return new Decimal64(FastMath.atan(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 atan2(final Decimal64 x) {\n+        return new Decimal64(FastMath.atan2(value, x.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 cosh() {\n+        return new Decimal64(FastMath.cosh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 sinh() {\n+        return new Decimal64(FastMath.sinh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 tanh() {\n+        return new Decimal64(FastMath.tanh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 acosh() {\n+        return new Decimal64(FastMath.acosh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 asinh() {\n+        return new Decimal64(FastMath.asinh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 atanh() {\n+        return new Decimal64(FastMath.atanh(value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final Decimal64[] a, final Decimal64[] b)\n+        throws DimensionMismatchException {\n+        if (a.length != b.length) {\n+            throw new DimensionMismatchException(a.length, b.length);\n+        }\n+        final double[] aDouble = new double[a.length];\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < a.length; ++i) {\n+            aDouble[i] = a[i].value;\n+            bDouble[i] = b[i].value;\n+        }\n+        return new Decimal64(MathArrays.linearCombination(aDouble, bDouble));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final double[] a, final Decimal64[] b)\n+        throws DimensionMismatchException {\n+        if (a.length != b.length) {\n+            throw new DimensionMismatchException(a.length, b.length);\n+        }\n+        final double[] bDouble = new double[b.length];\n+        for (int i = 0; i < a.length; ++i) {\n+            bDouble[i] = b[i].value;\n+        }\n+        return new Decimal64(MathArrays.linearCombination(a, bDouble));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n+                                       final Decimal64 a2, final Decimal64 b2) {\n+        return new Decimal64(MathArrays.linearCombination(a1.value, b1.value,\n+                                                          a2.value, b2.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n+                                       final double a2, final Decimal64 b2) {\n+        return new Decimal64(MathArrays.linearCombination(a1, b1.value,\n+                                                          a2, b2.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n+                                       final Decimal64 a2, final Decimal64 b2,\n+                                       final Decimal64 a3, final Decimal64 b3) {\n+        return new Decimal64(MathArrays.linearCombination(a1.value, b1.value,\n+                                                          a2.value, b2.value,\n+                                                          a3.value, b3.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n+                                       final double a2, final Decimal64 b2,\n+                                       final double a3, final Decimal64 b3) {\n+        return new Decimal64(MathArrays.linearCombination(a1, b1.value,\n+                                                          a2, b2.value,\n+                                                          a3, b3.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n+                                       final Decimal64 a2, final Decimal64 b2,\n+                                       final Decimal64 a3, final Decimal64 b3,\n+                                       final Decimal64 a4, final Decimal64 b4) {\n+        return new Decimal64(MathArrays.linearCombination(a1.value, b1.value,\n+                                                          a2.value, b2.value,\n+                                                          a3.value, b3.value,\n+                                                          a4.value, b4.value));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n+                                       final double a2, final Decimal64 b2,\n+                                       final double a3, final Decimal64 b3,\n+                                       final double a4, final Decimal64 b4) {\n+        return new Decimal64(MathArrays.linearCombination(a1, b1.value,\n+                                                          a2, b2.value,\n+                                                          a3, b3.value,\n+                                                          a4, b4.value));\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n \n package org.apache.commons.math3.util;\n \n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.Collections;\n-\n-import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+\n+import org.apache.commons.math3.Field;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.exception.MathArithmeticException;\n \n /**\n  * Arrays utilities.\n         }\n \n         return result;\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * This method computes the sum of the products\n-     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n-     * It does so by using specific multiplication and addition algorithms to\n-     * preserve accuracy and reduce cancellation effects.\n-     * <br/>\n-     * It is based on the 2005 paper\n-     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n-     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     *\n-     * @param a Factors.\n-     * @param b Factors.\n-     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n-     * @throws DimensionMismatchException if arrays dimensions don't match\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n-        throws DimensionMismatchException {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double[] aDouble = new double[a.length];\n-        for (int i = 0; i < a.length; ++i) {\n-            aDouble[i] = a[i].getValue();\n-        }\n-        final double[] bDouble = new double[b.length];\n-        for (int i = 0; i < b.length; ++i) {\n-            bDouble[i] = b[i].getValue();\n-        }\n-        final double accurateValue = MathArrays.linearCombination(aDouble, bDouble);\n-\n-        // compute a simple value, with all partial derivatives\n-        DerivativeStructure simpleValue = a[0].getField().getZero();\n-        for (int i = 0; i < a.length; ++i) {\n-            simpleValue = simpleValue.add(a[i].multiply(b[i]));\n-        }\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * This method computes the sum of the products\n-     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n-     * It does so by using specific multiplication and addition algorithms to\n-     * preserve accuracy and reduce cancellation effects.\n-     * <br/>\n-     * It is based on the 2005 paper\n-     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n-     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     *\n-     * @param a Factors.\n-     * @param b Factors.\n-     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n-     * @throws DimensionMismatchException if arrays dimensions don't match\n-     */\n-    public static DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n-        throws DimensionMismatchException {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double[] bDouble = new double[b.length];\n-        for (int i = 0; i < b.length; ++i) {\n-            bDouble[i] = b[i].getValue();\n-        }\n-        final double accurateValue = MathArrays.linearCombination(a, bDouble);\n-\n-        // compute a simple value, with all partial derivatives\n-        DerivativeStructure simpleValue = b[0].getField().getZero();\n-        for (int i = 0; i < a.length; ++i) {\n-            simpleValue = simpleValue.add(b[i].multiply(a[i]));\n-        }\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub>\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n-                                                        final DerivativeStructure a2, final DerivativeStructure b2) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n-                                                                  a2.getValue(), b2.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub>\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n-                                                        final double a2, final DerivativeStructure b2) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n-                                                                  a2, b2.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n-                                                        final DerivativeStructure a2, final DerivativeStructure b2,\n-                                                        final DerivativeStructure a3, final DerivativeStructure b3) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n-                                                                  a2.getValue(), b2.getValue(),\n-                                                                  a3.getValue(), b3.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure)\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n-                                                        final double a2, final DerivativeStructure b2,\n-                                                        final double a3, final DerivativeStructure b3) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n-                                                                  a2, b2.getValue(),\n-                                                                  a3, b3.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @param a4 first factor of the third term\n-     * @param b4 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @see #linearCombination(DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n-                                                        final DerivativeStructure a2, final DerivativeStructure b2,\n-                                                        final DerivativeStructure a3, final DerivativeStructure b3,\n-                                                        final DerivativeStructure a4, final DerivativeStructure b4) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n-                                                                  a2.getValue(), b2.getValue(),\n-                                                                  a3.getValue(), b3.getValue(),\n-                                                                  a4.getValue(), b4.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @param a4 first factor of the third term\n-     * @param b4 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure)\n-     * @see #linearCombination(double, DerivativeStructure, double, DerivativeStructure, double, DerivativeStructure)\n-     * @since 3.2\n-     */\n-    public static DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n-                                                        final double a2, final DerivativeStructure b2,\n-                                                        final double a3, final DerivativeStructure b3,\n-                                                        final double a4, final DerivativeStructure b4) {\n-\n-        // compute an accurate value, taking care of cancellations\n-        final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n-                                                                  a2, b2.getValue(),\n-                                                                  a3, b3.getValue(),\n-                                                                  a4, b4.getValue());\n-\n-        // compute a simple value, with all partial derivatives\n-        final DerivativeStructure simpleValue = b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4));\n-\n-        // create a result with accurate value and all derivatives (not necessarily as accurate as the value)\n-        final double[] data = simpleValue.getAllDerivatives();\n-        data[0] = accurateValue;\n-        return new DerivativeStructure(simpleValue.getFreeParameters(), simpleValue.getOrder(), data);\n-\n     }\n \n     /**\n          }\n          return out;\n      }\n+\n+     /** Build an array of elements.\n+      * <p>\n+      * Arrays are filled with field.getZero()\n+      * </p>\n+      * @param <T> the type of the field elements\n+      * @param field field to which array elements belong\n+      * @param length of the array\n+      * @return a new array\n+      */\n+     public static <T> T[] buildArray(final Field<T> field, final int length) {\n+         @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n+         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n+         Arrays.fill(array, field.getZero());\n+         return array;\n+     }\n+\n+     /** Build a double dimension  array of elements.\n+      * <p>\n+      * Arrays are filled with field.getZero()\n+      * </p>\n+      * @param <T> the type of the field elements\n+      * @param field field to which array elements belong\n+      * @param rows number of rows in the array\n+     * @param columns number of columns (may be negative to build partial\n+     * arrays in the same way <code>new Field[rows][]</code> works)\n+      * @return a new array\n+      */\n+     @SuppressWarnings(\"unchecked\")\n+    public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n+         final T[][] array;\n+         if (columns < 0) {\n+             T[] dummyRow = buildArray(field, 0);\n+             array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n+         } else {\n+             array = (T[][]) Array.newInstance(field.getRuntimeClass(),\n+                                               new int[] {\n+                                                   rows, columns\n+                                               });\n+             for (int i = 0; i < rows; ++i) {\n+                 Arrays.fill(array[i], field.getZero());\n+             }\n+         }\n+         return array;\n+     }\n+\n }\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.random.Well1024a;\n import org.apache.commons.math3.util.ArithmeticUtils;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n     }\n \n     @Test\n+    public void testLinearCombination1DSDS() {\n+        final DerivativeStructure[] a = new DerivativeStructure[] {\n+            new DerivativeStructure(6, 1, 0, -1321008684645961.0 / 268435456.0),\n+            new DerivativeStructure(6, 1, 1, -5774608829631843.0 / 268435456.0),\n+            new DerivativeStructure(6, 1, 2, -7645843051051357.0 / 8589934592.0)\n+        };\n+        final DerivativeStructure[] b = new DerivativeStructure[] {\n+            new DerivativeStructure(6, 1, 3, -5712344449280879.0 / 2097152.0),\n+            new DerivativeStructure(6, 1, 4, -4550117129121957.0 / 2097152.0),\n+            new DerivativeStructure(6, 1, 5, 8846951984510141.0 / 131072.0)\n+        };\n+\n+        final DerivativeStructure abSumInline = a[0].linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]);\n+        final DerivativeStructure abSumArray = a[0].linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n+        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n+        Assert.assertEquals(b[0].getValue(), abSumInline.getPartialDerivative(1, 0, 0, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(b[1].getValue(), abSumInline.getPartialDerivative(0, 1, 0, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(b[2].getValue(), abSumInline.getPartialDerivative(0, 0, 1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[0].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[1].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(a[2].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 0, 1), 1.0e-15);\n+\n+    }\n+\n+    @Test\n+    public void testLinearCombination1DoubleDS() {\n+        final double[] a = new double[] {\n+            -1321008684645961.0 / 268435456.0,\n+            -5774608829631843.0 / 268435456.0,\n+            -7645843051051357.0 / 8589934592.0\n+        };\n+        final DerivativeStructure[] b = new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 0, -5712344449280879.0 / 2097152.0),\n+            new DerivativeStructure(3, 1, 1, -4550117129121957.0 / 2097152.0),\n+            new DerivativeStructure(3, 1, 2, 8846951984510141.0 / 131072.0)\n+        };\n+\n+        final DerivativeStructure abSumInline = b[0].linearCombination(a[0], b[0],\n+                                                                       a[1], b[1],\n+                                                                       a[2], b[2]);\n+        final DerivativeStructure abSumArray = b[0].linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n+        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n+        Assert.assertEquals(a[0], abSumInline.getPartialDerivative(1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(a[1], abSumInline.getPartialDerivative(0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(a[2], abSumInline.getPartialDerivative(0, 0, 1), 1.0e-15);\n+\n+    }\n+\n+    @Test\n+    public void testLinearCombination2DSDS() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(0xc6af886975069f11l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final DerivativeStructure[] u = new DerivativeStructure[4];\n+            final DerivativeStructure[] v = new DerivativeStructure[4];\n+            for (int j = 0; j < u.length; ++j) {\n+                u[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n+                v[j] = new DerivativeStructure(u.length, 1, 1e17 * random.nextDouble());\n+            }\n+\n+            DerivativeStructure lin = u[0].linearCombination(u[0], v[0], u[1], v[1]);\n+            double ref = u[0].getValue() * v[0].getValue() +\n+                         u[1].getValue() * v[1].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+\n+            lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n+            ref = u[0].getValue() * v[0].getValue() +\n+                  u[1].getValue() * v[1].getValue() +\n+                  u[2].getValue() * v[2].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+\n+            lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n+            ref = u[0].getValue() * v[0].getValue() +\n+                  u[1].getValue() * v[1].getValue() +\n+                  u[2].getValue() * v[2].getValue() +\n+                  u[3].getValue() * v[3].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+            Assert.assertEquals(v[3].getValue(), lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombination2DoubleDS() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(0xc6af886975069f11l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final double[] u = new double[4];\n+            final DerivativeStructure[] v = new DerivativeStructure[4];\n+            for (int j = 0; j < u.length; ++j) {\n+                u[j] = 1e17 * random.nextDouble();\n+                v[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n+            }\n+\n+            DerivativeStructure lin = v[0].linearCombination(u[0], v[0], u[1], v[1]);\n+            double ref = u[0] * v[0].getValue() +\n+                         u[1] * v[1].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+\n+            lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n+            ref = u[0] * v[0].getValue() +\n+                  u[1] * v[1].getValue() +\n+                  u[2] * v[2].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+\n+            lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n+            ref = u[0] * v[0].getValue() +\n+                  u[1] * v[1].getValue() +\n+                  u[2] * v[2].getValue() +\n+                  u[3] * v[3].getValue();\n+            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n+            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n+            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n+            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n+            Assert.assertEquals(u[3], lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n+\n+        }\n+    }\n+\n+    @Test\n     public void testSerialization() {\n         DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3);\n         DerivativeStructure b = (DerivativeStructure) TestUtils.serializeAndRecover(a);\n--- a/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n+++ b/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n     public void testLog10()\n     {\n \n-        Assert.assertEquals(\"log10 #1\", 1, field.newDfp(\"12\").log10());\n-        Assert.assertEquals(\"log10 #2\", 2, field.newDfp(\"123\").log10());\n-        Assert.assertEquals(\"log10 #3\", 3, field.newDfp(\"1234\").log10());\n-        Assert.assertEquals(\"log10 #4\", 4, field.newDfp(\"12345\").log10());\n-        Assert.assertEquals(\"log10 #5\", 5, field.newDfp(\"123456\").log10());\n-        Assert.assertEquals(\"log10 #6\", 6, field.newDfp(\"1234567\").log10());\n-        Assert.assertEquals(\"log10 #6\", 7, field.newDfp(\"12345678\").log10());\n-        Assert.assertEquals(\"log10 #7\", 8, field.newDfp(\"123456789\").log10());\n-        Assert.assertEquals(\"log10 #8\", 9, field.newDfp(\"1234567890\").log10());\n-        Assert.assertEquals(\"log10 #9\", 10, field.newDfp(\"12345678901\").log10());\n-        Assert.assertEquals(\"log10 #10\", 11, field.newDfp(\"123456789012\").log10());\n-        Assert.assertEquals(\"log10 #11\", 12, field.newDfp(\"1234567890123\").log10());\n-\n-        Assert.assertEquals(\"log10 #12\", 0, field.newDfp(\"2\").log10());\n-        Assert.assertEquals(\"log10 #13\", 0, field.newDfp(\"1\").log10());\n-        Assert.assertEquals(\"log10 #14\", -1, field.newDfp(\"0.12\").log10());\n-        Assert.assertEquals(\"log10 #15\", -2, field.newDfp(\"0.012\").log10());\n+        Assert.assertEquals(\"log10 #1\", 1, field.newDfp(\"12\").intLog10());\n+        Assert.assertEquals(\"log10 #2\", 2, field.newDfp(\"123\").intLog10());\n+        Assert.assertEquals(\"log10 #3\", 3, field.newDfp(\"1234\").intLog10());\n+        Assert.assertEquals(\"log10 #4\", 4, field.newDfp(\"12345\").intLog10());\n+        Assert.assertEquals(\"log10 #5\", 5, field.newDfp(\"123456\").intLog10());\n+        Assert.assertEquals(\"log10 #6\", 6, field.newDfp(\"1234567\").intLog10());\n+        Assert.assertEquals(\"log10 #6\", 7, field.newDfp(\"12345678\").intLog10());\n+        Assert.assertEquals(\"log10 #7\", 8, field.newDfp(\"123456789\").intLog10());\n+        Assert.assertEquals(\"log10 #8\", 9, field.newDfp(\"1234567890\").intLog10());\n+        Assert.assertEquals(\"log10 #9\", 10, field.newDfp(\"12345678901\").intLog10());\n+        Assert.assertEquals(\"log10 #10\", 11, field.newDfp(\"123456789012\").intLog10());\n+        Assert.assertEquals(\"log10 #11\", 12, field.newDfp(\"1234567890123\").intLog10());\n+\n+        Assert.assertEquals(\"log10 #12\", 0, field.newDfp(\"2\").intLog10());\n+        Assert.assertEquals(\"log10 #13\", 0, field.newDfp(\"1\").intLog10());\n+        Assert.assertEquals(\"log10 #14\", -1, field.newDfp(\"0.12\").intLog10());\n+        Assert.assertEquals(\"log10 #15\", -2, field.newDfp(\"0.012\").intLog10());\n     }\n \n     @Test\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDSTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class FieldRotationDSTest {\n+\n+    @Test\n+    public void testIdentity() {\n+\n+        FieldRotation<DerivativeStructure> r = createRotation(1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(-1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(42, 0, 0, 0, true);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+    }\n+\n+    @Test\n+    public void testAxisAngle() throws MathIllegalArgumentException {\n+\n+        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3));\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));\n+        double s = 1 / FastMath.sqrt(3);\n+        checkVector(r.getAxis(), createVector(s, s, s));\n+        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);\n+\n+        try {\n+            new FieldRotation<DerivativeStructure>(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException e) {\n+        }\n+\n+        r = new FieldRotation<DerivativeStructure>(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 0, -1));\n+        checkAngle(r.getAngle(), 0.5 * FastMath.PI);\n+\n+        r = new FieldRotation<DerivativeStructure>(createAxis(0, 1, 0), createAngle(FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 1, 0));\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0));\n+\n+    }\n+\n+    @Test\n+    public void testRevert() {\n+        double a = 0.001;\n+        double b = 0.36;\n+        double c = 0.48;\n+        double d = 0.8;\n+        FieldRotation<DerivativeStructure> r = createRotation(a, b, c, d, true);\n+        double a2 = a * a;\n+        double b2 = b * b;\n+        double c2 = c * c;\n+        double d2 = d * d;\n+        double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2);\n+        Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        FieldRotation<DerivativeStructure> reverted = r.revert();\n+        FieldRotation<DerivativeStructure> rrT = r.applyTo(reverted);\n+        checkRotationDS(rrT, 1, 0, 0, 0);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        FieldRotation<DerivativeStructure> rTr = reverted.applyTo(r);\n+        checkRotationDS(rTr, 1, 0, 0, 0);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);\n+        Assert.assertEquals(-1, r.getAxis().dotProduct(reverted.getAxis()).getReal(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testVectorOnePair() throws MathArithmeticException {\n+\n+        FieldVector3D<DerivativeStructure> u = createVector(3, 2, 1);\n+        FieldVector3D<DerivativeStructure> v = createVector(-4, 2, 2);\n+        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u, v);\n+        checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n+\n+        checkAngle(new FieldRotation<DerivativeStructure>(u, u.negate()).getAngle(), FastMath.PI);\n+\n+        try {\n+            new FieldRotation<DerivativeStructure>(u, createVector(0, 0, 0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testVectorTwoPairs() throws MathArithmeticException {\n+\n+        FieldVector3D<DerivativeStructure> u1 = createVector(3, 0, 0);\n+        FieldVector3D<DerivativeStructure> u2 = createVector(0, 5, 0);\n+        FieldVector3D<DerivativeStructure> v1 = createVector(0, 0, 2);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-2, 0, 2);\n+        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0));\n+\n+        r = new FieldRotation<DerivativeStructure>(u1, u2, u1.negate(), u2.negate());\n+        FieldVector3D<DerivativeStructure> axis = r.getAxis();\n+        if (axis.dotProduct(createVector(0, 0, 1)).getReal() > 0) {\n+            checkVector(axis, createVector(0, 0, 1));\n+        } else {\n+            checkVector(axis, createVector(0, 0, -1));\n+        }\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        double sqrt = FastMath.sqrt(2) / 2;\n+        r = new FieldRotation<DerivativeStructure>(createVector(1, 0, 0),  createVector(0, 1, 0),\n+                           createVector(0.5, 0.5,  sqrt),\n+                           createVector(0.5, 0.5, -sqrt));\n+        checkRotationDS(r, sqrt, 0.5, 0.5, 0);\n+\n+        r = new FieldRotation<DerivativeStructure>(u1, u2, u1, u1.crossProduct(u2));\n+        checkRotationDS(r, sqrt, -sqrt, 0, 0);\n+\n+        checkRotationDS(new FieldRotation<DerivativeStructure>(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+        try {\n+            new FieldRotation<DerivativeStructure>(u1, u2, createVector(0, 0, 0), v2);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMatrix()\n+            throws NotARotationMatrixException {\n+\n+        try {\n+            createRotation(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.445888,  0.797184, -0.407040 },\n+                {  0.821760, -0.184320,  0.539200 },\n+                { -0.354816,  0.574912,  0.737280 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.4,  0.8, -0.4 },\n+                { -0.4,  0.6,  0.7 },\n+                {  0.8, -0.2,  0.5 }\n+            }, 1.0e-15);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.445888,  0.797184, -0.407040 },\n+            { -0.354816,  0.574912,  0.737280 },\n+            {  0.821760, -0.184320,  0.539200 }\n+        }, 1.0e-10),\n+        0.8, 0.288, 0.384, 0.36);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.539200,  0.737280,  0.407040 },\n+            {  0.184320, -0.574912,  0.797184 },\n+            {  0.821760, -0.354816, -0.445888 }\n+        }, 1.0e-10),\n+        0.36, 0.8, 0.288, 0.384);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.445888,  0.797184, -0.407040 },\n+            {  0.354816,  0.574912,  0.737280 },\n+            {  0.821760,  0.184320, -0.539200 }\n+        }, 1.0e-10),\n+        0.384, 0.36, 0.8, 0.288);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.539200,  0.737280,  0.407040 },\n+            { -0.184320, -0.574912,  0.797184 },\n+            {  0.821760,  0.354816,  0.445888 }\n+        }, 1.0e-10),\n+        0.288, 0.384, 0.36, 0.8);\n+\n+        double[][] m1 = { { 0.0, 1.0, 0.0 },\n+            { 0.0, 0.0, 1.0 },\n+            { 1.0, 0.0, 0.0 } };\n+        FieldRotation<DerivativeStructure> r = createRotation(m1, 1.0e-7);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));\n+\n+        double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+            { 0.48293,  0.78164, -0.39474 },\n+            { 0.27296,  0.29396,  0.91602 } };\n+        r = createRotation(m2, 1.0e-12);\n+\n+        DerivativeStructure[][] m3 = r.getMatrix();\n+        double d00 = m2[0][0] - m3[0][0].getReal();\n+        double d01 = m2[0][1] - m3[0][1].getReal();\n+        double d02 = m2[0][2] - m3[0][2].getReal();\n+        double d10 = m2[1][0] - m3[1][0].getReal();\n+        double d11 = m2[1][1] - m3[1][1].getReal();\n+        double d12 = m2[1][2] - m3[1][2].getReal();\n+        double d20 = m2[2][0] - m3[2][0].getReal();\n+        double d21 = m2[2][1] - m3[2][1].getReal();\n+        double d22 = m2[2][2] - m3[2][2].getReal();\n+\n+        Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+        Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);\n+\n+        for (int i = 0; i < 3; ++i) {\n+            for (int j = 0; j < 3; ++j) {\n+                double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() +\n+                               m3[i][1].getReal() * m3[j][1].getReal() +\n+                               m3[i][2].getReal() * m3[j][2].getReal();\n+                if (i == j) {\n+                    Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n+                } else {\n+                    Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n+                }\n+            }\n+        }\n+\n+        checkVector(r.applyTo(createVector(1, 0, 0)),\n+                    new FieldVector3D<DerivativeStructure>(m3[0][0], m3[1][0], m3[2][0]));\n+        checkVector(r.applyTo(createVector(0, 1, 0)),\n+                    new FieldVector3D<DerivativeStructure>(m3[0][1], m3[1][1], m3[2][1]));\n+        checkVector(r.applyTo(createVector(0, 0, 1)),\n+                    new FieldVector3D<DerivativeStructure>(m3[0][2], m3[1][2], m3[2][2]));\n+\n+        double[][] m4 = { { 1.0,  0.0,  0.0 },\n+            { 0.0, -1.0,  0.0 },\n+            { 0.0,  0.0, -1.0 } };\n+        r = createRotation(m4, 1.0e-7);\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        try {\n+            double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 } };\n+            r = createRotation(m5, 1.0e-7);\n+            Assert.fail(\"got \" + r + \", should have caught an exception\");\n+        } catch (NotARotationMatrixException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAngles()\n+            throws CardanEulerSingularityException {\n+\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+                for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+                        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i],\n+                                                      new DerivativeStructure(3, 1, 0, alpha1),\n+                                                      new DerivativeStructure(3, 1, 1, alpha2),\n+                                                      new DerivativeStructure(3, 1, 2, alpha3));\n+                        DerivativeStructure[] angles = r.getAngles(CardanOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+                for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+                        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i],\n+                                                      new DerivativeStructure(3, 1, 0, alpha1),\n+                                                      new DerivativeStructure(3, 1, 1, alpha2),\n+                                                      new DerivativeStructure(3, 1, 2, alpha3));\n+                        DerivativeStructure[] angles = r.getAngles(EulerOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSingularities() {\n+\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (int j = 0; j < singularCardanAngle.length; ++j) {\n+                FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i],\n+                                              new DerivativeStructure(3, 1, 0, 0.1),\n+                                              new DerivativeStructure(3, 1, 1, singularCardanAngle[j]),\n+                                              new DerivativeStructure(3, 1, 2, 0.3));\n+                try {\n+                    r.getAngles(CardanOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        double[] singularEulerAngle = { 0, FastMath.PI };\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (int j = 0; j < singularEulerAngle.length; ++j) {\n+                FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i],\n+                                              new DerivativeStructure(3, 1, 0, 0.1),\n+                                              new DerivativeStructure(3, 1, 1, singularEulerAngle[j]),\n+                                              new DerivativeStructure(3, 1, 2, 0.3));\n+                try {\n+                    r.getAngles(EulerOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testQuaternion() throws MathIllegalArgumentException {\n+\n+        FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7));\n+        double n = 23.5;\n+        FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(r1.getQ0().multiply(n), r1.getQ1().multiply(n),\n+                                       r1.getQ2().multiply(n), r1.getQ3().multiply(n),\n+                                       true);\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<DerivativeStructure> u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(u), r1.applyTo(u));\n+                }\n+            }\n+        }\n+\n+        r1 = createRotation(0.288,  0.384,  0.36,  0.8, false);\n+        checkRotationDS(r1,\n+                        -r1.getQ0().getReal(), -r1.getQ1().getReal(),\n+                        -r1.getQ2().getReal(), -r1.getQ3().getReal());\n+\n+    }\n+\n+    @Test\n+    public void testCompose() throws MathIllegalArgumentException {\n+\n+        FieldRotation<DerivativeStructure> r1       = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7));\n+        FieldRotation<DerivativeStructure> r2       = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3));\n+        FieldRotation<DerivativeStructure> r3       = r2.applyTo(r1);\n+        FieldRotation<DerivativeStructure> r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(),\n+                                                      r1.getQ1().getReal(),\n+                                                      r1.getQ2().getReal(),\n+                                                      r1.getQ3().getReal(),\n+                                                      false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<DerivativeStructure> u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testComposeInverse() throws MathIllegalArgumentException {\n+\n+        FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7));\n+        FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3));\n+        FieldRotation<DerivativeStructure> r3 = r2.applyInverseTo(r1);\n+        FieldRotation<DerivativeStructure> r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(),\n+                                                             r1.getQ1().getReal(),\n+                                                             r1.getQ2().getReal(),\n+                                                             r1.getQ3().getReal(),\n+                                                             false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<DerivativeStructure> u = createVector(x, y, z);\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleVectors() throws MathIllegalArgumentException {\n+\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit = g.nextVector();\n+            FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(unit[0], unit[1], unit[2]),\n+                                          createAngle(random.nextDouble()));\n+\n+            for (double x = -0.9; x < 0.9; x += 0.2) {\n+                for (double y = -0.9; y < 0.9; y += 0.2) {\n+                    for (double z = -0.9; z < 0.9; z += 0.2) {\n+                        FieldVector3D<DerivativeStructure> uds   = createVector(x, y, z);\n+                        FieldVector3D<DerivativeStructure> ruds  = r.applyTo(uds);\n+                        FieldVector3D<DerivativeStructure> rIuds = r.applyInverseTo(uds);\n+                        Vector3D   u     = new Vector3D(x, y, z);\n+                        FieldVector3D<DerivativeStructure> ru    = r.applyTo(u);\n+                        FieldVector3D<DerivativeStructure> rIu   = r.applyInverseTo(u);\n+                        DerivativeStructure[] ruArray = new DerivativeStructure[3];\n+                        r.applyTo(new double[] { x, y, z}, ruArray);\n+                        DerivativeStructure[] rIuArray = new DerivativeStructure[3];\n+                        r.applyInverseTo(new double[] { x, y, z}, rIuArray);\n+                        checkVector(ruds, ru);\n+                        checkVector(ruds, new FieldVector3D<DerivativeStructure>(ruArray));\n+                        checkVector(rIuds, rIu);\n+                        checkVector(rIuds, new FieldVector3D<DerivativeStructure>(rIuArray));\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleRotations() throws MathIllegalArgumentException {\n+\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit1 = g.nextVector();\n+            Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]),\n+                                      random.nextDouble());\n+            FieldRotation<DerivativeStructure> r1Prime = new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, r1.getQ0()),\n+                                                new DerivativeStructure(4, 1, 1, r1.getQ1()),\n+                                                new DerivativeStructure(4, 1, 2, r1.getQ2()),\n+                                                new DerivativeStructure(4, 1, 3, r1.getQ3()),\n+                                                false);\n+            double[] unit2 = g.nextVector();\n+            FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(unit2[0], unit2[1], unit2[2]),\n+                                           createAngle(random.nextDouble()));\n+\n+            FieldRotation<DerivativeStructure> rA = FieldRotation.applyTo(r1, r2);\n+            FieldRotation<DerivativeStructure> rB = r1Prime.applyTo(r2);\n+            FieldRotation<DerivativeStructure> rC = FieldRotation.applyInverseTo(r1, r2);\n+            FieldRotation<DerivativeStructure> rD = r1Prime.applyInverseTo(r2);\n+\n+            for (double x = -0.9; x < 0.9; x += 0.2) {\n+                for (double y = -0.9; y < 0.9; y += 0.2) {\n+                    for (double z = -0.9; z < 0.9; z += 0.2) {\n+\n+                        FieldVector3D<DerivativeStructure> uds   = createVector(x, y, z);\n+                        checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds));\n+                        checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds));\n+                        checkVector(rA.applyTo(uds), rB.applyTo(uds));\n+                        checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds));\n+                        checkVector(rC.applyTo(uds), rD.applyTo(uds));\n+                        checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds));\n+\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDerivatives() {\n+\n+        double eps      = 5.0e-16;\n+        double kx       = 2;\n+        double ky       = -3;\n+        double kz       = 5;\n+        double n2       = kx * kx + ky * ky + kz * kz;\n+        double n        = FastMath.sqrt(n2);\n+        double theta    = 1.7;\n+        double cosTheta = FastMath.cos(theta);\n+        double sinTheta = FastMath.sin(theta);\n+        FieldRotation<DerivativeStructure> r    = new FieldRotation<DerivativeStructure>(createAxis(kx, ky, kz), createAngle(theta));\n+        Vector3D a      = new Vector3D(kx / n, ky / n, kz / n);\n+\n+        // Jacobian of the normalized rotation axis a with respect to the Cartesian vector k\n+        RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] {\n+            { (ky * ky + kz * kz) / ( n * n2),            -kx * ky / ( n * n2),            -kx * kz / ( n * n2) },\n+            {            -kx * ky / ( n * n2), (kx * kx + kz * kz) / ( n * n2),            -ky * kz / ( n * n2) },\n+            {            -kx * kz / ( n * n2),            -ky * kz / ( n * n2), (kx * kx + ky * ky) / ( n * n2) }\n+        });\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3D   u = new Vector3D(x, y, z);\n+                    FieldVector3D<DerivativeStructure> v = r.applyTo(createVector(x, y, z));\n+\n+                    // explicit formula for rotation of vector u around axis a with angle theta\n+                    double dot     = Vector3D.dotProduct(u, a);\n+                    Vector3D cross = Vector3D.crossProduct(a, u);\n+                    double c1      = 1 - cosTheta;\n+                    double c2      = c1 * dot;\n+                    Vector3D rt    = new Vector3D(cosTheta, u, c2, a, sinTheta, cross);\n+                    Assert.assertEquals(rt.getX(), v.getX().getReal(), eps);\n+                    Assert.assertEquals(rt.getY(), v.getY().getReal(), eps);\n+                    Assert.assertEquals(rt.getZ(), v.getZ().getReal(), eps);\n+\n+                    // Jacobian of the image v = r(u) with respect to rotation axis a\n+                    // (analytical differentiation of the explicit formula)\n+                    RealMatrix dvda = MatrixUtils.createRealMatrix(new double[][] {\n+                        { c1 * x * a.getX() + c2,           c1 * y * a.getX() + sinTheta * z, c1 * z * a.getX() - sinTheta * y },\n+                        { c1 * x * a.getY() - sinTheta * z, c1 * y * a.getY() + c2,           c1 * z * a.getY() + sinTheta * x },\n+                        { c1 * x * a.getZ() + sinTheta * y, c1 * y * a.getZ() - sinTheta * x, c1 * z * a.getZ() + c2           }\n+                    });\n+\n+                    // compose Jacobians\n+                    RealMatrix dvdk = dvda.multiply(dadk);\n+\n+                    // derivatives with respect to un-normalized axis\n+                    Assert.assertEquals(dvdk.getEntry(0, 0), v.getX().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(0, 1), v.getX().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(0, 2), v.getX().getPartialDerivative(0, 0, 1, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 0), v.getY().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 1), v.getY().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 2), v.getY().getPartialDerivative(0, 0, 1, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 0), v.getZ().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 1), v.getZ().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 2), v.getZ().getPartialDerivative(0, 0, 1, 0), eps);\n+\n+                    // derivative with respect to rotation angle\n+                    // (analytical differentiation of the explicit formula)\n+                    Vector3D dvdTheta =\n+                            new Vector3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);\n+                    Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps);\n+                    Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps);\n+                    Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps);\n+\n+                }\n+            }\n+        }\n+     }\n+\n+    @Test\n+    public void testArray() throws MathIllegalArgumentException {\n+\n+        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(2, -3, 5), createAngle(1.7));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<DerivativeStructure> u = createVector(x, y, z);\n+                    FieldVector3D<DerivativeStructure> v = r.applyTo(u);\n+                    DerivativeStructure[] out = new DerivativeStructure[3];\n+                    r.applyTo(new DerivativeStructure[] { u.getX(), u.getY(), u.getZ() }, out);\n+                    Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10);\n+                    Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10);\n+                    Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10);\n+                    r.applyInverseTo(out, out);\n+                    Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10);\n+                    Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10);\n+                    Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testApplyInverseTo() throws MathIllegalArgumentException {\n+\n+        DerivativeStructure[] in      = new DerivativeStructure[3];\n+        DerivativeStructure[] out     = new DerivativeStructure[3];\n+        DerivativeStructure[] rebuilt = new DerivativeStructure[3];\n+        FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                r.applyInverseTo(r.applyTo(u));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+                in[0] = u.getX();\n+                in[1] = u.getY();\n+                in[2] = u.getZ();\n+                r.applyTo(in, out);\n+                r.applyInverseTo(out, rebuilt);\n+                Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12);\n+                Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12);\n+                Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12);\n+            }\n+        }\n+\n+        r = createRotation(1, 0, 0, 0, false);\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+        r = new FieldRotation<DerivativeStructure>(createVector(0, 0, 1), createAngle(FastMath.PI));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testIssue639() throws MathArithmeticException{\n+        FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -3822921525525679.0 / 4294967296.0);\n+        FieldVector3D<DerivativeStructure> u2 =createVector( -5712344449280879.0 /    2097152.0,\n+                                   -2275058564560979.0 /    1048576.0,\n+                                   4423475992255071.0 /      65536.0);\n+        FieldRotation<DerivativeStructure> rot = new FieldRotation<DerivativeStructure>(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1));\n+        Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15);\n+        Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15);\n+        Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15);\n+        Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testIssue801() throws MathArithmeticException {\n+        FieldVector3D<DerivativeStructure> u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0);\n+        FieldVector3D<DerivativeStructure> u2 = createVector(0.0, 0.0, 1.0);\n+\n+        FieldVector3D<DerivativeStructure> v1 = createVector(0.9999999999999999, 0.0, 0.0);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(0.0, 0.0, -1.0);\n+\n+        FieldRotation<DerivativeStructure> quat = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2);\n+        double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() +\n+                    quat.getQ1().getReal() * quat.getQ1().getReal() +\n+                    quat.getQ2().getReal() * quat.getQ2().getReal() +\n+                    quat.getQ3().getReal() * quat.getQ3().getReal();\n+        Assert.assertEquals(1.0, q2, 1.0e-14);\n+        Assert.assertEquals(0.0, v1.angle(quat.applyTo(u1)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, v2.angle(quat.applyTo(u2)).getReal(), 1.0e-14);\n+\n+    }\n+\n+    private void checkAngle(DerivativeStructure a1, double a2) {\n+        Assert.assertEquals(a1.getReal(), MathUtils.normalizeAngle(a2, a1.getReal()), 1.0e-10);\n+    }\n+\n+    private void checkRotationDS(FieldRotation<DerivativeStructure> r, double q0, double q1, double q2, double q3) {\n+        FieldRotation<DerivativeStructure> rPrime = createRotation(q0, q1, q2, q3, false);\n+        Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12);\n+    }\n+\n+    private FieldRotation<DerivativeStructure> createRotation(double q0, double q1, double q2, double q3,\n+                                      boolean needsNormalization) {\n+        return new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, q0),\n+                              new DerivativeStructure(4, 1, 1, q1),\n+                              new DerivativeStructure(4, 1, 2, q2),\n+                              new DerivativeStructure(4, 1, 3, q3),\n+                              needsNormalization);\n+    }\n+\n+    private FieldRotation<DerivativeStructure> createRotation(double[][] m, double threshold) {\n+        DerivativeStructure[][] mds = new DerivativeStructure[m.length][m[0].length];\n+        int index = 0;\n+        for (int i = 0; i < m.length; ++i) {\n+            for (int j = 0; j < m[i].length; ++j) {\n+                mds[i][j] = new DerivativeStructure(4, 1, index, m[i][j]);\n+                index = (index + 1) % 4;\n+            }\n+        }\n+        return new FieldRotation<DerivativeStructure>(mds, threshold);\n+    }\n+\n+    private FieldVector3D<DerivativeStructure> createVector(double x, double y, double z) {\n+        return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, x),\n+                              new DerivativeStructure(4, 1, y),\n+                              new DerivativeStructure(4, 1, z));\n+    }\n+\n+    private FieldVector3D<DerivativeStructure> createAxis(double x, double y, double z) {\n+        return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 0, x),\n+                              new DerivativeStructure(4, 1, 1, y),\n+                              new DerivativeStructure(4, 1, 2, z));\n+    }\n+\n+    private DerivativeStructure createAngle(double alpha) {\n+        return new DerivativeStructure(4, 1, 3, alpha);\n+    }\n+\n+    private void checkVector(FieldVector3D<DerivativeStructure> u, FieldVector3D<DerivativeStructure> v) {\n+        Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12);\n+        Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12);\n+        Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDfpTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import org.apache.commons.math3.dfp.Dfp;\n+import org.apache.commons.math3.dfp.DfpField;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class FieldRotationDfpTest {\n+\n+    @Test\n+    public void testIdentity() {\n+\n+        FieldRotation<Dfp> r = createRotation(1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(-1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(42, 0, 0, 0, true);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+    }\n+\n+    @Test\n+    public void testAxisAngle() throws MathIllegalArgumentException {\n+\n+        FieldRotation<Dfp> r = new FieldRotation<Dfp>(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3));\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));\n+        double s = 1 / FastMath.sqrt(3);\n+        checkVector(r.getAxis(), createVector(s, s, s));\n+        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);\n+\n+        try {\n+            new FieldRotation<Dfp>(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException e) {\n+        }\n+\n+        r = new FieldRotation<Dfp>(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 0, -1));\n+        checkAngle(r.getAngle(), 0.5 * FastMath.PI);\n+\n+        r = new FieldRotation<Dfp>(createAxis(0, 1, 0), createAngle(FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 1, 0));\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0));\n+\n+    }\n+\n+    @Test\n+    public void testRevert() {\n+        double a = 0.001;\n+        double b = 0.36;\n+        double c = 0.48;\n+        double d = 0.8;\n+        FieldRotation<Dfp> r = createRotation(a, b, c, d, true);\n+        FieldRotation<Dfp> reverted = r.revert();\n+        FieldRotation<Dfp> rrT = r.applyTo(reverted);\n+        checkRotationDS(rrT, 1, 0, 0, 0);\n+        FieldRotation<Dfp> rTr = reverted.applyTo(r);\n+        checkRotationDS(rTr, 1, 0, 0, 0);\n+        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);\n+        Assert.assertEquals(-1, r.getAxis().dotProduct(reverted.getAxis()).getReal(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testVectorOnePair() throws MathArithmeticException {\n+\n+        FieldVector3D<Dfp> u = createVector(3, 2, 1);\n+        FieldVector3D<Dfp> v = createVector(-4, 2, 2);\n+        FieldRotation<Dfp> r = new FieldRotation<Dfp>(u, v);\n+        checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n+\n+        checkAngle(new FieldRotation<Dfp>(u, u.negate()).getAngle(), FastMath.PI);\n+\n+        try {\n+            new FieldRotation<Dfp>(u, createVector(0, 0, 0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testVectorTwoPairs() throws MathArithmeticException {\n+\n+        FieldVector3D<Dfp> u1 = createVector(3, 0, 0);\n+        FieldVector3D<Dfp> u2 = createVector(0, 5, 0);\n+        FieldVector3D<Dfp> v1 = createVector(0, 0, 2);\n+        FieldVector3D<Dfp> v2 = createVector(-2, 0, 2);\n+        FieldRotation<Dfp> r = new FieldRotation<Dfp>(u1, u2, v1, v2);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0));\n+\n+        r = new FieldRotation<Dfp>(u1, u2, u1.negate(), u2.negate());\n+        FieldVector3D<Dfp> axis = r.getAxis();\n+        if (axis.dotProduct(createVector(0, 0, 1)).getReal() > 0) {\n+            checkVector(axis, createVector(0, 0, 1));\n+        } else {\n+            checkVector(axis, createVector(0, 0, -1));\n+        }\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        double sqrt = FastMath.sqrt(2) / 2;\n+        r = new FieldRotation<Dfp>(createVector(1, 0, 0),  createVector(0, 1, 0),\n+                           createVector(0.5, 0.5,  sqrt),\n+                           createVector(0.5, 0.5, -sqrt));\n+        checkRotationDS(r, sqrt, 0.5, 0.5, 0);\n+\n+        r = new FieldRotation<Dfp>(u1, u2, u1, u1.crossProduct(u2));\n+        checkRotationDS(r, sqrt, -sqrt, 0, 0);\n+\n+        checkRotationDS(new FieldRotation<Dfp>(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+        try {\n+            new FieldRotation<Dfp>(u1, u2, createVector(0, 0, 0), v2);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMatrix()\n+            throws NotARotationMatrixException {\n+\n+        try {\n+            createRotation(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.445888,  0.797184, -0.407040 },\n+                {  0.821760, -0.184320,  0.539200 },\n+                { -0.354816,  0.574912,  0.737280 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.4,  0.8, -0.4 },\n+                { -0.4,  0.6,  0.7 },\n+                {  0.8, -0.2,  0.5 }\n+            }, 1.0e-15);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.445888,  0.797184, -0.407040 },\n+            { -0.354816,  0.574912,  0.737280 },\n+            {  0.821760, -0.184320,  0.539200 }\n+        }, 1.0e-10),\n+        0.8, 0.288, 0.384, 0.36);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.539200,  0.737280,  0.407040 },\n+            {  0.184320, -0.574912,  0.797184 },\n+            {  0.821760, -0.354816, -0.445888 }\n+        }, 1.0e-10),\n+        0.36, 0.8, 0.288, 0.384);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.445888,  0.797184, -0.407040 },\n+            {  0.354816,  0.574912,  0.737280 },\n+            {  0.821760,  0.184320, -0.539200 }\n+        }, 1.0e-10),\n+        0.384, 0.36, 0.8, 0.288);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.539200,  0.737280,  0.407040 },\n+            { -0.184320, -0.574912,  0.797184 },\n+            {  0.821760,  0.354816,  0.445888 }\n+        }, 1.0e-10),\n+        0.288, 0.384, 0.36, 0.8);\n+\n+        double[][] m1 = { { 0.0, 1.0, 0.0 },\n+            { 0.0, 0.0, 1.0 },\n+            { 1.0, 0.0, 0.0 } };\n+        FieldRotation<Dfp> r = createRotation(m1, 1.0e-7);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));\n+\n+        double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+            { 0.48293,  0.78164, -0.39474 },\n+            { 0.27296,  0.29396,  0.91602 } };\n+        r = createRotation(m2, 1.0e-12);\n+\n+        Dfp[][] m3 = r.getMatrix();\n+        double d00 = m2[0][0] - m3[0][0].getReal();\n+        double d01 = m2[0][1] - m3[0][1].getReal();\n+        double d02 = m2[0][2] - m3[0][2].getReal();\n+        double d10 = m2[1][0] - m3[1][0].getReal();\n+        double d11 = m2[1][1] - m3[1][1].getReal();\n+        double d12 = m2[1][2] - m3[1][2].getReal();\n+        double d20 = m2[2][0] - m3[2][0].getReal();\n+        double d21 = m2[2][1] - m3[2][1].getReal();\n+        double d22 = m2[2][2] - m3[2][2].getReal();\n+\n+        Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+        Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);\n+\n+        for (int i = 0; i < 3; ++i) {\n+            for (int j = 0; j < 3; ++j) {\n+                double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() +\n+                               m3[i][1].getReal() * m3[j][1].getReal() +\n+                               m3[i][2].getReal() * m3[j][2].getReal();\n+                if (i == j) {\n+                    Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n+                } else {\n+                    Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n+                }\n+            }\n+        }\n+\n+        checkVector(r.applyTo(createVector(1, 0, 0)),\n+                    new FieldVector3D<Dfp>(m3[0][0], m3[1][0], m3[2][0]));\n+        checkVector(r.applyTo(createVector(0, 1, 0)),\n+                    new FieldVector3D<Dfp>(m3[0][1], m3[1][1], m3[2][1]));\n+        checkVector(r.applyTo(createVector(0, 0, 1)),\n+                    new FieldVector3D<Dfp>(m3[0][2], m3[1][2], m3[2][2]));\n+\n+        double[][] m4 = { { 1.0,  0.0,  0.0 },\n+            { 0.0, -1.0,  0.0 },\n+            { 0.0,  0.0, -1.0 } };\n+        r = createRotation(m4, 1.0e-7);\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        try {\n+            double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 } };\n+            r = createRotation(m5, 1.0e-7);\n+            Assert.fail(\"got \" + r + \", should have caught an exception\");\n+        } catch (NotARotationMatrixException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAngles()\n+            throws CardanEulerSingularityException {\n+\n+        DfpField field = new DfpField(15);\n+\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 2.0) {\n+                for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.8) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 2.0) {\n+                        FieldRotation<Dfp> r = new FieldRotation<Dfp>(CardanOrders[i],\n+                                                                      field.newDfp(alpha1),\n+                                                                      field.newDfp(alpha2),\n+                                                                      field.newDfp(alpha3));\n+                        Dfp[] angles = r.getAngles(CardanOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 2.0) {\n+                for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.8) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 2.0) {\n+                        FieldRotation<Dfp> r = new FieldRotation<Dfp>(EulerOrders[i],\n+                                                                      field.newDfp(alpha1),\n+                                                                      field.newDfp(alpha2),\n+                                                                      field.newDfp(alpha3));\n+                        Dfp[] angles = r.getAngles(EulerOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSingularities() {\n+\n+        DfpField field = new DfpField(20);\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (int j = 0; j < singularCardanAngle.length; ++j) {\n+                FieldRotation<Dfp> r = new FieldRotation<Dfp>(CardanOrders[i],\n+                                                              field.newDfp(0.1),\n+                                                              field.newDfp(singularCardanAngle[j]),\n+                                                              field.newDfp(0.3));\n+                try {\n+                    r.getAngles(CardanOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        double[] singularEulerAngle = { 0, FastMath.PI };\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (int j = 0; j < singularEulerAngle.length; ++j) {\n+                FieldRotation<Dfp> r = new FieldRotation<Dfp>(EulerOrders[i],\n+                                                              field.newDfp(0.1),\n+                                                              field.newDfp(singularEulerAngle[j]),\n+                                                              field.newDfp(0.3));\n+                try {\n+                    r.getAngles(EulerOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testQuaternion() throws MathIllegalArgumentException {\n+\n+        FieldRotation<Dfp> r1 = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7));\n+        double n = 23.5;\n+        FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(r1.getQ0().multiply(n), r1.getQ1().multiply(n),\n+                                       r1.getQ2().multiply(n), r1.getQ3().multiply(n),\n+                                       true);\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<Dfp> u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(u), r1.applyTo(u));\n+                }\n+            }\n+        }\n+\n+        r1 = createRotation(0.288,  0.384,  0.36,  0.8, false);\n+        checkRotationDS(r1,\n+                        -r1.getQ0().getReal(), -r1.getQ1().getReal(),\n+                        -r1.getQ2().getReal(), -r1.getQ3().getReal());\n+\n+    }\n+\n+    @Test\n+    public void testCompose() throws MathIllegalArgumentException {\n+\n+        FieldRotation<Dfp> r1       = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7));\n+        FieldRotation<Dfp> r2       = new FieldRotation<Dfp>(createVector(-1, 3, 2), createAngle(0.3));\n+        FieldRotation<Dfp> r3       = r2.applyTo(r1);\n+        FieldRotation<Dfp> r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(),\n+                                                      r1.getQ1().getReal(),\n+                                                      r1.getQ2().getReal(),\n+                                                      r1.getQ3().getReal(),\n+                                                      false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<Dfp> u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testComposeInverse() throws MathIllegalArgumentException {\n+\n+        FieldRotation<Dfp> r1 = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7));\n+        FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(createVector(-1, 3, 2), createAngle(0.3));\n+        FieldRotation<Dfp> r3 = r2.applyInverseTo(r1);\n+        FieldRotation<Dfp> r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(),\n+                                                             r1.getQ1().getReal(),\n+                                                             r1.getQ2().getReal(),\n+                                                             r1.getQ3().getReal(),\n+                                                             false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<Dfp> u = createVector(x, y, z);\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleVectors() throws MathIllegalArgumentException {\n+\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit = g.nextVector();\n+            FieldRotation<Dfp> r = new FieldRotation<Dfp>(createVector(unit[0], unit[1], unit[2]),\n+                                          createAngle(random.nextDouble()));\n+\n+            for (double x = -0.9; x < 0.9; x += 0.4) {\n+                for (double y = -0.9; y < 0.9; y += 0.4) {\n+                    for (double z = -0.9; z < 0.9; z += 0.4) {\n+                        FieldVector3D<Dfp> uds   = createVector(x, y, z);\n+                        FieldVector3D<Dfp> ruds  = r.applyTo(uds);\n+                        FieldVector3D<Dfp> rIuds = r.applyInverseTo(uds);\n+                        Vector3D   u     = new Vector3D(x, y, z);\n+                        FieldVector3D<Dfp> ru    = r.applyTo(u);\n+                        FieldVector3D<Dfp> rIu   = r.applyInverseTo(u);\n+                        Dfp[] ruArray = new Dfp[3];\n+                        r.applyTo(new double[] { x, y, z}, ruArray);\n+                        Dfp[] rIuArray = new Dfp[3];\n+                        r.applyInverseTo(new double[] { x, y, z}, rIuArray);\n+                        checkVector(ruds, ru);\n+                        checkVector(ruds, new FieldVector3D<Dfp>(ruArray));\n+                        checkVector(rIuds, rIu);\n+                        checkVector(rIuds, new FieldVector3D<Dfp>(rIuArray));\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleRotations() throws MathIllegalArgumentException {\n+\n+        DfpField field = new DfpField(20);\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit1 = g.nextVector();\n+            Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]),\n+                                      random.nextDouble());\n+            FieldRotation<Dfp> r1Prime = new FieldRotation<Dfp>(field.newDfp(r1.getQ0()),\n+                                                                field.newDfp(r1.getQ1()),\n+                                                                field.newDfp(r1.getQ2()),\n+                                                                field.newDfp(r1.getQ3()),\n+                                                                false);\n+            double[] unit2 = g.nextVector();\n+            FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(createVector(unit2[0], unit2[1], unit2[2]),\n+                                           createAngle(random.nextDouble()));\n+\n+            FieldRotation<Dfp> rA = FieldRotation.applyTo(r1, r2);\n+            FieldRotation<Dfp> rB = r1Prime.applyTo(r2);\n+            FieldRotation<Dfp> rC = FieldRotation.applyInverseTo(r1, r2);\n+            FieldRotation<Dfp> rD = r1Prime.applyInverseTo(r2);\n+\n+            for (double x = -0.9; x < 0.9; x += 0.4) {\n+                for (double y = -0.9; y < 0.9; y += 0.4) {\n+                    for (double z = -0.9; z < 0.9; z += 0.4) {\n+\n+                        FieldVector3D<Dfp> uds   = createVector(x, y, z);\n+                        checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds));\n+                        checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds));\n+                        checkVector(rA.applyTo(uds), rB.applyTo(uds));\n+                        checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds));\n+                        checkVector(rC.applyTo(uds), rD.applyTo(uds));\n+                        checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds));\n+\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testArray() throws MathIllegalArgumentException {\n+\n+        FieldRotation<Dfp> r = new FieldRotation<Dfp>(createAxis(2, -3, 5), createAngle(1.7));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    FieldVector3D<Dfp> u = createVector(x, y, z);\n+                    FieldVector3D<Dfp> v = r.applyTo(u);\n+                    Dfp[] out = new Dfp[3];\n+                    r.applyTo(new Dfp[] { u.getX(), u.getY(), u.getZ() }, out);\n+                    Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10);\n+                    Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10);\n+                    Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10);\n+                    r.applyInverseTo(out, out);\n+                    Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10);\n+                    Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10);\n+                    Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testApplyInverseTo() throws MathIllegalArgumentException {\n+\n+        Dfp[] in      = new Dfp[3];\n+        Dfp[] out     = new Dfp[3];\n+        Dfp[] rebuilt = new Dfp[3];\n+        FieldRotation<Dfp> r = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                r.applyInverseTo(r.applyTo(u));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+                in[0] = u.getX();\n+                in[1] = u.getY();\n+                in[2] = u.getZ();\n+                r.applyTo(in, out);\n+                r.applyInverseTo(out, rebuilt);\n+                Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12);\n+                Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12);\n+                Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12);\n+            }\n+        }\n+\n+        r = createRotation(1, 0, 0, 0, false);\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+        r = new FieldRotation<Dfp>(createVector(0, 0, 1), createAngle(FastMath.PI));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testIssue639() throws MathArithmeticException{\n+        FieldVector3D<Dfp> u1 = createVector(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -3822921525525679.0 / 4294967296.0);\n+        FieldVector3D<Dfp> u2 =createVector( -5712344449280879.0 /    2097152.0,\n+                                   -2275058564560979.0 /    1048576.0,\n+                                   4423475992255071.0 /      65536.0);\n+        FieldRotation<Dfp> rot = new FieldRotation<Dfp>(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1));\n+        Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15);\n+        Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15);\n+        Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15);\n+        Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testIssue801() throws MathArithmeticException {\n+        FieldVector3D<Dfp> u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0);\n+        FieldVector3D<Dfp> u2 = createVector(0.0, 0.0, 1.0);\n+\n+        FieldVector3D<Dfp> v1 = createVector(0.9999999999999999, 0.0, 0.0);\n+        FieldVector3D<Dfp> v2 = createVector(0.0, 0.0, -1.0);\n+\n+        FieldRotation<Dfp> quat = new FieldRotation<Dfp>(u1, u2, v1, v2);\n+        double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() +\n+                    quat.getQ1().getReal() * quat.getQ1().getReal() +\n+                    quat.getQ2().getReal() * quat.getQ2().getReal() +\n+                    quat.getQ3().getReal() * quat.getQ3().getReal();\n+        Assert.assertEquals(1.0, q2, 1.0e-14);\n+        Assert.assertEquals(0.0, v1.angle(quat.applyTo(u1)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, v2.angle(quat.applyTo(u2)).getReal(), 1.0e-14);\n+\n+    }\n+\n+    private void checkAngle(Dfp a1, double a2) {\n+        Assert.assertEquals(a1.getReal(), MathUtils.normalizeAngle(a2, a1.getReal()), 1.0e-10);\n+    }\n+\n+    private void checkRotationDS(FieldRotation<Dfp> r, double q0, double q1, double q2, double q3) {\n+        FieldRotation<Dfp> rPrime = createRotation(q0, q1, q2, q3, false);\n+        Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12);\n+    }\n+\n+    private FieldRotation<Dfp> createRotation(double q0, double q1, double q2, double q3,\n+                                      boolean needsNormalization) {\n+        DfpField field = new DfpField(20);\n+        return new FieldRotation<Dfp>(field.newDfp(q0),\n+                                      field.newDfp(q1),\n+                                      field.newDfp(q2),\n+                                      field.newDfp(q3),\n+                                      needsNormalization);\n+    }\n+\n+    private FieldRotation<Dfp> createRotation(double[][] m, double threshold) {\n+        DfpField field = new DfpField(20);\n+        Dfp[][] mds = new Dfp[m.length][m[0].length];\n+        for (int i = 0; i < m.length; ++i) {\n+            for (int j = 0; j < m[i].length; ++j) {\n+                mds[i][j] = field.newDfp(m[i][j]);\n+            }\n+        }\n+        return new FieldRotation<Dfp>(mds, threshold);\n+    }\n+\n+    private FieldVector3D<Dfp> createVector(double x, double y, double z) {\n+        DfpField field = new DfpField(20);\n+        return new FieldVector3D<Dfp>(field.newDfp(x), field.newDfp(y), field.newDfp(z));\n+    }\n+\n+    private FieldVector3D<Dfp> createAxis(double x, double y, double z) {\n+        DfpField field = new DfpField(20);\n+        return new FieldVector3D<Dfp>(field.newDfp(x), field.newDfp(y), field.newDfp(z));\n+    }\n+\n+    private Dfp createAngle(double alpha) {\n+        return new DfpField(20).newDfp(alpha);\n+    }\n+\n+    private void checkVector(FieldVector3D<Dfp> u, FieldVector3D<Dfp> v) {\n+        Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12);\n+        Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12);\n+        Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3DTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class FieldVector3DTest {\n+\n+    @Test\n+    public void testConstructors() throws DimensionMismatchException {\n+        double cosAlpha = 1 / 2.0;\n+        double sinAlpha = FastMath.sqrt(3) / 2.0;\n+        double cosDelta = FastMath.sqrt(2) / 2.0;\n+        double sinDelta = -FastMath.sqrt(2) / 2.0;\n+        FieldVector3D<DerivativeStructure> u = new FieldVector3D<DerivativeStructure>(2,\n+                new FieldVector3D<DerivativeStructure>(new DerivativeStructure(2, 1, 0,  FastMath.PI / 3),\n+                        new DerivativeStructure(2, 1, 1, -FastMath.PI / 4)));\n+        checkVector(u, 2 * cosAlpha * cosDelta, 2 * sinAlpha * cosDelta, 2 * sinDelta);\n+        Assert.assertEquals(-2 * sinAlpha * cosDelta, u.getX().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(+2 * cosAlpha * cosDelta, u.getY().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(0,                        u.getZ().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(-2 * cosAlpha * sinDelta, u.getX().getPartialDerivative(0, 1), 1.0e-12);\n+        Assert.assertEquals(-2 * sinAlpha * sinDelta, u.getY().getPartialDerivative(0, 1), 1.0e-12);\n+        Assert.assertEquals(2 * cosDelta,             u.getZ().getPartialDerivative(0, 1), 1.0e-12);\n+\n+        checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0,  0, 3)),\n+                                   2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4)),\n+                                   2, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0)),\n+                                   2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0);\n+\n+        checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0,  0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 0, 3, -1, 0, 0, 0, -1, 0, 0, 0, -1);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 0, 3, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, -1, -1);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);\n+\n+        checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3),\n+                                   5, createVector(0, 1, 0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 5, 3, 4, 0, 0, 0, 4, 0, 0, 0, 4);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, 1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 5, 3, 4, 0, 0, 1, 0, 4, 0, 1, 0, 0, 4, -1);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, 1,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 5, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1);\n+\n+        checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3),\n+                                   5, createVector(0, 1, 0, 3),\n+                                   5, createVector(0, -1, 0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 0, 3, 9, 0, 0, 0, 9, 0, 0, 0, 9);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, 1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, -1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 0, 3, 9, 0, 0, 1, 0, 9, 0, 0, 0, 0, 9, -1);\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, 1,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, -1,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);\n+\n+        checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 2,  2),\n+            new DerivativeStructure(3, 1, 1,  5),\n+            new DerivativeStructure(3, 1, 0, -3)\n+        }),\n+        2, 5, -3, 0, 0, 1, 0, 1, 0, 1, 0, 0);\n+\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        FieldVector3D<DerivativeStructure> u1 = createVector(1, 2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v  = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3);\n+        Assert.assertTrue(u1.equals(u1));\n+        Assert.assertTrue(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                   new DerivativeStructure(3, 1, 1, 2.0),\n+                                                   new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 1.0),\n+                                                    new DerivativeStructure(3, 1, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                    new DerivativeStructure(3, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                    new DerivativeStructure(3, 1, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 3.0))));\n+        Assert.assertFalse(u1.equals(v));\n+        Assert.assertFalse(u1.equals(u1.toVector3D()));\n+        Assert.assertTrue(createVector(0, Double.NaN, 0, 3).equals(createVector(0, 0, Double.NaN, 3)));\n+    }\n+\n+    @Test\n+    public void testHash() {\n+        Assert.assertEquals(createVector(0, Double.NaN, 0, 3).hashCode(), createVector(0, 0, Double.NaN, 3).hashCode());\n+        FieldVector3D<DerivativeStructure> u = createVector(1, 2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3);\n+        Assert.assertTrue(u.hashCode() != v.hashCode());\n+    }\n+\n+    @Test\n+    public void testInfinite() {\n+        Assert.assertTrue(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isInfinite());\n+        Assert.assertTrue(createVector(1, Double.NEGATIVE_INFINITY, 1, 3).isInfinite());\n+        Assert.assertTrue(createVector(Double.NEGATIVE_INFINITY, 1, 1, 3).isInfinite());\n+        Assert.assertFalse(createVector(1, 1, 2, 3).isInfinite());\n+        Assert.assertFalse(createVector(1, Double.NaN, Double.NEGATIVE_INFINITY, 3).isInfinite());\n+    }\n+\n+    @Test\n+    public void testNaN() {\n+        Assert.assertTrue(createVector(1, 1, Double.NaN, 3).isNaN());\n+        Assert.assertTrue(createVector(1, Double.NaN, 1, 3).isNaN());\n+        Assert.assertTrue(createVector(Double.NaN, 1, 1, 3).isNaN());\n+        Assert.assertFalse(createVector(1, 1, 2, 3).isNaN());\n+        Assert.assertFalse(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isNaN());\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        Assert.assertEquals(\"{3; 2; 1}\", createVector(3, 2, 1, 3).toString());\n+        NumberFormat format = new DecimalFormat(\"0.000\", new DecimalFormatSymbols(Locale.US));\n+        Assert.assertEquals(\"{3.000; 2.000; 1.000}\", createVector(3, 2, 1, 3).toString(format));\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testWrongDimension() throws DimensionMismatchException {\n+        new FieldVector3D<DerivativeStructure>(new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 0, 2),\n+            new DerivativeStructure(3, 1, 0, 5)\n+        });\n+    }\n+\n+    @Test\n+    public void testCoordinates() {\n+        FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3, 3);\n+        Assert.assertTrue(FastMath.abs(v.getX().getReal() - 1) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getY().getReal() - 2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getZ().getReal() - 3) < 1.0e-12);\n+        DerivativeStructure[] coordinates = v.toArray();\n+        Assert.assertTrue(FastMath.abs(coordinates[0].getReal() - 1) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(coordinates[1].getReal() - 2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(coordinates[2].getReal() - 3) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testNorm1() {\n+        Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNorm1().getReal(), 0);\n+        Assert.assertEquals( 6.0, createVector(1, -2, 3, 3).getNorm1().getReal(), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNorm() {\n+        double r = FastMath.sqrt(14);\n+        Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNorm().getReal(), 0);\n+        Assert.assertEquals(r, createVector(1, 2, 3, 3).getNorm().getReal(), 1.0e-12);\n+        Assert.assertEquals( 1.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 2.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 3.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNormSq() {\n+        Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNormSq().getReal(), 0);\n+        Assert.assertEquals(14, createVector(1, 2, 3, 3).getNormSq().getReal(), 1.0e-12);\n+        Assert.assertEquals( 2, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 4, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 6, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNormInf() {\n+        Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 3.0, createVector(1, -2, 3, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(2, -1, 3, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(1, -3, 2, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(2, -3, 1, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(3, -1, 2, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 1.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(3, -2, 1, 3).getNormInf().getReal(), 0);\n+        Assert.assertEquals( 1.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testDistance1() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distance1(createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = v1.distance1(v2);\n+        Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = v1.distance1(new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistance() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distance(createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = v1.distance(v2);\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = v1.distance(new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);\n+        Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistanceSq() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distanceSq(createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distanceSq = v1.distanceSq(v2);\n+        Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distanceSq = v1.distanceSq(new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);\n+        Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testDistanceInf() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distanceInf(createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = v1.distanceInf(v2);\n+        Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = v1.distanceInf(new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNormInf().getReal(), v1.distanceInf(v2).getReal(), 1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            createVector( 1, -2, 3, 3).distanceInf(createVector(-4,  2, 0, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector( 1, 3, -2, 3).distanceInf(createVector(-4, 0,  2, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(-2,  1, 3, 3).distanceInf(createVector( 2, -4, 0, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(-2, 3,  1, 3).distanceInf(createVector( 2, 0, -4, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(3, -2,  1, 3).distanceInf(createVector(0,  2, -4, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(3,  1, -2, 3).distanceInf(createVector(0, -4,  2, 3)).getReal(),\n+                            1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            createVector( 1, -2, 3, 3).distanceInf(new Vector3D(-4,  2, 0)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector( 1, 3, -2, 3).distanceInf(new Vector3D(-4, 0,  2)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(-2,  1, 3, 3).distanceInf(new Vector3D( 2, -4, 0)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(-2, 3,  1, 3).distanceInf(new Vector3D( 2, 0, -4)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(3, -2,  1, 3).distanceInf(new Vector3D(0,  2, -4)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            createVector(3,  1, -2, 3).distanceInf(new Vector3D(0, -4,  2)).getReal(),\n+                            1.0e-12);\n+\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, 2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-3, -2, -1, 3);\n+        v1 = v1.subtract(v2);\n+        checkVector(v1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+\n+        checkVector(v2.subtract(v1), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(new Vector3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(3, v1), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(3, new Vector3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Vector3D(4, 4, 4)),\n+                    -15, -14, -13, 1, 0, -4, 0, 1, -4, 0, 0, -3);\n+\n+        checkVector(createVector(1, 2, 3, 4).subtract(new DerivativeStructure(4, 1, 3, 5.0),\n+                                                      createVector(3, -2, 1, 4)),\n+                    -14, 12, -2,\n+                     -4,  0,  0, -3,\n+                      0, -4,  0,  2,\n+                      0,  0, -4, -1);\n+\n+    }\n+\n+    @Test\n+    public void testAdd() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(1, 2, 3, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(-3, -2, -1, 3);\n+        v1 = v1.add(v2);\n+        checkVector(v1, -2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2);\n+\n+        checkVector(v2.add(v1), -5, -2, 1, 3, 0, 0, 0, 3, 0, 0, 0, 3);\n+        checkVector(v2.add(new Vector3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.add(3, v1), -9, -2, 5, 7, 0, 0, 0, 7, 0, 0, 0, 7);\n+        checkVector(v2.add(3, new Vector3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Vector3D(-2, 0, 2)),\n+                    -9, -2, 5, 1, 0, -2, 0, 1, 0, 0, 0, 3);\n+\n+        checkVector(createVector(1, 2, 3, 4).add(new DerivativeStructure(4, 1, 3, 5.0),\n+                                                 createVector(3, -2, 1, 4)),\n+                    16, -8,  8,\n+                     6,  0,  0,  3,\n+                     0,  6,  0, -2,\n+                     0,  0,  6,  1);\n+\n+    }\n+\n+    @Test\n+    public void testScalarProduct() {\n+        FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3, 3);\n+        v = v.scalarMultiply(3);\n+        checkVector(v, 3, 6, 9);\n+\n+        checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);\n+    }\n+\n+    @Test\n+    public void testVectorialProducts() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(2, 1, -4, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(3, 1, -1, 3);\n+\n+        Assert.assertTrue(FastMath.abs(v1.dotProduct(v2).getReal() - 11) < 1.0e-12);\n+\n+        FieldVector3D<DerivativeStructure> v3 = v1.crossProduct(v2);\n+        checkVector(v3, 3, -10, -1);\n+\n+        Assert.assertTrue(FastMath.abs(v1.dotProduct(v3).getReal()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v2.dotProduct(v3).getReal()) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testCrossProductCancellation() {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(9070467121.0, 4535233560.0, 1, 3);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(9070467123.0, 4535233561.0, 1, 3);\n+        checkVector(v1.crossProduct(v2), -1, 2, 1);\n+\n+        double scale    = FastMath.scalb(1.0, 100);\n+        FieldVector3D<DerivativeStructure> big1   = new FieldVector3D<DerivativeStructure>(scale, v1);\n+        FieldVector3D<DerivativeStructure> small2 = new FieldVector3D<DerivativeStructure>(1 / scale, v2);\n+        checkVector(big1.crossProduct(small2), -1, 2, 1);\n+\n+    }\n+\n+    @Test\n+    public void testAngular() {\n+        Assert.assertEquals(0,           createVector(1, 0, 0, 3).getAlpha().getReal(), 1.0e-10);\n+        Assert.assertEquals(0,           createVector(1, 0, 0, 3).getDelta().getReal(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, createVector(0, 1, 0, 3).getAlpha().getReal(), 1.0e-10);\n+        Assert.assertEquals(0,           createVector(0, 1, 0, 3).getDelta().getReal(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, createVector(0, 0, 1, 3).getDelta().getReal(), 1.0e-10);\n+      \n+        FieldVector3D<DerivativeStructure> u = createVector(-1, 1, -1, 3);\n+        Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha().getReal(), 1.0e-10);\n+        Assert.assertEquals(-1.0 / FastMath.sqrt(3), u.getDelta().sin().getReal(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testAngularSeparation() throws MathArithmeticException {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(2, -1, 4, 3);\n+\n+        FieldVector3D<DerivativeStructure>  k = v1.normalize();\n+        FieldVector3D<DerivativeStructure>  i = k.orthogonal();\n+        FieldVector3D<DerivativeStructure> v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));\n+\n+        Assert.assertTrue(FastMath.abs(v1.angle(v2).getReal() - 1.2) < 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testNormalize() throws MathArithmeticException {\n+        Assert.assertEquals(1.0, createVector(5, -4, 2, 3).normalize().getNorm().getReal(), 1.0e-12);\n+        try {\n+            createVector(0, 0, 0, 3).normalize();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testNegate() {\n+        checkVector(createVector(0.1, 2.5, 1.3, 3).negate(),\n+                    -0.1, -2.5, -1.3, -1, 0, 0, 0, -1, 0, 0, 0, -1);\n+    }\n+\n+    @Test\n+    public void testOrthogonal() throws MathArithmeticException {\n+        FieldVector3D<DerivativeStructure> v1 = createVector(0.1, 2.5, 1.3, 3);\n+        Assert.assertEquals(0.0, v1.dotProduct(v1.orthogonal()).getReal(), 1.0e-12);\n+        FieldVector3D<DerivativeStructure> v2 = createVector(2.3, -0.003, 7.6, 3);\n+        Assert.assertEquals(0.0, v2.dotProduct(v2.orthogonal()).getReal(), 1.0e-12);\n+        FieldVector3D<DerivativeStructure> v3 = createVector(-1.7, 1.4, 0.2, 3);\n+        Assert.assertEquals(0.0, v3.dotProduct(v3.orthogonal()).getReal(), 1.0e-12);\n+        FieldVector3D<DerivativeStructure> v4 = createVector(4.2, 0.1, -1.8, 3);\n+        Assert.assertEquals(0.0, v4.dotProduct(v4.orthogonal()).getReal(), 1.0e-12);\n+        try {\n+            createVector(0, 0, 0, 3).orthogonal();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAngle() throws MathArithmeticException {\n+        Assert.assertEquals(0.22572612855273393616,\n+                            createVector(1, 2, 3, 3).angle(createVector(4, 5, 6, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(7.98595620686106654517199e-8,\n+                            createVector(1, 2, 3, 3).angle(createVector(2, 4, 6.000001, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(3.14159257373023116985197793156,\n+                            createVector(1, 2, 3, 3).angle(createVector(-2, -4, -6.000001, 3)).getReal(),\n+                            1.0e-12);\n+        try {\n+            createVector(0, 0, 0, 3).angle(createVector(1, 0, 0, 3));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAccurateDotProduct() {\n+        // the following two vectors are nearly but not exactly orthogonal\n+        // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of 0.0, instead of the correct -1.855129...\n+        FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -7645843051051357.0 / 8589934592.0, 3);\n+        FieldVector3D<DerivativeStructure> u2 = createVector(-5712344449280879.0 /    2097152.0,\n+                                   -4550117129121957.0 /    2097152.0,\n+                                    8846951984510141.0 /     131072.0, 3);\n+        DerivativeStructure sNaive = u1.getX().multiply(u2.getX()).add(u1.getY().multiply(u2.getY())).add(u1.getZ().multiply(u2.getZ()));\n+        DerivativeStructure sAccurate = u1.dotProduct(u2);\n+        Assert.assertEquals(0.0, sNaive.getReal(), 1.0e-30);\n+        Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate.getReal(), 1.0e-16);\n+    }\n+\n+    @Test\n+    public void testDotProduct() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(553267312521321234l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = 10000 * random.nextDouble();\n+            double uy = 10000 * random.nextDouble();\n+            double uz = 10000 * random.nextDouble();\n+            double vx = 10000 * random.nextDouble();\n+            double vy = 10000 * random.nextDouble();\n+            double vz = 10000 * random.nextDouble();\n+            double sNaive = ux * vx + uy * vy + uz * vz;\n+\n+            FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3);\n+            FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);\n+            Vector3D v = new Vector3D(vx, vy, vz);\n+\n+            DerivativeStructure sAccurate = uds.dotProduct(vds);\n+            Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive);\n+            Assert.assertEquals(ux + vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(uy + vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(uz + vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n+\n+            sAccurate = uds.dotProduct(v);\n+            Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testAccurateCrossProduct() {\n+        // the vectors u1 and u2 are nearly but not exactly anti-parallel\n+        // (7.31e-16 degrees from 180 degrees) naive cross product (i.e.\n+        // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of   [0.0009765, -0.0001220, -0.0039062],\n+        // instead of the correct [0.0006913, -0.0001254, -0.0007909]\n+        final FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 /   268435456.0,\n+                                         -5774608829631843.0 /   268435456.0,\n+                                         -7645843051051357.0 /  8589934592.0, 3);\n+        final FieldVector3D<DerivativeStructure> u2 = createVector( 1796571811118507.0 /  2147483648.0,\n+                                          7853468008299307.0 /  2147483648.0,\n+                                          2599586637357461.0 / 17179869184.0, 3);\n+        final FieldVector3D<DerivativeStructure> u3 = createVector(12753243807587107.0 / 18446744073709551616.0, \n+                                         -2313766922703915.0 / 18446744073709551616.0, \n+                                          -227970081415313.0 /   288230376151711744.0, 3);\n+        FieldVector3D<DerivativeStructure> cNaive = new FieldVector3D<DerivativeStructure>(u1.getY().multiply(u2.getZ()).subtract(u1.getZ().multiply(u2.getY())),\n+                                       u1.getZ().multiply(u2.getX()).subtract(u1.getX().multiply(u2.getZ())),\n+                                       u1.getX().multiply(u2.getY()).subtract(u1.getY().multiply(u2.getX())));\n+        FieldVector3D<DerivativeStructure> cAccurate = u1.crossProduct(u2);\n+        Assert.assertTrue(u3.distance(cNaive).getReal() > 2.9 * u3.getNorm().getReal());\n+        Assert.assertEquals(0.0, u3.distance(cAccurate).getReal(), 1.0e-30 * cAccurate.getNorm().getReal());\n+    }\n+\n+    @Test\n+    public void testCrossProduct() {\n+        // we compare accurate versus naive cross product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(885362227452043214l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = random.nextDouble();\n+            double uy = random.nextDouble();\n+            double uz = random.nextDouble();\n+            double vx = random.nextDouble();\n+            double vy = random.nextDouble();\n+            double vz = random.nextDouble();\n+            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);\n+\n+            FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3);\n+            FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);\n+            Vector3D v = new Vector3D(vx, vy, vz);\n+\n+            checkVector(uds.crossProduct(vds),\n+                        cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n+                        0, vz - uz, uy - vy,\n+                        uz - vz, 0, vx - ux,\n+                        vy - uy, ux - vx, 0);\n+\n+            checkVector(uds.crossProduct(v),\n+                        cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n+                          0,  vz, -vy,\n+                        -vz,   0,  vx,\n+                         vy, -vx,   0);\n+\n+        }\n+    }\n+\n+    private FieldVector3D<DerivativeStructure> createVector(double x, double y, double z, int params) {\n+        return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(params, 1, 0, x),\n+                              new DerivativeStructure(params, 1, 1, y),\n+                              new DerivativeStructure(params, 1, 2, z));\n+    }\n+\n+    private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z) {\n+        Assert.assertEquals(x, v.getX().getReal(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getReal(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12);\n+    }\n+\n+    private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z,\n+                             double dxdx, double dxdy, double dxdz,\n+                             double dydx, double dydy, double dydz,\n+                             double dzdx, double dzdy, double dzdz) {\n+        Assert.assertEquals(x, v.getX().getReal(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getReal(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12);\n+        Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1), 1.0e-12);\n+    }\n+\n+    private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z,\n+                             double dxdx, double dxdy, double dxdz, double dxdt,\n+                             double dydx, double dydy, double dydz, double dydt,\n+                             double dzdx, double dzdy, double dzdz, double dzdt) {\n+        Assert.assertEquals(x, v.getX().getReal(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getReal(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12);\n+        Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dxdt, v.getX().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dydt, v.getY().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dzdt, v.getZ().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.MathArithmeticException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.random.Well1024a;\n-import org.apache.commons.math3.TestUtils;\n-\n import org.junit.Assert;\n import org.junit.Test;\n \n     }\n \n     @Test\n-    public void testLinearCombination1DSDS() {\n-        final DerivativeStructure[] a = new DerivativeStructure[] {\n-            new DerivativeStructure(6, 1, 0, -1321008684645961.0 / 268435456.0),\n-            new DerivativeStructure(6, 1, 1, -5774608829631843.0 / 268435456.0),\n-            new DerivativeStructure(6, 1, 2, -7645843051051357.0 / 8589934592.0)\n-        };\n-        final DerivativeStructure[] b = new DerivativeStructure[] {\n-            new DerivativeStructure(6, 1, 3, -5712344449280879.0 / 2097152.0),\n-            new DerivativeStructure(6, 1, 4, -4550117129121957.0 / 2097152.0),\n-            new DerivativeStructure(6, 1, 5, 8846951984510141.0 / 131072.0)\n-        };\n-\n-        final DerivativeStructure abSumInline = MathArrays.linearCombination(a[0], b[0],\n-                                                                             a[1], b[1],\n-                                                                             a[2], b[2]);\n-        final DerivativeStructure abSumArray = MathArrays.linearCombination(a, b);\n-\n-        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n-        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n-        Assert.assertEquals(b[0].getValue(), abSumInline.getPartialDerivative(1, 0, 0, 0, 0, 0), 1.0e-15);\n-        Assert.assertEquals(b[1].getValue(), abSumInline.getPartialDerivative(0, 1, 0, 0, 0, 0), 1.0e-15);\n-        Assert.assertEquals(b[2].getValue(), abSumInline.getPartialDerivative(0, 0, 1, 0, 0, 0), 1.0e-15);\n-        Assert.assertEquals(a[0].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 1, 0, 0), 1.0e-15);\n-        Assert.assertEquals(a[1].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 1, 0), 1.0e-15);\n-        Assert.assertEquals(a[2].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 0, 1), 1.0e-15);\n-\n-    }\n-\n-    @Test\n-    public void testLinearCombination1DoubleDS() {\n-        final double[] a = new double[] {\n-            -1321008684645961.0 / 268435456.0,\n-            -5774608829631843.0 / 268435456.0,\n-            -7645843051051357.0 / 8589934592.0\n-        };\n-        final DerivativeStructure[] b = new DerivativeStructure[] {\n-            new DerivativeStructure(3, 1, 0, -5712344449280879.0 / 2097152.0),\n-            new DerivativeStructure(3, 1, 1, -4550117129121957.0 / 2097152.0),\n-            new DerivativeStructure(3, 1, 2, 8846951984510141.0 / 131072.0)\n-        };\n-\n-        final DerivativeStructure abSumInline = MathArrays.linearCombination(a[0], b[0],\n-                                                                             a[1], b[1],\n-                                                                             a[2], b[2]);\n-        final DerivativeStructure abSumArray = MathArrays.linearCombination(a, b);\n-\n-        Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0);\n-        Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15);\n-        Assert.assertEquals(a[0], abSumInline.getPartialDerivative(1, 0, 0), 1.0e-15);\n-        Assert.assertEquals(a[1], abSumInline.getPartialDerivative(0, 1, 0), 1.0e-15);\n-        Assert.assertEquals(a[2], abSumInline.getPartialDerivative(0, 0, 1), 1.0e-15);\n-\n-    }\n-\n-    @Test\n-    public void testLinearCombination2DSDS() {\n-        // we compare accurate versus naive dot product implementations\n-        // on regular vectors (i.e. not extreme cases like in the previous test)\n-        Well1024a random = new Well1024a(0xc6af886975069f11l);\n-\n-        for (int i = 0; i < 10000; ++i) {\n-            final DerivativeStructure[] u = new DerivativeStructure[4];\n-            final DerivativeStructure[] v = new DerivativeStructure[4];\n-            for (int j = 0; j < u.length; ++j) {\n-                u[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n-                v[j] = new DerivativeStructure(u.length, 1, 1e17 * random.nextDouble());\n-            }\n-\n-            DerivativeStructure lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1]);\n-            double ref = u[0].getValue() * v[0].getValue() +\n-                         u[1].getValue() * v[1].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-\n-            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n-            ref = u[0].getValue() * v[0].getValue() +\n-                  u[1].getValue() * v[1].getValue() +\n-                  u[2].getValue() * v[2].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n-\n-            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n-            ref = u[0].getValue() * v[0].getValue() +\n-                  u[1].getValue() * v[1].getValue() +\n-                  u[2].getValue() * v[2].getValue() +\n-                  u[3].getValue() * v[3].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-            Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n-            Assert.assertEquals(v[3].getValue(), lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n-\n-        }\n-    }\n-\n-    @Test\n-    public void testLinearCombination2DoubleDS() {\n-        // we compare accurate versus naive dot product implementations\n-        // on regular vectors (i.e. not extreme cases like in the previous test)\n-        Well1024a random = new Well1024a(0xc6af886975069f11l);\n-\n-        for (int i = 0; i < 10000; ++i) {\n-            final double[] u = new double[4];\n-            final DerivativeStructure[] v = new DerivativeStructure[4];\n-            for (int j = 0; j < u.length; ++j) {\n-                u[j] = 1e17 * random.nextDouble();\n-                v[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble());\n-            }\n-\n-            DerivativeStructure lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1]);\n-            double ref = u[0] * v[0].getValue() +\n-                         u[1] * v[1].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-\n-            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]);\n-            ref = u[0] * v[0].getValue() +\n-                  u[1] * v[1].getValue() +\n-                  u[2] * v[2].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n-\n-            lin = MathArrays.linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]);\n-            ref = u[0] * v[0].getValue() +\n-                  u[1] * v[1].getValue() +\n-                  u[2] * v[2].getValue() +\n-                  u[3] * v[3].getValue();\n-            Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref));\n-            Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue()));\n-            Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue()));\n-            Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue()));\n-            Assert.assertEquals(u[3], lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue()));\n-\n-        }\n-    }\n-\n-    @Test\n     public void testArrayEquals() {\n         Assert.assertFalse(MathArrays.equals(new double[] { 1d }, null));\n         Assert.assertFalse(MathArrays.equals(null, new double[] { 1d }));\n--- a/src/test/java/org/apache/commons/math3/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/MathUtilsTest.java\n  */\n package org.apache.commons.math3.util;\n \n+import org.apache.commons.math3.distribution.RealDistribution;\n+import org.apache.commons.math3.distribution.UniformRealDistribution;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NotFiniteNumberException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.random.RandomDataImpl;\n-import org.apache.commons.math3.distribution.RealDistribution;\n-import org.apache.commons.math3.distribution.UniformRealDistribution;\n import org.junit.Assert;\n import org.junit.Test;\n ", "timestamp": 1361733197, "metainfo": ""}