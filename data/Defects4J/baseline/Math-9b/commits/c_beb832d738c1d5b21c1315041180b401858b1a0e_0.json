{"sha": "beb832d738c1d5b21c1315041180b401858b1a0e", "log": "MATH-664 Allow to pass a singularity threshold value to \"getCovariances\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixUtils;\n-import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n public abstract class AbstractLeastSquaresOptimizer\n     extends BaseAbstractVectorialOptimizer<DifferentiableMultivariateVectorialFunction>\n     implements DifferentiableMultivariateVectorialOptimizer {\n+    /** Singularity threshold (cf. {@link #getCovariances(double)}). */\n+    private static final double DEFAULT_SINGULARITY_THRESHOLD = 1e-14;\n     /**\n      * Jacobian matrix of the weighted residuals.\n      * This matrix is in canonical form just after the calls to\n      * if the covariance matrix cannot be computed (singular problem).\n      */\n     public double[][] getCovariances() {\n-        // set up the jacobian\n+        return getCovariances(DEFAULT_SINGULARITY_THRESHOLD);\n+    }\n+\n+    /**\n+     * Get the covariance matrix of the optimized parameters.\n+     *\n+     * @param threshold Singularity threshold.\n+     * @return the covariance matrix.\n+     * @throws org.apache.commons.math.linear.SingularMatrixException\n+     * if the covariance matrix cannot be computed (singular problem).\n+     */\n+    public double[][] getCovariances(double threshold) {\n+        // Set up the jacobian.\n         updateJacobian();\n \n-        // compute transpose(J).J, avoiding building big intermediate matrices\n+        // Compute transpose(J)J, without building intermediate matrices.\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {\n             for (int j = i; j < cols; ++j) {\n             }\n         }\n \n-        // compute the covariances matrix\n-        RealMatrix inverse =\n-            new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n-        return inverse.getData();\n+        // Compute the covariances matrix.\n+        final DecompositionSolver solver\n+            = new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj), threshold).getSolver();\n+        return solver.getInverse().getData();\n     }\n \n     /**", "timestamp": 1315691629, "metainfo": ""}