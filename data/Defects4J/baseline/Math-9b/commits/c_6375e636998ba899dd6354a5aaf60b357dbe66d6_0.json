{"sha": "6375e636998ba899dd6354a5aaf60b357dbe66d6", "log": "MATH-164 add a special handling for multiplication of complex numbers with infinite parts  ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n     \n     /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n+\n+    /** A complex number representing \"+INF + INFi\" */\n+    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n \n     /** A complex number representing \"1.0 + 0.0i\" */    \n     public static final Complex ONE = new Complex(1.0, 0.0);\n     /**\n      * Return the product of this complex number and the given complex number.\n      * <p>\n-     * Implements the definitional formula:\n+     * Implements preliminary checks for NaN and infinity followed by\n+     * the definitional formula:\n      * <pre><code>\n      * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n      * </code></pre>\n+     * </p>\n      * <p>\n      * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n      * NaN parts.\n-     * <p>\n-     * Returns NaN or infinite values in components of the result per the\n-     * definitional formula and and the rules for {@link java.lang.Double}\n-     * arithmetic.  Examples:\n-     * <pre><code>\n-     *  (1 + i) (INF + i)  =  INF + INFi\n-     *  (1 + INFi) (1 - INFi) = INF + NaNi\n-     *  (-INF + -INFi)(1 + NaNi) = NaN + NaNi\n-     *  </code></pre>\n+     * </p>\n+     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n+     * NaN parts and if either this or <code>rhs</code> has one or more\n+     * infinite parts (same result is returned regardless of the sign of the\n+     * components).\n+     * </p>\n+     * <p>\n+     * Returns finite values in components of the result per the\n+     * definitional formula in all remaining cases.\n+     *  </p>\n      * \n      * @param rhs the other complex number\n      * @return the complex number product\n     public Complex multiply(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n+        }\n+        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n+            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n+            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+            return INF;\n         }\n         return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                 real * rhs.imaginary + imaginary * rhs.real);\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n         Complex w = z.multiply(infOne);\n         assertEquals(w.real, inf, 0);\n         assertEquals(w.imaginary, inf, 0);\n+\n+        // [MATH-164]\n+        assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n+        assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));\n+        assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n         \n         w = oneInf.multiply(oneNegInf);\n         assertEquals(w.real, inf, 0);\n-        assertTrue(Double.isNaN(w.imaginary));\n+        assertEquals(w.imaginary, inf, 0);\n         \n         w = negInfNegInf.multiply(oneNaN);\n         assertTrue(Double.isNaN(w.real));", "timestamp": 1199863813, "metainfo": ""}