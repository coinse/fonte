{"sha": "47574cb8db94bd6a69845522e8f927bc2d8344fc", "log": "Deprecated abstract factory methods and made DescriptiveStatistics a concrete class. Pushed implementations up from DescriptiveStatisticsImpl and deprecated this class. Made implementations of statistics configurable via setters.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n import org.apache.commons.math.stat.descriptive.rank.Percentile;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.ResizableDoubleArray;\n \n \n /**\n- * Abstract factory class for univariate statistical summaries.\n+ * Maintains a dataset of values of a single variable and computes descriptive\n+ * statistics based on stored data. The {@link #getWindowSize() windowSize}\n+ * property sets a limit on the number of values that can be stored in the \n+ * dataset.  The default value, INFINITE_WINDOW, puts no limit on the size of\n+ * the dataset.  This value should be used with caution, as the backing store\n+ * will grow without bound in this case.  For very large datasets, \n+ * {@link SummaryStatistics}, which does not store the dataset, should be used\n+ * instead of this class. If <code>windowSize</code> is not INFINITE_WINDOW and\n+ * more values are added than can be stored in the dataset, new values are\n+ * added in a \"rolling\" manner, with new values replacing the \"oldest\" values \n+ * in the dataset.\n+ * \n+ * Note: this class is not threadsafe.  Use \n+ * {@link SynchronizedDescriptiveStatistics} if concurrent access from multiple\n+ * threads is required.\n  *\n  * @version $Revision$ $Date$\n  */\n-public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {\n+public class DescriptiveStatistics implements StatisticalSummary, Serializable {\n     \n     /** Serialization UID */\n     private static final long serialVersionUID = 5188298269533339922L;\n+    \n+    /** hold the window size **/\n+    protected int windowSize = INFINITE_WINDOW;\n+    \n+    /** \n+     *  Stored data values\n+     */\n+    protected ResizableDoubleArray eDA = new ResizableDoubleArray();\n+    \n+    // Cached implementation instances \n+    // Can be reset by setters\n+    private UnivariateStatistic meanImpl = null;\n+    private UnivariateStatistic geometricMeanImpl = null;\n+    private UnivariateStatistic kurtosisImpl = null;\n+    private UnivariateStatistic maxImpl = null;\n+    private UnivariateStatistic minImpl = null;\n+    private UnivariateStatistic percentileImpl = null;\n+    private UnivariateStatistic skewnessImpl = null;\n+    private UnivariateStatistic varianceImpl = null;\n+    private UnivariateStatistic sumsqImpl = null;\n+    private UnivariateStatistic sumImpl = null;\n+    \n+    /**\n+     * Construct a DescriptiveStatistics instance with an infinite window\n+     */\n+    public DescriptiveStatistics() {\n+    }\n+    \n+    /**\n+     * Construct a DescriptiveStatistics instance with the specified window\n+     * \n+     * @param window the window size.\n+     */\n+    public DescriptiveStatistics(int window) {\n+        super();\n+        setWindowSize(window);\n+    }\n     \n     /**\n      * Create an instance of a <code>DescriptiveStatistics</code>\n      * @param cls the type of <code>DescriptiveStatistics</code> object to\n      *        create. \n-     * @return a new factory. \n+     * @return a new instance. \n      * @throws InstantiationException is thrown if the object can not be\n      *            created.\n      * @throws IllegalAccessException is thrown if the type's default\n      *            constructor is not accessible.\n+     * @deprecated to be removed in commons-math 2.0\n      */\n     public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {\n         return (DescriptiveStatistics)cls.newInstance();\n     \n     /**\n      * Create an instance of a <code>DescriptiveStatistics</code>\n-     * @return a new factory. \n+     * @return a new DescriptiveStatistics instance. \n+     * @deprecated to be removed in commons-math 2.0\n      */\n     public static DescriptiveStatistics newInstance() {\n         DescriptiveStatistics factory = null;\n     public static final int INFINITE_WINDOW = -1;\n \n     /**\n-     * Adds the value to the set of numbers\n+     * Adds the value to the dataset. If the dataset is at the maximum size\n+     * (i.e., the number of stored elements equals the currently configured\n+     * windowSize), the first (oldest) element in the dataset is discarded\n+     * to make room for the new value.\n+     * \n      * @param v the value to be added \n      */\n-    public abstract void addValue(double v);\n+    public void addValue(double v) {\n+        if (windowSize != INFINITE_WINDOW) {\n+            if (getN() == windowSize) {\n+                eDA.addElementRolling(v);\n+            } else if (getN() < windowSize) {\n+                eDA.addElement(v);\n+            }\n+        } else {\n+            eDA.addElement(v);\n+        }\n+    }\n \n     /** \n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n      * @return The mean or Double.NaN if no values have been added.\n      */\n     public double getMean() {\n-        return apply(new Mean());\n+        return apply(getMeanImpl());\n     }\n \n     /** \n      * or if the productof the available values is less than or equal to 0.\n      */\n     public double getGeometricMean() {\n-        return apply(new GeometricMean());\n+        return apply(getGeometricMeanImpl());\n     }\n \n     /** \n      * or 0.0 for a single value set.  \n      */\n     public double getVariance() {\n-        return apply(new Variance());\n+        return apply(getVarianceImpl());\n     }\n \n     /** \n \n     /**\n      * Returns the skewness of the available values. Skewness is a \n-     * measure of the assymetry of a given distribution.\n+     * measure of the asymmetry of a given distribution.\n      * @return The skewness, Double.NaN if no values have been added \n      * or 0.0 for a value set &lt;=2. \n      */\n     public double getSkewness() {\n-        return apply(new Skewness());\n+        return apply(getSkewnessImpl());\n     }\n \n     /**\n      * for a value set &lt;=3. \n      */\n     public double getKurtosis() {\n-        return apply(new Kurtosis());\n+        return apply(getKurtosisImpl());\n     }\n \n     /** \n      * @return The max or Double.NaN if no values have been added.\n      */\n     public double getMax() {\n-        return apply(new Max());\n+        return apply(getMaxImpl());\n     }\n \n     /** \n     * @return The min or Double.NaN if no values have been added.\n     */\n     public double getMin() {\n-        return apply(new Min());\n+        return apply(getMinImpl());\n     }\n \n     /** \n      * Returns the number of available values\n      * @return The number of available values\n      */\n-    public abstract long getN();\n+    public long getN() {\n+        return eDA.getNumElements();\n+    }\n \n     /**\n      * Returns the sum of the values that have been added to Univariate.\n      * @return The sum or Double.NaN if no values have been added\n      */\n     public double getSum() {\n-        return apply(new Sum());\n+        return apply(getSumImpl());\n     }\n \n     /**\n      * values have been added.\n      */\n     public double getSumsq() {\n-        return apply(new SumOfSquares());\n+        return apply(getSumsqImpl());\n     }\n \n     /** \n      * Resets all statistics and storage\n      */\n-    public abstract void clear();\n-\n-    /**\n-     * Univariate has the ability to return only measures for the\n-     * last N elements added to the set of values.\n+    public void clear() {\n+        eDA.clear();\n+    }\n+\n+\n+    /**\n+     * Returns the maximum number of values that can be stored in the\n+     * dataset, or INFINITE_WINDOW (-1) if there is no limit.\n+     * \n      * @return The current window size or -1 if its Infinite.\n      */\n-\n-    public abstract int getWindowSize();\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n \n     /**\n      * WindowSize controls the number of values which contribute \n-     * to the values returned by Univariate.  For example, if \n+     * to the reported statistics.  For example, if \n      * windowSize is set to 3 and the values {1,2,3,4,5} \n      * have been added <strong> in that order</strong> \n      * then the <i>available values</i> are {3,4,5} and all\n      * reported statistics will be based on these values\n      * @param windowSize sets the size of the window.\n      */\n-    public abstract void setWindowSize(int windowSize);\n+    public void setWindowSize(int windowSize) {\n+        if (windowSize < 1) {\n+            if (windowSize != INFINITE_WINDOW) {\n+                throw new IllegalArgumentException(\"window size must be positive.\");\n+            }\n+        }\n+        \n+        this.windowSize = windowSize;\n+\n+        // We need to check to see if we need to discard elements\n+        // from the front of the array.  If the windowSize is less than \n+        // the current number of elements.\n+        if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {\n+            eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n+        }\n+    }\n     \n     /**\n      * Returns the current set of values in an array of double primitives.  \n      * @return returns the current set of numbers in the order in which they \n      *         were added to this set\n      */\n-    public abstract double[] getValues();\n+    public double[] getValues() {\n+        double[] copiedArray = new double[eDA.getNumElements()];\n+        System.arraycopy(eDA.getElements(), 0, copiedArray,\n+            0, eDA.getNumElements());\n+        return copiedArray;\n+    }\n \n     /**\n      * Returns the current set of values in an array of double primitives,  \n      * @param index The Index of the element\n      * @return return the element at the specified index\n      */\n-    public abstract double getElement(int index);\n+    public double getElement(int index) {\n+        return eDA.getElement(index);\n+    }\n \n     /**\n      * Returns an estimate for the pth percentile of the stored values. \n      * @param stat the statistic to apply\n      * @return the computed value of the statistic.\n      */\n-    public abstract double apply(UnivariateStatistic stat);\n-\n+    public double apply(UnivariateStatistic stat) {\n+        return stat.evaluate(eDA.getValues(), eDA.start(), eDA.getNumElements());\n+    }\n+\n+    // Implementation getters and setter\n+    \n+    /**\n+     * @return the meanImpl\n+     */\n+    public UnivariateStatistic getMeanImpl() {\n+        if (meanImpl == null) {\n+            meanImpl = new Mean();\n+        }\n+        return meanImpl;\n+    }\n+\n+    /**\n+     * @param meanImpl the meanImpl to set\n+     */\n+    public void setMeanImpl(UnivariateStatistic meanImpl) {\n+        this.meanImpl = meanImpl;\n+    }\n+\n+    /**\n+     * @return the geometricMeanImpl\n+     */\n+    public UnivariateStatistic getGeometricMeanImpl() {\n+        if (geometricMeanImpl == null) {\n+            geometricMeanImpl = new GeometricMean();\n+        }\n+        return geometricMeanImpl;\n+    }\n+\n+    /**\n+     * @param geometricMeanImpl the geometricMeanImpl to set\n+     */\n+    public void setGeometricMeanImpl(UnivariateStatistic geometricMeanImpl) {\n+        this.geometricMeanImpl = geometricMeanImpl;\n+    }\n+\n+    /**\n+     * @return the kurtosisImpl\n+     */\n+    public UnivariateStatistic getKurtosisImpl() {\n+        if (kurtosisImpl == null) {\n+            kurtosisImpl = new Kurtosis();\n+        }\n+        return kurtosisImpl;\n+    }\n+\n+    /**\n+     * @param kurtosisImpl the kurtosisImpl to set\n+     */\n+    public void setKurtosisImpl(UnivariateStatistic kurtosisImpl) {\n+        this.kurtosisImpl = kurtosisImpl;\n+    }\n+\n+    /**\n+     * @return the maxImpl\n+     */\n+    public UnivariateStatistic getMaxImpl() {\n+        if (maxImpl == null) {\n+            maxImpl = new Max();\n+        }\n+        return maxImpl;\n+    }\n+\n+    /**\n+     * @param maxImpl the maxImpl to set\n+     */\n+    public void setMaxImpl(UnivariateStatistic maxImpl) {\n+        this.maxImpl = maxImpl;\n+    }\n+\n+    /**\n+     * @return the minImpl\n+     */\n+    public UnivariateStatistic getMinImpl() {\n+        if (minImpl == null) {\n+            minImpl =  new Min();\n+        }\n+        return minImpl;\n+    }\n+\n+    /**\n+     * @param minImpl the minImpl to set\n+     */\n+    public void setMinImpl(UnivariateStatistic minImpl) {\n+        this.minImpl = minImpl;\n+    }\n+\n+    /**\n+     * @return the percentileImpl\n+     */\n+    public UnivariateStatistic getPercentileImpl() {\n+        if (percentileImpl == null) {\n+            percentileImpl = new Percentile();\n+        }\n+        return percentileImpl;\n+    }\n+\n+    /**\n+     * @param percentileImpl the percentileImpl to set\n+     */\n+    public void setPercentileImpl(UnivariateStatistic percentileImpl) {\n+        this.percentileImpl = percentileImpl;\n+    }\n+\n+    /**\n+     * @return the skewnessImpl\n+     */\n+    public UnivariateStatistic getSkewnessImpl() {\n+        if (skewnessImpl == null) {\n+            skewnessImpl = new Skewness();\n+        }\n+        return skewnessImpl;\n+    }\n+\n+    /**\n+     * @param skewnessImpl the skewnessImpl to set\n+     */\n+    public void setSkewnessImpl(UnivariateStatistic skewnessImpl) {\n+        this.skewnessImpl = skewnessImpl;\n+    }\n+\n+    /**\n+     * @return the varianceImpl\n+     */\n+    public UnivariateStatistic getVarianceImpl() {\n+        if (varianceImpl == null) {\n+            varianceImpl =  new Variance();\n+        }\n+        return varianceImpl;\n+    }\n+\n+    /**\n+     * @param varianceImpl the varianceImpl to set\n+     */\n+    public void setVarianceImpl(UnivariateStatistic varianceImpl) {\n+        this.varianceImpl = varianceImpl;\n+    }\n+\n+    /**\n+     * @return the sumsqImpl\n+     */\n+    public UnivariateStatistic getSumsqImpl() {\n+        if (sumsqImpl == null) {\n+            sumsqImpl = new SumOfSquares();\n+        }\n+        return sumsqImpl;\n+    }\n+\n+    /**\n+     * @param sumsqImpl the sumsqImpl to set\n+     */\n+    public void setSumsqImpl(UnivariateStatistic sumsqImpl) {\n+        this.sumsqImpl = sumsqImpl;\n+    }\n+\n+    /**\n+     * @return the sumImpl\n+     */\n+    public UnivariateStatistic getSumImpl() {\n+        if (sumImpl == null) {\n+            sumImpl = new Sum();\n+        }\n+        return sumImpl;\n+    }\n+\n+    /**\n+     * @param sumImpl the sumImpl to set\n+     */\n+    public void setSumImpl(UnivariateStatistic sumImpl) {\n+        this.sumImpl = sumImpl;\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1868088725461221010L;\n-    \n-    /** hold the window size **/\n-    protected int windowSize;\n-    \n-    /** \n-     *  Stored data values\n-     */\n-    protected ResizableDoubleArray eDA;\n \n     /**\n      * Construct a DescriptiveStatisticsImpl with infinite window\n      */\n     public DescriptiveStatisticsImpl() {\n-        this(INFINITE_WINDOW);\n+        super();\n     }\n     \n     /**\n      * @param window the finite window size.\n      */\n     public DescriptiveStatisticsImpl(int window) {\n-        super();\n-        eDA = new ResizableDoubleArray();\n-        setWindowSize(window);\n-    }\n-\n-    /**\n-     * Access the window size.\n-     * @return the current window size.\n-     */\n-    public int getWindowSize() {\n-        return windowSize;\n+        super(window);\n     }\n     \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()\n-     */\n-    public double[] getValues() {\n-\n-        double[] copiedArray = new double[eDA.getNumElements()];\n-        System.arraycopy(\n-            eDA.getElements(),\n-            0,\n-            copiedArray,\n-            0,\n-            eDA.getNumElements());\n-        return copiedArray;\n-    }\n-    \n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)\n-     */\n-    public double getElement(int index) {\n-        return eDA.getElement(index);\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()\n-     */\n-    public long getN() {\n-        return eDA.getNumElements();\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n-     */\n-    public void addValue(double v) {\n-        if (windowSize != INFINITE_WINDOW) {\n-            if (getN() == windowSize) {\n-                eDA.addElementRolling(v);\n-            } else if (getN() < windowSize) {\n-                eDA.addElement(v);\n-            }\n-        } else {\n-            eDA.addElement(v);\n-        }\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#clear()\n+    /** \n+     * Resets all statistics and storage\n      */\n     public void clear() {\n-        eDA.clear();\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)\n-     */\n-    public void setWindowSize(int windowSize) {\n-        if (windowSize < 1) {\n-            if (windowSize != INFINITE_WINDOW) {\n-                throw new IllegalArgumentException(\"window size must be positive.\");\n-            }\n-        }\n-        \n-        this.windowSize = windowSize;\n-\n-        // We need to check to see if we need to discard elements\n-        // from the front of the array.  If the windowSize is less than \n-        // the current number of elements.\n-        if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {\n-            eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n-        }\n-    }\n-\n-    /**\n-     * Apply the given statistic to this univariate collection.\n-     * @param stat the statistic to apply\n-     * @return the computed value of the statistic.\n-     */\n-    public double apply(UnivariateStatistic stat) {\n-        return stat.evaluate(eDA.getValues(), eDA.start(), eDA.getNumElements());\n+        super.clear();\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsAbstractTest.java\n import org.apache.commons.math.random.RandomDataImpl;\n \n /**\n- * Test cases for the {@link Univariate} class.\n+ * Test cases for the DescriptiveStatistics implementations.\n  *\n  * @version $Revision$ $Date$\n+ * @deprecated should be moved down into DescriptiveStatisticsTest\n+ *   when DescriptiveStatisticsImpl is removed in 2.0\n  */\n public abstract class DescriptiveStatisticsAbstractTest extends TestCase {\n     private double var = 0.666666666666666666667;\n--- a/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImplTest.java\n import junit.framework.TestSuite;\n \n /**\n- * Test cases for the {@link Univariate} class.\n+ * Test cases for the DescriptiveStatisticsImpl class.\n+ * @deprecated - to be removed in 2.0 with DescriptiveStatisticsImpl\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the DescriptiveStatistics class.\n+ * When DescriptiveStatisticsImpl is removed, this class should replace\n+ * DescriptiveStatisticsAbstractTest\n+ * \n+ * @version $Revision: 592121 $ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ *          2007) $\n+ */\n+public final class DescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {\n+\n+    public DescriptiveStatisticsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);\n+        suite.setName(\"DescriptiveStatistics Tests\");\n+        return suite;\n+    }\n+\n+    protected DescriptiveStatistics createDescriptiveStatistics() {\n+        return new DescriptiveStatistics();\n+    }\n+    \n+    public void testSetterInjection() throws Exception {\n+        DescriptiveStatistics stats = new DescriptiveStatistics();\n+        stats.addValue(1);\n+        stats.addValue(3);\n+        assertEquals(2, stats.getMean(), 1E-10);\n+        // Now lets try some new math\n+        stats.setMeanImpl(new deepMean());\n+        assertEquals(42, stats.getMean(), 1E-10);\n+    }\n+    \n+    /**\n+     * A new way to compute the mean \n+     */\n+    class deepMean implements UnivariateStatistic {\n+        public double evaluate(double[] values, int begin, int length) {\n+            return 42;\n+        }\n+\n+        public double evaluate(double[] values) {\n+            return 42;\n+        }\n+        \n+    }\n+}\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n \n     /** Number Transformer maps Objects to Number for us. */\n     protected NumberTransformer transformer;\n-    \n-    /** hold the window size **/\n-    protected int windowSize = DescriptiveStatistics.INFINITE_WINDOW;\n \n     /**\n      * No argument Constructor", "timestamp": 1196054825, "metainfo": ""}