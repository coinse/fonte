{"sha": "bd345d954b85ef8eb3867c5044f933e34df0c124", "log": "replaced duplicated strings by a single static string in many classes this will later allow enabling the MultipleStringLiterals rule in checkstyle (there are many other duplicated strings, so this cannot be enabled yet, I'll do another pass on it later on)  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -4305020489115478365L;\n \n+    /** Message for failed evaluation. */\n+    private static final String FAILED_EVALUATION_MESSAGE =\n+        \"evaluation failed for argument = {0}\";\n+\n     /** Argument causing function evaluation failure */\n     private double[] argument;\n \n      * @param argument  the failing function argument\n      */\n     public FunctionEvaluationException(double argument) {\n-        super(\"evaluation failed for argument = {0}\", argument);\n+        super(FAILED_EVALUATION_MESSAGE, argument);\n         this.argument = new double[] { argument };\n     }\n \n      * @since 2.0\n      */\n     public FunctionEvaluationException(double[] argument) {\n-        super(\"evaluation failed for argument = {0}\", new ArrayRealVector(argument));\n+        super(FAILED_EVALUATION_MESSAGE, new ArrayRealVector(argument));\n         this.argument = argument.clone();\n     }\n \n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"cannot raise an integral value to a negative power ({0}^{1})\",\n       \"impossible d''\\u00e9lever une valeur enti\\u00e8re \" +\n       \"\\u00e0 une puissance n\\u00e9gative ({0}^{1})\" },\n-    { \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n-       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n-      \"m\\u00e9thode d''arondi {0} invalide, m\\u00e9thodes valides : {1} ({2}), {3} ({4}),\" +\n-       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\" },\n+    { \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n+      \"m\\u00e9thode d''arondi {0} invalide, m\\u00e9thodes valides : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\" },\n     { \"Cannot normalize to an infinite value\",\n       \"impossible de normaliser vers une valeur infinie\" },\n     { \"Cannot normalize to NaN\",\n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"simplex must contain at least one point\",\n       \"le simplex doit contenir au moins un point\" },\n-    { \"equals vertices {0} and {1} in simplex configuration\",\n+    { \"equal vertices {0} and {1} in simplex configuration\",\n       \"sommets {0} et {1} \\u00e9gaux dans la configuration du simplex\" },\n \n     // org.apache.commons.math.estimation.AbstractEstimation\n     // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator\n     { \"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\",\n       \"pas minimal ({0,number,0.00E00}) atteint, l''int\\u00e9gration n\\u00e9cessite {1,number,0.00E00}\" },\n-    { \"dimensions mismatch: state vector has dimension {0},\" +\n-      \" absolute tolerance vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n-      \" et le vecteur de tol\\u00e9rance absolue ({1})\" },\n-    { \"dimensions mismatch: state vector has dimension {0},\" +\n-      \" relative tolerance vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n-      \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n+    { \"dimensions mismatch: state vector has dimension {0}, absolute tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}), et le vecteur de tol\\u00e9rance absolue ({1})\" },\n+    { \"dimensions mismatch: state vector has dimension {0}, relative tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}), et le vecteur de tol\\u00e9rance relative ({1})\" },\n \n     // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator,\n     // org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator\n-    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n-      \" initial state vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n-      \" et le vecteur d''\\u00e9tat initial ({1})\" },\n-    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n-      \" final state vector has dimension {1}\",\n-      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n-      \" et le vecteur d''\\u00e9tat final ({1})\" },\n+    { \"dimensions mismatch: ODE problem has dimension {0}, initial state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}), et le vecteur d''\\u00e9tat initial ({1})\" },\n+    { \"dimensions mismatch: ODE problem has dimension {0}, final state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}), et le vecteur d''\\u00e9tat final ({1})\" },\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n     // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n     { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-      \"dimensions erronn\\u00e9es : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n+      \"dimensions incoh\\u00e9rentes : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n \n     // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n     // org.apache.commons.math.linear.ArrayRealVector\n     // org.apache.commons.math.linear.SparseRealVector\n     { \"vector length mismatch: got {0} but expected {1}\",\n-      \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n+      \"taille de vecteur invalide : {0} au lieu de {1} attendue\" },\n \n     // org.apache.commons.math.linear.ArrayRealVector\n     // org.apache.commons.math.linear.ArrayFieldVector\n       \"nombre de lignes invalide : {0} (doit \\u00eatre positif)\" },\n     { \"invalid column dimension: {0} (must be positive)\",\n       \"nombre de colonnes invalide : {0} (doit \\u00eatre positif)\" },\n-    { \"vector length mismatch: got {0} but expected {1}\",\n-      \"taille de vecteur invalide : {0} au lieu de {1} attendue\" },\n-    { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-      \"dimensions incoh\\u00e9rentes : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n     { \"matrix must have at least one row\",\n       \"une matrice doit comporter au moins une ligne\" },\n     { \"matrix must have at least one column\",\n    // org.apache.commons.math.stat.descriptive.DescriptiveStatistics\n    { \"window size must be positive ({0})\",\n      \"la taille de la fen\\u00eatre doit \\u00eatre positive ({0})\" },\n-   { \"percentile implementation {0} does not support setQuantile\",\n-     \"l''implantation de pourcentage {0} ne dispose pas de la m\\u00e9thode setQuantile\" },\n-   { \"cannot access setQuantile method in percentile implementation {0}\",\n-     \"acc\\u00e8s impossible \\u00e0 la m\\u00e9thode setQuantile\" +\n-     \" dans l''implantation de pourcentage {0}\" },\n+   { \"percentile implementation {0} does not support {1}\",\n+     \"l''implantation de pourcentage {0} ne dispose pas de la m\\u00e9thode {1}\" },\n+   { \"cannot access {0} method in percentile implementation {1}\",\n+     \"acc\\u00e8s impossible \\u00e0 la m\\u00e9thode {0}\" +\n+     \" dans l''implantation de pourcentage {1}\" },\n    { \"out of bounds quantile value: {0}, must be in (0, 100]\",\n      \"valeur de quantile {0} hors bornes, doit \\u00eatre dans l''intervalle ]0, 100]\" },\n \n \n    // org.apache.commons.math.stat.descriptive.moment.Kurtosis\n    { \"statistics constructed from external moments cannot be incremented\",\n-     \"les statistiques bas\\u00e9es sur des moments externes \" +\n-     \"ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n+     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n    { \"statistics constructed from external moments cannot be cleared\",\n-     \"les statistiques bas\\u00e9es sur des moments externes \" +\n-     \"ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" },\n+     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" },\n \n    // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n    { \"expected array length = {0}, must be at least 2\",\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n  */\n public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n-    /**\n-     * Serializtion identifier\n+    /** Message for empty coefficients array. */\n+    private static final String EMPTY_ARRAY_MESSAGE =\n+        \"empty polynomials coefficients array\";\n+\n+    /**\n+     * Serialization identifier\n      */\n     private static final long serialVersionUID = -7726511984200295583L;\n \n     public PolynomialFunction(double c[]) {\n         super();\n         if (c.length < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n         }\n         int l = c.length;\n         while ((l > 1) && (c[l - 1] == 0)) {\n     protected static double evaluate(double[] coefficients, double argument) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n         }\n         double result = coefficients[n - 1];\n         for (int j = n -2; j >=0; j--) {\n     protected static double[] differentiate(double[] coefficients) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n         }\n         if (n == 1) {\n             return new double[]{0};\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n  * @since 1.2\n  */\n public class LaguerreSolver extends UnivariateRealSolverImpl {\n+\n+    /** Message for non-polynomial function. */\n+    private static final String NON_POLYNOMIAL_FUNCTION_MESSAGE =\n+        \"function is not polynomial\";\n+\n+    /** Message for non-positive degree. */\n+    private static final String NON_POSITIVE_DEGREE_MESSAGE =\n+        \"polynomial degree must be positive: degree={0}\";\n+\n     /** polynomial function to solve.\n      * @deprecated as of 2.0 the function is not stored anymore in the instance\n      */\n         if (f instanceof PolynomialFunction) {\n             p = (PolynomialFunction) f;\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n+            throw MathRuntimeException.createIllegalArgumentException(NON_POLYNOMIAL_FUNCTION_MESSAGE);\n         }\n     }\n \n \n         // check function type\n         if (!(f instanceof PolynomialFunction)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n+            throw MathRuntimeException.createIllegalArgumentException(NON_POLYNOMIAL_FUNCTION_MESSAGE);\n         }\n \n         // check for zeros before verifying bracketing\n         int iterationCount = 0;\n         if (n < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"polynomial degree must be positive: degree={0}\", n);\n+                  NON_POSITIVE_DEGREE_MESSAGE, n);\n         }\n         Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n         for (int i = 0; i <= n; i++) {\n         int n = coefficients.length - 1;\n         if (n < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"polynomial degree must be positive: degree={0}\", n);\n+                  NON_POSITIVE_DEGREE_MESSAGE, n);\n         }\n         Complex N  = new Complex(n,     0.0);\n         Complex N1 = new Complex(n - 1, 0.0);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverUtils {\n+\n+    /** Message for null function.*/\n+    private static final String NULL_FUNCTION_MESSAGE =\n+        \"function is null\";\n+\n     /**\n      * Default constructor.\n      */\n             FunctionEvaluationException {\n \n         if (function == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(NULL_FUNCTION_MESSAGE);\n         }\n         if (maximumIterations <= 0)  {\n             throw MathRuntimeException.createIllegalArgumentException(\n      */\n     private static void setup(UnivariateRealFunction f) {\n         if (f == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(NULL_FUNCTION_MESSAGE);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n public abstract class AbstractIntegerDistribution extends AbstractDistribution\n     implements IntegerDistribution, Serializable {\n \n+    /** Message for endpoints in wrong order. */\n+    private static final String WRONG_ORDER_ENDPOINTS_MESSAGE =\n+        \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\";\n+\n+    /** Message for out of range point. */\n+    private static final String OUT_OF_RANGE_POINT =\n+        \"{0} out of [{1}, {2}] range\";\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n \n         throws MathException {\n         if (x0 > x1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n-                  x0, x1);\n+                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);\n         }\n         if (Math.floor(x0) < x0) {\n             return cumulativeProbability(((int) Math.floor(x0)) + 1,\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n         if (x0 > x1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n-                  x0, x1);\n+                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n     public int inverseCumulativeProbability(final double p) throws MathException{\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  OUT_OF_RANGE_POINT, p, 0.0, 1.0);\n         }\n \n         // by default, do simple bisection.\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     extends AbstractContinuousDistribution\n     implements FDistribution, Serializable  {\n \n+    /** Message for non positive degrees of freddom. */\n+    private static final String NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE =\n+        \"degrees of freedom must be positive ({0})\";\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8516354193418641566L;\n \n     public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"degrees of freedom must be positive ({0})\",\n-                  degreesOfFreedom);\n+                  NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE, degreesOfFreedom);\n         }\n         this.numeratorDegreesOfFreedom = degreesOfFreedom;\n     }\n     public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"degrees of freedom must be positive ({0})\",\n-                  degreesOfFreedom);\n+                  NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE, degreesOfFreedom);\n         }\n         this.denominatorDegreesOfFreedom = degreesOfFreedom;\n     }\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -5630213147331578515L;\n \n+    /** Message for zero denominator. */\n+    private static final String FORBIDDEN_ZERO_DENOMINATOR =\n+        \"denominator must be different from 0\";\n+\n     /** <code>BigInteger</code> representation of 100. */\n     private static final BigInteger ONE_HUNDRED_DOUBLE = BigInteger.valueOf(100);\n \n             throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n         }\n         if (BigInteger.ZERO.equals(den)) {\n-            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n         }\n         if (BigInteger.ZERO.equals(num)) {\n             numerator   = BigInteger.ZERO;\n      */\n     public BigFraction divide(final BigInteger bg) {\n         if (BigInteger.ZERO.equals(bg)) {\n-            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n         }\n         return new BigFraction(numerator, denominator.multiply(bg));\n     }\n      */\n     public BigFraction divide(final BigFraction fraction) {\n         if (BigInteger.ZERO.equals(fraction.numerator)) {\n-            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n         }\n \n         return multiply(fraction.reciprocal());\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n     /** A fraction representing \"-1 / 1\". */\n     public static final Fraction MINUS_ONE = new Fraction(-1, 1);\n \n+    /** Message for zero denominator. */\n+    private static final String ZERO_DENOMINATOR_MESSAGE =\n+        \"zero denominator in fraction {0}/{1}\";\n+\n+    /** Message for overflow. */\n+    private static final String OVERFLOW_MESSAGE =\n+        \"overflow in fraction {0}/{1}, cannot negate\";\n+\n+    /** Message for null fraction. */\n+    private static final String NULL_FRACTION =\n+        \"null fraction\";\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 3698073679419233275L;\n \n      */\n     public Fraction(int num, int den) {\n         if (den == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n-                                                                 num, den);\n+            throw MathRuntimeException.createArithmeticException(\n+                  ZERO_DENOMINATOR_MESSAGE, num, den);\n         }\n         if (den < 0) {\n             if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n-                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n-                                                                     num, den);\n+                throw MathRuntimeException.createArithmeticException(\n+                      OVERFLOW_MESSAGE, num, den);\n             }\n             num = -num;\n             den = -den;\n      */\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n-            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n-                                                                 numerator, denominator);\n+            throw MathRuntimeException.createArithmeticException(\n+                  OVERFLOW_MESSAGE, numerator, denominator);\n         }\n         return new Fraction(-numerator, denominator);\n     }\n      */\n     private Fraction addSub(Fraction fraction, boolean isAdd) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n         }\n         // zero is identity for addition.\n         if (numerator == 0) {\n      */\n     public Fraction multiply(Fraction fraction) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n         }\n         if (numerator == 0 || fraction.numerator == 0) {\n             return ZERO;\n      */\n     public Fraction divide(Fraction fraction) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n         }\n         if (fraction.numerator == 0) {\n             throw MathRuntimeException.createArithmeticException(\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n             throw MathRuntimeException.createArithmeticException(\n-                    \"zero denominator in fraction {0}/{1}\",\n-                    numerator, denominator);\n+                  ZERO_DENOMINATOR_MESSAGE, numerator, denominator);\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n                 throw MathRuntimeException.createArithmeticException(\n-                        \"overflow in fraction {0}/{1}, cannot negate\",\n-                        numerator, denominator);\n+                      OVERFLOW_MESSAGE, numerator, denominator);\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7260756672015356458L;\n \n+    /** Message for at least one row. */\n+    private static final String AT_LEAST_ONE_ROW_MESSAGE =\n+        \"matrix must have at least one row\";\n+\n+    /** Message for at least one column. */\n+    private static final String AT_LEAST_ONE_COLUMN_MESSAGE =\n+        \"matrix must have at least one column\";\n+\n+    /** Message for different rows lengths. */\n+    private static final String DIFFERENT_ROWS_LENGTHS_MESSAGE =\n+        \"some rows have length {0} while others have length {1}\";\n+\n+    /** Message for no entry at selected indices. */\n+    private static final String NO_ENTRY_MESSAGE =\n+        \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\";\n+\n+    /** Message for vector lengths mismatch. */\n+    private static final String VECTOR_LENGTHS_MISMATCH =\n+        \"vector length mismatch: got {0} but expected {1}\";\n+\n     /** Entries of the matrix */\n     protected T[][] data;\n \n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_ROW_MESSAGE);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_COLUMN_MESSAGE);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n-                            nCols, d[r].length);\n+                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                 }\n             }\n             data = d;\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} rows are not initialized yet\",\n-                        row);\n+                      \"first {0} rows are not initialized yet\", row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} columns are not initialized yet\",\n-                        column);\n+                      \"first {0} columns are not initialized yet\", column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_ROW_MESSAGE);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_COLUMN_MESSAGE);\n             }\n             data = buildArray(getField(), subMatrix.length, nCols);\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n-                            nCols, subMatrix[i].length);\n+                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = data[row][column].add(increment);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = data[row][column].multiply(factor);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n-                    v.length, nCols);\n+                  VECTOR_LENGTHS_MISMATCH, v.length, nCols);\n         }\n         final T[] out = buildArray(getField(), nRows);\n         for (int row = 0; row < nRows; row++) {\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n-                    v.length, nRows);\n+                  VECTOR_LENGTHS_MISMATCH, v.length, nRows);\n         }\n \n         final T[] out = buildArray(getField(), nCols);\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1067294169172445528L;\n \n+    /** Message for at least one row. */\n+    private static final String AT_LEAST_ONE_ROW_MESSAGE =\n+        \"matrix must have at least one row\";\n+\n+    /** Message for at least one column. */\n+    private static final String AT_LEAST_ONE_COLUMN_MESSAGE =\n+        \"matrix must have at least one column\";\n+\n+    /** Message for different rows lengths. */\n+    private static final String DIFFERENT_ROWS_LENGTHS_MESSAGE =\n+        \"some rows have length {0} while others have length {1}\";\n+\n+    /** Message for no entry at selected indices. */\n+    private static final String NO_ENTRY_MESSAGE =\n+        \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\";\n+\n+    /** Message for vector lengths mismatch. */\n+    private static final String VECTOR_LENGTHS_MISMATCH =\n+        \"vector length mismatch: got {0} but expected {1}\";\n+\n     /** Entries of the matrix */\n     protected double data[][];\n \n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_ROW_MESSAGE);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_COLUMN_MESSAGE);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n-                            nCols, d[r].length);\n+                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                 }\n             }\n             data = d;\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} rows are not initialized yet\",\n-                        row);\n+                      \"first {0} rows are not initialized yet\", row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} columns are not initialized yet\",\n-                        column);\n+                      \"first {0} columns are not initialized yet\", column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_ROW_MESSAGE);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      AT_LEAST_ONE_COLUMN_MESSAGE);\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n-                            nCols, subMatrix[i].length);\n+                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-                    row, column, getRowDimension(), getColumnDimension());\n+                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n-                    v.length, nCols);\n+                  VECTOR_LENGTHS_MISMATCH, v.length, nCols);\n         }\n         final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n-                    v.length, nRows);\n+                  VECTOR_LENGTHS_MISMATCH, v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n  */\n public class ArrayRealVector implements RealVector, Serializable {\n \n+    /** Message for non fitting position and size. */\n+    private static final String NON_FITTING_POSITION_AND_SIZE_MESSAGE =\n+        \"position {0} and size {1} don't fit to the size of the input array {2}\";\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1097961340710804027L;\n \n     public ArrayRealVector(double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n-                    pos, size, d.length);\n+                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n         }\n         data = new double[size];\n         System.arraycopy(d, pos, data, 0, size);\n     public ArrayRealVector(Double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n-                    pos, size, d.length);\n+                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n         }\n         data = new double[size];\n         for (int i = pos; i < pos + size; i++) {\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n     /** Default bound to determine effective singularity in LU decomposition */\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n \n+    /** Message for vector length mismatch. */\n+    private static final String VECTOR_LENGTH_MISMATCH_MESSAGE =\n+        \"vector length mismatch: got {0} but expected {1}\";\n+\n     /** Entries of LU decomposition. */\n     private double lu[][];\n \n             final int m = pivot.length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                        b.length, m);\n+                        VECTOR_LENGTH_MISMATCH_MESSAGE, b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n                 final int m = pivot.length;\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"vector length mismatch: got {0} but expected {1}\",\n-                            b.getDimension(), m);\n+                            VECTOR_LENGTH_MISMATCH_MESSAGE, b.getDimension(), m);\n                 }\n                 if (singular) {\n                     throw new SingularMatrixException();\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n  * @since 1.2\n  */\n public abstract class DirectSearchOptimizer implements MultivariateRealOptimizer {\n+\n+    /** Message for equal vertices. */\n+    private static final String EQUAL_VERTICES_MESSAGE =\n+        \"equal vertices {0} and {1} in simplex configuration\";\n+\n+    /** Message for dimension mismatch. */\n+    private static final String DIMENSION_MISMATCH_MESSAGE =\n+        \"dimension mismatch {0} != {1}\";\n \n     /** Simplex. */\n     protected RealPointValuePair[] simplex;\n             for (int j = 0; j < i + 1; ++j) {\n                 if (steps[j] == 0.0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"equals vertices {0} and {1} in simplex configuration\",\n-                            j, j + 1);\n+                          EQUAL_VERTICES_MESSAGE, j, j + 1);\n                 }\n                 System.arraycopy(steps, 0, vertexI, 0, j + 1);\n             }\n             // safety checks\n             if (refI.length != n) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimension mismatch {0} != {1}\",\n-                        refI.length, n);\n+                      DIMENSION_MISMATCH_MESSAGE, refI.length, n);\n             }\n             for (int j = 0; j < i; ++j) {\n                 final double[] refJ = referenceSimplex[j];\n                 }\n                 if (allEquals) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"equals vertices {0} and {1} in simplex configuration\",\n-                            i, j);\n+                          EQUAL_VERTICES_MESSAGE, i, j);\n                 }\n             }\n \n         final int n = startPoint.length;\n         if (n != startConfiguration.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimension mismatch {0} != {1}\",\n-                    n, startConfiguration.length);\n+                  DIMENSION_MISMATCH_MESSAGE, n, startConfiguration.length);\n         }\n \n         // set first vertex\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n  */\n class SimplexTableau implements Serializable {\n \n+    /** Column label for negative vars. */\n+    private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1369660067587938365L;\n \n         columnLabels.add(\"x\" + i);\n       }\n       if (!restrictToNonNegative) {\n-        columnLabels.add(\"x-\");\n+        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n       }\n       for (int i = 0; i < getNumSlackVariables(); i++) {\n         columnLabels.add(\"s\" + i);\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n-      int negativeVarColumn = columnLabels.indexOf(\"x-\");\n+      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n       Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n     /** Serialization UID */\n     private static final long serialVersionUID = 4133067267405273064L;\n \n+    /** Name of the setQuantile method. */\n+    private static final String SET_QUANTILE_METHOD_NAME = \"setQuantile\";\n+\n+    /** Message for unsupported setQuantile. */\n+    private static final String UNSUPPORTED_METHOD_MESSAGE =\n+        \"percentile implementation {0} does not support {1}\";\n+\n+    /** Message for illegal accesson setquantile. */\n+    private static final String ILLEGAL_ACCESS_MESSAGE =\n+        \"cannot access {0} method in percentile implementation {1}\";\n+\n     /** hold the window size **/\n     protected int windowSize = INFINITE_WINDOW;\n \n             ((Percentile) percentileImpl).setQuantile(p);\n         } else {\n             try {\n-                percentileImpl.getClass().getMethod(\"setQuantile\",\n+                percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME,\n                         new Class[] {Double.TYPE}).invoke(percentileImpl,\n                                 new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"percentile implementation {0} does not support setQuantile\",\n-                      percentileImpl.getClass().getName());\n+                      UNSUPPORTED_METHOD_MESSAGE,\n+                      percentileImpl.getClass().getName(), SET_QUANTILE_METHOD_NAME);\n             } catch (IllegalAccessException e2) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"cannot access setQuantile method in percentile implementation {0}\",\n-                      percentileImpl.getClass().getName());\n+                      ILLEGAL_ACCESS_MESSAGE,\n+                      SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName());\n             } catch (InvocationTargetException e3) {\n                 throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n             }\n     public synchronized void setPercentileImpl(\n             UnivariateStatistic percentileImpl) {\n         try {\n-            percentileImpl.getClass().getMethod(\"setQuantile\",\n+            percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME,\n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n                             new Object[] {Double.valueOf(50.0d)});\n         } catch (NoSuchMethodException e1) {\n                   percentileImpl.getClass().getName());\n         } catch (IllegalAccessException e2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"cannot access setQuantile method in percentile implementation {0}\",\n-                  percentileImpl.getClass().getName());\n+                  ILLEGAL_ACCESS_MESSAGE,\n+                  SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName());\n         } catch (InvocationTargetException e3) {\n             throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n         }\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n  */\n public class TTestImpl implements TTest  {\n \n+    /** Message for insufficient data. */\n+    private static final String INSUFFICIENT_DATA_MESSAGE =\n+        \"insufficient data for t statistic, needs at least 2, got {0}\";\n+\n     /** Distribution used to compute inference statistics. */\n     private TDistribution distribution;\n \n         throws IllegalArgumentException {\n         if ((data == null) || (data.length < 2)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"insufficient data for t statistic, needs at least 2, got {0}\",\n+                  INSUFFICIENT_DATA_MESSAGE,\n                   (data == null) ? 0 : data.length);\n         }\n     }\n         throws IllegalArgumentException {\n         if ((stat == null) || (stat.getN() < 2)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"insufficient data for t statistic, needs at least 2, got {0}\",\n+                  INSUFFICIENT_DATA_MESSAGE,\n                   (stat == null) ? 0 : stat.getN());\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n+    /** Message for not power of 2. */\n+    private static final String NOT_POWER_OF_TWO_MESSAGE =\n+        \"{0} is not a power of 2, consider padding for fix\";\n+\n+    /** Message for dimension mismatch. */\n+    private static final String DIMENSION_MISMATCH_MESSAGE =\n+        \"some dimensions don't match: {0} != {1}\";\n+\n+    /** Message for not computed roots of unity. */\n+    private static final String MISSING_ROOTS_OF_UNITY_MESSAGE =\n+        \"roots of unity have not been computed yet\";\n+\n+    /** Message for out of range root index. */\n+    private static final String OUT_OF_RANGE_ROOT_INDEX_MESSAGE =\n+        \"out of range root of unity index {0} (must be in [{1};{2}])\";\n+\n     /** roots of unity */\n     private RootsOfUnity roots = new RootsOfUnity();\n \n     public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n         if (!isPowerOf2(d.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} is not a power of 2, consider padding for fix\",\n-                    d.length);\n+                    NOT_POWER_OF_TWO_MESSAGE, d.length);\n         }\n     }\n \n     public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n         if (!isPowerOf2(o.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} is not a power of 2, consider padding for fix\",\n-                    o.length);\n+                    NOT_POWER_OF_TWO_MESSAGE, o.length);\n         }\n     }\n \n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some dimensions don't match: {0} != {1}\",\n-                            0, dimensionSize.length);\n+                            DIMENSION_MISMATCH_MESSAGE, 0, dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some dimensions don't match: {0} != {1}\",\n-                        vector.length, dimensionSize.length);\n+                        DIMENSION_MISMATCH_MESSAGE, vector.length, dimensionSize.length);\n             }\n \n             Object lastDimension = multiDimensionalComplexArray;\n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some dimensions don't match: {0} != {1}\",\n-                            0, dimensionSize.length);\n+                            DIMENSION_MISMATCH_MESSAGE, 0, dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some dimensions don't match: {0} != {1}\",\n-                        vector.length,dimensionSize.length);\n+                        DIMENSION_MISMATCH_MESSAGE, vector.length,dimensionSize.length);\n             }\n \n             Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n \n         if (omegaCount == 0) {\n           throw MathRuntimeException.createIllegalStateException(\n-                  \"roots of unity have not been computed yet\");\n+                  MISSING_ROOTS_OF_UNITY_MESSAGE);\n         }\n         return isForward;\n \n \n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"roots of unity have not been computed yet\");\n+                    MISSING_ROOTS_OF_UNITY_MESSAGE);\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"out of range root of unity index {0} (must be in [{1};{2}])\",\n-                    k, 0, omegaCount - 1);\n+                    OUT_OF_RANGE_ROOT_INDEX_MESSAGE, k, 0, omegaCount - 1);\n         }\n \n         return omegaReal[k];\n \n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"roots of unity have not been computed yet\");\n+                    MISSING_ROOTS_OF_UNITY_MESSAGE);\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n           throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of range root of unity index {0} (must be in [{1};{2}])\",\n-                  k, 0, omegaCount - 1);\n+                  OUT_OF_RANGE_ROOT_INDEX_MESSAGE, k, 0, omegaCount - 1);\n         }\n \n         return isForward ? omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3646337053166149105L;\n \n+    /** Message for map modification during iteration. */\n+    private static final String CONCURRENT_MODIFICATION_MESSAGE =\n+        \"map has been modified while iterating\";\n+\n+    /** Message for exhausted iterator. */\n+    private static final String EXHAUSTED_ITERATOR_MESSAGE =\n+        \"iterator exhausted\";\n+\n     /** Load factor for the map. */\n     private static final float LOAD_FACTOR = 0.5f;\n \n         public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n             }\n             return keys[current];\n         }\n         public double value()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n             }\n             return values[current];\n         }\n             throws ConcurrentModificationException, NoSuchElementException {\n \n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n \n             // advance on step\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 next = -2;\n                 if (current < 0) {\n-                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                    throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n                 }\n             }\n \n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -9179080286849120720L;\n \n+    /** Message for map modification during iteration. */\n+    private static final String CONCURRENT_MODIFICATION_MESSAGE =\n+        \"map has been modified while iterating\";\n+\n+    /** Message for exhausted iterator. */\n+    private static final String EXHAUSTED_ITERATOR_MESSAGE =\n+        \"iterator exhausted\";\n+\n     /** Load factor for the map. */\n     private static final float LOAD_FACTOR = 0.5f;\n \n         public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n             }\n             return keys[current];\n         }\n         public T value()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n             }\n             return values[current];\n         }\n             throws ConcurrentModificationException, NoSuchElementException {\n \n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+                throw MathRuntimeException.createConcurrentModificationException(\n+                      CONCURRENT_MODIFICATION_MESSAGE);\n             }\n \n             // advance on step\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 next = -2;\n                 if (current < 0) {\n-                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                    throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n                 }\n             }\n ", "timestamp": 1259531271, "metainfo": ""}