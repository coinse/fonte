{"sha": "120e9f5229c0e1f27788603fe95dc8a43f686ac9", "log": "Removed deprecated code in implementations of \"IntegerDistribution\". Added \"final\" keyword. Added \"sample\" methods to \"IntegerDistribution\" and \"ContinuousDistribution\" interfaces. Cleaned up Javadoc.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.util.FastMath;\n  */\n public abstract class AbstractIntegerDistribution extends AbstractDistribution\n     implements IntegerDistribution, Serializable {\n-\n    /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n-\n-    /**\n-     * RandomData instance used to generate samples from the distribution\n+    /**\n+     * RandomData instance used to generate samples from the distribution.\n      * @since 2.2\n      */\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n     /**\n      * Default constructor.\n      */\n-    protected AbstractIntegerDistribution() {\n-        super();\n-    }\n-\n-    /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X &le; x).  In other words,\n-     * this method represents the  (cumulative) distribution function, or\n-     * CDF, for this distribution.\n-     * <p>\n-     * If <code>x</code> does not represent an integer value, the CDF is\n-     * evaluated at the greatest integer less than x.\n-     *\n-     * @param x the value at which the distribution function is evaluated.\n-     * @return cumulative probability that a random variable with this\n-     * distribution takes a value less than or equal to <code>x</code>\n+    protected AbstractIntegerDistribution() {}\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X < x)}.  In other\n+     * words, this method represents the (cumulative) distribution function,\n+     * or CDF, for this distribution.\n+     * If {@code x} does not represent an integer value, the CDF is\n+     * evaluated at the greatest integer less than {@code x}.\n+     *\n+     * @param x Value at which the distribution function is evaluated.\n+     * @return the cumulative probability that a random variable with this\n+     * distribution takes a value less than or equal to {@code x}.\n      * @throws MathException if the cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n      */\n     }\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     *\n-     * @param x0 the (inclusive) lower bound\n-     * @param x1 the (inclusive) upper bound\n+     * For a random variable {@code X} whose values are distributed\n+     * according to this distribution, this method returns\n+     * {@code P(x0 < X < x1)}.\n+     *\n+     * @param x0 Inclusive lower bound.\n+     * @param x1 Inclusive upper bound.\n      * @return the probability that a random variable with this distribution\n-     * will take a value between <code>x0</code> and <code>x1</code>,\n+     * will take a value between {@code x0} and {@code x1},\n      * including the endpoints.\n      * @throws MathException if the cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     * @throws NumberIsTooSmallException if {@code x1 > x0}.\n      */\n     @Override\n     public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n-        if (x0 > x1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1);\n+        if (x1 < x0) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n         }\n         if (FastMath.floor(x0) < x0) {\n             return cumulativeProbability(((int) FastMath.floor(x0)) + 1,\n     }\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X &le; x).  In other words,\n-     * this method represents the probability distribution function, or PDF,\n-     * for this distribution.\n-     *\n-     * @param x the value at which the PDF is evaluated.\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X < x)}. In other\n+     * words, this method represents the probability distribution function,\n+     * or PDF, for this distribution.\n+     *\n+     * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * computed due to convergence or other numerical errors.\n      */\n     public abstract double cumulativeProbability(int x) throws MathException;\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X = x). In other words, this\n-     * method represents the probability mass function,  or PMF, for the distribution.\n-     * <p>\n-     * If <code>x</code> does not represent an integer value, 0 is returned.\n-     *\n-     * @param x the value at which the probability density function is evaluated\n-     * @return the value of the probability density function at x\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X = x)}. In other\n+     * words, this method represents the probability mass function, or PMF,\n+     * for the distribution.\n+     * If {@code x} does not represent an integer value, 0 is returned.\n+     *\n+     * @param x Value at which the probability density function is evaluated.\n+     * @return the value of the probability density function at {@code x}.\n      */\n     public double probability(double x) {\n         double fl = FastMath.floor(x);\n     }\n \n     /**\n-    * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     *\n-     * @param x0 the inclusive, lower bound\n-     * @param x1 the inclusive, upper bound\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(x0 < X < x1)}.\n+     *\n+     * @param x0 Inclusive lower bound.\n+     * @param x1 Inclusive upper bound.\n      * @return the cumulative probability.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if x0 > x1\n+     * computed due to convergence or other numerical errors.\n+     * @throws NumberIsTooSmallException {@code if x0 > x1}.\n      */\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n-        if (x0 > x1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1);\n+        if (x1 < x0) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns the largest x, such\n-     * that P(X &le; x) &le; <code>p</code>.\n-     *\n-     * @param p the desired probability\n-     * @return the largest x such that P(X &le; x) <= p\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns the largest {@code x}, such\n+     * that {@code P(X < x) < p}.\n+     *\n+     * @param p Desired probability.\n+     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p < 0 or p > 1\n+     * computed due to convergence or other numerical errors.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     public int inverseCumulativeProbability(final double p) throws MathException{\n-        if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n         }\n \n         // by default, do simple bisection.\n     }\n \n     /**\n-     * Reseeds the random generator used to generate samples.\n-     *\n-     * @param seed the new seed\n-     * @since 2.2\n+     * {@inheritDoc}\n      */\n     public void reseedRandomGenerator(long seed) {\n         randomData.reSeed(seed);\n     /**\n      * Generates a random value sampled from this distribution. The default\n      * implementation uses the\n-     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n-     *\n-     * @return random value\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n+     *  inversion method.\n+     * </a>\n+     *\n+     * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value\n+     * @throws MathException if an error occurs generating the random value.\n      */\n     public int sample() throws MathException {\n         return randomData.nextInversionDeviate(this);\n     }\n \n     /**\n-     * Generates a random sample from the distribution.  The default implementation\n-     * generates the sample by calling {@link #sample()} in a loop.\n-     *\n-     * @param sampleSize number of random values to generate\n+     * Generates a random sample from the distribution.  The default\n+     * implementation generates the sample by calling {@link #sample()}\n+     * in a loop.\n+     *\n+     * @param sampleSize number of random values to generate.\n      * @since 2.2\n-     * @return an array representing the random sample\n-     * @throws MathException if an error occurs generating the sample\n-     * @throws IllegalArgumentException if sampleSize is not positive\n+     * @return an array representing the random sample.\n+     * @throws MathException if an error occurs generating the sample.\n+     * @throws NotStrictlyPositiveException if {@code sampleSize <= 0}.\n      */\n     public int[] sample(int sampleSize) throws MathException {\n         if (sampleSize <= 0) {\n-            MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, sampleSize);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                                                   sampleSize);\n         }\n         int[] out = new int[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n     }\n \n     /**\n-     * Computes the cumulative probability function and checks for NaN values returned.\n-     * Throws MathException if the value is NaN. Wraps and rethrows any MathException encountered\n-     * evaluating the cumulative probability function in a FunctionEvaluationException. Throws\n-     * FunctionEvaluationException of the cumulative probability function returns NaN.\n-     *\n-     * @param argument input value\n-     * @return cumulative probability\n-     * @throws FunctionEvaluationException if a MathException occurs computing the cumulative probability\n-     */\n-    private double checkedCumulativeProbability(int argument) throws FunctionEvaluationException {\n+     * Computes the cumulative probability function and checks for NaN\n+     * values returned.\n+     * Throws MathException if the value is NaN. Wraps and rethrows any\n+     * MathException encountered evaluating the cumulative probability\n+     * function in a FunctionEvaluationException.\n+     * Throws FunctionEvaluationException of the cumulative probability\n+     * function returns NaN.\n+     *\n+     * @param argument Input value.\n+     * @return the cumulative probability.\n+     * @throws FunctionEvaluationException if a MathException occurs\n+     * computing the cumulative probability.\n+     */\n+    private double checkedCumulativeProbability(int argument)\n+        throws FunctionEvaluationException {\n         double result = Double.NaN;\n         try {\n             result = cumulativeProbability(argument);\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a PDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     protected abstract int getDomainLowerBound(double p);\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a PDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     protected abstract int getDomainUpperBound(double p);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n  */\n public class BetaDistributionImpl\n     extends AbstractContinuousDistribution implements BetaDistribution {\n-\n     /**\n-     * Default inverse cumulative probability accurac\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1221965979403477668L;\n-\n     /** First shape parameter. */\n-    private double alpha;\n-\n+    private final double alpha;\n     /** Second shape parameter. */\n-    private double beta;\n-\n+    private final double beta;\n     /** Normalizing factor used in density computations.\n      * updated whenever alpha or beta are changed.\n      */\n     private double z;\n-\n-    /** Inverse cumulative probability accuracy */\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n public interface BinomialDistribution extends IntegerDistribution {\n     /**\n      * Access the number of trials for this distribution.\n+     *\n      * @return the number of trials.\n      */\n     int getNumberOfTrials();\n \n     /**\n      * Access the probability of success for this distribution.\n+     *\n      * @return the probability of success.\n      */\n     double getProbabilityOfSuccess();\n-\n-    /**\n-     * Change the number of trials for this distribution.\n-     * @param trials the new number of trials.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setNumberOfTrials(int trials);\n-\n-    /**\n-     * Change the probability of success for this distribution.\n-     * @param p the new probability of success.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setProbabilityOfSuccess(double p);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.FastMath;\n  */\n public class BinomialDistributionImpl extends AbstractIntegerDistribution\n         implements BinomialDistribution, Serializable {\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = 6751309484392813623L;\n-\n     /** The number of trials. */\n-    private int numberOfTrials;\n-\n+    private final int numberOfTrials;\n     /** The probability of success. */\n-    private double probabilityOfSuccess;\n+    private final double probabilityOfSuccess;\n \n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n      *\n-     * @param trials the number of trials.\n-     * @param p the probability of success.\n+     * @param trials Number of trials.\n+     * @param p Probability of success.\n+     * @throws NotPositiveException if {@code trials < 0}.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     public BinomialDistributionImpl(int trials, double p) {\n-        super();\n-        setNumberOfTrialsInternal(trials);\n-        setProbabilityOfSuccessInternal(p);\n+        if (trials < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_TRIALS,\n+                                           trials);\n+        }\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        probabilityOfSuccess = p;\n+        numberOfTrials = trials;\n     }\n \n     /**\n-     * Access the number of trials for this distribution.\n-     *\n-     * @return the number of trials.\n+     * {@inheritDoc}\n      */\n     public int getNumberOfTrials() {\n         return numberOfTrials;\n     }\n \n     /**\n-     * Access the probability of success for this distribution.\n-     *\n-     * @return the probability of success.\n+     * {@inheritDoc}\n      */\n     public double getProbabilityOfSuccess() {\n         return probabilityOfSuccess;\n     }\n \n     /**\n-     * Change the number of trials for this distribution.\n-     *\n-     * @param trials the new number of trials.\n-     * @throws IllegalArgumentException if <code>trials</code> is not a valid\n-     *             number of trials.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNumberOfTrials(int trials) {\n-        setNumberOfTrialsInternal(trials);\n-    }\n-    /**\n-     * Change the number of trials for this distribution.\n-     *\n-     * @param trials the new number of trials.\n-     * @throws IllegalArgumentException if <code>trials</code> is not a valid\n-     *             number of trials.\n-     */\n-    private void setNumberOfTrialsInternal(int trials) {\n-        if (trials < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NEGATIVE_NUMBER_OF_TRIALS, trials);\n-        }\n-        numberOfTrials = trials;\n-    }\n-\n-    /**\n-     * Change the probability of success for this distribution.\n-     *\n-     * @param p the new probability of success.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *             probability.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setProbabilityOfSuccess(double p) {\n-        setProbabilityOfSuccessInternal(p);\n-    }\n-    /**\n-     * Change the probability of success for this distribution.\n-     *\n-     * @param p the new probability of success.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *             probability.\n-     */\n-    private void setProbabilityOfSuccessInternal(double p) {\n-        if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n-        }\n-        probabilityOfSuccess = p;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n-     *         <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n-     *         <code>p</code>\n+     * @param p Desired probability for the critical value\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &le; x).\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n      *\n-     * @param x the value at which the PDF is evaluated.\n+     * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be computed\n-     *             due to convergence or other numerical errors.\n+     * due to convergence or other numerical errors.\n      */\n     @Override\n     public double cumulativeProbability(int x) throws MathException {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X = x).\n+     * For this distribution, {@code X}, this method returns {@code P(X = x)}.\n      *\n-     * @param x the value at which the PMF is evaluated.\n+     * @param x Value at which the PMF is evaluated.\n      * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns the largest x, such that\n-     * P(X &le; x) &le; <code>p</code>.\n-     * <p>\n-     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code> for\n-     * p=1.\n-     * </p>\n+     * For this distribution, {@code X}, this method returns the largest\n+     * {@code x}, such that {@code P(X < x) p}.\n+     * It will return -1 when p = 0 and {@code Integer.MAX_VALUE} when p = 1.\n      *\n-     * @param p the desired probability\n-     * @return the largest x such that P(X &le; x) <= p\n+     * @param p Desired probability.\n+     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *             computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p < 0 or p > 1\n+     * computed due to convergence or other numerical errors.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n     public int inverseCumulativeProbability(final double p)\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class CauchyDistributionImpl extends AbstractContinuousDistribution\n-        implements CauchyDistribution, Serializable {\n-    /**\n-     * Default inverse cumulative probability accuracy\n+    implements CauchyDistribution, Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n     /** The median of this distribution. */\n-    private double median = 0;\n+    private final double median;\n     /** The scale of this distribution. */\n-    private double scale = 1;\n+    private final double scale;\n     /** Inverse cumulative probability accuracy */\n     private final double solverAbsoluteAccuracy;\n \n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8352658048349159782L;\n     /** Internal Gamma distribution. */\n-    private GammaDistribution gamma;\n+    private final GammaDistribution gamma;\n     /** Inverse cumulative probability accuracy */\n     private final double solverAbsoluteAccuracy;\n \n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n      * @return the pdf at point {@code x}.\n      */\n     double density(double x);\n+\n+    /**\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed New seed.\n+     * @since 3.0\n+     */\n+    void reseedRandomGenerator(long seed);\n+\n+    /**\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n+     * @throws MathException if an error occurs generating the random value.\n+     * @since 3.0\n+     */\n+    double sample() throws MathException;\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     *\n+     * @param sampleSize number of random values to generate.\n+     * @return an array representing the random sample.\n+     * @throws MathException if an error occurs generating the sample.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if {@code sampleSize} is not positive.\n+     * @since 3.0\n+     */\n+    double[] sample(int sampleSize) throws MathException;\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n public class ExponentialDistributionImpl extends AbstractContinuousDistribution\n     implements ExponentialDistribution, Serializable {\n     /**\n-     * Default inverse cumulative probability accuracy\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 2401296428283614780L;\n     /** The mean of this distribution. */\n-    private double mean;\n-    /** Inverse cumulative probability accuracy */\n+    private final double mean;\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     extends AbstractContinuousDistribution\n     implements FDistribution, Serializable  {\n     /**\n-     * Default inverse cumulative probability accuracy\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -8516354193418641566L;\n-    /** The numerator degrees of freedom*/\n-    private double numeratorDegreesOfFreedom;\n-    /** The numerator degrees of freedom*/\n-    private double denominatorDegreesOfFreedom;\n-    /** Inverse cumulative probability accuracy */\n+    /** The numerator degrees of freedom. */\n+    private final double numeratorDegreesOfFreedom;\n+    /** The numerator degrees of freedom. */\n+    private final double denominatorDegreesOfFreedom;\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n  */\n public class GammaDistributionImpl extends AbstractContinuousDistribution\n     implements GammaDistribution, Serializable  {\n-\n-    /**\n-     * Default inverse cumulative probability accuracy\n+    /**\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -3239549463135430361L;\n-\n     /** The shape parameter. */\n-    private double alpha;\n-\n+    private final double alpha;\n     /** The scale parameter. */\n-    private double beta;\n-\n-    /** Inverse cumulative probability accuracy */\n+    private final double beta;\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface HypergeometricDistribution extends IntegerDistribution {\n-\n     /**\n      * Access the number of successes.\n+     *\n      * @return the number of successes.\n      */\n     int getNumberOfSuccesses();\n \n     /**\n      * Access the population size.\n+     *\n      * @return the population size.\n      */\n     int getPopulationSize();\n \n     /**\n      * Access the sample size.\n+     *\n      * @return the sample size.\n      */\n     int getSampleSize();\n-\n-    /**\n-     * Modify the number of successes.\n-     * @param num the new number of successes.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setNumberOfSuccesses(int num);\n-\n-    /**\n-     * Modify the population size.\n-     * @param size the new population size.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setPopulationSize(int size);\n-\n-    /**\n-     * Modify the sample size.\n-     * @param size the new sample size.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setSampleSize(int size);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n  * @version $Revision$ $Date$\n  */\n public class HypergeometricDistributionImpl extends AbstractIntegerDistribution\n-        implements HypergeometricDistribution, Serializable {\n-\n-    /** Serializable version identifier */\n+    implements HypergeometricDistribution, Serializable {\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -436928820673516179L;\n-\n     /** The number of successes in the population. */\n-    private int numberOfSuccesses;\n-\n+    private final int numberOfSuccesses;\n     /** The population size. */\n-    private int populationSize;\n-\n+    private final int populationSize;\n     /** The sample size. */\n-    private int sampleSize;\n-\n-    /**\n-     * Construct a new hypergeometric distribution with the given the population\n-     * size, the number of successes in the population, and the sample size.\n-     *\n-     * @param populationSize the population size.\n-     * @param numberOfSuccesses number of successes in the population.\n-     * @param sampleSize the sample size.\n+    private final int sampleSize;\n+\n+    /**\n+     * Construct a new hypergeometric distribution with the given the\n+     * population size, the number of successes in the population, and\n+     * the sample size.\n+     *\n+     * @param populationSize Population size.\n+     * @param numberOfSuccesses Number of successes in the population.\n+     * @param sampleSize Sample size.\n+     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n+     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n+     * @throws NotPositiveException if {@code populationSize < 0}.\n+     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize}.\n+     * @throws NumberIsTooLargeException if {@code sampleSize > populationSize}.\n      */\n     public HypergeometricDistributionImpl(int populationSize,\n-            int numberOfSuccesses, int sampleSize) {\n-        super();\n+                                          int numberOfSuccesses,\n+                                          int sampleSize) {\n+        if (populationSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n+                                                   populationSize);\n+        }\n+        if (numberOfSuccesses < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+                                           numberOfSuccesses);\n+        }\n+        if (sampleSize < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                                           sampleSize);\n+        }\n+\n         if (numberOfSuccesses > populationSize) {\n-            throw MathRuntimeException\n-                    .createIllegalArgumentException(\n-                            LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n-                            numberOfSuccesses, populationSize);\n+            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n+                                                numberOfSuccesses, populationSize, true);\n         }\n         if (sampleSize > populationSize) {\n-            throw MathRuntimeException\n-                    .createIllegalArgumentException(\n-                            LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n-                            sampleSize, populationSize);\n-        }\n-\n-        setPopulationSizeInternal(populationSize);\n-        setSampleSizeInternal(sampleSize);\n-        setNumberOfSuccessesInternal(numberOfSuccesses);\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &le; x).\n-     *\n-     * @param x the value at which the PDF is evaluated.\n+            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n+                                                sampleSize, populationSize, true);\n+        }\n+\n+        this.numberOfSuccesses = numberOfSuccesses;\n+        this.populationSize = populationSize;\n+        this.sampleSize = sampleSize;\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n      */\n     @Override\n     /**\n      * Return the domain for the given hypergeometric distribution parameters.\n      *\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n+     * @param n Population size.\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n      * @return a two element array containing the lower and upper bounds of the\n-     *         hypergeometric distribution.\n+     * hypergeometric distribution.\n      */\n     private int[] getDomain(int n, int m, int k) {\n         return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n-     *         <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n-     *         <code>p</code>\n+     * @param p Desired probability for the critical value\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n      * Return the lowest domain value for the given hypergeometric distribution\n      * parameters.\n      *\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n+     * @param n Population size.\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n      * @return the lowest domain value of the hypergeometric distribution.\n      */\n     private int getLowerDomain(int n, int m, int k) {\n     }\n \n     /**\n-     * Access the number of successes.\n-     *\n-     * @return the number of successes.\n+     * {@inheritDoc}\n      */\n     public int getNumberOfSuccesses() {\n         return numberOfSuccesses;\n     }\n \n     /**\n-     * Access the population size.\n-     *\n-     * @return the population size.\n+     * {@inheritDoc}\n      */\n     public int getPopulationSize() {\n         return populationSize;\n     }\n \n     /**\n-     * Access the sample size.\n-     *\n-     * @return the sample size.\n+     * {@inheritDoc}\n      */\n     public int getSampleSize() {\n         return sampleSize;\n      * Return the highest domain value for the given hypergeometric distribution\n      * parameters.\n      *\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n      * @return the highest domain value of the hypergeometric distribution.\n      */\n     private int getUpperDomain(int m, int k) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X = x).\n-     *\n-     * @param x the value at which the PMF is evaluated.\n+     * For this distribution, {@code X}, this method returns {@code P(X = x)}.\n+     *\n+     * @param x Value at which the PMF is evaluated.\n      * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n     }\n \n     /**\n-     * For the distribution, X, defined by the given hypergeometric distribution\n-     * parameters, this method returns P(X = x).\n-     *\n+     * For this distribution, {@code X}, defined by the given hypergeometric\n+     *  distribution parameters, this method returns {@code P(X = x)}.\n+     *\n+     * @param x Value at which the PMF is evaluated.\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n-     * @param x the value at which the PMF is evaluated.\n      * @return PMF for the distribution.\n      */\n     private double probability(int n, int m, int k, int x) {\n     }\n \n     /**\n-     * Modify the number of successes.\n-     *\n-     * @param num the new number of successes.\n-     * @throws IllegalArgumentException if <code>num</code> is negative.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNumberOfSuccesses(int num) {\n-        setNumberOfSuccessesInternal(num);\n-    }\n-    /**\n-     * Modify the number of successes.\n-     *\n-     * @param num the new number of successes.\n-     * @throws IllegalArgumentException if <code>num</code> is negative.\n-     */\n-    private void setNumberOfSuccessesInternal(int num) {\n-        if (num < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES, num);\n-        }\n-        numberOfSuccesses = num;\n-    }\n-\n-    /**\n-     * Modify the population size.\n-     *\n-     * @param size the new population size.\n-     * @throws IllegalArgumentException if <code>size</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setPopulationSize(int size) {\n-        setPopulationSizeInternal(size);\n-    }\n-    /**\n-     * Modify the population size.\n-     *\n-     * @param size the new population size.\n-     * @throws IllegalArgumentException if <code>size</code> is not positive.\n-     */\n-    private void setPopulationSizeInternal(int size) {\n-        if (size <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE, size);\n-        }\n-        populationSize = size;\n-    }\n-\n-    /**\n-     * Modify the sample size.\n-     *\n-     * @param size the new sample size.\n-     * @throws IllegalArgumentException if <code>size</code> is negative.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setSampleSize(int size) {\n-        setSampleSizeInternal(size);\n-    }\n-    /**\n-     * Modify the sample size.\n-     *\n-     * @param size the new sample size.\n-     * @throws IllegalArgumentException if <code>size</code> is negative.\n-     */\n-    private void setSampleSizeInternal(int size) {\n-        if (size < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, size);\n-        }\n-        sampleSize = size;\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &ge; x).\n-     *\n-     * @param x the value at which the CDF is evaluated.\n-     * @return upper tail CDF for this distribution.\n+     * For this distribution, {@code X}, this method returns {@code P(X >= x)}.\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return the upper tail CDF for this distribution.\n      * @since 1.1\n      */\n     public double upperCumulativeProbability(int x) {\n         } else if (x > domain[1]) {\n             ret = 0.0;\n         } else {\n-            ret = innerCumulativeProbability(domain[1], x, -1, populationSize, numberOfSuccesses, sampleSize);\n-        }\n-\n-        return ret;\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(x0 &le; X &le; x1). This\n-     * probability is computed by summing the point probabilities for the values\n-     * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx.\n-     *\n-     * @param x0 the inclusive, lower bound\n-     * @param x1 the inclusive, upper bound\n-     * @param dx the direction of summation. 1 indicates summing from x0 to x1.\n-     *            0 indicates summing from x1 to x0.\n+            ret = innerCumulativeProbability(domain[1], x, -1, populationSize,\n+                                             numberOfSuccesses, sampleSize);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns\n+     * {@code P(x0 <= X <= x1)}.\n+     * This probability is computed by summing the point probabilities for the\n+     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n+     * {@code dx}.\n+     *\n+     * @param x0 Inclusive lower bound.\n+     * @param x1 Inclusive upper bound.\n+     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n+     * 0 indicates summing from x1 to x0).\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n-     * @return P(x0 &le; X &le; x1).\n-     */\n-    private double innerCumulativeProbability(int x0, int x1, int dx, int n,\n-            int m, int k) {\n+     * @return {@code P(x0 <= X <= x1)}.\n+     */\n+    private double innerCumulativeProbability(int x0, int x1, int dx,\n+                                              int n, int m, int k) {\n         double ret = probability(n, m, k, x0);\n         while (x0 != x1) {\n             x0 += dx;\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n  */\n public interface IntegerDistribution extends DiscreteDistribution {\n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X = x). In other words, this\n-     * method represents the probability mass function for the distribution.\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X = x)}. In other\n+     * words, this method represents the probability mass function for the\n+     * distribution.\n      *\n-     * @param x the value at which the probability density function is evaluated.\n-     * @return the value of the probability density function at x\n+     * @param x Value at which the probability density function is evaluated.\n+     * @return the value of the probability density function at {@code x}.\n      */\n     double probability(int x);\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X &le; x).  In other words,\n-     * this method represents the probability distribution function, or PDF\n-     * for the distribution.\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X < x)}.  In other\n+     * words, this method represents the probability distribution function, or\n+     * PDF for the distribution.\n      *\n-     * @param x the value at which the PDF is evaluated.\n+     * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * @throws MathException if the cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n      */\n     double cumulativeProbability(int x) throws MathException;\n \n     /**\n-     * For this distribution, X, this method returns P(x0 &le; X &le; x1).\n+     * For this distribution, {@code X}, this method returns\n+     * {@code P(x0 < X < x1)}.\n+     *\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n      * @return the cumulative probability.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if x0 > x1\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if {@code x0 > x1}.\n      */\n     double cumulativeProbability(int x0, int x1) throws MathException;\n \n     /**\n-     * For this distribution, X, this method returns the largest x such that\n-     * P(X &le; x) <= p.\n-     * <p>\n-     * Note that this definition implies: <ul>\n-     * <li> If there is a minimum value, <code>m</code>, with positive\n-     * probability under (the density of) X, then <code>m - 1</code> is\n-     * returned by <code>inverseCumulativeProbability(0).</code>  If there is\n-     * no such value <code>m,  Integer.MIN_VALUE</code> is\n-     * returned.</li>\n-     * <li> If there is a maximum value, <code>M</code>, such that\n-     * P(X &le; M) =1, then <code>M</code> is returned by\n-     * <code>inverseCumulativeProbability(1).</code>\n-     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is\n-     * returned.</li></ul></p>\n+     * For this distribution, {@code X}, this method returns the largest\n+     * {@code x} such that {@code P(X < x) <= p}.\n+     * <br/>\n+     * Note that this definition implies:\n+     * <ul>\n+     *  <li> If there is a minimum value, {@code m}, with positive\n+     *   probability under (the density of) {@code X}, then {@code m - 1} is\n+     *   returned by {@code inverseCumulativeProbability(0).}  If there is\n+     *   no such value {@code m},  {@code Integer.MIN_VALUE} is returned.\n+     *  </li>\n+     *  <li> If there is a maximum value, {@code M}, such that\n+     *   {@code P(X < M) = 1}, then {@code M} is returned by\n+     *   {@code inverseCumulativeProbability(1)}.\n+     *   If there is no such value, {@code M}, {@code Integer.MAX_VALUE} is\n+     *   returned.\n+     *  </li>\n+     * </ul>\n      *\n-     * @param p the cumulative probability.\n-     * @return the largest x such that P(X &le; x) <= p\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p is not between 0 and 1 (inclusive)\n+     * @param p Cumulative probability.\n+     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n+     * @throws MathException if the inverse cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if {@code p} is not between 0 and 1\n+     * (inclusive).\n      */\n     int inverseCumulativeProbability(double p) throws MathException;\n+\n+    /**\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed New seed.\n+     * @since 3.0\n+     */\n+    void reseedRandomGenerator(long seed);\n+\n+    /**\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n+     * @throws MathException if an error occurs generating the random value.\n+     * @since 3.0\n+     */\n+    int sample() throws MathException;\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     *\n+     * @param sampleSize number of random values to generate.\n+     * @return an array representing the random sample.\n+     * @throws MathException if an error occurs generating the sample.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if {@code sampleSize} is not positive.\n+     * @since 3.0\n+     */\n+    int[] sample(int sampleSize) throws MathException;\n }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n public class NormalDistributionImpl extends AbstractContinuousDistribution\n         implements NormalDistribution, Serializable {\n     /**\n-     * Default inverse cumulative probability accuracy\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** &sqrt;(2 &pi;) */\n     private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n     /** Mean of this distribution. */\n-    private double mean = 0;\n+    private final double mean;\n     /** Standard deviation of this distribution. */\n-    private double standardDeviation = 1;\n+    private final double standardDeviation;\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n     /**\n      * Access the number of successes for this distribution.\n      *\n-     * @return the number of successes\n+     * @return the number of successes.\n      */\n     int getNumberOfSuccesses();\n \n     /**\n      * Access the probability of success for this distribution.\n      *\n-     * @return the probability of success\n+     * @return the probability of success.\n      */\n     double getProbabilityOfSuccess();\n-\n-    /**\n-     * Change the number of successes for this distribution.\n-     *\n-     * @param successes the new number of successes\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setNumberOfSuccesses(int successes);\n-\n-    /**\n-     * Change the probability of success for this distribution.\n-     *\n-     * @param p the new probability of success\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setProbabilityOfSuccess(double p);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.MathUtils;\n  */\n public class PascalDistributionImpl extends AbstractIntegerDistribution\n     implements PascalDistribution, Serializable {\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = 6751309484392813623L;\n-\n-    /** The number of successes */\n-    private int numberOfSuccesses;\n-\n-    /** The probability of success */\n-    private double probabilityOfSuccess;\n+    /** The number of successes. */\n+    private final int numberOfSuccesses;\n+    /** The probability of success. */\n+    private final double probabilityOfSuccess;\n \n     /**\n      * Create a Pascal distribution with the given number of trials and\n      * probability of success.\n-     * @param r the number of successes\n-     * @param p the probability of success\n+     *\n+     * @param r Number of successes.\n+     * @param p Probability of success.\n      */\n     public PascalDistributionImpl(int r, double p) {\n-        super();\n-        setNumberOfSuccessesInternal(r);\n-        setProbabilityOfSuccessInternal(p);\n+        if (r < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+                                           r);\n+        }\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        numberOfSuccesses = r;\n+        probabilityOfSuccess = p;\n     }\n \n     /**\n-     * Access the number of successes for this distribution.\n-     * @return the number of successes\n+     * {@inheritDoc}\n      */\n     public int getNumberOfSuccesses() {\n         return numberOfSuccesses;\n     }\n \n     /**\n-     * Access the probability of success for this distribution.\n-     * @return the probability of success\n+     * {@inheritDoc}\n      */\n     public double getProbabilityOfSuccess() {\n         return probabilityOfSuccess;\n     }\n \n     /**\n-     * Change the number of successes for this distribution.\n-     * @param successes the new number of successes\n-     * @throws IllegalArgumentException if <code>successes</code> is not\n-     *         positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNumberOfSuccesses(int successes) {\n-        setNumberOfSuccessesInternal(successes);\n-    }\n-    /**\n-     * Change the number of successes for this distribution.\n-     * @param successes the new number of successes\n-     * @throws IllegalArgumentException if <code>successes</code> is not\n-     *         positive.\n-     */\n-    private void setNumberOfSuccessesInternal(int successes) {\n-        if (successes < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES,\n-                  successes);\n-        }\n-        numberOfSuccesses = successes;\n-    }\n-\n-    /**\n-     * Change the probability of success for this distribution.\n-     * @param p the new probability of success\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setProbabilityOfSuccess(double p) {\n-        setProbabilityOfSuccessInternal(p);\n-    }\n-    /**\n-     * Change the probability of success for this distribution.\n-     * @param p the new probability of success\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n-     */\n-    private void setProbabilityOfSuccessInternal(double p) {\n-        if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n-        }\n-        probabilityOfSuccess = p;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a PDF root.\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n-     *         <code>p</code>\n+     *\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a PDF root.\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n-     *         <code>p</code>\n+     *\n+     * @param p Desired probability for the critical value\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &le; x).\n-     * @param x the value at which the PDF is evaluated\n-     * @return PDF for this distribution\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * @param x Value at which the PDF is evaluated.\n+     * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be computed\n-     *         due to convergence or other numerical errors\n+     * due to convergence or other numerical errors.\n      */\n     @Override\n     public double cumulativeProbability(int x) throws MathException {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X = x).\n-     * @param x the value at which the PMF is evaluated\n-     * @return PMF for this distribution\n+     * For this distribution, {@code X}, this method returns {@code P(X = x)}.\n+     *\n+     * @param x Value at which the PMF is evaluated.\n+     * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n         double ret;\n     }\n \n     /**\n-     * For this distribution, X, this method returns the largest x, such that\n-     * P(X &le; x) &le; <code>p</code>.\n-     * <p>\n-     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code>\n-     * for p=1.</p>\n-     * @param p the desired probability\n-     * @return the largest x such that P(X &le; x) <= p\n+     * For this distribution, {@code X}, this method returns the largest\n+     * {@code x}, such that {@code P(X < x) p}.\n+     * It will return -1 when p = 0 and {@code Integer.MAX_VALUE} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return the largest {@code x} such that {@code P(X < x) <= p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p < 0 or p > 1\n+     * computed due to convergence or other numerical errors.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n     public int inverseCumulativeProbability(final double p)\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class PoissonDistributionImpl extends AbstractIntegerDistribution\n-        implements PoissonDistribution, Serializable {\n-\n+    implements PoissonDistribution, Serializable {\n     /**\n      * Default maximum number of iterations for cumulative probability calculations.\n      * @since 2.1\n      */\n     public static final int DEFAULT_MAX_ITERATIONS = 10000000;\n-\n     /**\n      * Default convergence criterion.\n      * @since 2.1\n      */\n-    public static final double DEFAULT_EPSILON = 1E-12;\n-\n-    /** Serializable version identifier */\n+    public static final double DEFAULT_EPSILON = 1e-12;\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -3349935121172596109L;\n-\n     /** Distribution used to compute normal approximation. */\n-    private NormalDistribution normal;\n-\n-    /**\n-     * Holds the Poisson mean for the distribution.\n-     */\n-    private double mean;\n-\n+    private final NormalDistribution normal;\n+    /** Mean of the distribution. */\n+    private final double mean;\n     /**\n      * Maximum number of iterations for cumulative probability.\n      *\n      * Cumulative probabilities are estimated using either Lanczos series approximation of\n      * Gamma#regularizedGammaP or continued fraction approximation of Gamma#regularizedGammaQ.\n      */\n-    private int maxIterations = DEFAULT_MAX_ITERATIONS;\n-\n+    private final int maxIterations;\n     /**\n      * Convergence criterion for cumulative probability.\n      */\n-    private double epsilon = DEFAULT_EPSILON;\n+    private final double epsilon;\n \n     /**\n      * Create a new Poisson distribution with the given the mean. The mean value\n      * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n      *\n      * @param p the Poisson mean\n-     * @throws IllegalArgumentException if p &le; 0\n+     * @throws NotStrictlyPositiveException if {@code p <= 0}.\n      */\n     public PoissonDistributionImpl(double p) {\n         this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n      * Create a new Poisson distribution with the given mean, convergence criterion\n      * and maximum number of iterations.\n      *\n-     * @param p the Poisson mean\n-     * @param epsilon the convergence criteria for cumulative probabilites\n-     * @param maxIterations the maximum number of iterations for cumulative probabilites\n+     * @param p Poisson mean.\n+     * @param epsilon Convergence criterion for cumulative probabilities.\n+     * @param maxIterations the maximum number of iterations for cumulative\n+     * probabilities.\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n     /**\n      * Create a new Poisson distribution with the given mean and convergence criterion.\n      *\n-     * @param p the Poisson mean\n-     * @param epsilon the convergence criteria for cumulative probabilites\n+     * @param p Poisson mean.\n+     * @param epsilon Convergence criterion for cumulative probabilities.\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon) {\n     /**\n      * Create a new Poisson distribution with the given mean and maximum number of iterations.\n      *\n-     * @param p the Poisson mean\n-     * @param maxIterations the maximum number of iterations for cumulative probabilites\n+     * @param p Poisson mean.\n+     * @param maxIterations Maximum number of iterations for cumulative probabilities.\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, int maxIterations) {\n     }\n \n     /**\n-     * Get the Poisson mean for the distribution.\n-     *\n-     * @return the Poisson mean for the distribution.\n+     * {@inheritDoc}\n      */\n     public double getMean() {\n         return mean;\n     }\n \n     /**\n-     * The probability mass function P(X = x) for a Poisson distribution.\n-     *\n-     * @param x the value at which the probability density function is\n-     *            evaluated.\n-     * @return the value of the probability mass function at x\n+     * The probability mass function {@code P(X = x)} for a Poisson distribution.\n+     *\n+     * @param x Value at which the probability density function is evaluated.\n+     * @return the value of the probability mass function at {@code x}.\n      */\n     public double probability(int x) {\n         double ret;\n     }\n \n     /**\n-     * The probability distribution function P(X <= x) for a Poisson\n+     * The probability distribution function {@code P(X <= x)} for a Poisson\n      * distribution.\n      *\n-     * @param x the value at which the PDF is evaluated.\n-     * @return Poisson distribution function evaluated at x\n-     * @throws MathException if the cumulative probability can not be computed\n-     *             due to convergence or other numerical errors.\n+     * @param x Value at which the PDF is evaluated.\n+     * @return the Poisson distribution function evaluated at {@code x}.\n+     * @throws MathException if the cumulative probability cannot be computed\n+     * due to convergence or other numerical errors.\n      */\n     @Override\n     public double cumulativeProbability(int x) throws MathException {\n \n     /**\n      * Calculates the Poisson distribution function using a normal\n-     * approximation. The <code>N(mean, sqrt(mean))</code> distribution is used\n+     * approximation. The {@code N(mean, sqrt(mean))} distribution is used\n      * to approximate the Poisson distribution.\n-     * <p>\n-     * The computation uses \"half-correction\" -- evaluating the normal\n-     * distribution function at <code>x + 0.5</code>\n-     * </p>\n-     *\n-     * @param x the upper bound, inclusive\n+     * The computation uses \"half-correction\" (evaluating the normal\n+     * distribution function at {@code x + 0.5}).\n+     *\n+     * @param x Upper bound, inclusive.\n      * @return the distribution function value calculated using a normal\n-     *         approximation\n+     * approximation.\n      * @throws MathException if an error occurs computing the normal\n-     *             approximation\n+     * approximation.\n      */\n     public double normalApproximateProbability(int x) throws MathException {\n         // calculate the probability using half-correction\n \n     /**\n      * Generates a random value sampled from this distribution.\n-     *\n-     * <p><strong>Algorithm Description</strong>:\n-     * <ul><li> For small means, uses simulation of a Poisson process\n-     * using Uniform deviates, as described\n-     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li><\n-     *\n-     * <li> For large means, uses the rejection algorithm described in <br/>\n-     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n-     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n-     *\n-     * @return random value\n+     * <br/>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul>\n+     *  <li>For small means, uses simulation of a Poisson process\n+     *   using Uniform deviates, as described\n+     *   <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here</a>.\n+     *   The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+     *  </li>\n+     *  <li>For large means, uses the rejection algorithm described in\n+     *   <quote>\n+     *    Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     *    <strong>Computing</strong> vol. 26 pp. 197-207.\n+     *   </quote>\n+     *  </li>\n+     * </ul>\n+     *\n+     * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value\n+     * @throws MathException if an error occurs generating the random value.\n      */\n     @Override\n     public int sample() throws MathException {\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root. This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain lower bound\n+     * @param p Desired probability for the critical value.\n+     * @return the domain lower bound.\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root. This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain upper bound\n+     * @param p Desired probability for the critical value.\n+     * @return the domain upper bound.\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -5852615386664158222L;\n     /** The degrees of freedom. */\n-    private double degreesOfFreedom;\n+    private final double degreesOfFreedom;\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class WeibullDistributionImpl extends AbstractContinuousDistribution\n-        implements WeibullDistribution, Serializable {\n-    /**\n-     * Default inverse cumulative probability accuracy\n+    implements WeibullDistribution, Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = 8589540077390120676L;\n     /** The shape parameter. */\n-    private double shape;\n+    private final double shape;\n     /** The scale parameter. */\n-    private double scale;\n+    private final double scale;\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface ZipfDistribution extends IntegerDistribution {\n-\n     /**\n      * Get the number of elements (e.g. corpus size) for the distribution.\n      *\n     int getNumberOfElements();\n \n     /**\n-     * Set the number of elements (e.g. corpus size) for the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n-     *\n-     * @param n the number of elements\n-     * @throws IllegalArgumentException if n &le; 0\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setNumberOfElements(int n);\n-\n-    /**\n      * Get the exponent characterising the distribution.\n      *\n      * @return the exponent\n      */\n     double getExponent();\n-\n-    /**\n-     * Set the exponent characterising the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n-     *\n-     * @param s the exponent\n-     * @throws IllegalArgumentException if s &le; 0.0\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setExponent(double s);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n  */\n public class ZipfDistributionImpl extends AbstractIntegerDistribution\n     implements ZipfDistribution, Serializable {\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -140627372283420404L;\n-\n     /** Number of elements. */\n-    private int numberOfElements;\n-\n+    private final int numberOfElements;\n     /** Exponent parameter of the distribution. */\n-    private double exponent;\n+    private final double exponent;\n \n     /**\n      * Create a new Zipf distribution with the given number of elements and\n-     * exponent. Both values must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n+     * exponent.\n      *\n-     * @param numberOfElements the number of elements\n-     * @param exponent the exponent\n-     * @exception IllegalArgumentException if n &le; 0 or s &le; 0.0\n+     * @param numberOfElements Number of elements.\n+     * @param exponent Exponent.\n+     * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n+     * or {@code exponent <= 0}.\n      */\n-    public ZipfDistributionImpl(final int numberOfElements, final double exponent)\n-        throws IllegalArgumentException {\n-        setNumberOfElementsInternal(numberOfElements);\n-        setExponentInternal(exponent);\n+    public ZipfDistributionImpl(final int numberOfElements,\n+                                final double exponent) {\n+        if (numberOfElements <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n+                                                   numberOfElements);\n+        }\n+        if (exponent <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.EXPONENT,\n+                                                   exponent);\n+        }\n+\n+        this.numberOfElements = numberOfElements;\n+        this.exponent = exponent;\n     }\n \n     /**\n-     * Get the number of elements (e.g. corpus size) for the distribution.\n-     *\n-     * @return the number of elements\n+     * {@inheritDoc}\n      */\n     public int getNumberOfElements() {\n         return numberOfElements;\n     }\n \n     /**\n-     * Set the number of elements (e.g. corpus size) for the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n-     *\n-     * @param n the number of elements\n-     * @exception IllegalArgumentException if n &le; 0\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNumberOfElements(final int n) {\n-        setNumberOfElementsInternal(n);\n-    }\n-    /**\n-     * Set the number of elements (e.g. corpus size) for the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n-     *\n-     * @param n the number of elements\n-     * @exception IllegalArgumentException if n &le; 0\n-     */\n-    private void setNumberOfElementsInternal(final int n)\n-        throws IllegalArgumentException {\n-        if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INSUFFICIENT_DIMENSION, n, 0);\n-        }\n-        this.numberOfElements = n;\n-    }\n-\n-    /**\n-     * Get the exponent characterising the distribution.\n-     *\n-     * @return the exponent\n+     * {@inheritDoc}\n      */\n     public double getExponent() {\n         return exponent;\n     }\n \n     /**\n-     * Set the exponent characterising the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n+     * The probability mass function {@code P(X = x)} for a Zipf distribution.\n      *\n-     * @param s the exponent\n-     * @exception IllegalArgumentException if s &le; 0.0\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setExponent(final double s) {\n-        setExponentInternal(s);\n-    }\n-    /**\n-     * Set the exponent characterising the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgumentException</code> is thrown.\n-     *\n-     * @param s the exponent\n-     * @exception IllegalArgumentException if s &le; 0.0\n-     */\n-    private void setExponentInternal(final double s)\n-        throws IllegalArgumentException {\n-        if (s <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POSITIVE_EXPONENT,\n-                    s);\n-        }\n-        this.exponent = s;\n-    }\n-\n-    /**\n-     * The probability mass function P(X = x) for a Zipf distribution.\n-     *\n-     * @param x the value at which the probability density function is evaluated.\n-     * @return the value of the probability mass function at x\n+     * @param x Value at which the probability density function is evaluated.\n+     * @return the value of the probability mass function at {@code x}.\n      */\n     public double probability(final int x) {\n         if (x <= 0 || x > numberOfElements) {\n         }\n \n         return (1.0 / FastMath.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n-\n     }\n \n     /**\n-     * The probability distribution function P(X <= x) for a Zipf distribution.\n+     * The probability distribution function {@code P(X <= x)} for a\n+     * Zipf distribution.\n      *\n-     * @param x the value at which the PDF is evaluated.\n-     * @return Zipf distribution function evaluated at x\n+     * @param x Value at which the PDF is evaluated.\n+     * @return Zipf distribution function evaluated at {@code x}.\n      */\n     @Override\n     public double cumulativeProbability(final int x) {\n         }\n \n         return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);\n-\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected int getDomainLowerBound(final double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a PDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected int getDomainUpperBound(final double p) {\n         return numberOfElements;\n     }\n \n-\n     /**\n      * Calculates the Nth generalized harmonic number. See\n      * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic\n      * Series</a>.\n      *\n-     * @param n the term in the series to calculate (must be &ge; 1)\n-     * @param m the exponent; special case m == 1.0 is the harmonic series\n-     * @return the nth generalized harmonic number\n+     * @param n Term in the series to calculate (must be larger than 1)\n+     * @param m Exponent (special case {@code m = 1} is the harmonic series).\n+     * @return the n<sup>th</sup> generalized harmonic number.\n      */\n     private double generalizedHarmonic(final int n, final double m) {\n         double value = 0;\n         }\n         return value;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES(\"instance of class {0} not comparable to existing values\"),\n     INSUFFICIENT_DATA_FOR_T_STATISTIC(\"insufficient data for t statistic, needs at least 2, got {0}\"),\n     INSUFFICIENT_DIMENSION(\"insufficient dimension {0}, must be at least {1}\"),\n+    DIMENSION(\"dimension ({0})\"), /* keep */\n     INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE(\"sample contains {0} observed points, at least {1} are required\"),\n     INSUFFICIENT_ROWS_AND_COLUMNS(\"insufficient data: only {0} rows and {1} columns.\"),\n     INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT(\"{0} method needs at least one previous point\"),\n     NEGATIVE_ELEMENT_AT_2D_INDEX(\"element ({0}, {1}) is negative: {2}\"),\n     NEGATIVE_ELEMENT_AT_INDEX(\"element {0} is negative: {1}\"),\n     NEGATIVE_NUMBER_OF_SUCCESSES(\"number of successes must be non-negative ({0})\"),\n+    NUMBER_OF_SUCCESSES(\"number of successes ({0})\"), /* keep */\n     NEGATIVE_NUMBER_OF_TRIALS(\"number of trials must be non-negative ({0})\"),\n+    NUMBER_OF_TRIALS(\"number of trials ({0})\"),\n     NEGATIVE_ROBUSTNESS_ITERATIONS(\"the number of robustness iterations must be non-negative, but got {0}\"),\n     START_POSITION(\"start position ({0})\"), /* keep */\n     NON_CONVERGENT_CONTINUED_FRACTION(\"Continued fraction convergents failed to converge for value {0}\"),\n     NOT_POSITIVE_DEGREES_OF_FREEDOM(\"degrees of freedom must be positive ({0})\"),\n     NOT_POSITIVE_ELEMENT_AT_INDEX(\"element {0} is not positive: {1}\"),\n     NOT_POSITIVE_EXPONENT(\"invalid exponent {0} (must be positive)\"),\n+    EXPONENT(\"exponent ({0})\"), /* keep */\n     NOT_POSITIVE_LENGTH(\"length must be positive ({0})\"),\n     LENGTH(\"length ({0})\"), /* keep */\n     NOT_POSITIVE_MEAN(\"mean must be positive ({0})\"),\n     PERMUTATION_SIZE(\"permutation size ({0}\"), /* keep */\n     NOT_POSITIVE_POISSON_MEAN(\"the Poisson mean must be positive ({0})\"),\n     NOT_POSITIVE_POPULATION_SIZE(\"population size must be positive ({0})\"),\n+    POPULATION_SIZE(\"population size ({0})\"), /* keep */\n     NOT_POSITIVE_ROW_DIMENSION(\"invalid row dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_SAMPLE_SIZE(\"sample size must be positive ({0})\"),\n     NOT_POSITIVE_SCALE(\"scale must be positive ({0})\"),\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n \n /**\n  * Test cases for HyperGeometriclDistribution.\n         verifyInverseCumulativeProbabilities();\n     }\n \n-    public void testPopulationSize() {\n-        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);\n-        try {\n-            dist.setPopulationSize(-1);\n-            fail(\"negative population size.  IllegalArgumentException expected\");\n-        } catch(IllegalArgumentException ex) {\n-        }\n-\n-        dist.setPopulationSize(10);\n-        assertEquals(10, dist.getPopulationSize());\n+    public void testPreconditions() {\n+        HypergeometricDistribution dist;\n+        try {\n+            dist = new HypergeometricDistributionImpl(0, 3, 5);\n+            fail(\"negative population size. NotStrictlyPositiveException expected\");\n+        } catch(NotStrictlyPositiveException ex) {\n+            // Expected.\n+        }\n+        try {\n+            dist = new HypergeometricDistributionImpl(5, -1, 5);\n+            fail(\"negative number of successes. NotPositiveException expected\");\n+        } catch(NotPositiveException ex) {\n+            // Expected.\n+        }\n+        try {\n+            dist = new HypergeometricDistributionImpl(5, 3, -1);\n+            fail(\"negative sample size. NotPositiveException expected\");\n+        } catch(NotPositiveException ex) {\n+            // Expected.\n+        }\n+        try {\n+            dist = new HypergeometricDistributionImpl(5, 6, 5);\n+            fail(\"numberOfSuccesses > populationSize. NumberIsTooLargeException expected\");\n+        } catch(NumberIsTooLargeException ex) {\n+            // Expected.\n+        }\n+        try {\n+            dist = new HypergeometricDistributionImpl(5, 3, 6);\n+            fail(\"sampleSize > populationSize. NumberIsTooLargeException expected\");\n+        } catch(NumberIsTooLargeException ex) {\n+            // Expected.\n+        }\n+    }\n+\n+    public void testAccessors() {\n+        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5, 3, 4);\n+        assertEquals(5, dist.getPopulationSize());\n+        assertEquals(3, dist.getNumberOfSuccesses());\n+        assertEquals(4, dist.getSampleSize());\n     }\n \n     public void testLargeValues() {\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+\n /**\n  * Test cases for {@link ZipfDistribution}.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n public class ZipfDistributionTest extends IntegerDistributionAbstractTest {\n     public ZipfDistributionTest(String name) {\n         super(name);\n+    }\n+\n+    public void testPreconditions() {\n+        ZipfDistribution dist;\n+        try {\n+            dist = new ZipfDistributionImpl(0, 1);\n+            fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n+        try {\n+            dist = new ZipfDistributionImpl(1, 0);\n+            fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n     }\n \n     //-------------- Implementations for abstract methods -----------------------", "timestamp": 1285937176, "metainfo": ""}