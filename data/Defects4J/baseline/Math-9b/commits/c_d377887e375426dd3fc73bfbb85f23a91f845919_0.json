{"sha": "d377887e375426dd3fc73bfbb85f23a91f845919", "log": "Use the new differentation API for all optimizers.  The older API is still supported as of version 3.1, but is implemented by wrapping the user function into the new API and then calling the new code.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math3.optimization.general;\n \n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math3.analysis.FunctionUtils;\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.analysis.differentiation.JacobianFunction;\n import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.linear.QRDecomposition;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.QRDecomposition;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n     /** Cost value (square root of the sum of the residuals). */\n     protected double cost;\n     /** Objective function derivatives. */\n-    private MultivariateMatrixFunction jF;\n+    private MultivariateDifferentiableVectorFunction jF;\n     /** Number of evaluations of the Jacobian. */\n     private int jacobianEvaluations;\n \n      */\n     protected void updateJacobian() {\n         ++jacobianEvaluations;\n-        weightedResidualJacobian = jF.value(point);\n-        if (weightedResidualJacobian.length != rows) {\n-            throw new DimensionMismatchException(weightedResidualJacobian.length, rows);\n+\n+        DerivativeStructure[] dsPoint = new DerivativeStructure[point.length];\n+        for (int i = 0; i < point.length; ++i) {\n+            dsPoint[i] = new DerivativeStructure(point.length, 1, i, point[i]);\n+        }\n+        DerivativeStructure[] dsValue = jF.value(dsPoint);\n+        if (dsValue.length != rows) {\n+            throw new DimensionMismatchException(dsValue.length, rows);\n+        }\n+        for (int i = 0; i < rows; ++i) {\n+            int[] orders = new int[point.length];\n+            for (int j = 0; j < point.length; ++j) {\n+                orders[j] = 1;\n+                weightedResidualJacobian[i][j] = dsValue[i].getPartialDerivative(orders);\n+                orders[j] = 0;\n+            }\n         }\n \n         final double[] residualsWeights = getWeightRef();\n                                          final DifferentiableMultivariateVectorFunction f,\n                                          final double[] target, final double[] weights,\n                                          final double[] startPoint) {\n-        // Reset counter.\n-        jacobianEvaluations = 0;\n-\n-        // Store least squares problem characteristics.\n-        jF = f.jacobian();\n-\n-        // Arrays shared with the other private methods.\n-        point = startPoint.clone();\n-        rows = target.length;\n-        cols = point.length;\n-\n-        weightedResidualJacobian = new double[rows][cols];\n-        this.weightedResiduals = new double[rows];\n-\n-        cost = Double.POSITIVE_INFINITY;\n-\n-        return optimizeInternal(maxEval, f, target, weights, startPoint);\n+        return optimize(maxEval, FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n+                        target, weights, startPoint);\n     }\n \n     /**\n         jacobianEvaluations = 0;\n \n         // Store least squares problem characteristics.\n-        jF = new JacobianFunction(f);\n+        jF = f;\n \n         // Arrays shared with the other private methods.\n         point = startPoint.clone();", "timestamp": 1351107608, "metainfo": ""}