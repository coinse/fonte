{"sha": "2618bdbc0317bf317578609b8f5737057651aee2", "log": "allow switching functions to trigger FunctionEvaluationException let the low level errors in switching functions find their way to upper level  ", "commit": "\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n package org.apache.commons.math;\n \n /**\n- * Exeption thrown when an error occurs evaluating a function.\n+ * Exception thrown when an error occurs evaluating a function.\n  * <p>\n  * Maintains an <code>argument</code> property holding the input value that\n  * caused the function evaluation to fail.\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n    */\n   public void addSwitchingFunction(SwitchingFunction function,\n                                    double maxCheckInterval,\n-                                   double convergence) {\n-    switchesHandler.add(function, maxCheckInterval, convergence);\n+                                   double convergence,\n+                                   int maxIterationCount) {\n+    switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n    */\n   public void addSwitchingFunction(SwitchingFunction function,\n                                    double maxCheckInterval,\n-                                   double convergence);\n+                                   double convergence,\n+                                   int maxIterationCount);\n \n   /** Integrate the differential equations up to the given time.\n    * <p>This method solves an Initial Value Problem (IVP).</p>\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n    */\n   public void addSwitchingFunction(SwitchingFunction function,\n                                    double maxCheckInterval,\n-                                   double convergence) {\n-    super.addSwitchingFunction(function, maxCheckInterval, convergence);\n+                                   double convergence,\n+                                   int maxIterationCount) {\n+    super.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);\n     denseOutput = (handler.requiresDenseOutput()\n                    || (! switchesHandler.isEmpty()));\n \n--- a/src/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n     super(specifier, parts);\n   }\n \n-  private static final long serialVersionUID = -1390328069787882608L;\n+  /**\n+   * Create an exception with a given root cause.\n+   * @param cause  the exception or error that caused this exception to be thrown\n+   */\n+  public IntegratorException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  private static final long serialVersionUID = -1215318282266670558L;\n \n }\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n    */\n   public void addSwitchingFunction(SwitchingFunction function,\n                                    double maxCheckInterval,\n-                                   double convergence) {\n-    switchesHandler.add(function, maxCheckInterval, convergence);\n+                                   double convergence,\n+                                   int maxIterationCount) {\n+    switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n--- a/src/java/org/apache/commons/math/ode/SwitchState.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchState.java\n class SwitchState implements Serializable {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 3256541562455482289L;\n+  private static final long serialVersionUID = -7307007422156119622L;\n \n   /** Switching function. */\n   private SwitchingFunction function;\n \n   /** Convergence threshold for event localisation. */\n   private double convergence;\n+\n+  /** Upper limit in the iteration count for event localisation. */\n+  private int maxIterationCount;\n \n   /** Time at the beginning of the step. */\n   private double t0;\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n-   */\n-  public SwitchState(SwitchingFunction function,\n-                     double maxCheckInterval, double convergence) {\n-    this.function         = function;\n-    this.maxCheckInterval = maxCheckInterval;\n-    this.convergence      = Math.abs(convergence);\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n+   */\n+  public SwitchState(SwitchingFunction function, double maxCheckInterval,\n+                     double convergence, int maxIterationCount) {\n+    this.function          = function;\n+    this.maxCheckInterval  = maxCheckInterval;\n+    this.convergence       = Math.abs(convergence);\n+    this.maxIterationCount = maxIterationCount;\n \n     // some dummy values ...\n     t0                = Double.NaN;\n    * beginning of the step\n    * @param y0 array containing the current value of the state vector\n    * at the beginning of the step\n-   */\n-  public void reinitializeBegin(double t0, double[] y0) {\n+   * @exception FunctionEvaluationException if the switching function\n+   * value cannot be evaluated at the beginning of the step\n+   */\n+  public void reinitializeBegin(double t0, double[] y0)\n+    throws FunctionEvaluationException {\n     this.t0 = t0;\n     g0 = function.g(t0, y0);\n     g0Positive = (g0 >= 0);\n    * @return true if the switching function triggers an event before\n    * the end of the proposed step (this implies the step should be\n    * rejected)\n-   */\n-  public boolean evaluateStep(final StepInterpolator interpolator) {\n+   * @exception DerivativeException if the interpolator fails to\n+   * compute the function somewhere within the step\n+   * @exception FunctionEvaluationException if the switching function\n+   * cannot be evaluated\n+   * @exception ConvergenceException if an event cannot be located\n+   */\n+  public boolean evaluateStep(final StepInterpolator interpolator)\n+    throws DerivativeException, FunctionEvaluationException, ConvergenceException {\n \n     try {\n \n           // variation direction, with respect to the integration direction\n           increasing = (gb >= ga);\n \n-          try {\n-              UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {\n-                  public double value(double t) throws FunctionEvaluationException {\n-                      try {\n-                          interpolator.setInterpolatedTime(t);\n-                          return function.g(t, interpolator.getInterpolatedState());\n-                      } catch (DerivativeException e) {\n-                          throw new FunctionEvaluationException(t, e);\n-                      }\n+          UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {\n+              public double value(double t) throws FunctionEvaluationException {\n+                  try {\n+                      interpolator.setInterpolatedTime(t);\n+                      return function.g(t, interpolator.getInterpolatedState());\n+                  } catch (DerivativeException e) {\n+                      throw new FunctionEvaluationException(t, e);\n                   }\n-              });\n-              solver.setAbsoluteAccuracy(convergence);\n-              solver.setMaximalIterationCount(1000);\n-              double root = solver.solve(ta, tb);\n-              if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n-                  pendingEventTime = root;\n-                  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                      // we were already waiting for this event which was\n-                      // found during a previous call for a step that was\n-                      // rejected, this step must now be accepted since it\n-                      // properly ends exactly at the event occurrence\n-                      return false;\n-                  }\n-                  // either we were not waiting for the event or it has\n-                  // moved in such a way the step cannot be accepted\n-                  pendingEvent = true;\n-                  return true;\n               }\n-          } catch (ConvergenceException ce) {\n-              throw new RuntimeException(\"internal error\");\n+          });\n+          solver.setAbsoluteAccuracy(convergence);\n+          solver.setMaximalIterationCount(maxIterationCount);\n+          double root = solver.solve(ta, tb);\n+          if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n+              pendingEventTime = root;\n+              if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                  // we were already waiting for this event which was\n+                  // found during a previous call for a step that was\n+                  // rejected, this step must now be accepted since it\n+                  // properly ends exactly at the event occurrence\n+                  return false;\n+              }\n+              // either we were not waiting for the event or it has\n+              // moved in such a way the step cannot be accepted\n+              pendingEvent = true;\n+              return true;\n           }\n \n         } else {\n       pendingEventTime = Double.NaN;\n       return false;\n \n-    } catch (DerivativeException e) {\n-      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n     } catch (FunctionEvaluationException e) {\n-      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n+     Throwable cause = e.getCause();\n+      if ((cause != null) && (cause instanceof DerivativeException)) {\n+        throw (DerivativeException) cause;\n+      }\n+      throw e;\n     }\n \n   }\n    * end of the step\n    * @param y array containing the current value of the state vector\n    * at the end of the step\n-   */\n-  public void stepAccepted(double t, double[] y) {\n+   * @exception FunctionEvaluationException if the value of the switching\n+   * function cannot be evaluated\n+   */\n+  public void stepAccepted(double t, double[] y)\n+    throws FunctionEvaluationException {\n \n     t0 = t;\n     g0 = function.g(t, y);\n--- a/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n package org.apache.commons.math.ode;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /** This interface represents a switching function.\n  *\n    * @param t current value of the independent <i>time</i> variable\n    * @param y array containing the current value of the state vector\n    * @return value of the g function\n+   * @exception FunctionEvaluationException if the value of the function\n+   * cannot be evaluated\n    */\n-  public double g(double t, double[] y);\n+  public double g(double t, double[] y) throws FunctionEvaluationException;\n \n   /** Handle an event and choose what to do next.\n \n--- a/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n \n package org.apache.commons.math.ode;\n \n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.ode.DerivativeException;\n \n import java.util.ArrayList;\n    * function checks (this interval prevents missing sign changes in\n    * case the integration steps becomes very large)\n    * @param convergence convergence threshold in the event time search\n-   */\n-  public void add(SwitchingFunction function,\n-                  double maxCheckInterval, double convergence) {\n-    functions.add(new SwitchState(function, maxCheckInterval, convergence));\n+   * @param maxIterationCount upper limit of the iteration count in\n+   * the event time search\n+   */\n+  public void add(SwitchingFunction function, double maxCheckInterval,\n+                  double convergence, int maxIterationCount) {\n+    functions.add(new SwitchState(function, maxCheckInterval,\n+                                  convergence, maxIterationCount));\n   }\n \n   /** Check if the handler does not have any condition.\n    * @return true if at least one switching function triggers an event\n    * before the end of the proposed step (this implies the step should\n    * be rejected)\n-   */\n-  public boolean evaluateStep(StepInterpolator interpolator) {\n+   * @exception DerivativeException if the interpolator fails to\n+   * compute the function somewhere within the step\n+   * @exception IntegratorException if an event cannot be located\n+   */\n+  public boolean evaluateStep(StepInterpolator interpolator)\n+    throws DerivativeException, IntegratorException {\n \n     try {\n \n \n       return first != null;\n \n-    } catch (DerivativeException e) {\n-      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n+    } catch (FunctionEvaluationException fee) {\n+      throw new IntegratorException(fee);\n+    } catch (ConvergenceException ce) {\n+      throw new IntegratorException(ce);\n     }\n \n   }\n    * end of the step\n    * @param y array containing the current value of the state vector\n    * at the end of the step\n-   */\n-  public void stepAccepted(double t, double[] y) {\n-    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-      ((SwitchState) iter.next()).stepAccepted(t, y);\n+   * @exception IntegratorException if the value of one of the\n+   * switching functions cannot be evaluated\n+   */\n+  public void stepAccepted(double t, double[] y)\n+    throws IntegratorException {\n+    try {\n+      for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+        ((SwitchState) iter.next()).stepAccepted(t, y);\n+      }\n+    } catch (FunctionEvaluationException fee) {\n+      throw new IntegratorException(fee);\n     }\n   }\n \n--- a/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaIntegratorTest.java\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addSwitchingFunction(functions[l],\n-                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addSwitchingFunction(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n--- a/src/test/org/apache/commons/math/ode/DormandPrince853IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince853IntegratorTest.java\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addSwitchingFunction(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n-    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n     assertEquals(8.0, y[0], 1.0e-12);\n--- a/src/test/org/apache/commons/math/ode/EulerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/EulerIntegratorTest.java\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addSwitchingFunction(functions[l],\n-                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n--- a/src/test/org/apache/commons/math/ode/GillIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GillIntegratorTest.java\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addSwitchingFunction(functions[l],\n-                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n   throws DerivativeException, IntegratorException {\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ = new GillIntegrator(0.3);\n-    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n     assertEquals(8.0, y[0], 1.0e-12);\n--- a/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addSwitchingFunction(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n-    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);\n     double[] y = { Double.NaN };\n     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n     assertEquals(8.0, y[0], 1.0e-12);\n--- a/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n \n package org.apache.commons.math.ode;\n \n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.HighamHall54Integrator;\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addSwitchingFunction(functions[l],\n-                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n \n   }\n+\n+  public void testSwitchingFunctionsError()\n+    throws DerivativeException, IntegratorException {\n+\n+      final TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ =\n+          new HighamHall54Integrator(minStep, maxStep,\n+                                     scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setStepHandler(handler);\n+\n+      integ.addSwitchingFunction(new SwitchingFunction() {\n+        public int eventOccurred(double t, double[] y) {\n+          return SwitchingFunction.CONTINUE;\n+        }\n+        public double g(double t, double[] y) throws FunctionEvaluationException {\n+          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+          double offset = t - middle;\n+          if (offset > 0) {\n+            throw new FunctionEvaluationException(t);\n+          }\n+          return offset;\n+        }\n+        public void resetState(double t, double[] y) {\n+        }\n+        private static final long serialVersionUID = 935652725339916361L;\n+      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+\n+      try {\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+\n+  }\n+\n+  public void testSwitchingFunctionsNoConvergence()\n+  throws DerivativeException, IntegratorException {\n+\n+    final TestProblem1 pb = new TestProblem1();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ =\n+        new HighamHall54Integrator(minStep, maxStep,\n+                                   scalAbsoluteTolerance, scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.setStepHandler(handler);\n+\n+    integ.addSwitchingFunction(new SwitchingFunction() {\n+      public int eventOccurred(double t, double[] y) {\n+        return SwitchingFunction.CONTINUE;\n+      }\n+      public double g(double t, double[] y) {\n+        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+        double offset = t - middle;\n+        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);\n+      }\n+      public void resetState(double t, double[] y) {\n+      }\n+      private static final long serialVersionUID = 935652725339916361L;\n+    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);\n+\n+    try {\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch (IntegratorException ie) {\n+       assertTrue(ie.getCause() != null);\n+       assertTrue(ie.getCause() instanceof ConvergenceException);\n+    } catch (Exception e) {\n+      fail(\"wrong exception type caught\");\n+    }\n+\n+}\n \n   public void testSanityChecks() {\n     try {\n--- a/src/test/org/apache/commons/math/ode/MidpointIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/MidpointIntegratorTest.java\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addSwitchingFunction(functions[l],\n-                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n--- a/src/test/org/apache/commons/math/ode/ThreeEighthesIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/ThreeEighthesIntegratorTest.java\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addSwitchingFunction(functions[l],\n-                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);", "timestamp": 1194121419, "metainfo": ""}