{"sha": "00fea9d8078d487e31cec8292dbd9bd69bc9c216", "log": "MATH-546 Wrong  variable type (\"int\" instead of \"double\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n--- a/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Random;\n \n \n     }\n \n+    /**\n+     * A helper class for testSmallDistances(). This class is similar to EuclideanIntegerPoint, but\n+     * it defines a different distanceFrom() method that tends to return distances less than 1.\n+     */\n+    private class CloseIntegerPoint implements Clusterable<CloseIntegerPoint> {\n+        public CloseIntegerPoint(EuclideanIntegerPoint point) {\n+            euclideanPoint = point;\n+        }\n+\n+        public double distanceFrom(CloseIntegerPoint p) {\n+            return euclideanPoint.distanceFrom(p.euclideanPoint) * 0.001;\n+        }\n+\n+        public CloseIntegerPoint centroidOf(Collection<CloseIntegerPoint> p) {\n+            Collection<EuclideanIntegerPoint> euclideanPoints =\n+                new ArrayList<EuclideanIntegerPoint>();\n+            for (CloseIntegerPoint point : p) {\n+                euclideanPoints.add(point.euclideanPoint);\n+            }\n+            return new CloseIntegerPoint(euclideanPoint.centroidOf(euclideanPoints));\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof CloseIntegerPoint)) {\n+                return false;\n+            }\n+            CloseIntegerPoint p = (CloseIntegerPoint) o;\n+\n+            return euclideanPoint.equals(p.euclideanPoint);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return euclideanPoint.hashCode();\n+        }\n+\n+        private EuclideanIntegerPoint euclideanPoint;\n+    }\n+\n+    /**\n+     * Test points that are very close together. See issue MATH-546.\n+     */\n+    @Test\n+    public void testSmallDistances() {\n+        // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\n+        // small distance.\n+        int[] repeatedArray = { 0 };\n+        int[] uniqueArray = { 1 };\n+        CloseIntegerPoint repeatedPoint =\n+            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\n+        CloseIntegerPoint uniquePoint =\n+            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\n+\n+        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\n+        final int NUM_REPEATED_POINTS = 10 * 1000;\n+        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\n+            points.add(repeatedPoint);\n+        }\n+        points.add(uniquePoint);\n+\n+        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n+        // cluster centers).\n+        final long RANDOM_SEED = 0;\n+        final int NUM_CLUSTERS = 2;\n+        final int NUM_ITERATIONS = 0;\n+        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\n+            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\n+        List<Cluster<CloseIntegerPoint>> clusters =\n+            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\n+\n+        // Check that one of the chosen centers is the unique point.\n+        boolean uniquePointIsCenter = false;\n+        for (Cluster<CloseIntegerPoint> cluster : clusters) {\n+            if (cluster.getCenter().equals(uniquePoint)) {\n+                uniquePointIsCenter = true;\n+            }\n+        }\n+        assertTrue(uniquePointIsCenter);\n+    }\n }", "timestamp": 1300191302, "metainfo": ""}