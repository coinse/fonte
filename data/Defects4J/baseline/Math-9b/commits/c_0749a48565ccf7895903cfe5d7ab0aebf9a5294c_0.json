{"sha": "0749a48565ccf7895903cfe5d7ab0aebf9a5294c", "log": "[MATH-235] add HessenbergTransformer to transform a general real matrix to Hessenberg form. This is a first step for the eigenvalue decomposition of a non-symmetric matrix.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/HessenbergTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+\n+/**\n+ * Class transforming a general real matrix to Hessenberg form.\n+ * <p>A m &times; m matrix A can be written as the product of three matrices: A = P\n+ * &times; H &times; P<sup>T</sup> with P an unitary matrix and H a Hessenberg\n+ * matrix. Both P and H are m &times; m matrices.</p>\n+ * <p>Transformation to Hessenberg form is often not a goal by itself, but it is an\n+ * intermediate step in more general decomposition algorithms like\n+ * {@link EigenDecomposition eigen decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence\n+ * of this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * <p>This class is based on the method orthes in class EigenvalueDecomposition\n+ * from the <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/HessenbergDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Householder_transformation\">Householder Transformations</a>\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+class HessenbergTransformer {\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+    /** Temporary storage vector. */\n+    private final double ort[];\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+    /** Cached value of Pt. */\n+    private RealMatrix cachedPt;\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n+\n+    /**\n+     * Build the transformation to Hessenberg form of a general matrix.\n+     *\n+     * @param matrix matrix to transform.\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     */\n+    public HessenbergTransformer(RealMatrix matrix) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                    matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getRowDimension();\n+        householderVectors = matrix.getData();\n+        ort = new double[m];\n+        cachedP = null;\n+        cachedPt = null;\n+        cachedH = null;\n+\n+        // transform matrix\n+        transform();\n+    }\n+\n+    /**\n+     * Returns the matrix P of the transform.\n+     * <p>P is an unitary matrix, i.e. its inverse is also its transpose.</p>\n+     *\n+     * @return the P matrix\n+     */\n+    public RealMatrix getP() {\n+        if (cachedP == null) {\n+            final int n = householderVectors.length;\n+            final int high = n - 1;\n+            final double[][] pa = new double[n][n];\n+\n+            for (int i = 0; i < n; i++) {\n+                for (int j = 0; j < n; j++) {\n+                    pa[i][j] = (i == j) ? 1 : 0;\n+                }\n+            }\n+\n+            for (int m = high - 1; m >= 1; m--) {\n+                if (householderVectors[m][m - 1] != 0.0) {\n+                    for (int i = m + 1; i <= high; i++) {\n+                        ort[i] = householderVectors[i][m - 1];\n+                    }\n+\n+                    for (int j = m; j <= high; j++) {\n+                        double g = 0.0;\n+\n+                        for (int i = m; i <= high; i++) {\n+                            g += ort[i] * pa[i][j];\n+                        }\n+\n+                        // Double division avoids possible underflow\n+                        g = (g / ort[m]) / householderVectors[m][m - 1];\n+\n+                        for (int i = m; i <= high; i++) {\n+                            pa[i][j] += g * ort[i];\n+                        }\n+                    }\n+                }\n+            }\n+\n+            cachedP = MatrixUtils.createRealMatrix(pa);\n+        }\n+        return cachedP;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix P of the transform.\n+     * <p>P is an unitary matrix, i.e. its inverse is also its transpose.</p>\n+     *\n+     * @return the transpose of the P matrix\n+     */\n+    public RealMatrix getPT() {\n+        if (cachedPt == null) {\n+            cachedPt = getP().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedPt;\n+    }\n+\n+    /**\n+     * Returns the Hessenberg matrix H of the transform.\n+     *\n+     * @return the H matrix\n+     */\n+    public RealMatrix getH() {\n+        if (cachedH == null) {\n+            final int m = householderVectors.length;\n+            final double[][] h = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                if (i > 0) {\n+                    // copy the entry of the lower sub-diagonal\n+                    h[i][i - 1] = householderVectors[i][i - 1];\n+                }\n+\n+                // copy upper triangular part of the matrix\n+                for (int j = i; j < m; ++j) {\n+                    h[i][j] = householderVectors[i][j];\n+                }\n+            }\n+            cachedH = MatrixUtils.createRealMatrix(h);\n+        }\n+\n+        // return the cached matrix\n+        return cachedH;\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use, it returns\n+     * directly a reference to its internal arrays, not a copy.</p>\n+     *\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Transform original matrix to Hessenberg form.\n+     * <p>Transformation is done using Householder transforms.</p>\n+     */\n+    private void transform() {\n+        final int n = householderVectors.length;\n+        final int high = n - 1;\n+\n+        for (int m = 1; m <= high - 1; m++) {\n+            // Scale column.\n+            double scale = 0;\n+            for (int i = m; i <= high; i++) {\n+                scale += FastMath.abs(householderVectors[i][m - 1]);\n+            }\n+\n+            if (!Precision.equals(scale, 0)) {\n+                // Compute Householder transformation.\n+                double h = 0;\n+                for (int i = high; i >= m; i--) {\n+                    ort[i] = householderVectors[i][m - 1] / scale;\n+                    h += ort[i] * ort[i];\n+                }\n+                final double g = (ort[m] > 0) ? -FastMath.sqrt(h) : FastMath.sqrt(h);\n+\n+                h = h - ort[m] * g;\n+                ort[m] = ort[m] - g;\n+\n+                // Apply Householder similarity transformation\n+                // H = (I - u*u' / h) * H * (I - u*u' / h)\n+\n+                for (int j = m; j < n; j++) {\n+                    double f = 0;\n+                    for (int i = high; i >= m; i--) {\n+                        f += ort[i] * householderVectors[i][j];\n+                    }\n+                    f = f / h;\n+                    for (int i = m; i <= high; i++) {\n+                        householderVectors[i][j] -= f * ort[i];\n+                    }\n+                }\n+\n+                for (int i = 0; i <= high; i++) {\n+                    double f = 0;\n+                    for (int j = high; j >= m; j--) {\n+                        f += ort[j] * householderVectors[i][j];\n+                    }\n+                    f = f / h;\n+                    for (int j = m; j <= high; j++) {\n+                        householderVectors[i][j] -= f * ort[j];\n+                    }\n+                }\n+\n+                ort[m] = scale * ort[m];\n+                householderVectors[m][m - 1] = scale * g;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/HessenbergTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class HessenbergTransformerTest {\n+\n+    private double[][] testSquare5 = {\n+            { 5, 4, 3, 2, 1 },\n+            { 1, 4, 0, 3, 3 },\n+            { 2, 0, 3, 0, 0 },\n+            { 3, 2, 1, 2, 5 },\n+            { 4, 2, 1, 4, 1 }\n+    };\n+\n+    private double[][] testSquare3 = {\n+            {  2, -1, 1 },\n+            { -1,  2, 1 },\n+            {  1, -1, 2 }\n+    };\n+\n+    // from http://eigen.tuxfamily.org/dox/classEigen_1_1HessenbergDecomposition.html\n+\n+    private double[][] testRandom = {\n+            {  0.680,  0.823, -0.4440, -0.2700 },\n+            { -0.211, -0.605,  0.1080,  0.0268 },\n+            {  0.566, -0.330, -0.0452,  0.9040 },\n+            {  0.597,  0.536,  0.2580,  0.8320 }\n+    };\n+\n+    @Test\n+    public void testNonSquare() {\n+        try {\n+            new HessenbergTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonSquareMatrixException ime) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAEqualPHPt() {\n+        checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare5));\n+        checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare3));\n+        checkAEqualPHPt(MatrixUtils.createRealMatrix(testRandom));\n+   }\n+\n+    private void checkAEqualPHPt(RealMatrix matrix) {\n+        HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n+        RealMatrix p  = transformer.getP();\n+        RealMatrix pT = transformer.getPT();\n+        RealMatrix h  = transformer.getH();\n+        double norm = p.multiply(h).multiply(pT).subtract(matrix).getNorm();\n+        Assert.assertEquals(0, norm, 4.0e-14);\n+    }\n+\n+    @Test\n+    public void testPOrthogonal() {\n+        checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP());\n+        checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP());\n+    }\n+\n+    @Test\n+    public void testPTOrthogonal() {\n+        checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT());\n+        checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);\n+    }\n+\n+    @Test\n+    public void testHessenbergForm() {\n+        checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getH());\n+        checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getH());\n+    }\n+\n+    private void checkHessenbergForm(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if (i > j + 1) {\n+                    Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMatricesValues5() {\n+        checkMatricesValues(testSquare5,\n+                            new double[][] {\n+                                { 1.0,  0.0,                0.0,                0.0,                0.0               },\n+                                { 0.0, -0.182574185835055,  0.784218758628863,  0.395029040913988, -0.442289115981669 },\n+                                { 0.0, -0.365148371670111, -0.337950625265477, -0.374110794088820, -0.782621974707823 },\n+                                { 0.0, -0.547722557505166,  0.402941130124223, -0.626468266309003,  0.381019628053472 },\n+                                { 0.0, -0.730296743340221, -0.329285224617644,  0.558149336547665,  0.216118545309225 }\n+                            },\n+                            new double[][] {\n+                                {  5.0,              -3.65148371670111,  2.59962019434982, -0.237003414680848, -3.13886458663398  },\n+                                { -5.47722557505166,  6.9,              -2.29164066120599,  0.207283564429169,  0.703858369151728 },\n+                                {  0.0,              -4.21386600008432,  2.30555659846067,  2.74935928725112,   0.857569835914113 },\n+                                {  0.0,               0.0,               2.86406180891882, -1.11582249161595,   0.817995267184158 },\n+                                {  0.0,               0.0,               0.0,               0.683518597386085,  1.91026589315528  }\n+                            });\n+    }\n+\n+    @Test\n+    public void testMatricesValues3() {\n+        checkMatricesValues(testSquare3,\n+                            new double[][] {\n+                                {  1.0,  0.0,               0.0               },\n+                                {  0.0, -0.707106781186547, 0.707106781186547 },\n+                                {  0.0,  0.707106781186547, 0.707106781186548 },\n+                            },\n+                            new double[][] {\n+                                {  2.0,              1.41421356237309,  0.0 },\n+                                {  1.41421356237310, 2.0,              -1.0 },\n+                                {  0.0,              1.0,               2.0 },\n+                            });\n+    }\n+\n+    private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) {\n+\n+        HessenbergTransformer transformer =\n+            new HessenbergTransformer(MatrixUtils.createRealMatrix(matrix));\n+\n+        // check values against known references\n+        RealMatrix p = transformer.getP();\n+        Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14);\n+\n+        RealMatrix h = transformer.getH();\n+        Assert.assertEquals(0, h.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(p == transformer.getP());\n+        Assert.assertTrue(h == transformer.getH());\n+    }\n+}", "timestamp": 1336240412, "metainfo": ""}