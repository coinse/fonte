{"sha": "d05f26160a434239c8d81be80206838ac63ad1c3", "log": "MATH-458 Removed the checked \"MathException\" from the interpolator interfaces. Updated all affected classes. \"LoessInterpolator\": Replaced usage of \"MathException\" with specific exceptions.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n      */\n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n-                                                          final double[][] fval)\n-        throws MathException {\n+                                                          final double[][] fval) {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n \n /**\n  */\n public interface BivariateRealGridInterpolator {\n     /**\n-     * Computes an interpolating function for the data set.\n+     * Compute an interpolating function for the dataset.\n      *\n      * @param xval All the x-coordinates of the interpolation points, sorted\n      * in increasing order.\n      * in increasing order.\n      * @param fval The values of the interpolation points on all the grid knots:\n      * {@code fval[i][j] = f(xval[i], yval[j])}.\n-     * @return a function which interpolates the data set.\n-     * @throws MathException if arguments violate assumptions made by the\n-     *         interpolation algorithm.\n+     * @return a function which interpolates the dataset.\n+     * @throws org.apache.commons.math.exception.NoDataException if any of\n+     * the arrays has zero length.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are inconsistent.\n      */\n-    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] fval)\n-        throws MathException;\n+    BivariateRealFunction interpolate(double[] xval, double[] yval,\n+                                      double[][] fval);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n  */\n public class LoessInterpolator\n         implements UnivariateRealInterpolator, Serializable {\n-\n     /** Default value of the bandwidth parameter. */\n     public static final double DEFAULT_BANDWIDTH = 0.3;\n-\n     /** Default value of the number of robustness iterations. */\n     public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n-\n     /**\n      * Default value for accuracy.\n      * @since 2.1\n      */\n     public static final double DEFAULT_ACCURACY = 1e-12;\n-\n     /** serializable version identifier. */\n     private static final long serialVersionUID = 5204927143605193821L;\n-\n     /**\n      * The bandwidth parameter: when computing the loess fit at\n      * a particular point, this fraction of source points closest\n      * A sensible value is usually 0.25 to 0.5.\n      */\n     private final double bandwidth;\n-\n     /**\n      * The number of robustness iterations parameter: this many\n      * robustness iterations are done.\n      * robustness iterations) to 4.\n      */\n     private final int robustnessIters;\n-\n     /**\n      * If the median residual at a certain robustness iteration\n      * is less than this amount, no more iterations are done.\n     }\n \n     /**\n-     * Constructs a new {@link LoessInterpolator}\n+     * Construct a new {@link LoessInterpolator}\n      * with given bandwidth and number of robustness iterations.\n      * <p>\n      * Calling this constructor is equivalent to calling {link {@link\n      * A sensible value is usually 0 (just the initial fit without any\n      * robustness iterations) to 4, the default value is\n      * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n-     * @throws MathException if bandwidth does not lie in the interval [0,1]\n-     * or if robustnessIters is negative.\n+\n      * @see #LoessInterpolator(double, int, double)\n      */\n-    public LoessInterpolator(double bandwidth, int robustnessIters) throws MathException {\n+    public LoessInterpolator(double bandwidth, int robustnessIters) {\n         this(bandwidth, robustnessIters, DEFAULT_ACCURACY);\n     }\n \n     /**\n-     * Constructs a new {@link LoessInterpolator}\n+     * Construct a new {@link LoessInterpolator}\n      * with given bandwidth, number of robustness iterations and accuracy.\n      *\n      * @param bandwidth  when computing the loess fit at\n      * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n      * @param accuracy If the median residual at a certain robustness iteration\n      * is less than this amount, no more iterations are done.\n-     * @throws MathException if bandwidth does not lie in the interval [0,1]\n-     * or if robustnessIters is negative.\n+     * @throws OutOfRangeException if bandwidth does not lie in the interval [0,1].\n+     * @throws NotPositiveException if {@code robustnessIters} is negative.\n      * @see #LoessInterpolator(double, int)\n      * @since 2.1\n      */\n-    public LoessInterpolator(double bandwidth, int robustnessIters, double accuracy) throws MathException {\n-        if (bandwidth < 0 || bandwidth > 1) {\n-            throw new MathException(LocalizedFormats.BANDWIDTH_OUT_OF_INTERVAL,\n-                                    bandwidth);\n+    public LoessInterpolator(double bandwidth, int robustnessIters, double accuracy) {\n+        if (bandwidth < 0 ||\n+            bandwidth > 1) {\n+            throw new OutOfRangeException(LocalizedFormats.BANDWIDTH, bandwidth, 0, 1);\n         }\n         this.bandwidth = bandwidth;\n         if (robustnessIters < 0) {\n-            throw new MathException(LocalizedFormats.NEGATIVE_ROBUSTNESS_ITERATIONS, robustnessIters);\n+            throw new NotPositiveException(LocalizedFormats.ROBUSTNESS_ITERATIONS, robustnessIters);\n         }\n         this.robustnessIters = robustnessIters;\n         this.accuracy = accuracy;\n      * @param xval the arguments for the interpolation points\n      * @param yval the values for the interpolation points\n      * @return A cubic spline built upon a loess fit to the data at the original abscissae\n-     * @throws MathException  if some of the following conditions are false:\n-     * <ul>\n-     * <li> Arguments and values are of the same size that is greater than zero</li>\n-     * <li> The arguments are in a strictly increasing order</li>\n-     * <li> All arguments and values are finite real numbers</li>\n-     * </ul>\n-     */\n-    public final PolynomialSplineFunction interpolate(\n-            final double[] xval, final double[] yval) throws MathException {\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code xval} not sorted in strictly increasing order.\n+     * @throws DimensionMismatchException if {@code xval} and {@code yval} have\n+     * different sizes.\n+     * @throws NoDataException if {@code xval} or {@code yval} has zero size.\n+     * @throws org.apache.commons.math.exception.NotFiniteNumberException if\n+     * any of the arguments and values are not finite real numbers.\n+     * @throws NumberIsTooSmallException if the bandwidth is too small to\n+     * accomodate the size of the input data (i.e. the bandwidth must be\n+     * larger than 2/n).\n+     */\n+    public final PolynomialSplineFunction interpolate(final double[] xval, final double[] yval) {\n         return new SplineInterpolator().interpolate(xval, smooth(xval, yval));\n     }\n \n     /**\n      * Compute a weighted loess fit on the data at the original abscissae.\n      *\n-     * @param xval the arguments for the interpolation points\n-     * @param yval the values for the interpolation points\n-     * @param weights point weights: coefficients by which the robustness weight of a point is multiplied\n-     * @return values of the loess fit at corresponding original abscissae\n-     * @throws MathException if some of the following conditions are false:\n-     * <ul>\n-     * <li> Arguments and values are of the same size that is greater than zero</li>\n-     * <li> The arguments are in a strictly increasing order</li>\n-     * <li> All arguments and values are finite real numbers</li>\n-     * </ul>\n+     * @param xval Arguments for the interpolation points.\n+     * @param yval Values for the interpolation points.\n+     * @param weights point weights: coefficients by which the robustness weight\n+     * of a point is multiplied.\n+     * @return the values of the loess fit at corresponding original abscissae.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code xval} not sorted in strictly increasing order.\n+     * @throws DimensionMismatchException if {@code xval} and {@code yval} have\n+     * different sizes.\n+     * @throws NoDataException if {@code xval} or {@code yval} has zero size.\n+     * @throws org.apache.commons.math.exception.NotFiniteNumberException if\n+     * any of the arguments and values are not finite real numbers.\n+     * @throws NumberIsTooSmallException if the bandwidth is too small to\n+     * accomodate the size of the input data (i.e. the bandwidth must be\n+     * larger than 2/n).\n      * @since 2.1\n      */\n-    public final double[] smooth(final double[] xval, final double[] yval, final double[] weights)\n-            throws MathException {\n+    public final double[] smooth(final double[] xval, final double[] yval,\n+                                 final double[] weights)  {\n         if (xval.length != yval.length) {\n-            throw new MathException(LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS,\n-                                    xval.length, yval.length);\n+            throw new DimensionMismatchException(xval.length, yval.length);\n         }\n \n         final int n = xval.length;\n \n         if (n == 0) {\n-            throw new MathException(LocalizedFormats.LOESS_EXPECTS_AT_LEAST_ONE_POINT);\n-        }\n-\n-        checkAllFiniteReal(xval, LocalizedFormats.NON_REAL_FINITE_ABSCISSA);\n-        checkAllFiniteReal(yval, LocalizedFormats.NON_REAL_FINITE_ORDINATE);\n-        checkAllFiniteReal(weights, LocalizedFormats.NON_REAL_FINITE_WEIGHT);\n-\n-        checkStrictlyIncreasing(xval);\n+            throw new NoDataException();\n+        }\n+\n+        checkAllFiniteReal(xval);\n+        checkAllFiniteReal(yval);\n+        checkAllFiniteReal(weights);\n+\n+        MathUtils.checkOrder(xval);\n \n         if (n == 1) {\n             return new double[]{yval[0]};\n         int bandwidthInPoints = (int) (bandwidth * n);\n \n         if (bandwidthInPoints < 2) {\n-            throw new MathException(LocalizedFormats.TOO_SMALL_BANDWIDTH,\n-                                    n, 2.0 / n, bandwidth);\n+            throw new NumberIsTooSmallException(LocalizedFormats.BANDWIDTH,\n+                                                bandwidthInPoints, 2, true);\n         }\n \n         final double[] res = new double[n];\n      * @param xval the arguments for the interpolation points\n      * @param yval the values for the interpolation points\n      * @return values of the loess fit at corresponding original abscissae\n-     * @throws MathException if some of the following conditions are false:\n-     * <ul>\n-     * <li> Arguments and values are of the same size that is greater than zero</li>\n-     * <li> The arguments are in a strictly increasing order</li>\n-     * <li> All arguments and values are finite real numbers</li>\n-     * </ul>\n-     */\n-    public final double[] smooth(final double[] xval, final double[] yval)\n-            throws MathException {\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code xval} not sorted in strictly increasing order.\n+     * @throws DimensionMismatchException if {@code xval} and {@code yval} have\n+     * different sizes.\n+     * @throws NoDataException if {@code xval} or {@code yval} has zero size.\n+     * @throws org.apache.commons.math.exception.NotFiniteNumberException if\n+     * any of the arguments and values are not finite real numbers.\n+     * @throws NumberIsTooSmallException if the bandwidth is too small to\n+     * accomodate the size of the input data (i.e. the bandwidth must be\n+     * larger than 2/n).\n+     */\n+    public final double[] smooth(final double[] xval, final double[] yval) {\n         if (xval.length != yval.length) {\n-            throw new MathException(LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS,\n-                                    xval.length, yval.length);\n+            throw new DimensionMismatchException(xval.length, yval.length);\n         }\n \n         final double[] unitWeights = new double[xval.length];\n \n     /**\n      * Given an index interval into xval that embraces a certain number of\n-     * points closest to xval[i-1], update the interval so that it embraces\n-     * the same number of points closest to xval[i], ignoring zero weights.\n-     *\n-     * @param xval arguments array\n-     * @param weights weights array\n-     * @param i the index around which the new interval should be computed\n-     * @param bandwidthInterval a two-element array {left, right} such that: <p/>\n-     * <tt>(left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])</tt>\n-     * <p/> and also <p/>\n-     * <tt>(right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])</tt>.\n+     * points closest to {@code xval[i-1]}, update the interval so that it\n+     * embraces the same number of points closest to {@code xval[i]},\n+     * ignoring zero weights.\n+     *\n+     * @param xval Arguments array.\n+     * @param weights Weights array.\n+     * @param i Index around which the new interval should be computed.\n+     * @param bandwidthInterval a two-element array {left, right} such that:\n+     * {@code (left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])}\n+     * and\n+     * {@code (right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])}.\n      * The array will be updated.\n      */\n     private static void updateBandwidthInterval(final double[] xval, final double[] weights,\n     }\n \n     /**\n-     * Returns the smallest index j such that j > i && (j==weights.length || weights[j] != 0)\n-     * @param weights weights array\n-     * @param i the index from which to start search; must be < weights.length\n-     * @return the smallest index j such that j > i && (j==weights.length || weights[j] != 0)\n+     * Return the smallest index {@code j} such that\n+     * {@code j > i && (j == weights.length || weights[j] != 0)}.\n+     *\n+     * @param weights Weights array.\n+     * @param i Index from which to start search.\n+     * @return the smallest compliant index.\n      */\n     private static int nextNonzero(final double[] weights, final int i) {\n         int j = i + 1;\n         while(j < weights.length && weights[j] == 0) {\n-            j++;\n+            ++j;\n         }\n         return j;\n     }\n      * <a href=\"http://en.wikipedia.org/wiki/Local_regression#Weight_function\">tricube</a>\n      * weight function\n      *\n-     * @param x the argument\n-     * @return (1-|x|^3)^3\n+     * @param x Argument.\n+     * @return <code>(1 - |x|<sup>3</sup>)<sup>3</sup></code>.\n      */\n     private static double tricube(final double x) {\n         final double tmp = 1 - x * x * x;\n     /**\n      * Check that all elements of an array are finite real numbers.\n      *\n-     * @param values the values array\n-     * @param pattern pattern of the error message\n-     * @throws MathException if one of the values is not a finite real number\n-     */\n-    private static void checkAllFiniteReal(final double[] values, final Localizable pattern)\n-        throws MathException {\n+     * @param values Values array.\n+     * @throws org.apache.commons.math.exception.NotFiniteNumberException\n+     * if one of the values is not a finite real number.\n+     */\n+    private static void checkAllFiniteReal(final double[] values) {\n         for (int i = 0; i < values.length; i++) {\n-            final double x = values[i];\n-            if (Double.isInfinite(x) || Double.isNaN(x)) {\n-                throw new MathException(pattern, i, x);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check that elements of the abscissae array are in a strictly\n-     * increasing order.\n-     *\n-     * @param xval the abscissae array\n-     * @throws MathException if the abscissae array\n-     * is not in a strictly increasing order\n-     */\n-    private static void checkStrictlyIncreasing(final double[] xval)\n-        throws MathException {\n-        for (int i = 0; i < xval.length; ++i) {\n-            if (i >= 1 && xval[i - 1] >= xval[i]) {\n-                throw new MathException(LocalizedFormats.OUT_OF_ORDER_ABSCISSA_ARRAY,\n-                                        i - 1, xval[i - 1], i, xval[i]);\n-            }\n+            MathUtils.checkFinite(values[i]);\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n \n /**\n      * @param x the interpolating points array\n      * @param y the interpolating values array\n      * @return a function which interpolates the data set\n-     * @throws MathException if arguments are invalid\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException if\n+     * the array lengths are different.\n+     * @throws org.apache.commons.math.exception.NumberIsTooSmallException if\n+     * the number of points is less than 2.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if two abscissae have the same value.\n      */\n-    public PolynomialFunctionLagrangeForm interpolate(double x[], double y[])\n-        throws MathException {\n+    public PolynomialFunctionLagrangeForm interpolate(double x[], double y[]) {\n         return new PolynomialFunctionLagrangeForm(x, y);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.fitting.PolynomialFitter;\n     @Override\n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n-                                                          final double[][] fval)\n-        throws MathException {\n+                                                          final double[][] fval) {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     public TricubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                            final double[] yval,\n                                                            final double[] zval,\n-                                                           final double[][][] fval)\n-        throws MathException {\n+                                                           final double[][][] fval) {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n \n /**\n  */\n public interface TrivariateRealGridInterpolator {\n     /**\n-     * Computes an interpolating function for the data set.\n+     * Compute an interpolating function for the dataset.\n      *\n      * @param xval All the x-coordinates of the interpolation points, sorted\n      * in increasing order.\n      * @param fval the values of the interpolation points on all the grid knots:\n      * {@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.\n      * @return a function that interpolates the data set.\n-     * @throws org.apache.commons.math.exception.NoDataException if any of the arrays has zero length.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException if the array lengths are inconsistent.\n-     * @throws MathException if arguments violate assumptions made by the\n-     *         interpolation algorithm.\n+     * @throws org.apache.commons.math.exception.NoDataException if any of\n+     * the arrays has zero length.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are inconsistent.\n      */\n-    TrivariateRealFunction interpolate(double[] xval, double[] yval, double[] zval, double[][][] fval)\n-        throws MathException;\n+    TrivariateRealFunction interpolate(double[] xval, double[] yval, double[] zval,\n+                                       double[][][] fval);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealInterpolator {\n-\n     /**\n-     * Computes an interpolating function for the data set.\n-     * @param xval the arguments for the interpolation points\n-     * @param yval the values for the interpolation points\n-     * @return a function which interpolates the data set\n-     * @throws MathException if arguments violate assumptions made by the\n-     *         interpolation algorithm\n+     * Compute an interpolating function for the dataset.\n+     *\n+     * @param xval Arguments for the interpolation points.\n+     * @param yval Values for the interpolation points.\n+     * @return a function which interpolates the dataset.\n+     * @throws org.apache.commons.math.exception.MathRuntimeException if the\n+     * arguments violate assumptions made by the interpolation algorithm.\n      */\n-    UnivariateRealFunction interpolate(double xval[], double yval[])\n-        throws MathException;\n+    UnivariateRealFunction interpolate(double xval[], double yval[]);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n      *\n      * @param x interpolating points\n      * @param y function values at interpolating points\n-     * @throws IllegalArgumentException if input arrays are not valid\n+     * @throws DimensionMismatchException if the array lengths are different.\n+     * @throws NumberIsTooSmallException if the number of points is less than 2.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if two abscissae have the same value.\n      */\n     public PolynomialFunctionLagrangeForm(double x[], double y[]) {\n         this.x = new double[x.length];\n--- a/src/main/java/org/apache/commons/math/exception/NotFiniteNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotFiniteNumberException.java\n      * @param args Optional arguments.\n      */\n     public NotFiniteNumberException(Number wrong,\n-                                    Object ... arguments) {\n-        this(null, wrong, arguments);\n+                                    Object ... args) {\n+        this(null, wrong, args);\n     }\n \n     /**\n      */\n     public NotFiniteNumberException(Localizable specific,\n                                     Number wrong,\n-                                    Object ... arguments) {\n+                                    Object ... args) {\n         super(specific, LocalizedFormats.NOT_FINITE_NUMBER,\n-              wrong, arguments);\n+              wrong, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     ASSYMETRIC_EIGEN_NOT_SUPPORTED(\"eigen decomposition of assymetric matrices not supported yet\"),\n     AT_LEAST_ONE_COLUMN(\"matrix must have at least one column\"),\n     AT_LEAST_ONE_ROW(\"matrix must have at least one row\"),\n-    BANDWIDTH_OUT_OF_INTERVAL(\"bandwidth must be in the interval [0,1], but got {0}\"),\n+    BANDWIDTH(\"bandwidth ({0})\"),\n     BINOMIAL_INVALID_PARAMETERS_ORDER(\"must have n >= k for binomial coefficient (n, k), got k = {0}, n = {1}\"),\n     BINOMIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for binomial coefficient (n, k), got n = {0}\"),\n     CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS(\"statistics constructed from external moments cannot be cleared\"),\n     NUMBER_OF_SUCCESSES(\"number of successes ({0})\"), /* keep */\n     NEGATIVE_NUMBER_OF_TRIALS(\"number of trials must be non-negative ({0})\"),\n     NUMBER_OF_TRIALS(\"number of trials ({0})\"),\n-    NEGATIVE_ROBUSTNESS_ITERATIONS(\"the number of robustness iterations must be non-negative, but got {0}\"),\n+    ROBUSTNESS_ITERATIONS(\"number of robustness iterations ({0})\"),\n     START_POSITION(\"start position ({0})\"), /* keep */\n     NON_CONVERGENT_CONTINUED_FRACTION(\"Continued fraction convergents failed to converge (in less than {0} iterations) for value {1}\"),\n     NON_POSITIVE_MICROSPHERE_ELEMENTS(\"number of microsphere elements must be positive, but got {0}\"),\n     SUBARRAY_ENDS_AFTER_ARRAY_END(\"subarray ends after array end\"),\n     TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n     TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n-    TOO_SMALL_BANDWIDTH(\"the bandwidth must be large enough to accomodate at least 2 points. There are {0}  data points, and bandwidth must be at least {1}  but it is only {2}\"),\n     TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n     TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n     TOO_SMALL_ORTHOGONALITY_TOLERANCE(\"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\"),\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.NotFiniteNumberException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+\n import org.junit.Assert;\n import org.junit.Test;\n \n public class LoessInterpolatorTest {\n \n     @Test\n-    public void testOnOnePoint() throws MathException {\n+    public void testOnOnePoint() {\n         double[] xval = {0.5};\n         double[] yval = {0.7};\n         double[] res = new LoessInterpolator().smooth(xval, yval);\n     }\n \n     @Test\n-    public void testOnTwoPoints() throws MathException {\n+    public void testOnTwoPoints() {\n         double[] xval = {0.5, 0.6};\n         double[] yval = {0.7, 0.8};\n         double[] res = new LoessInterpolator().smooth(xval, yval);\n     }\n \n     @Test\n-    public void testOnStraightLine() throws MathException {\n+    public void testOnStraightLine() {\n         double[] xval = {1,2,3,4,5};\n         double[] yval = {2,4,6,8,10};\n         LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12);\n     }\n \n     @Test\n-    public void testOnDistortedSine() throws MathException {\n+    public void testOnDistortedSine() {\n         int numPoints = 100;\n         double[] xval = new double[numPoints];\n         double[] yval = new double[numPoints];\n     }\n \n     @Test\n-    public void testIncreasingBandwidthIncreasesSmoothness() throws MathException {\n+    public void testIncreasingBandwidthIncreasesSmoothness() {\n         int numPoints = 100;\n         double[] xval = new double[numPoints];\n         double[] yval = new double[numPoints];\n     }\n \n     @Test\n-    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() throws MathException {\n+    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() {\n         int numPoints = 100;\n         double[] xval = new double[numPoints];\n         double[] yval = new double[numPoints];\n         }\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testUnequalSizeArguments() throws MathException {\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testUnequalSizeArguments() {\n         new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testEmptyData() throws MathException {\n+    @Test(expected=NoDataException.class)\n+    public void testEmptyData() {\n         new LoessInterpolator().smooth(new double[] {}, new double[] {});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNonStrictlyIncreasing1() throws MathException {\n+    @Test(expected=NonMonotonousSequenceException.class)\n+    public void testNonStrictlyIncreasing1() {\n         new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNonStrictlyIncreasing2() throws MathException {\n+    @Test(expected=NonMonotonousSequenceException.class)\n+    public void testNonStrictlyIncreasing2() {\n         new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal1() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal1() {\n         new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal2() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal2() {\n         new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal3() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal3() {\n         new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal4() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal4() {\n         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal5() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal5() {\n         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testNotAllFiniteReal6() throws MathException {\n+    @Test(expected=NotFiniteNumberException.class)\n+    public void testNotAllFiniteReal6() {\n         new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testInsufficientBandwidth() throws MathException {\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testInsufficientBandwidth() {\n         LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12);\n         li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testCompletelyIncorrectBandwidth1() throws MathException {\n+    @Test(expected=OutOfRangeException.class)\n+    public void testCompletelyIncorrectBandwidth1() {\n         new LoessInterpolator(-0.2, 3, 1e-12);\n     }\n \n-    @Test(expected=MathException.class)\n-    public void testCompletelyIncorrectBandwidth2() throws MathException {\n+    @Test(expected=OutOfRangeException.class)\n+    public void testCompletelyIncorrectBandwidth2() {\n         new LoessInterpolator(1.1, 3, 1e-12);\n     }\n \n     @Test\n-    public void testMath296withoutWeights() throws MathException {\n+    public void testMath296withoutWeights() {\n         double[] xval = {\n                 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n                  1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};\n             x += dx * (1 + (2 * FastMath.random() - 1) * xnoise);\n         }\n     }\n-\n }", "timestamp": 1294330851, "metainfo": ""}