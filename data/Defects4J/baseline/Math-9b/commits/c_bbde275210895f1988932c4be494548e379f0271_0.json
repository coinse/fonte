{"sha": "bbde275210895f1988932c4be494548e379f0271", "log": "Code and Javadoc formatting.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n  * </p>\n  * <p>\n  * This implementation is based on the paper by A. Drubrulle, R.S. Martin and\n- * J.H. Wilkinson 'The Implicit QL Algorithm' in Wilksinson and Reinsch (1971)\n+ * J.H. Wilkinson \"The Implicit QL Algorithm\" in Wilksinson and Reinsch (1971)\n  * Handbook for automatic computation, vol. 2, Linear algebra, Springer-Verlag,\n  * New-York\n  * </p>\n  * @since 2.0 (changed to concrete class in 3.0)\n  */\n public class EigenDecomposition{\n-\n     /** Maximum number of iterations accepted in the implicit QL transformation */\n     private byte maxIter = 30;\n-\n     /** Main diagonal of the tridiagonal matrix. */\n     private double[] main;\n-\n     /** Secondary diagonal of the tridiagonal matrix. */\n     private double[] secondary;\n-\n     /**\n      * Transformer to tridiagonal (may be null if matrix is already\n      * tridiagonal).\n      */\n     private TriDiagonalTransformer transformer;\n-\n     /** Real part of the realEigenvalues. */\n     private double[] realEigenvalues;\n-\n     /** Imaginary part of the realEigenvalues. */\n     private double[] imagEigenvalues;\n-\n     /** Eigenvectors. */\n     private ArrayRealVector[] eigenvectors;\n-\n     /** Cached value of V. */\n     private RealMatrix cachedV;\n-\n     /** Cached value of D. */\n     private RealMatrix cachedD;\n-\n     /** Cached value of Vt. */\n     private RealMatrix cachedVt;\n \n      * Calculates the eigen decomposition of the symmetric tridiagonal\n      * matrix.  The Householder matrix is assumed to be the identity matrix.\n      *\n-     * @param main Main diagonal of the symmetric triadiagonal form\n-     * @param secondary Secondary of the tridiagonal form\n+     * @param main Main diagonal of the symmetric tridiagonal form.\n+     * @param secondary Secondary of the tridiagonal form.\n      * @param splitTolerance Dummy parameter (present for backward\n      * compatibility only).\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n     }\n \n     /**\n-     * Returns the matrix V of the decomposition.\n-     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n-     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n-     * <p>No assumption is made about the orientation of the system axes formed\n+     * Gets the matrix V of the decomposition.\n+     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n+     * The columns of V are the eigenvectors of the original matrix.\n+     * No assumption is made about the orientation of the system axes formed\n      * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n-     * or right-handed system).</p>\n-     * @return the V matrix\n+     * or right-handed system).\n+     *\n+     * @return the V matrix.\n      */\n     public RealMatrix getV() {\n \n     }\n \n     /**\n-     * Returns the block diagonal matrix D of the decomposition.\n-     * <p>D is a block diagonal matrix.</p>\n-     * <p>Real eigenvalues are on the diagonal while complex values are on\n-     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</p>\n-     * @return the D matrix\n+     * Gets the block diagonal matrix D of the decomposition.\n+     * D is a block diagonal matrix.\n+     * Real eigenvalues are on the diagonal while complex values are on\n+     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\n+     *\n+     * @return the D matrix.\n+     *\n      * @see #getRealEigenvalues()\n      * @see #getImagEigenvalues()\n      */\n     }\n \n     /**\n-     * Returns the transpose of the matrix V of the decomposition.\n-     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n-     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n-     * <p>No assumption is made about the orientation of the system axes formed\n+     * Gets the transpose of the matrix V of the decomposition.\n+     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n+     * The columns of V are the eigenvectors of the original matrix.\n+     * No assumption is made about the orientation of the system axes formed\n      * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n-     * or right-handed system).</p>\n-     * @return the transpose of the V matrix\n+     * or right-handed system).\n+     *\n+     * @return the transpose of the V matrix.\n      */\n     public RealMatrix getVT() {\n \n     }\n \n     /**\n-     * Returns a copy of the real parts of the eigenvalues of the original matrix.\n-     * @return a copy of the real parts of the eigenvalues of the original matrix\n+     * Gets a copy of the real parts of the eigenvalues of the original matrix.\n+     *\n+     * @return a copy of the real parts of the eigenvalues of the original matrix.\n+     *\n      * @see #getD()\n      * @see #getRealEigenvalue(int)\n      * @see #getImagEigenvalues()\n     }\n \n     /**\n-     * Returns the real part of the i<sup>th</sup> eigenvalue of the original matrix.\n+     * Returns the real part of the i<sup>th</sup> eigenvalue of the original\n+     * matrix.\n+     *\n      * @param i index of the eigenvalue (counting from 0)\n-     * @return real part of the i<sup>th</sup> eigenvalue of the original matrix\n+     * @return real part of the i<sup>th</sup> eigenvalue of the original\n+     * matrix.\n+     *\n      * @see #getD()\n      * @see #getRealEigenvalues()\n      * @see #getImagEigenvalue(int)\n     }\n \n     /**\n-     * Returns a copy of the imaginary parts of the eigenvalues of the original matrix.\n-     * @return a copy of the imaginary parts of the eigenvalues of the original matrix\n+     * Gets a copy of the imaginary parts of the eigenvalues of the original\n+     * matrix.\n+     *\n+     * @return a copy of the imaginary parts of the eigenvalues of the original\n+     * matrix.\n+     *\n      * @see #getD()\n      * @see #getImagEigenvalue(int)\n      * @see #getRealEigenvalues()\n     }\n \n     /**\n-     * Returns the imaginary part of the i<sup>th</sup> eigenvalue of the original matrix.\n-     * @param i index of the eigenvalue (counting from 0)\n-     * @return imaginary part of the i<sup>th</sup> eigenvalue of the original matrix\n+     * Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original\n+     * matrix.\n+     *\n+     * @param i Index of the eigenvalue (counting from 0).\n+     * @return the imaginary part of the i<sup>th</sup> eigenvalue of the original\n+     * matrix.\n+     *\n      * @see #getD()\n      * @see #getImagEigenvalues()\n      * @see #getRealEigenvalue(int)\n     }\n \n     /**\n-     * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n-     * @param i index of the eigenvector (counting from 0)\n-     * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n+     * Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.\n+     *\n+     * @param i Index of the eigenvector (counting from 0).\n+     * @return a copy of the i<sup>th</sup> eigenvector of the original matrix.\n      * @see #getD()\n      */\n     public RealVector getEigenvector(final int i) {\n     }\n \n     /**\n-     * Return the determinant of the matrix\n-     * @return determinant of the matrix\n+     * Computes the determinant of the matrix.\n+     *\n+     * @return the determinant of the matrix.\n      */\n     public double getDeterminant() {\n         double determinant = 1;\n     }\n \n     /**\n-     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n-     * @return a solver\n+     * Gets a solver for finding the A &times; X = B solution in exact\n+     * linear sense.\n+     *\n+     * @return a solver.\n      */\n     public DecompositionSolver getSolver() {\n         return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-\n         /** Real part of the realEigenvalues. */\n         private double[] realEigenvalues;\n-\n         /** Imaginary part of the realEigenvalues. */\n         private double[] imagEigenvalues;\n-\n         /** Eigenvectors. */\n         private final ArrayRealVector[] eigenvectors;\n \n         /**\n-         * Build a solver from decomposed matrix.\n-         * @param realEigenvalues\n-         *            real parts of the eigenvalues\n-         * @param imagEigenvalues\n-         *            imaginary parts of the eigenvalues\n-         * @param eigenvectors\n-         *            eigenvectors\n+         * Builds a solver from decomposed matrix.\n+         *\n+         * @param realEigenvalues Real parts of the eigenvalues.\n+         * @param imagEigenvalues Imaginary parts of the eigenvalues.\n+         * @param eigenvectors Eigenvectors.\n          */\n         private Solver(final double[] realEigenvalues,\n                 final double[] imagEigenvalues,\n         }\n \n         /**\n-         * Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * Solves the linear equation A &times; X = B for symmetric matrices A.\n          * <p>\n-         * This method only find exact linear solutions, i.e. solutions for\n+         * This method only finds exact linear solutions, i.e. solutions for\n          * which ||A &times; X - B|| is exactly 0.\n          * </p>\n-         * @param b Right-hand side of the equation A &times; X = B\n-         * @return a Vector X that minimizes the two norm of A &times; X - B\n+         *\n+         * @param b Right-hand side of the equation A &times; X = B.\n+         * @return a Vector X that minimizes the two norm of A &times; X - B.\n+         *\n          * @throws DimensionMismatchException if the matrices dimensions do not match.\n          * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         }\n \n         /**\n-         * Check if the decomposed matrix is non-singular.\n-         * @return true if the decomposed matrix is non-singular\n+         * Checks whether the decomposed matrix is non-singular.\n+         *\n+         * @return true if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n             for (int i = 0; i < realEigenvalues.length; ++i) {\n-                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n+                if (realEigenvalues[i] == 0 &&\n+                    imagEigenvalues[i] == 0) {\n                     return false;\n                 }\n             }\n     }\n \n     /**\n-     * Transform matrix to tridiagonal.\n+     * Transforms the matrix to tridiagonal form.\n      *\n      * @param matrix Matrix to transform.\n      */\n      * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\n      *\n      * @param householderMatrix Householder matrix of the transformation\n-     * to tri-diagonal form.\n+     * to tridiagonal form.\n      */\n     private void findEigenVectors(double[][] householderMatrix) {\n-        double[][]z = householderMatrix.clone();\n+        final double[][]z = householderMatrix.clone();\n         final int n = main.length;\n         realEigenvalues = new double[n];\n         imagEigenvalues = new double[n];\n-        double[] e = new double[n];\n+        final double[] e = new double[n];\n         for (int i = 0; i < n - 1; i++) {\n             realEigenvalues[i] = main[i];\n             e[i] = secondary[i];\n         }\n         realEigenvalues[n - 1] = main[n - 1];\n-        e[n - 1] = 0.0;\n+        e[n - 1] = 0;\n \n         // Determine the largest main and secondary value in absolute term.\n-        double maxAbsoluteValue=0.0;\n+        double maxAbsoluteValue = 0;\n         for (int i = 0; i < n; i++) {\n-            if (FastMath.abs(realEigenvalues[i])>maxAbsoluteValue) {\n-                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n-            }\n-            if (FastMath.abs(e[i])>maxAbsoluteValue) {\n-                maxAbsoluteValue=FastMath.abs(e[i]);\n+            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n+                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n+            }\n+            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n+                maxAbsoluteValue = FastMath.abs(e[i]);\n             }\n         }\n         // Make null any main and secondary value too small to be significant\n-        if (maxAbsoluteValue!=0.0) {\n+        if (maxAbsoluteValue != 0) {\n             for (int i=0; i < n; i++) {\n-                if (FastMath.abs(realEigenvalues[i])<=Precision.EPSILON*maxAbsoluteValue) {\n-                    realEigenvalues[i]=0.0;\n-                }\n-                if (FastMath.abs(e[i])<=Precision.EPSILON*maxAbsoluteValue) {\n-                    e[i]=0.0;\n+                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n+                    realEigenvalues[i] = 0;\n+                }\n+                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n+                    e[i]=0;\n                 }\n             }\n         }\n             int m;\n             do {\n                 for (m = j; m < n - 1; m++) {\n-                    double delta = FastMath.abs(realEigenvalues[m]) + FastMath.abs(realEigenvalues[m + 1]);\n+                    double delta = FastMath.abs(realEigenvalues[m]) +\n+                        FastMath.abs(realEigenvalues[m + 1]);\n                     if (FastMath.abs(e[m]) + delta == delta) {\n                         break;\n                     }\n         }\n \n         // Determine the largest eigen value in absolute term.\n-        maxAbsoluteValue=0.0;\n+        maxAbsoluteValue = 0;\n         for (int i = 0; i < n; i++) {\n-            if (FastMath.abs(realEigenvalues[i])>maxAbsoluteValue) {\n+            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                 maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n             }\n         }\n         // Make null any eigen value too small to be significant\n         if (maxAbsoluteValue!=0.0) {\n             for (int i=0; i < n; i++) {\n-                if (FastMath.abs(realEigenvalues[i])<Precision.EPSILON*maxAbsoluteValue) {\n-                    realEigenvalues[i]=0.0;\n+                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n+                    realEigenvalues[i] = 0;\n                 }\n             }\n         }\n         eigenvectors = new ArrayRealVector[n];\n-        double[] tmp = new double[n];\n+        final double[] tmp = new double[n];\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 tmp[j] = z[j][i];", "timestamp": 1319709181, "metainfo": ""}