{"sha": "5edec31c26d01d2d23750aebaf2e90c097714e11", "log": "fixed javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n  * set of n+1 points in dimension n) that is updated by the algorithms\n  * steps.</p>\n \n- * <p>The instances can be built either in single-start or in\n+ * <p>Minimization can be attempted either in single-start or in\n  * multi-start mode. Multi-start is a traditional way to try to avoid\n- * beeing trapped in a local minimum and miss the global minimum of a\n+ * being trapped in a local minimum and miss the global minimum of a\n  * function. It can also be used to verify the convergence of an\n- * algorithm. In multi-start mode, the {@link #minimizes(CostFunction,\n- * int, ConvergenceChecker, double[], double[]) minimizes}\n- * method returns the best minimum found after all starts, and the\n+ * algorithm. The various multi-start-enabled <code>minimizes</code>\n+ * methods return the best minimum found after all starts, and the\n  * {@link #getMinima getMinima} method can be used to retrieve all\n  * minima from all starts (including the one already provided by the\n  * {@link #minimizes(CostFunction, int, ConvergenceChecker, double[],\n      * considered to represent two opposite vertices of a box parallel\n      * to the canonical axes of the space. The simplex is the subset of\n      * vertices encountered while going from vertexA to vertexB\n-     * travelling along the box edges only. This can be seen as a scaled\n+     * traveling along the box edges only. This can be seen as a scaled\n      * regular simplex using the projected separation between the given\n      * points as the scaling factor along each coordinate axis.</p>\n      * <p>The optimization is performed in single-start mode.</p>\n      * considered to represent two opposite vertices of a box parallel\n      * to the canonical axes of the space. The simplex is the subset of\n      * vertices encountered while going from vertexA to vertexB\n-     * travelling along the box edges only. This can be seen as a scaled\n+     * traveling along the box edges only. This can be seen as a scaled\n      * regular simplex using the projected separation between the given\n      * points as the scaling factor along each coordinate axis.</p>\n      * <p>The optimization is performed in multi-start mode.</p>\n                                    int starts, long seed)\n     throws CostException, ConvergenceException {\n \n-        // set up the simplex travelling around the box\n+        // set up the simplex traveling around the box\n         buildSimplex(vertexA, vertexB);\n \n         // we consider the simplex could have been produced by a generator\n         // having its mean value at the center of the box, the standard\n-        // deviation along each axe beeing the corresponding half size\n+        // deviation along each axe being the corresponding half size\n         double[] mean              = new double[vertexA.length];\n         double[] standardDeviation = new double[vertexA.length];\n         for (int i = 0; i < vertexA.length; ++i) {\n      * <p>The two vertices are considered to represent two opposite\n      * vertices of a box parallel to the canonical axes of the\n      * space. The simplex is the subset of vertices encountered while\n-     * going from vertexA to vertexB travelling along the box edges\n+     * going from vertexA to vertexB traveling along the box edges\n      * only. This can be seen as a scaled regular simplex using the\n      * projected separation between the given points as the scaling\n      * factor along each coordinate axis.</p>\n         int n = vertexA.length;\n         simplex = new PointCostPair[n + 1];\n \n-        // set up the simplex travelling around the box\n+        // set up the simplex traveling around the box\n         for (int i = 0; i <= n; ++i) {\n             double[] vertex = new double[n];\n             if (i > 0) {\n      * highest minimum cost, and null elements corresponding to the runs\n      * that did not converge (all elements will be null if the {@link\n      * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n-     * minimizes} method throwed a {@link ConvergenceException\n+     * minimizes} method did throw a {@link ConvergenceException\n      * ConvergenceException}).</p>\n      * @return array containing the minima, or null if {@link\n      * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])", "timestamp": 1189409935, "metainfo": ""}