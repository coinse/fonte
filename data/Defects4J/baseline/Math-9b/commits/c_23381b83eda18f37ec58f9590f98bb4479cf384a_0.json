{"sha": "23381b83eda18f37ec58f9590f98bb4479cf384a", "log": "simplified DifferentiableMultivariateVectorialFunction the gradient and partial derivaritves can be retrieved from the jacobian and adding them at the interface level was cumbersome for implementing optimization problems. Now users need to provide only the jacobian method  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction.java\n     extends MultivariateVectorialFunction {\n \n     /**\n-     * Returns the partial derivative of the function with respect to point\n-     * coordinate x<sub>j</sub>.\n-     * <p>\n-     * The partial derivative basically represents column j of the jacobian\n-     * matrix. If the partial derivatives with respect to all coordinates are\n-     * needed, it may be more efficient to use the {@link #jacobian()} method\n-     * which will compute the complete matrix at once.\n-     * </p>\n-     * @param j index of the coordinate with respect to which the partial\n-     * derivative is computed\n-     * @return the partial derivative function with respect to point coordinate\n-     * x<sub>i</sub>\n-     */\n-    MultivariateVectorialFunction partialDerivative(int j);\n-\n-    /**\n-     * Returns the gradient function of the i<sup>th</sup> component of\n-     * the vectorial function.\n-     * \n-     * <p>\n-     * The i<sup>th</sup> gradient basically represents row i of the jacobian\n-     * matrix. If all gradients are needed, it may be more efficient to use the\n-     * {@link #jacobian()} method which will compute the complete matrix at once.\n-     * </p>\n-     * @param i index of the function component for which the gradient is requested\n-     * @return the gradient function of the i<sup>th</sup> component of\n-     * the vectorial function\n-     */\n-    MultivariateVectorialFunction gradient(int i);\n-\n-    /**\n      * Returns the jacobian function.\n-     * <p>\n-     * If only one column of the jacobian is needed, it may be more efficient to\n-     * use the {@link #partialDerivative(int)} method which will compute only the\n-     * specified column. If only one row of the jacobian is needed, it may be more\n-     * efficient to use the {@link #gradient(int)} method which will compute only the\n-     * specified row.\n-     * </p>\n      * @return the jacobian function\n      */\n     MultivariateMatrixFunction jacobian();\n--- a/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n             return factors.operate(variables);\n         }\n \n-        public MultivariateVectorialFunction partialDerivative(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 1037082026387842358L;\n-                public double[] value(double[] point) {\n-                    return factors.getColumn(i);\n-                }\n-            };\n-        }\n-\n-        public MultivariateVectorialFunction gradient(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = -3268626996728727146L;\n-                public double[] value(double[] point) {\n-                    return factors.getRow(i);\n-                }\n-            };\n-        }\n-\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n                 private static final long serialVersionUID = -8387467946663627585L;\n \n         }\n \n-        public MultivariateVectorialFunction partialDerivative(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = -2884159755283203273L;\n-                public double[] value(double[] point) {\n-                    double[][] m = jacobian(point);\n-                    double[] partial = new double[m.length];\n-                    for (int j = 0; j < partial.length; ++j) {\n-                        partial[i] = m[i][j];\n-                    }\n-                    return partial;\n-                }\n-            };\n-        }\n-\n-        public MultivariateVectorialFunction gradient(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = -43357217231860547L;\n-                public double[] value(double[] point) {\n-                    return jacobian(point)[i];\n-                }\n-            };\n-        }\n-\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n                 private static final long serialVersionUID = -4340046230875165095L;\n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n             return factors.operate(variables);\n         }\n \n-        public MultivariateVectorialFunction partialDerivative(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 4868131119285501303L;\n-                public double[] value(double[] point) {\n-                    return factors.getColumn(i);\n-                }\n-            };\n-        }\n-\n-        public MultivariateVectorialFunction gradient(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 6280336674474631774L;\n-                public double[] value(double[] point) {\n-                    return factors.getRow(i);\n-                }\n-            };\n-        }\n-\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n                 private static final long serialVersionUID = 556396458721526234L;\n \n         }\n \n-        public MultivariateVectorialFunction partialDerivative(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = -2884159755283203273L;\n-                public double[] value(double[] point) {\n-                    double[][] m = jacobian(point);\n-                    double[] partial = new double[m.length];\n-                    for (int j = 0; j < partial.length; ++j) {\n-                        partial[i] = m[i][j];\n-                    }\n-                    return partial;\n-                }\n-            };\n-        }\n-\n-        public MultivariateVectorialFunction gradient(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = -43357217231860547L;\n-                public double[] value(double[] point) {\n-                    return jacobian(point)[i];\n-                }\n-            };\n-        }\n-\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n                 private static final long serialVersionUID = -4340046230875165095L;\n             return values;\n         }\n \n-        public MultivariateVectorialFunction partialDerivative(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 2371658898687841192L;\n-                public double[] value(double[] point) {\n-                    double[][] m = jacobian(point);\n-                    double[] partial = new double[m.length];\n-                    for (int j = 0; j < partial.length; ++j) {\n-                        partial[i] = m[i][j];\n-                    }\n-                    return partial;\n-                }\n-            };\n-        }\n-\n-        public MultivariateVectorialFunction gradient(final int i) {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 6863958501785879369L;\n-                public double[] value(double[] point) {\n-                    return jacobian(point)[i];\n-                }\n-            };\n-        }\n-\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n                 private static final long serialVersionUID = -8673650298627399464L;\n--- a/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n           return true;\n       }\n \n-      public MultivariateVectorialFunction partialDerivative(final int i) {\n-          return new MultivariateVectorialFunction() {\n-            private static final long serialVersionUID = 2192585229396907068L;\n-            public double[] value(double[] point) {\n-                  double[][] m = jacobian(point);\n-                  double[] partial = new double[m.length];\n-                  for (int j = 0; j < partial.length; ++j) {\n-                      partial[i] = m[i][j];\n-                  }\n-                  return partial;\n-              }\n-          };\n-      }\n-\n-      public MultivariateVectorialFunction gradient(final int i) {\n-          return new MultivariateVectorialFunction() {\n-            private static final long serialVersionUID = -5562016064510078300L;\n-            public double[] value(double[] point) {\n-                  return jacobian(point)[i];\n-              }\n-          };\n-      }\n-\n       public MultivariateMatrixFunction jacobian() {\n           return new MultivariateMatrixFunction() {\n             private static final long serialVersionUID = -2435076097232923678L;", "timestamp": 1242591574, "metainfo": ""}