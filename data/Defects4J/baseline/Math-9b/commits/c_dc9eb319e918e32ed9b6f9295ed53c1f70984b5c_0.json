{"sha": "dc9eb319e918e32ed9b6f9295ed53c1f70984b5c", "log": "Brought back some useful static methods.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n \n         // build orthonormalized base from u1, u2\n         // this fails when vectors are null or colinear, which is forbidden to define a rotation\n-        final FieldVector3D<T> u3 = u1.crossProduct(u2).normalize();\n-        u2 = u3.crossProduct(u1).normalize();\n+        final FieldVector3D<T> u3 = FieldVector3D.crossProduct(u1, u2).normalize();\n+        u2 = FieldVector3D.crossProduct(u3, u1).normalize();\n         u1 = u1.normalize();\n \n         // build an orthonormalized base from v1, v2\n         // this fails when vectors are null or colinear, which is forbidden to define a rotation\n-        final FieldVector3D<T> v3 = v1.crossProduct(v2).normalize();\n-        v2 = v3.crossProduct(v1).normalize();\n+        final FieldVector3D<T> v3 = FieldVector3D.crossProduct(v1, v2).normalize();\n+        v2 = FieldVector3D.crossProduct(v3, v1).normalize();\n         v1 = v1.normalize();\n \n         // buid a matrix transforming the first base into the second one\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n         }\n \n-        final T dot = u.dotProduct(v);\n+        final T dot = FieldVector3D.dotProduct(u, v);\n \n         if (dot.getReal() < ((2.0e-15 - 1.0) * normProduct.getReal())) {\n             // special case u = -v: we select a PI angle rotation around\n             // the shortest possible rotation: axis orthogonal to this plane\n             q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n             final T coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n-            final FieldVector3D<T> q = v.crossProduct(u);\n+            final FieldVector3D<T> q = FieldVector3D.crossProduct(v, u);\n             q1 = coeff.multiply(q.getX());\n             q2 = coeff.multiply(q.getY());\n             q3 = coeff.multiply(q.getZ());\n     /** Apply a rotation to a vector.\n      * @param r rotation to apply\n      * @param u vector to apply the rotation to\n+     * @param <T> the type of the field elements\n      * @return a new vector which is the image of u by the rotation\n      */\n     public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n     /** Apply the inverse of a rotation to a vector.\n      * @param r rotation to apply\n      * @param u vector to apply the inverse of the rotation to\n+     * @param <T> the type of the field elements\n      * @return a new vector which such that u is its image by the rotation\n      */\n     public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n      * where comp = applyTo(rOuter, rInner).\n      * @param r1 rotation to apply\n      * @param rInner rotation to apply the rotation to\n+     * @param <T> the type of the field elements\n      * @return a new rotation which is the composition of r by the instance\n      */\n     public static <T extends ExtendedFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n      * comp = applyInverseTo(rOuter, rInner).\n      * @param rOuter rotation to apply the rotation to\n      * @param rInner rotation to apply the rotation to\n+     * @param <T> the type of the field elements\n      * @return a new rotation which is the composition of r by the inverse\n      * of the instance\n      */\n      * their components are different (they are exact opposites).</p>\n      * @param r1 first rotation\n      * @param r2 second rotation\n+     * @param <T> the type of the field elements\n      * @return <i>distance</i> between r1 and r2\n      */\n     public static <T extends ExtendedFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n \n     }\n \n-    /** Compute the angular separation between the instance and another vector.\n+    /** Compute the angular separation between two vectors.\n      * <p>This method computes the angular separation between two\n      * vectors using the dot product for well separated vectors and the\n      * cross product for almost aligned vectors. This allows to have a\n      * good accuracy in all cases, even for vectors very close to each\n      * other.</p>\n-     * @param v second vector\n-     * @return angular separation between the instance and v\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return angular separation between v1 and v2\n      * @exception MathArithmeticException if either vector has a null norm\n      */\n-    public T angle(FieldVector3D<T> v) throws MathArithmeticException {\n-\n-        final T normProduct = getNorm().multiply(v.getNorm());\n+    public static <T extends ExtendedFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2)\n+        throws MathArithmeticException {\n+\n+        final T normProduct = v1.getNorm().multiply(v2.getNorm());\n         if (normProduct.getReal() == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n \n-        final T dot = dotProduct(v);\n+        final T dot = dotProduct(v1, v2);\n         final double threshold = normProduct.getReal() * 0.9999;\n         if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n             // the vectors are almost aligned, compute using the sine\n-            FieldVector3D<T> v3 = crossProduct(v);\n+            FieldVector3D<T> v3 = crossProduct(v1, v2);\n             if (dot.getReal() >= 0) {\n                 return v3.getNorm().divide(normProduct).asin();\n             }\n         // the vectors are sufficiently separated to use the cosine\n         return dot.divide(normProduct).acos();\n \n+    }\n+\n+    /** Compute the angular separation between two vectors.\n+     * <p>This method computes the angular separation between two\n+     * vectors using the dot product for well separated vectors and the\n+     * cross product for almost aligned vectors. This allows to have a\n+     * good accuracy in all cases, even for vectors very close to each\n+     * other.</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return angular separation between v1 and v2\n+     * @exception MathArithmeticException if either vector has a null norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2)\n+        throws MathArithmeticException {\n+\n+        final T normProduct = v1.getNorm().multiply(v2.getNorm());\n+        if (normProduct.getReal() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        final T dot = dotProduct(v1, v2);\n+        final double threshold = normProduct.getReal() * 0.9999;\n+        if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n+            // the vectors are almost aligned, compute using the sine\n+            FieldVector3D<T> v3 = crossProduct(v1, v2);\n+            if (dot.getReal() >= 0) {\n+                return v3.getNorm().divide(normProduct).asin();\n+            }\n+            return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n+        }\n+\n+        // the vectors are sufficiently separated to use the cosine\n+        return dot.divide(normProduct).acos();\n+\n+    }\n+\n+    /** Compute the angular separation between two vectors.\n+     * <p>This method computes the angular separation between two\n+     * vectors using the dot product for well separated vectors and the\n+     * cross product for almost aligned vectors. This allows to have a\n+     * good accuracy in all cases, even for vectors very close to each\n+     * other.</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return angular separation between v1 and v2\n+     * @exception MathArithmeticException if either vector has a null norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2)\n+        throws MathArithmeticException {\n+        return angle(v2, v1);\n     }\n \n     /** Get the opposite of the instance.\n         return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n     }\n \n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the dot product v1.v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n+                                                                   final FieldVector3D<T> v2) {\n+        return v1.dotProduct(v2);\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the dot product v1.v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n+                                                                   final Vector3D v2) {\n+        return v1.dotProduct(v2);\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the dot product v1.v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T dotProduct(final Vector3D v1,\n+                                                                   final FieldVector3D<T> v2) {\n+        return v2.dotProduct(v1);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n+                                                                                    final FieldVector3D<T> v2) {\n+        return v1.crossProduct(v2);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n+                                                                                    final Vector3D v2) {\n+        return v1.crossProduct(v2);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1,\n+                                                                                    final FieldVector3D<T> v2) {\n+        return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y),\n+                                    v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z),\n+                                    v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n+                                                                  final FieldVector3D<T> v2) {\n+        return v1.distance1(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n+                                                                  final Vector3D v2) {\n+        return v1.distance1(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance1(final Vector3D v1,\n+                                                                  final FieldVector3D<T> v2) {\n+        return v2.distance1(v1);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance(final FieldVector3D<T> v1,\n+                                                                 final FieldVector3D<T> v2) {\n+        return v1.distance(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance(final FieldVector3D<T> v1,\n+                                                                 final Vector3D v2) {\n+        return v1.distance(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distance(final Vector3D v1,\n+                                                                 final FieldVector3D<T> v2) {\n+        return v2.distance(v1);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n+                                                                    final FieldVector3D<T> v2) {\n+        return v1.distanceInf(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n+                                                                    final Vector3D v2) {\n+        return v1.distanceInf(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceInf(final Vector3D v1,\n+                                                                    final FieldVector3D<T> v2) {\n+        return v2.distanceInf(v1);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n+                                                                   final FieldVector3D<T> v2) {\n+        return v1.distanceSq(v2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n+                                                                   final Vector3D v2) {\n+        return v1.distanceSq(v2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @param <T> the type of the field elements\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static <T extends ExtendedFieldElement<T>> T distanceSq(final Vector3D v1,\n+                                                                   final FieldVector3D<T> v2) {\n+        return v2.distanceSq(v1);\n+    }\n+\n     /** Get a string representation of this vector.\n      * @return a string representation of this vector\n      */\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDSTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDSTest.java\n         Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n         Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n         Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);\n-        Assert.assertEquals(-1, r.getAxis().dotProduct(reverted.getAxis()).getReal(), 1.0e-15);\n+        Assert.assertEquals(-1, FieldVector3D.dotProduct(r.getAxis(), reverted.getAxis()).getReal(), 1.0e-15);\n     }\n \n     @Test\n \n         r = new FieldRotation<DerivativeStructure>(u1, u2, u1.negate(), u2.negate());\n         FieldVector3D<DerivativeStructure> axis = r.getAxis();\n-        if (axis.dotProduct(createVector(0, 0, 1)).getReal() > 0) {\n+        if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() > 0) {\n             checkVector(axis, createVector(0, 0, 1));\n         } else {\n             checkVector(axis, createVector(0, 0, -1));\n                            createVector(0.5, 0.5, -sqrt));\n         checkRotationDS(r, sqrt, 0.5, 0.5, 0);\n \n-        r = new FieldRotation<DerivativeStructure>(u1, u2, u1, u1.crossProduct(u2));\n+        r = new FieldRotation<DerivativeStructure>(u1, u2, u1, FieldVector3D.crossProduct(u1, u2));\n         checkRotationDS(r, sqrt, -sqrt, 0, 0);\n \n         checkRotationDS(new FieldRotation<DerivativeStructure>(u1, u2, u1, u2), 1, 0, 0, 0);\n         checkRotationDS(r1,\n                         -r1.getQ0().getReal(), -r1.getQ1().getReal(),\n                         -r1.getQ2().getReal(), -r1.getQ3().getReal());\n+        Assert.assertEquals(0.288, r1.toRotation().getQ0(), 1.0e-15);\n+        Assert.assertEquals(0.384, r1.toRotation().getQ1(), 1.0e-15);\n+        Assert.assertEquals(0.36,  r1.toRotation().getQ2(), 1.0e-15);\n+        Assert.assertEquals(0.8,   r1.toRotation().getQ3(), 1.0e-15);\n \n     }\n \n                     quat.getQ2().getReal() * quat.getQ2().getReal() +\n                     quat.getQ3().getReal() * quat.getQ3().getReal();\n         Assert.assertEquals(1.0, q2, 1.0e-14);\n-        Assert.assertEquals(0.0, v1.angle(quat.applyTo(u1)).getReal(), 1.0e-14);\n-        Assert.assertEquals(0.0, v2.angle(quat.applyTo(u2)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDfpTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotationDfpTest.java\n         FieldRotation<Dfp> rTr = reverted.applyTo(r);\n         checkRotationDS(rTr, 1, 0, 0, 0);\n         Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);\n-        Assert.assertEquals(-1, r.getAxis().dotProduct(reverted.getAxis()).getReal(), 1.0e-15);\n+        Assert.assertEquals(-1, FieldVector3D.dotProduct(r.getAxis(), reverted.getAxis()).getReal(), 1.0e-15);\n     }\n \n     @Test\n \n         r = new FieldRotation<Dfp>(u1, u2, u1.negate(), u2.negate());\n         FieldVector3D<Dfp> axis = r.getAxis();\n-        if (axis.dotProduct(createVector(0, 0, 1)).getReal() > 0) {\n+        if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() > 0) {\n             checkVector(axis, createVector(0, 0, 1));\n         } else {\n             checkVector(axis, createVector(0, 0, -1));\n                            createVector(0.5, 0.5, -sqrt));\n         checkRotationDS(r, sqrt, 0.5, 0.5, 0);\n \n-        r = new FieldRotation<Dfp>(u1, u2, u1, u1.crossProduct(u2));\n+        r = new FieldRotation<Dfp>(u1, u2, u1, FieldVector3D.crossProduct(u1, u2));\n         checkRotationDS(r, sqrt, -sqrt, 0, 0);\n \n         checkRotationDS(new FieldRotation<Dfp>(u1, u2, u1, u2), 1, 0, 0, 0);\n                     quat.getQ2().getReal() * quat.getQ2().getReal() +\n                     quat.getQ3().getReal() * quat.getQ3().getReal();\n         Assert.assertEquals(1.0, q2, 1.0e-14);\n-        Assert.assertEquals(0.0, v1.angle(quat.applyTo(u1)).getReal(), 1.0e-14);\n-        Assert.assertEquals(0.0, v2.angle(quat.applyTo(u2)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14);\n+        Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3DTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3DTest.java\n     public void testDistance1() {\n         FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n-        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distance1(createVector(-1, 0, 0, 3)).getReal(), 0);\n-        DerivativeStructure distance = v1.distance1(v2);\n+        Assert.assertEquals(0.0, FieldVector3D.distance1(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = FieldVector3D.distance1(v1, v2);\n         Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n-        distance = v1.distance1(new Vector3D(-4, 2, 0));\n+        distance = FieldVector3D.distance1(v1, new Vector3D(-4, 2, 0));\n         Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);\n         Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = FieldVector3D.distance1(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(12.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n     }\n \n     @Test\n     public void testDistance() {\n         FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n-        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distance(createVector(-1, 0, 0, 3)).getReal(), 0);\n-        DerivativeStructure distance = v1.distance(v2);\n+        Assert.assertEquals(0.0, FieldVector3D.distance(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = FieldVector3D.distance(v1, v2);\n         Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n-        distance = v1.distance(new Vector3D(-4, 2, 0));\n+        distance = FieldVector3D.distance(v1, new Vector3D(-4, 2, 0));\n         Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);\n         Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = FieldVector3D.distance(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12);\n+        Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n     }\n \n     @Test\n     public void testDistanceSq() {\n         FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n-        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distanceSq(createVector(-1, 0, 0, 3)).getReal(), 0);\n-        DerivativeStructure distanceSq = v1.distanceSq(v2);\n+        Assert.assertEquals(0.0, FieldVector3D.distanceSq(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distanceSq = FieldVector3D.distanceSq(v1, v2);\n         Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);\n         Assert.assertEquals(0, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n-        distanceSq = v1.distanceSq(new Vector3D(-4, 2, 0));\n+        distanceSq = FieldVector3D.distanceSq(v1, new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);\n+        Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distanceSq = FieldVector3D.distanceSq(new Vector3D(-4, 2, 0), v1);\n         Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12);\n         Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n     public void testDistanceInf() {\n         FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3);\n-        Assert.assertEquals(0.0, createVector(-1, 0, 0, 3).distanceInf(createVector(-1, 0, 0, 3)).getReal(), 0);\n-        DerivativeStructure distance = v1.distanceInf(v2);\n+        Assert.assertEquals(0.0, FieldVector3D.distanceInf(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0);\n+        DerivativeStructure distance = FieldVector3D.distanceInf(v1, v2);\n         Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n-        distance = v1.distanceInf(new Vector3D(-4, 2, 0));\n+        distance = FieldVector3D.distanceInf(v1, new Vector3D(-4, 2, 0));\n         Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);\n         Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n         Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n-        Assert.assertEquals(v1.subtract(v2).getNormInf().getReal(), v1.distanceInf(v2).getReal(), 1.0e-12);\n-\n-        Assert.assertEquals(5.0,\n-                            createVector( 1, -2, 3, 3).distanceInf(createVector(-4,  2, 0, 3)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector( 1, 3, -2, 3).distanceInf(createVector(-4, 0,  2, 3)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(-2,  1, 3, 3).distanceInf(createVector( 2, -4, 0, 3)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(-2, 3,  1, 3).distanceInf(createVector( 2, 0, -4, 3)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(3, -2,  1, 3).distanceInf(createVector(0,  2, -4, 3)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(3,  1, -2, 3).distanceInf(createVector(0, -4,  2, 3)).getReal(),\n-                            1.0e-12);\n-\n-        Assert.assertEquals(5.0,\n-                            createVector( 1, -2, 3, 3).distanceInf(new Vector3D(-4,  2, 0)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector( 1, 3, -2, 3).distanceInf(new Vector3D(-4, 0,  2)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(-2,  1, 3, 3).distanceInf(new Vector3D( 2, -4, 0)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(-2, 3,  1, 3).distanceInf(new Vector3D( 2, 0, -4)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(3, -2,  1, 3).distanceInf(new Vector3D(0,  2, -4)).getReal(),\n-                            1.0e-12);\n-        Assert.assertEquals(5.0,\n-                            createVector(3,  1, -2, 3).distanceInf(new Vector3D(0, -4,  2)).getReal(),\n+        distance = FieldVector3D.distanceInf(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(5.0, distance.getReal(), 1.0e-12);\n+        Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNormInf().getReal(), FieldVector3D.distanceInf(v1, v2).getReal(), 1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), createVector(-4,  2, 0, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), createVector(-4, 0,  2, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(-2,  1, 3, 3), createVector( 2, -4, 0, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(-2, 3,  1, 3), createVector( 2, 0, -4, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(3, -2,  1, 3), createVector(0,  2, -4, 3)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(3,  1, -2, 3), createVector(0, -4,  2, 3)).getReal(),\n+                            1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), new Vector3D(-4,  2, 0)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), new Vector3D(-4, 0,  2)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(-2,  1, 3, 3), new Vector3D( 2, -4, 0)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(-2, 3,  1, 3), new Vector3D( 2, 0, -4)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(3, -2,  1, 3), new Vector3D(0,  2, -4)).getReal(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            FieldVector3D.distanceInf(createVector(3,  1, -2, 3), new Vector3D(0, -4,  2)).getReal(),\n                             1.0e-12);\n \n     }\n         FieldVector3D<DerivativeStructure> v1 = createVector(2, 1, -4, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(3, 1, -1, 3);\n \n-        Assert.assertTrue(FastMath.abs(v1.dotProduct(v2).getReal() - 11) < 1.0e-12);\n-\n-        FieldVector3D<DerivativeStructure> v3 = v1.crossProduct(v2);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v2).getReal() - 11) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v2.toVector3D()).getReal() - 11) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1.toVector3D(), v2).getReal() - 11) < 1.0e-12);\n+\n+        FieldVector3D<DerivativeStructure> v3 = FieldVector3D.crossProduct(v1, v2);\n         checkVector(v3, 3, -10, -1);\n-\n-        Assert.assertTrue(FastMath.abs(v1.dotProduct(v3).getReal()) < 1.0e-12);\n-        Assert.assertTrue(FastMath.abs(v2.dotProduct(v3).getReal()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12);\n+\n+        v3 = FieldVector3D.crossProduct(v1, v2.toVector3D());\n+        checkVector(v3, 3, -10, -1);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12);\n+\n+        v3 = FieldVector3D.crossProduct(v1.toVector3D(), v2);\n+        checkVector(v3, 3, -10, -1);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12);\n+\n     }\n \n     @Test\n     public void testCrossProductCancellation() {\n         FieldVector3D<DerivativeStructure> v1 = createVector(9070467121.0, 4535233560.0, 1, 3);\n         FieldVector3D<DerivativeStructure> v2 = createVector(9070467123.0, 4535233561.0, 1, 3);\n-        checkVector(v1.crossProduct(v2), -1, 2, 1);\n+        checkVector(FieldVector3D.crossProduct(v1, v2), -1, 2, 1);\n \n         double scale    = FastMath.scalb(1.0, 100);\n         FieldVector3D<DerivativeStructure> big1   = new FieldVector3D<DerivativeStructure>(scale, v1);\n         FieldVector3D<DerivativeStructure> small2 = new FieldVector3D<DerivativeStructure>(1 / scale, v2);\n-        checkVector(big1.crossProduct(small2), -1, 2, 1);\n+        checkVector(FieldVector3D.crossProduct(big1, small2), -1, 2, 1);\n \n     }\n \n         FieldVector3D<DerivativeStructure>  i = k.orthogonal();\n         FieldVector3D<DerivativeStructure> v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));\n \n-        Assert.assertTrue(FastMath.abs(v1.angle(v2).getReal() - 1.2) < 1.0e-12);\n-  }\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1, v2).getReal() - 1.2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1, v2.toVector3D()).getReal() - 1.2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1.toVector3D(), v2).getReal() - 1.2) < 1.0e-12);\n+\n+        try {\n+            FieldVector3D.angle(v1, Vector3D.ZERO);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException mae) {\n+            // expected\n+        }\n+        Assert.assertEquals(0.0, FieldVector3D.angle(v1, v1.toVector3D()).getReal(), 1.0e-15);\n+        Assert.assertEquals(FastMath.PI, FieldVector3D.angle(v1, v1.negate().toVector3D()).getReal(), 1.0e-15);\n+\n+    }\n \n     @Test\n     public void testNormalize() throws MathArithmeticException {\n     @Test\n     public void testOrthogonal() throws MathArithmeticException {\n         FieldVector3D<DerivativeStructure> v1 = createVector(0.1, 2.5, 1.3, 3);\n-        Assert.assertEquals(0.0, v1.dotProduct(v1.orthogonal()).getReal(), 1.0e-12);\n+        Assert.assertEquals(0.0, FieldVector3D.dotProduct(v1, v1.orthogonal()).getReal(), 1.0e-12);\n         FieldVector3D<DerivativeStructure> v2 = createVector(2.3, -0.003, 7.6, 3);\n-        Assert.assertEquals(0.0, v2.dotProduct(v2.orthogonal()).getReal(), 1.0e-12);\n+        Assert.assertEquals(0.0, FieldVector3D.dotProduct(v2, v2.orthogonal()).getReal(), 1.0e-12);\n         FieldVector3D<DerivativeStructure> v3 = createVector(-1.7, 1.4, 0.2, 3);\n-        Assert.assertEquals(0.0, v3.dotProduct(v3.orthogonal()).getReal(), 1.0e-12);\n+        Assert.assertEquals(0.0, FieldVector3D.dotProduct(v3, v3.orthogonal()).getReal(), 1.0e-12);\n         FieldVector3D<DerivativeStructure> v4 = createVector(4.2, 0.1, -1.8, 3);\n-        Assert.assertEquals(0.0, v4.dotProduct(v4.orthogonal()).getReal(), 1.0e-12);\n+        Assert.assertEquals(0.0, FieldVector3D.dotProduct(v4, v4.orthogonal()).getReal(), 1.0e-12);\n         try {\n             createVector(0, 0, 0, 3).orthogonal();\n             Assert.fail(\"an exception should have been thrown\");\n     @Test\n     public void testAngle() throws MathArithmeticException {\n         Assert.assertEquals(0.22572612855273393616,\n-                            createVector(1, 2, 3, 3).angle(createVector(4, 5, 6, 3)).getReal(),\n+                            FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(4, 5, 6, 3)).getReal(),\n                             1.0e-12);\n         Assert.assertEquals(7.98595620686106654517199e-8,\n-                            createVector(1, 2, 3, 3).angle(createVector(2, 4, 6.000001, 3)).getReal(),\n+                            FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(2, 4, 6.000001, 3)).getReal(),\n                             1.0e-12);\n         Assert.assertEquals(3.14159257373023116985197793156,\n-                            createVector(1, 2, 3, 3).angle(createVector(-2, -4, -6.000001, 3)).getReal(),\n+                            FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(-2, -4, -6.000001, 3)).getReal(),\n                             1.0e-12);\n         try {\n-            createVector(0, 0, 0, 3).angle(createVector(1, 0, 0, 3));\n+            FieldVector3D.angle(createVector(0, 0, 0, 3), createVector(1, 0, 0, 3));\n             Assert.fail(\"an exception should have been thrown\");\n         } catch (MathArithmeticException ae) {\n             // expected behavior\n                                    -4550117129121957.0 /    2097152.0,\n                                     8846951984510141.0 /     131072.0, 3);\n         DerivativeStructure sNaive = u1.getX().multiply(u2.getX()).add(u1.getY().multiply(u2.getY())).add(u1.getZ().multiply(u2.getZ()));\n-        DerivativeStructure sAccurate = u1.dotProduct(u2);\n+        DerivativeStructure sAccurate = FieldVector3D.dotProduct(u1, u2);\n         Assert.assertEquals(0.0, sNaive.getReal(), 1.0e-30);\n         Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate.getReal(), 1.0e-16);\n     }\n             FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);\n             Vector3D v = new Vector3D(vx, vy, vz);\n \n-            DerivativeStructure sAccurate = uds.dotProduct(vds);\n+            DerivativeStructure sAccurate = FieldVector3D.dotProduct(uds, vds);\n             Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive);\n             Assert.assertEquals(ux + vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n             Assert.assertEquals(uy + vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n             Assert.assertEquals(uz + vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n \n-            sAccurate = uds.dotProduct(v);\n+            sAccurate = FieldVector3D.dotProduct(uds, v);\n             Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive);\n             Assert.assertEquals(vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n             Assert.assertEquals(vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n         FieldVector3D<DerivativeStructure> cNaive = new FieldVector3D<DerivativeStructure>(u1.getY().multiply(u2.getZ()).subtract(u1.getZ().multiply(u2.getY())),\n                                        u1.getZ().multiply(u2.getX()).subtract(u1.getX().multiply(u2.getZ())),\n                                        u1.getX().multiply(u2.getY()).subtract(u1.getY().multiply(u2.getX())));\n-        FieldVector3D<DerivativeStructure> cAccurate = u1.crossProduct(u2);\n-        Assert.assertTrue(u3.distance(cNaive).getReal() > 2.9 * u3.getNorm().getReal());\n-        Assert.assertEquals(0.0, u3.distance(cAccurate).getReal(), 1.0e-30 * cAccurate.getNorm().getReal());\n+        FieldVector3D<DerivativeStructure> cAccurate = FieldVector3D.crossProduct(u1, u2);\n+        Assert.assertTrue(FieldVector3D.distance(u3, cNaive).getReal() > 2.9 * u3.getNorm().getReal());\n+        Assert.assertEquals(0.0, FieldVector3D.distance(u3, cAccurate).getReal(), 1.0e-30 * cAccurate.getNorm().getReal());\n     }\n \n     @Test\n             FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3);\n             Vector3D v = new Vector3D(vx, vy, vz);\n \n-            checkVector(uds.crossProduct(vds),\n+            checkVector(FieldVector3D.crossProduct(uds, vds),\n                         cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n                         0, vz - uz, uy - vy,\n                         uz - vz, 0, vx - ux,\n                         vy - uy, ux - vx, 0);\n \n-            checkVector(uds.crossProduct(v),\n+            checkVector(FieldVector3D.crossProduct(uds, v),\n                         cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n                           0,  vz, -vy,\n                         -vz,   0,  vx,", "timestamp": 1361870965, "metainfo": ""}