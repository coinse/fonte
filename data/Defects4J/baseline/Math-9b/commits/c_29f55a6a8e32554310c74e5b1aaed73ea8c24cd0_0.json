{"sha": "29f55a6a8e32554310c74e5b1aaed73ea8c24cd0", "log": "In o.a.c.m.complex.RootsOfUnity - renamed computeOmega(int) to computeRoots(int) - renamed getOmegaReal(int) to getReal(int) - renamed getOmegaImaginary(int) to getImaginary(int) - added int getNumberOfRoots() - added unit tests. See MATH-677  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/RootsOfUnity.java\n+++ b/src/main/java/org/apache/commons/math/complex/RootsOfUnity.java\n     private double[] omegaImaginaryClockwise;\n \n     /**\n-     * {@code true} if {@link #computeOmega(int)} was called with a positive\n+     * {@code true} if {@link #computeRoots(int)} was called with a positive\n      * value of its argument {@code n}. In this case, counter-clockwise ordering\n      * of the roots of unity should be used.\n      */\n     }\n \n     /**\n-     * Returns {@code true} if {@link #computeOmega(int)} was called with a\n+     * Returns {@code true} if {@link #computeRoots(int)} was called with a\n      * positive value of its argument {@code n}. If {@code true}, then\n      * counter-clockwise ordering of the roots of unity should be used.\n      *\n      * @param n the (signed) number of roots of unity to be computed\n      * @throws ZeroException if {@code n = 0}\n      */\n-    public synchronized void computeOmega(int n) throws ZeroException {\n+    public synchronized void computeRoots(int n) throws ZeroException {\n \n         if (n == 0) {\n             throw new ZeroException(\n      * computed yet\n      * @throws MathIllegalArgumentException if {@code k} is out of range\n      */\n-    public synchronized double getOmegaReal(int k)\n+    public synchronized double getReal(int k)\n             throws MathIllegalStateException, MathIllegalArgumentException {\n \n         if (omegaCount == 0) {\n      * computed yet\n      * @throws OutOfRangeException if {@code k} is out of range\n      */\n-    public synchronized double getOmegaImaginary(int k)\n+    public synchronized double getImaginary(int k)\n             throws MathIllegalStateException, OutOfRangeException {\n \n         if (omegaCount == 0) {\n         return isCounterClockWise ? omegaImaginaryCounterClockwise[k] :\n             omegaImaginaryClockwise[k];\n     }\n+\n+    /**\n+     * Returns the number of roots of unity currently stored. If\n+     * {@link #computeRoots(int)} was called with {@code n}, then this method\n+     * returns {@code abs(n)}. If no roots of unity have been computed yet, this\n+     * method returns 0.\n+     *\n+     * @return the number of roots of unity currently stored\n+     */\n+    public synchronized int getNumberOfRoots() {\n+        return omegaCount;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n      * not a power of two\n      */\n     public Complex[] transform(Complex[] f) {\n-        roots.computeOmega(-f.length);\n+        roots.computeRoots(-f.length);\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n             return TransformUtils.scaleArray(fft(f), s);\n      * not a power of two\n      */\n     public Complex[] inverseTransform(Complex[] f) {\n-        roots.computeOmega(f.length);\n+        roots.computeRoots(f.length);\n         final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n         return TransformUtils.scaleArray(fft(f), s);\n     }\n         for (int i = 0; i < n; i++) {\n             repacked[i] = new Complex(f[2 * i], f[2 * i + 1]);\n         }\n-        roots.computeOmega(isInverse ? n : -n);\n+        roots.computeRoots(isInverse ? n : -n);\n         Complex[] z = fft(repacked);\n \n         // reconstruct the FFT result for the original array\n-        roots.computeOmega(isInverse ? 2 * n : -2 * n);\n+        roots.computeRoots(isInverse ? 2 * n : -2 * n);\n         transformed[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n         transformed[n] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n         for (int i = 1; i < n; i++) {\n             Complex b = z[i].add(a);\n             Complex c = z[i].subtract(a);\n             //Complex D = roots.getOmega(i).multiply(Complex.I);\n-            Complex d = new Complex(-roots.getOmegaImaginary(i),\n-                                    roots.getOmegaReal(i));\n+            Complex d = new Complex(-roots.getImaginary(i),\n+                                    roots.getReal(i));\n             transformed[i] = b.subtract(c.multiply(d));\n             transformed[2 * n - i] = transformed[i].conjugate();\n         }\n                 for (int k = 0; k < i; k++) {\n                     //z = f[i+j+k].multiply(roots.getOmega(k*m));\n                     final int km = k * m;\n-                    final double omegaKmReal = roots.getOmegaReal(km);\n-                    final double omegaKmImag = roots.getOmegaImaginary(km);\n+                    final double omegaKmReal = roots.getReal(km);\n+                    final double omegaKmImag = roots.getImaginary(km);\n                     //z = f[i+j+k].multiply(omega[k*m]);\n                     final Complex z = new Complex(\n                         f[i + j + k].getReal() * omegaKmReal -\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/complex/RootsOfUnityTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Unit tests for the {@link RootsOfUnity} class.\n+ *\n+ * @version $Id$\n+ */\n+public class RootsOfUnityTest {\n+\n+    @Test(expected = MathIllegalStateException.class)\n+    public void testMathIllegalState1() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        roots.getReal(0);\n+    }\n+\n+    @Test(expected = MathIllegalStateException.class)\n+    public void testMathIllegalState2() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        roots.getImaginary(0);\n+    }\n+\n+    @Test(expected = MathIllegalStateException.class)\n+    public void testMathIllegalState3() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        roots.isCounterClockWise();\n+    }\n+\n+    @Test(expected = ZeroException.class)\n+    public void testZeroNumberOfRoots() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        roots.computeRoots(0);\n+    }\n+\n+    @Test\n+    public void testGetNumberOfRoots() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        Assert.assertEquals(\"\", 0, roots.getNumberOfRoots());\n+        roots.computeRoots(5);\n+        Assert.assertEquals(\"\", 5, roots.getNumberOfRoots());\n+        /*\n+         * Testing -5 right after 5 is important, as the roots in this case are\n+         * not recomputed.\n+         */\n+        roots.computeRoots(-5);\n+        Assert.assertEquals(\"\", 5, roots.getNumberOfRoots());\n+        roots.computeRoots(6);\n+        Assert.assertEquals(\"\", 6, roots.getNumberOfRoots());\n+    }\n+\n+    @Test\n+    public void testComputeRoots() {\n+        final RootsOfUnity roots = new RootsOfUnity();\n+        for (int n = -10; n < 11; n++) {\n+            /*\n+             * Testing -n right after n is important, as the roots in this case\n+             * are not recomputed.\n+             */\n+            if (n != 0) {\n+                roots.computeRoots(n);\n+                doTestComputeRoots(roots);\n+                roots.computeRoots(-n);\n+                doTestComputeRoots(roots);\n+            }\n+        }\n+    }\n+\n+    private void doTestComputeRoots(final RootsOfUnity roots) {\n+        final int n = roots.isCounterClockWise() ? roots.getNumberOfRoots() :\n+            -roots.getNumberOfRoots();\n+        final double tol = 10 * Math.ulp(1.0);\n+        for (int k = 0; k < n; k++) {\n+            final double t = 2.0 * FastMath.PI * k / n;\n+            final String msg = String.format(\"n = %d, k = %d\", n, k);\n+            Assert.assertEquals(msg, FastMath.cos(t), roots.getReal(k), tol);\n+            Assert.assertEquals(msg, FastMath.sin(t), roots.getImaginary(k), tol);\n+        }\n+    }\n+}", "timestamp": 1328061056, "metainfo": ""}