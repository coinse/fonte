{"sha": "994756b1a06de64cc418413fe9a7e7507f75ff79", "log": "Finished moving methods from MathUtils to ArithmeticsUtils (MATH-689)  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n import java.util.Map;\n \n import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * A collection of static methods that operate on or return polynomials.\n         final int[][] coeff = new int[dp1][dp1];\n         for (int i = 0; i < dp1; i++){\n             for(int j = 0; j <= i; j++){\n-                coeff[i][j] = (int) MathUtils.binomialCoefficient(i, j);\n+                coeff[i][j] = (int) ArithmeticsUtils.binomialCoefficient(i, j);\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * @return PMF for the distribution.\n      */\n     private double probability(int n, int m, int k, int x) {\n-        return FastMath.exp(MathUtils.binomialCoefficientLog(m, x) +\n-               MathUtils.binomialCoefficientLog(n - m, k - x) -\n-               MathUtils.binomialCoefficientLog(n, k));\n+        return FastMath.exp(ArithmeticsUtils.binomialCoefficientLog(m, x) +\n+               ArithmeticsUtils.binomialCoefficientLog(n - m, k - x) -\n+               ArithmeticsUtils.binomialCoefficientLog(n, k));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         if (x < 0) {\n             ret = 0.0;\n         } else {\n-            ret = MathUtils.binomialCoefficientDouble(x +\n+            ret = ArithmeticsUtils.binomialCoefficientDouble(x +\n                   numberOfSuccesses - 1, numberOfSuccesses - 1) *\n                   FastMath.pow(probabilityOfSuccess, numberOfSuccesses) *\n                   FastMath.pow(1.0 - probabilityOfSuccess, x);\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.ArithmeticsUtils;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         int d1 = ArithmeticsUtils.gcd(denominator, fraction.denominator);\n         if (d1==1) {\n             // result is ( (u*v' +/- u'v) / u'v')\n-            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n-            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n+            int uvp = ArithmeticsUtils.mulAndCheck(numerator, fraction.denominator);\n+            int upv = ArithmeticsUtils.mulAndCheck(fraction.numerator, denominator);\n             return new Fraction\n                 (isAdd ? ArithmeticsUtils.addAndCheck(uvp, upv) :\n                  ArithmeticsUtils.subAndCheck(uvp, upv),\n-                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n+                 ArithmeticsUtils.mulAndCheck(denominator, fraction.denominator));\n         }\n         // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n         // exercise 7.  we're going to use a BigInteger.\n                                               w);\n         }\n         return new Fraction (w.intValue(),\n-                MathUtils.mulAndCheck(denominator/d1,\n+                ArithmeticsUtils.mulAndCheck(denominator/d1,\n                         fraction.denominator/d2));\n     }\n \n         int d1 = ArithmeticsUtils.gcd(numerator, fraction.denominator);\n         int d2 = ArithmeticsUtils.gcd(fraction.numerator, denominator);\n         return getReducedFraction\n-        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n-                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n+        (ArithmeticsUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n+                ArithmeticsUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n     }\n \n     /**\n-     * Add two long integers, checking for overflow.\n-     *\n-     * @param a Addend.\n-     * @param b Addend.\n-     * @param pattern Pattern to use for any thrown exception.\n-     * @return the sum {@code a + b}.\n-     * @throws MathArithmeticException if the result cannot be represented\n-     * as a {@code long}.\n-     * @since 1.2\n-     */\n-     private static long addAndCheck(long a, long b, Localizable pattern) {\n-        long ret;\n-        if (a > b) {\n-            // use symmetry to reduce boundary cases\n-            ret = addAndCheck(b, a, pattern);\n+     * Returns an exact representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which all coefficients are\n+     * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n+     * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n+     * thrown.</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws MathIllegalArgumentException if preconditions are not met.\n+     * @throws MathArithmeticException if the result is too large to be\n+     * represented by a long integer.\n+     */\n+    public static long binomialCoefficient(final int n, final int k) {\n+        ArithmeticsUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        // Use symmetry for large k\n+        if (k > n / 2) {\n+            return binomialCoefficient(n, n - k);\n+        }\n+\n+        // We use the formula\n+        // (n choose k) = n! / (n-k)! / k!\n+        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n+        // which could be written\n+        // (n choose k) == (n-1 choose k-1) * n / k\n+        long result = 1;\n+        if (n <= 61) {\n+            // For n <= 61, the naive implementation cannot overflow.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                result = result * i / j;\n+                i++;\n+            }\n+        } else if (n <= 66) {\n+            // For n > 61 but n <= 66, the result cannot overflow,\n+            // but we must take care not to overflow intermediate values.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                // We know that (result * i) is divisible by j,\n+                // but (result * i) may overflow, so we split j:\n+                // Filter out the gcd, d, so j/d and i/d are integer.\n+                // result is divisible by (j/d) because (j/d)\n+                // is relative prime to (i/d) and is a divisor of\n+                // result * (i/d).\n+                final long d = gcd(i, j);\n+                result = (result / (j / d)) * (i / d);\n+                i++;\n+            }\n         } else {\n-            // assert a <= b\n-\n-            if (a < 0) {\n-                if (b < 0) {\n-                    // check for negative overflow\n-                    if (Long.MIN_VALUE - b <= a) {\n-                        ret = a + b;\n-                    } else {\n-                        throw new MathArithmeticException(pattern, a, b);\n-                    }\n-                } else {\n-                    // opposite sign addition is always safe\n-                    ret = a + b;\n-                }\n-            } else {\n-                // assert a >= 0\n-                // assert b >= 0\n-\n-                // check for positive overflow\n-                if (a <= Long.MAX_VALUE - b) {\n-                    ret = a + b;\n-                } else {\n-                    throw new MathArithmeticException(pattern, a, b);\n-                }\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Subtract two integers, checking for overflow.\n-     *\n-     * @param x Minuend.\n-     * @param y Subtrahend.\n-     * @return the difference {@code x - y}.\n-     * @throws MathArithmeticException if the result can not be represented\n-     * as an {@code int}.\n-     * @since 1.1\n-     */\n-    public static int subAndCheck(int x, int y) {\n-        long s = (long)x - (long)y;\n-        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n-        }\n-        return (int)s;\n-    }\n-\n-    /**\n-     * Subtract two long integers, checking for overflow.\n-     *\n-     * @param a Value.\n-     * @param b Value.\n-     * @return the difference {@code a - b}.\n-     * @throws MathArithmeticException if the result can not be represented as a\n-     * {@code long}.\n-     * @since 1.2\n-     */\n-    public static long subAndCheck(long a, long b) {\n-        long ret;\n-        if (b == Long.MIN_VALUE) {\n-            if (a < 0) {\n-                ret = a - b;\n-            } else {\n-                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n-            }\n-        } else {\n-            // use additive inverse\n-            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n-        }\n-        return ret;\n+            // For n > 66, a result overflow might occur, so we check\n+            // the multiplication, taking care to not overflow\n+            // unnecessary.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                final long d = gcd(i, j);\n+                result = mulAndCheck(result / (j / d), i / d);\n+                i++;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code double} representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code double}. The\n+     * largest value of {@code n} for which all coefficients are <\n+     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n+     * Double.POSITIVE_INFINITY is returned</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientDouble(final int n, final int k) {\n+        ArithmeticsUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1d;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        if (k > n/2) {\n+            return binomialCoefficientDouble(n, n - k);\n+        }\n+        if (n < 67) {\n+            return binomialCoefficient(n,k);\n+        }\n+\n+        double result = 1d;\n+        for (int i = 1; i <= k; i++) {\n+             result *= (double)(n - k + i) / (double)i;\n+        }\n+\n+        return FastMath.floor(result + 0.5);\n+    }\n+\n+    /**\n+     * Returns the natural {@code log} of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientLog(final int n, final int k) {\n+        ArithmeticsUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 0;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return FastMath.log(n);\n+        }\n+\n+        /*\n+         * For values small enough to do exact integer computation,\n+         * return the log of the exact value\n+         */\n+        if (n < 67) {\n+            return FastMath.log(binomialCoefficient(n,k));\n+        }\n+\n+        /*\n+         * Return the log of binomialCoefficientDouble for values that will not\n+         * overflow binomialCoefficientDouble\n+         */\n+        if (n < 1030) {\n+            return FastMath.log(binomialCoefficientDouble(n, k));\n+        }\n+\n+        if (k > n / 2) {\n+            return binomialCoefficientLog(n, n - k);\n+        }\n+\n+        /*\n+         * Sum logs for values that could overflow\n+         */\n+        double logSum = 0;\n+\n+        // n!/(n-k)!\n+        for (int i = n - k + 1; i <= n; i++) {\n+            logSum += FastMath.log(i);\n+        }\n+\n+        // divide by k!\n+        for (int i = 2; i <= k; i++) {\n+            logSum -= FastMath.log(i);\n+        }\n+\n+        return logSum;\n     }\n \n     /**\n         } while (t != 0);\n         return -u * (1L << k); // gcd is u*2^k\n     }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n+     * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n+     * would be 2^31, which is too large for an int value.</li>\n+     * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n+     * {@code 0} for any {@code x}.\n+     * </ul>\n+     *\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n+     * @since 1.1\n+     */\n+    public static int lcm(int a, int b) {\n+        if (a == 0 || b == 0){\n+            return 0;\n+        }\n+        int lcm = FastMath.abs(ArithmeticsUtils.mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Integer.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n+                                              a, b);\n+        }\n+        return lcm;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n+     * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n+     * would be 2^63, which is too large for an int value.</li>\n+     * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n+     * {@code 0L} for any {@code x}.\n+     * </ul>\n+     *\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a non-negative {@code long} value.\n+     * @since 2.1\n+     */\n+    public static long lcm(long a, long b) {\n+        if (a == 0 || b == 0){\n+            return 0;\n+        }\n+        long lcm = FastMath.abs(ArithmeticsUtils.mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Long.MIN_VALUE){\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n+                                              a, b);\n+        }\n+        return lcm;\n+    }\n+\n+    /**\n+     * Multiply two integers, checking for overflow.\n+     *\n+     * @param x Factor.\n+     * @param y Factor.\n+     * @return the product {@code x * y}.\n+     * @throws MathArithmeticException if the result can not be\n+     * represented as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x) * ((long)y);\n+        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException();\n+        }\n+        return (int)m;\n+    }\n+\n+    /**\n+     * Multiply two long integers, checking for overflow.\n+     *\n+     * @param a Factor.\n+     * @param b Factor.\n+     * @return the product {@code a * b}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as a {@code long}.\n+     * @since 1.2\n+     */\n+    public static long mulAndCheck(long a, long b) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = mulAndCheck(b, a);\n+        } else {\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for positive overflow with negative a, negative b\n+                    if (a >= Long.MAX_VALUE / b) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new MathArithmeticException();\n+                    }\n+                } else if (b > 0) {\n+                    // check for negative overflow with negative a, positive b\n+                    if (Long.MIN_VALUE / b <= a) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new MathArithmeticException();\n+\n+                    }\n+                } else {\n+                    // assert b == 0\n+                    ret = 0;\n+                }\n+            } else if (a > 0) {\n+                // assert a > 0\n+                // assert b > 0\n+\n+                // check for positive overflow with positive a, positive b\n+                if (a <= Long.MAX_VALUE / b) {\n+                    ret = a * b;\n+                } else {\n+                    throw new MathArithmeticException();\n+                }\n+            } else {\n+                // assert a == 0\n+                ret = 0;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Subtract two integers, checking for overflow.\n+     *\n+     * @param x Minuend.\n+     * @param y Subtrahend.\n+     * @return the difference {@code x - y}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x - (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Subtract two long integers, checking for overflow.\n+     *\n+     * @param a Value.\n+     * @param b Value.\n+     * @return the difference {@code a - b}.\n+     * @throws MathArithmeticException if the result can not be represented as a\n+     * {@code long}.\n+     * @since 1.2\n+     */\n+    public static long subAndCheck(long a, long b) {\n+        long ret;\n+        if (b == Long.MIN_VALUE) {\n+            if (a < 0) {\n+                ret = a - b;\n+            } else {\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n+            }\n+        } else {\n+            // use additive inverse\n+            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     *\n+     * @param a Addend.\n+     * @param b Addend.\n+     * @param pattern Pattern to use for any thrown exception.\n+     * @return the sum {@code a + b}.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a {@code long}.\n+     * @since 1.2\n+     */\n+     private static long addAndCheck(long a, long b, Localizable pattern) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = addAndCheck(b, a, pattern);\n+        } else {\n+            // assert a <= b\n+\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for negative overflow\n+                    if (Long.MIN_VALUE - b <= a) {\n+                        ret = a + b;\n+                    } else {\n+                        throw new MathArithmeticException(pattern, a, b);\n+                    }\n+                } else {\n+                    // opposite sign addition is always safe\n+                    ret = a + b;\n+                }\n+            } else {\n+                // assert a >= 0\n+                // assert b >= 0\n+\n+                // check for positive overflow\n+                if (a <= Long.MAX_VALUE - b) {\n+                    ret = a + b;\n+                } else {\n+                    throw new MathArithmeticException(pattern, a, b);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Check binomial preconditions.\n+     *\n+     * @param n Size of the set.\n+     * @param k Size of the subsets to be counted.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     */\n+    private static void checkBinomial(final int n, final int k) {\n+        if (n < k) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n+                                                k, n, true);\n+        }\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n import org.apache.commons.math.exception.NotFiniteNumberException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n     }\n \n     /**\n-     * Returns an exact representation of the <a\n-     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"{@code n choose k}\", the number of\n-     * {@code k}-element subsets that can be selected from an\n-     * {@code n}-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> {@code 0 <= k <= n } (otherwise\n-     * {@code IllegalArgumentException} is thrown)</li>\n-     * <li> The result is small enough to fit into a {@code long}. The\n-     * largest value of {@code n} for which all coefficients are\n-     * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n-     * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n-     * thrown.</li>\n-     * </ul></p>\n-     *\n-     * @param n the size of the set\n-     * @param k the size of the subsets to be counted\n-     * @return {@code n choose k}\n-     * @throws MathIllegalArgumentException if preconditions are not met.\n-     * @throws MathArithmeticException if the result is too large to be\n-     * represented by a long integer.\n-     */\n-    public static long binomialCoefficient(final int n, final int k) {\n-        checkBinomial(n, k);\n-        if ((n == k) || (k == 0)) {\n-            return 1;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return n;\n-        }\n-        // Use symmetry for large k\n-        if (k > n / 2) {\n-            return binomialCoefficient(n, n - k);\n-        }\n-\n-        // We use the formula\n-        // (n choose k) = n! / (n-k)! / k!\n-        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-        // which could be written\n-        // (n choose k) == (n-1 choose k-1) * n / k\n-        long result = 1;\n-        if (n <= 61) {\n-            // For n <= 61, the naive implementation cannot overflow.\n-            int i = n - k + 1;\n-            for (int j = 1; j <= k; j++) {\n-                result = result * i / j;\n-                i++;\n-            }\n-        } else if (n <= 66) {\n-            // For n > 61 but n <= 66, the result cannot overflow,\n-            // but we must take care not to overflow intermediate values.\n-            int i = n - k + 1;\n-            for (int j = 1; j <= k; j++) {\n-                // We know that (result * i) is divisible by j,\n-                // but (result * i) may overflow, so we split j:\n-                // Filter out the gcd, d, so j/d and i/d are integer.\n-                // result is divisible by (j/d) because (j/d)\n-                // is relative prime to (i/d) and is a divisor of\n-                // result * (i/d).\n-                final long d = ArithmeticsUtils.gcd(i, j);\n-                result = (result / (j / d)) * (i / d);\n-                i++;\n-            }\n-        } else {\n-            // For n > 66, a result overflow might occur, so we check\n-            // the multiplication, taking care to not overflow\n-            // unnecessary.\n-            int i = n - k + 1;\n-            for (int j = 1; j <= k; j++) {\n-                final long d = ArithmeticsUtils.gcd(i, j);\n-                result = mulAndCheck(result / (j / d), i / d);\n-                i++;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Returns a {@code double} representation of the <a\n-     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"{@code n choose k}\", the number of\n-     * {@code k}-element subsets that can be selected from an\n-     * {@code n}-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> {@code 0 <= k <= n } (otherwise\n-     * {@code IllegalArgumentException} is thrown)</li>\n-     * <li> The result is small enough to fit into a {@code double}. The\n-     * largest value of {@code n} for which all coefficients are <\n-     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n-     * Double.POSITIVE_INFINITY is returned</li>\n-     * </ul></p>\n-     *\n-     * @param n the size of the set\n-     * @param k the size of the subsets to be counted\n-     * @return {@code n choose k}\n-     * @throws IllegalArgumentException if preconditions are not met.\n-     */\n-    public static double binomialCoefficientDouble(final int n, final int k) {\n-        checkBinomial(n, k);\n-        if ((n == k) || (k == 0)) {\n-            return 1d;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return n;\n-        }\n-        if (k > n/2) {\n-            return binomialCoefficientDouble(n, n - k);\n-        }\n-        if (n < 67) {\n-            return binomialCoefficient(n,k);\n-        }\n-\n-        double result = 1d;\n-        for (int i = 1; i <= k; i++) {\n-             result *= (double)(n - k + i) / (double)i;\n-        }\n-\n-        return FastMath.floor(result + 0.5);\n-    }\n-\n-    /**\n-     * Returns the natural {@code log} of the <a\n-     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"{@code n choose k}\", the number of\n-     * {@code k}-element subsets that can be selected from an\n-     * {@code n}-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> {@code 0 <= k <= n } (otherwise\n-     * {@code IllegalArgumentException} is thrown)</li>\n-     * </ul></p>\n-     *\n-     * @param n the size of the set\n-     * @param k the size of the subsets to be counted\n-     * @return {@code n choose k}\n-     * @throws IllegalArgumentException if preconditions are not met.\n-     */\n-    public static double binomialCoefficientLog(final int n, final int k) {\n-        checkBinomial(n, k);\n-        if ((n == k) || (k == 0)) {\n-            return 0;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return FastMath.log(n);\n-        }\n-\n-        /*\n-         * For values small enough to do exact integer computation,\n-         * return the log of the exact value\n-         */\n-        if (n < 67) {\n-            return FastMath.log(binomialCoefficient(n,k));\n-        }\n-\n-        /*\n-         * Return the log of binomialCoefficientDouble for values that will not\n-         * overflow binomialCoefficientDouble\n-         */\n-        if (n < 1030) {\n-            return FastMath.log(binomialCoefficientDouble(n, k));\n-        }\n-\n-        if (k > n / 2) {\n-            return binomialCoefficientLog(n, n - k);\n-        }\n-\n-        /*\n-         * Sum logs for values that could overflow\n-         */\n-        double logSum = 0;\n-\n-        // n!/(n-k)!\n-        for (int i = n - k + 1; i <= n; i++) {\n-            logSum += FastMath.log(i);\n-        }\n-\n-        // divide by k!\n-        for (int i = 2; i <= k; i++) {\n-            logSum -= FastMath.log(i);\n-        }\n-\n-        return logSum;\n-    }\n-\n-    /**\n-     * Check binomial preconditions.\n-     *\n-     * @param n Size of the set.\n-     * @param k Size of the subsets to be counted.\n-     * @throws NotPositiveException if {@code n < 0}.\n-     * @throws NumberIsTooLargeException if {@code k > n}.\n-     */\n-    private static void checkBinomial(final int n, final int k) {\n-        if (n < k) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n-                                                k, n, true);\n-        }\n-        if (n < 0) {\n-            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);\n-        }\n-    }\n-\n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n      * hyperbolic cosine</a> of x.\n      *\n      */\n     public static short indicator(final short x) {\n         return (x >= ZS) ? PS : NS;\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns the least common multiple of the absolute value of two numbers,\n-     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n-     * </p>\n-     * Special cases:\n-     * <ul>\n-     * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n-     * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n-     * power of 2, throw an {@code ArithmeticException}, because the result\n-     * would be 2^31, which is too large for an int value.</li>\n-     * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n-     * {@code 0} for any {@code x}.\n-     * </ul>\n-     *\n-     * @param a Number.\n-     * @param b Number.\n-     * @return the least common multiple, never negative.\n-     * @throws MathArithmeticException if the result cannot be represented as\n-     * a non-negative {@code int} value.\n-     * @since 1.1\n-     */\n-    public static int lcm(int a, int b) {\n-        if (a == 0 || b == 0){\n-            return 0;\n-        }\n-        int lcm = FastMath.abs(mulAndCheck(a / ArithmeticsUtils.gcd(a, b), b));\n-        if (lcm == Integer.MIN_VALUE) {\n-            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n-                                              a, b);\n-        }\n-        return lcm;\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns the least common multiple of the absolute value of two numbers,\n-     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n-     * </p>\n-     * Special cases:\n-     * <ul>\n-     * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n-     * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n-     * power of 2, throw an {@code ArithmeticException}, because the result\n-     * would be 2^63, which is too large for an int value.</li>\n-     * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n-     * {@code 0L} for any {@code x}.\n-     * </ul>\n-     *\n-     * @param a Number.\n-     * @param b Number.\n-     * @return the least common multiple, never negative.\n-     * @throws MathArithmeticException if the result cannot be represented\n-     * as a non-negative {@code long} value.\n-     * @since 2.1\n-     */\n-    public static long lcm(long a, long b) {\n-        if (a == 0 || b == 0){\n-            return 0;\n-        }\n-        long lcm = FastMath.abs(mulAndCheck(a / ArithmeticsUtils.gcd(a, b), b));\n-        if (lcm == Long.MIN_VALUE){\n-            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n-                                              a, b);\n-        }\n-        return lcm;\n     }\n \n     /**\n      */\n     public static double log(double base, double x) {\n         return FastMath.log(x)/FastMath.log(base);\n-    }\n-\n-    /**\n-     * Multiply two integers, checking for overflow.\n-     *\n-     * @param x Factor.\n-     * @param y Factor.\n-     * @return the product {@code x * y}.\n-     * @throws MathArithmeticException if the result can not be\n-     * represented as an {@code int}.\n-     * @since 1.1\n-     */\n-    public static int mulAndCheck(int x, int y) {\n-        long m = ((long)x) * ((long)y);\n-        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n-            throw new MathArithmeticException();\n-        }\n-        return (int)m;\n-    }\n-\n-    /**\n-     * Multiply two long integers, checking for overflow.\n-     *\n-     * @param a Factor.\n-     * @param b Factor.\n-     * @return the product {@code a * b}.\n-     * @throws MathArithmeticException if the result can not be represented\n-     * as a {@code long}.\n-     * @since 1.2\n-     */\n-    public static long mulAndCheck(long a, long b) {\n-        long ret;\n-        if (a > b) {\n-            // use symmetry to reduce boundary cases\n-            ret = mulAndCheck(b, a);\n-        } else {\n-            if (a < 0) {\n-                if (b < 0) {\n-                    // check for positive overflow with negative a, negative b\n-                    if (a >= Long.MAX_VALUE / b) {\n-                        ret = a * b;\n-                    } else {\n-                        throw new MathArithmeticException();\n-                    }\n-                } else if (b > 0) {\n-                    // check for negative overflow with negative a, positive b\n-                    if (Long.MIN_VALUE / b <= a) {\n-                        ret = a * b;\n-                    } else {\n-                        throw new MathArithmeticException();\n-\n-                    }\n-                } else {\n-                    // assert b == 0\n-                    ret = 0;\n-                }\n-            } else if (a > 0) {\n-                // assert a > 0\n-                // assert b > 0\n-\n-                // check for positive overflow with positive a, positive b\n-                if (a <= Long.MAX_VALUE / b) {\n-                    ret = a * b;\n-                } else {\n-                    throw new MathArithmeticException();\n-                }\n-            } else {\n-                // assert a == 0\n-                ret = 0;\n-            }\n-        }\n-        return ret;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.integration.LegendreGaussIntegrator;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n             for (int w = 0; w < 10; ++w) {\n                 for (int i = 0; i < 10; ++i) {\n                     PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, v, w);\n-                    double binomial = MathUtils.binomialCoefficient(v + i, i);\n+                    double binomial = ArithmeticsUtils.binomialCoefficient(v + i, i);\n                     Assert.assertTrue(Precision.equals(binomial, jacobi.value(1.0), 1));\n                 }\n             }\n--- a/src/test/java/org/apache/commons/math/linear/InverseHilbertMatrix.java\n+++ b/src/test/java/org/apache/commons/math/linear/InverseHilbertMatrix.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n \n /**\n  * This class implements inverses of Hilbert Matrices as\n      */\n     public long getEntry(final int i, final int j) {\n         long val = i + j + 1;\n-        long aux = MathUtils.binomialCoefficient(n + i, n - j - 1);\n-        val = MathUtils.mulAndCheck(val, aux);\n-        aux = MathUtils.binomialCoefficient(n + j, n - i - 1);\n-        val = MathUtils.mulAndCheck(val, aux);\n-        aux = MathUtils.binomialCoefficient(i + j, i);\n-        val = MathUtils.mulAndCheck(val, aux);\n-        val = MathUtils.mulAndCheck(val, aux);\n+        long aux = ArithmeticsUtils.binomialCoefficient(n + i, n - j - 1);\n+        val = ArithmeticsUtils.mulAndCheck(val, aux);\n+        aux = ArithmeticsUtils.binomialCoefficient(n + j, n - i - 1);\n+        val = ArithmeticsUtils.mulAndCheck(val, aux);\n+        aux = ArithmeticsUtils.binomialCoefficient(i + j, i);\n+        val = ArithmeticsUtils.mulAndCheck(val, aux);\n+        val = ArithmeticsUtils.mulAndCheck(val, aux);\n         return ((i + j) & 1) == 0 ? val : -val;\n     }\n \n--- a/src/test/java/org/apache/commons/math/util/ArithmeticsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ArithmeticsUtilsTest.java\n package org.apache.commons.math.util;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n  * @version $Id$\n  */\n public class ArithmeticsUtilsTest {\n-    /**\n-     * Exact direct multiplication implementation to test against\n-     */\n-    private long factorial(int n) {\n-        long result = 1;\n-        for (int i = 2; i <= n; i++) {\n-            result *= i;\n-        }\n-        return result;\n+\n+    /** cached binomial coefficients */\n+    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n+\n+    /** Verify that b(0,0) = 1 */\n+    @Test\n+    public void test0Choose0() {\n+        Assert.assertEquals(ArithmeticsUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n+        Assert.assertEquals(ArithmeticsUtils.binomialCoefficientLog(0, 0), 0d, 0);\n+        Assert.assertEquals(ArithmeticsUtils.binomialCoefficient(0, 0), 1);\n     }\n \n     @Test\n         } catch (MathArithmeticException ex) {\n         }\n     }\n-\n \n     @Test\n     public void testAddAndCheckLong() {\n         testAddAndCheckLongFailure(-1L, min);\n     }\n \n-    private void testAddAndCheckLongFailure(long a, long b) {\n-        try {\n-            ArithmeticsUtils.addAndCheck(a, b);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // success\n-        }\n-    }\n-\n-    @Test\n-    public void testSubAndCheck() {\n-        int big = Integer.MAX_VALUE;\n-        int bigNeg = Integer.MIN_VALUE;\n-        Assert.assertEquals(big, ArithmeticsUtils.subAndCheck(big, 0));\n-        Assert.assertEquals(bigNeg + 1, ArithmeticsUtils.subAndCheck(bigNeg, -1));\n-        Assert.assertEquals(-1, ArithmeticsUtils.subAndCheck(bigNeg, -big));\n-        try {\n-            ArithmeticsUtils.subAndCheck(big, -1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-        }\n-        try {\n-            ArithmeticsUtils.subAndCheck(bigNeg, 1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-        }\n-    }\n-\n-    @Test\n-    public void testSubAndCheckErrorMessage() {\n-        int big = Integer.MAX_VALUE;\n-        try {\n-            ArithmeticsUtils.subAndCheck(big, -1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            Assert.assertTrue(ex.getMessage().length() > 1);\n-        }\n-    }\n-\n-    @Test\n-    public void testSubAndCheckLong() {\n-        long max = Long.MAX_VALUE;\n-        long min = Long.MIN_VALUE;\n-        Assert.assertEquals(max, ArithmeticsUtils.subAndCheck(max, 0));\n-        Assert.assertEquals(min, ArithmeticsUtils.subAndCheck(min, 0));\n-        Assert.assertEquals(-max, ArithmeticsUtils.subAndCheck(0, max));\n-        Assert.assertEquals(min + 1, ArithmeticsUtils.subAndCheck(min, -1));\n-        // min == -1-max\n-        Assert.assertEquals(-1, ArithmeticsUtils.subAndCheck(-max - 1, -max));\n-        Assert.assertEquals(max, ArithmeticsUtils.subAndCheck(-1, -1 - max));\n-        testSubAndCheckLongFailure(0L, min);\n-        testSubAndCheckLongFailure(max, -1L);\n-        testSubAndCheckLongFailure(min, 1L);\n-    }\n-\n-    private void testSubAndCheckLongFailure(long a, long b) {\n-        try {\n-            ArithmeticsUtils.subAndCheck(a, b);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // success\n-        }\n+\n+    @Test\n+    public void testBinomialCoefficient() {\n+        long[] bcoef5 = {\n+            1,\n+            5,\n+            10,\n+            10,\n+            5,\n+            1 };\n+        long[] bcoef6 = {\n+            1,\n+            6,\n+            15,\n+            20,\n+            15,\n+            6,\n+            1 };\n+        for (int i = 0; i < 6; i++) {\n+            Assert.assertEquals(\"5 choose \" + i, bcoef5[i], ArithmeticsUtils.binomialCoefficient(5, i));\n+        }\n+        for (int i = 0; i < 7; i++) {\n+            Assert.assertEquals(\"6 choose \" + i, bcoef6[i], ArithmeticsUtils.binomialCoefficient(6, i));\n+        }\n+\n+        for (int n = 1; n < 10; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), ArithmeticsUtils.binomialCoefficient(n, k));\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), ArithmeticsUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n+                Assert.assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), ArithmeticsUtils.binomialCoefficientLog(n, k), 10E-12);\n+            }\n+        }\n+\n+        int[] n = { 34, 66, 100, 1500, 1500 };\n+        int[] k = { 17, 33, 10, 1500 - 4, 4 };\n+        for (int i = 0; i < n.length; i++) {\n+            long expected = binomialCoefficient(n[i], k[i]);\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n+                ArithmeticsUtils.binomialCoefficient(n[i], k[i]));\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n+                ArithmeticsUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n+            Assert.assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n+                ArithmeticsUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBinomialCoefficientFail() {\n+        try {\n+            ArithmeticsUtils.binomialCoefficient(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticsUtils.binomialCoefficientDouble(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticsUtils.binomialCoefficientLog(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticsUtils.binomialCoefficient(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticsUtils.binomialCoefficientDouble(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticsUtils.binomialCoefficientLog(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticsUtils.binomialCoefficient(67, 30);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticsUtils.binomialCoefficient(67, 34);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // ignored\n+        }\n+        double x = ArithmeticsUtils.binomialCoefficientDouble(1030, 515);\n+        Assert.assertTrue(\"expecting infinite binomial coefficient\", Double\n+            .isInfinite(x));\n+    }\n+\n+    /**\n+     * Tests correctness for large n and sharpness of upper bound in API doc\n+     * JIRA: MATH-241\n+     */\n+    @Test\n+    public void testBinomialCoefficientLarge() throws Exception {\n+        // This tests all legal and illegal values for n <= 200.\n+        for (int n = 0; n <= 200; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                long ourResult = -1;\n+                long exactResult = -1;\n+                boolean shouldThrow = false;\n+                boolean didThrow = false;\n+                try {\n+                    ourResult = ArithmeticsUtils.binomialCoefficient(n, k);\n+                } catch (MathArithmeticException ex) {\n+                    didThrow = true;\n+                }\n+                try {\n+                    exactResult = binomialCoefficient(n, k);\n+                } catch (MathArithmeticException ex) {\n+                    shouldThrow = true;\n+                }\n+                Assert.assertEquals(n + \" choose \" + k, exactResult, ourResult);\n+                Assert.assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n+                Assert.assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n+\n+                if (!shouldThrow && exactResult > 1) {\n+                    Assert.assertEquals(n + \" choose \" + k, 1.,\n+                        ArithmeticsUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n+                    Assert.assertEquals(n + \" choose \" + k, 1,\n+                        ArithmeticsUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);\n+                }\n+            }\n+        }\n+\n+        long ourResult = ArithmeticsUtils.binomialCoefficient(300, 3);\n+        long exactResult = binomialCoefficient(300, 3);\n+        Assert.assertEquals(exactResult, ourResult);\n+\n+        ourResult = ArithmeticsUtils.binomialCoefficient(700, 697);\n+        exactResult = binomialCoefficient(700, 697);\n+        Assert.assertEquals(exactResult, ourResult);\n+\n+        // This one should throw\n+        try {\n+            ArithmeticsUtils.binomialCoefficient(700, 300);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // Expected\n+        }\n+\n+        int n = 10000;\n+        ourResult = ArithmeticsUtils.binomialCoefficient(n, 3);\n+        exactResult = binomialCoefficient(n, 3);\n+        Assert.assertEquals(exactResult, ourResult);\n+        Assert.assertEquals(1, ArithmeticsUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n+        Assert.assertEquals(1, ArithmeticsUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n \n     }\n \n         Assert.assertTrue(\"expecting infinite factorial value\", Double.isInfinite(ArithmeticsUtils.factorialDouble(171)));\n     }\n \n-\n     @Test\n     public void testGcd() {\n         int a = 30;\n         try {\n             // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             ArithmeticsUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-    }\n-\n-    @Test\n-    public void  testGcdLong(){\n-        long a = 30;\n-        long b = 50;\n-        long c = 77;\n-\n-        Assert.assertEquals(0, ArithmeticsUtils.gcd(0L, 0));\n-\n-        Assert.assertEquals(b, ArithmeticsUtils.gcd(0, b));\n-        Assert.assertEquals(a, ArithmeticsUtils.gcd(a, 0));\n-        Assert.assertEquals(b, ArithmeticsUtils.gcd(0, -b));\n-        Assert.assertEquals(a, ArithmeticsUtils.gcd(-a, 0));\n-\n-        Assert.assertEquals(10, ArithmeticsUtils.gcd(a, b));\n-        Assert.assertEquals(10, ArithmeticsUtils.gcd(-a, b));\n-        Assert.assertEquals(10, ArithmeticsUtils.gcd(a, -b));\n-        Assert.assertEquals(10, ArithmeticsUtils.gcd(-a, -b));\n-\n-        Assert.assertEquals(1, ArithmeticsUtils.gcd(a, c));\n-        Assert.assertEquals(1, ArithmeticsUtils.gcd(-a, c));\n-        Assert.assertEquals(1, ArithmeticsUtils.gcd(a, -c));\n-        Assert.assertEquals(1, ArithmeticsUtils.gcd(-a, -c));\n-\n-        Assert.assertEquals(3L * (1L<<45), ArithmeticsUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n-\n-        Assert.assertEquals(1L<<45, ArithmeticsUtils.gcd(1L<<45, Long.MIN_VALUE));\n-\n-        Assert.assertEquals(Long.MAX_VALUE, ArithmeticsUtils.gcd(Long.MAX_VALUE, 0L));\n-        Assert.assertEquals(Long.MAX_VALUE, ArithmeticsUtils.gcd(-Long.MAX_VALUE, 0L));\n-        Assert.assertEquals(1, ArithmeticsUtils.gcd(60247241209L, 153092023L));\n-        try {\n-            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n-            ArithmeticsUtils.gcd(Long.MIN_VALUE, 0);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-        try {\n-            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n-            ArithmeticsUtils.gcd(0, Long.MIN_VALUE);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-        try {\n-            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n-            ArithmeticsUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n             Assert.fail(\"expecting MathArithmeticException\");\n         } catch (MathArithmeticException expected) {\n             // expected\n             Assert.assertEquals(gcd, ArithmeticsUtils.gcd(l1, l2));\n         }\n     }\n+\n+    @Test\n+    public void  testGcdLong(){\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticsUtils.gcd(0L, 0));\n+\n+        Assert.assertEquals(b, ArithmeticsUtils.gcd(0, b));\n+        Assert.assertEquals(a, ArithmeticsUtils.gcd(a, 0));\n+        Assert.assertEquals(b, ArithmeticsUtils.gcd(0, -b));\n+        Assert.assertEquals(a, ArithmeticsUtils.gcd(-a, 0));\n+\n+        Assert.assertEquals(10, ArithmeticsUtils.gcd(a, b));\n+        Assert.assertEquals(10, ArithmeticsUtils.gcd(-a, b));\n+        Assert.assertEquals(10, ArithmeticsUtils.gcd(a, -b));\n+        Assert.assertEquals(10, ArithmeticsUtils.gcd(-a, -b));\n+\n+        Assert.assertEquals(1, ArithmeticsUtils.gcd(a, c));\n+        Assert.assertEquals(1, ArithmeticsUtils.gcd(-a, c));\n+        Assert.assertEquals(1, ArithmeticsUtils.gcd(a, -c));\n+        Assert.assertEquals(1, ArithmeticsUtils.gcd(-a, -c));\n+\n+        Assert.assertEquals(3L * (1L<<45), ArithmeticsUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n+\n+        Assert.assertEquals(1L<<45, ArithmeticsUtils.gcd(1L<<45, Long.MIN_VALUE));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticsUtils.gcd(Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticsUtils.gcd(-Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(1, ArithmeticsUtils.gcd(60247241209L, 153092023L));\n+        try {\n+            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n+            ArithmeticsUtils.gcd(Long.MIN_VALUE, 0);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n+            ArithmeticsUtils.gcd(0, Long.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n+            ArithmeticsUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testLcm() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticsUtils.lcm(0, b));\n+        Assert.assertEquals(0, ArithmeticsUtils.lcm(a, 0));\n+        Assert.assertEquals(b, ArithmeticsUtils.lcm(1, b));\n+        Assert.assertEquals(a, ArithmeticsUtils.lcm(a, 1));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(a, b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(-a, b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(a, -b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, ArithmeticsUtils.lcm(a, c));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        Assert.assertEquals((1<<20)*15, ArithmeticsUtils.lcm((1<<20)*3, (1<<20)*5));\n+\n+        // Special case\n+        Assert.assertEquals(0, ArithmeticsUtils.lcm(0, 0));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticsUtils.lcm(Integer.MIN_VALUE, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticsUtils.lcm(Integer.MIN_VALUE, 1<<20);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            ArithmeticsUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testLcmLong() {\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticsUtils.lcm(0, b));\n+        Assert.assertEquals(0, ArithmeticsUtils.lcm(a, 0));\n+        Assert.assertEquals(b, ArithmeticsUtils.lcm(1, b));\n+        Assert.assertEquals(a, ArithmeticsUtils.lcm(a, 1));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(a, b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(-a, b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(a, -b));\n+        Assert.assertEquals(150, ArithmeticsUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, ArithmeticsUtils.lcm(a, c));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticsUtils.lcm(60247241209L, 153092023L));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        Assert.assertEquals((1L<<50)*15, ArithmeticsUtils.lcm((1L<<45)*3, (1L<<50)*5));\n+\n+        // Special case\n+        Assert.assertEquals(0L, ArithmeticsUtils.lcm(0L, 0L));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticsUtils.lcm(Long.MIN_VALUE, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticsUtils.lcm(Long.MIN_VALUE, 1<<20);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n+            ArithmeticsUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n+        try {\n+            ArithmeticsUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testMulAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        Assert.assertEquals(big, ArithmeticsUtils.mulAndCheck(big, 1));\n+        try {\n+            ArithmeticsUtils.mulAndCheck(big, 2);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+        try {\n+            ArithmeticsUtils.mulAndCheck(bigNeg, 2);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+    }\n+\n+    @Test\n+    public void testMulAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        Assert.assertEquals(max, ArithmeticsUtils.mulAndCheck(max, 1L));\n+        Assert.assertEquals(min, ArithmeticsUtils.mulAndCheck(min, 1L));\n+        Assert.assertEquals(0L, ArithmeticsUtils.mulAndCheck(max, 0L));\n+        Assert.assertEquals(0L, ArithmeticsUtils.mulAndCheck(min, 0L));\n+        Assert.assertEquals(max, ArithmeticsUtils.mulAndCheck(1L, max));\n+        Assert.assertEquals(min, ArithmeticsUtils.mulAndCheck(1L, min));\n+        Assert.assertEquals(0L, ArithmeticsUtils.mulAndCheck(0L, max));\n+        Assert.assertEquals(0L, ArithmeticsUtils.mulAndCheck(0L, min));\n+        Assert.assertEquals(1L, ArithmeticsUtils.mulAndCheck(-1L, -1L));\n+        Assert.assertEquals(min, ArithmeticsUtils.mulAndCheck(min / 2, 2));\n+        testMulAndCheckLongFailure(max, 2L);\n+        testMulAndCheckLongFailure(2L, max);\n+        testMulAndCheckLongFailure(min, 2L);\n+        testMulAndCheckLongFailure(2L, min);\n+        testMulAndCheckLongFailure(min, -1L);\n+        testMulAndCheckLongFailure(-1L, min);\n+    }\n+\n+    @Test\n+    public void testSubAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        Assert.assertEquals(big, ArithmeticsUtils.subAndCheck(big, 0));\n+        Assert.assertEquals(bigNeg + 1, ArithmeticsUtils.subAndCheck(bigNeg, -1));\n+        Assert.assertEquals(-1, ArithmeticsUtils.subAndCheck(bigNeg, -big));\n+        try {\n+            ArithmeticsUtils.subAndCheck(big, -1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+        try {\n+            ArithmeticsUtils.subAndCheck(bigNeg, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+    }\n+\n+    @Test\n+    public void testSubAndCheckErrorMessage() {\n+        int big = Integer.MAX_VALUE;\n+        try {\n+            ArithmeticsUtils.subAndCheck(big, -1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            Assert.assertTrue(ex.getMessage().length() > 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSubAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        Assert.assertEquals(max, ArithmeticsUtils.subAndCheck(max, 0));\n+        Assert.assertEquals(min, ArithmeticsUtils.subAndCheck(min, 0));\n+        Assert.assertEquals(-max, ArithmeticsUtils.subAndCheck(0, max));\n+        Assert.assertEquals(min + 1, ArithmeticsUtils.subAndCheck(min, -1));\n+        // min == -1-max\n+        Assert.assertEquals(-1, ArithmeticsUtils.subAndCheck(-max - 1, -max));\n+        Assert.assertEquals(max, ArithmeticsUtils.subAndCheck(-1, -1 - max));\n+        testSubAndCheckLongFailure(0L, min);\n+        testSubAndCheckLongFailure(max, -1L);\n+        testSubAndCheckLongFailure(min, 1L);\n+    }\n+\n+    /**\n+     * Exact (caching) recursive implementation to test against\n+     */\n+    private long binomialCoefficient(int n, int k) throws MathArithmeticException {\n+        if (binomialCache.size() > n) {\n+            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n+            if (cachedResult != null) {\n+                return cachedResult.longValue();\n+            }\n+        }\n+        long result = -1;\n+        if ((n == k) || (k == 0)) {\n+            result = 1;\n+        } else if ((k == 1) || (k == n - 1)) {\n+            result = n;\n+        } else {\n+            // Reduce stack depth for larger values of n\n+            if (k < n - 100) {\n+                binomialCoefficient(n - 100, k);\n+            }\n+            if (k > 100) {\n+                binomialCoefficient(n - 100, k - 100);\n+            }\n+            result = ArithmeticsUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n+                binomialCoefficient(n - 1, k));\n+        }\n+        if (result == -1) {\n+            throw new MathArithmeticException();\n+        }\n+        for (int i = binomialCache.size(); i < n + 1; i++) {\n+            binomialCache.add(new HashMap<Integer, Long>());\n+        }\n+        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));\n+        return result;\n+    }\n+\n+    /**\n+     * Exact direct multiplication implementation to test against\n+     */\n+    private long factorial(int n) {\n+        long result = 1;\n+        for (int i = 2; i <= n; i++) {\n+            result *= i;\n+        }\n+        return result;\n+    }\n+\n+    private void testAddAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticsUtils.addAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    private void testMulAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticsUtils.mulAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    private void testSubAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticsUtils.subAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n \n \n import org.apache.commons.math.TestUtils;\n  *          2007) $\n  */\n public final class MathUtilsTest {\n-\n-    /** cached binomial coefficients */\n-    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n-\n-    /**\n-     * Exact (caching) recursive implementation to test against\n-     */\n-    private long binomialCoefficient(int n, int k) throws MathArithmeticException {\n-        if (binomialCache.size() > n) {\n-            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n-            if (cachedResult != null) {\n-                return cachedResult.longValue();\n-            }\n-        }\n-        long result = -1;\n-        if ((n == k) || (k == 0)) {\n-            result = 1;\n-        } else if ((k == 1) || (k == n - 1)) {\n-            result = n;\n-        } else {\n-            // Reduce stack depth for larger values of n\n-            if (k < n - 100) {\n-                binomialCoefficient(n - 100, k);\n-            }\n-            if (k > 100) {\n-                binomialCoefficient(n - 100, k - 100);\n-            }\n-            result = ArithmeticsUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n-                binomialCoefficient(n - 1, k));\n-        }\n-        if (result == -1) {\n-            throw new MathArithmeticException();\n-        }\n-        for (int i = binomialCache.size(); i < n + 1; i++) {\n-            binomialCache.add(new HashMap<Integer, Long>());\n-        }\n-        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));\n-        return result;\n-    }\n-\n-    /** Verify that b(0,0) = 1 */\n-    @Test\n-    public void test0Choose0() {\n-        Assert.assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n-        Assert.assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);\n-        Assert.assertEquals(MathUtils.binomialCoefficient(0, 0), 1);\n-    }\n-\n-    @Test\n-    public void testBinomialCoefficient() {\n-        long[] bcoef5 = {\n-            1,\n-            5,\n-            10,\n-            10,\n-            5,\n-            1 };\n-        long[] bcoef6 = {\n-            1,\n-            6,\n-            15,\n-            20,\n-            15,\n-            6,\n-            1 };\n-        for (int i = 0; i < 6; i++) {\n-            Assert.assertEquals(\"5 choose \" + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));\n-        }\n-        for (int i = 0; i < 7; i++) {\n-            Assert.assertEquals(\"6 choose \" + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));\n-        }\n-\n-        for (int n = 1; n < 10; n++) {\n-            for (int k = 0; k <= n; k++) {\n-                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n-                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n-                Assert.assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n-            }\n-        }\n-\n-        int[] n = { 34, 66, 100, 1500, 1500 };\n-        int[] k = { 17, 33, 10, 1500 - 4, 4 };\n-        for (int i = 0; i < n.length; i++) {\n-            long expected = binomialCoefficient(n[i], k[i]);\n-            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n-                MathUtils.binomialCoefficient(n[i], k[i]));\n-            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n-                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n-            Assert.assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n-                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n-        }\n-    }\n-\n-    /**\n-     * Tests correctness for large n and sharpness of upper bound in API doc\n-     * JIRA: MATH-241\n-     */\n-    @Test\n-    public void testBinomialCoefficientLarge() throws Exception {\n-        // This tests all legal and illegal values for n <= 200.\n-        for (int n = 0; n <= 200; n++) {\n-            for (int k = 0; k <= n; k++) {\n-                long ourResult = -1;\n-                long exactResult = -1;\n-                boolean shouldThrow = false;\n-                boolean didThrow = false;\n-                try {\n-                    ourResult = MathUtils.binomialCoefficient(n, k);\n-                } catch (MathArithmeticException ex) {\n-                    didThrow = true;\n-                }\n-                try {\n-                    exactResult = binomialCoefficient(n, k);\n-                } catch (MathArithmeticException ex) {\n-                    shouldThrow = true;\n-                }\n-                Assert.assertEquals(n + \" choose \" + k, exactResult, ourResult);\n-                Assert.assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n-                Assert.assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n-\n-                if (!shouldThrow && exactResult > 1) {\n-                    Assert.assertEquals(n + \" choose \" + k, 1.,\n-                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n-                    Assert.assertEquals(n + \" choose \" + k, 1,\n-                        MathUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);\n-                }\n-            }\n-        }\n-\n-        long ourResult = MathUtils.binomialCoefficient(300, 3);\n-        long exactResult = binomialCoefficient(300, 3);\n-        Assert.assertEquals(exactResult, ourResult);\n-\n-        ourResult = MathUtils.binomialCoefficient(700, 697);\n-        exactResult = binomialCoefficient(700, 697);\n-        Assert.assertEquals(exactResult, ourResult);\n-\n-        // This one should throw\n-        try {\n-            MathUtils.binomialCoefficient(700, 300);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // Expected\n-        }\n-\n-        int n = 10000;\n-        ourResult = MathUtils.binomialCoefficient(n, 3);\n-        exactResult = binomialCoefficient(n, 3);\n-        Assert.assertEquals(exactResult, ourResult);\n-        Assert.assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n-        Assert.assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n-\n-    }\n-\n-    @Test\n-    public void testBinomialCoefficientFail() {\n-        try {\n-            MathUtils.binomialCoefficient(4, 5);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-\n-        try {\n-            MathUtils.binomialCoefficientDouble(4, 5);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-\n-        try {\n-            MathUtils.binomialCoefficientLog(4, 5);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-\n-        try {\n-            MathUtils.binomialCoefficient(-1, -2);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            MathUtils.binomialCoefficientDouble(-1, -2);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            MathUtils.binomialCoefficientLog(-1, -2);\n-            Assert.fail(\"expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // ignored\n-        }\n-\n-        try {\n-            MathUtils.binomialCoefficient(67, 30);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // ignored\n-        }\n-        try {\n-            MathUtils.binomialCoefficient(67, 34);\n-            Assert.fail(\"expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // ignored\n-        }\n-        double x = MathUtils.binomialCoefficientDouble(1030, 515);\n-        Assert.assertTrue(\"expecting infinite binomial coefficient\", Double\n-            .isInfinite(x));\n-    }\n-\n     @Test\n     public void testCosh() {\n         double x = 3.0;\n     }\n \n     @Test\n-    public void testLcm() {\n-        int a = 30;\n-        int b = 50;\n-        int c = 77;\n-\n-        Assert.assertEquals(0, MathUtils.lcm(0, b));\n-        Assert.assertEquals(0, MathUtils.lcm(a, 0));\n-        Assert.assertEquals(b, MathUtils.lcm(1, b));\n-        Assert.assertEquals(a, MathUtils.lcm(a, 1));\n-        Assert.assertEquals(150, MathUtils.lcm(a, b));\n-        Assert.assertEquals(150, MathUtils.lcm(-a, b));\n-        Assert.assertEquals(150, MathUtils.lcm(a, -b));\n-        Assert.assertEquals(150, MathUtils.lcm(-a, -b));\n-        Assert.assertEquals(2310, MathUtils.lcm(a, c));\n-\n-        // Assert that no intermediate value overflows:\n-        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n-        Assert.assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n-\n-        // Special case\n-        Assert.assertEquals(0, MathUtils.lcm(0, 0));\n-\n-        try {\n-            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n-            MathUtils.lcm(Integer.MIN_VALUE, 1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-\n-        try {\n-            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n-            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-\n-        try {\n-            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-    }\n-\n-    @Test\n-    public void testLcmLong() {\n-        long a = 30;\n-        long b = 50;\n-        long c = 77;\n-\n-        Assert.assertEquals(0, MathUtils.lcm(0, b));\n-        Assert.assertEquals(0, MathUtils.lcm(a, 0));\n-        Assert.assertEquals(b, MathUtils.lcm(1, b));\n-        Assert.assertEquals(a, MathUtils.lcm(a, 1));\n-        Assert.assertEquals(150, MathUtils.lcm(a, b));\n-        Assert.assertEquals(150, MathUtils.lcm(-a, b));\n-        Assert.assertEquals(150, MathUtils.lcm(a, -b));\n-        Assert.assertEquals(150, MathUtils.lcm(-a, -b));\n-        Assert.assertEquals(2310, MathUtils.lcm(a, c));\n-\n-        Assert.assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));\n-\n-        // Assert that no intermediate value overflows:\n-        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n-        Assert.assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));\n-\n-        // Special case\n-        Assert.assertEquals(0L, MathUtils.lcm(0L, 0L));\n-\n-        try {\n-            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n-            MathUtils.lcm(Long.MIN_VALUE, 1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-\n-        try {\n-            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n-            MathUtils.lcm(Long.MIN_VALUE, 1<<20);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-\n-        Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n-            MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n-        try {\n-            MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException expected) {\n-            // expected\n-        }\n-    }\n-\n-    @Test\n     public void testLog() {\n         Assert.assertEquals(2.0, MathUtils.log(2, 4), 0);\n         Assert.assertEquals(3.0, MathUtils.log(2, 8), 0);\n         Assert.assertTrue(Double.isNaN(MathUtils.log(0, 0)));\n         Assert.assertEquals(0, MathUtils.log(0, 10), 0);\n         Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);\n-    }\n-\n-    @Test\n-    public void testMulAndCheck() {\n-        int big = Integer.MAX_VALUE;\n-        int bigNeg = Integer.MIN_VALUE;\n-        Assert.assertEquals(big, MathUtils.mulAndCheck(big, 1));\n-        try {\n-            MathUtils.mulAndCheck(big, 2);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-        }\n-        try {\n-            MathUtils.mulAndCheck(bigNeg, 2);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-        }\n-    }\n-\n-    @Test\n-    public void testMulAndCheckLong() {\n-        long max = Long.MAX_VALUE;\n-        long min = Long.MIN_VALUE;\n-        Assert.assertEquals(max, MathUtils.mulAndCheck(max, 1L));\n-        Assert.assertEquals(min, MathUtils.mulAndCheck(min, 1L));\n-        Assert.assertEquals(0L, MathUtils.mulAndCheck(max, 0L));\n-        Assert.assertEquals(0L, MathUtils.mulAndCheck(min, 0L));\n-        Assert.assertEquals(max, MathUtils.mulAndCheck(1L, max));\n-        Assert.assertEquals(min, MathUtils.mulAndCheck(1L, min));\n-        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, max));\n-        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, min));\n-        Assert.assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));\n-        Assert.assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));\n-        testMulAndCheckLongFailure(max, 2L);\n-        testMulAndCheckLongFailure(2L, max);\n-        testMulAndCheckLongFailure(min, 2L);\n-        testMulAndCheckLongFailure(2L, min);\n-        testMulAndCheckLongFailure(min, -1L);\n-        testMulAndCheckLongFailure(-1L, min);\n-    }\n-\n-    private void testMulAndCheckLongFailure(long a, long b) {\n-        try {\n-            MathUtils.mulAndCheck(a, b);\n-            Assert.fail(\"Expecting MathArithmeticException\");\n-        } catch (MathArithmeticException ex) {\n-            // success\n-        }\n     }\n \n     @Test", "timestamp": 1318483768, "metainfo": ""}