{"sha": "1ae0a97fb9bc80229d7777dd4a8b33067bacd7e6", "log": "New implementation of AbstractRealDistribution.inverseCumulativeProbability(double). Solves MATH-699, and leads to slightly smaller execution times.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n-import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n \n     /** {@inheritDoc} */\n     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n-\n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple root finding using bracketing and default solver.\n-        // subclasses can override if there is a better method.\n-        UnivariateFunction rootFindingFunction =\n-            new UnivariateFunction() {\n-            public double value(double x) {\n+        double lowerBound = getSupportLowerBound();\n+        if (p == 0.0) {\n+            return lowerBound;\n+        }\n+\n+        double upperBound = getSupportUpperBound();\n+        if (p == 1.0) {\n+            return upperBound;\n+        }\n+\n+        final double mu = getNumericalMean();\n+        final double sig = FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies;\n+        chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                             Double.isInfinite(sig) || Double.isNaN(sig));\n+\n+        if (lowerBound == Double.NEGATIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n+            } else {\n+                lowerBound = -1.0;\n+                while (cumulativeProbability(lowerBound) >= p) {\n+                    lowerBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        if (upperBound == Double.POSITIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                upperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n+            } else {\n+                upperBound = 1.0;\n+                while (cumulativeProbability(upperBound) < p) {\n+                    upperBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        final UnivariateFunction toSolve = new UnivariateFunction() {\n+\n+            public double value(final double x) {\n                 return cumulativeProbability(x) - p;\n             }\n         };\n \n-        // Try to bracket root, test domain endpoints if this fails\n-        double lowerBound = getDomainLowerBound(p);\n-        double upperBound = getDomainUpperBound(p);\n-        double[] bracket = null;\n-        try {\n-            bracket = UnivariateRealSolverUtils.bracket(\n-                    rootFindingFunction, getInitialDomain(p),\n-                    lowerBound, upperBound);\n-        } catch (NumberIsTooLargeException ex) {\n-            /*\n-             * Check domain endpoints to see if one gives value that is within\n-             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n-             * case if density has bounded support and p is 0 or 1).\n-             */\n-            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n-                return lowerBound;\n-            }\n-            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n-                return upperBound;\n-            }\n-            // Failed bracket convergence was not because of corner solution\n-            throw new MathInternalError(ex);\n-        }\n-\n-        // find root\n-        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n-                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n-                // absolute accuracy different from the default.\n-                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n-        return root;\n+        double x = UnivariateRealSolverUtils.solve(toSolve,\n+                                                   lowerBound,\n+                                                   upperBound,\n+                                                   getSolverAbsoluteAccuracy());\n+\n+        if (!isSupportConnected()) {\n+            /* Test for plateau. */\n+            final double dx = getSolverAbsoluteAccuracy();\n+            if (x - dx >= getSupportLowerBound()) {\n+                double px = cumulativeProbability(x);\n+                if (cumulativeProbability(x - dx) == px) {\n+                    upperBound = x;\n+                    while (upperBound - lowerBound > dx) {\n+                        final double midPoint = 0.5 * (lowerBound + upperBound);\n+                        if (cumulativeProbability(midPoint) < px) {\n+                            lowerBound = midPoint;\n+                        } else {\n+                            upperBound = midPoint;\n+                        }\n+                    }\n+                    return upperBound;\n+                }\n+            }\n+        }\n+        return x;\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.integration.RombergIntegrator;\n+import org.apache.commons.math.analysis.integration.UnivariateRealIntegrator;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Various tests related to MATH-699. */\n+public class AbstractRealDistributionTest {\n+\n+    @Test\n+    public void testContinuous() {\n+        final double x0 = 0.0;\n+        final double x1 = 1.0;\n+        final double x2 = 2.0;\n+        final double x3 = 3.0;\n+        final double p12 = 0.5;\n+        final AbstractRealDistribution distribution;\n+        distribution = new AbstractRealDistribution() {\n+\n+            public double cumulativeProbability(final double x) {\n+                if ((x < x0) || (x > x3)) {\n+                    throw new OutOfRangeException(x, x0, x3);\n+                }\n+                if (x <= x1) {\n+                    return p12 * (x - x0) / (x1 - x0);\n+                } else if (x <= x2) {\n+                    return p12;\n+                } else if (x <= x3) {\n+                    return p12 + (1.0 - p12) * (x - x2) / (x3 - x2);\n+                }\n+                return 0.0;\n+            }\n+\n+            public double density(final double x) {\n+                if ((x < x0) || (x > x3)) {\n+                    throw new OutOfRangeException(x, x0, x3);\n+                }\n+                if (x <= x1) {\n+                    return p12 / (x1 - x0);\n+                } else if (x <= x2) {\n+                    return 0.0;\n+                } else if (x <= x3) {\n+                    return (1.0 - p12) / (x3 - x2);\n+                }\n+                return 0.0;\n+            }\n+\n+            @Override\n+            protected double getDomainLowerBound(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            protected double getDomainUpperBound(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            protected double getInitialDomain(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public double getNumericalMean() {\n+                return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0;\n+            }\n+\n+            public double getNumericalVariance() {\n+                final double meanX = getNumericalMean();\n+                final double meanX2;\n+                meanX2 = ((x0 * x0 + x0 * x1 + x1 * x1) * p12 + (x2 * x2 + x2\n+                        * x3 + x3 * x3)\n+                        * (1.0 - p12)) / 3.0;\n+                return meanX2 - meanX * meanX;\n+            }\n+\n+            public double getSupportLowerBound() {\n+                return x0;\n+            }\n+\n+            public double getSupportUpperBound() {\n+                return x3;\n+            }\n+\n+            public boolean isSupportConnected() {\n+                return false;\n+            }\n+\n+            public boolean isSupportLowerBoundInclusive() {\n+                return true;\n+            }\n+\n+            public boolean isSupportUpperBoundInclusive() {\n+                return true;\n+            }\n+\n+            public double probability(final double x) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final double expected = x1;\n+        final double actual = distribution.inverseCumulativeProbability(p12);\n+        Assert.assertEquals(\"\", expected, actual,\n+                distribution.getSolverAbsoluteAccuracy());\n+    }\n+\n+    @Test\n+    public void testDiscontinuous() {\n+        final double x0 = 0.0;\n+        final double x1 = 0.25;\n+        final double x2 = 0.5;\n+        final double x3 = 0.75;\n+        final double x4 = 1.0;\n+        final double p12 = 1.0 / 3.0;\n+        final double p23 = 2.0 / 3.0;\n+        final AbstractRealDistribution distribution;\n+        distribution = new AbstractRealDistribution() {\n+\n+            public double cumulativeProbability(final double x) {\n+                if ((x < x0) || (x > x4)) {\n+                    throw new OutOfRangeException(x, x0, x4);\n+                }\n+                if (x <= x1) {\n+                    return p12 * (x - x0) / (x1 - x0);\n+                } else if (x <= x2) {\n+                    return p12;\n+                } else if (x <= x3) {\n+                    return p23;\n+                } else {\n+                    return (1.0 - p23) * (x - x3) / (x4 - x3) + p23;\n+                }\n+            }\n+\n+            public double density(final double x) {\n+                if ((x < x0) || (x > x4)) {\n+                    throw new OutOfRangeException(x, x0, x4);\n+                }\n+                if (x <= x1) {\n+                    return p12 / (x1 - x0);\n+                } else if (x <= x2) {\n+                    return 0.0;\n+                } else if (x <= x3) {\n+                    return 0.0;\n+                } else {\n+                    return (1.0 - p23) / (x4 - x3);\n+                }\n+            }\n+\n+            @Override\n+            protected double getDomainLowerBound(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            protected double getDomainUpperBound(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            protected double getInitialDomain(final double p) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public double getNumericalMean() {\n+                final UnivariateFunction f = new UnivariateFunction() {\n+\n+                    public double value(final double x) {\n+                        return x * density(x);\n+                    }\n+                };\n+                final UnivariateRealIntegrator integrator = new RombergIntegrator();\n+                return integrator.integrate(Integer.MAX_VALUE, f, x0, x4);\n+            }\n+\n+            public double getNumericalVariance() {\n+                final double meanX = getNumericalMean();\n+                final UnivariateFunction f = new UnivariateFunction() {\n+\n+                    public double value(final double x) {\n+                        return x * x * density(x);\n+                    }\n+                };\n+                final UnivariateRealIntegrator integrator = new RombergIntegrator();\n+                final double meanX2 = integrator.integrate(Integer.MAX_VALUE,\n+                        f, x0, x4);\n+                return meanX2 - meanX * meanX;\n+            }\n+\n+            public double getSupportLowerBound() {\n+                return x0;\n+            }\n+\n+            public double getSupportUpperBound() {\n+                return x4;\n+            }\n+\n+            public boolean isSupportConnected() {\n+                return false;\n+            }\n+\n+            public boolean isSupportLowerBoundInclusive() {\n+                return true;\n+            }\n+\n+            public boolean isSupportUpperBoundInclusive() {\n+                return true;\n+            }\n+\n+            public double probability(final double x) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final double expected = x2;\n+        final double actual = distribution.inverseCumulativeProbability(p23);\n+        Assert.assertEquals(\"\", expected, actual,\n+                distribution.getSolverAbsoluteAccuracy());\n+\n+    }\n+}", "timestamp": 1322929495, "metainfo": ""}