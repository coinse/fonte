{"sha": "1d0f8c0e3e16a2159b52c16f36a50559d3550bfa", "log": "MATH-884 Added methods \"isSymmetric\" and \"checkSymmetric\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n             m.setEntry(i, 0, columnData[i]);\n         }\n         return m;\n+    }\n+\n+    /**\n+     * Checks whether a matrix is symmetric, within a given relative tolerance.\n+     *\n+     * @param matrix Matrix to check.\n+     * @param relativeTolerance Tolerance of the symmetry check.\n+     * @param raiseException If {@code true}, an exception will be raised if\n+     * the matrix is not symmetric.\n+     * @return {@code true} if {@code matrix} is symmetric.\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     */\n+    private static boolean isSymmetricInternal(RealMatrix matrix,\n+                                               double relativeTolerance,\n+                                               boolean raiseException) {\n+        final int rows = matrix.getRowDimension();\n+        if (rows != matrix.getColumnDimension()) {\n+            if (raiseException) {\n+                throw new NonSquareMatrixException(rows, matrix.getColumnDimension());\n+            } else {\n+                return false;\n+            }\n+        }\n+        for (int i = 0; i < rows; i++) {\n+            for (int j = i + 1; j < rows; j++) {\n+                final double mij = matrix.getEntry(i, j);\n+                final double mji = matrix.getEntry(j, i);\n+                if (FastMath.abs(mij - mji) >\n+                    FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * relativeTolerance) {\n+                    if (raiseException) {\n+                        throw new NonSymmetricMatrixException(i, j, relativeTolerance);\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether a matrix is symmetric.\n+     *\n+     * @param matrix Matrix to check.\n+     * @param eps Relative tolerance.\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     */\n+    public static void checkSymmetric(RealMatrix matrix,\n+                                      double eps) {\n+        isSymmetricInternal(matrix, eps, true);\n+    }\n+\n+    /**\n+     * Checks whether a matrix is symmetric.\n+     *\n+     * @param matrix Matrix to check.\n+     * @param eps Relative tolerance.\n+     * @return {@code true} if {@code matrix} is symmetric.\n+     */\n+    public static boolean isSymmetric(RealMatrix matrix,\n+                                      double eps) {\n+        return isSymmetricInternal(matrix, eps, false);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/MatrixUtilsTest.java\n             }\n         }\n     }\n+\n+    @Test\n+    public void testIsSymmetric() {\n+        final double eps = Math.ulp(1d);\n+\n+        final double[][] dataSym = {\n+            { 1, 2, 3 },\n+            { 2, 2, 5 },\n+            { 3, 5, 6 },\n+        };\n+        Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym), eps));\n+\n+        final double[][] dataNonSym = {\n+            { 1, 2, -3 },\n+            { 2, 2, 5 },\n+            { 3, 5, 6 },\n+        };\n+        Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym), eps));\n+    }\n+\n+    @Test\n+    public void testIsSymmetricTolerance() {\n+        final double eps = 1e-4;\n+\n+        final double[][] dataSym1 = {\n+            { 1,   1, 1.00009 },\n+            { 1,   1, 1       },\n+            { 1.0, 1, 1       },\n+        };\n+        Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym1), eps));\n+        final double[][] dataSym2 = {\n+            { 1,   1, 0.99990 },\n+            { 1,   1, 1       },\n+            { 1.0, 1, 1       },\n+        };\n+        Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym2), eps));\n+\n+        final double[][] dataNonSym1 = {\n+            { 1,   1, 1.00011 },\n+            { 1,   1, 1       },\n+            { 1.0, 1, 1       },\n+        };\n+        Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym1), eps));\n+        final double[][] dataNonSym2 = {\n+            { 1,   1, 0.99989 },\n+            { 1,   1, 1       },\n+            { 1.0, 1, 1       },\n+        };\n+        Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym2), eps));\n+    }\n+\n+    @Test\n+    public void testCheckSymmetric1() {\n+        final double[][] dataSym = {\n+            { 1, 2, 3 },\n+            { 2, 2, 5 },\n+            { 3, 5, 6 },\n+        };\n+        MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataSym), Math.ulp(1d));\n+    }\n+    \n+    @Test(expected=NonSymmetricMatrixException.class)\n+    public void testCheckSymmetric2() {\n+        final double[][] dataNonSym = {\n+            { 1, 2, -3 },\n+            { 2, 2, 5 },\n+            { 3, 5, 6 },\n+        };\n+        MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataNonSym), Math.ulp(1d));\n+    }\n }", "timestamp": 1351556480, "metainfo": ""}