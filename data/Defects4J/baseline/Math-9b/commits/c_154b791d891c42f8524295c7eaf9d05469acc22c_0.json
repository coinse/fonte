{"sha": "154b791d891c42f8524295c7eaf9d05469acc22c", "log": "MATH-491 Replaced old (checked) \"DimensionMismatchException\" by its unchecked equivalent in package \"exception\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n \n package org.apache.commons.math.random;\n \n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n \n public class CorrelatedRandomVectorGenerator\n     implements RandomVectorGenerator {\n-\n     /** Mean vector. */\n     private final double[] mean;\n-\n     /** Underlying generator. */\n     private final NormalizedRandomGenerator generator;\n-\n     /** Storage for the normalized vector. */\n     private final double[] normalized;\n-\n     /** Permutated Cholesky root of the covariance matrix. */\n     private RealMatrix root;\n-\n     /** Rank of the covariance matrix. */\n     private int rank;\n \n      * considered to be dependent on previous ones and are discarded\n      * @param generator underlying generator for uncorrelated normalized\n      * components\n-     * @exception IllegalArgumentException if there is a dimension\n-     * mismatch between the mean vector and the covariance matrix\n-     * @exception NonPositiveDefiniteMatrixException if the\n+     * @throws NonPositiveDefiniteMatrixException if the\n      * covariance matrix is not strictly positive definite\n-     * @exception DimensionMismatchException if the mean and covariance\n-     * arrays dimensions don't match\n+     * @throws DimensionMismatchException if the mean and covariance\n+     * arrays dimensions do not match.\n      */\n     public CorrelatedRandomVectorGenerator(double[] mean,\n                                            RealMatrix covariance, double small,\n-                                           NormalizedRandomGenerator generator)\n-    throws DimensionMismatchException {\n-\n+                                           NormalizedRandomGenerator generator) {\n         int order = covariance.getRowDimension();\n         if (mean.length != order) {\n             throw new DimensionMismatchException(mean.length, order);\n      * @param covariance covariance matrix\n      * @param small diagonal elements threshold under which  column are\n      * considered to be dependent on previous ones and are discarded\n-     * @exception NonPositiveDefiniteMatrixException if the\n-     * covariance matrix is not strictly positive definite\n+     * @throws NonPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite.\n      */\n     private void decompose(RealMatrix covariance, double small) {\n         int order = covariance.getRowDimension();\n \n                 // prepare next iteration\n                 loop = ++rank < order;\n-\n-            }\n-\n+            }\n         }\n \n         // build the root matrix\n         }\n \n         return correlated;\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n  * @version $Revision$ $Date$\n  */\n public class MultivariateSummaryStatistics\n-  implements StatisticalMultivariateSummary, Serializable {\n+    implements StatisticalMultivariateSummary, Serializable {\n \n     /** Serialization UID */\n     private static final long serialVersionUID = 2271900808994826718L;\n      * @throws DimensionMismatchException if the length of the array\n      * does not match the one used at construction\n      */\n-    public void addValue(double[] value)\n-      throws DimensionMismatchException {\n+    public void addValue(double[] value) {\n         checkDimension(value.length);\n         for (int i = 0; i < k; ++i) {\n             double v = value[i];\n      *  (i.e if n > 0)\n      */\n     private void setImpl(StorelessUnivariateStatistic[] newImpl,\n-                         StorelessUnivariateStatistic[] oldImpl)\n-       throws DimensionMismatchException, IllegalStateException {\n+                         StorelessUnivariateStatistic[] oldImpl) {\n         checkEmpty();\n         checkDimension(newImpl.length);\n         System.arraycopy(newImpl, 0, oldImpl, 0, newImpl.length);\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n-      throws DimensionMismatchException {\n+    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n         setImpl(sumImpl, this.sumImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n-      throws DimensionMismatchException {\n+    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n         setImpl(sumsqImpl, this.sumSqImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n-      throws DimensionMismatchException {\n+    public void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n         setImpl(minImpl, this.minImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n-      throws DimensionMismatchException {\n+    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n         setImpl(maxImpl, this.maxImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n-      throws DimensionMismatchException {\n+    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n         setImpl(sumLogImpl, this.sumLogImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n-      throws DimensionMismatchException {\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n         setImpl(geoMeanImpl, this.geoMeanImpl);\n     }\n \n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n-      throws DimensionMismatchException {\n+    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n         setImpl(meanImpl, this.meanImpl);\n     }\n \n      * @param dimension dimension to check\n      * @throws DimensionMismatchException if dimension != k\n      */\n-    private void checkDimension(int dimension)\n-      throws DimensionMismatchException {\n+    private void checkDimension(int dimension) {\n         if (dimension != k) {\n             throw new DimensionMismatchException(dimension, k);\n         }\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n  */\n package org.apache.commons.math.stat.descriptive;\n \n-import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.linear.RealMatrix;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class SynchronizedMultivariateSummaryStatistics\n-  extends MultivariateSummaryStatistics {\n+    extends MultivariateSummaryStatistics {\n \n     /** Serialization UID */\n     private static final long serialVersionUID = 7099834153347155363L;\n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void addValue(double[] value)\n-      throws DimensionMismatchException {\n+    public synchronized void addValue(double[] value) {\n       super.addValue(value);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n         super.setSumImpl(sumImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n         super.setSumsqImpl(sumsqImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n         super.setMinImpl(minImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n         super.setMaxImpl(maxImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n         super.setSumLogImpl(sumLogImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n         super.setGeoMeanImpl(geoMeanImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n-      throws DimensionMismatchException {\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n         super.setMeanImpl(meanImpl);\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n \n     /**\n      * Add a new vector to the sample.\n      * @param v vector to add\n-     * @exception DimensionMismatchException if the vector does not have the right dimension\n+     * @throws DimensionMismatchException if the vector does not have the right dimension\n      */\n     public void increment(double[] v) throws DimensionMismatchException {\n         if (v.length != sums.length) {\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Returns the arithmetic mean of the available vectors.\n     /**\n      * Add a new vector to the sample.\n      * @param v vector to add\n-     * @exception DimensionMismatchException if the vector does not have the right dimension\n+     * @throws DimensionMismatchException if the vector does not have the right dimension\n      */\n-    public void increment(double[] v) throws DimensionMismatchException {\n+    public void increment(double[] v) {\n         if (v.length != means.length) {\n             throw new DimensionMismatchException(v.length, means.length);\n         }\n--- a/src/test/java/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n \n package org.apache.commons.math.random;\n \n-import junit.framework.TestCase;\n-\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n import org.apache.commons.math.util.FastMath;\n \n-public class CorrelatedRandomVectorGeneratorTest\n-extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-    public CorrelatedRandomVectorGeneratorTest(String name) {\n-        super(name);\n-        mean       = null;\n-        covariance = null;\n-        generator  = null;\n+public class CorrelatedRandomVectorGeneratorTest {\n+    private double[] mean;\n+    private RealMatrix covariance;\n+    private CorrelatedRandomVectorGenerator generator;\n+\n+    public CorrelatedRandomVectorGeneratorTest() {\n+        mean = new double[] { 0.0, 1.0, -3.0, 2.3 };\n+\n+        RealMatrix b = MatrixUtils.createRealMatrix(4, 3);\n+        int counter = 0;\n+        for (int i = 0; i < b.getRowDimension(); ++i) {\n+            for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                b.setEntry(i, j, 1.0 + 0.1 * ++counter);\n+            }\n+        }\n+        RealMatrix bbt = b.multiply(b.transpose());\n+        covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);\n+        for (int i = 0; i < covariance.getRowDimension(); ++i) {\n+            covariance.setEntry(i, i, bbt.getEntry(i, i));\n+            for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n+                double s = bbt.getEntry(i, j);\n+                covariance.setEntry(i, j, s);\n+                covariance.setEntry(j, i, s);\n+            }\n+        }\n+\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(17399225432l);\n+        GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);\n+        generator = new CorrelatedRandomVectorGenerator(mean,\n+                                                        covariance,\n+                                                        1.0e-12 * covariance.getNorm(),\n+                                                        rawGenerator);\n     }\n \n+    @Test\n     public void testRank() {\n-        assertEquals(3, generator.getRank());\n+        Assert.assertEquals(3, generator.getRank());\n     }\n \n-    public void testMath226()\n-        throws DimensionMismatchException {\n+    @Test\n+    public void testMath226() {\n         double[] mean = { 1, 1, 10, 1 };\n         double[][] cov = {\n                 { 1, 3, 2, 6 },\n \n         for (int i = 0; i < 10; i++) {\n             double[] generated = sg.nextVector();\n-            assertTrue(FastMath.abs(generated[0] - 1) > 0.1);\n+            Assert.assertTrue(FastMath.abs(generated[0] - 1) > 0.1);\n         }\n \n     }\n \n+    @Test\n     public void testRootMatrix() {\n         RealMatrix b = generator.getRootMatrix();\n         RealMatrix bbt = b.multiply(b.transpose());\n         for (int i = 0; i < covariance.getRowDimension(); ++i) {\n             for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n-                assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);\n+                Assert.assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);\n             }\n         }\n     }\n \n-    public void testMeanAndCovariance() throws DimensionMismatchException {\n+    @Test\n+    public void testMeanAndCovariance() {\n \n         VectorialMean meanStat = new VectorialMean(mean.length);\n         VectorialCovariance covStat = new VectorialCovariance(mean.length, true);\n         double[] estimatedMean = meanStat.getResult();\n         RealMatrix estimatedCovariance = covStat.getResult();\n         for (int i = 0; i < estimatedMean.length; ++i) {\n-            assertEquals(mean[i], estimatedMean[i], 0.07);\n+            Assert.assertEquals(mean[i], estimatedMean[i], 0.07);\n             for (int j = 0; j <= i; ++j) {\n-                assertEquals(covariance.getEntry(i, j),\n-                        estimatedCovariance.getEntry(i, j),\n-                        0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));\n+                Assert.assertEquals(covariance.getEntry(i, j),\n+                                    estimatedCovariance.getEntry(i, j),\n+                                    0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));\n             }\n         }\n \n     }\n-\n-    @Override\n-    public void setUp() {\n-        try {\n-            mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n-\n-            RealMatrix b = MatrixUtils.createRealMatrix(4, 3);\n-            int counter = 0;\n-            for (int i = 0; i < b.getRowDimension(); ++i) {\n-                for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    b.setEntry(i, j, 1.0 + 0.1 * ++counter);\n-                }\n-            }\n-            RealMatrix bbt = b.multiply(b.transpose());\n-            covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);\n-            for (int i = 0; i < covariance.getRowDimension(); ++i) {\n-                covariance.setEntry(i, i, bbt.getEntry(i, i));\n-                for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n-                    double s = bbt.getEntry(i, j);\n-                    covariance.setEntry(i, j, s);\n-                    covariance.setEntry(j, i, s);\n-                }\n-            }\n-\n-            RandomGenerator rg = new JDKRandomGenerator();\n-            rg.setSeed(17399225432l);\n-            GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);\n-            generator = new CorrelatedRandomVectorGenerator(mean,\n-                                                            covariance,\n-                                                            1.0e-12 * covariance.getNorm(),\n-                                                            rawGenerator);\n-        } catch (DimensionMismatchException e) {\n-            fail(e.getMessage());\n-        } catch (NonPositiveDefiniteMatrixException e) {\n-            fail(\"not positive definite matrix\");\n-        }\n-    }\n-\n-    @Override\n-    public void tearDown() {\n-        mean       = null;\n-        covariance = null;\n-        generator  = null;\n-    }\n-\n-    private double[] mean;\n-    private RealMatrix covariance;\n-    private CorrelatedRandomVectorGenerator generator;\n-\n }\n--- a/src/test/java/org/apache/commons/math/random/UncorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/UncorrelatedRandomVectorGeneratorTest.java\n \n package org.apache.commons.math.random;\n \n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n \n-import junit.framework.*;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-public class UncorrelatedRandomVectorGeneratorTest\n-extends TestCase {\n+public class UncorrelatedRandomVectorGeneratorTest {\n+    private double[] mean;\n+    private double[] standardDeviation;\n+    private UncorrelatedRandomVectorGenerator generator;\n \n-    public UncorrelatedRandomVectorGeneratorTest(String name) {\n-        super(name);\n-        mean = null;\n-        standardDeviation = null;\n-        generator = null;\n+    public UncorrelatedRandomVectorGeneratorTest() {\n+        mean              = new double[] {0.0, 1.0, -3.0, 2.3};\n+        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(17399225432l);\n+        generator =\n+            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,\n+                    new GaussianRandomGenerator(rg));\n     }\n \n-    public void testMeanAndCorrelation() throws DimensionMismatchException {\n+    @Test\n+    public void testMeanAndCorrelation() {\n \n         VectorialMean meanStat = new VectorialMean(mean.length);\n         VectorialCovariance covStat = new VectorialCovariance(mean.length, true);\n         double scale;\n         RealMatrix estimatedCorrelation = covStat.getResult();\n         for (int i = 0; i < estimatedMean.length; ++i) {\n-            assertEquals(mean[i], estimatedMean[i], 0.07);\n+            Assert.assertEquals(mean[i], estimatedMean[i], 0.07);\n             for (int j = 0; j < i; ++j) {\n                 scale = standardDeviation[i] * standardDeviation[j];\n-                assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);\n+                Assert.assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);\n             }\n             scale = standardDeviation[i] * standardDeviation[i];\n-            assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);\n+            Assert.assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);\n         }\n-\n     }\n-\n-    @Override\n-    public void setUp() {\n-        mean              = new double[] {0.0, 1.0, -3.0, 2.3};\n-        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};\n-        RandomGenerator rg = new JDKRandomGenerator();\n-        rg.setSeed(17399225432l);\n-        generator =\n-            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,\n-                    new GaussianRandomGenerator(rg));\n-    }\n-\n-    @Override\n-    public void tearDown() {\n-        mean = null;\n-        standardDeviation = null;\n-        generator = null;\n-    }\n-\n-    private double[] mean;\n-    private double[] standardDeviation;\n-    private UncorrelatedRandomVectorGenerator generator;\n-\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n \n import java.util.Locale;\n \n-import junit.framework.TestCase;\n-\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.util.FastMath;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n \n /**\n  * Test cases for the {@link MultivariateSummaryStatistics} class.\n  * @version $Revision$ $Date$\n  */\n \n-public class MultivariateSummaryStatisticsTest extends TestCase {\n-\n-    public MultivariateSummaryStatisticsTest(String name) {\n-        super(name);\n-    }\n+public class MultivariateSummaryStatisticsTest {\n \n     protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n         return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected);\n     }\n \n+    @Test\n     public void testSetterInjection() throws Exception {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n         u.setMeanImpl(new StorelessUnivariateStatistic[] {\n                       });\n         u.addValue(new double[] { 1, 2 });\n         u.addValue(new double[] { 3, 4 });\n-        assertEquals(4, u.getMean()[0], 1E-14);\n-        assertEquals(6, u.getMean()[1], 1E-14);\n+        Assert.assertEquals(4, u.getMean()[0], 1E-14);\n+        Assert.assertEquals(6, u.getMean()[1], 1E-14);\n         u.clear();\n         u.addValue(new double[] { 1, 2 });\n         u.addValue(new double[] { 3, 4 });\n-        assertEquals(4, u.getMean()[0], 1E-14);\n-        assertEquals(6, u.getMean()[1], 1E-14);\n+        Assert.assertEquals(4, u.getMean()[0], 1E-14);\n+        Assert.assertEquals(6, u.getMean()[1], 1E-14);\n         u.clear();\n         u.setMeanImpl(new StorelessUnivariateStatistic[] {\n                         new Mean(), new Mean()\n                       }); // OK after clear\n         u.addValue(new double[] { 1, 2 });\n         u.addValue(new double[] { 3, 4 });\n-        assertEquals(2, u.getMean()[0], 1E-14);\n-        assertEquals(3, u.getMean()[1], 1E-14);\n-        assertEquals(2, u.getDimension());\n-    }\n-\n+        Assert.assertEquals(2, u.getMean()[0], 1E-14);\n+        Assert.assertEquals(3, u.getMean()[1], 1E-14);\n+        Assert.assertEquals(2, u.getDimension());\n+    }\n+\n+    @Test\n     public void testSetterIllegalState() throws Exception {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n         u.addValue(new double[] { 1, 2 });\n             u.setMeanImpl(new StorelessUnivariateStatistic[] {\n                             new sumMean(), new sumMean()\n                           });\n-            fail(\"Expecting IllegalStateException\");\n+            Assert.fail(\"Expecting IllegalStateException\");\n         } catch (IllegalStateException ex) {\n             // expected\n         }\n     }\n \n-    public void testToString() throws DimensionMismatchException {\n+    @Test\n+    public void testToString() {\n         MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true);\n         stats.addValue(new double[] {1, 3});\n         stats.addValue(new double[] {2, 2});\n         Locale d = Locale.getDefault();\n         Locale.setDefault(Locale.US);\n         final String suffix = System.getProperty(\"line.separator\");\n-        assertEquals(\"MultivariateSummaryStatistics:\" + suffix+\n+        Assert.assertEquals(\"MultivariateSummaryStatistics:\" + suffix+\n                      \"n: 3\" +suffix+\n                      \"min: 1.0, 1.0\" +suffix+\n                      \"max: 3.0, 3.0\" +suffix+\n         Locale.setDefault(d);\n     }\n \n-    public void testShuffledStatistics() throws DimensionMismatchException {\n+    @Test\n+    public void testShuffledStatistics() {\n         // the purpose of this test is only to check the get/set methods\n         // we are aware shuffling statistics like this is really not\n         // something sensible to do in production ...\n         }\n     }\n \n+    @Test\n     public void testDimension() {\n         try {\n             createMultivariateSummaryStatistics(2, true).addValue(new double[3]);\n-            fail(\"Expecting DimensionMismatchException\");\n+            Assert.fail(\"Expecting DimensionMismatchException\");\n         } catch (DimensionMismatchException dme) {\n             // expected behavior\n         }\n     }\n \n     /** test stats */\n-    public void testStats() throws DimensionMismatchException {\n-        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n-        assertEquals(0, u.getN());\n+    @Test\n+    public void testStats() {\n+        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n+        Assert.assertEquals(0, u.getN());\n         u.addValue(new double[] { 1, 2 });\n         u.addValue(new double[] { 2, 3 });\n         u.addValue(new double[] { 2, 3 });\n         u.addValue(new double[] { 3, 4 });\n-        assertEquals( 4, u.getN());\n-        assertEquals( 8, u.getSum()[0], 1.0e-10);\n-        assertEquals(12, u.getSum()[1], 1.0e-10);\n-        assertEquals(18, u.getSumSq()[0], 1.0e-10);\n-        assertEquals(38, u.getSumSq()[1], 1.0e-10);\n-        assertEquals( 1, u.getMin()[0], 1.0e-10);\n-        assertEquals( 2, u.getMin()[1], 1.0e-10);\n-        assertEquals( 3, u.getMax()[0], 1.0e-10);\n-        assertEquals( 4, u.getMax()[1], 1.0e-10);\n-        assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);\n-        assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);\n-        assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);\n-        assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);\n-        assertEquals( 2, u.getMean()[0], 1.0e-10);\n-        assertEquals( 3, u.getMean()[1], 1.0e-10);\n-        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n-        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n-        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);\n-        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);\n-        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n-        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);\n+        Assert.assertEquals( 4, u.getN());\n+        Assert.assertEquals( 8, u.getSum()[0], 1.0e-10);\n+        Assert.assertEquals(12, u.getSum()[1], 1.0e-10);\n+        Assert.assertEquals(18, u.getSumSq()[0], 1.0e-10);\n+        Assert.assertEquals(38, u.getSumSq()[1], 1.0e-10);\n+        Assert.assertEquals( 1, u.getMin()[0], 1.0e-10);\n+        Assert.assertEquals( 2, u.getMin()[1], 1.0e-10);\n+        Assert.assertEquals( 3, u.getMax()[0], 1.0e-10);\n+        Assert.assertEquals( 4, u.getMax()[1], 1.0e-10);\n+        Assert.assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);\n+        Assert.assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);\n+        Assert.assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);\n+        Assert.assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);\n+        Assert.assertEquals( 2, u.getMean()[0], 1.0e-10);\n+        Assert.assertEquals( 3, u.getMean()[1], 1.0e-10);\n+        Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n+        Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n+        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);\n+        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);\n+        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n+        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);\n         u.clear();\n-        assertEquals(0, u.getN());\n-    }\n-\n+        Assert.assertEquals(0, u.getN());\n+    }\n+\n+    @Test\n     public void testN0andN1Conditions() throws Exception {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n-        assertTrue(Double.isNaN(u.getMean()[0]));\n-        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getMean()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n \n         /* n=1 */\n         u.addValue(new double[] { 1 });\n-        assertEquals(1.0, u.getMean()[0], 1.0e-10);\n-        assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);\n-        assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, u.getMean()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);\n+        Assert.assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);\n \n         /* n=2 */\n         u.addValue(new double[] { 2 });\n-        assertTrue(u.getStandardDeviation()[0] > 0);\n-\n-    }\n-\n-    public void testNaNContracts() throws DimensionMismatchException {\n+        Assert.assertTrue(u.getStandardDeviation()[0] > 0);\n+\n+    }\n+\n+    @Test\n+    public void testNaNContracts() {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n-        assertTrue(Double.isNaN(u.getMean()[0]));\n-        assertTrue(Double.isNaN(u.getMin()[0]));\n-        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n-        assertTrue(Double.isNaN(u.getGeometricMean()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getMean()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getMin()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n+        Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0]));\n \n         u.addValue(new double[] { 1.0 });\n-        assertFalse(Double.isNaN(u.getMean()[0]));\n-        assertFalse(Double.isNaN(u.getMin()[0]));\n-        assertFalse(Double.isNaN(u.getStandardDeviation()[0]));\n-        assertFalse(Double.isNaN(u.getGeometricMean()[0]));\n-\n-    }\n-\n-    public void testSerialization() throws DimensionMismatchException {\n+        Assert.assertFalse(Double.isNaN(u.getMean()[0]));\n+        Assert.assertFalse(Double.isNaN(u.getMin()[0]));\n+        Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0]));\n+        Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0]));\n+\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n         // Empty test\n         TestUtils.checkSerializedEquality(u);\n         MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n-        assertEquals(u, s);\n+        Assert.assertEquals(u, s);\n \n         // Add some data\n         u.addValue(new double[] { 2d, 1d });\n         // Test again\n         TestUtils.checkSerializedEquality(u);\n         s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n-        assertEquals(u, s);\n-\n-    }\n-\n-    public void testEqualsAndHashCode() throws DimensionMismatchException {\n+        Assert.assertEquals(u, s);\n+\n+    }\n+\n+    @Test\n+    public void testEqualsAndHashCode() {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n         MultivariateSummaryStatistics t = null;\n         int emptyHash = u.hashCode();\n-        assertTrue(u.equals(u));\n-        assertFalse(u.equals(t));\n-        assertFalse(u.equals(Double.valueOf(0)));\n+        Assert.assertTrue(u.equals(u));\n+        Assert.assertFalse(u.equals(t));\n+        Assert.assertFalse(u.equals(Double.valueOf(0)));\n         t = createMultivariateSummaryStatistics(2, true);\n-        assertTrue(t.equals(u));\n-        assertTrue(u.equals(t));\n-        assertEquals(emptyHash, t.hashCode());\n+        Assert.assertTrue(t.equals(u));\n+        Assert.assertTrue(u.equals(t));\n+        Assert.assertEquals(emptyHash, t.hashCode());\n \n         // Add some data to u\n         u.addValue(new double[] { 2d, 1d });\n         u.addValue(new double[] { 3d, 1d });\n         u.addValue(new double[] { 4d, 1d });\n         u.addValue(new double[] { 5d, 1d });\n-        assertFalse(t.equals(u));\n-        assertFalse(u.equals(t));\n-        assertTrue(u.hashCode() != t.hashCode());\n+        Assert.assertFalse(t.equals(u));\n+        Assert.assertFalse(u.equals(t));\n+        Assert.assertTrue(u.hashCode() != t.hashCode());\n \n         //Add data in same order to t\n         t.addValue(new double[] { 2d, 1d });\n         t.addValue(new double[] { 3d, 1d });\n         t.addValue(new double[] { 4d, 1d });\n         t.addValue(new double[] { 5d, 1d });\n-        assertTrue(t.equals(u));\n-        assertTrue(u.equals(t));\n-        assertEquals(u.hashCode(), t.hashCode());\n+        Assert.assertTrue(t.equals(u));\n+        Assert.assertTrue(u.equals(t));\n+        Assert.assertEquals(u.hashCode(), t.hashCode());\n \n         // Clear and make sure summaries are indistinguishable from empty summary\n         u.clear();\n         t.clear();\n-        assertTrue(t.equals(u));\n-        assertTrue(u.equals(t));\n-        assertEquals(emptyHash, t.hashCode());\n-        assertEquals(emptyHash, u.hashCode());\n-    }\n-\n+        Assert.assertTrue(t.equals(u));\n+        Assert.assertTrue(u.equals(t));\n+        Assert.assertEquals(emptyHash, t.hashCode());\n+        Assert.assertEquals(emptyHash, u.hashCode());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatisticsTest.java\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public final class SynchronizedMultivariateSummaryStatisticsTest extends MultivariateSummaryStatisticsTest {\n-\n-    public SynchronizedMultivariateSummaryStatisticsTest(String name) {\n-        super(name);\n-    }\n-\n+public final class SynchronizedMultivariateSummaryStatisticsTest\n+    extends MultivariateSummaryStatisticsTest {\n     @Override\n     protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n         return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected);\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n \n package org.apache.commons.math.stat.descriptive.moment;\n \n-import junit.framework.TestCase;\n-\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.linear.RealMatrix;\n \n-public class VectorialCovarianceTest\n-extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-    public VectorialCovarianceTest(String name) {\n-        super(name);\n-        points = null;\n+public class VectorialCovarianceTest {\n+    private double[][] points;\n+\n+    public VectorialCovarianceTest() {\n+        points = new double[][] {\n+            { 1.2, 2.3,  4.5},\n+            {-0.7, 2.3,  5.0},\n+            { 3.1, 0.0, -3.1},\n+            { 6.0, 1.2,  4.2},\n+            {-0.7, 2.3,  5.0}\n+        };\n     }\n \n+    @Test\n     public void testMismatch() {\n         try {\n             new VectorialCovariance(8, true).increment(new double[5]);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException dme) {\n-            assertEquals(5, dme.getDimension1());\n-            assertEquals(8, dme.getDimension2());\n+            Assert.assertEquals(5, dme.getArgument());\n+            Assert.assertEquals(8, dme.getDimension());\n         }\n     }\n \n-    public void testSimplistic() throws DimensionMismatchException {\n+    @Test\n+    public void testSimplistic() {\n         VectorialCovariance stat = new VectorialCovariance(2, true);\n         stat.increment(new double[] {-1.0,  1.0});\n         stat.increment(new double[] { 1.0, -1.0});\n         RealMatrix c = stat.getResult();\n-        assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);\n-        assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);\n-        assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);\n+        Assert.assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);\n+        Assert.assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);\n+        Assert.assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);\n     }\n \n-    public void testBasicStats() throws DimensionMismatchException {\n+    @Test\n+    public void testBasicStats() {\n \n         VectorialCovariance stat = new VectorialCovariance(points[0].length, true);\n         for (int i = 0; i < points.length; ++i) {\n             stat.increment(points[i]);\n         }\n \n-        assertEquals(points.length, stat.getN());\n+        Assert.assertEquals(points.length, stat.getN());\n \n         RealMatrix c = stat.getResult();\n         double[][] refC    = new double[][] {\n \n         for (int i = 0; i < c.getRowDimension(); ++i) {\n             for (int j = 0; j <= i; ++j) {\n-                assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);\n+                Assert.assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);\n             }\n         }\n \n     }\n \n+    @Test\n     public void testSerial(){\n         VectorialCovariance stat = new VectorialCovariance(points[0].length, true);\n-        assertEquals(stat, TestUtils.serializeAndRecover(stat));\n+        Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));\n     }\n-\n-    @Override\n-    public void setUp() {\n-        points = new double[][] {\n-                { 1.2, 2.3,  4.5},\n-                {-0.7, 2.3,  5.0},\n-                { 3.1, 0.0, -3.1},\n-                { 6.0, 1.2,  4.2},\n-                {-0.7, 2.3,  5.0}\n-        };\n-    }\n-\n-    @Override\n-    public void tearDown() {\n-        points = null;\n-    }\n-\n-    private double [][] points;\n-\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialMeanTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialMeanTest.java\n \n package org.apache.commons.math.stat.descriptive.moment;\n \n-import junit.framework.TestCase;\n-\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.TestUtils;\n \n-public class VectorialMeanTest\n-extends TestCase {\n+import org.junit.Test;\n+import org.junit.Assert;\n \n-    public VectorialMeanTest(String name) {\n-        super(name);\n-        points = null;\n+public class VectorialMeanTest {\n+    private double[][] points;\n+\n+    public VectorialMeanTest() {\n+        points = new double[][] {\n+            { 1.2, 2.3,  4.5},\n+            {-0.7, 2.3,  5.0},\n+            { 3.1, 0.0, -3.1},\n+            { 6.0, 1.2,  4.2},\n+            {-0.7, 2.3,  5.0}\n+        };\n     }\n \n+    @Test\n     public void testMismatch() {\n         try {\n             new VectorialMean(8).increment(new double[5]);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (DimensionMismatchException dme) {\n-            assertEquals(5, dme.getDimension1());\n-            assertEquals(8, dme.getDimension2());\n+            Assert.assertEquals(5, dme.getArgument());\n+            Assert.assertEquals(8, dme.getDimension());\n         }\n     }\n \n-    public void testSimplistic() throws DimensionMismatchException {\n+    @Test\n+    public void testSimplistic() {\n         VectorialMean stat = new VectorialMean(2);\n         stat.increment(new double[] {-1.0,  1.0});\n         stat.increment(new double[] { 1.0, -1.0});\n         double[] mean = stat.getResult();\n-        assertEquals(0.0, mean[0], 1.0e-12);\n-        assertEquals(0.0, mean[1], 1.0e-12);\n+        Assert.assertEquals(0.0, mean[0], 1.0e-12);\n+        Assert.assertEquals(0.0, mean[1], 1.0e-12);\n     }\n \n-    public void testBasicStats() throws DimensionMismatchException {\n+    @Test\n+    public void testBasicStats() {\n \n         VectorialMean stat = new VectorialMean(points[0].length);\n         for (int i = 0; i < points.length; ++i) {\n             stat.increment(points[i]);\n         }\n \n-        assertEquals(points.length, stat.getN());\n+        Assert.assertEquals(points.length, stat.getN());\n \n         double[] mean = stat.getResult();\n         double[]   refMean = new double[] { 1.78, 1.62,  3.12};\n \n         for (int i = 0; i < mean.length; ++i) {\n-            assertEquals(refMean[i], mean[i], 1.0e-12);\n+            Assert.assertEquals(refMean[i], mean[i], 1.0e-12);\n         }\n \n     }\n \n-    public void testSerial() throws DimensionMismatchException {\n+    @Test\n+    public void testSerial() {\n         VectorialMean stat = new VectorialMean(points[0].length);\n         for (int i = 0; i < points.length; ++i) {\n             stat.increment(points[i]);\n         }\n-        assertEquals(stat, TestUtils.serializeAndRecover(stat));\n+        Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));\n     }\n-    @Override\n-    public void setUp() {\n-        points = new double[][] {\n-                { 1.2, 2.3,  4.5},\n-                {-0.7, 2.3,  5.0},\n-                { 3.1, 0.0, -3.1},\n-                { 6.0, 1.2,  4.2},\n-                {-0.7, 2.3,  5.0}\n-        };\n-    }\n-\n-    @Override\n-    public void tearDown() {\n-        points = null;\n-    }\n-\n-    private double [][] points;\n-\n }", "timestamp": 1295622775, "metainfo": ""}