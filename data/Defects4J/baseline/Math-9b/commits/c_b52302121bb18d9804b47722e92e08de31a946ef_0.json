{"sha": "b52302121bb18d9804b47722e92e08de31a946ef", "log": "Added a RealTransformer interface on top of cosine, sine and Hadamard transforms. The Fourier transform cannot implement this interface since it produces complex results. Improved error messages.  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    { \"{0} is not a power of 2\",\n      \"{0} n''est pas une puissance de 2\" },\n \n+   // org.apache.commons.math.transform.FastFourierTransformer\n+   { \"cannot compute 0-th root of unity, indefinite result\",\n+     \"impossible de calculer la racine z\\u00e9roi\\u00e8me de l''unit\\u00e9, r\\u00e9sultat ind\\u00e9fini\" },\n+   { \"number of sample is not positive: {0}\",\n+     \"le nombre d''\\u00e9chantillons n''est pas positif : {0}\" },\n+   { \"{0} is not a power of 2, consider padding for fix\",\n+     \"{0} n''est pas une puissance de 2, ajoutez des \\u00e9l\\u00e9ments pour corriger\" },\n+   { \"endpoints do not specify an interval: [{0}, {1}]\",\n+     \"les extr\\u00e9mit\\u00e9s ne constituent pas un intervalle : [{0}, {1}]\" },\n+   { \"some dimensions don't math: {0} != {1}\",\n+     \"certaines dimensions sont incoh\\u00e9rentes : {0} != {1}\" },\n+\n+   // org.apache.commons.math.transform.FastCosineTransformer\n+   { \"{0} is not a power of 2 plus one\",\n+     \"{0} n''est pas une puissance de 2 plus un\" },\n+\n+   // org.apache.commons.math.transform.FastSineTransformer\n+   { \"first element is not 0: {0}\",\n+     \"le premier \\u00e9l\\u00e9ment n''est pas nul : {0}\" },\n+\n    // org.apache.commons.math.util.OpenIntToDoubleHashMap\n    { \"map has been modified while iterating\",\n      \"la table d''adressage a \\u00e9t\\u00e9 modifi\\u00e9e pendant l''it\\u00e9ration\" },\n--- a/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import java.io.Serializable;\n-import org.apache.commons.math.analysis.*;\n-import org.apache.commons.math.complex.*;\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.complex.Complex;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  * @since 1.2\n  */\n-public class FastCosineTransformer implements Serializable {\n+public class FastCosineTransformer implements RealTransformer {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = -7673941545134707766L;\n+    private static final long serialVersionUID = -831323620109865380L;\n \n     /**\n      * Construct a default transformer.\n     /**\n      * Transform the given real data set.\n      * <p>\n-     * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n-     *                        \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n+     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(double f[]) throws MathException,\n-        IllegalArgumentException {\n-\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[]) throws IllegalArgumentException {\n         return fct(f);\n     }\n \n     /**\n      * Transform the given real function, sampled on the given interval.\n      * <p>\n-     * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n-     *                        \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n+     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the function to be sampled and transformed\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n-\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         return fct(data);\n     }\n     /**\n      * Transform the given real data set.\n      * <p>\n-     * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n+     * The formula is F<sub>n</sub> = \\sqrt{1/2N} [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws IllegalArgumentException {\n \n         double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));\n         return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n     /**\n      * Transform the given real function, sampled on the given interval.\n      * <p>\n-     * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n+     * The formula is F<sub>n</sub> = \\sqrt{1/2N} [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      *\n      * </p>\n      * \n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(UnivariateRealFunction f,\n+                               double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         double scaling_coefficient = Math.sqrt(2.0 / (n-1));\n     /**\n      * Inversely transform the given real data set.\n      * <p>\n-     * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n-     *                        (2/N) \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n+     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws IllegalArgumentException {\n \n         double scaling_coefficient = 2.0 / (f.length - 1);\n         return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n     /**\n      * Inversely transform the given real function, sampled on the given interval.\n      * <p>\n-     * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n-     *                        (2/N) \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n+     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the function to be sampled and inversely transformed\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(UnivariateRealFunction f,\n+                                     double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         double scaling_coefficient = 2.0 / (n - 1);\n     /**\n      * Inversely transform the given real data set.\n      * <p>\n-     * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n+     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n-\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws IllegalArgumentException {\n         return transform2(f);\n     }\n \n     /**\n      * Inversely transform the given real function, sampled on the given interval.\n      * <p>\n-     * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n+     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n      * \n      * @param f the function to be sampled and inversely transformed\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(UnivariateRealFunction f,\n+                                      double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         return transform2(f, min, max, n);\n     }\n      *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    protected double[] fct(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fct(double f[])\n+        throws IllegalArgumentException {\n \n         double A, B, C, F1, x[], F[] = new double[f.length];\n \n         int N = f.length - 1;\n         if (!FastFourierTransformer.isPowerOf2(N)) {\n-            throw new IllegalArgumentException\n-                (\"Number of samples not power of 2 plus one: \" + f.length);\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2 plus one\",\n+                                                                      new Object[] { f.length });\n         }\n         if (N == 1) {       // trivial case\n             F[0] = 0.5 * (f[0] + f[1]);\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n \n      * \n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform(double f[]) throws MathException,\n-        IllegalArgumentException {\n-\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(double f[])\n+        throws IllegalArgumentException {\n         return fft(f, false);\n     }\n \n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n-\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(UnivariateRealFunction f,\n+                               double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n         double data[] = sample(f, min, max, n);\n         return fft(data, false);\n     }\n      * \n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform(Complex f[]) throws MathException,\n-        IllegalArgumentException {\n-\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(Complex f[])\n+        throws IllegalArgumentException {\n         computeOmega(f.length);\n         return fft(f);\n     }\n      * \n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(double f[])\n+        throws IllegalArgumentException {\n \n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n         return scaleArray(fft(f, false), scaling_coefficient);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(UnivariateRealFunction f,\n+                                double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / Math.sqrt(n);\n      * \n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] transform2(Complex f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(Complex f[])\n+        throws IllegalArgumentException {\n \n         computeOmega(f.length);\n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(double f[])\n+        throws IllegalArgumentException {\n \n         double scaling_coefficient = 1.0 / f.length;\n         return scaleArray(fft(f, true), scaling_coefficient);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(UnivariateRealFunction f,\n+                                      double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / n;\n      * \n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform(Complex f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(Complex f[])\n+        throws IllegalArgumentException {\n \n         computeOmega(-f.length);    // pass negative argument\n         double scaling_coefficient = 1.0 / f.length;\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(double f[])\n+        throws IllegalArgumentException {\n \n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n         return scaleArray(fft(f, true), scaling_coefficient);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(UnivariateRealFunction f,\n+                                       double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n         double scaling_coefficient = 1.0 / Math.sqrt(n);\n      * \n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] inversetransform2(Complex f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(Complex f[])\n+        throws IllegalArgumentException {\n \n         computeOmega(-f.length);    // pass negative argument\n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n      * @param f the real data array to be transformed\n      * @param isInverse the indicator of forward or inverse transform\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    protected Complex[] fft(double f[], boolean isInverse) throws\n-        MathException, IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(double f[], boolean isInverse)\n+        throws IllegalArgumentException {\n \n         verifyDataSet(f);\n         Complex F[] = new Complex[f.length];\n      *\n      * @param data the complex data array to be transformed\n      * @return the complex transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    protected Complex[] fft(Complex data[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(Complex data[])\n+        throws IllegalArgumentException {\n \n         int i, j, k, m, N = data.length;\n         Complex A, B, C, D, E, F, z, f[] = new Complex[N];\n      * @param n the integer passed in\n      * @throws IllegalArgumentException if n = 0\n      */\n-    protected void computeOmega(int n) throws IllegalArgumentException {\n+    protected void computeOmega(int n)\n+        throws IllegalArgumentException {\n         if (n == 0) {\n-            throw new IllegalArgumentException\n-                (\"Cannot compute 0-th root of unity, indefinite result.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot compute 0-th root of unity, indefinite result\",\n+                                                                      null);\n         }\n         // avoid repetitive calculations\n         if (n == omegaCount) { return; }\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the samples array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public static double[] sample(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public static double[] sample(UnivariateRealFunction f,\n+                                  double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         if (n <= 0) {\n-            throw new IllegalArgumentException(\"Number of samples not positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"number of sample is not positive: {0}\",\n+                                                                      new Object[] { n });\n         }\n         verifyInterval(min, max);\n \n      */\n     public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n         if (!isPowerOf2(d.length)) {\n-            throw new IllegalArgumentException\n-                (\"Number of samples not power of 2, consider padding for fix.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2, consider padding for fix\",\n+                                                                      new Object[] { d.length });\n         }       \n     }\n \n      */\n     public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n         if (!isPowerOf2(o.length)) {\n-            throw new IllegalArgumentException\n-                (\"Number of samples not power of 2, consider padding for fix.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2, consider padding for fix\",\n+                                                                      new Object[] { o.length });\n         }       \n     }\n \n      * @param upper upper endpoint\n      * @throws IllegalArgumentException if not interval\n      */\n-    public static void verifyInterval(double lower, double upper) throws\n-        IllegalArgumentException {\n+    public static void verifyInterval(double lower, double upper)\n+        throws IllegalArgumentException {\n \n         if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"Endpoints do not specify an interval: [\" + lower +\n-                \", \" + upper + \"]\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"endpoints do not specify an interval: [{0}, {1}]\",\n+                                                                     new Object[] { lower, upper });\n         }       \n     }\n     \n      * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n      * @param forward inverseTransform2 is preformed if this is false\n      * @return transform of mdca as a Multi-Dimensional Complex Array id est Complex[][][][]\n-     * @throws MathException if any dimension is not a power of two\n-     */\n-    public Object mdfft(Object mdca, boolean forward) throws MathException {\n+     * @throws IllegalArgumentException if any dimension is not a power of two\n+     */\n+    public Object mdfft(Object mdca, boolean forward)\n+        throws IllegalArgumentException {\n         MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n                 new MultiDimensionalComplexMatrix(mdca).clone();\n         int[] dimensionSize = mdcm.getDimensionSizes();\n      * @param forward inverseTransform2 is preformed if this is false\n      * @param d index of the dimension to process\n      * @param subVector recursion subvector\n-     * @throws MathException if any dimension is not a power of two\n+     * @throws IllegalArgumentException if any dimension is not a power of two\n      */\n     private void mdfft(MultiDimensionalComplexMatrix mdcm, boolean forward,\n-                         int d, int[] subVector) throws MathException {\n+                       int d, int[] subVector)\n+        throws IllegalArgumentException {\n         int[] dimensionSize = mdcm.getDimensionSizes();\n         //if done\n         if (subVector.length == dimensionSize.length) {\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n      */\n-    private class MultiDimensionalComplexMatrix implements Serializable,\n-                                                           Cloneable {\n+    private class MultiDimensionalComplexMatrix\n+        implements Serializable, Cloneable {\n \n         /** Serializable version identifier. */\n         private static final long serialVersionUID =  0x564FCD47EBA8169BL;\n          * Get a matrix element.\n          * @param vector indices of the element\n          * @return matrix element\n+         * @exception IllegalArgumentException if dimensions do not match\n          */\n-        public Complex get(int... vector) {\n-            if ((vector == null && dimensionSize.length > 1) ||\n-                (vector != null && vector.length != dimensionSize.length)) {\n-                throw new IllegalArgumentException(\"Number of dimensions must match\");\n+        public Complex get(int... vector)\n+            throws IllegalArgumentException {\n+            if (vector == null && dimensionSize.length > 1) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n+                                                                          new Object[] { 0, dimensionSize.length });\n+            }\n+            if (vector != null && vector.length != dimensionSize.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n+                                                                          new Object[] {\n+                                                                              vector.length,\n+                                                                              dimensionSize.length\n+                                                                          });\n             }\n             \n             Object lastDimension = multiDimensionalComplexArray;\n          * @param magnitude magnitude of the element\n          * @param vector indices of the element\n          * @return the previous value\n+         * @exception IllegalArgumentException if dimensions do not match\n          */\n-        public Complex set(Complex magnitude, int... vector) {\n-            if ((vector == null && dimensionSize.length > 1) ||\n-                (vector != null && vector.length != dimensionSize.length)) {\n-                throw new IllegalArgumentException(\"Number of dimensions must match\");\n+        public Complex set(Complex magnitude, int... vector)\n+            throws IllegalArgumentException {\n+            if (vector == null && dimensionSize.length > 1) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n+                                                                          new Object[] { 0, dimensionSize.length });\n+            }\n+            if (vector != null && vector.length != dimensionSize.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"some dimensions don't math: {0} != {1}\",\n+                                                                          new Object[] {\n+                                                                              vector.length,\n+                                                                              dimensionSize.length\n+                                                                          });\n             }\n             \n             Object lastDimension = multiDimensionalComplexArray;\n--- a/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import java.io.Serializable;\n-\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n  * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class FastHadamardTransformer implements Serializable {\n+public class FastHadamardTransformer implements RealTransformer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 5044269102877526860L;\n+    private static final long serialVersionUID = -710169279109099264L;\n \n-    /**\n-     * Wrapper method for fht() for double vectors\n-     *  \n-     * @param x input vector\n-     * @return y output vector\n-     * @throws IllegalArgumentException\n-     */\n-    public double[] transform(double x[]) throws IllegalArgumentException {\n-        return fht(x);\n+    /** {@inheritDoc} */\n+    public double[] transform(double f[]) throws IllegalArgumentException {\n+        return fht(f);\n     }\n \n+    /** {@inheritDoc} */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        return fht(FastFourierTransformer.sample(f, min, max, n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] inversetransform(double f[])\n+    throws IllegalArgumentException {\n+        return fht(f);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] inversetransform(UnivariateRealFunction f,\n+                                     double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        return fht(FastFourierTransformer.sample(f, min, max, n));\n+    }\n \n     /**\n      * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n     protected double[] fht(double x[]) throws IllegalArgumentException {\n \n         // n is the row count of the input vector x\n-        int n = x.length;\n+        final int n     = x.length;\n+        final int halfN = n / 2;\n \n         // n has to be of the form n = 2^p !!\n-        int p    = 0;\n-        int twoP = 1;\n-        while (twoP < n) {\n-            ++p;\n-            twoP *= 2;\n-        }\n-        if (n != twoP) {\n+        if (!FastFourierTransformer.isPowerOf2(n)) {\n             throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2\",\n                                                                       new Object[] { n });\n         }\n         double[] yCurrent  = x.clone();\n \n         // iterate from left to right (column)\n-        for (int j = 0; j < p; j++) {\n+        for (int j = 1; j < n; j <<= 1) {\n \n             // switch columns\n             final double[] yTmp = yCurrent;\n             yPrevious = yTmp;\n \n             // iterate from top to bottom (row)\n-            for (int i = 0; i < n; i++) { \n-                if (i < n / 2) {\n-                    // D<sub>top</sub>\n-                    // The top part works with addition\n-                    yCurrent[i] = yPrevious[i*2] + yPrevious[i*2 +1];\n-                } else {\n-                    // D<sub>bottom</sub>   \n-                    // The bottom part works with subtraction\n-                    yCurrent[i] = yPrevious[(i-n/2)*2] - yPrevious[(i-n/2)*2 +1];\n-                }\n+            for (int i = 0; i < halfN; ++i) { \n+                // D<sub>top</sub>\n+                // The top part works with addition\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n+            }\n+            for (int i = halfN; i < n; ++i) { \n+                // D<sub>bottom</sub>   \n+                // The bottom part works with subtraction\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n             }\n         }\n \n--- a/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import java.io.Serializable;\n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.complex.*;\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class FastSineTransformer implements Serializable {\n+public class FastSineTransformer implements RealTransformer {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = -478002039949390854L;\n+    private static final long serialVersionUID = -7557024407476823001L;\n \n     /**\n      * Construct a default transformer.\n      * \n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(double f[]) throws MathException,\n-        IllegalArgumentException {\n-\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[])\n+        throws IllegalArgumentException {\n         return fst(f);\n     }\n \n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * \n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws IllegalArgumentException {\n \n         double scaling_coefficient = Math.sqrt(2.0 / f.length);\n         return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform2(\n         UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws IllegalArgumentException {\n \n         double scaling_coefficient = 2.0 / f.length;\n         return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n      * \n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform2(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws IllegalArgumentException {\n \n         return transform2(f);\n     }\n      * @param max the upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inversetransform2(\n-        UnivariateRealFunction f, double min, double max, int n)\n-        throws MathException, IllegalArgumentException {\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n         return transform2(f, min, max, n);\n     }\n      *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n-     * @throws MathException if any math-related errors occur\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    protected double[] fst(double f[]) throws MathException,\n-        IllegalArgumentException {\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fst(double f[]) throws IllegalArgumentException {\n \n         double A, B, x[], F[] = new double[f.length];\n \n         FastFourierTransformer.verifyDataSet(f);\n         if (f[0] != 0.0) {\n-            throw new IllegalArgumentException\n-                (\"The first element is not zero: \" + f[0]);\n+            throw MathRuntimeException.createIllegalArgumentException(\"first element is not 0: {0}\",\n+                                                                      new Object[] { f[0] });\n         }\n         int N = f.length;\n         if (N == 1) {       // trivial case\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/transform/RealTransformer.java\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Interface for one-dimensional data sets transformations producing real results.\n+ * <p>Such transforms include {@link FastSineTransformer sine transform},\n+ * {@link FastCosineTransformer cosine transform} or {@link\n+ * FastHadamardTransformer Hadamard transform}. {@link FastFourierTransformer\n+ * Fourier transform} is of a different kind and does not implement this\n+ * interface since it produces {@link Complex complex} results instead of real\n+ * ones.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealTransformer extends Serializable {\n+\n+    /**\n+     * Transform the given real data set.\n+     * @param f the real data array to be transformed (signal)\n+     * @return the real transformed array (spectrum)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] transform(double f[])\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] transform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * @param f the real data array to be inversely transformed (spectrum)\n+     * @return the real inversely transformed array (signal)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public abstract double[] inversetransform(double f[])\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}", "timestamp": 1230487768, "metainfo": ""}