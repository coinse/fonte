{"sha": "012b2e98493e90800918569bf51123e860578eb2", "log": "Made intercept/noIntercept configurable in multiple regression classes.  JIRA: MATH-409.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n     /** Y sample data. */\n     protected RealVector Y;\n \n+    /** Whether or not the regression model includes an intercept.  True means no intercept. */\n+    private boolean noIntercept = false;\n+\n+    /**\n+     * @return true if the model has no intercept term; false otherwise\n+     */\n+    public boolean isNoIntercept() {\n+        return noIntercept;\n+    }\n+\n+    /**\n+     * @param noIntercept true means the model is to be estimated without an intercept term\n+     */\n+    public void setNoIntercept(boolean noIntercept) {\n+        this.noIntercept = noIntercept;\n+    }\n+\n     /**\n      * <p>Loads model x and y sample data from a flat input array, overriding any previous sample.\n      * </p>\n      * </pre>\n      * </p>\n      * <p>Note that there is no need to add an initial unitary column (column of 1's) when\n-     * specifying a model including an intercept term.\n+     * specifying a model including an intercept term.  If {@link #isNoIntercept()} is <code>true</code>,\n+     * the X matrix will be created without an initial column of \"1\"s; otherwise this column will\n+     * be added.\n      * </p>\n      * <p>Throws IllegalArgumentException if any of the following preconditions fail:\n      * <ul><li><code>data</code> cannot be null</li>\n                     LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS);\n         }\n         double[] y = new double[nobs];\n-        double[][] x = new double[nobs][nvars + 1];\n+        final int cols = noIntercept ? nvars: nvars + 1;\n+        double[][] x = new double[nobs][cols];\n         int pointer = 0;\n         for (int i = 0; i < nobs; i++) {\n             y[i] = data[pointer++];\n-            x[i][0] = 1.0d;\n-            for (int j = 1; j < nvars + 1; j++) {\n+            if (!noIntercept) {\n+                x[i][0] = 1.0d;\n+            }\n+            for (int j = noIntercept ? 0 : 1; j < cols; j++) {\n                 x[i][j] = data[pointer++];\n             }\n         }\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NO_DATA);\n         }\n-        final int nVars = x[0].length;\n-        final double[][] xAug = new double[x.length][nVars + 1];\n-        for (int i = 0; i < x.length; i++) {\n-            if (x[i].length != nVars) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        x[i].length, nVars);\n+        if (noIntercept) {\n+            this.X = new Array2DRowRealMatrix(x, true);\n+        } else { // Augment design matrix with initial unitary column\n+            final int nVars = x[0].length;\n+            final double[][] xAug = new double[x.length][nVars + 1];\n+            for (int i = 0; i < x.length; i++) {\n+                if (x[i].length != nVars) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n+                            x[i].length, nVars);\n+                }\n+                xAug[i][0] = 1.0d;\n+                System.arraycopy(x[i], 0, xAug[i], 1, nVars);\n             }\n-            xAug[i][0] = 1.0d;\n-            System.arraycopy(x[i], 0, xAug[i], 1, nVars);\n-        }\n-        this.X = new Array2DRowRealMatrix(xAug, false);\n+            this.X = new Array2DRowRealMatrix(xAug, false);\n+        }\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.stat.StatUtils;\n import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n \n /**\n  * <p>Implements ordinary least squares (OLS) to estimate the parameters of a\n  * multiple linear regression model.</p>\n  *\n- * <p>OLS assumes the covariance matrix of the error to be diagonal and with\n- * equal variance.</p>\n- * <p>\n- * u ~ N(0, &sigma;<sup>2</sup>I)\n- * </p>\n- *\n- * <p>The regression coefficients, b, satisfy the normal equations:\n- * <p>\n- * X<sup>T</sup> X b = X<sup>T</sup> y\n- * </p>\n+ * <p>The regression coefficients, <code>b</code>, satisfy the normal equations:\n+ * <pre><code> X<sup>T</sup> X b = X<sup>T</sup> y </code></pre></p>\n  *\n  * <p>To solve the normal equations, this implementation uses QR decomposition\n- * of the X matrix. (See {@link QRDecompositionImpl} for details on the\n- * decomposition algorithm.)\n- * </p>\n- * <p>X<sup>T</sup>X b = X<sup>T</sup> y <br/>\n- * (QR)<sup>T</sup> (QR) b = (QR)<sup>T</sup>y <br/>\n- * R<sup>T</sup> (Q<sup>T</sup>Q) R b = R<sup>T</sup> Q<sup>T</sup> y <br/>\n- * R<sup>T</sup> R b = R<sup>T</sup> Q<sup>T</sup> y <br/>\n- * (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> R b = (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> Q<sup>T</sup> y <br/>\n- * R b = Q<sup>T</sup> y\n- * </p>\n- * Given Q and R, the last equation is solved by back-substitution.</p>\n+ * of the <code>X</code> matrix. (See {@link QRDecompositionImpl} for details on the\n+ * decomposition algorithm.) The <code>X</code> matrix, also known as the <i>design matrix,</i>\n+ * has rows corresponding to sample observations and columns corresponding to independent\n+ * variables.  When the model is estimated using an intercept term (i.e. when\n+ * {@link #isNoIntercept() isNoIntercept} is false as it is by default), the <code>X</code>\n+ * matrix includes an initial column identically equal to 1.  We solve the normal equations\n+ * as follows:\n+ * <pre><code> X<sup>T</sup>X b = X<sup>T</sup> y\n+ * (QR)<sup>T</sup> (QR) b = (QR)<sup>T</sup>y\n+ * R<sup>T</sup> (Q<sup>T</sup>Q) R b = R<sup>T</sup> Q<sup>T</sup> y\n+ * R<sup>T</sup> R b = R<sup>T</sup> Q<sup>T</sup> y\n+ * (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> R b = (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> Q<sup>T</sup> y\n+ * R b = Q<sup>T</sup> y </code></pre></p>\n+ *\n+ * <p>Given <code>Q</code> and <code>R</code>, the last equation is solved by back-substitution.</p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n     }\n \n     /**\n-     * Returns the sum of squared deviations of Y from its mean.\n-     *\n-     * @return total sum of squares\n+     * <p>Returns the sum of squared deviations of Y from its mean.</p>\n+     *\n+     * <p>If the model has no intercept term, <code>0</code> is used for the\n+     * mean of Y - i.e., what is returned is the sum of the squared Y values.</p>\n+     *\n+     * <p>The value returned by this method is the SSTO value used in\n+     * the {@link #calculateRSquared() R-squared} computation.</p>\n+     *\n+     * @return SSTO - the total sum of squares\n+     * @see #isNoIntercept()\n      */\n     public double calculateTotalSumOfSquares() {\n-        return new SecondMoment().evaluate(Y.getData());\n+        if (isNoIntercept()) {\n+            return StatUtils.sumSq(Y.getData());\n+        } else {\n+            return new SecondMoment().evaluate(Y.getData());\n+        }\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns the adjusted R-squared statistic, defined by the formula <pre>\n+     * <p>Returns the adjusted R-squared statistic, defined by the formula <pre>\n      * R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)]\n      * </pre>\n      * where SSR is the {@link #calculateResidualSumOfSquares() sum of squared residuals},\n      * SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}, n is the number\n-     * of observations and p is the number of parameters estimated (including the intercept).\n+     * of observations and p is the number of parameters estimated (including the intercept).</p>\n+     *\n+     * <p>If the regression is estimated without an intercept term, what is returned is <pre>\n+     * <code> 1 - (1 - {@link #calculateRSquared()}) * (n / (n - p)) </code>\n+     * </pre></p>\n      *\n      * @return adjusted R-Squared statistic\n+     * @see #isNoIntercept()\n      */\n     public double calculateAdjustedRSquared() {\n         final double n = X.getRowDimension();\n-        return 1 - (calculateResidualSumOfSquares() * (n - 1)) /\n-            (calculateTotalSumOfSquares() * (n - X.getColumnDimension()));\n+        if (isNoIntercept()) {\n+            return 1 - (1 - calculateRSquared()) * (n / (n - X.getColumnDimension()));\n+        } else {\n+            return 1 - (calculateResidualSumOfSquares() * (n - 1)) /\n+                (calculateTotalSumOfSquares() * (n - X.getColumnDimension()));\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n-     * <p>This implementation computes and caches the QR decomposition of the X matrix once it is successfully loaded.</p>\n+     * <p>This implementation computes and caches the QR decomposition of the X matrix\n+     * once it is successfully loaded.</p>\n      */\n     @Override\n     protected void newXSampleData(double[][] x) {\n     }\n \n     /**\n-     * <p>Calculates the variance on the beta by OLS.\n+     * <p>Calculates the variance-covariance matrix of the regression parameters.\n      * </p>\n      * <p>Var(b) = (X<sup>T</sup>X)<sup>-1</sup>\n      * </p>\n      * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n      * R included, where p = the length of the beta vector.</p>\n      *\n-     * @return The beta variance\n+     * @return The beta variance-covariance matrix\n      */\n     @Override\n     protected RealMatrix calculateBetaVariance() {\n--- a/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n         regression.newYSampleData(y);\n         assertEquals(flatX, regression.X);\n         assertEquals(flatY, regression.Y);\n+        \n+        // No intercept\n+        regression.setNoIntercept(true);\n+        regression.newSampleData(design, 4, 3);\n+        flatX = regression.X.copy();\n+        flatY = regression.Y.copy();\n+        regression.newXSampleData(x);\n+        regression.newYSampleData(y);\n+        assertEquals(flatX, regression.X);\n+        assertEquals(flatY, regression.Y);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n--- a/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n             70551,116.9,554894,4007,2827,130081,1962\n         };\n \n-        // Transform to Y and X required by interface\n-        int nobs = 16;\n-        int nvars = 6;\n+        final int nobs = 16;\n+        final int nvars = 6;\n \n         // Estimate the model\n         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n         assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);\n         \n         checkVarianceConsistency(model);\n+        \n+        // Estimate model without intercept\n+        model.setNoIntercept(true);\n+        model.newSampleData(design, nobs, nvars);\n+        \n+        // Check expected beta values from R\n+        betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat,\n+          new double[]{-52.99357013868291, 0.07107319907358,\n+                -0.42346585566399,-0.57256866841929,\n+                -0.41420358884978, 48.41786562001326}, 1E-11); \n+        \n+        // Check standard errors from R\n+        errors = model.estimateRegressionParametersStandardErrors();\n+        TestUtils.assertEquals(new double[] {129.54486693117232, 0.03016640003786,\n+                0.41773654056612, 0.27899087467676, 0.32128496193363,\n+                17.68948737819961}, errors, 1E-11);\n+        \n+        // Check expected residuals from R\n+        residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                279.90274927293092, -130.32465380836874, 90.73228661967445, -401.31252201634948,\n+                -440.46768772620027, -543.54512853774793, 201.32111639536299, 215.90889365977932,\n+                73.09368242049943, 913.21694494481869, 424.82484953610174, -8.56475876776709,\n+                -361.32974610842876, 27.34560497213464, 151.28955976355002, -492.49937355336846},\n+                      1E-10);\n+        \n+        // Check regression standard error against R\n+        assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);\n+        \n+        // Check R-Square statistics against R\n+        assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);\n+        assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);\n+         \n     }\n \n     /**\n         model.newSampleData(design, nobs, nvars);\n \n         // Check expected beta values from R\n-        final double[] betaHat = model.estimateRegressionParameters();\n+        double[] betaHat = model.estimateRegressionParameters();\n         TestUtils.assertEquals(betaHat,\n                 new double[]{91.05542390271397,\n                 -0.22064551045715,\n                  0.12441843147162}, 1E-12);\n \n         // Check expected residuals from R\n-        final double[] residuals = model.estimateResiduals();\n+        double[] residuals = model.estimateResiduals();\n         TestUtils.assertEquals(residuals, new double[]{\n                 7.1044267859730512,1.6580347433531366,\n                 4.6944952770029644,8.4548022690166160,13.6547432343186212,\n                 1E-12);\n \n         // Check standard errors from R\n-        final double[] errors = model.estimateRegressionParametersStandardErrors();\n+        double[] errors = model.estimateRegressionParametersStandardErrors();\n         TestUtils.assertEquals(new double[] {6.94881329475087,\n                 0.07360008972340,\n                 0.27410957467466,\n         assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);\n         \n         checkVarianceConsistency(model);\n+        \n+        // Estimate the model with no intercept\n+        model = new OLSMultipleLinearRegression();\n+        model.setNoIntercept(true);\n+        model.newSampleData(design, nobs, nvars);\n+\n+        // Check expected beta values from R\n+        betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat,\n+                new double[]{0.52191832900513,\n+                  2.36588087917963,\n+                  -0.94770353802795, \n+                  0.30851985863609}, 1E-12);\n+\n+        // Check expected residuals from R\n+        residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                44.138759883538249, 27.720705122356215, 35.873200836126799, \n+                34.574619581211977, 26.600168342080213, 15.074636243026923, -12.704904871199814,\n+                1.497443824078134, 2.691972687079431, 5.582798774291231, -4.422986561283165, \n+                -9.198581600334345, 4.481765170730647, 2.273520207553216, -22.649827853221336,\n+                -17.747900013943308, 20.298314638496436, 6.861405135329779, -8.684712790954924,\n+                -10.298639278062371, -9.896618896845819, 4.568568616351242, -15.313570491727944,\n+                -13.762961360873966, 7.156100301980509, 16.722282219843990, 26.716200609071898,\n+                -1.991466398777079, -2.523342564719335, 9.776486693095093, -5.297535127628603,\n+                -16.639070567471094, -10.302057295211819, -23.549487860816846, 1.506624392156384,\n+                -17.939174438345930, 13.105792202765040, -1.943329906928462, -1.516005841666695,\n+                -0.759066561832886, 20.793137744128977, -2.485236153005426, 27.588238710486976,\n+                2.658333257106881, -15.998337823623046, -5.550742066720694, -14.219077806826615},\n+                1E-12);\n+\n+        // Check standard errors from R\n+        errors = model.estimateRegressionParametersStandardErrors();\n+        TestUtils.assertEquals(new double[] {0.10470063765677, 0.41684100584290,\n+                0.43370143099691, 0.07694953606522}, errors, 1E-10);\n+        \n+        // Check regression standard error against R\n+        assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);\n+        \n+        // Check R-Square statistics against R\n+        assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);\n+        assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);\n     }\n \n     /**\n         regression.newYSampleData(y);\n         assertEquals(combinedX, regression.X);\n         assertEquals(combinedY, regression.Y);\n+        \n+        // No intercept\n+        regression.setNoIntercept(true);\n+        regression.newSampleData(y, x);\n+        combinedX = regression.X.copy();\n+        combinedY = regression.Y.copy();\n+        regression.newXSampleData(x);\n+        regression.newYSampleData(y);\n+        assertEquals(combinedX, regression.X);\n+        assertEquals(combinedY, regression.Y);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)", "timestamp": 1284343302, "metainfo": ""}