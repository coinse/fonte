{"sha": "e91dec76a00e05c451496bdcc7029a626ac684d7", "log": "Implemented alternative algorithm for generating poisson deviates when the mean is large. JIRA: MATH-294.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n     /**\n      * {@inheritDoc}\n      * <p>\n-     * <strong>Algorithm Description</strong>: For small means, uses simulation\n-     * of a Poisson process using Uniform deviates, as described <a\n-     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-     * </p>\n-     * <p>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n-     * </p>\n-     *\n-     * <p>\n-     * For large means, uses a reject method as described in <a\n-     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n-     * Variate Generation</a>\n-     * </p>\n-     *\n-     * <p>\n-     * References:\n-     * <ul>\n-     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n-     * New York, NY. Springer-Verlag</li>\n-     * </ul>\n-     * </p>\n-     *\n-     * @param mean\n-     *            mean of the Poisson distribution.\n+     * <strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>\n+     *\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n+     *\n+     * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      */\n     public long nextPoisson(double mean) {\n \n         final RandomGenerator generator = getRan();\n \n-        double pivot = 6.0;\n+        final double pivot = 40.0d;\n         if (mean < pivot) {\n             double p = Math.exp(-mean);\n             long n = 0;\n             }\n             return n;\n         } else {\n-            double mu = Math.floor(mean);\n-            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n-            // between 6\n-            // and mean\n-            double mu2delta = 2.0 * mu + delta;\n-            double muDeltaHalf = mu + delta / 2.0;\n-            double logMeanMu = Math.log(mean / mu);\n-\n-            double muFactorialLog = MathUtils.factorialLog((int) mu);\n-\n-            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n-            double c2 = c1 +\n-                        Math.sqrt(Math.PI * muDeltaHalf /\n-                                  (2.0 * Math.exp(1.0 / mu2delta)));\n-            double c3 = c2 + 2.0;\n-            double c4 = c3 + Math.exp(1.0 / 78.0);\n-            double c = c4 + 2.0 / delta * mu2delta *\n-                       Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n-\n-            double y = 0.0;\n-            double x = 0.0;\n-            double w = Double.POSITIVE_INFINITY;\n-\n-            boolean accept = false;\n-            while (!accept) {\n-                double u = nextUniform(0.0, c);\n-                double e = nextExponential(mean);\n-\n-                if (u <= c1) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n-                    x = Math.floor(y);\n-                    w = -z * z / 2.0 - e - x * logMeanMu;\n-                    if (x < -mu) {\n-                        w = Double.POSITIVE_INFINITY;\n+            final double lambda = Math.floor(mean);\n+            final double lambdaFractional = mean - lambda;\n+            final double logLambda = Math.log(lambda);\n+            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n+            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n+            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));\n+            final double halfDelta = delta / 2;\n+            final double twolpd = 2 * lambda + delta;\n+            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);\n+            final double aSum = a1 + a2 + 1;\n+            final double p1 = a1 / aSum;\n+            final double p2 = a2 / aSum;\n+            final double c1 = 1 / (8 * lambda);\n+\n+            double x = 0;\n+            double y = 0;\n+            double v = 0;\n+            int a = 0;\n+            double t = 0;\n+            double qr = 0;\n+            double qa = 0;\n+            for (;;) {\n+                final double u = nextUniform(0.0, 1);\n+                if (u <= p1) {\n+                    final double n = nextGaussian(0d, 1d);\n+                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;\n+                    if (x > delta || x < -lambda) {\n+                        continue;\n                     }\n-                } else if (c1 < u && u <= c2) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n-                    x = Math.ceil(y);\n-                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n-                    if (x > delta) {\n-                        w = Double.POSITIVE_INFINITY;\n+                    y = x < 0 ? Math.floor(x) : Math.ceil(x);\n+                    final double e = nextExponential(1d);\n+                    v = -e - (n * n / 2) + c1;\n+                } else {\n+                    if (u > p1 + p2) {\n+                        y = lambda;\n+                        break;\n+                    } else {\n+                        x = delta + (twolpd / delta) * nextExponential(1d);\n+                        y = Math.ceil(x);\n+                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n                     }\n-                } else if (c2 < u && u <= c3) {\n-                    x = 0.0;\n-                    w = -e;\n-                } else if (c3 < u && u <= c4) {\n-                    x = 1.0;\n-                    w = -e - logMeanMu;\n-                } else if (c4 < u) {\n-                    double v = nextExponential(mean);\n-                    y = delta + v * 2.0 / delta * mu2delta;\n-                    x = Math.ceil(y);\n-                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n                 }\n-                accept = w <= x * Math.log(mu) -\n-                         MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n+                a = x < 0 ? 1 : 0;\n+                t = y * (y + 1) / (2 * lambda);\n+                if (v < -t && a == 0) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n+                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n+                if (v < qa) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                if (v > qr) {\n+                    continue;\n+                }\n+                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                    y = lambda + y;\n+                    break;\n+                }\n             }\n-            // cast to long is acceptable because both x and mu are whole\n-            // numbers.\n-            return (long) (x + mu);\n+            return y2 + (long) y;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n \t}\n \t\n \tpublic void testNextPoissionConistency() throws Exception {\n-\t    // TODO: once MATH-294 is resolved, increase upper bounds on test means\n-\t    for (int i = 1; i < 6; i++) {\n+\t    // Small integral means\n+\t    for (int i = 1; i < 100; i++) {\n \t        checkNextPoissonConsistency(i);\n \t    }\n+\t    // non-integer means\n \t    RandomData randomData = new RandomDataImpl();\n \t    for (int i = 1; i < 10; i++) {\n-\t        checkNextPoissonConsistency(randomData.nextUniform(1, 6));\n-\t    }\n+\t        checkNextPoissonConsistency(randomData.nextUniform(1, 1000));\n+\t    }\n+\t    // large means \n+\t    // TODO: When MATH-282 is resolved, s/3000/10000 below\n+\t    for (int i = 1; i < 10; i++) {\n+            checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));\n+        }\n \t}\n \t\n \t/** \n \t        msgBuffer.append(alpha);\n \t        msgBuffer.append(\".\");\n \t        fail(msgBuffer.toString());\n-\t    }\n-\t    \n-\t}\n-\n-\tpublic void testNextPoissonLargeMean() {\n-\t\tfor (int i = 0; i < 1000; i++) {\n-\t\t\tlong n = randomData.nextPoisson(1500.0);\n-\t\t\tassertTrue(0 <= n);\n-\t\t}\n+\t    }  \n \t}\n \n \t/** test dispersion and failute modes for nextHex() */", "timestamp": 1255313046, "metainfo": ""}