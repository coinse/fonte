{"sha": "1ebdd87b932c75a1d34278bf381210ead9a48da2", "log": "Code cleanup: Moved all computations to the constructor, allowing the class to be immutable.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/GaussianFitter.java\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.fitting.CurveFitter;\n import org.apache.commons.math3.optimization.fitting.WeightedObservedPoint;\n+import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Fits points to a {@link\n      * based on the specified observed points.\n      */\n     public static class ParameterGuesser {\n-        /** Observed points. */\n-        private final WeightedObservedPoint[] observations;\n-        /** Resulting guessed parameters. */\n-        private double[] parameters;\n+        /** Normalization factor. */\n+        private final double norm;\n+        /** Mean. */\n+        private final double mean;\n+        /** Standard deviation. */\n+        private final double sigma;\n \n         /**\n          * Constructs instance with the specified observed points.\n          *\n-         * @param observations observed points upon which should base guess\n+         * @param observations Observed points from which to guess the\n+         * parameters of the Gaussian.\n+         * @throws NullArgumentException if {@code observations} is\n+         * {@code null}.\n+         * @throws NumberIsTooSmallException if there are less than 3\n+         * observations.\n          */\n         public ParameterGuesser(WeightedObservedPoint[] observations) {\n             if (observations == null) {\n             if (observations.length < 3) {\n                 throw new NumberIsTooSmallException(observations.length, 3, true);\n             }\n-            this.observations = observations.clone();\n-        }\n-\n-        /**\n-         * Guesses the parameters based on the observed points.\n-         *\n-         * @return the guessed parameters: norm, mean and sigma.\n+\n+            final WeightedObservedPoint[] sorted = sortObservations(observations);\n+            final double[] params = basicGuess(sorted);\n+\n+            norm = params[0];\n+            mean = params[1];\n+            sigma = params[2];\n+        }\n+\n+        /**\n+         * Gets an estimation of the parameters.\n+         *\n+         * @return the guessed parameters, in the following order:\n+         * <ul>\n+         *  <li>Normalization factor</li>\n+         *  <li>Mean</li>\n+         *  <li>Standard deviation</li>\n+         * </ul>\n          */\n         public double[] guess() {\n-            if (parameters == null) {\n-                parameters = basicGuess(observations);\n-            }\n-            return parameters.clone();\n+            return new double[] { norm, mean, sigma };\n+        }\n+\n+        /**\n+         * Sort the observations.\n+         *\n+         * @param unsorted Input observations.\n+         * @return the input observations, sorted.\n+         */\n+        private WeightedObservedPoint[] sortObservations(WeightedObservedPoint[] unsorted) {\n+            final WeightedObservedPoint[] observations = unsorted.clone();\n+            final Comparator<WeightedObservedPoint> cmp\n+                = new Comparator<WeightedObservedPoint>() {\n+                public int compare(WeightedObservedPoint p1,\n+                                   WeightedObservedPoint p2) {\n+                    if (p1 == null && p2 == null) {\n+                        return 0;\n+                    }\n+                    if (p1 == null) {\n+                        return -1;\n+                    }\n+                    if (p2 == null) {\n+                        return 1;\n+                    }\n+                    if (p1.getX() < p2.getX()) {\n+                        return -1;\n+                    }\n+                    if (p1.getX() > p2.getX()) {\n+                        return 1;\n+                    }\n+                    if (p1.getY() < p2.getY()) {\n+                        return -1;\n+                    }\n+                    if (p1.getY() > p2.getY()) {\n+                        return 1;\n+                    }\n+                    if (p1.getWeight() < p2.getWeight()) {\n+                        return -1;\n+                    }\n+                    if (p1.getWeight() > p2.getWeight()) {\n+                        return 1;\n+                    }\n+                    return 0;\n+                }\n+            };\n+\n+            Arrays.sort(observations, cmp);\n+            return observations;\n         }\n \n         /**\n          * Guesses the parameters based on the specified observed points.\n          *\n-         * @param points Observed points upon which should base guess.\n-         * @return the guessed parameters: norm, mean and sigma.\n+         * @param points Observed points, sorted.\n+         * @return the guessed parameters (normalization factor, mean and\n+         * sigma).\n          */\n         private double[] basicGuess(WeightedObservedPoint[] points) {\n-            Arrays.sort(points, createWeightedObservedPointComparator());\n-            double[] params = new double[3];\n-\n-            int maxYIdx = findMaxY(points);\n-            params[0] = points[maxYIdx].getY();\n-            params[1] = points[maxYIdx].getX();\n+            final int maxYIdx = findMaxY(points);\n+            final double n = points[maxYIdx].getY();\n+            final double m = points[maxYIdx].getX();\n \n             double fwhmApprox;\n             try {\n-                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n-                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n-                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n+                final double halfY = n + ((m - n) / 2);\n+                final double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n+                final double fwhmX2 = interpolateXAtY(points, maxYIdx, 1, halfY);\n                 fwhmApprox = fwhmX2 - fwhmX1;\n             } catch (OutOfRangeException e) {\n+                // TODO: Exceptions should not be used for flow control.\n                 fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n             }\n-            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n-\n-            return params;\n+            final double s = fwhmApprox / (2 * FastMath.sqrt(2 * FastMath.log(2)));\n+\n+            return new double[] { n, m, s };\n         }\n \n         /**\n          * specified Y.\n          *\n          * @param points Points to use for interpolation.\n-         * @param startIdx Index within points from which to start search for\n-         *  interpolation bounds points.\n-         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param startIdx Index within points from which to start the search for\n+         * interpolation bounds points.\n+         * @param idxStep Index step for searching interpolation bounds points.\n          * @param y Y value for which X should be determined.\n-         * @return the value of X at the specified Y.\n+         * @return the value of X for the specified Y.\n          * @throws ZeroException if {@code idxStep} is 0.\n          * @throws OutOfRangeException if specified {@code y} is not within the\n          * range of the specified {@code points}.\n          */\n         private double interpolateXAtY(WeightedObservedPoint[] points,\n-                                       int startIdx, int idxStep, double y)\n+                                       int startIdx,\n+                                       int idxStep,\n+                                       double y)\n             throws OutOfRangeException {\n             if (idxStep == 0) {\n                 throw new ZeroException();\n             }\n-            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n-            WeightedObservedPoint pointA = twoPoints[0];\n-            WeightedObservedPoint pointB = twoPoints[1];\n-            if (pointA.getY() == y) {\n-                return pointA.getX();\n-            }\n-            if (pointB.getY() == y) {\n-                return pointB.getX();\n-            }\n-            return pointA.getX() +\n-                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n-                    (pointB.getY() - pointA.getY()));\n+            final WeightedObservedPoint[] twoPoints\n+                = getInterpolationPointsForY(points, startIdx, idxStep, y);\n+            final WeightedObservedPoint p1 = twoPoints[0];\n+            final WeightedObservedPoint p2 = twoPoints[1];\n+            if (p1.getY() == y) {\n+                return p1.getX();\n+            }\n+            if (p2.getY() == y) {\n+                return p2.getX();\n+            }\n+            return p1.getX() + (((y - p1.getY()) * (p2.getX() - p1.getX())) /\n+                                (p2.getY() - p1.getY()));\n         }\n \n         /**\n          * range of the specified {@code points}.\n          */\n         private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n-                                                                   int startIdx, int idxStep, double y)\n+                                                                   int startIdx,\n+                                                                   int idxStep,\n+                                                                   double y)\n             throws OutOfRangeException {\n             if (idxStep == 0) {\n                 throw new ZeroException();\n             }\n             for (int i = startIdx;\n-                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n+                 idxStep < 0 ? i + idxStep >= 0 : i + idxStep < points.length;\n                  i += idxStep) {\n-                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n-                    return (idxStep < 0) ?\n-                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n-                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n-                }\n-            }\n-\n-            double minY = Double.POSITIVE_INFINITY;\n-            double maxY = Double.NEGATIVE_INFINITY;\n-            for (final WeightedObservedPoint point : points) {\n-                minY = Math.min(minY, point.getY());\n-                maxY = Math.max(maxY, point.getY());\n-            }\n-            throw new OutOfRangeException(y, minY, maxY);\n+                final WeightedObservedPoint p1 = points[i];\n+                final WeightedObservedPoint p2 = points[i + idxStep];\n+                if (isBetween(y, p1.getY(), p2.getY())) {\n+                    if (idxStep < 0) {\n+                        return new WeightedObservedPoint[] { p2, p1 };\n+                    } else {\n+                        return new WeightedObservedPoint[] { p1, p2 };\n+                    }\n+                }\n+            }\n+\n+            // Boundaries are replaced by dummy values because the raised\n+            // exception is caught and the message never displayed.\n+            // TODO: Exceptions should not be used for flow control.\n+            throw new OutOfRangeException(y,\n+                                          Double.NEGATIVE_INFINITY,\n+                                          Double.POSITIVE_INFINITY);\n         }\n \n         /**\n          * Determines whether a value is between two other values.\n          *\n-         * @param value Value to determine whether is between {@code boundary1}\n+         * @param value Value to test whether it is between {@code boundary1}\n          * and {@code boundary2}.\n          * @param boundary1 One end of the range.\n          * @param boundary2 Other end of the range.\n          * @return {@code true} if {@code value} is between {@code boundary1} and\n          * {@code boundary2} (inclusive), {@code false} otherwise.\n          */\n-        private boolean isBetween(double value, double boundary1, double boundary2) {\n+        private boolean isBetween(double value,\n+                                  double boundary1,\n+                                  double boundary2) {\n             return (value >= boundary1 && value <= boundary2) ||\n-                   (value >= boundary2 && value <= boundary1);\n-        }\n-\n-        /**\n-         * Factory method creating {@code Comparator} for comparing\n-         * {@code WeightedObservedPoint} instances.\n-         *\n-         * @return the new {@code Comparator} instance.\n-         */\n-        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n-            return new Comparator<WeightedObservedPoint>() {\n-                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n-                    if (p1 == null && p2 == null) {\n-                        return 0;\n-                    }\n-                    if (p1 == null) {\n-                        return -1;\n-                    }\n-                    if (p2 == null) {\n-                        return 1;\n-                    }\n-                    if (p1.getX() < p2.getX()) {\n-                        return -1;\n-                    }\n-                    if (p1.getX() > p2.getX()) {\n-                        return 1;\n-                    }\n-                    if (p1.getY() < p2.getY()) {\n-                        return -1;\n-                    }\n-                    if (p1.getY() > p2.getY()) {\n-                        return 1;\n-                    }\n-                    if (p1.getWeight() < p2.getWeight()) {\n-                        return -1;\n-                    }\n-                    if (p1.getWeight() > p2.getWeight()) {\n-                        return 1;\n-                    }\n-                    return 0;\n-                }\n-            };\n+                (value >= boundary2 && value <= boundary1);\n         }\n     }\n }", "timestamp": 1345252165, "metainfo": ""}