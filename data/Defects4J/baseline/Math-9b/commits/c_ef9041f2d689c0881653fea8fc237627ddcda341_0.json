{"sha": "ef9041f2d689c0881653fea8fc237627ddcda341", "log": "Added a few linearCombination utility methods in MathUtils to compute accurately linear combinations a1.b1 + a2.b2 + ... + an.bn taking great care to compensate for cancellation effects. This both improves and simplify several methods in euclidean geometry classes, including linear constructors, dot product and cross product.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.Collections;\n-\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.NotFiniteNumberException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.NonMonotonousSequenceException;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NotPositiveException;\n-import org.apache.commons.math.exception.MathArithmeticException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.NumberIsTooLargeException;\n-import org.apache.commons.math.exception.NotFiniteNumberException;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n                479001600l,         6227020800l,         87178291200l,\n            1307674368000l,     20922789888000l,     355687428096000l,\n         6402373705728000l, 121645100408832000l, 2432902008176640000l };\n+\n+    /** Factor used for splitting double numbers: n = 2^27 + 1. */\n+    private static final int SPLIT_FACTOR = 0x8000001;\n \n     /**\n      * Private Constructor\n             throw new NullArgumentException();\n         }\n     }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n+     * so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects. It is based\n+     * on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(double, double, double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they shoud NOT be simplified, as they\n+        // do use IEEE753 floating point arithmetic rouding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variables naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // final rounding, s12 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        return s12High + (prod1Low + prod2Low + s12Low);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2,\n+                                           final double a3, final double b3) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they shoud NOT be simplified, as they\n+        // do use IEEE753 floating point arithmetic rouding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variables naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // split a3 and b3 as two 26 bits numbers\n+        final double ca3        = SPLIT_FACTOR * a3;\n+        final double a3High     = ca3 - (ca3 - a3);\n+        final double a3Low      = a3 - a3High;\n+        final double cb3        = SPLIT_FACTOR * b3;\n+        final double b3High     = cb3 - (cb3 - b3);\n+        final double b3Low      = b3 - b3High;\n+\n+        // accurate multiplication a3 * b3\n+        final double prod3High  = a3 * b3;\n+        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n+        final double s123High   = s12High + prod3High;\n+        final double s123Prime  = s123High - prod3High;\n+        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n+\n+        // final rounding, s123 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        return s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n+\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2,\n+                                           final double a3, final double b3,\n+                                           final double a4, final double b4) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they shoud NOT be simplified, as they\n+        // do use IEEE753 floating point arithmetic rouding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variables naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // split a3 and b3 as two 26 bits numbers\n+        final double ca3        = SPLIT_FACTOR * a3;\n+        final double a3High     = ca3 - (ca3 - a3);\n+        final double a3Low      = a3 - a3High;\n+        final double cb3        = SPLIT_FACTOR * b3;\n+        final double b3High     = cb3 - (cb3 - b3);\n+        final double b3Low      = b3 - b3High;\n+\n+        // accurate multiplication a3 * b3\n+        final double prod3High  = a3 * b3;\n+        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n+\n+        // split a4 and b4 as two 26 bits numbers\n+        final double ca4        = SPLIT_FACTOR * a4;\n+        final double a4High     = ca4 - (ca4 - a4);\n+        final double a4Low      = a4 - a4High;\n+        final double cb4        = SPLIT_FACTOR * b4;\n+        final double b4High     = cb4 - (cb4 - b4);\n+        final double b4Low      = b4 - b4High;\n+\n+        // accurate multiplication a4 * b4\n+        final double prod4High  = a4 * b4;\n+        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n+        final double s123High   = s12High + prod3High;\n+        final double s123Prime  = s123High - prod3High;\n+        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n+        final double s1234High  = s123High + prod4High;\n+        final double s1234Prime = s1234High - prod4High;\n+        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n+\n+        // final rounding, s1234 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        return s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n+\n+    }\n+\n }", "timestamp": 1312556509, "metainfo": ""}