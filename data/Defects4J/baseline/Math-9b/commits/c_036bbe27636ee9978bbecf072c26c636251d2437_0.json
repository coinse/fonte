{"sha": "036bbe27636ee9978bbecf072c26c636251d2437", "log": "simplified and reorganized slightly the Adams integrators class hierarchy this will allow a future BDF integrator development for stiff problems  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n \n package org.apache.commons.math.ode;\n \n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.lang.reflect.Field;\n-\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n  */\n public abstract class MultistepIntegrator extends AdaptiveStepsizeIntegrator {\n \n-    /** Transformer. */\n-    protected final transient NordsieckTransformer transformer;\n-\n     /** Starter integrator. */\n     private FirstOrderIntegrator starter;\n \n     /** Nordsieck matrix of the higher scaled derivatives.\n      * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n      */\n-    protected RealMatrix nordsieck;\n+    protected Array2DRowRealMatrix nordsieck;\n \n     /** Stepsize control exponent. */\n     private double exp;\n                                                  scalAbsoluteTolerance,\n                                                  scalRelativeTolerance);\n         this.nSteps = nSteps;\n-        transformer = NordsieckTransformer.getInstance(nSteps + 1);\n \n         exp = -1.0 / order;\n \n                                                  vecAbsoluteTolerance,\n                                                  vecRelativeTolerance);\n         this.nSteps = nSteps;\n-        transformer = NordsieckTransformer.getInstance(nSteps + 1);\n \n         exp = -1.0 / order;\n \n \n     }\n \n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param first first scaled derivative at step start\n+     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+     * will be modified\n+     * @return high order derivatives at step start\n+     */\n+    protected abstract Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                                           final double[][] multistep);\n+\n     /** Get the minimal reduction factor for stepsize control.\n      * @return minimal reduction factor\n      */\n         return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n     }\n \n-    /** Serialize the instance.\n-     * @param oos stream where object should be written\n-     * @throws IOException if object cannot be written to stream\n-     */\n-    private void writeObject(ObjectOutputStream oos)\n-        throws IOException {\n-        oos.defaultWriteObject();\n-        oos.writeInt(nSteps);\n-    }\n-\n-    /** Deserialize the instance.\n-     * @param ois stream from which the object should be read\n-     * @throws ClassNotFoundException if a class in the stream cannot be found\n-     * @throws IOException if object cannot be read from the stream\n-     */\n-    private void readObject(ObjectInputStream ois)\n-      throws ClassNotFoundException, IOException {\n-        try {\n-\n-            ois.defaultReadObject();\n-            final int nSteps = ois.readInt();\n-\n-            final Class<MultistepIntegrator> cl = MultistepIntegrator.class;\n-            final Field f = cl.getDeclaredField(\"transformer\");\n-            f.setAccessible(true);\n-            f.set(this, NordsieckTransformer.getInstance(nSteps + 1));\n-\n-        } catch (NoSuchFieldException nsfe) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(nsfe);\n-            throw ioe;\n-        } catch (IllegalAccessException iae) {\n-            IOException ioe = new IOException();\n-            ioe.initCause(iae);\n-            throw ioe;\n-        }\n-\n+    /** Transformer used to convert the first step to Nordsieck representation. */\n+    public static interface NordsieckTransformer {\n+        /** Initialize the high order scaled derivatives at step start.\n+         * @param first first scaled derivative at step start\n+         * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+         * will be modified\n+         * @return high order derivatives at step start\n+         */\n+        RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n     }\n \n     /** Specialized step handler storing the first step. */\n                 }\n                 multistep[i - 1] = msI;\n             }\n-            nordsieck = transformer.initializeHighOrderDerivatives(scaled, multistep);\n+            nordsieck = initializeHighOrderDerivatives(scaled, multistep);\n \n             // stop the integrator after the first step has been handled\n             throw new InitializationCompletedMarkerException();\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.MultistepIntegrator;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class AdamsBashforthIntegrator extends MultistepIntegrator {\n+public class AdamsBashforthIntegrator extends AdamsIntegrator {\n \n     /**\n-     * Build an Adams-Bashforth with the given order and step size.\n+     * Build an Adams-Bashforth integrator with the given order and step control parameters.\n      * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n     }\n \n     /**\n-     * Build an Adams-Bashforth with the given order and step size.\n+     * Build an Adams-Bashforth integrator with the given order and step control parameters.\n      * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n                     for (int j = 0; j < y0.length; ++j) {\n                         predictedScaled[j] = stepSize * yDot[j];\n                     }\n-                    final RealMatrix nordsieckTmp =\n-                        transformer.updateHighOrderDerivativesPhase1(nordsieck);\n-                    transformer.updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+                    final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+                    updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n \n                     // discrete events handling\n                     interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+\n+\n+/** Base class for {@link AdamsBashforthIntegrator Adams-Bashforth} and\n+ * {@link AdamsMoultonIntegrator Adams-Moulton} integrators.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AdamsIntegrator extends MultistepIntegrator {\n+\n+    /** Transformer. */\n+    private final AdamsNordsieckTransformer transformer;\n+\n+    /**\n+     * Build an Adams integrator with the given order and step control prameters.\n+     * @param name name of the method\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsIntegrator(final String name, final int nSteps, final int order,\n+                           final double minStep, final double maxStep,\n+                           final double scalAbsoluteTolerance,\n+                           final double scalRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(name, nSteps, order, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n+        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n+    }\n+\n+    /**\n+     * Build an Adams integrator with the given order and step control parameters.\n+     * @param name name of the method\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsIntegrator(final String name, final int nSteps, final int order,\n+                           final double minStep, final double maxStep,\n+                           final double[] vecAbsoluteTolerance,\n+                           final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(name, nSteps, order, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n+        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public abstract double integrate(final FirstOrderDifferentialEquations equations,\n+                                     final double t0, final double[] y0,\n+                                     final double t, final double[] y)\n+        throws DerivativeException, IntegratorException;\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                        final double[][] multistep) {\n+        return transformer.initializeHighOrderDerivatives(first, multistep);\n+    }\n+\n+    /** Update the high order scaled derivatives for Adams integrators (phase 1).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n+     * @param highOrder high order scaled derivatives\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @return updated high order derivatives\n+     * @see #updateHighOrderDerivativesPhase2(double[], double[], RealMatrix)\n+     */\n+    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n+        return transformer.updateHighOrderDerivativesPhase1(highOrder);\n+    }\n+\n+    /** Update the high order scaled derivatives Adams integrators (phase 2).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n+     * <p>Phase 1 of the update must already have been performed.</p>\n+     * @param start first order scaled derivatives at step start\n+     * @param end first order scaled derivatives at step end\n+     * @param highOrder high order scaled derivatives, will be modified\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @see #updateHighOrderDerivativesPhase1(RealMatrix)\n+     */\n+    public void updateHighOrderDerivativesPhase2(final double[] start,\n+                                                 final double[] end,\n+                                                 final Array2DRowRealMatrix highOrder) {\n+        transformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.MatrixVisitorException;\n-import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.MultistepIntegrator;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n  * <ul>\n  *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n  *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n- *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n  * </ul>\n  * where A is a rows shifting matrix (the lower left part is an identity matrix):\n  * <pre>\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class AdamsMoultonIntegrator extends MultistepIntegrator {\n+public class AdamsMoultonIntegrator extends AdamsIntegrator {\n \n     /**\n      * Build an Adams-Moulton integrator with the given order and error control parameters.\n     }\n \n     /**\n-     * Build an Adams-Moulton integrator with the given order and step size.\n+     * Build an Adams-Moulton integrator with the given order and error control parameters.\n      * @param nSteps number of steps of the method excluding the one being computed\n      * @param minStep minimal step (must be positive even for backward\n      * integration), the last step can be smaller than this\n                 for (int j = 0; j < y0.length; ++j) {\n                     predictedScaled[j] = stepSize * yDot[j];\n                 }\n-                final RealMatrix nordsieckTmp =\n-                    transformer.updateHighOrderDerivativesPhase1(nordsieck);\n-                transformer.updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n \n                 // apply correction (C in the PECE sequence)\n                 error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n                     for (int j = 0; j < y0.length; ++j) {\n                         correctedScaled[j] = stepSize * yDot[j];\n                     }\n-                    transformer.updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n+                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n \n                     // discrete events handling\n                     interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);", "timestamp": 1246226180, "metainfo": ""}