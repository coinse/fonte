{"sha": "4e89d4e9b66e2b105b57c175d472dbd2b40e556e", "log": "Javadoc cleanup of genetics package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/genetics/AbstractListChromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/AbstractListChromosome.java\n     /**\n      * Constructor.\n      * @param representation inner representation of the chromosome\n-     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *         a valid chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n     public AbstractListChromosome(final List<T> representation) {\n         checkValidity(representation);\n     }\n \n     /**\n+     * Asserts that <code>representation</code> can represent a valid chromosome.\n      *\n-     * Asserts that <code>representation</code> can represent a valid chromosome.\n      * @param chromosomeRepresentation representation of the chromosome\n-     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *         a valid chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n     protected abstract void checkValidity(List<T> chromosomeRepresentation) throws InvalidRepresentationException;\n \n     }\n \n     /**\n-     * Creates a new instance of the same class as <code>this</code> is, with a\n-     * given <code>arrayRepresentation</code>. This is needed in crossover and\n-     * mutation operators, where we need a new instance of the same class, but\n-     * with different array representation.\n-     *\n+     * Creates a new instance of the same class as <code>this</code> is, with a given <code>arrayRepresentation</code>.\n+     * This is needed in crossover and mutation operators, where we need a new instance of the same class, but with\n+     * different array representation.\n+     * <p>\n      * Usually, this method just calls a constructor of the class.\n      *\n-     * @param chromosomeRepresentation\n-     *            the inner array representation of the new chromosome.\n-     * @return new instance extended from FixedLengthChromosome with the given\n-     *         arrayRepresentation\n+     * @param chromosomeRepresentation the inner array representation of the new chromosome.\n+     * @return new instance extended from FixedLengthChromosome with the given arrayRepresentation\n      */\n     public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> chromosomeRepresentation);\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public String toString() {\n         return String.format(\"(f=%s %s)\", getFitness(), getRepresentation());\n--- a/src/main/java/org/apache/commons/math3/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/BinaryChromosome.java\n     /**\n      * Constructor.\n      * @param representation list of {0,1} values representing the chromosome\n-     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *         a valid chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n     public BinaryChromosome(List<Integer> representation) {\n         super(representation);\n     /**\n      * Constructor.\n      * @param representation array of {0,1} values representing the chromosome\n-     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *         a valid chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome\n      */\n     public BinaryChromosome(Integer[] representation) {\n         super(representation);\n--- a/src/main/java/org/apache/commons/math3/genetics/BinaryMutation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/BinaryMutation.java\n \n     /**\n      * Mutate the given chromosome. Randomly changes one gene.\n+     *\n      * @param original the original chromosome.\n      * @return the mutated chromosome.\n-     * @throws MathIllegalArgumentException if <code>original</code> is not an instance\n-     *         of {@link BinaryChromosome}.\n+     * @throws MathIllegalArgumentException if <code>original</code> is not an instance of {@link BinaryChromosome}.\n      */\n     public Chromosome mutate(Chromosome original) {\n         if (!(original instanceof BinaryChromosome)) {\n--- a/src/main/java/org/apache/commons/math3/genetics/Chromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/Chromosome.java\n \n /**\n  * Individual in a population. Chromosomes are compared based on their fitness.\n- *\n+ * <p>\n  * The chromosomes are IMMUTABLE, and so their fitness is also immutable and\n  * therefore it can be cached.\n  *\n     private double fitness = NO_FITNESS;\n \n     /**\n-     * Access the fitness of this chromosome. The bigger the fitness, the better\n-     * the chromosome.\n+     * Access the fitness of this chromosome. The bigger the fitness, the better the chromosome.\n+     * <p>\n+     * Computation of fitness is usually very time-consuming task, therefore the fitness is cached.\n      *\n-     * Computation of fitness is usually very time-consuming task, therefore the\n-     * fitness is cached.\n-     *\n-     * @return the fitness.\n+     * @return the fitness\n      */\n     public double getFitness() {\n         if (this.fitness == NO_FITNESS) {\n     }\n \n     /**\n-     * Compares two chromosomes based on their fitness. The bigger the fitness,\n-     * the better the chromosome.\n+     * Compares two chromosomes based on their fitness. The bigger the fitness, the better the chromosome.\n      *\n      * @param another another chromosome to compare\n      * @return\n      * <ul>\n-     *     <li>-1 if <code>another</code> is better than <code>this</code></li>\n-     *     <li>1 if <code>another</code> is worse than <code>this</code></li>\n-     *     <li>0 if the two chromosomes have the same fitness</li>\n+     *   <li>-1 if <code>another</code> is better than <code>this</code></li>\n+     *   <li>1 if <code>another</code> is worse than <code>this</code></li>\n+     *   <li>0 if the two chromosomes have the same fitness</li>\n      * </ul>\n      */\n     public int compareTo(final Chromosome another) {\n     }\n \n     /**\n-     * Returns <code>true</code> iff <code>another</code> has the same\n-     * representation and therefore the same fitness. By default, it returns\n-     * false -- override it in your implementation if you need it.\n+     * Returns <code>true</code> iff <code>another</code> has the same representation and therefore the same fitness. By\n+     * default, it returns false -- override it in your implementation if you need it.\n+     *\n      * @param another chromosome to compare\n      * @return true if <code>another</code> is equivalent to this chromosome\n      */\n     }\n \n     /**\n-     * Searches the <code>population</code> for another chromosome with the same\n-     * representation. If such chromosome is found, it is returned, if no such\n-     * chromosome exists, returns <code>null</code>.\n+     * Searches the <code>population</code> for another chromosome with the same representation. If such chromosome is\n+     * found, it is returned, if no such chromosome exists, returns <code>null</code>.\n      *\n      * @param population Population to search\n-     * @return Chromosome with the same representation, or <code>null</code> if\n-     *         no such chromosome exists.\n+     * @return Chromosome with the same representation, or <code>null</code> if no such chromosome exists.\n      */\n     protected Chromosome findSameChromosome(final Population population) {\n         for (Chromosome anotherChr : population) {\n     }\n \n     /**\n-     * Searches the population for a chromosome representing the same solution,\n-     * and if it finds one, updates the fitness to its value.\n+     * Searches the population for a chromosome representing the same solution, and if it finds one,\n+     * updates the fitness to its value.\n      *\n      * @param population Population to search\n      */\n--- a/src/main/java/org/apache/commons/math3/genetics/ChromosomePair.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ChromosomePair.java\n         return second;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public String toString() {\n         return String.format(\"(%s,%s)\", getFirst(), getSecond());\n--- a/src/main/java/org/apache/commons/math3/genetics/CrossoverPolicy.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/CrossoverPolicy.java\n  * @version $Id$\n  */\n public interface CrossoverPolicy {\n+\n     /**\n      * Perform a crossover operation on the given chromosomes.\n      *\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n      *\n      * @param chromosomes list of chromosomes in the population\n      * @param populationLimit maximal size of the population\n-     * @param elitismRate how many best chromosomes will be directly transferred to the\n-     *                    next generation [in %]\n+     * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final List<Chromosome> chromosomes,\n     }\n \n     /**\n-     * Creates a new {@link ElitisticListPopulation} instance and initializes its inner\n-     * chromosome list.\n+     * Creates a new {@link ElitisticListPopulation} instance and initializes its inner chromosome list.\n      *\n      * @param populationLimit maximal size of the population\n-     * @param elitismRate how many best chromosomes will be directly transferred to the\n-     *                    next generation [in %]\n+     * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n     }\n \n     /**\n-     * Sets the elitism rate, i.e. how many best chromosomes will be directly\n-     * transferred to the next generation [in %].\n+     * Sets the elitism rate, i.e. how many best chromosomes will be directly transferred to the next generation [in %].\n      *\n-     * @param elitismRate how many best chromosomes will be directly transferred to the\n-     *                    next generation [in %]\n+     * @param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public void setElitismRate(final double elitismRate) {\n--- a/src/main/java/org/apache/commons/math3/genetics/Fitness.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/Fitness.java\n public interface Fitness {\n \n     /**\n-     * Compute the fitness. This is usually very time-consuming, so the value\n-     * should be cached.\n-     *\n+     * Compute the fitness. This is usually very time-consuming, so the value should be cached.\n      * @return fitness\n      */\n     double fitness();\n--- a/src/main/java/org/apache/commons/math3/genetics/FixedElapsedTime.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/FixedElapsedTime.java\n \n /**\n  * Stops after a fixed amount of time has elapsed.\n- *\n  * <p>\n- * The first time {@link #isSatisfied(Population)} is invoked, the end time of\n- * the evolution is determined based on the provided <code>maxTime</code> value.\n- * Once the elapsed time reaches the configured <code>maxTime</code> value,\n+ * The first time {@link #isSatisfied(Population)} is invoked, the end time of the evolution is determined based on the\n+ * provided <code>maxTime</code> value. Once the elapsed time reaches the configured <code>maxTime</code> value,\n  * {@link #isSatisfied(Population)} returns true.\n- * </p>\n  *\n  * @version $Id$\n  * @since 3.1\n--- a/src/main/java/org/apache/commons/math3/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/FixedGenerationCount.java\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n \n /**\n- * Stops after a fixed number of generations.  Each time\n- * {@link #isSatisfied(Population)} is invoked, a generation counter is\n- * incremented.  Once the counter reaches the configured\n- * <code>maxGenerations</code> value, {@link #isSatisfied(Population)} returns\n- * true.\n+ * Stops after a fixed number of generations. Each time {@link #isSatisfied(Population)} is invoked, a generation\n+ * counter is incremented. Once the counter reaches the configured <code>maxGenerations</code> value,\n+ * {@link #isSatisfied(Population)} returns true.\n  *\n  * @version $Id$\n  * @since 2.0\n     }\n \n     /**\n-     * Determine whether or not the given number of generations have passed.\n-     * Increments the number of generations counter if the maximum has not\n-     * been reached.\n+     * Determine whether or not the given number of generations have passed. Increments the number of generations\n+     * counter if the maximum has not been reached.\n      *\n      * @param population ignored (no impact on result)\n      * @return <code>true</code> IFF the maximum number of generations has been exceeded\n     }\n \n     /**\n+     * Returns the number of generations that have already passed.\n      * @return the number of generations that have passed\n      */\n     public int getNumGenerations() {\n--- a/src/main/java/org/apache/commons/math3/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/GeneticAlgorithm.java\n public class GeneticAlgorithm {\n \n     /**\n-     * Static random number generator shared by GA implementation classes.\n-     * Set the randomGenerator seed to get reproducible results.\n-     * Use {@link #setRandomGenerator(RandomGenerator)} to supply an alternative\n-     * to the default JDK-provided PRNG.\n+     * Static random number generator shared by GA implementation classes. Set the randomGenerator seed to get\n+     * reproducible results. Use {@link #setRandomGenerator(RandomGenerator)} to supply an alternative to the default\n+     * JDK-provided PRNG.\n      */\n     //@GuardedBy(\"this\")\n     private static RandomGenerator randomGenerator = new JDKRandomGenerator();\n     private int generationsEvolved = 0;\n \n     /**\n+     * Create a new genetic algorithm.\n      * @param crossoverPolicy The {@link CrossoverPolicy}\n      * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)\n      * @param mutationPolicy The {@link MutationPolicy}\n     }\n \n     /**\n-     * <p>Evolve the given population into the next generation.</p>\n-     * <p><ol>\n-     *    <li>Get nextGeneration population to fill from <code>current</code>\n-     *        generation, using its nextGeneration method</li>\n-     *    <li>Loop until new generation is filled:</li>\n-     *    <ul><li>Apply configured SelectionPolicy to select a pair of parents\n-     *            from <code>current</code></li>\n-     *        <li>With probability = {@link #getCrossoverRate()}, apply\n-     *            configured {@link CrossoverPolicy} to parents</li>\n-     *        <li>With probability = {@link #getMutationRate()}, apply\n-     *            configured {@link MutationPolicy} to each of the offspring</li>\n-     *        <li>Add offspring individually to nextGeneration,\n-     *            space permitting</li>\n-     *    </ul>\n-     *    <li>Return nextGeneration</li>\n-     *    </ol>\n-     * </p>\n+     * Evolve the given population into the next generation.\n+     * <p>\n+     * <ol>\n+     *  <li>Get nextGeneration population to fill from <code>current</code>\n+     *      generation, using its nextGeneration method</li>\n+     *  <li>Loop until new generation is filled:</li>\n+     *  <ul><li>Apply configured SelectionPolicy to select a pair of parents\n+     *          from <code>current</code></li>\n+     *      <li>With probability = {@link #getCrossoverRate()}, apply\n+     *          configured {@link CrossoverPolicy} to parents</li>\n+     *      <li>With probability = {@link #getMutationRate()}, apply\n+     *          configured {@link MutationPolicy} to each of the offspring</li>\n+     *      <li>Add offspring individually to nextGeneration,\n+     *          space permitting</li>\n+     *  </ul>\n+     *  <li>Return nextGeneration</li>\n+     * </ol>\n      *\n      * @param current the current population.\n      * @return the population for the next generation.\n     }\n \n     /**\n-     * Returns the number of generations evolved to\n-     * reach {@link StoppingCondition} in the last run.\n+     * Returns the number of generations evolved to reach {@link StoppingCondition} in the last run.\n      *\n      * @return number of generations evolved\n      * @since 2.1\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n \n     /**\n      * Creates a new ListPopulation instance.\n-     * <p>Note: the chromosomes of the specified list are added to the population.</p>\n+     * <p>\n+     * Note: the chromosomes of the specified list are added to the population.\n+     *\n      * @param chromosomes list of chromosomes to be added to the population\n      * @param populationLimit maximal size of the population\n      * @throws NullArgumentException if the list of chromosomes is {@code null}\n \n     /**\n      * Sets the list of chromosomes.\n-     * <p>Note: this method removed all existing chromosomes in the population and adds all chromosomes\n-     * of the specified list to the population.</p>\n+     * <p>\n+     * Note: this method removed all existing chromosomes in the population and adds all chromosomes\n+     * of the specified list to the population.\n+     *\n      * @param chromosomes the list of chromosomes\n      * @throws NullArgumentException if the list of chromosomes is {@code null}\n      * @throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit\n \n     /**\n      * Add the given chromosome to the population.\n+     *\n      * @param chromosome the chromosome to add.\n      * @throws NumberIsTooLargeException if the population would exceed the {@code populationLimit} after\n-     * adding this chromosome\n+     *   adding this chromosome\n      */\n     public void addChromosome(final Chromosome chromosome) {\n         if (chromosomes.size() >= populationLimit) {\n      * @param populationLimit maximal population size.\n      * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      * @throws NumberIsTooSmallException if the new population size is smaller than the current number\n-     * of chromosomes in the population\n+     *   of chromosomes in the population\n      */\n     public void setPopulationLimit(final int populationLimit) {\n         if (populationLimit <= 0) {\n--- a/src/main/java/org/apache/commons/math3/genetics/NPointCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/NPointCrossover.java\n \n     /**\n      * Creates a new {@link NPointCrossover} policy using the given number of points.\n-     *\n-     * <p><b>Note</b>: the number of crossover points must be &lt; <code>chromosome length - 1</code>.\n+     * <p>\n+     * <b>Note</b>: the number of crossover points must be &lt; <code>chromosome length - 1</code>.\n      * This condition can only be checked at runtime, as the chromosome length is not known in advance.\n-     * </p>\n      *\n      * @param crossoverPoints the number of crossover points\n-     * @throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not\n-     * strictly positive\n+     * @throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not strictly positive\n      */\n     public NPointCrossover(final int crossoverPoints) {\n         if (crossoverPoints <= 0) {\n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n      * @throws MathIllegalArgumentException iff one of the chromosomes is\n-     *         not an instance of {@link AbstractListChromosome}\n+     *   not an instance of {@link AbstractListChromosome}\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n      * @param second the second chromosome\n      * @return the pair of new chromosomes that resulted from the crossover\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n-     * @throws NumberIsTooLargeException if the number of crossoverPoints is too large for the\n-     * actual chromosomes\n+     * @throws NumberIsTooLargeException if the number of crossoverPoints is too large for the actual chromosomes\n      */\n     private ChromosomePair mate(final AbstractListChromosome<T> first,\n                                 final AbstractListChromosome<T> second) {\n--- a/src/main/java/org/apache/commons/math3/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/OnePointCrossover.java\n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n      * @throws MathIllegalArgumentException iff one of the chromosomes is\n-     *         not an instance of {@link AbstractListChromosome}\n+     *   not an instance of {@link AbstractListChromosome}\n      * @throws DimensionMismatchException if the length of the two chromosomes is different\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n--- a/src/main/java/org/apache/commons/math3/genetics/OrderedCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/OrderedCrossover.java\n  *   <li>starting from the right side of the slice, copy genes from parent 2 as they\n  *       appear to child 1 if they are not yet marked out.</li>\n  * </ol>\n- * </p>\n- *\n+ * <p>\n  * Example (random sublist from index 3 to 7, underlined):\n  * <pre>\n  * p1 = (8 4 7 3 6 2 5 1 9 0)   X   c1 = (0 4 7 3 6 2 5 1 8 9)\n  *             ---------                        ---------\n  * p2 = (0 1 2 3 4 5 6 7 8 9)   X   c2 = (8 1 2 3 4 5 6 7 9 0)\n  * </pre>\n- *\n+ * <p>\n  * This policy works only on {@link AbstractListChromosome}, and therefore it\n  * is parameterized by T. Moreover, the chromosomes must have same lengths.\n  *\n--- a/src/main/java/org/apache/commons/math3/genetics/PermutationChromosome.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/PermutationChromosome.java\n /**\n  * Interface indicating that the chromosome represents a permutation of objects.\n  *\n- * @param <T>\n- *            type of the permuted objects\n+ * @param <T> type of the permuted objects\n  * @since 2.0\n  * @version $Id$\n  */\n--- a/src/main/java/org/apache/commons/math3/genetics/Population.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/Population.java\n      * Add the given chromosome to the population.\n      * @param chromosome the chromosome to add.\n      * @throws org.apache.commons.math3.exception.NumberIsTooLargeException if the population would exceed\n-     * the population limit when adding this chromosome\n+     *   the population limit when adding this chromosome\n      */\n     void addChromosome(Chromosome chromosome);\n \n--- a/src/main/java/org/apache/commons/math3/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/RandomKey.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n- * <p>\n  * Random Key chromosome is used for permutation representation. It is a vector\n  * of a fixed length of real numbers in [0,1] interval. The index of the i-th\n  * smallest value in the vector represents an i-th member of the permutation.\n- * </p>\n- *\n  * <p>\n  * For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the\n  * permutation of indices (3,0,1,2). If the original (unpermuted) sequence would\n  * be (a,b,c,d), this would mean the sequence (d,a,b,c).\n- * </p>\n- *\n  * <p>\n  * With this representation, common operators like n-point crossover can be\n  * used, because any such chromosome represents a valid permutation.\n- * </p>\n- *\n  * <p>\n  * Since the chromosome (and thus its arrayRepresentation) is immutable, the\n  * array representation is sorted only once in the constructor.\n- * </p>\n- *\n  * <p>\n  * For details, see:\n  * <ul>\n- * <li>Bean, J.C.: Genetic algorithms and random keys for sequencing and\n- * optimization. ORSA Journal on Computing 6 (1994) 154-160</li>\n- * <li>Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms.\n- * Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag,\n- * Heidelberg (2002)</li>\n+ *   <li>Bean, J.C.: Genetic algorithms and random keys for sequencing and\n+ *       optimization. ORSA Journal on Computing 6 (1994) 154-160</li>\n+ *   <li>Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms.\n+ *       Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag,\n+ *       Heidelberg (2002)</li>\n  * </ul>\n- * </p>\n  *\n- * @param <T>\n- *            type of the permuted objects\n+ * @param <T> type of the permuted objects\n  * @since 2.0\n  * @version $Id$\n  */\n      *\n      * @param representation list of [0,1] values representing the permutation\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n-     *         a valid chromosome\n+     *   a valid chromosome\n      */\n     public RandomKey(final List<Double> representation) {\n         super(representation);\n      * @param sortedRepr sorted <code>representation</code>\n      * @return list with the sequence values permuted according to the representation\n      * @throws DimensionMismatchException iff the length of the <code>sequence</code>,\n-     * <code>representation</code> or <code>sortedRepr</code> lists are not equal\n+     *   <code>representation</code> or <code>sortedRepr</code> lists are not equal\n      */\n     private static <S> List<S> decodeGeneric(final List<S> sequence, List<Double> representation,\n                                              final List<Double> sortedRepr) {\n      * @param originalData the original, unpermuted data\n      * @param permutedData the data, somehow permuted\n      * @return representation of a permutation corresponding to the permutation\n-     * <code>originalData -> permutedData</code>\n+     *   <code>originalData -> permutedData</code>\n      * @throws DimensionMismatchException iff the length of <code>originalData</code>\n-     * and <code>permutedData</code> lists are not equal\n+     *   and <code>permutedData</code> lists are not equal\n      * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n-     * <code>originalData</code> lists contain different data\n+     *   <code>originalData</code> lists contain different data\n      */\n     public static <S> List<Double> inducedPermutation(final List<S> originalData,\n                                                       final List<S> permutedData) {\n         return Arrays.asList(res);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public String toString() {\n         return String.format(\"(f=%s pi=(%s))\", getFitness(), baseSeqPermutation);\n--- a/src/main/java/org/apache/commons/math3/genetics/RandomKeyMutation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/RandomKeyMutation.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @throws MathIllegalArgumentException if <code>original</code> is not a\n-     * {@link RandomKey} instance\n+     * @throws MathIllegalArgumentException if <code>original</code> is not a {@link RandomKey} instance\n      */\n     public Chromosome mutate(final Chromosome original) {\n         if (!(original instanceof RandomKey<?>)) {\n--- a/src/main/java/org/apache/commons/math3/genetics/StoppingCondition.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/StoppingCondition.java\n  */\n public interface StoppingCondition {\n     /**\n-     * Determine whether or not the given population satisfies the stopping\n-     * condition.\n+     * Determine whether or not the given population satisfies the stopping condition.\n      *\n      * @param population the population to test.\n-     * @return <code>true</code> if this stopping condition is met by the\n-     *         given population. <code>false</code> otherwise.\n+     * @return <code>true</code> if this stopping condition is met by the given population,\n+     *   <code>false</code> otherwise.\n      */\n     boolean isSatisfied(Population population);\n }\n--- a/src/main/java/org/apache/commons/math3/genetics/TournamentSelection.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/TournamentSelection.java\n     }\n \n     /**\n-     * Helper for {@link #select(Population)}. Draw {@link #arity} random\n-     * chromosomes without replacement from the population, and then select the\n-     * fittest chromosome among them.\n+     * Helper for {@link #select(Population)}. Draw {@link #arity} random chromosomes without replacement from the\n+     * population, and then select the fittest chromosome among them.\n      *\n      * @param population the population from which the chromosomes are choosen.\n      * @return the selected chromosome.\n-     * @throws MathIllegalArgumentException if the tournament arity is bigger than the\n-     * population size\n+     * @throws MathIllegalArgumentException if the tournament arity is bigger than the population size\n      */\n     private Chromosome tournament(final ListPopulation population) {\n         if (population.getPopulationSize() < this.arity) {\n--- a/src/main/java/org/apache/commons/math3/genetics/UniformCrossover.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/UniformCrossover.java\n  * parent. This is typically a poor method of crossover, but empirical evidence\n  * suggests that it is more exploratory and results in a larger part of the\n  * problem space being searched.\n- *\n- * <p>This crossover policy evaluates each gene of the parent chromosomes by chosing a\n+ * <p>\n+ * This crossover policy evaluates each gene of the parent chromosomes by chosing a\n  * uniform random number {@code p} in the range [0, 1]. If {@code p} &lt; {@code ratio},\n  * the parent genes are swapped. This means with a ratio of 0.7, 30% of the genes from the\n  * first parent and 70% from the second parent will be selected for the first offspring (and\n- * vice versa for the second offspring).</p>\n- *\n- * <p>This policy works only on {@link AbstractListChromosome}, and therefore it\n+ * vice versa for the second offspring).\n+ * <p>\n+ * This policy works only on {@link AbstractListChromosome}, and therefore it\n  * is parameterized by T. Moreover, the chromosomes must have same lengths.\n- * </p>\n  *\n  * @see <a href=\"http://en.wikipedia.org/wiki/Crossover_%28genetic_algorithm%29\">Crossover techniques (Wikipedia)</a>\n  * @see <a href=\"http://www.obitko.com/tutorials/genetic-algorithms/crossover-mutation.php\">Crossover (Obitko.com)</a>\n--- a/src/main/java/org/apache/commons/math3/genetics/package-info.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/package-info.java\n  * limitations under the License.\n  */\n /**\n- *\n- * <p>\n  * This package provides Genetic Algorithms components and implementations.\n- * </p>\n- *\n  */\n package org.apache.commons.math3.genetics;", "timestamp": 1347808795, "metainfo": ""}