{"sha": "f11ad9cc273c33be047333a0961758f1ae330bc1", "log": "Added a way to compute both the final state in an Initial Value Problem (IVP) for Ordinary Differential Equations (ODE) and its derivatives with respect to initial state and with respect to some problem parameters. This allows wrapping ODE solvers into optimization or root finding algorithms, which in turn can be used to solve Boundary Value Problems (BVP). There are no implementations (yet) of BVP solvers in the library.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/EnhancedFirstOrderIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/** This class enhances a first order integrator for differential equations to\n+ * compute also partial derivatives of the solution with respect to initial state\n+ * and parameters.\n+ * <p>In order to compute both the state and its derivatives, the ODE problem\n+ * is extended with jacobians of the raw ODE and the variational equations are\n+ * added to form a new compound problem of higher dimension. If the original ODE\n+ * problem has dimension n and there are p parameters, the compound problem will\n+ * have dimension n &times; (1 + n + k).</p>\n+ * @see ParameterizedFirstOrderDifferentialEquations\n+ * @see ParameterizedFirstOrderDifferentialEquationsWithPartials\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+public class EnhancedFirstOrderIntegrator {\n+\n+    /** Underlying integrator for compound problem. */\n+    private final FirstOrderIntegrator integrator;\n+\n+    /** Raw equations to integrate. */\n+    private final ParameterizedFirstOrderDifferentialEquationsWithPartials ode;\n+\n+    /** Build an enhanced integrator using internal differentiation to compute jacobians.\n+     * @param integrator underlying integrator to solve the compound problem\n+     * @param ode original problem (f in the equation y' = f(t, y))\n+     * @param p parameters array (may be null if {@link\n+     * ParameterizedFirstOrderDifferentialEquations#getParametersDimension()\n+     * getParametersDimension()} from original problem is zero)\n+     * @param hY step sizes to use for computing the jacobian df/dy, must have the\n+     * same dimension as the original problem\n+     * @param hP step sizes to use for computing the jacobian df/dp, must have the\n+     * same dimension as the original problem parameters dimension\n+     * @see #EnhancedFirstOrderIntegrator(FirstOrderIntegrator,\n+     * ParameterizedFirstOrderDifferentialEquationsWithPartials)\n+     */\n+    public EnhancedFirstOrderIntegrator(final FirstOrderIntegrator integrator,\n+                                        final ParameterizedFirstOrderDifferentialEquations ode,\n+                                        final double[] p, final double[] hY, final double[] hP) {\n+        checkDimension(ode.getDimension(), hY);\n+        checkDimension(ode.getParametersDimension(), p);\n+        checkDimension(ode.getParametersDimension(), hP);\n+        this.integrator = integrator;\n+        this.ode = new FiniteDifferencesWrapper(ode, p, hY, hP);\n+    }\n+\n+    /** Build an enhanced integrator using ODE builtin jacobian computation features.\n+     * @param integrator underlying integrator to solve the compound problem\n+     * @param ode original problem, which can compute the jacobians by itself\n+     * @see #EnhancedFirstOrderIntegrator(FirstOrderIntegrator,\n+     * ParameterizedFirstOrderDifferentialEquations, double[], double[], double[])\n+     */\n+    public EnhancedFirstOrderIntegrator(final FirstOrderIntegrator integrator,\n+                                        final ParameterizedFirstOrderDifferentialEquationsWithPartials ode) {\n+        this.integrator = integrator;\n+        this.ode = ode;\n+    }\n+\n+    /** Integrate the differential equations and the variational equations up to the given time.\n+     * <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives\n+     * of the solution with respect to initial state and parameters. This can be used as\n+     * a basis to solve Boundary Value Problems (BVP).</p>\n+     * <p>Since this method stores some internal state variables made\n+     * available in its public interface during integration ({@link\n+     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n+     * @param equations differential equations to integrate\n+     * @param t0 initial time\n+     * @param y0 initial value of the state vector at t0\n+     * @param dY0dP initial value of the state vector derivative with respect to the\n+     * parameters at t0\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n+     * @param y placeholder where to put the state vector at each successful\n+     *  step (and hence at the end of integration), can be the same object as y0\n+     * @param dYdY0 placeholder where to put the state vector derivative with respect\n+     * to the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful\n+     *  step (and hence at the end of integration)\n+     * @param dYdP placeholder where to put the state vector derivative with respect\n+     * to the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful\n+     *  step (and hence at the end of integration)\n+     * @return stop time, will be the same as target time if integration reached its\n+     * target, but may be different if some event handler stops it at some point.\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    public double integrate(final double t0, final double[] y0, final double[][] dY0dP,\n+                            final double t, final double[] y,\n+                            final double[][] dYdY0, final double[][] dYdP)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = ode.getDimension();\n+        final int k = ode.getParametersDimension();\n+        checkDimension(n, y0);\n+        checkDimension(n, y);\n+        checkDimension(n, dYdY0);\n+        checkDimension(n, dYdY0[0]);\n+        if (k != 0) {\n+            checkDimension(n, dY0dP);\n+            checkDimension(k, dY0dP[0]);\n+            checkDimension(n, dYdP);\n+            checkDimension(k, dYdP[0]);\n+        }\n+\n+        // the compound state z contains the raw state y and its derivatives\n+        // with respect to initial state y0 and to parameters p\n+        //    y[i]         is stored in z[i]\n+        //    dy[i]/dy0[j] is stored in z[n + i * n + j]\n+        //    dy[i]/dp[j]  is stored in z[n * (n + 1) + i * k + j]\n+        final int q = n * (1 + n + k);\n+\n+        // set up initial state, including partial derivatives\n+        final double[] z = new double[q];\n+        System.arraycopy(y0, 0, z, 0, n);\n+        for (int i = 0; i < n; ++i) {\n+\n+            // set diagonal element of dy/dy0 to 1.0 at t = t0\n+            z[i * (1 + n) + n] = 1.0;\n+\n+            // set initial derivatives with respect to parameters\n+            System.arraycopy(dY0dP[i], 0, z, n * (n + 1) + i * k, k);\n+\n+        }\n+\n+        // integrate the compound state variational equations\n+        final double stopTime = integrator.integrate(new FirstOrderDifferentialEquations() {\n+\n+            /** Current state. */\n+            private final double[]   y    = new double[n];\n+\n+            /** Time derivative of the current state. */\n+            private final double[]   yDot = new double[n];\n+\n+            /** Derivatives of yDot with respect to state. */\n+            private final double[][] dFdY = new double[n][n];\n+\n+            /** Derivatives of yDot with respect to parameters. */\n+            private final double[][] dFdP = new double[n][k];\n+\n+            /** {@inheritDoc} */\n+            public int getDimension() {\n+                return q;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void computeDerivatives(final double t, final double[] z, final double[] zDot)\n+                throws DerivativeException {\n+\n+                // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n+                System.arraycopy(z,    0, y,    0, n);\n+                ode.computeDerivatives(t, y, yDot);\n+                ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n+\n+                // state part of the compound equations\n+                System.arraycopy(yDot, 0, zDot, 0, n);\n+\n+                // variational equations: from d[dy/dt]/dy0 to d[dy/dy0]/dt\n+                for (int i = 0; i < n; ++i) {\n+                    final double[] dFdYi = dFdY[i];\n+                    for (int j = 0; j < n; ++j) {\n+                        double s = 0;\n+                        int zIndex = n + j;\n+                        for (int l = 0; l < n; ++l) {\n+                            s += dFdYi[l] * z[zIndex];\n+                            zIndex += l;\n+                        }\n+                        zDot[n + i * n + j] = s;\n+                    }\n+                }\n+\n+                // variational equations: d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dp]/dt\n+                for (int i = 0; i < n; ++i) {\n+                    final double[] dFdYi = dFdY[i];\n+                    final double[] dFdPi = dFdP[i];\n+                    for (int j = 0; j < k; ++j) {\n+                        double s = dFdPi[j];\n+                        int zIndex = n * (n + 1)+ j;\n+                        for (int l = 0; l < n; ++l) {\n+                            s += dFdYi[l] * z[zIndex];\n+                            zIndex += k;\n+                        }\n+                        zDot[n * (n + 1) + i * k + j] = s;\n+                    }\n+                }\n+\n+            }\n+\n+        }, t0, z, t, z);\n+\n+        // dispatch the final compound state into the state and partial derivatives arrays\n+        System.arraycopy(z, 0, y, 0, n);\n+        for (int i = 0; i < n; ++i) {\n+            System.arraycopy(z, n * (i + 1), dYdY0[i], 0, n);\n+        }\n+        for (int i = 0; i < n; ++i) {\n+            System.arraycopy(z, n * (n + 1) + i * k, dYdP[i], 0, k);\n+        }\n+\n+        return stopTime;\n+\n+    }\n+\n+    /** Check array dimensions.\n+     * @param expected expected dimension\n+     * @param array (may be null if expected is 0)\n+     * @throws IllegalArgumentException if the array dimension does not match the expected one\n+     */\n+    private void checkDimension(final int expected, final Object array)\n+        throws IllegalArgumentException {\n+        int arrayDimension = (array == null) ? 0 : Array.getLength(array);\n+        if (arrayDimension != expected) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\", arrayDimension, expected);\n+        }\n+    }\n+\n+    /** Wrapper class to compute jacobians by finite differences for ODE which do not compute them themselves. */\n+    private static class FiniteDifferencesWrapper\n+        implements ParameterizedFirstOrderDifferentialEquationsWithPartials {\n+\n+        /** Raw ODE without jacobians computation. */\n+        private final ParameterizedFirstOrderDifferentialEquations ode;\n+\n+        /** Parameters array (may be null if parameters dimension from original problem is zero) */\n+        private final double[] p;\n+\n+        /** Step sizes to use for computing the jacobian df/dy. */\n+        private final double[] hY;\n+\n+        /** Step sizes to use for computing the jacobian df/dp. */\n+        private final double[] hP;\n+\n+        /** Temporary array for state derivatives used to compute jacobians. */\n+        private final double[] tmpDot;\n+\n+        /** Simple constructor.\n+         * @param ode original ODE problem, without jacobians computations\n+         * @param p parameters array (may be null if parameters dimension from original problem is zero)\n+         * @param hY step sizes to use for computing the jacobian df/dy\n+         * @param hP step sizes to use for computing the jacobian df/dp\n+         */\n+        public FiniteDifferencesWrapper(final ParameterizedFirstOrderDifferentialEquations ode,\n+                                        final double[] p, final double[] hY, final double[] hP) {\n+            this.ode = ode;\n+            this.p  = p.clone();\n+            this.hY = hY.clone();\n+            this.hP = hP.clone();\n+            tmpDot = new double[ode.getDimension()];\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return ode.getDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException {\n+            ode.computeDerivatives(t, y, yDot);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getParametersDimension() {\n+            return ode.getParametersDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setParameter(int i, double value) {\n+            ode.setParameter(i, value);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeJacobians(double t, double[] y, double[] yDot,\n+                                     double[][] dFdY, double[][] dFdP)\n+            throws DerivativeException {\n+\n+            final int n = ode.getDimension();\n+            final int k = ode.getParametersDimension();\n+\n+            // compute df/dy where f is the ODE and y is the state array\n+            for (int j = 0; j < n; ++j) {\n+                final double savedYj = y[j];\n+                y[j] += hY[j];\n+                ode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdY[i][j] = (tmpDot[i] - yDot[i]) / hY[j];\n+                }\n+                y[j] = savedYj;\n+            }\n+\n+            // compute df/dp where f is the ODE and p is the parameters array\n+            for (int j = 0; j < k; ++j) {\n+                ode.setParameter(j, p[j] +  hP[j]);\n+                ode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdP[i][j] = (tmpDot[i] - yDot[i]) / hP[j];\n+                }\n+                ode.setParameter(j, p[j]);\n+            }\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedFirstOrderDifferentialEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+\n+/** This interface represents {@link FirstOrderDifferentialEquations\n+ * first order differential equations} with parameters.\n+ *\n+ * @see EnhancedFirstOrderIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface ParameterizedFirstOrderDifferentialEquations\n+    extends FirstOrderDifferentialEquations {\n+\n+    /** Get the number of parameters.\n+     * @return number of parameters\n+     */\n+    int getParametersDimension();\n+\n+    /** Set a parameter.\n+     * @param i index of the parameters (must be between 0\n+     * and {@link #getParametersDimension() getParametersDimension() - 1})\n+     * @param value value for the parameter\n+     */\n+    void setParameter(int i, double value);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedFirstOrderDifferentialEquationsWithPartials.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+\n+/** This interface represents {@link ParameterizedFirstOrderDifferentialEquations\n+ * first order differential equations} with parameters and partial derivatives.\n+ *\n+ * @see EnhancedFirstOrderIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface ParameterizedFirstOrderDifferentialEquationsWithPartials\n+    extends ParameterizedFirstOrderDifferentialEquations {\n+\n+    /** Compute the partial derivatives of ODE with respect to state.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot array containing the current value of the time derivative of the state vector\n+     * @param dFdY placeholder array where to put the jacobian of the ODE with respect to the state vector\n+     * @param dFdP placeholder array where to put the jacobian of the ODE with respect to the parameters\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP)\n+        throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/EnhancedFirstOrderIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class EnhancedFirstOrderIntegratorTest {\n+\n+    @Test\n+    public void testLowAccuracyExternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            brusselator.setParameter(0, b + hP);\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 600);\n+        Assert.assertTrue(residuals0.getStandardDeviation() > 30);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 800);\n+        Assert.assertTrue(residuals1.getStandardDeviation() > 50);\n+    }\n+\n+    @Test\n+    public void testHighAccuracyExternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            brusselator.setParameter(0, b + hP);\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 0.02);\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.03);\n+        Assert.assertTrue(residuals0.getStandardDeviation() > 0.003);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.004);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 0.04);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.05);\n+        Assert.assertTrue(residuals1.getStandardDeviation() > 0.006);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.007);\n+    }\n+\n+    @Test\n+    public void testInternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            brusselator.setParameter(0, b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[][] dZdP  = new double[2][1];\n+            double hY = 1.0e-12;\n+            EnhancedFirstOrderIntegrator extInt =\n+                new EnhancedFirstOrderIntegrator(integ, brusselator, new double[] { b },\n+                                                 new double[] { hY, hY }, new double[] { hP });\n+            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());\n+            residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.006);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.0009);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.006);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.0012);\n+    }\n+\n+    @Test\n+    public void testAnalyticalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            brusselator.setParameter(0, b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[][] dZdP  = new double[2][1];\n+            EnhancedFirstOrderIntegrator extInt =\n+                new EnhancedFirstOrderIntegrator(integ, brusselator);\n+            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());\n+            residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());\n+       }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.004);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.001);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.005);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.001);\n+    }\n+\n+    private static class Brusselator implements ParameterizedFirstOrderDifferentialEquationsWithPartials {\n+\n+        private double b;\n+\n+        public Brusselator(double b) {\n+            this.b = b;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void setParameter(int i, double p) {\n+            b = p;\n+        }\n+\n+        public int getParametersDimension() {\n+            return 1;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            double prod = y[0] * y[0] * y[1];\n+            yDot[0] = 1 + prod - (b + 1) * y[0];\n+            yDot[1] = b * y[0] - prod;\n+        }\n+\n+        public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {\n+            double p = 2 * y[0] * y[1];\n+            double y02 = y[0] * y[0];\n+            dFdY[0][0] = p - (1 + b);\n+            dFdY[0][1] = y02;\n+            dFdY[1][0] = b - p;\n+            dFdY[1][1] = -y02;\n+            dFdP[0][0] = -y[0];\n+            dFdP[1][0] = y[0];\n+        }\n+\n+        public double dYdP0() {\n+            return -1087.8787631970476 + (1050.4387741821572 + (-338.90621620263096 + 36.51793006801084 * b) * b) * b;\n+        }\n+\n+        public double dYdP1() {\n+            return 1499.0904666097015 + (-1434.9574631810726 + (459.71079478756945 - 49.29949940968588 * b) * b) * b;\n+        }\n+\n+    };\n+\n+}", "timestamp": 1267463267, "metainfo": ""}