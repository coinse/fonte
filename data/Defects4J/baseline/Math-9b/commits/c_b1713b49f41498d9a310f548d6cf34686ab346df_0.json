{"sha": "b1713b49f41498d9a310f548d6cf34686ab346df", "log": "MATH-396. Introducing \"PowellOptimizer\" which uses \"BracketFinder\". \"PowellOptimizerTest\" uses \"SumSincFunction\" which uses \"SincFunction\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.optimization.univariate.BracketFinder;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * Powell algorithm.\n+ * This code is translated and adapted from the Python version of this\n+ * algorithm (as implemented in module {@code optimize.py} v0.5 of\n+ * <em>SciPy</em>).\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class PowellOptimizer\n+    extends AbstractScalarOptimizer {\n+    /**\n+     * Defautl line search tolerance ({@value}).\n+     */\n+    public static final double DEFAULT_LINE_SEARCH_TOLERANCE = 1e-7;\n+    /**\n+     * Line search.\n+     */\n+    private final LineSearch line;\n+\n+    /**\n+     * Constructor using the default line search tolerance (see the\n+     * {@link #PowellOptimizer(double) other constructor}).\n+     */\n+    public PowellOptimizer() {\n+        this(DEFAULT_LINE_SEARCH_TOLERANCE);\n+    }\n+\n+    /**\n+     * @param lineSearchTolerance Relative error tolerance for the line search\n+     * algorithm ({@link BrentOptimizer}).\n+     */\n+    public PowellOptimizer(double lineSearchTolerance) {\n+        line = new LineSearch(lineSearchTolerance);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException,\n+               OptimizationException {\n+        final GoalType goal = getGoalType();\n+        final double[] guess = getStartPoint();\n+        final int n = guess.length;\n+        \n+        final double[][] direc = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+            direc[i][i] = 1;\n+        }\n+        \n+        double[] x = guess;\n+        double fVal = computeObjectiveValue(x);\n+        double[] x1 = x.clone();\n+        while (true) {\n+            incrementIterationsCounter();\n+            \n+            double fX = fVal;\n+            double fX2 = 0;\n+            double delta = 0;\n+            int bigInd = 0;\n+            double alphaMin = 0;\n+            \n+            double[] direc1 = new double[n];\n+            for (int i = 0; i < n; i++) {\n+                direc1 = direc[i];\n+            \n+                fX2 = fVal;\n+            \n+                line.search(x, direc1);\n+                fVal = line.getValueAtOptimum();\n+                alphaMin = line.getOptimum();\n+                setNewPointAndDirection(x, direc1, alphaMin);\n+       \n+                if ((fX2 - fVal) > delta) {\n+                    delta = fX2 - fVal;\n+                    bigInd = i;\n+                }\n+            }\n+\n+            final RealPointValuePair previous = new RealPointValuePair(x1, fX);\n+            final RealPointValuePair current = new RealPointValuePair(x, fVal);\n+            if (getConvergenceChecker().converged(getIterations(), previous, current)) {\n+                switch (goal) {\n+                case MINIMIZE:\n+                    return (fVal < fX ? current : previous);\n+                case MAXIMIZE:\n+                    return (fVal > fX ? current : previous);\n+                }\n+            }\n+            \n+            double[] x2 = new double[n];\n+            for (int i = 0; i < n; i++) {\n+                direc1[i] = x[i] - x1[i];\n+                x2[i] = 2 * x[i] - x1[i];\n+            }\n+\n+            x1 = x.clone();\n+            fX2 = computeObjectiveValue(x2);\n+\n+            if (fX > fX2) {\n+                double t = 2 * (fX + fX2 - 2 * fVal);\n+                double temp = fX - fVal - delta;\n+                t *= temp * temp;\n+                temp = fX - fX2;\n+                t -= delta * temp * temp;\n+\n+                if (t < 0.0) {\n+                    line.search(x, direc1);\n+                    fVal = line.getValueAtOptimum();\n+                    alphaMin = line.getOptimum();\n+                    setNewPointAndDirection(x, direc1, alphaMin);\n+                    \n+                    final int lastInd = n - 1;\n+                    direc[bigInd] = direc[lastInd];\n+                    direc[lastInd] = direc1;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compute a new point (in the original space) and a new direction\n+     * vector, resulting from the line search.\n+     * The parameters {@code p} and {@code d} will be changed in-place.\n+     *\n+     * @param p Point used in the line search.\n+     * @param d Direction used in the line search.\n+     * @param optimum Optimum found by the line search.\n+     */\n+    private void setNewPointAndDirection(double[] p,\n+                                         double[] d,\n+                                         double optimum) {\n+        final int n = p.length;\n+        for (int i = 0; i < n; i++) {\n+            d[i] *= optimum;\n+            p[i] += d[i];\n+        }\n+    }\n+\n+    /**\n+     * Class for finding the minimum of the objective function along a given\n+     * direction.\n+     */\n+    private class LineSearch {\n+        /**\n+         * Optimizer.\n+         */\n+        private final AbstractUnivariateRealOptimizer optim = new BrentOptimizer();\n+        /**\n+         * Automatic bracketing.\n+         */\n+        private final BracketFinder bracket = new BracketFinder();\n+        /**\n+         * Value of the optimum.\n+         */\n+        private double optimum = Double.NaN;\n+        /**\n+         * Value of the objective function at the optimum.\n+         */\n+        private double valueAtOptimum = Double.NaN;\n+\n+        /**\n+         * @param tolerance Relative tolerance.\n+         */\n+        public LineSearch(double tolerance) {\n+            optim.setRelativeAccuracy(tolerance);\n+            optim.setAbsoluteAccuracy(Math.ulp(1d));\n+        }\n+\n+        /**\n+         * Find the minimum of the function {@code f(p + alpha * d)}.\n+         *\n+         * @param p Starting point.\n+         * @param d Search direction.\n+         */\n+        public void search(final double[] p,\n+                           final double[] d)\n+            throws OptimizationException {\n+            try {\n+                final int n = p.length;\n+                final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                        public double value(double alpha)\n+                            throws FunctionEvaluationException {\n+\n+                            final double[] x = new double[n];\n+                            for (int i = 0; i < n; i++) {\n+                                x[i] = p[i] + alpha * d[i];\n+                            }\n+                            return computeObjectiveValue(x);\n+                        }\n+                    };\n+\n+                final GoalType goal = getGoalType();\n+                bracket.search(f, goal, 0, 1);\n+                optimum = optim.optimize(f, goal,\n+                                         bracket.getLo(),\n+                                         bracket.getHi(),\n+                                         bracket.getMid());\n+                valueAtOptimum = f.value(optimum);\n+            } catch (Exception e) {\n+                throw new OptimizationException(e);\n+            }\n+        }\n+\n+        /**\n+         * @return the optimum.\n+         */\n+        public double getOptimum() {\n+            return optimum;\n+        }\n+        /**\n+         * @return the value of the function at the optimum.\n+         */\n+        public double getValueAtOptimum() {\n+            return valueAtOptimum;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+/**\n+ * Provide an interval that brackets a local optimum of a function.\n+ * This code is based on a Python implementation (from <em>SciPy</em>,\n+ * module {@code optimize.py} v0.5).\n+ */\n+public class BracketFinder {\n+    private static final double EPS_MIN = 1e-21;\n+    /**\n+     * Golden section.\n+     */\n+    private static final double GOLD = 1.618034;\n+    /**\n+     * Factor for expanding the interval.\n+     */\n+    private final double growLimit;\n+    /**\n+     * Maximum number of iterations.\n+     */\n+    private final int maxIterations;\n+    /**\n+     * Number of iterations.\n+     */\n+    private int iterations;\n+    /**\n+     * Number of function evaluations.\n+     */\n+    private int evaluations;\n+    /**\n+     * Lower bound of the bracket.\n+     */\n+    private double lo;\n+    /**\n+     * Higher bound of the bracket.\n+     */\n+    private double hi;\n+    /**\n+     * Point inside the bracket.\n+     */\n+    private double mid;\n+    /**\n+     * Function value at {@link #lo}.\n+     */\n+    private double fLo;\n+    /**\n+     * Function value at {@link #hi}.\n+     */\n+    private double fHi;\n+    /**\n+     * Function value at {@link #mid}.\n+     */\n+    private double fMid;\n+\n+    /**\n+     * Constructor with default values {@code 100, 50} (see the\n+     * {@link #BracketFinder(double,int) other constructor}).\n+     */\n+    public BracketFinder() {\n+        this(100, 50);\n+    }\n+\n+    /**\n+     * Create a bracketing interval finder.\n+     *\n+     * @param growLimit Expanding factor.\n+     * @param maxIterations Maximum number of iterations allowed for finding\n+     * a bracketing interval.\n+     */\n+    public BracketFinder(double growLimit,\n+                         int maxIterations) {\n+        if (growLimit <= 0) {\n+            throw new NotStrictlyPositiveException(growLimit);\n+        }\n+        if (maxIterations <= 0) {\n+            throw new NotStrictlyPositiveException(maxIterations);\n+        }\n+\n+        this.growLimit = growLimit;\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Search new points that bracket a local optimum of the function.\n+     *\n+     * @param func Function whose optimum should be bracketted.\n+     * @param goal {@link GoalType Goal type}.\n+     * @param xA Initial point.\n+     * @param xB Initial point.\n+     */\n+    public void search(UnivariateRealFunction func,\n+                       GoalType goal,\n+                       double xA,\n+                       double xB)\n+        throws MaxIterationsExceededException,\n+               FunctionEvaluationException {\n+        reset();\n+        final boolean isMinim = (goal == GoalType.MINIMIZE);\n+\n+        double fA = eval(func, xA);\n+        double fB = eval(func, xB);\n+        if (isMinim ?\n+            fA < fB :\n+            fA > fB) {\n+            double tmp = xA;\n+            xA = xB;\n+            xB = tmp;\n+\n+            tmp = fA;\n+            fA = fB;\n+            fB = tmp;\n+        }\n+\n+        double xC = xB + GOLD * (xB - xA);\n+        double fC = eval(func, xC);\n+\n+        while (isMinim ? fC < fB : fC > fB) {\n+            if (++iterations > maxIterations) {\n+                throw new MaxIterationsExceededException(maxIterations);\n+            }\n+            \n+            double tmp1 = (xB - xA) * (fB - fC);\n+            double tmp2 = (xB - xC) * (fB - fA);\n+\n+            double val = tmp2 - tmp1;\n+            double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val;\n+\n+            double w = xB - ((xB - xC) * tmp2 - (xB -xA) * tmp1) / denom;\n+            double wLim = xB + growLimit * (xC - xB);\n+\n+            double fW;\n+            if ((w - xC) * (xB - w) > 0) {\n+                fW = eval(func, w);\n+                if (isMinim ?\n+                    fW < fC :\n+                    fW > fC) {\n+                    xA = xB;\n+                    xB = w;\n+                    fA = fB;\n+                    fB = fW;\n+                    break;\n+                } else if (isMinim ?\n+                           fW > fB :\n+                           fW < fB) {\n+                    xC = w;\n+                    fC = fW;\n+                    break;\n+                }\n+                w = xC + GOLD * (xC - xB);\n+                fW = eval(func, w);\n+            } else if ((w - wLim) * (wLim - xC) >= 0) {\n+                w = wLim;\n+                fW = eval(func, w);\n+            } else if ((w - wLim) * (xC - w) > 0) {\n+                fW = eval(func, w);\n+                if (isMinim ?\n+                    fW < fC :\n+                    fW > fC) {\n+                    xB = xC;\n+                    xC = w;\n+                    w = xC + GOLD * (xC -xB);\n+                    fB = fC;\n+                    fC =fW;\n+                    fW = eval(func, w);\n+                }\n+            } else {\n+                w = xC + GOLD * (xC - xB);\n+                fW = eval(func, w);\n+            }\n+\n+            xA = xB;\n+            xB = xC;\n+            xC = w;\n+            fA = fB;\n+            fB = fC;\n+            fC = fW;\n+        }\n+\n+        lo = xA;\n+        mid = xB;\n+        hi = xC;\n+        fLo = fA;\n+        fMid = fB;\n+        fHi = fC;\n+    }\n+\n+    /**\n+     * @return the number of iterations.\n+     */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+    /**\n+     * @return the number of evalutations.\n+     */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /**\n+     * @return the lower bound of the bracket.\n+     */\n+    public double getLo() {\n+        return lo;\n+    }\n+    /**\n+     * @return the higher bound of the bracket.\n+     */\n+    public double getHi() {\n+        return hi;\n+    }\n+    /**\n+     * @return a point in the middle of the bracket.\n+     */\n+    public double getMid() {\n+        return mid;\n+    }\n+\n+    /**\n+     * @param func Function.\n+     * @param x Argument.\n+     * @return {@code f(x)}\n+     */\n+    private double eval(UnivariateRealFunction f,\n+                        double x)\n+        throws FunctionEvaluationException {\n+\n+        ++evaluations;\n+        return f.value(x);\n+    }\n+\n+    /**\n+     * Reset internal state.\n+     */\n+    private void reset() {\n+        iterations = 0;\n+        evaluations = 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/SincFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxiliary class for testing optimizers.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SincFunction implements DifferentiableUnivariateRealFunction {\n+    private static final double EPS = 1e-12;\n+\n+    /**\n+     * @param x Argument.\n+     * @return the value of this function at point {@code x}.\n+     */\n+    public double value(double x) {\n+        return (Math.abs(x) < EPS ?\n+                1 :\n+                Math.sin(x) / x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) {\n+                return (Math.abs(x) < EPS ?\n+                        0 :\n+                        (x * Math.cos(x) - Math.sin(x)) / (x * x));\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxiliary class for testing optimizers.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SumSincFunction implements DifferentiableMultivariateRealFunction {\n+    private static final DifferentiableUnivariateRealFunction sinc = new SincFunction();\n+    private static final UnivariateRealFunction sincDeriv = sinc.derivative();\n+\n+    /**\n+     * Factor that will multiply each term of the sum.\n+     */\n+    private final double factor;\n+\n+    /**\n+     * @param factor Factor that will multiply each term of the sum.\n+     */\n+    public SumSincFunction(double factor) {\n+        this.factor = factor;\n+    }\n+\n+    /**\n+     * @param point Argument.\n+     * @return the value of this function at point {@code x}.\n+     */\n+    public double value(double[] point) throws FunctionEvaluationException {\n+        double sum = 0;\n+        for (int i = 0, max = point.length; i < max; i++) {\n+            final double x = point[i];\n+            final double v = sinc.value(x);\n+            sum += v;\n+        }\n+        return factor * sum;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public MultivariateRealFunction partialDerivative(final int k) {\n+        return new MultivariateRealFunction() {\n+            public double value(double[] point) throws FunctionEvaluationException {\n+                return sincDeriv.value(point[k]);\n+            }\n+        };\n+    }\n+\n+    /**                                                                            \n+     * {@inheritDoc}\n+     */\n+    public MultivariateVectorialFunction gradient() {\n+        return new MultivariateVectorialFunction() {\n+            public double[] value(double[] point)\n+                throws FunctionEvaluationException {\n+                final int n = point.length;\n+                final double[] r = new double[n];\n+                for (int i = 0; i < n; i++) {\n+                    final double x = point[i];\n+                    r[i] = factor * sincDeriv.value(x);\n+                }\n+                return r;\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.general;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.SumSincFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link PowellOptimizer}.\n+ */\n+public class PowellOptimizerTest {\n+\n+    @Test\n+    public void testSumSinc() throws MathException {\n+        final MultivariateRealFunction func = new SumSincFunction(-1);\n+\n+        int dim = 1;\n+        final double[] minPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            minPoint[i] = 0;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i];\n+        }\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-15, 1e-8);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i] + 4;\n+        }\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-15, 1e-8);\n+    }\n+\n+    @Test\n+    public void testQuadratic() throws MathException {\n+        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+                public double value(double[] x)\n+                    throws FunctionEvaluationException {\n+                    final double a = x[0] - 1;\n+                    final double b = x[1] - 1;\n+                    return a * a + b * b + 1;\n+                }\n+            };\n+\n+        int dim = 2;\n+        final double[] minPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            minPoint[i] = 1;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i];\n+        }\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-15, 1e-8);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = minPoint[i] - 20;\n+        }\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-15, 1e-8);\n+    }\n+\n+    @Test\n+    public void testMaximizeQuadratic() throws MathException {\n+        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+                public double value(double[] x)\n+                    throws FunctionEvaluationException {\n+                    final double a = x[0] - 1;\n+                    final double b = x[1] - 1;\n+                    return -a * a - b * b + 1;\n+                }\n+            };\n+\n+        int dim = 2;\n+        final double[] maxPoint = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            maxPoint[i] = 1;\n+        }\n+\n+        double[] init = new double[dim];\n+\n+        // Initial is minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = maxPoint[i];\n+        }\n+        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-15, 1e-8);\n+\n+        // Initial is far from minimum.\n+        for (int i = 0; i < dim; i++) {\n+            init[i] = maxPoint[i] - 20;\n+        }\n+        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-15, 1e-8);\n+    }\n+\n+    /**\n+     * @param func Function to optimize.\n+     * @param optimum Expected optimum.\n+     * @param init Starting point.\n+     * @param goal Minimization or maximization.\n+     * @param objTol Tolerance (relative error on the objective function).\n+     * @param pointTol Tolerance on the position of the optimum.\n+     */\n+    private void doTest(MultivariateRealFunction func,\n+                        double[] optimum,\n+                        double[] init,\n+                        GoalType goal,\n+                        double objTol,\n+                        double pointTol)\n+        throws MathException {\n+        final MultivariateRealOptimizer optim = new PowellOptimizer();\n+        final double relTol = 1e-10;\n+        optim.setConvergenceChecker(new SimpleScalarValueChecker(objTol, -1));\n+\n+        final RealPointValuePair result = optim.optimize(func, goal, init);\n+        final double[] found = result.getPoint();\n+\n+        for (int i = 0, dim = optimum.length; i < dim; i++) {\n+            Assert.assertEquals(optimum[i], found[i], pointTol);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BracketFinderTest {\n+\n+    @Test\n+    public void testCubicMin() throws MathException {\n+        final BracketFinder bFind = new BracketFinder();\n+        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+                public double value(double x)\n+                    throws FunctionEvaluationException {\n+                    if (x < -2) {\n+                        return value(-2);\n+                    }\n+                    else  {\n+                        return (x - 1) * (x + 2) * (x + 3);\n+                    }\n+                }\n+            };\n+\n+        bFind.search(func, GoalType.MINIMIZE, -2 , -1);\n+        final double tol = 1e-15;\n+        // Comparing with results computed in Python.\n+        Assert.assertEquals(-2, bFind.getLo(), tol);\n+        Assert.assertEquals(-1, bFind.getMid(), tol);\n+        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);\n+    }\n+\n+    @Test\n+    public void testCubicMax() throws MathException {\n+        final BracketFinder bFind = new BracketFinder();\n+        final UnivariateRealFunction func = new UnivariateRealFunction() {\n+                public double value(double x)\n+                    throws FunctionEvaluationException {\n+                    if (x < -2) {\n+                        return value(-2);\n+                    }\n+                    else  {\n+                        return -(x - 1) * (x + 2) * (x + 3);\n+                    }\n+                }\n+            };\n+\n+        bFind.search(func, GoalType.MAXIMIZE, -2 , -1);\n+        final double tol = 1e-15;\n+        Assert.assertEquals(-2, bFind.getLo(), tol);\n+        Assert.assertEquals(-1, bFind.getMid(), tol);\n+        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);\n+    }\n+}", "timestamp": 1280180852, "metainfo": ""}