{"sha": "f8160b492a15067239220b5f42a25743f498bfeb", "log": "In transform.FastSineTransformer, replaced the pair transform2() / inverseTransform2() with two factory methods: create() and createOrthogonal() (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  * @since 1.2\n  */\n public class FastSineTransformer implements RealTransformer {\n-\n-    /** Construct a default transformer. */\n-    public FastSineTransformer() {\n-        super();\n-    }\n-\n-    /**\n-     * Transform the given real data set.\n+    /**\n+     * {@code true} if the orthogonal version of the DCT should be used.\n+     *\n+     * @see #create()\n+     * @see #createOrthogonal()\n+     */\n+    private final boolean orthogonal;\n+\n+    /**\n+     * Creates a new instance of this class, with various normalization\n+     * conventions.\n+     *\n+     * @param orthogonal {@code false} if the DST is <em>not</em> to be scaled,\n+     * {@code true} if it is to be scaled so as to make the transform\n+     * orthogonal.\n+     * @see #create()\n+     * @see #createOrthogonal()\n+     */\n+    private FastSineTransformer(final boolean orthogonal) {\n+        this.orthogonal = orthogonal;\n+    }\n+\n+    /**\n      * <p>\n-     * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> sin(&pi; nk / N),</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = (2 / N) &sum;<sub>n=0</sub><sup>N-1</sup>\n+     * y<sub>n</sub> sin(&pi; nk / N),</li>\n+     * </ul>\n+     * where N is the size of the data sample.\n      * </p>\n      *\n-     * @param f the real data array to be transformed\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(double[] f)\n+     * @return a new DST transformer, with \"standard\" normalizing conventions\n+     */\n+    public static FastSineTransformer create() {\n+        return new FastSineTransformer(false);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = &radic;(2 / N) &sum;<sub>k=0</sub><sup>N-1</sup>\n+     * x<sub>k</sub> sin(&pi; nk / N),</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = &radic;(2 / N) &sum;<sub>n=0</sub><sup>N-1</sup>\n+     * y<sub>n</sub> sin(&pi; nk / N),</li>\n+     * </ul>\n+     * which make the transform orthogonal. N is the size of the data sample.\n+     * </p>\n+     *\n+     * @return a new DST transformer, with \"orthogonal\" normalizing conventions\n+     */\n+    public static FastSineTransformer createOrthogonal() {\n+        return new FastSineTransformer(true);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The first element of the specified data set is required to be {@code 0}.\n+     */\n+    public double[] transform(double[] f) throws IllegalArgumentException {\n+        if (orthogonal){\n+            final double s = FastMath.sqrt(2.0 / f.length);\n+            return FastFourierTransformer.scaleArray(fst(f), s);\n+        }\n+        return fst(f);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.\n+     */\n+    public double[] transform(UnivariateFunction f,\n+        double min, double max, int n) throws IllegalArgumentException {\n+\n+        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        if (orthogonal) {\n+            final double s = FastMath.sqrt(2.0 / n);\n+            return FastFourierTransformer.scaleArray(fst(data), s);\n+        }\n+        return fst(data);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The first element of the specified data set is required to be {@code 0}.\n+     */\n+    public double[] inverseTransform(double[] f)\n         throws IllegalArgumentException {\n-        return fst(f);\n-    }\n-\n-    /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform(UnivariateFunction f,\n-                              double min, double max, int n)\n+\n+        if (orthogonal) {\n+            return transform(f);\n+        }\n+        final double s = 2.0 / f.length;\n+        return FastFourierTransformer.scaleArray(fst(f), s);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.\n+     */\n+    public double[] inverseTransform(UnivariateFunction f,\n+        double min, double max, int n)\n         throws IllegalArgumentException {\n \n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        if (orthogonal) {\n+            return transform(f, min, max, n);\n+        }\n+\n+        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n-        return fst(data);\n-    }\n-\n-    /**\n-     * Transform the given real data set.\n-     * <p>\n-     * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the real data array to be transformed\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(double[] f) throws IllegalArgumentException {\n-\n-        double scalingCoefficient = FastMath.sqrt(2.0 / f.length);\n-        return FastFourierTransformer.scaleArray(fst(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(\n-        UnivariateFunction f, double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n-        data[0] = 0.0;\n-        double scalingCoefficient = FastMath.sqrt(2.0 / n);\n-        return FastFourierTransformer.scaleArray(fst(data), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform(double[] f) throws IllegalArgumentException {\n-\n-        double scalingCoefficient = 2.0 / f.length;\n-        return FastFourierTransformer.scaleArray(fst(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform(UnivariateFunction f, double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n-        data[0] = 0.0;\n-        double scalingCoefficient = 2.0 / n;\n-        return FastFourierTransformer.scaleArray(fst(data), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform2(double[] f) throws IllegalArgumentException {\n-\n-        return transform2(f);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform2(UnivariateFunction f, double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        return transform2(f, min, max, n);\n-    }\n-\n-    /**\n-     * Perform the FST algorithm (including inverse).\n+        final double s = 2.0 / n;\n+\n+        return FastFourierTransformer.scaleArray(fst(data), s);\n+    }\n+\n+    /**\n+     * Perform the FST algorithm (including inverse). The first element of the\n+     * data set is required to be {@code 0}.\n      *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n      */\n     @Test\n     public void testAdHocData() {\n-        FastSineTransformer transformer = new FastSineTransformer();\n+        FastSineTransformer transformer = FastSineTransformer.create();\n         double result[], tolerance = 1E-12;\n \n         double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };\n         }\n \n         FastFourierTransformer.scaleArray(x, FastMath.sqrt(x.length / 2.0));\n+        transformer = FastSineTransformer.createOrthogonal();\n \n-        result = transformer.transform2(y);\n+        result = transformer.transform(y);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform2(x);\n+        result = transformer.inverseTransform(x);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        FastSineTransformer transformer = new FastSineTransformer();\n+        FastSineTransformer transformer = FastSineTransformer.create();\n         double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n \n         min = 0.0; max = 2.0 * FastMath.PI;\n     @Test\n     public void testParameters() throws Exception {\n         UnivariateFunction f = new SinFunction();\n-        FastSineTransformer transformer = new FastSineTransformer();\n+        FastSineTransformer transformer = FastSineTransformer.create();\n \n         try {\n             // bad interval", "timestamp": 1323674363, "metainfo": ""}