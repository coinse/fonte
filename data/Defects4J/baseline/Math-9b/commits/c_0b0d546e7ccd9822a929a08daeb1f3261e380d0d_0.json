{"sha": "0b0d546e7ccd9822a929a08daeb1f3261e380d0d", "log": "MATH-795: SparseRealVectorTest now uses RealVectorAbstractTest.RealVectorTestImpl instead of SparseRealVectorTest.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java\n  */\n package org.apache.commons.math3.linear;\n \n-import java.io.Serializable;\n-import java.util.Iterator;\n-\n-import org.apache.commons.math3.analysis.UnivariateFunction;\n-import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n  */\n public class SparseRealVectorTest extends RealVectorAbstractTest {\n \n-    // Testclass to test the RealVector interface\n-    // only with enough content to support the test\n-    public static class SparseRealVectorTestImpl extends RealVector implements Serializable {\n-\n-        private static final long serialVersionUID = -6251371752518113791L;\n-        /** Entries of the vector. */\n-        protected double data[];\n-\n-        public SparseRealVectorTestImpl(double[] d) {\n-            data = d.clone();\n-        }\n-\n-        private UnsupportedOperationException unsupported() {\n-            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n-        }\n-\n-        @Override\n-        public RealVector map(UnivariateFunction function) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapToSelf(UnivariateFunction function) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public Iterator<Entry> iterator() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector copy() {\n-            return new SparseRealVectorTestImpl(data);\n-        }\n-\n-        @Override\n-        public RealVector add(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-\n-        @Override\n-        public RealVector subtract(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAdd(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAddToSelf(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSubtract(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSubtractToSelf(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapMultiply(double d) {\n-            double[] out = new double[data.length];\n-            for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] * d;\n-            }\n-            return new OpenMapRealVector(out);\n-        }\n-\n-        @Override\n-        public RealVector mapMultiplyToSelf(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapDivide(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapDivideToSelf(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector ebeMultiply(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector ebeDivide(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double dotProduct(RealVector v) {\n-            double dot = 0;\n-            for (int i = 0; i < data.length; i++) {\n-                dot += data[i] * v.getEntry(i);\n-            }\n-            return dot;\n-        }\n-\n-        @Override\n-        public double getNorm() {\n-            double sqrNorm = 0.0;\n-            for (int i = 0; i < data.length; i++) {\n-                sqrNorm += data[i] * data[i];\n-            }\n-            return FastMath.sqrt(sqrNorm);\n-        }\n-\n-        @Override\n-        public double getL1Norm() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getLInfNorm() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getDistance(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getL1Distance(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getLInfDistance(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector unitVector() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void unitize() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealMatrix outerProduct(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double getEntry(int index) {\n-            return data[index];\n-        }\n-\n-        @Override\n-        public int getDimension() {\n-            return data.length;\n-        }\n-\n-        @Override\n-        public RealVector append(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector append(double d) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector getSubVector(int index, int n) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void setEntry(int index, double value) {\n-            data[index] = value;\n-        }\n-\n-        @Override\n-        public void setSubVector(int index, RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void set(double value) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public double[] toArray() {\n-            return data.clone();\n-        }\n-\n-        @Override\n-        public boolean isNaN() {\n-            boolean isNaN = false;\n-            for (int i = 0; i < data.length; i++) {\n-                isNaN |= Double.isNaN(data[i]);\n-            }\n-            return isNaN;\n-        }\n-\n-        @Override\n-        public boolean isInfinite() {\n-            boolean isInfinite = false;\n-            for (int i = 0; i < data.length; i++) {\n-                final double x = data[i];\n-                if (Double.isNaN(x)) {\n-                    return false;\n-                }\n-                isInfinite |= Double.isInfinite(x);\n-            }\n-            return isInfinite;\n-        }\n-    }\n-\n     @Override\n     public RealVector create(double[] data) {\n         return new OpenMapRealVector(data);\n \n     @Override\n     public RealVector createAlien(double[] data) {\n-        return new SparseRealVectorTestImpl(data);\n+        return new RealVectorTestImpl(data);\n     }\n \n     @Test\n         Assert.assertEquals(\"testData len\", 7, v7.getDimension());\n         Assert.assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6), 0);\n \n-        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);\n+        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n \n         OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);\n         Assert.assertEquals(\"testData len\", 3, v7_2.getDimension());", "timestamp": 1341599351, "metainfo": ""}