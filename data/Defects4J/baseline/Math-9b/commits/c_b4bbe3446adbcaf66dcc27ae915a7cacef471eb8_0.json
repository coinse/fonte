{"sha": "b4bbe3446adbcaf66dcc27ae915a7cacef471eb8", "log": "improved javadoc, mainly explaining the underlying conventions with quaternions Jira: MATH-363  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Rotation.java\n  * user can build a rotation from any of these representations, and\n  * any of these representations can be retrieved from a\n  * <code>Rotation</code> instance (see the various constructors and\n- * getters). In addition, a rotation can also be built implicitely\n+ * getters). In addition, a rotation can also be built implicitly\n  * from a set of vectors and their image.</p>\n  * <p>This implies that this class can be used to convert from one\n  * representation to another one. For example, converting a rotation\n  * matrix into a set of Cardan angles from can be done using the\n- * followong single line of code:</p>\n+ * following single line of code:</p>\n  * <pre>\n  * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n  * </pre>\n  * meaning of these vectors may vary and the semantics of the rotation also.</p>\n  * <p>For example in an spacecraft attitude simulation tool, users will often\n  * consider the vectors are fixed (say the Earth direction for example) and the\n- * rotation transforms the coordinates coordinates of this vector in inertial\n+ * frames change. The rotation transforms the coordinates of the vector in inertial\n  * frame into the coordinates of the same vector in satellite frame. In this\n- * case, the rotation implicitely defines the relation between the two frames.\n- * Another example could be a telescope control application, where the rotation\n+ * case, the rotation implicitly defines the relation between the two frames.</p>\n+ * <p>Another example could be a telescope control application, where the rotation\n  * would transform the sighting direction at rest into the desired observing\n  * direction when the telescope is pointed towards an object of interest. In this\n- * case the rotation transforms the directionf at rest in a topocentric frame\n- * into the sighting direction in the same topocentric frame. In many case, both\n- * approaches will be combined, in our telescope example, we will probably also\n- * need to transform the observing direction in the topocentric frame into the\n- * observing direction in inertial frame taking into account the observatory\n- * location and the Earth rotation.</p>\n+ * case the rotation transforms the direction at rest in a topocentric frame\n+ * into the sighting direction in the same topocentric frame. This implies in this\n+ * case the frame is fixed and the vector moves.</p>\n+ * <p>In many case, both approaches will be combined. In our telescope example,\n+ * we will probably also need to transform the observing direction in the topocentric\n+ * frame into the observing direction in inertial frame taking into account the observatory\n+ * location and the Earth rotation, which would essentially be an application of the\n+ * first approach.</p>\n  *\n- * <p>These examples show that a rotation is what the user wants it to be, so this\n+ * <p>These examples show that a rotation is what the user wants it to be. This\n  * class does not push the user towards one specific definition and hence does not\n  * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n  * <code>computeTransformedDirection</code>. It provides simpler and more generic\n    * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n    * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n    * the constructor can normalize it in a preprocessing step.</p>\n+   * <p>Note that some conventions put the scalar part of the quaternion\n+   * as the 4<sup>th</sup> component and the vector part as the first three\n+   * components. This is <em>not</em> our convention. We put the scalar part\n+   * as the first component.</p>\n    * @param q0 scalar part of the quaternion\n    * @param q1 first coordinate of the vectorial part of the quaternion\n    * @param q2 second coordinate of the vectorial part of the quaternion\n    * <p>We use the convention that angles are oriented according to\n    * the effect of the rotation on vectors around the axis. That means\n    * that if (i, j, k) is a direct frame and if we first provide +k as\n-   * the axis and PI/2 as the angle to this constructor, and then\n+   * the axis and &pi;/2 as the angle to this constructor, and then\n    * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n    * +j.</p>\n+   * <p>Another way to represent our convention is to say that a rotation\n+   * of angle &theta; about the unit vector (x, y, z) is the same as the\n+   * rotation build from quaternion components { cos(-&theta;/2),\n+   * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n+   * Note the minus sign on the angle!</p>\n+   * <p>On the one hand this convention is consistent with a vectorial\n+   * perspective (moving vectors in fixed frames), on the other hand it\n+   * is different from conventions with a frame perspective (fixed vectors\n+   * viewed from different frames) like the ones used for example in spacecraft\n+   * attitude community or in the graphics community.</p>\n    * @param axis axis around which to rotate\n    * @param angle rotation angle.\n    * @exception ArithmeticException if the axis norm is zero\n \n   /** Get the normalized axis of the rotation.\n    * @return normalized axis of the rotation\n+   * @see #Rotation(Vector3D, double)\n    */\n   public Vector3D getAxis() {\n     double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n \n   /** Get the angle of the rotation.\n    * @return angle of the rotation (between 0 and &pi;)\n+   * @see #Rotation(Vector3D, double)\n    */\n   public double getAngle() {\n     if ((q0 < -0.1) || (q0 > 0.1)) {", "timestamp": 1270986862, "metainfo": ""}