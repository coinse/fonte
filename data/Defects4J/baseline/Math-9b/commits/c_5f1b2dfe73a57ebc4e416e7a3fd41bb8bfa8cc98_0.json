{"sha": "5f1b2dfe73a57ebc4e416e7a3fd41bb8bfa8cc98", "log": "MATH-867 Previous commit was missing a crucial modification (in the \"repair\" method), an inconsistency which entailed the failing of some tests. With that modification (thanks to Nikolaus Hansen), it was established that the \"encode\" and \"decode\" steps were indeed useless. This commit thus removes them, and all the code that was necessary only because of those two methods. Finite and infinite can now be freely mixed. Unit tests that depended on those limitations were also removed (thus also the one that was added following MATH-865).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n     private boolean isActiveCMA;\n     /**\n      * Determines how often a new random offspring is generated in case it is\n-     * not feasible / beyond the defined limits, default is 0. Only relevant if\n-     * boundaries != null.\n+     * not feasible / beyond the defined limits, default is 0.\n      */\n     private int checkFeasableCount;\n     /**\n-     * Lower and upper boundaries of the objective variables. boundaries == null\n-     * means no boundaries.\n+     * Lower and upper boundaries of the objective variables.\n      */\n     private double[][] boundaries;\n     /**\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         final FitnessFunction fitfun = new FitnessFunction();\n-        final double[] guess = fitfun.encode(getStartPoint());\n+        final double[] guess = getStartPoint();\n         // number of objective variables/problem dimension\n         dimension = guess.length;\n         initializeCMA(guess);\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                            fitfun.repair(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n         final double[] lB = getLowerBound();\n         final double[] uB = getUpperBound();\n \n-        // Checks whether there is at least one finite bound value.\n-        boolean hasFiniteBounds = false;\n-        for (int i = 0; i < lB.length; i++) {\n-            if (!Double.isInfinite(lB[i]) ||\n-                !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n-                break;\n-            }\n-        }\n-        // Checks whether there is at least one infinite bound value.\n-        boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n-            for (int i = 0; i < lB.length; i++) {\n-                if (Double.isInfinite(lB[i]) ||\n-                    Double.isInfinite(uB[i])) {\n-                    hasInfiniteBounds = true;\n-                    break;\n-                }\n-            }\n-\n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n-                // Convert API to internal handling of boundaries.\n-                boundaries = new double[2][];\n-                boundaries[0] = lB;\n-                boundaries[1] = uB;\n-\n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n-            }\n-        } else {\n-            // Convert API to internal handling of boundaries.\n-            boundaries = null;\n-        }\n+        // Convert API to internal handling of boundaries.\n+        boundaries = new double[2][];\n+        boundaries[0] = lB;\n+        boundaries[1] = uB;\n \n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n                 }\n-                if (boundaries != null) {\n-                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n-                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n-                    }\n+                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n+                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                 }\n             }\n         }\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n         for (int i = 0; i < guess.length; i++) {\n-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            sigmaArray[i][0] = inputSigma == null ? 0.3 : inputSigma[i];\n         }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n         }\n \n         /**\n-         * @param x Original objective variables.\n-         * @return the normalized objective variables.\n-         */\n-        public double[] encode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n-            }\n-            return res;\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables, possibly repaired.\n-         */\n-        public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n-                decode(x);\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables.\n-         */\n-        public double[] decode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n-            }\n-            return res;\n-        }\n-\n-        /**\n          * @param point Normalized objective variables.\n          * @return the objective value + penalty for violated bounds.\n          */\n         public double value(final double[] point) {\n             double value;\n-            if (boundaries != null && isRepairMode) {\n+            if (isRepairMode) {\n                 double[] repaired = repair(point);\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(repaired)) +\n+                        .computeObjectiveValue(repaired) +\n                         penalty(point, repaired);\n             } else {\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(point));\n+                        .computeObjectiveValue(point);\n             }\n             return isMinimize ? value : -value;\n         }\n          * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n-            if (boundaries == null) {\n-                return true;\n-            }\n-\n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n-\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < boundaries[0][i]) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > boundaries[1][i]) {\n                     return false;\n                 }\n             }\n          * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n-            double[] repaired = new double[x.length];\n+            final double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n-                    repaired[i] = 0;\n-                } else if (x[i] > 1.0) {\n-                    repaired[i] = 1.0;\n+                if (x[i] < boundaries[0][i]) {\n+                    repaired[i] = boundaries[0][i];\n+                } else if (x[i] > boundaries[1][i]) {\n+                    repaired[i] = boundaries[1][i];\n                 } else {\n                     repaired[i] = x[i];\n                 }\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n                 1e-13, 1e-6, 100000, expected);\n     }\n \n-    @Test(expected = MathUnsupportedOperationException.class)\n-    public void testUnsupportedBoundaries1() {\n-        double[] startPoint = point(DIM,0.5);\n-        double[] insigma = null;\n-        double[][] boundaries = boundaries(DIM,-1, Double.POSITIVE_INFINITY);\n-        PointValuePair expected =\n-            new PointValuePair(point(DIM,1.0),0.0);\n-        doTest(new Rosen(), startPoint, insigma, boundaries,\n-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n-                1e-13, 1e-6, 100000, expected);\n-    }\n-\n-    @Test(expected = MathUnsupportedOperationException.class)\n-    public void testUnsupportedBoundaries2() {\n-        double[] startPoint = point(DIM, 0.5);\n-        double[] insigma = null;\n-        final double[] lB = new double[] { -1, -1, -1, -1, -1, Double.NEGATIVE_INFINITY, -1, -1, -1, -1, -1, -1, -1 };\n-        final double[] uB = new double[] { 2, 2, 2, Double.POSITIVE_INFINITY, 2, 2, 2, 2, 2, 2, 2, 2, 2 };\n-        double[][] boundaries = new double[2][];\n-        boundaries[0] = lB;\n-        boundaries[1] = uB;\n-        PointValuePair expected =\n-            new PointValuePair(point(DIM,1.0),0.0);\n-        doTest(new Rosen(), startPoint, insigma, boundaries,\n-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n-                1e-13, 1e-6, 100000, expected);\n-    }\n-\n     @Test(expected = NotPositiveException.class)\n     public void testInputSigmaNegative() {\n         double[] startPoint = point(DIM,0.5);\n     }\n \n     @Test\n+    public void testCigarWithBoundaries() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[] insigma = point(DIM,0.1);\n+        double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Cigar(), startPoint, insigma, boundaries,\n+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n+                1e-13, 1e-6, 200000, expected);\n+        doTest(new Cigar(), startPoint, insigma, boundaries,\n+                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n+                1e-13, 1e-6, 100000, expected);\n+    }\n+\n+    @Test\n     public void testTwoAxes() {\n         double[] startPoint = point(DIM,1.0);\n         double[] insigma = point(DIM,0.1);\n \n     @Test\n     public void testConstrainedRosen() {\n-        double[] startPoint = point(DIM, 0.7);\n+        double[] startPoint = point(DIM, 0.1);\n         double[] insigma = point(DIM, 0.1);\n         double[][] boundaries = boundaries(DIM, -1, 2);\n         PointValuePair expected =\n                                                    start, lower, upper).getPoint();\n         Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\n                           result[0] <= upper[0]);\n-    }\n-\n-    /**\n-     * Cf. MATH-865\n-     */\n-    @Test(expected=NumberIsTooLargeException.class)\n-    public void testBoundaryRangeTooLarge() {\n-        final CMAESOptimizer optimizer = new CMAESOptimizer();\n-        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n-                public double value(double[] parameters) {\n-                    if (Double.isNaN(parameters[0])) {\n-                        throw new MathIllegalStateException();\n-                    }\n-                    final double target = 1;\n-                    final double error = target - parameters[0];\n-                    return error * error;\n-                }\n-            };\n-\n-        final double[] start = { 0 };\n-\n-        // The difference between upper and lower bounds is used to normalize\n-        // the variables: In case of overflow, NaN is produced.\n-        final double max = Double.MAX_VALUE / 2;\n-        final double tooLarge = FastMath.nextUp(max);\n-        final double[] lower = { -tooLarge };\n-        final double[] upper = { tooLarge };\n-        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n-                                                   start, lower, upper).getPoint();\n     }\n \n     /**", "timestamp": 1348957098, "metainfo": ""}