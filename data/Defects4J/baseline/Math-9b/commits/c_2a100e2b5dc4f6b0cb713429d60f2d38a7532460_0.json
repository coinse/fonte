{"sha": "2a100e2b5dc4f6b0cb713429d60f2d38a7532460", "log": "Added Pascal distribution implementation. JIRA: MATH-148 Contributed by Joni Salonen   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * An interface to classes that implement a algorithm to calculate the \n+ * QR-decomposition of a real matrix.\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ */\n+public interface QRDecomposition {\n+\n+    /**\n+     * Returns the matrix R of the decomposition. \n+     */\n+    public abstract RealMatrix getR();\n+\n+    /**\n+     * Returbs the matrix Q of the decomposition.\n+     */\n+    public abstract RealMatrix getQ();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Calculates the QR-decomposition of a matrix. In the QR-decomposition of\n+ * a matrix A consists of two matrices Q and R that satisfy: A = QR, Q is\n+ * orthogonal (Q<sup>T</sup>Q = I), and R is upper triangular. If A is\n+ * m&times;n, Q is m&times;m and R m&times;n. \n+ * <p>\n+ * Implemented using Householder reflectors.\n+ *\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ */\n+public class QRDecompositionImpl implements QRDecomposition {\n+\n+    /**\n+     * A packed representation of the QR decomposition. The elements above the \n+     * diagonal are the elements of R, and the columns of the lower triangle \n+     * are the Householder reflector vectors of which an explicit form of Q can\n+     * be calculated. \n+     */\n+    private double[][] qr;\n+\n+    /**\n+     * The diagonal elements of R.\n+     */\n+    private double[] rDiag;\n+\n+    /**\n+     * The row dimension of the given matrix. The size of Q will be m x m, the \n+     * size of R will be m x n. \n+     */\n+    private int m;\n+\n+    /**\n+     * The column dimension of the given matrix. The size of R will be m x n. \n+     */\n+    private int n;\n+\n+    /**\n+     * Calculates the QR decomposition of the given matrix. \n+     * \n+     * @param matrix The matrix to factorize.\n+     */\n+    public QRDecompositionImpl(RealMatrix matrix) {\n+        m = matrix.getRowDimension();\n+        n = matrix.getColumnDimension();\n+        qr = matrix.getData();\n+        rDiag = new double[n];\n+\n+        /*\n+         * The QR decomposition of a matrix A is calculated using Householder\n+         * reflectors by repeating the following operations to each minor\n+         * A(minor,minor) of A:\n+         */\n+        for (int minor = 0; minor < Math.min(m, n); minor++) {\n+            /*\n+             * Let x be the first column of the minor, and a^2 = |x|^2.\n+             * x will be in the positions qr[minor][minor] through qr[m][minor].\n+             * The first column of the transformed minor will be (a,0,0,..)'\n+             * The sign of a is chosen to be opposite to the sign of the first\n+             * component of x. Let's find a:\n+             */\n+            double xNormSqr = 0;\n+            for (int row = minor; row < m; row++) {\n+                xNormSqr += qr[row][minor]*qr[row][minor];\n+            }\n+            double a = Math.sqrt(xNormSqr);\n+            if (qr[minor][minor] > 0) a = -a;\n+            rDiag[minor] = a;\n+\n+            if (a != 0.0) {\n+\n+                /*\n+                 * Calculate the normalized reflection vector v and transform\n+                 * the first column. We know the norm of v beforehand: v = x-ae\n+                 * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =\n+                 * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).\n+                 * Here <x, e> is now qr[minor][minor].\n+                 * v = x-ae is stored in the column at qr:\n+                 */\n+                qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+\n+                /*\n+                 * Transform the rest of the columns of the minor:\n+                 * They will be transformed by the matrix H = I-2vv'/|v|^2.\n+                 * If x is a column vector of the minor, then\n+                 * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n+                 * Therefore the transformation is easily calculated by\n+                 * subtracting the column vector (2<x,v>/|v|^2)v from x.\n+                 * \n+                 * Let 2<x,v>/|v|^2 = alpha. From above we have\n+                 * |v|^2 = -2a*(qr[minor][minor]), so\n+                 * alpha = -<x,v>/(a*qr[minor][minor])\n+                 */\n+                for (int col = minor+1; col < n; col++) {\n+                    double alpha = 0;\n+                    for (int row = minor; row < m; row++) {\n+                        alpha -= qr[row][col]*qr[row][minor];\n+                    }\n+                    alpha /= a*qr[minor][minor];\n+\n+                    // Subtract the column vector alpha*v from x.\n+                    for (int row = minor; row < m; row++) {\n+                        qr[row][col] -= alpha*qr[row][minor];\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the matrix R of the QR-decomposition. \n+     */\n+    public RealMatrix getR()\n+    {\n+        // R is supposed to be m x n\n+        RealMatrixImpl ret = new RealMatrixImpl(m,n);\n+        double[][] r = ret.getDataRef();\n+\n+        // copy the diagonal from rDiag and the upper triangle of qr\n+        for (int row = Math.min(m,n)-1; row >= 0; row--) {\n+            r[row][row] = rDiag[row];\n+            for (int col = row+1; col < n; col++) {\n+                r[row][col] = qr[row][col];\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the matrix Q of the QR-decomposition.\n+     */\n+    public RealMatrix getQ()\n+    {\n+        // Q is supposed to be m x m\n+        RealMatrixImpl ret = new RealMatrixImpl(m,m);\n+        double[][] Q = ret.getDataRef();\n+\n+        /* \n+         * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n+         * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n+         * succession to the result \n+         */ \n+        for (int minor = m-1; minor >= Math.min(m,n); minor--) {\n+            Q[minor][minor]=1;\n+        }\n+\n+        for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n+            Q[minor][minor] = 1;\n+            if (qr[minor][minor] != 0.0) {\n+                for (int col = minor; col < m; col++) {\t\t\t\t\n+                    double alpha = 0;\n+                    for (int row = minor; row < m; row++) {\n+                        alpha -= Q[row][col] * qr[row][minor];\n+                    }\n+                    alpha /= rDiag[minor]*qr[minor][minor];\n+\n+                    for (int row = minor; row < m; row++) {\n+                        Q[row][col] -= alpha*qr[row][minor];\n+                    }\n+                }\n+            }\n+        }\n+\n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class QRDecompositionImplTest extends TestCase {\n+    double[][] testData3x3NonSingular = { \n+            { 12, -51, 4 }, \n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    double[][] testData3x3Singular = { \n+            { 1, 4, 7, }, \n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    double[][] testData3x4 = { \n+            { 12, -51, 4, 1 }, \n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    double[][] testData4x3 = { \n+            { 12, -51, 4, }, \n+            { 6, 167, -68, },\n+            { -4, 24, -41, }, \n+            { -5, 34, 7, }, };\n+\n+    final double entryTolerance = 10e-16;\n+\n+    final double normTolerance = 10e-14;\n+\n+    public QRDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(QRDecompositionImplTest.class);\n+        suite.setName(\"QRDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        QRDecomposition qr = new QRDecompositionImpl(matrix);\n+        assertEquals(\"3x3 Q size\", qr.getQ().getRowDimension(), 3);\n+        assertEquals(\"3x3 Q size\", qr.getQ().getColumnDimension(), 3);\n+        assertEquals(\"3x3 R size\", qr.getR().getRowDimension(), 3);\n+        assertEquals(\"3x3 R size\", qr.getR().getColumnDimension(), 3);\n+\n+        matrix = new RealMatrixImpl(testData4x3);\n+        qr = new QRDecompositionImpl(matrix);\n+        assertEquals(\"4x3 Q size\", qr.getQ().getRowDimension(), 4);\n+        assertEquals(\"4x3 Q size\", qr.getQ().getColumnDimension(), 4);\n+        assertEquals(\"4x3 R size\", qr.getR().getRowDimension(), 4);\n+        assertEquals(\"4x3 R size\", qr.getR().getColumnDimension(), 3);\n+\n+        matrix = new RealMatrixImpl(testData3x4);\n+        qr = new QRDecompositionImpl(matrix);\n+        assertEquals(\"3x4 Q size\", qr.getQ().getRowDimension(), 3);\n+        assertEquals(\"3x4 Q size\", qr.getQ().getColumnDimension(), 3);\n+        assertEquals(\"3x4 R size\", qr.getR().getRowDimension(), 3);\n+        assertEquals(\"3x4 R size\", qr.getR().getColumnDimension(), 4);\n+    }\n+\n+    /** test A = QR */\n+    public void testAEqualQR() {\n+        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);\n+        QRDecomposition qr = new QRDecompositionImpl(A);\n+        RealMatrix Q = qr.getQ();\n+        RealMatrix R = qr.getR();\n+        double norm = Q.multiply(R).subtract(A).getNorm();\n+        assertEquals(\"3x3 nonsingular A = QR\", 0, norm, normTolerance);\n+\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);\n+        qr = new QRDecompositionImpl(matrix);\n+        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n+        assertEquals(\"3x3 singular A = QR\", 0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x4);\n+        qr = new QRDecompositionImpl(matrix);\n+        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n+        assertEquals(\"3x4 A = QR\", 0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testData4x3);\n+        qr = new QRDecompositionImpl(matrix);\n+        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n+        assertEquals(\"4x3 A = QR\", 0, norm, normTolerance);\n+    }\n+\n+    /** test the orthogonality of Q */\n+    public void testQOrthogonal() {\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        matrix = new QRDecompositionImpl(matrix).getQ();\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n+        double norm = matrix.transpose().multiply(matrix).subtract(eye)\n+                .getNorm();\n+        assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x3Singular);\n+        matrix = new QRDecompositionImpl(matrix).getQ();\n+        eye = MatrixUtils.createRealIdentityMatrix(3);\n+        norm = matrix.transpose().multiply(matrix).subtract(eye)\n+                .getNorm();\n+        assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new QRDecompositionImpl(matrix).getQ();\n+        eye = MatrixUtils.createRealIdentityMatrix(3);\n+        norm = matrix.transpose().multiply(matrix).subtract(eye)\n+                .getNorm();\n+        assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new QRDecompositionImpl(matrix).getQ();\n+        eye = MatrixUtils.createRealIdentityMatrix(4);\n+        norm = matrix.transpose().multiply(matrix).subtract(eye)\n+                .getNorm();\n+        assertEquals(\"4x3 Q'Q = I\", 0, norm, normTolerance);\n+    }\n+\n+    /** test that R is upper triangular */\n+    public void testRUpperTriangular() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrix R = new QRDecompositionImpl(matrix).getR();\n+        for (int i = 0; i < R.getRowDimension(); i++)\n+            for (int j = 0; j < i; j++)\n+                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n+                        entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x4);\n+        R = new QRDecompositionImpl(matrix).getR();\n+        for (int i = 0; i < R.getRowDimension(); i++)\n+            for (int j = 0; j < i; j++)\n+                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n+                        entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData4x3);\n+        R = new QRDecompositionImpl(matrix).getR();\n+        for (int i = 0; i < R.getRowDimension(); i++)\n+            for (int j = 0; j < i; j++)\n+                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n+                        entryTolerance);\n+    }\n+}", "timestamp": 1149470884, "metainfo": ""}