{"sha": "0a0085f61c203112d4950f8a1db4ca83553ea344", "log": "Enforced bounds on quantile, improved javadoc.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n /**\n  * Provides percentile computation.\n  * <p>\n- * There are several commonly used methods for estimating percentiles (a.k.a. quantiles) based\n- * on sample data.  For large samples, the different methods agree closely, but when sample sizes\n- * are small, different methods will give significantly different results.  The implementation provided here\n- * follows the first estimation procedure presented\n- * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n- * \n- * @version $Revision: 1.19 $ $Date: 2004/05/19 14:16:32 $\n+ * There are several commonly used methods for estimating percentiles (a.k.a. \n+ * quantiles) based on sample data.  For large samples, the different methods \n+ * agree closely, but when sample sizes are small, different methods will give\n+ * significantly different results.  The algorithm implemented here works as follows:\n+ * <ol>\n+ * <li>Let <code>n</code> be the length of the (sorted) array and \n+ * <code>0 < p <= 100</code> be the desired percentile.</li>\n+ * <li>If <code> n = 1 </code> return the unique array element (regardless of \n+ * the value of <code>p</code>); otherwise </li>\n+ * <li>Compute the estimated percentile position  \n+ * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>\n+ * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional\n+ * part of <code>pos</code>).  If <code>pos >= n</code> return the largest\n+ * element in the array; otherwise</li>\n+ * <li>Let <code>lower</code> be the element in position \n+ * <code>floor(pos)</code> in the array and let <code>upper</code> be the\n+ * next element in the array.  Return <code>lower + d * (upper - lower)</code>\n+ * </li>\n+ * </ol>\n+ * <p>\n+ * \n+ * To compute percentiles, the data must be (totally) ordered.  Input arrays\n+ * are copied and then sorted using  {@link java.util.Arrays#sort(double[])}.\n+ * The ordering used by <code>Arrays.sort(double[]</code> is the one determined\n+ * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes \n+ * <code>Double.NaN</code> larger than any other value (including \n+ * <code>Double.POSITIVE_INFINITY</code>).  Therefore, for example, the median\n+ * (50th percentile) of  \n+ * <code>{0, 1, 2, 3, 4, Double.NaN}</code> evaluates to <code>2.5.</code>  \n+ * <p>\n+ * Since percentile estimation usually involves interpolation between array \n+ * elements, arrays containing  <code>NaN</code> or infinite values will often\n+ * result in <code>NaN<code> or infinite values returned.\n+ * \n+ * @version $Revision: 1.20 $ $Date: 2004/06/19 21:14:54 $\n  */\n public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = -8091216485095130416L; \n        \n-    /** Determines what percentile is computed when evaluate() is activated with no quantile argument */\n+    /** Determines what percentile is computed when evaluate() is activated \n+     * with no quantile argument */\n     private double quantile = 0.0;\n \n     /**\n     /**\n      * Constructs a Percentile with the specific quantile value.\n      * @param p the quantile\n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n      */\n     public Percentile(final double p) {\n-        this.quantile = p;\n+        setQuantile(p);\n     }\n \n     /**\n      * Calls to this method do not modify the internal <code>quantile</code>\n      * state of this statistic.\n      * <p>\n-     * See {@link Percentile} for a description of the percentile estimation algorithm used.\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <code>0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n+     *  if <code>values</code> has length <code>1</code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     *  is null </li>\n+     * </ul>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     *  algorithm used.\n      * \n      * @param values Is a double[] containing the values\n      * @param p Is the quantile to evaluate to.\n-     * @return the result of the evaluation or Double.NaN\n-     * if the array is empty\n+     * @return the result of the evaluation or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if <code>values</code> is null\n      */\n     public double evaluate(final double[] values, final double p) {\n         test(values, 0, 0);\n     }\n \n     /**\n-     * Returns an estimate of the <code>quantile</code>th percentile of the values\n-     * in the <code>values</code> array.  The quantile estimated is determined by\n-     * the <code>quantile</code> property.\n-     * <p>\n-     * See {@link Percentile} for a description of the percentile estimation algorithm used.\n+     * Returns an estimate of the <code>quantile</code>th percentile of the\n+     * values in the <code>values</code> array.  The quantile estimated is\n+     * determined by the <code>quantile</code> property.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>quantile</code>) \n+     * <code>values[begin]</code> if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null,  or <code>start</code> or <code>length</code> \n+     * is invalid</li>\n+     * </ul>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.\n      * \n      * @param values  array of input values\n      * @param start  the first (0-based) element to include in the computation\n      * @param length  the number of array elements to include\n-     * @return the result of the evaluation or Double.NaN\n-     * if the array is empty\n-     * \n-     */\n-    public double evaluate(\n-        final double[] values,\n-        final int start,\n-        final int length) {\n-\n+     * @return the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     * \n+     */\n+    public double evaluate( final double[] values, final int start, final int length) {\n         return evaluate(values, start, length, quantile);\n     }\n \n      * Calls to this method do not modify the internal <code>quantile</code>\n      * state of this statistic.\n      * <p>\n-      * See {@link Percentile} for a description of the percentile estimation algorithm used.\n-     * \n-     * @param values Is a double[] containing the values\n-     * @param p Is the quantile to evaluate to.\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n+     *  if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     * <code>p</code> is not a valid quantile value</li>\n+     * </ul>\n+     * <p>\n+      * See {@link Percentile} for a description of the percentile estimation\n+      * algorithm used.\n+     * \n+     * @param values array of input values\n+     * @param p  the percentile to compute\n      * @param begin  the first (0-based) element to include in the computation\n      * @param length  the number of array elements to include\n-     * @return the result of the evaluation or Double.NaN\n-     * if the array is empty\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         quantile.\n-     */\n-    public double evaluate(\n-        final double[] values,\n-        final int begin,\n-        final int length,\n-        final double p) {\n+     * @return  the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, \n+            final int length, final double p) {\n \n         test(values, begin, length);\n \n         if ((p > 100) || (p <= 0)) {\n-            throw new IllegalArgumentException(\"invalid quantile value\");\n+            throw new IllegalArgumentException(\"invalid quantile value: \" + p);\n         }\n         double n = (double) length;\n         if (n == 0) {\n     }\n \n     /**\n-     * Returns the value of the quantile field (determines what percentile is computed when evaluate()\n-     * is called with no quantile argument)\n+     * Returns the value of the quantile field (determines what percentile is\n+     * computed when evaluate() is called with no quantile argument).\n      * \n      * @return quantile\n      */\n     }\n \n     /**\n-     * Sets the value of the quantile field (determines what percentile is computed when evaluate()\n-     * is called with no quantile argument)\n-     * \n-     * @param p a value between 0 <= p <= 100 \n+     * Sets the value of the quantile field (determines what percentile is \n+     * computed when evaluate() is called with no quantile argument).\n+     * \n+     * @param p a value between 0 < p <= 100 \n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n      */\n     public void setQuantile(final double p) {\n+        if (p <= 0 || p > 100) {\n+            throw new IllegalArgumentException(\"Illegal quantile value: \" + p);\n+        }\n         quantile = p;\n     }\n ", "timestamp": 1087679694, "metainfo": ""}