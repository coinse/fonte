{"sha": "39e2ad8af8fdedac51144158061cb31e7863c3a1", "log": "Singular Value Decomposition now computes either the compact SVD (using only positive singular values) or truncated SVD (using a user-specified maximal number of singular values). Fixed Singular Value Decomposition solving of singular systems. JIRA: MATH-320, MATH-321   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    ei1 = eData[i + 1];\n-                    for (int j = 0; j < p; ++j) {\n-                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    if (i < n - 1) {\n+                        ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n+                        for (int j = 0; j < p; ++j) {\n+                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                        }\n+                    } else {\n+                        for (int j = 0; j < p; ++j) {\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n                     }\n                 }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n-                for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n-                }\n+\n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n                 }\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    ei1 = eData[i + 1];\n-                    for (int j = 0; j < p; ++j) {\n-                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    if (i < m - 1) {\n+                        ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n+                        for (int j = 0; j < p; ++j) {\n+                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                        }\n+                    } else {\n+                        for (int j = 0; j < p; ++j) {\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n                     }\n-                }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n-                for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n     }\n \n     @Test\n+    public void testTruncated() {\n+\n+        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n+            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n+        });\n+        double s439  = Math.sqrt(439.0);\n+        double[] reference = new double[] {\n+            Math.sqrt(3.0 * (21.0 + s439))\n+        };\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(rm, 1);\n+\n+        // check we get the expected theoretical singular values\n+        double[] singularValues = svd.getSingularValues();\n+        Assert.assertEquals(reference.length, singularValues.length);\n+        for (int i = 0; i < reference.length; ++i) {\n+            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n+        }\n+\n+        // check the truncated decomposition DON'T allows to recover the original matrix\n+        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n+        Assert.assertTrue(recomposed.subtract(rm).getNorm() > 1.4);\n+\n+    }\n+\n+    @Test\n     public void testMath320A() {\n         RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n             { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n         };\n         SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(rm);\n+\n+        // check we get the expected theoretical singular values\n         double[] singularValues = svd.getSingularValues();\n+        Assert.assertEquals(reference.length, singularValues.length);\n         for (int i = 0; i < reference.length; ++i) {\n             Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n         }\n-        regularElements(svd.getU());\n-        regularElements(svd.getVT());\n-//        double[] b = new double[] { 5.0, 6.0, 7.0 };\n-//        double[] resSVD = svd.getSolver().solve(b);\n-//        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n-//        System.out.println(\"resSVD = \" + resSVD[0] + \" \" + resSVD[1] + \" \" + resSVD[2]);\n-//        double minResidual = Double.POSITIVE_INFINITY;\n-//        double d0Min = Double.NaN;\n-//        double d1Min = Double.NaN;\n-//        double d2Min = Double.NaN;\n-//        double h = 0.01;\n-//        int    k = 100;\n-//        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n-//            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n-//                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n-//                    double[] f = rm.operate(new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 });\n-//                    double residual = Math.sqrt((f[0] - b[0]) * (f[0] - b[0]) +\n-//                                                (f[1] - b[1]) * (f[1] - b[1]) +\n-//                                                (f[2] - b[2]) * (f[2] - b[2]));\n-//                    if (residual < minResidual) {\n-//                        d0Min = d0;\n-//                        d1Min = d1;\n-//                        d2Min = d2;\n-//                        minResidual = residual;\n-//                    }\n-//                }\n-//            }\n-//        }\n-//        System.out.println(d0Min + \" \" + d1Min + \" \" + d2Min + \" -> \" + minResidual);\n-//        Assert.assertEquals(0, d0Min, 1.0e-15);\n-//        Assert.assertEquals(0, d1Min, 1.0e-15);\n-//        Assert.assertEquals(0, d2Min, 1.0e-15);\n-    }\n-\n+\n+        // check the decomposition allows to recover the original matrix\n+        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n+        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n+\n+        // check we can solve a singular system\n+        double[] b = new double[] { 5.0, 6.0, 7.0 };\n+        double[] resSVD = svd.getSolver().solve(b);\n+        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n+\n+        // check the solution really minimizes the residuals\n+        double svdMinResidual = residual(rm, resSVD, b);\n+        double epsilon = 2 * Math.ulp(svdMinResidual);\n+        double h = 0.1;\n+        int    k = 3;\n+        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n+            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n+                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n+                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n+                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n+                }\n+            }\n+        }\n+\n+    }\n \n     @Test\n     public void testMath320B() {\n         });\n         SingularValueDecomposition svd =\n             new SingularValueDecompositionImpl(rm);\n-        regularElements(svd.getU());\n-        regularElements(svd.getVT());\n-    }\n-\n-    private void regularElements(RealMatrix m) {\n-        for (int i = 0; i < m.getRowDimension(); ++i) {\n-            for (int j = 0; j < m.getColumnDimension(); ++j) {\n-                double mij = m.getEntry(i, j);\n-                Assert.assertFalse(Double.isInfinite(mij));\n-                Assert.assertFalse(Double.isNaN(mij));\n-            }\n-        }\n+        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n+        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n+    }\n+\n+    private double residual(RealMatrix a, double[] x, double[] b) {\n+        double[] ax = a.operate(x);\n+        double sum = 0;\n+        for (int i = 0; i < ax.length; ++i) {\n+            sum += (ax[i] - b[i]) * (ax[i] - b[i]);\n+        }\n+        return Math.sqrt(sum);\n     }\n \n }", "timestamp": 1262281936, "metainfo": ""}