{"sha": "255364ac1f6434c1a429433931980145adc181ce", "log": "MATH-438 Removed deprecated methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n public class BisectionSolver extends UnivariateRealSolverImpl {\n \n     /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve.\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public BisectionSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n      * Construct a solver.\n      *\n      */\n     public BisectionSolver() {\n         super(100, 1E-6);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(double min, double max, double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(double min, double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n     private static final long serialVersionUID = 7694577816772532779L;\n \n     /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve.\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public BrentSolver(UnivariateRealFunction f) {\n-        super(f, DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n      * Construct a solver with default properties.\n      */\n     public BrentSolver() {\n      */\n     public BrentSolver(int maximumIterations, double absoluteAccuracy) {\n         super(maximumIterations, absoluteAccuracy);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(double min, double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(double min, double max, double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max, initial);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n  */\n public class LaguerreSolver extends UnivariateRealSolverImpl {\n \n-    /** polynomial function to solve.\n-     * @deprecated as of 2.0 the function is not stored anymore in the instance\n-     */\n-    @Deprecated\n-    private final PolynomialFunction p;\n-\n-    /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve\n-     * @throws IllegalArgumentException if function is not polynomial\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public LaguerreSolver(UnivariateRealFunction f) throws\n-        IllegalArgumentException {\n-        super(f, 100, 1E-6);\n-        if (f instanceof PolynomialFunction) {\n-            p = (PolynomialFunction) f;\n-        } else {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_POLYNOMIAL);\n-        }\n-    }\n-\n     /**\n      * Construct a solver.\n      */\n     public LaguerreSolver() {\n         super(100, 1E-6);\n-        p = null;\n-    }\n-\n-    /**\n-     * Returns a copy of the polynomial function.\n-     *\n-     * @return a fresh copy of the polynomial function\n-     * @deprecated as of 2.0 the function is not stored anymore within the instance.\n-     */\n-    @Deprecated\n-    public PolynomialFunction getPolynomialFunction() {\n-        return new PolynomialFunction(p.getCoefficients());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(p, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max, final double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(p, min, max, initial);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n public class MullerSolver extends UnivariateRealSolverImpl {\n \n     /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public MullerSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n      * Construct a solver.\n      */\n     public MullerSolver() {\n         super(100, 1E-6);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max, final double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max, initial);\n     }\n \n     /**\n      * <p>\n      * The formulas here do not use divided differences directly.</p>\n      *\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     * @deprecated replaced by {@link #solve2(UnivariateRealFunction, double, double)}\n-     * since 2.0\n-     */\n-    @Deprecated\n-    public double solve2(final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve2(f, min, max);\n-    }\n-\n-    /**\n-     * Find a real root in the given interval.\n-     * <p>\n-     * solve2() differs from solve() in the way it avoids complex operations.\n-     * Except for the initial [min, max], solve2() does not require bracketing\n-     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n-     * number arises in the computation, we simply use its modulus as real\n-     * approximation.</p>\n-     * <p>\n-     * Because the interval may not be bracketing, bisection alternative is\n-     * not applicable here. However in practice our treatment usually works\n-     * well, especially near real zeros where the imaginary part of complex\n-     * approximation is often negligible.</p>\n-     * <p>\n-     * The formulas here do not use divided differences directly.</p>\n-     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n public class NewtonSolver extends UnivariateRealSolverImpl {\n \n     /**\n-     * Construct a solver for the given function.\n-     * @param f function to solve.\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public NewtonSolver(DifferentiableUnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n      * Construct a solver.\n      */\n     public NewtonSolver() {\n         super(100, 1E-6);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max)\n-        throws MaxIterationsExceededException,\n-        FunctionEvaluationException  {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max, final double startValue)\n-        throws MaxIterationsExceededException, FunctionEvaluationException  {\n-        return solve(f, min, max, startValue);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n public class RiddersSolver extends UnivariateRealSolverImpl {\n \n     /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public RiddersSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n      * Construct a solver.\n      */\n     public RiddersSolver() {\n         super(100, 1E-6);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max, final double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max, initial);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n public class SecantSolver extends UnivariateRealSolverImpl {\n \n     /**\n-     * Construct a solver for the given function.\n-     * @param f function to solve.\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    public SecantSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n      * Construct a solver.\n      */\n     public SecantSolver() {\n         super(100, 1E-6);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Deprecated\n-    public double solve(final double min, final double max, final double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n-        return solve(f, min, max, initial);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.</p>\n      *\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @return a value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if min > max or the endpoints do not\n-     * satisfy the requirements specified by the solver\n-     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double)}\n-     * since 2.0\n-     */\n-    @Deprecated\n-    double solve(double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException;\n-\n-    /**\n-     * Solve for a zero root in the given interval.\n-     * <p>A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.</p>\n-     *\n      * @param f the function to solve.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n     double solve(UnivariateRealFunction f, double min, double max)\n         throws ConvergenceException,\n         FunctionEvaluationException;\n-\n-    /**\n-     * Solve for a zero in the given interval, start at startValue.\n-     * <p>A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.</p>\n-     *\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param startValue the start value to use\n-     * @return a value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if min > max or the arguments do not\n-     * satisfy the requirements specified by the solver\n-     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double, double)}\n-     * since 2.0\n-     */\n-    @Deprecated\n-    double solve(double min, double max, double startValue)\n-        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n \n     /**\n      * Solve for a zero in the given interval, start at startValue.\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n     /** Value of the function at the last computed result. */\n     protected double functionValue;\n \n-    /** The function to solve.\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method. */\n-    @Deprecated\n-    protected UnivariateRealFunction f;\n-\n-    /**\n-     * Construct a solver with given iteration count and accuracy.\n-     *\n-     * @param f the function to solve.\n-     * @param defaultAbsoluteAccuracy maximum absolute error\n-     * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the\n-     * defaultAbsoluteAccuracy is not valid\n-     * @deprecated as of 2.0 the function to solve is passed as an argument\n-     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n-     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n-     * method.\n-     */\n-    @Deprecated\n-    protected UnivariateRealSolverImpl(final UnivariateRealFunction f,\n-                                       final int defaultMaximalIterationCount,\n-                                       final double defaultAbsoluteAccuracy) {\n-        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n-        if (f == null) {\n-            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n-        }\n-        this.f = f;\n-        this.defaultFunctionValueAccuracy = 1.0e-15;\n-        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n-    }\n-\n     /**\n      * Construct a solver with given iteration count and accuracy.\n      *\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n  * @version $Revision$ $Date$\n  */\n public final class BisectionSolverTest extends TestCase {\n-\n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        double result;\n-\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        result = solver.solve(3, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(1, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-    }\n \n     public void testSinZero() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n \n     public BrentSolverTest(String name) {\n         super(name);\n-    }\n-\n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n-        // The sinus function is behaved well around the root at #pi. The second\n-        // order derivative is zero, which means linar approximating methods will\n-        // still converge quadratically.\n-        UnivariateRealFunction f = new SinFunction();\n-        double result;\n-        UnivariateRealSolver solver = new BrentSolver(f);\n-        // Somewhat benign interval. The function is monotone.\n-        result = solver.solve(3, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 4 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 5);\n-        // Larger and somewhat less benign interval. The function is grows first.\n-        result = solver.solve(1, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        solver = new SecantSolver(f);\n-        result = solver.solve(3, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 4 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 5);\n-        result = solver.solve(1, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        assertEquals(result, solver.getResult(), 0);\n     }\n \n     public void testSinZero() throws MathException {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n  * @version $Revision$ $Date$\n  */\n public final class LaguerreSolverTest extends TestCase {\n-\n-    /**\n-     * Test deprecated APIs.\n-     */\n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n-        double min, max, expected, result, tolerance;\n-\n-        // p(x) = 4x - 1\n-        double coefficients[] = { -1.0, 4.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n-\n-        min = 0.0; max = 1.0; expected = 0.25;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n \n     /**\n      * Test of solver for the linear function.\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n public final class MullerSolverTest extends TestCase {\n \n     /**\n-     * Test deprecated APIs.\n-     */\n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = FastMath.PI;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test deprecated APIs.\n-     */\n-    @Deprecated\n-    public void testDeprecated2() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        MullerSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n      * Test of solver for the sine function.\n      */\n     public void testSinFunction() throws MathException {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n  */\n public final class NewtonSolverTest extends TestCase {\n \n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n+    /**\n+     *\n+     */\n+    public void testSinZero() throws MathException {\n         DifferentiableUnivariateRealFunction f = new SinFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new NewtonSolver(f);\n-        result = solver.solve(3, 4);\n+        UnivariateRealSolver solver = new NewtonSolver();\n+        result = solver.solve(f, 3, 4);\n         assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(1, 4);\n+        result = solver.solve(f, 1, 4);\n         assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         assertEquals(result, solver.getResult(), 0);\n     }\n \n     /**\n-    *\n-    */\n-   public void testSinZero() throws MathException {\n-       DifferentiableUnivariateRealFunction f = new SinFunction();\n-       double result;\n-\n-       UnivariateRealSolver solver = new NewtonSolver();\n-       result = solver.solve(f, 3, 4);\n-       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-\n-       result = solver.solve(f, 1, 4);\n-       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-\n-       assertEquals(result, solver.getResult(), 0);\n-       assertTrue(solver.getIterationCount() > 0);\n-   }\n-\n-   /**\n      *\n      */\n     public void testQuinticZero() throws MathException {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n  * @version $Revision$ $Date$\n  */\n public final class RiddersSolverTest extends TestCase {\n-\n-    /**\n-     * Test the deprecated APIs.\n-     */\n-    @Deprecated\n-    public void testDeprecated() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = FastMath.PI;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n \n     /**\n      * Test of solver for the sine function.", "timestamp": 1289687254, "metainfo": ""}