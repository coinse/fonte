{"sha": "85b6aa6a9d3979f73697e6a6e939b61a9b4543da", "log": "MATH-854: fill the \"throws\" clause of ArrayFieldVector.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n \n     /**\n      * Build a 0-length vector.\n-     * Zero-length vectors may be used to initialized construction of vectors\n+     * Zero-length vectors may be used to initialize construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #ArrayFieldVector(ArrayFieldVector, ArrayFieldVector)} constructor\n      * or one of the {@code append} methods ({@link #add(FieldVector)} or\n      * @throws ZeroException if {@code d} is empty.\n      * @see #ArrayFieldVector(Field, FieldElement[])\n      */\n-    public ArrayFieldVector(T[] d) {\n+    public ArrayFieldVector(T[] d)\n+            throws NullArgumentException, ZeroException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #ArrayFieldVector(FieldElement[])\n      */\n-    public ArrayFieldVector(Field<T> field, T[] d) {\n+    public ArrayFieldVector(Field<T> field, T[] d)\n+            throws NullArgumentException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(FieldElement[])\n      * @see #ArrayFieldVector(Field, FieldElement[], boolean)\n      */\n-    public ArrayFieldVector(T[] d, boolean copyArray) {\n+    public ArrayFieldVector(T[] d, boolean copyArray)\n+            throws NullArgumentException, ZeroException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n             throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n         field = d[0].getField();\n-        data = copyArray ? d.clone() :  d;\n+        data = copyArray ? d.clone() : d;\n     }\n \n     /**\n      * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #ArrayFieldVector(FieldElement[], boolean)\n      */\n-    public ArrayFieldVector(Field<T> field, T[] d, boolean copyArray) {\n+    public ArrayFieldVector(Field<T> field, T[] d, boolean copyArray)\n+            throws NullArgumentException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NumberIsTooLargeException if the size of {@code d} is less\n      * than {@code pos + size}.\n      */\n-    public ArrayFieldVector(T[] d, int pos, int size) {\n+    public ArrayFieldVector(T[] d, int pos, int size)\n+            throws NullArgumentException, NumberIsTooLargeException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NumberIsTooLargeException if the size of {@code d} is less\n      * than {@code pos + size}.\n      */\n-    public ArrayFieldVector(Field<T> field, T[] d, int pos, int size) {\n+    public ArrayFieldVector(Field<T> field, T[] d, int pos, int size)\n+            throws NullArgumentException, NumberIsTooLargeException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @param v Vector to copy.\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n-    public ArrayFieldVector(FieldVector<T> v) {\n+    public ArrayFieldVector(FieldVector<T> v)\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * @param v Vector to copy.\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n-    public ArrayFieldVector(ArrayFieldVector<T> v) {\n+    public ArrayFieldVector(ArrayFieldVector<T> v)\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * a shallow copy\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n-    public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep) {\n+    public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep)\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code v1} or {@code v2} is\n      * {@code null}.\n      */\n-    public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2) {\n-        if (v1 == null ||\n-            v2 == null) {\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2)\n+            throws NullArgumentException {\n+        if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n         field = v1.getField();\n      * @throws NullArgumentException if {@code v1} or {@code v2} is\n      * {@code null}.\n      */\n-    public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2) {\n-        if (v1 == null ||\n-            v2 == null) {\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2)\n+            throws NullArgumentException {\n+        if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n         field = v1.getField();\n      * @throws NullArgumentException if {@code v1} or {@code v2} is\n      * {@code null}.\n      */\n-    public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2) {\n-        if (v1 == null ||\n-            v2 == null) {\n+    public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2)\n+            throws NullArgumentException {\n+        if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n         field = v2.getField();\n      * @throws ZeroException if both arrays are empty.\n      * @see #ArrayFieldVector(Field, FieldElement[], FieldElement[])\n      */\n-    public ArrayFieldVector(T[] v1, T[] v2) {\n-        if (v1 == null ||\n-            v2 == null) {\n+    public ArrayFieldVector(T[] v1, T[] v2)\n+            throws NullArgumentException, ZeroException {\n+        if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n         if (v1.length + v2.length == 0) {\n      * @throws ZeroException if both arrays are empty.\n      * @see #ArrayFieldVector(FieldElement[], FieldElement[])\n      */\n-    public ArrayFieldVector(Field<T> field, T[] v1, T[] v2) {\n+    public ArrayFieldVector(Field<T> field, T[] v1, T[] v2)\n+            throws NullArgumentException, ZeroException {\n+        if (v1 == null || v2 == null) {\n+            throw new NullArgumentException();\n+        }\n         if (v1.length + v2.length == 0) {\n             throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> add(FieldVector<T> v) {\n+    public FieldVector<T> add(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return add((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /**\n-     * Compute the sum of this and v.\n+     * Compute the sum of {@code this} and {@code v}.\n      * @param v vector to be added\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayFieldVector<T> add(ArrayFieldVector<T> v) {\n+     * @return {@code this + v}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public ArrayFieldVector<T> add(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(FieldVector<T> v) {\n+    public FieldVector<T> subtract(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return subtract((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /**\n-     * Compute this minus v.\n+     * Compute {@code this} minus {@code v}.\n      * @param v vector to be subtracted\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v) {\n+     * @return {@code this - v}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(FieldVector<T> v) {\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return ebeMultiply((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     /**\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v) {\n+     * @return a vector containing {@code this[i] * v[i]} for all {@code i}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(FieldVector<T> v) {\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return ebeDivide((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v) {\n+     * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(FieldVector<T> v) {\n+    public T dotProduct(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return dotProduct((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     /**\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    public T dotProduct(ArrayFieldVector<T> v) {\n+     * @return the scalar dot product of {@code this} and {@code v}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public T dotProduct(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n         T dot = field.getZero();\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> projection(FieldVector<T> v) {\n+    public FieldVector<T> projection(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n \n-   /** Find the orthogonal projection of this vector onto another vector.\n-     * @param v vector onto which instance must be projected\n-     * @return projection of the instance onto v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v) {\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which {@code this} must be projected\n+     * @return projection of {@code this} onto {@code v}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v)\n+        throws DimensionMismatchException {\n         return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n \n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n-     * @return the square matrix outer product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @return the matrix outer product between instance and v\n      */\n     public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {\n         final int m = data.length;\n      *\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @throws OutOfRangeException if the index is\n-     * inconsistent with vector size\n-     */\n-    public void set(int index, ArrayFieldVector<T> v) {\n+     * @throws OutOfRangeException if the index is invalid.\n+     */\n+    public void set(int index, ArrayFieldVector<T> v) throws OutOfRangeException {\n         try {\n             System.arraycopy(v.data, 0, data, index, v.data.length);\n         } catch (IndexOutOfBoundsException e) {\n     /**\n      * Check if instance and specified vectors have the same dimension.\n      * @param v vector to compare instance with\n-     * @exception IllegalArgumentException if the vectors do not\n-     * have the same dimension\n-     */\n-    protected void checkVectorDimensions(FieldVector<T> v) {\n+     * @exception DimensionMismatchException if the vectors do not\n+     * have the same dimensions\n+     */\n+    protected void checkVectorDimensions(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n     }\n \n      * Check if instance dimension is equal to some expected value.\n      *\n      * @param n Expected dimension.\n-     * @throws OutOfRangeException if the dimension is\n-     * inconsistent with this vector size.\n-     */\n-    protected void checkVectorDimensions(int n) {\n+     * @throws DimensionMismatchException if the dimension is not equal to the\n+     * size of {@code this} vector.\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws DimensionMismatchException {\n         if (data.length != n) {\n             throw new DimensionMismatchException(data.length, n);\n         }\n      * @param index Index to check.\n      * @exception OutOfRangeException if the index is not valid.\n      */\n-    private void checkIndex(final int index) {\n+    private void checkIndex(final int index) throws OutOfRangeException {\n         if (index < 0 || index >= getDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.INDEX,\n                                           index, 0, getDimension() - 1);", "timestamp": 1347303954, "metainfo": ""}