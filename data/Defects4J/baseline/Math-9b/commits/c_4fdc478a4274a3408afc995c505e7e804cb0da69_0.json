{"sha": "4fdc478a4274a3408afc995c505e7e804cb0da69", "log": "Added throw declarations for package util.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n+++ b/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n      * as an {@code int}.\n      * @since 1.1\n      */\n-    public static int addAndCheck(int x, int y) {\n+    public static int addAndCheck(int x, int y)\n+            throws MathArithmeticException {\n         long s = (long)x + (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n             throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n      *         long\n      * @since 1.2\n      */\n-    public static long addAndCheck(long a, long b) {\n+    public static long addAndCheck(long a, long b) throws MathArithmeticException {\n         return ArithmeticUtils.addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n     }\n \n      * @throws MathArithmeticException if the result is too large to be\n      * represented by a long integer.\n      */\n-    public static long binomialCoefficient(final int n, final int k) {\n+    public static long binomialCoefficient(final int n, final int k)\n+        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n         ArithmeticUtils.checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 1;\n      * @return {@code n choose k}\n      * @throws NotPositiveException if {@code n < 0}.\n      * @throws NumberIsTooLargeException if {@code k > n}.\n-     */\n-    public static double binomialCoefficientDouble(final int n, final int k) {\n+     * @throws MathArithmeticException if the result is too large to be\n+     * represented by a long integer.\n+     */\n+    public static double binomialCoefficientDouble(final int n, final int k)\n+        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n         ArithmeticUtils.checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 1d;\n      * @return {@code n choose k}\n      * @throws NotPositiveException if {@code n < 0}.\n      * @throws NumberIsTooLargeException if {@code k > n}.\n-     */\n-    public static double binomialCoefficientLog(final int n, final int k) {\n+     * @throws MathArithmeticException if the result is too large to be\n+     * represented by a long integer.\n+     */\n+    public static double binomialCoefficientLog(final int n, final int k)\n+        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n         ArithmeticUtils.checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 0;\n      * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n      * large to fit in a {@code long}.\n      */\n-    public static long factorial(final int n) {\n+    public static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n         if (n < 0) {\n             throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                            n);\n      * @return {@code n!}\n      * @throws NotPositiveException if {@code n < 0}.\n      */\n-    public static double factorialDouble(final int n) {\n+    public static double factorialDouble(final int n) throws NotPositiveException, MathArithmeticException {\n         if (n < 0) {\n             throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                            n);\n         }\n         if (n < 21) {\n-            return factorial(n);\n+            return FACTORIALS[n];\n         }\n         return FastMath.floor(FastMath.exp(ArithmeticUtils.factorialLog(n)) + 0.5);\n     }\n      * @return {@code n!}\n      * @throws NotPositiveException if {@code n < 0}.\n      */\n-    public static double factorialLog(final int n) {\n+    public static double factorialLog(final int n) throws NotPositiveException {\n         if (n < 0) {\n             throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                            n);\n         }\n         if (n < 21) {\n-            return FastMath.log(factorial(n));\n+            return FastMath.log(FACTORIALS[n]);\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n      * a non-negative {@code long} value.\n      * @since 2.1\n      */\n-    public static long gcd(final long p, final long q) {\n+    public static long gcd(final long p, final long q) throws MathArithmeticException {\n         long u = p;\n         long v = q;\n         if ((u == 0) || (v == 0)) {\n      * a non-negative {@code int} value.\n      * @since 1.1\n      */\n-    public static int lcm(int a, int b) {\n+    public static int lcm(int a, int b) throws MathArithmeticException {\n         if (a == 0 || b == 0){\n             return 0;\n         }\n      * as a non-negative {@code long} value.\n      * @since 2.1\n      */\n-    public static long lcm(long a, long b) {\n+    public static long lcm(long a, long b) throws MathArithmeticException {\n         if (a == 0 || b == 0){\n             return 0;\n         }\n      * represented as an {@code int}.\n      * @since 1.1\n      */\n-    public static int mulAndCheck(int x, int y) {\n+    public static int mulAndCheck(int x, int y) throws MathArithmeticException {\n         long m = ((long)x) * ((long)y);\n         if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n             throw new MathArithmeticException();\n      * as a {@code long}.\n      * @since 1.2\n      */\n-    public static long mulAndCheck(long a, long b) {\n+    public static long mulAndCheck(long a, long b) throws MathArithmeticException {\n         long ret;\n         if (a > b) {\n             // use symmetry to reduce boundary cases\n      * as an {@code int}.\n      * @since 1.1\n      */\n-    public static int subAndCheck(int x, int y) {\n+    public static int subAndCheck(int x, int y) throws MathArithmeticException {\n         long s = (long)x - (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n             throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n      * {@code long}.\n      * @since 1.2\n      */\n-    public static long subAndCheck(long a, long b) {\n+    public static long subAndCheck(long a, long b) throws MathArithmeticException {\n         long ret;\n         if (b == Long.MIN_VALUE) {\n             if (a < 0) {\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static int pow(final int k, int e) {\n+    public static int pow(final int k, int e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static int pow(final int k, long e) {\n+    public static int pow(final int k, long e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static long pow(final long k, int e) {\n+    public static long pow(final long k, int e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static long pow(final long k, long e) {\n+    public static long pow(final long k, long e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static BigInteger pow(final BigInteger k, int e) {\n+    public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static BigInteger pow(final BigInteger k, long e) {\n+    public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {\n         if (e < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * @return k<sup>e</sup>\n      * @throws NotPositiveException if {@code e < 0}.\n      */\n-    public static BigInteger pow(final BigInteger k, BigInteger e) {\n+    public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {\n         if (e.compareTo(BigInteger.ZERO) < 0) {\n             throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n      * as a {@code long}.\n      * @since 1.2\n      */\n-     private static long addAndCheck(long a, long b, Localizable pattern) {\n+     private static long addAndCheck(long a, long b, Localizable pattern) throws MathArithmeticException {\n         long ret;\n         if (a > b) {\n             // use symmetry to reduce boundary cases\n      * @throws NotPositiveException if {@code n < 0}.\n      * @throws NumberIsTooLargeException if {@code k > n}.\n      */\n-    private static void checkBinomial(final int n, final int k) {\n+    private static void checkBinomial(final int n, final int k) throws NumberIsTooLargeException, NotPositiveException {\n         if (n < k) {\n             throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                                                 k, n, true);\n--- a/src/main/java/org/apache/commons/math3/util/BigReal.java\n+++ b/src/main/java/org/apache/commons/math3/util/BigReal.java\n      *\n      * @throws MathArithmeticException if {@code a} is zero\n      */\n-    public BigReal divide(BigReal a) {\n+    public BigReal divide(BigReal a) throws MathArithmeticException {\n         try {\n             return new BigReal(d.divide(a.d, scale, roundingMode));\n         } catch (ArithmeticException e) {\n      *\n      * @throws MathArithmeticException if {@code this} is zero\n      */\n-    public BigReal reciprocal() {\n+    public BigReal reciprocal() throws MathArithmeticException {\n         try {\n             return new BigReal(BigDecimal.ONE.divide(d, scale, roundingMode));\n         } catch (ArithmeticException e) {\n--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n package org.apache.commons.math3.util;\n \n import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n      * @return the value of the continued fraction evaluated at x.\n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n-    public double evaluate(double x) {\n-        return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    public double evaluate(double x) throws ConvergenceException {\n+        try {\n+            return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+        } catch (MaxCountExceededException e) {\n+            // this should never happen as integers never exceed MAX_VALUE\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @return the value of the continued fraction evaluated at x.\n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n-    public double evaluate(double x, double epsilon) {\n-        return evaluate(x, epsilon, Integer.MAX_VALUE);\n+    public double evaluate(double x, double epsilon) throws ConvergenceException {\n+        try {\n+            return evaluate(x, epsilon, Integer.MAX_VALUE);\n+        } catch (MaxCountExceededException e) {\n+            // this should never happen as integers never exceed MAX_VALUE\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @param maxIterations maximum number of convergents\n      * @return the value of the continued fraction evaluated at x.\n      * @throws ConvergenceException if the algorithm fails to converge.\n+     * @throws MaxCountExceededException if maximal number of iterations is reached\n      */\n-    public double evaluate(double x, int maxIterations) {\n+    public double evaluate(double x, int maxIterations)\n+        throws ConvergenceException, MaxCountExceededException {\n         return evaluate(x, DEFAULT_EPSILON, maxIterations);\n     }\n \n      * @param maxIterations maximum number of convergents\n      * @return the value of the continued fraction evaluated at x.\n      * @throws ConvergenceException if the algorithm fails to converge.\n+     * @throws MaxCountExceededException if maximal number of iterations is reached\n      */\n-    public double evaluate(double x, double epsilon, int maxIterations) {\n+    public double evaluate(double x, double epsilon, int maxIterations)\n+        throws ConvergenceException, MaxCountExceededException {\n         final double small = 1e-50;\n         double hPrev = getA(0, x);\n \n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n     public static boolean isMonotonic(double[] val,\n                                       OrderDirection dir,\n                                       boolean strict) {\n-        return checkOrder(val, dir, strict, false);\n+        try {\n+            return checkOrder(val, dir, strict, false);\n+        } catch (NonMonotonicSequenceException e) {\n+            // this should never happen as abort is set to false\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * and {@code abort} is {@code true}.\n      */\n     public static boolean checkOrder(double[] val, OrderDirection dir,\n-                                     boolean strict, boolean abort) {\n+                                     boolean strict, boolean abort)\n+        throws NonMonotonicSequenceException {\n         double previous = val[0];\n         final int max = val.length;\n \n      * @since 2.2\n      */\n     public static void checkOrder(double[] val, OrderDirection dir,\n-                                  boolean strict) {\n+                                  boolean strict) throws NonMonotonicSequenceException {\n         checkOrder(val, dir, strict, true);\n     }\n \n      * @throws NonMonotonicSequenceException if the array is not sorted.\n      * @since 2.2\n      */\n-    public static void checkOrder(double[] val) {\n+    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n         checkOrder(val, OrderDirection.INCREASING, true);\n     }\n \n      * @throws NullArgumentException if {@code x} or any {@code y} is null.\n      * @since 3.0\n      */\n-    public static void sortInPlace(double[] x,\n-                                   double[] ... yList) {\n+    public static void sortInPlace(double[] x, double[] ... yList)\n+        throws DimensionMismatchException, NullArgumentException {\n         sortInPlace(x, OrderDirection.INCREASING, yList);\n     }\n \n      */\n     public static void sortInPlace(double[] x,\n                                    final OrderDirection dir,\n-                                   double[] ... yList) {\n+                                   double[] ... yList)\n+        throws NullArgumentException, DimensionMismatchException {\n         if (x == null) {\n             throw new NullArgumentException();\n         }\n      * @param a Factors.\n      * @param b Factors.\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n-     */\n-    public static double linearCombination(final double[] a, final double[] b) {\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     */\n+    public static double linearCombination(final double[] a, final double[] b)\n+        throws DimensionMismatchException {\n         final int len = a.length;\n         if (len != b.length) {\n             throw new DimensionMismatchException(len, b.length);\n       * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n       * @since 2.1\n       */\n-     public static double[] normalizeArray(double[] values, double normalizedSum) {\n+     public static double[] normalizeArray(double[] values, double normalizedSum)\n+         throws MathIllegalArgumentException, MathArithmeticException {\n          if (Double.isInfinite(normalizedSum)) {\n              throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n          }\n--- a/src/main/java/org/apache/commons/math3/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathUtils.java\n      * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n      * and {@code sign >= 0}.\n      */\n-    public static byte copySign(byte magnitude, byte sign) {\n+    public static byte copySign(byte magnitude, byte sign)\n+        throws MathArithmeticException {\n         if ((magnitude >= 0 && sign >= 0) ||\n             (magnitude < 0 && sign < 0)) { // Sign is OK.\n             return magnitude;\n      * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n      * and {@code sign >= 0}.\n      */\n-    public static short copySign(short magnitude, short sign) {\n+    public static short copySign(short magnitude, short sign)\n+            throws MathArithmeticException {\n         if ((magnitude >= 0 && sign >= 0) ||\n             (magnitude < 0 && sign < 0)) { // Sign is OK.\n             return magnitude;\n      * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n      * and {@code sign >= 0}.\n      */\n-    public static int copySign(int magnitude, int sign) {\n+    public static int copySign(int magnitude, int sign)\n+            throws MathArithmeticException {\n         if ((magnitude >= 0 && sign >= 0) ||\n             (magnitude < 0 && sign < 0)) { // Sign is OK.\n             return magnitude;\n      * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n      * and {@code sign >= 0}.\n      */\n-    public static long copySign(long magnitude, long sign) {\n+    public static long copySign(long magnitude, long sign)\n+        throws MathArithmeticException {\n         if ((magnitude >= 0 && sign >= 0) ||\n             (magnitude < 0 && sign < 0)) { // Sign is OK.\n             return magnitude;\n      * @throws NotFiniteNumberException if {@code x} is not a\n      * finite real number.\n      */\n-    public static void checkFinite(final double x) {\n+    public static void checkFinite(final double x)\n+        throws NotFiniteNumberException {\n         if (Double.isInfinite(x) || Double.isNaN(x)) {\n             throw new NotFiniteNumberException(x);\n         }\n      * @throws NotFiniteNumberException if any values of the array is not a\n      * finite real number.\n      */\n-    public static void checkFinite(final double[] val) {\n+    public static void checkFinite(final double[] val)\n+        throws NotFiniteNumberException {\n         for (int i = 0; i < val.length; i++) {\n             final double x = val[i];\n             if (Double.isInfinite(x) || Double.isNaN(x)) {\n      */\n     public static void checkNotNull(Object o,\n                                     Localizable pattern,\n-                                    Object ... args) {\n+                                    Object ... args)\n+        throws NullArgumentException {\n         if (o == null) {\n             throw new NullArgumentException(pattern, args);\n         }\n--- a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n package org.apache.commons.math3.util;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n      * @throws NotStrictlyPositiveException if one of the sizes is\n      * negative or zero.\n      */\n-    public MultidimensionalCounter(int ... size) {\n+    public MultidimensionalCounter(int ... size) throws NotStrictlyPositiveException {\n         dimension = size.length;\n         this.size = MathArrays.copyOf(size);\n \n      * @throws OutOfRangeException if {@code index} is not between\n      * {@code 0} and the value returned by {@link #getSize()} (excluded).\n      */\n-    public int[] getCounts(int index) {\n+    public int[] getCounts(int index) throws OutOfRangeException {\n         if (index < 0 ||\n             index >= totalSize) {\n             throw new OutOfRangeException(index, 0, totalSize);\n      * the range of the corresponding dimension, as defined in the\n      * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.\n      */\n-    public int getCount(int ... c) throws OutOfRangeException {\n+    public int getCount(int ... c)\n+        throws OutOfRangeException, DimensionMismatchException {\n         if (c.length != dimension) {\n             throw new DimensionMismatchException(c.length, dimension);\n         }\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < dimension; i++) {\n-            sb.append(\"[\").append(getCount(i)).append(\"]\");\n+            try {\n+                sb.append(\"[\").append(getCount(i)).append(\"]\");\n+            } catch (OutOfRangeException e) {\n+                // this should never happen\n+                throw new MathInternalError(e);\n+            } catch (DimensionMismatchException e) {\n+                // this should never happen\n+                throw new MathInternalError(e);\n+            }\n         }\n         return sb.toString();\n     }\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n import java.math.BigDecimal;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n      * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n      */\n     public static float round(float x, int scale) {\n+        try {\n         return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+        } catch (MathArithmeticException e) {\n+            // should never happen as we don't use BigDecimal.ROUND_UNNECESSARY\n+            throw new MathInternalError(e);\n+        } catch (MathIllegalArgumentException e) {\n+            // should never happen as we use a valid rounding\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**\n      * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n      * @return the rounded value.\n      * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n-     */\n-    public static float round(float x, int scale, int roundingMethod) {\n+     * @throws MathArithmeticException if an exact operation is required but result is not exact\n+     * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n+     */\n+    public static float round(float x, int scale, int roundingMethod)\n+        throws MathArithmeticException, MathIllegalArgumentException {\n         final float sign = FastMath.copySign(1f, x);\n         final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n         return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n      * @param sign Sign of the original, scaled value.\n      * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n      * @return the rounded value.\n+     * @throws MathArithmeticException if an exact operation is required but result is not exact\n      * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n      * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n      */\n     private static double roundUnscaled(double unscaled,\n                                         double sign,\n-                                        int roundingMethod) {\n+                                        int roundingMethod)\n+        throws MathArithmeticException, MathIllegalArgumentException {\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n      * <li><code>contractionFactor = 2.0</code></li>\n      * </ul>\n      * @param initialCapacity The initial size of the internal storage array\n-     * @throws IllegalArgumentException if initialCapacity is not > 0\n-     */\n-    public ResizableDoubleArray(int initialCapacity) {\n+     * @throws MathIllegalArgumentException if initialCapacity is not > 0\n+     */\n+    public ResizableDoubleArray(int initialCapacity) throws MathIllegalArgumentException {\n         setInitialCapacity(initialCapacity);\n         internalArray = new double[this.initialCapacity];\n     }\n      * @param initialCapacity The initial size of the internal storage array\n      * @param expansionFactor the array will be expanded based on this\n      *                        parameter\n-     * @throws IllegalArgumentException if parameters are not valid\n-     */\n-    public ResizableDoubleArray(int initialCapacity, float expansionFactor) {\n+     * @throws MathIllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor) throws MathIllegalArgumentException {\n         this.expansionFactor = expansionFactor;\n         setInitialCapacity(initialCapacity);\n         internalArray = new double[initialCapacity];\n      * @param expansionFactor the array will be expanded based on this\n      *                        parameter\n      * @param contractionCriteria The contraction Criteria.\n-     * @throws IllegalArgumentException if parameters are not valid\n+     * @throws MathIllegalArgumentException if parameters are not valid\n      */\n     public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n-        float contractionCriteria) {\n+        float contractionCriteria) throws MathIllegalArgumentException {\n         this.expansionFactor = expansionFactor;\n         setContractionCriteria(contractionCriteria);\n         setInitialCapacity(initialCapacity);\n      *                        parameter\n      * @param contractionCriteria the contraction Criteria\n      * @param expansionMode  the expansion mode\n-     * @throws IllegalArgumentException if parameters are not valid\n+     * @throws MathIllegalArgumentException if parameters are not valid\n      */\n     public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n-            float contractionCriteria, int expansionMode) {\n+            float contractionCriteria, int expansionMode) throws MathIllegalArgumentException {\n         this.expansionFactor = expansionFactor;\n         setContractionCriteria(contractionCriteria);\n         setInitialCapacity(initialCapacity);\n      *\n      * @param value new value to substitute for the most recently added value\n      * @return value that has been replaced in the array\n-     * @throws IllegalStateException if the array is empty\n+     * @throws MathIllegalStateException if the array is empty\n      * @since 2.0\n      */\n-    public synchronized double substituteMostRecentElement(double value) {\n+    public synchronized double substituteMostRecentElement(double value) throws MathIllegalStateException {\n         if (numElements < 1) {\n             throw new MathIllegalStateException(\n                     LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n      *\n      * @param expansion factor to be checked\n      * @param contraction criteria to be checked\n-     * @throws IllegalArgumentException if the contractionCriteria is less than\n+     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n-    protected void checkContractExpand(float contraction, float expansion) {\n+    protected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\n \n         if (contraction < expansion) {\n             throw new MathIllegalArgumentException(\n      * if i exceeds numElements.\n      *\n      * @param i  the number of elements to discard from the front of the array\n-     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardFrontElements(int i) {\n+    public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\n \n         discardExtremeElements(i,true);\n \n      * if i exceeds numElements.\n      *\n      * @param i  the number of elements to discard from the end of the array\n-     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardMostRecentElements(int i) {\n+    public synchronized void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n \n         discardExtremeElements(i,false);\n \n      * @param front true if elements are to be discarded from the front\n      * of the array, false if elements are to be discarded from the end\n      * of the array\n-     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    private synchronized void discardExtremeElements(int i,boolean front) {\n+    private synchronized void discardExtremeElements(int i,boolean front) throws MathIllegalArgumentException {\n         if (i > numElements) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n      * Sets the contraction criteria for this ExpandContractDoubleArray.\n      *\n      * @param contractionCriteria contraction criteria\n-     */\n-    public void setContractionCriteria(float contractionCriteria) {\n+     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n+     *         the expansionCriteria.\n+     */\n+    public void setContractionCriteria(float contractionCriteria) throws MathIllegalArgumentException {\n         checkContractExpand(contractionCriteria, getExpansionFactor());\n         synchronized(this) {\n             this.contractionCriteria = contractionCriteria;\n      * <li><code>contractionFactor >= expansionFactor</code></li>\n      * </ul>\n      * @param expansionFactor the new expansion factor value.\n-     * @throws IllegalArgumentException if expansionFactor is <= 1 or greater\n+     * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\n      * than contractionFactor\n      */\n-    public void setExpansionFactor(float expansionFactor) {\n+    public void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\n         checkContractExpand(getContractionCriteria(), expansionFactor);\n         // The check above verifies that the expansion factor is > 1.0;\n         synchronized(this) {\n      * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n      *\n      * @param expansionMode The expansionMode to set.\n-     * @throws IllegalArgumentException if the specified mode value is not valid\n-     */\n-    public void setExpansionMode(int expansionMode) {\n+     * @throws MathIllegalArgumentException if the specified mode value is not valid\n+     */\n+    public void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\n         if (expansionMode != MULTIPLICATIVE_MODE &&\n                 expansionMode != ADDITIVE_MODE) {\n             throw new MathIllegalArgumentException(\n      * Sets the initial capacity.  Should only be invoked by constructors.\n      *\n      * @param initialCapacity of the array\n-     * @throws IllegalArgumentException if <code>initialCapacity</code> is not\n+     * @throws MathIllegalArgumentException if <code>initialCapacity</code> is not\n      *         positive.\n      */\n-    protected void setInitialCapacity(int initialCapacity) {\n+    protected void setInitialCapacity(int initialCapacity) throws MathIllegalArgumentException {\n         if (initialCapacity > 0) {\n             synchronized(this) {\n                 this.initialCapacity = initialCapacity;\n      * array. This function will also expand the internal array as needed.\n      *\n      * @param i a new number of elements\n-     * @throws IllegalArgumentException if <code>i</code> is negative.\n-     */\n-    public synchronized void setNumElements(int i) {\n+     * @throws MathIllegalArgumentException if <code>i</code> is negative.\n+     */\n+    public synchronized void setNumElements(int i) throws MathIllegalArgumentException {\n \n         // If index is negative thrown an error\n         if (i < 0) {\n      * @since 2.0\n      */\n     public synchronized ResizableDoubleArray copy() {\n-        ResizableDoubleArray result = new ResizableDoubleArray();\n-        copy(this, result);\n-        return result;\n+        try {\n+            ResizableDoubleArray result = new ResizableDoubleArray();\n+            copy(this, result);\n+            return result;\n+        } catch (NullArgumentException e) {\n+            // this should never happen\n+            throw new MathInternalError(e);\n+        }\n     }\n \n     /**", "timestamp": 1346869787, "metainfo": ""}