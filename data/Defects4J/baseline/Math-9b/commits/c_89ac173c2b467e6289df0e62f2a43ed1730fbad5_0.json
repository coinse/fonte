{"sha": "89ac173c2b467e6289df0e62f2a43ed1730fbad5", "log": "Initial commit  ", "commit": "\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MantissaException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa;\n+\n+import java.text.MessageFormat;\n+import java.util.ResourceBundle;\n+import java.util.MissingResourceException;\n+\n+/** This class is the base class for all specific exceptions thrown by\n+ * the mantissa classes.\n+\n+ * <p>When the mantissa classes throw exceptions that are specific to\n+ * the package, these exceptions are always subclasses of\n+ * MantissaException. When exceptions that are already covered by the\n+ * standard java API should be thrown, like\n+ * ArrayIndexOutOfBoundsException or IllegalArgumentException, these\n+ * standard exceptions are thrown rather than the mantissa specific\n+ * ones.</p>\n+\n+ * @version $Id: MantissaException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MantissaException\n+  extends Exception {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static ResourceBundle resources\n+  = ResourceBundle.getBundle(\"org.spaceroots.mantissa.MessagesResources\");\n+\n+  /** Translate a string.\n+   * @param s string to translate\n+   * @return translated string\n+   */\n+  public static String translate(String s) {\n+    try {\n+      return resources.getString(s);\n+    } catch (MissingResourceException mre) {\n+      return s;\n+    }\n+  }\n+\n+  /** Translate a message.\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   * @return translated message\n+   */\n+  public static String translate(String specifier, String[] parts) {\n+    return new MessageFormat(translate(specifier)).format(parts);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception with an empty message\n+   */\n+  public MantissaException() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception by translating the specified message\n+   * @param message message to translate\n+   */\n+  public MantissaException(String message) {\n+    super(translate(message));\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public MantissaException(String specifier, String[] parts) {\n+    super(translate(specifier, parts));\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a cause\n+   * @param cause cause of this exception\n+   */\n+  public MantissaException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a message and a cause\n+   * @param message message to translate\n+   * @param cause cause of this exception\n+   */\n+  public MantissaException(String message, Throwable cause) {\n+    super(translate(message), cause);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a message and a cause\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   * @param cause cause of this exception\n+   */\n+  public MantissaException(String specifier, String[] parts, Throwable cause) {\n+    super(translate(specifier, parts), cause);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa;\n+\n+import java.util.ListResourceBundle;\n+\n+/** This class gather the message resources for the mantissa library.\n+ * @version $Id: MessagesResources.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+\n+public class MessagesResources\n+  extends ListResourceBundle {\n+\n+  /** Simple constructor.\n+   */\n+  public MessagesResources() {\n+  }\n+\n+  public Object[][] getContents() {\n+    return contents;\n+  }\n+\n+  static final Object[][] contents = {\n+\n+    // org.spaceroots.mantissa.estimation.GaussNewtonEstimator\n+    { \"unable to converge in {0} iterations\",\n+      \"unable to converge in {0} iterations\" },\n+\n+    // org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator\n+    { \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\",\n+      \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\" },\n+    { \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\",\n+      \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\" },\n+    { \"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\",\n+      \"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\" },\n+    { \"maximal number of evaluations exceeded ({0})\",\n+      \"maximal number of evaluations exceeded ({0})\" },\n+\n+    // org.spaceroots.mantissa.fitting.HarmonicCoefficientsGuesser\n+    { \"unable to guess a first estimate\",\n+      \"unable to guess a first estimate\" },\n+\n+    // org.spaceroots.mantissa.fitting.HarmonicFitter\n+    { \"sample must contain at least {0} points\",\n+      \"sample must contain at least {0} points\" },\n+\n+    // org.spaceroots.mantissa.functions.ExhaustedSampleException\n+    { \"sample contains only {0} elements\",\n+      \"sample contains only {0} elements\" },\n+\n+    // org.spaceroots.mantissa.geometry.CardanEulerSingularityException\n+    { \"Cardan angles singularity\",\n+      \"Cardan angles singularity\" },\n+    { \"Euler angles singularity\",\n+      \"Euler angles singularity\" },\n+\n+    // org.spaceroots.mantissa.geometry.Rotation\n+    { \"a {0}x{1} matrix cannot be a rotation matrix\",\n+      \"a {0}x{1} matrix cannot be a rotation matrix\" },\n+    { \"the closest orthogonal matrix has a negative determinant {0}\",\n+      \"the closest orthogonal matrix has a negative determinant {0}\" },\n+    { \"unable to orthogonalize matrix in {0} iterations\",\n+      \"unable to orthogonalize matrix in {0} iterations\" },\n+\n+    // org.spaceroots.mantissa.linalg;.SingularMatrixException\n+    { \"singular matrix\",\n+      \"singular matrix\" },\n+\n+    // org.spaceroots.mantissa.ode.AdaptiveStepsizeIntegrator\n+    { \"minimal step size ({0}) reached, integration needs {1}\",\n+      \"minimal step size ({0}) reached, integration needs {1}\" },\n+\n+    // org.spaceroots.mantissa.ode.GraggBulirschStoerIntegrator,\n+    // org.spaceroots.mantissa.ode.RungeKuttaFehlbergIntegrator,\n+    // org.spaceroots.mantissa.ode.RungeKuttaIntegrator\n+    { \"dimensions mismatch: ODE problem has dimension {0},\"\n+    + \" state vector has dimension {1}\",\n+      \"dimensions mismatch: ODE problem has dimension {0},\"\n+    + \" state vector has dimension {1}\" },\n+    { \"too small integration interval: length = {0}\",\n+      \"too small integration interval: length = {0}\" },\n+\n+    // org.spaceroots.mantissa.optimization.DirectSearchOptimizer\n+    { \"none of the {0} start points lead to convergence\",\n+      \"none of the {0} start points lead to convergence\"  },\n+\n+    // org.spaceroots.mantissa.random.CorrelatedRandomVectorGenerator\n+    { \"dimension mismatch {0} != {1}\",\n+      \"dimension mismatch {0} != {1}\" },\n+\n+    // org.spaceroots.mantissa.random.NotPositiveDefiniteMatrixException\n+    { \"not positive definite matrix\",\n+      \"not positive definite matrix\" }\n+\n+  };\n+  \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa;\n+\n+import java.util.ListResourceBundle;\n+\n+/** This class gather the message resources for the mantissa library.\n+ * @version $Id: MessagesResources_fr.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+public class MessagesResources_fr\n+  extends ListResourceBundle {\n+\n+  /** Simple constructor.\n+   */\n+  public MessagesResources_fr() {\n+  }\n+\n+  public Object[][] getContents() {\n+    return contents;\n+  }\n+\n+  static final Object[][] contents = {\n+\n+    // org.spaceroots.mantissa.estimation.GaussNewtonEstimator\n+    { \"unable to converge in {0} iterations\",\n+      \"pas de convergence apr\\u00e8s {0} it\\u00e9rations\" },\n+\n+    // org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator\n+    { \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\",\n+      \"trop petite tol\\u00e9rance relative sur le co\\u00fbt ({0}), aucune r\\u00e9duction de la somme des carr\\u00e9s n''est possible\" },\n+    { \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\",\n+      \"trop petite tol\\u00e9rance relative sur les param\\u00e8tres ({0}), aucune am\\u00e9lioration de la solution approximative n''est possible\" },\n+    { \"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\",\n+      \"trop petite tol\\u00e9rance sur l''orthogonalit\\u00e9 ({0}), la solution est orthogonale \\u00e0 la jacobienne\" },\n+    { \"maximal number of evaluations exceeded ({0})\",\n+      \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n+\n+    // org.spaceroots.mantissa.fitting.HarmonicCoefficientsGuesser\n+    { \"unable to guess a first estimate\",\n+      \"impossible de trouver une premi\\u00e8re estim\\u00e9e\" },\n+\n+    // org.spaceroots.mantissa.fitting.HarmonicFitter\n+    { \"sample must contain at least {0} points\",\n+      \"l''\\u00e9chantillon doit contenir au moins {0} points\" },\n+\n+    // org.spaceroots.mantissa.functions.ExhaustedSampleException\n+    { \"sample contains only {0} elements\",\n+      \"l''\\u00e9chantillon ne contient que {0} points\" },\n+\n+    // org.spaceroots.mantissa.geometry.CardanEulerSingularityException\n+    { \"Cardan angles singularity\",\n+      \"singularit\\u00e9 d''angles de Cardan\" },\n+    { \"Euler angles singularity\",\n+      \"singularit\\u00e9 d''angles d''Euler\" },\n+\n+    // org.spaceroots.mantissa.geometry.Rotation\n+    { \"a {0}x{1} matrix cannot be a rotation matrix\",\n+      \"une matrice {0}x{1} ne peut pas \\u00e9tre une matrice de rotation\" },\n+    { \"the closest orthogonal matrix has a negative determinant {0}\",\n+      \"la matrice orthogonale la plus proche a un d\\u00e9terminant n\\u00e9gatif {0}\" },\n+    { \"unable to orthogonalize matrix in {0} iterations\",\n+      \"impossible de rendre la matrice orthogonale en {0} it\\u00e9rations\" },\n+\n+    // org.spaceroots.mantissa.linalg;.SingularMatrixException\n+    { \"singular matrix\",\n+      \"matrice singuli\\u00e8re\" },\n+\n+    // org.spaceroots.mantissa.ode.AdaptiveStepsizeIntegrator\n+    { \"minimal step size ({0}) reached, integration needs {1}\",\n+      \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n+\n+    // org.spaceroots.mantissa.ode.GraggBulirschStoerIntegrator,\n+    // org.spaceroots.mantissa.ode.RungeKuttaFehlbergIntegrator,\n+    // org.spaceroots.mantissa.ode.RungeKuttaIntegrator\n+    { \"dimensions mismatch: ODE problem has dimension {0},\"\n+    + \" state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\"\n+    + \" et le vecteur d'\\u00e9tat ({1})\" },\n+    { \"too small integration interval: length = {0}\",\n+      \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n+\n+    // org.spaceroots.mantissa.optimization.DirectSearchOptimizer\n+    { \"none of the {0} start points lead to convergence\",\n+      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n+\n+    // org.spaceroots.mantissa.random.CorrelatedRandomVectorGenerator\n+    { \"dimension mismatch {0} != {1}\",\n+      \"dimensions incompatibles {0} != {1}\" },\n+\n+    // org.spaceroots.mantissa.random.NotPositiveDefiniteMatrixException\n+    { \"not positive definite matrix\",\n+      \"matrice non d\\u00e9finie positive\" }\n+\n+  };\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class implements Chebyshev polynomials.\n+\n+ * <p>Chebyshev polynomials can be defined by the following recurrence\n+ * relations:\n+ * <pre>\n+ *  T0(X)   = 1\n+ *  T1(X)   = X\n+ *  Tk+1(X) = 2X Tk(X) - Tk-1(X)\n+ * </pre></p>\n+\n+ * @version $Id: Chebyshev.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class Chebyshev\n+  extends OrthogonalPolynomial {\n+\n+  /** Simple constructor.\n+   * Build a degree 0 Chebyshev polynomial\n+   */\n+  public Chebyshev() {\n+    super(0, l, maxDegree);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a degree d Chebyshev polynomial\n+   * @param d degree of the polynomial\n+   */\n+  public Chebyshev(int d) {\n+    super(d, l, maxDegree);\n+  }\n+\n+  /** Initialize the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>Tk+1(X) = 2X Tk(X) - Tk-1(X)</pre>\n+   * @param k index of the current step\n+   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n+   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n+   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n+   */\n+  protected void initRecurrenceCoefficients(int k,\n+                                            RationalNumber b2k,\n+                                            RationalNumber b3k,\n+                                            RationalNumber b4k) {\n+    b2k.reset(0l);\n+    b3k.reset(2l);\n+    b4k.reset(1l);\n+  }\n+\n+  /** Set the maximal degree of already computed polynomials.\n+   * @param d maximal degree of already computed polynomials\n+   */\n+  protected void setMaxDegree(int d) {\n+    maxDegree = d;\n+  }\n+\n+  private static final long serialVersionUID = 8367010179599693222L;\n+\n+  /** List holding the coefficients of the polynomials computed so far. */\n+  private static List l;\n+\n+  /** Maximal degree of the polynomials computed so far. */\n+  private static int maxDegree;\n+\n+  /** Build the first two polynomials. */\n+  static {\n+\n+    l = new ArrayList ();\n+\n+    // T0(X)  = 1\n+    l.add(new RationalNumber(1l));\n+\n+    // T1(X)  = X\n+    l.add(new RationalNumber(0l));\n+    l.add(new RationalNumber(1l));\n+\n+    maxDegree = 1;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class implements Hermite polynomials.\n+\n+ * <p>Hermite polynomials can be defined by the following recurrence\n+ * relations:\n+ * <pre>\n+ *  H0(X)   = 1\n+ *  H1(X)   = 2X\n+ *  Hk+1(X) = 2X Hk(X) - 2k Hk-1(X)\n+ * </pre></p>\n+\n+ * @version $Id: Hermite.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class Hermite\n+  extends OrthogonalPolynomial {\n+\n+  /** Simple constructor.\n+   * Build a degree 0 Hermite polynomial\n+   */\n+  public Hermite() {\n+    super(0, l, maxDegree);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a degree d Hermite polynomial\n+   * @param d degree of the polynomial\n+   */\n+  public Hermite(int d) {\n+    super(d, l, maxDegree);\n+  }\n+\n+  /** Initialize the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>Hk+1(X) = 2X Hk(X) - 2k Hk-1(X)</pre>\n+   * @param k index of the current step\n+   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n+   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n+   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n+   */\n+  protected void initRecurrenceCoefficients(int k,\n+                                            RationalNumber b2k,\n+                                            RationalNumber b3k,\n+                                            RationalNumber b4k) {\n+    b2k.reset(0l);\n+    b3k.reset(2l);\n+    b4k.reset(2l * k);\n+  }\n+\n+  /** Set the maximal degree of already computed polynomials.\n+   * @param d maximal degree of already computed polynomials\n+   */\n+  protected void setMaxDegree(int d) {\n+    maxDegree = d;\n+  }\n+\n+  private static final long serialVersionUID = -4639726453485128770L;\n+\n+  /** Table holding the coefficients of the polynomials computed so far. */\n+  private static List l;\n+\n+  /** Maximal degree of the polynomials computed so far. */\n+  private static int maxDegree;\n+\n+  /** Build the first two polynomials. */\n+  static {\n+\n+    l = new ArrayList ();\n+\n+    // H0(X)  = 1\n+    l.add(new RationalNumber(1l));\n+\n+    // H1(X)  = 2X\n+    l.add(new RationalNumber(0l));\n+    l.add(new RationalNumber(2l));\n+\n+    maxDegree = 1;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class implements Laguerre polynomials.\n+\n+ * <p>Laguerre polynomials can be defined by the following recurrence\n+ * relations:\n+ * <pre>\n+ *        L0(X)   = 1\n+ *        L1(X)   = 1 - X\n+ *  (k+1) Lk+1(X) = (2k + 1 - X) Lk(X) - k Lk-1(X)\n+ * </pre></p>\n+\n+ * @version $Id: Laguerre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class Laguerre\n+  extends OrthogonalPolynomial {\n+\n+  /** Simple constructor.\n+   * Build a degree 0 Laguerre polynomial\n+   */\n+  public Laguerre() {\n+    super(0, l, maxDegree);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a degree d Laguerre polynomial\n+   * @param d degree of the polynomial\n+   */\n+  public Laguerre(int d) {\n+    super(d, l, maxDegree);\n+  }\n+\n+  /** Initialize the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>(k+1) Lk+1(X) = (2k + 1 - X) Lk(X) - k Lk-1(X)</pre>\n+   * @param k index of the current step\n+   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n+   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n+   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n+   */\n+  protected void initRecurrenceCoefficients(int k,\n+                                            RationalNumber b2k,\n+                                            RationalNumber b3k,\n+                                            RationalNumber b4k) {\n+    long kP1 = k + 1;\n+    b2k.reset(2 * k + 1, kP1);\n+    b3k.reset(-1l, kP1);\n+    b4k.reset(k, kP1);\n+  }\n+\n+  /** Set the maximal degree of already computed polynomials.\n+   * @param d maximal degree of already computed polynomials\n+   */\n+  protected void setMaxDegree(int d) {\n+    maxDegree = d;\n+  }\n+\n+  private static final long serialVersionUID = -750526984136835515L;\n+\n+  /** List holding the coefficients of the polynomials computed so far. */\n+  private static List l;\n+\n+  /** Maximal degree of the polynomials computed so far. */\n+  private static int maxDegree;\n+\n+  /** Build the first two polynomials. */\n+  static {\n+\n+    l = new ArrayList ();\n+\n+    // L0(X)  = 1\n+    l.add(new RationalNumber(1l));\n+\n+    // L1(X)  = 1 - X\n+    l.add(new RationalNumber(1l));\n+    l.add(new RationalNumber(-1l));\n+\n+    maxDegree = 1;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class implements Legendre polynomials.\n+\n+ * <p>Legendre polynomials can be defined by the following recurrence\n+ * relations:\n+ * <pre>\n+ *        P0(X)   = 1\n+ *        P1(X)   = X\n+ *  (k+1) Pk+1(X) = (2k+1) X Pk(X) - k Pk-1(X)\n+ * </pre></p>\n+\n+ * @version $Id: Legendre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class Legendre\n+  extends OrthogonalPolynomial {\n+\n+  /** Simple constructor.\n+   * Build a degree 0 Legendre polynomial\n+   */\n+  public Legendre() {\n+    super(0, l, maxDegree);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a degree d Legendre polynomial\n+   * @param d degree of the polynomial\n+   */\n+  public Legendre(int d) {\n+    super(d, l, maxDegree);\n+  }\n+\n+  /** Initialize the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>(k+1) Pk+1(X) = (2k+1) X Pk(X) - k Ok-1(X)</pre>\n+   * @param k index of the current step\n+   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n+   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n+   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n+   */\n+  protected void initRecurrenceCoefficients(int k,\n+                                            RationalNumber b2k,\n+                                            RationalNumber b3k,\n+                                            RationalNumber b4k) {\n+    long kP1 = k + 1;\n+    b2k.reset(0l);\n+    b3k.reset(2 * k + 1, kP1);\n+    b4k.reset(k, kP1);\n+  }\n+\n+  /** Set the maximal degree of already computed polynomials.\n+   * @param d maximal degree of already computed polynomials\n+   */\n+  protected void setMaxDegree(int d) {\n+    maxDegree = d;\n+  }\n+\n+  private static final long serialVersionUID = 428266828791532209L;\n+\n+  /** List holding the coefficients of the polynomials computed so far. */\n+  private static List l;\n+\n+  /** Maximal degree of the polynomials computed so far. */\n+  private static int maxDegree;\n+\n+  /** Build the first two polynomials. */\n+  static {\n+\n+    l = new ArrayList ();\n+\n+    // P0(X)  = 1\n+    l.add(new RationalNumber(1l));\n+\n+    // P1(X)  = X\n+    l.add(new RationalNumber(0l));\n+    l.add(new RationalNumber(1l));\n+\n+    maxDegree = 1;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.List;\n+\n+/**\n+ * This class is the base class for orthogonal polynomials.\n+\n+ * <p>Orthogonal polynomials can be defined by recurrence relations like:\n+ * <pre>\n+ *      O0(X)   = some 0 degree polynomial\n+ *      O1(X)   = some first degree polynomial\n+ *  a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)\n+ * </pre>\n+ * where a0k, a1k, a2k and a3k are simple expressions which either are\n+ * constants or depend on k.</p>\n+\n+ * @version $Id: OrthogonalPolynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public abstract class OrthogonalPolynomial\n+  extends Polynomial.Rational {\n+\n+  /** Simple constructor.\n+   * Build a degree d orthogonal polynomial\n+   * @param d degree of the polynomial\n+   * @param l list containing all coefficients already computed\n+   * @param maxDegree maximal degree of computed coefficients, this\n+   * coefficient <em>must</em> be greater or equal to 1, i.e. the\n+   * derived class <em>must</em> have initialized the first two\n+   * polynomials of degree 0 and 1 before this constructor can be\n+   * called.\n+   */\n+  protected OrthogonalPolynomial(int d, List l, int maxDegree) {\n+    if (d > maxDegree) {\n+      computeUpToDegree(d, l, maxDegree);\n+    }\n+\n+    // coefficient  for polynomial 0 is  l [0]\n+    // coefficient  for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n+    // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n+    // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n+    // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n+    // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n+    // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n+    // ...\n+    int start = d * (d + 1) / 2;\n+\n+    a = new RationalNumber[d+1];\n+    for (int i = 0; i <= d; ++i) {\n+      a[i] = new RationalNumber((RationalNumber) l.get(start + i));\n+    }\n+\n+    unknown = null;\n+\n+  }\n+\n+  /** Initialize the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)</pre>\n+   * @param k index of the current step\n+   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n+   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n+   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n+   */\n+  protected abstract void initRecurrenceCoefficients(int k,\n+                                                     RationalNumber b2k,\n+                                                     RationalNumber b3k,\n+                                                     RationalNumber b4k);\n+\n+  /** Set the maximal degree of already computed polynomials.\n+   * @param d maximal degree of already computed polynomials\n+   */\n+  protected abstract void setMaxDegree(int d);\n+\n+  /** Compute all the polynomial coefficients up to a given degree.\n+   * @param d maximal degree\n+   * @param l list containing all coefficients already computed\n+   * @param maxDegree maximal degree of computed coefficients\n+   */\n+  protected void computeUpToDegree(int d, List l, int maxDegree) {\n+\n+    RationalNumber b2k = new RationalNumber();\n+    RationalNumber b3k = new RationalNumber();\n+    RationalNumber b4k = new RationalNumber();\n+\n+    int startK = (maxDegree - 1) * maxDegree / 2;\n+    for (int k = maxDegree; k < d; ++k) {\n+\n+      // start indices of two previous polynomials Ok(X) and Ok-1(X)\n+      int startKm1 = startK;\n+      startK += k;\n+\n+      // a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)\n+      // we use bik = aik/a1k\n+      initRecurrenceCoefficients(k, b2k, b3k, b4k);\n+\n+      RationalNumber ckPrev = null;\n+      RationalNumber ck     = (RationalNumber)l.get(startK);\n+      RationalNumber ckm1   = (RationalNumber)l.get(startKm1);\n+\n+      // degree 0 coefficient\n+      RationalNumber coeff  = RationalNumber.multiply(ck, b2k);\n+      coeff.multiplyAndSubtractFromSelf(ckm1, b4k);\n+      l.add(coeff);\n+\n+      // degree 1 to degree k-1 coefficients\n+      for (int i = 1; i < k; ++i) {\n+        ckPrev = ck;\n+        ck     = (RationalNumber)l.get(startK + i);\n+        ckm1   = (RationalNumber)l.get(startKm1 + i);\n+        coeff  = RationalNumber.multiply(ck, b2k);\n+        coeff.multiplyAndAddToSelf(ckPrev, b3k);\n+        coeff.multiplyAndSubtractFromSelf(ckm1, b4k);\n+        l.add(coeff);\n+      }\n+\n+      // degree k coefficient\n+      ckPrev = ck;\n+      ck     = (RationalNumber)l.get(startK + k);\n+      coeff  = RationalNumber.multiply(ck, b2k);\n+      coeff.multiplyAndAddToSelf(ckPrev, b3k);\n+      l.add(coeff);\n+\n+      // degree k+1 coefficient\n+      l.add(RationalNumber.multiply(ck, b3k));\n+\n+    }\n+\n+    setMaxDegree(d);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+\n+/**\n+ * This class implements polynomials with one unknown.\n+\n+ * <p>This is an abstract class that only declares general methods but\n+ * does not hold the coefficients by themselves. Specific subclasses\n+ * are used to handle exact rational coefficients or approximate real\n+ * coefficients. This design is taken from the various java.awt.geom\n+ * classes (Point2D, Rectangle2D ...)</p>\n+\n+ * <p>The methods implemented deal mainly with the polynomials algebra\n+ * (addition, multiplication ...) but the analysis aspects are also\n+ * considered (value of the polynom for a given unknown,\n+ * derivative).</p>\n+\n+ * @version $Id: Polynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+*/\n+public abstract class Polynomial\n+  implements Cloneable, Serializable {\n+\n+  /** Create a copy of the instance.\n+   * @return a copy of the instance\n+   */\n+  public abstract Object clone();\n+\n+  /** Check if the instance is the null polynomial.\n+   * @return true if the polynomial is null\n+   */\n+  public abstract boolean isZero();\n+\n+  /** Check if the instance is the constant unit polynomial.\n+   * @return true if the polynomial is the constant unit polynomial\n+   */\n+  public abstract boolean isOne();\n+\n+  /** Check if the instance is the identity polynomial.\n+   * @return true if the polynomial is the identity polynomial\n+   */\n+  public abstract boolean isIdentity();\n+\n+  /** Get the polynomial degree.\n+   * @return degree\n+   */\n+  public abstract int getDegree();\n+\n+  /** Negate the instance.\n+   */\n+  public abstract void negateSelf();\n+\n+  /** Multiply the instance by a constant.\n+   * @param r constant to multiply by\n+   */\n+  public abstract void multiplySelf(RationalNumber r);\n+\n+  /** Multiply the instance by a constant.\n+   * @param l constant to multiply by\n+   */\n+  public abstract void multiplySelf(long l);\n+\n+  /** Multiply the instance by a constant.\n+   * @param i constant to multiply by\n+   */\n+  public void multiplySelf(BigInteger i) {\n+    multiplySelf(new RationalNumber(i));\n+  }\n+\n+  /** Get the value of the polynomial for a specified unknown.\n+   * @param x value of the unknown\n+   * @return value of the polynomial\n+   */\n+  public abstract double valueAt(double x);\n+\n+  /** Get the derivative of the instance with respect to the unknown.\n+   * The derivative of a n degree polynomial is a n-1 degree polynomial of\n+   * the same type.\n+   * @return a new polynomial which is the derivative of the instance\n+   */\n+  public abstract Polynomial getDerivative();\n+\n+  /** Set the name of the unknown (to appear during conversions to strings).\n+   * @param name name to set (if null, the default 'x' value  will be used)\n+   */\n+  public abstract void setUnknownName(String name);\n+\n+  /** This class implements polynomials with one unknown and rational\n+   * coefficients.\n+\n+   * <p>In addition to classical algebra operations, euclidian\n+   * division and remainder are handled.</p>\n+\n+   */\n+  public static class Rational extends Polynomial {\n+\n+    /** Simple constructor.\n+     * Build a null polynomial\n+     */\n+    public Rational() {\n+      a = new RationalNumber[1];\n+      a[0] = new RationalNumber(0l);\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a constant polynomial\n+     * @param value constant value of the polynomial\n+     */\n+    public Rational(long value) {\n+      this(new RationalNumber(value));\n+    }\n+\n+    /** Simple constructor.\n+     * Build a constant polynomial\n+     * @param value constant value of the polynomial\n+     */\n+    public Rational(RationalNumber value) {\n+      a = new RationalNumber[1];\n+      a[0] = value;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a first degree polynomial\n+     * @param a1 leeding degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(long a1, long a0) {\n+      this(new RationalNumber(a1), new RationalNumber(a0));\n+    }\n+\n+    /** Simple constructor.\n+     * Build a first degree polynomial\n+     * @param a1 leeding degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(RationalNumber a1, RationalNumber a0) {\n+      if (! a1.isZero()) {\n+        a = new RationalNumber[2];\n+        a[1] = a1;\n+      } else {\n+        a = new RationalNumber[1];\n+      }\n+      a[0] = a0;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a second degree polynomial\n+     * @param a2 leeding degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(long a2, long a1, long a0) {\n+      this(new RationalNumber(a2),\n+           new RationalNumber(a1),\n+           new RationalNumber(a0));\n+    }\n+\n+    /** Simple constructor.\n+     * Build a second degree polynomial\n+     * @param a2 leeding degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(RationalNumber a2, RationalNumber a1, RationalNumber a0) {\n+      if (! a2.isZero()) {\n+        a = new RationalNumber[3];\n+        a[2] = a2;\n+        a[1] = a1;\n+      } else {\n+        if (! a1.isZero()) {\n+          a = new RationalNumber[2];\n+          a[1] = a1;\n+        } else {\n+          a = new RationalNumber[1];\n+        }\n+      }\n+      a[0] = a0;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a polynomial from its coefficients\n+     * @param a coefficients array, the a[0] array element is the\n+     * constant term while the a[a.length-1] element is the leeding\n+     * degree coefficient. The array is copied in a new array, so it\n+     * can be changed once the constructor as returned.\n+     */\n+    public Rational(RationalNumber[] a) {\n+\n+      // remove null high degree coefficients\n+      int i = a.length - 1;\n+      while ((i > 0) && (a[i].isZero())) {\n+        --i;\n+      }\n+\n+      // copy the remaining coefficients\n+      this.a = new RationalNumber[i + 1];\n+      System.arraycopy(a, 0, this.a, 0, i + 1);\n+\n+      unknown = null;\n+\n+    }\n+\n+    /** Simple constructor.\n+     * Build a one term polynomial from one coefficient and the corresponding degree\n+     * @param c coefficient\n+     * @param degree degree associated with the coefficient\n+     */\n+    public Rational(RationalNumber c, int degree) {\n+\n+      if (c.isZero() || degree < 0) {\n+        a = new RationalNumber[1];\n+        a[0] = new RationalNumber(0l);\n+      } else {\n+        a = new RationalNumber[degree + 1];\n+        for (int i = 0; i < degree; ++i) {\n+          a[i] = new RationalNumber(0l);\n+        }\n+        a[degree] = new RationalNumber(c);\n+      }\n+\n+      unknown = null;\n+\n+    }\n+\n+    /** Copy constructor.\n+     * The copy is a deep copy: the polynomials do <em>not</em> share\n+     * their coefficients arrays\n+     * @param p polynomial to copy\n+     */\n+    public Rational(Rational p) {\n+\n+      a = new RationalNumber[p.a.length];\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] = new RationalNumber(p.a[i]);\n+      }\n+\n+      if (p.unknown == null) {\n+        unknown = null;\n+      } else {\n+        unknown = new String(p.unknown);\n+      }\n+\n+    }\n+\n+    /** Create a copy of the instance.\n+     * @return a copy of the instance\n+     */\n+    public Object clone() {\n+      return new Rational(this);\n+    }\n+\n+    /** Check if the instance is the null polynomial.\n+     * @return true if the polynomial is null\n+     */\n+    public boolean isZero() {\n+      return (a.length == 1) && a[0].isZero();\n+    }\n+\n+    /** Check if the instance is the constant unit polynomial.\n+     * @return true if the polynomial is the constant unit polynomial\n+     */\n+    public boolean isOne() {\n+      return (a.length == 1) && a[0].isOne();\n+    }\n+\n+    /** Check if the instance is the identity polynomial.\n+     * @return true if the polynomial is the identity polynomial\n+     */\n+    public boolean isIdentity() {\n+      return (a.length == 2) && a[0].isZero() && a[1].isOne();\n+    }\n+\n+    /** Get the polynomial degree.\n+     * @return degree\n+     */\n+    public int getDegree() {\n+      return a.length - 1;\n+    }\n+\n+    /** Get the coefficients of the polynomial.\n+     * @return a reference to the internal coefficients array, the array\n+     * element at index 0 is the constant term while the element at\n+     * index a.length-1 is the leeding degree coefficient\n+     */\n+    public RationalNumber[] getCoefficients() {\n+      return a;\n+    }\n+\n+    /** Set the name of the unknown (to appear during conversions to strings).\n+     * @param name name to set (if null, the default 'x' value  will be used)\n+     */\n+    public void setUnknownName(String name) {\n+      unknown = name;\n+    }\n+\n+    /** Simplify the polynomial, by removing null high degree terms.\n+     */\n+    private void simplify() {\n+\n+      int i = a.length - 1;\n+      while ((i > 0) && a[i].isZero()) {\n+        --i;\n+      }\n+\n+      if (i < a.length - 1) {\n+        RationalNumber[] newA = new RationalNumber[i + 1];\n+        System.arraycopy(a, 0, newA, 0, i + 1);\n+        a = newA;\n+      }\n+\n+    }\n+\n+    /** Add a polynomial to the instance.\n+     * @param p polynomial to add\n+     */\n+    public void addToSelf(Rational p) {\n+\n+      if (p.a.length > a.length) {\n+        RationalNumber[] newA = new RationalNumber[p.a.length];\n+        System.arraycopy(a, 0, newA, 0, a.length);\n+        for (int i = a.length; i < newA.length; ++i) {\n+          newA[i] = new RationalNumber(0l);\n+        }\n+        a = newA;\n+      }\n+\n+      for (int i = 0; i < p.a.length; ++i) {\n+        a[i].addToSelf(p.a[i]);\n+      }\n+\n+      simplify();\n+\n+    }\n+\n+    /** Add two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the sum of p1 and p2\n+     */\n+    public static Rational add(Rational p1, Rational p2) {\n+      Rational copy = new Rational(p1);\n+      copy.addToSelf(p2);\n+      return copy;\n+    }\n+\n+    /** Subtract a polynomial from the instance.\n+     * @param p polynomial to subtract\n+     */\n+    public void subtractFromSelf(Rational p) {\n+\n+      if (p.a.length > a.length) {\n+        RationalNumber[] newA = new RationalNumber[p.a.length];\n+        System.arraycopy(a, 0, newA, 0, a.length);\n+        for (int i = a.length; i < newA.length; ++i) {\n+          newA[i] = new RationalNumber(0l);\n+        }\n+        a = newA;\n+      }\n+\n+      for (int i = 0; i < p.a.length; ++i) {\n+        a[i].subtractFromSelf(p.a[i]);\n+      }\n+\n+      simplify();\n+\n+    }\n+\n+    /** Subtract two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the difference p1 minus p2\n+     */\n+    public static Rational subtract(Rational p1, Rational p2) {\n+      Rational copy = new Rational(p1);\n+      copy.subtractFromSelf(p2);\n+      return copy;\n+    }\n+\n+    /** Negate the instance.\n+     */\n+    public void negateSelf() {\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i].negateSelf();\n+      }\n+    }\n+\n+    /** Negate a polynomial.\n+     * @param p polynomial to negate\n+     * @return a new polynomial which is the opposite of p\n+     */\n+    public static Rational negate(Rational p) {\n+      Rational copy = new Rational(p);\n+      copy.negateSelf();\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a polynomial.\n+     * @param p polynomial to multiply by\n+     */\n+    public void multiplySelf(Rational p) {\n+\n+      RationalNumber[] newA = new RationalNumber[a.length + p.a.length - 1];\n+\n+      for (int i = 0; i < newA.length; ++i) {\n+        newA[i] = new RationalNumber(0l);\n+        for (int j = Math.max(0, i + 1 - p.a.length);\n+             j < Math.min(a.length, i + 1);\n+             ++j) {\n+          newA[i].addToSelf(RationalNumber.multiply(a[j], p.a[i-j]));\n+        }\n+      }\n+\n+      a = newA;\n+\n+    }\n+\n+    /** Multiply two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the product of p1 and p2\n+     */\n+    public static Rational multiply(Rational p1, Rational p2) {\n+      Rational copy = new Rational(p1);\n+      copy.multiplySelf(p2);\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param r constant to multiply by\n+     */\n+    public void multiplySelf(RationalNumber r) {\n+\n+      if (r.isZero()) {\n+        a = new RationalNumber[1];\n+        a[0] = new RationalNumber(0l);\n+      }\n+\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i].multiplySelf(r);\n+      }\n+\n+    }\n+\n+    /** Multiply a polynomial by a constant.\n+     * @param p polynomial\n+     * @param r constant\n+     * @return a new polynomial which is the product of p and r\n+     */\n+    public static Rational multiply(Rational p, RationalNumber r) {\n+      Rational copy = new Rational(p);\n+      copy.multiplySelf(r);\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param l constant to multiply by\n+     */\n+    public void multiplySelf(long l) {\n+\n+      if (l == 0l) {\n+        a = new RationalNumber[1];\n+        a[0] = new RationalNumber(0l);\n+      }\n+\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i].multiplySelf(l);\n+      }\n+\n+    }\n+\n+    /** Multiply a polynomial by a constant.\n+     * @param p polynomial\n+     * @param l constant\n+     * @return a new polynomial which is the product of p and l\n+     */\n+    public static Rational multiply(Rational p, long l) {\n+      Rational copy = new Rational(p);\n+      copy.multiplySelf(l);\n+      return copy;\n+    }\n+\n+    /** Get the value of the polynomial for a specified unknown.\n+     * @param x value of the unknown\n+     * @return value of the polynomial\n+     */\n+    public double valueAt(double x) {\n+      double y = 0;\n+      for (int i = a.length - 1; i >= 0; --i) {\n+        y = y * x + a[i].doubleValue();\n+      }\n+      return y;\n+    }\n+\n+    /** Get the derivative of the instance with respect to the unknown.\n+     * The derivative of a n degree polynomial is a n-1 degree polynomial of\n+     * the same type.\n+     * @return a new polynomial which is the derivative of the instance\n+     */\n+    public Polynomial getDerivative() {\n+      Rational derivative = new Rational();\n+      if (a.length == 1) {\n+        return derivative;\n+      }\n+      derivative.a = new RationalNumber[a.length - 1];\n+      for (int i = 1; i < a.length; ++i) {\n+        derivative.a[i-1] = RationalNumber.multiply(a[i], i);\n+      }\n+      return derivative;\n+    }\n+\n+    /** Perform the euclidian division of two polynomials.\n+     * @param dividend numerator polynomial\n+     * @param divisor  denominator polynomial\n+     * @return an object containing the quotient and the remainder of the division\n+     */\n+    public static DivisionResult euclidianDivision(Rational dividend,\n+                                                   Rational divisor) {\n+\n+      Rational quotient  = new Rational(0l);\n+      Rational remainder = new Rational(dividend);\n+\n+      int divisorDegree   = divisor.getDegree();\n+      int remainderDegree = remainder.getDegree();\n+      while ((! remainder.isZero()) && (remainderDegree >= divisorDegree)) {\n+\n+        RationalNumber c = RationalNumber.divide(remainder.a[remainderDegree],\n+                                                 divisor.a[divisorDegree]);\n+        Rational monomial = new Rational(c, remainderDegree - divisorDegree);\n+\n+        remainder.subtractFromSelf(Rational.multiply(monomial, divisor));\n+        quotient.addToSelf(monomial);\n+\n+        remainderDegree = remainder.getDegree();\n+\n+      }\n+\n+      return new DivisionResult(quotient, remainder);\n+\n+    }\n+\n+    /** Get the Least Common Multiple of the coefficients denominators.\n+     * This number is the smallest integer by which we should multiply\n+     * the instance to get a polynomial whose coefficients are all integers.\n+     * @return the Least Common Multiple of the coefficients denominators\n+     */\n+    public BigInteger getDenominatorsLCM() {\n+\n+      BigInteger lcm = BigInteger.ONE;\n+\n+      for (int i = 0; i < a.length; ++i) {\n+        RationalNumber newCoeff = RationalNumber.multiply(a[i], lcm);\n+        if (! newCoeff.isInteger()) {\n+          lcm = lcm.multiply(newCoeff.getDenominator());\n+        }\n+      }\n+\n+      return lcm;\n+\n+    }\n+\n+    /** Returns a string representation of the polynomial.\n+\n+    * <p>The representation is user oriented. Terms are displayed lowest\n+    * degrees first. The multiplications signs, coefficients equals to\n+    * one and null terms are not displayed (except if the polynomial is 0,\n+    * in which case the 0 constant term is displayed). Addition of terms\n+    * with negative coefficients are replaced by subtraction of terms\n+    * with positive coefficients except for the first displayed term\n+    * (i.e. we display <code>-3</code> for a constant negative polynomial,\n+    * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\n+    * the first one displayed).</p>\n+\n+    * <p>The name of the unknown is <code>x</code> by default, but can\n+    * be changed using the {@link #setUnknownName setUnknownName}\n+    * method.</p>\n+\n+    * @return a string representation of the polynomial\n+\n+    */\n+    public String toString() {\n+\n+      StringBuffer s = new StringBuffer();\n+      if (a[0].isZero()) {\n+        if (a.length == 1) {\n+          return \"0\";\n+        }\n+      } else {\n+        s.append(a[0].toString());\n+      }\n+\n+      for (int i = 1; i < a.length; ++i) {\n+\n+        if (! a[i].isZero()) {\n+\n+          if (s.length() > 0) {\n+            if (a[i].isNegative()) {\n+              s.append(\" - \");\n+            } else {\n+              s.append(\" + \");\n+            }\n+          } else {\n+            if (a[i].isNegative()) {\n+              s.append(\"-\");\n+            }\n+          }\n+\n+          RationalNumber absAi = RationalNumber.abs(a[i]);\n+          if (! absAi.isOne()) {\n+            s.append(absAi.toString());\n+            s.append(' ');\n+          }\n+\n+          s.append((unknown == null) ? defaultUnknown : unknown);\n+          if (i > 1) {\n+            s.append('^');\n+            s.append(Integer.toString(i));\n+          }\n+        }\n+\n+      }\n+\n+      return s.toString();\n+\n+    }\n+\n+    /** Coefficients array. */\n+    protected RationalNumber[] a;\n+\n+    /** Name of the unknown. */\n+    protected String unknown;\n+\n+    private static final long serialVersionUID = 3035650338772911046L;\n+\n+  }\n+\n+  /** This class stores the result of the euclidian division of two polynomials.\n+   * This class is a simple placeholder, it does not provide any\n+   * processing method\n+   * @see Polynomial.Rational#euclidianDivision\n+   */\n+  public static class DivisionResult {\n+\n+    /** The quotient of the division. */\n+    public final Rational quotient;\n+\n+    /** The remainder of the division. */\n+    public final Rational remainder;\n+\n+    /** Simple constructor. */\n+    public DivisionResult(Rational quotient, Rational remainder) {\n+      this.quotient  = quotient;\n+      this.remainder = remainder;\n+    }\n+\n+  }\n+\n+  /** This class implements polynomials with one unknown and real\n+   * coefficients.\n+   */\n+  public static class Double extends Polynomial {\n+\n+    /** Simple constructor.\n+     * Build a null polynomial\n+     */\n+    public Double() {\n+      a = new double[1];\n+      a[0] = 0;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a constant polynomial\n+     * @param value constant value of the polynomial\n+     */\n+    public Double(double value) {\n+      a = new double[1];\n+      a[0] = value;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a first degree polynomial\n+     * @param a1 leeding degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Double(double a1, double a0) {\n+      if (Math.abs(a1) > 1.0e-12) {\n+        a = new double[2];\n+        a[1] = a1;\n+      } else {\n+        a = new double[1];\n+      }\n+      a[0] = a0;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a second degree polynomial\n+     * @param a2 leeding degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Double(double a2, double a1, double a0) {\n+      if (Math.abs(a2) > 1.0e-12) {\n+        a = new double[3];\n+        a[2] = a2;\n+        a[1] = a1;\n+      } else {\n+        if (Math.abs(a1) > 1.0e-12) {\n+          a = new double[2];\n+          a[1] = a1;\n+        } else {\n+          a = new double[1];\n+        }\n+      }\n+      a[0] = a0;\n+      unknown = null;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a polynomial from its coefficients\n+     * @param a coefficients array, the a[0] array element is the\n+     * constant term while the a[a.length-1] element is the leeding\n+     * degree coefficient. The array is copied in a new array, so it\n+     * can be changed once the constructor as returned.\n+     */\n+    public Double(double[] a) {\n+\n+      // remove null high degree coefficients\n+      int i = a.length - 1;\n+      while ((i > 0) && (Math.abs(a[i]) <= 1.0e-12)) {\n+        --i;\n+      }\n+\n+      // copy the remaining coefficients\n+      this.a = new double[i + 1];\n+      System.arraycopy(a, 0, this.a, 0, i + 1);\n+\n+      unknown = null;\n+\n+    }\n+\n+    /** Simple constructor.\n+     * Build a one term polynomial from one coefficient and the corresponding degree\n+     * @param c coefficient\n+     * @param degree degree associated with the coefficient\n+     */\n+    public Double(double c, int degree) {\n+\n+      if ((Math.abs(c) <= 1.0e-12) || degree < 0) {\n+        a = new double[1];\n+        a[0] = 0;\n+      } else {\n+        a = new double[degree + 1];\n+        for (int i = 0; i < degree; ++i) {\n+          a[i] = 0;\n+        }\n+        a[degree] = c;\n+      }\n+\n+      unknown = null;\n+\n+    }\n+\n+    /** Copy constructor.\n+     * The copy is a deep copy: the polynomials do <em>not</em> share\n+     * their coefficients arrays\n+     * @param p polynomial to copy\n+     */\n+    public Double(Double p) {\n+\n+      a = new double[p.a.length];\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] = p.a[i];\n+      }\n+\n+      if (p.unknown == null) {\n+        unknown = null;\n+      } else {\n+        unknown = new String(p.unknown);\n+      }\n+\n+    }\n+\n+    /** Copy constructor.\n+     * The copy is a deep copy: the polynomials do <em>not</em> share\n+     * their coefficients arrays\n+     * @param p polynomial to copy\n+     */\n+    public Double(Rational p) {\n+\n+      RationalNumber[] pA = p.getCoefficients();\n+      a = new double[pA.length];\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] = pA[i].doubleValue();\n+      }\n+\n+      if (p.unknown == null) {\n+        unknown = null;\n+      } else {\n+        unknown = new String(p.unknown);\n+      }\n+\n+    }\n+\n+    /** Create a copy of the instance.\n+     * @return a copy of the instance\n+     */\n+    public Object clone() {\n+      return new Double(this);\n+    }\n+\n+    /** Check if the instance is the null polynomial.\n+     * @return true if the polynomial is null\n+     */\n+    public boolean isZero() {\n+      return (a.length == 1) && (Math.abs(a[0]) < 1.0e-12);\n+    }\n+\n+    /** Check if the instance is the constant unit polynomial.\n+     * @return true if the polynomial is the constant unit polynomial\n+     */\n+    public boolean isOne() {\n+      return (a.length == 1) && (Math.abs(a[0] - 1) < 1.0e-12);\n+    }\n+\n+    /** Check if the instance is the identity polynomial.\n+     * @return true if the polynomial is the identity polynomial\n+     */\n+    public boolean isIdentity() {\n+      return (a.length == 2)\n+        && (Math.abs(a[0]) < 1.0e-12)\n+        && (Math.abs(a[1] - 1) < 1.0e-12);\n+    }\n+\n+    /** Get the polynomial degree.\n+     * @return degree\n+     */\n+    public int getDegree() {\n+      return a.length - 1;\n+    }\n+\n+    /** Get the coefficients of the polynomial.\n+     * @return a reference to the internal coefficients array, the array\n+     * element at index 0 is the constant term while the element at\n+     * index a.length-1 is the leeding degree coefficient\n+     */\n+    public double[] getCoefficients() {\n+      return a;\n+    }\n+\n+    /** Simplify the polynomial, by removing null high degree terms.\n+     */\n+    private void simplify() {\n+\n+      int i = a.length - 1;\n+      while ((i > 0) && (Math.abs(a[i]) <= 1.0e-12)) {\n+        --i;\n+      }\n+\n+      if (i < a.length - 1) {\n+        double[] newA = new double[i + 1];\n+        System.arraycopy(a, 0, newA, 0, i + 1);\n+        a = newA;\n+      }\n+\n+    }\n+\n+    /** Add a polynomial to the instance.\n+     * @param p polynomial to add\n+     */\n+    public void addToSelf(Double p) {\n+\n+      if (p.a.length > a.length) {\n+        double[] newA = new double[p.a.length];\n+        System.arraycopy(a, 0, newA, 0, a.length);\n+        for (int i = a.length; i < newA.length; ++i) {\n+          newA[i] = 0;\n+        }\n+        a = newA;\n+      }\n+\n+      for (int i = 0; i < p.a.length; ++i) {\n+        a[i] += p.a[i];\n+      }\n+\n+      simplify();\n+\n+    }\n+\n+    /** Add two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the sum of p1 and p2\n+     */\n+    public static Double add(Double p1, Double p2) {\n+      Double copy = new Double(p1);\n+      copy.addToSelf(p2);\n+      return copy;\n+    }\n+\n+    /** Subtract a polynomial from the instance.\n+     * @param p polynomial to subtract\n+     */\n+    public void subtractFromSelf(Double p) {\n+\n+      if (p.a.length > a.length) {\n+        double[] newA = new double[p.a.length];\n+        System.arraycopy(a, 0, newA, 0, a.length);\n+        for (int i = a.length; i < newA.length; ++i) {\n+          newA[i] = 0;\n+        }\n+        a = newA;\n+      }\n+\n+      for (int i = 0; i < p.a.length; ++i) {\n+        a[i] -= p.a[i];\n+      }\n+\n+      simplify();\n+\n+    }\n+\n+    /** Subtract two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the difference p1 minus p2\n+     */\n+    public static Double subtract(Double p1, Double p2) {\n+      Double copy = new Double(p1);\n+      copy.subtractFromSelf(p2);\n+      return copy;\n+    }\n+\n+    /** Negate the instance.\n+     */\n+    public void negateSelf() {\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] = -a[i];\n+      }\n+    }\n+\n+    /** Negate a polynomial.\n+     * @param p polynomial to negate\n+     * @return a new polynomial which is the opposite of p\n+     */\n+    public static Double negate(Double p) {\n+      Double copy = new Double(p);\n+      copy.negateSelf();\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a polynomial.\n+     * @param p polynomial to multiply by\n+     */\n+    public void multiplySelf(Double p) {\n+\n+      double[] newA = new double[a.length + p.a.length - 1];\n+\n+      for (int i = 0; i < newA.length; ++i) {\n+        newA[i] = 0;\n+        for (int j = Math.max(0, i + 1 - p.a.length);\n+             j < Math.min(a.length, i + 1);\n+             ++j) {\n+          newA[i] += a[j] * p.a[i-j];\n+        }\n+      }\n+\n+      a = newA;\n+\n+    }\n+\n+    /** Multiply two polynomials.\n+     * @param p1 first polynomial\n+     * @param p2 second polynomial\n+     * @return a new polynomial which is the product of p1 and p2\n+     */\n+    public static Double multiply(Double p1, Double p2) {\n+      Double copy = new Double(p1);\n+      copy.multiplySelf(p2);\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param r constant to multiply by\n+     */\n+    public void multiplySelf(double r) {\n+\n+      if (Math.abs(r) < 1.0e-12) {\n+        a = new double[1];\n+        a[0] = 0;\n+      }\n+\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] *= r;\n+      }\n+\n+    }\n+\n+    /** Multiply a polynomial by a constant.\n+     * @param p polynomial\n+     * @param r constant\n+     * @return a new polynomial which is the product of p and r\n+     */\n+    public static Double multiply(Double p, double r) {\n+      Double copy = new Double(p);\n+      copy.multiplySelf(r);\n+      return copy;\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param r constant to multiply by\n+     */\n+    public void multiplySelf(RationalNumber r) {\n+\n+      if (r.isZero()) {\n+        a = new double[1];\n+        a[0] = 0;\n+      }\n+\n+      double rValue = r.doubleValue();\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] *= rValue;\n+      }\n+\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param l constant to multiply by\n+     */\n+    public void multiplySelf(long l) {\n+\n+      if (l == 0l) {\n+        a = new double[1];\n+        a[0] = 0;\n+      }\n+\n+      for (int i = 0; i < a.length; ++i) {\n+        a[i] *= l;\n+      }\n+\n+    }\n+\n+    /** Multiply a polynomial by a constant.\n+     * @param p polynomial\n+     * @param l constant\n+     * @return a new polynomial which is the product of p and l\n+     */\n+    public static Double multiply(Double p, long l) {\n+      Double copy = new Double(p);\n+      copy.multiplySelf(l);\n+      return copy;\n+    }\n+\n+    /** Get the value of the polynomial for a specified unknown.\n+     * @param x value of the unknown\n+     * @return value of the polynomial\n+     */\n+    public double valueAt(double x) {\n+      double y = 0;\n+      for (int i = a.length - 1; i >= 0; --i) {\n+        y = y * x + a[i];\n+      }\n+      return y;\n+    }\n+\n+    /** Get the derivative of the instance with respect to the unknown.\n+     * The derivative of a n degree polynomial is a n-1 degree polynomial of\n+     * the same type.\n+     * @return a new polynomial which is the derivative of the instance\n+     */\n+    public Polynomial getDerivative() {\n+      Double derivative = new Double();\n+      if (a.length == 1) {\n+        return derivative;\n+      }\n+      derivative.a = new double[a.length - 1];\n+      for (int i = 1; i < a.length; ++i) {\n+        derivative.a[i-1] = a[i] * i;\n+      }\n+      return derivative;\n+    }\n+\n+    /** Set the name of the unknown (to appear during conversions to strings).\n+     * @param name name to set (if null, the default 'x' value  will be used)\n+     */\n+    public void setUnknownName(String name) {\n+      unknown = name;\n+    }\n+\n+    /** Returns a string representation of the polynomial.\n+\n+    * <p>The representation is user oriented. Terms are displayed lowest\n+    * degrees first. The multiplications signs, coefficients equals to\n+    * one and null terms are not displayed (except if the polynomial is 0,\n+    * in which case the 0 constant term is displayed). Addition of terms\n+    * with negative coefficients are replaced by subtraction of terms\n+    * with positive coefficients except for the first displayed term\n+    * (i.e. we display <code>-3</code> for a constant negative polynomial,\n+    * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\n+    * the first one displayed).</p>\n+\n+    * <p>The name of the unknown is <code>x</code> by default, but can\n+    * be changed using the {@link #setUnknownName setUnknownName}\n+    * method.</p>\n+\n+    * @return a string representation of the polynomial\n+\n+    */\n+    public String toString() {\n+\n+      double maxCoeff = 0;\n+      for (int i = 0; i < a.length; ++i) {\n+        double abs = Math.abs(a[i]);\n+        if (abs > maxCoeff) {\n+          maxCoeff = abs;\n+        }\n+      }\n+      double epsilon = 1.0e-12 * maxCoeff;\n+\n+      StringBuffer s = new StringBuffer();\n+      if (Math.abs(a[0]) <= epsilon) {\n+        if (a.length == 1) {\n+          return \"0\";\n+        }\n+      } else {\n+        s.append(a[0]);\n+      }\n+\n+      for (int i = 1; i < a.length; ++i) {\n+\n+        if (Math.abs(a[i]) > epsilon) {\n+\n+          if (s.length() > 0) {\n+            if (a[i] < 0) {\n+              s.append(\" - \");\n+            } else {\n+              s.append(\" + \");\n+            }\n+          } else {\n+            if (a[i] < 0) {\n+              s.append(\"-\");\n+            }\n+          }\n+\n+          double absAi = Math.abs(a[i]);\n+          if (Math.abs(absAi - 1) > 1.0e-12) {\n+            s.append(absAi);\n+            s.append(' ');\n+          }\n+\n+          s.append((unknown == null) ? defaultUnknown : unknown);\n+          if (i > 1) {\n+            s.append('^');\n+            s.append(Integer.toString(i));\n+          }\n+        }\n+\n+      }\n+\n+      return s.toString();\n+\n+    }\n+\n+    /** Coefficients array. */\n+    protected double[] a;\n+\n+    /** Name of the unknown. */\n+    protected String unknown;\n+\n+    private static final long serialVersionUID = -5907669461605191069L;\n+\n+  }\n+\n+  /** Default name of unknowns. */\n+  protected static String defaultUnknown = new String(\"x\");\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * This class implements fractions of polynomials with one unknown and\n+ * rational coefficients.\n+\n+ * @version $Id: PolynomialFraction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class PolynomialFraction {\n+\n+  /**\n+   * Simple constructor.\n+   * Build a constant null fraction\n+   */\n+  public PolynomialFraction() {\n+    this(new Polynomial.Rational(new RationalNumber(0l)),\n+         new Polynomial.Rational(new RationalNumber(1l)));\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a numerator and a denominator.\n+   * @param numerator numerator of the fraction\n+   * @param denominator denominator of the fraction\n+   * @exception ArithmeticException if the denominator is null\n+   */\n+  public PolynomialFraction(long numerator, long denominator) {\n+    this(new Polynomial.Rational(new RationalNumber(numerator)),\n+         new Polynomial.Rational(new RationalNumber(denominator)));\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a numerator and a denominator.\n+   * @param numerator numerator of the fraction\n+   * @param denominator denominator of the fraction\n+   * @exception ArithmeticException if the denominator is null\n+   */\n+  public PolynomialFraction(BigInteger numerator, BigInteger denominator) {\n+    this(new Polynomial.Rational(new RationalNumber(numerator)),\n+         new Polynomial.Rational(new RationalNumber(denominator)));\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a numerator and a denominator.\n+   * @param numerator numerator of the fraction\n+   * @param denominator denominator of the fraction\n+   * @exception ArithmeticException if the denominator is null\n+   */\n+  public PolynomialFraction(RationalNumber numerator,\n+                            RationalNumber denominator) {\n+    this(new Polynomial.Rational(numerator),\n+         new Polynomial.Rational(denominator));\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a numerator and a denominator.\n+   * @param numerator numerator of the fraction\n+   * @param denominator denominator of the fraction\n+   * @exception ArithmeticException if the denominator is null\n+   */\n+  public PolynomialFraction(Polynomial.Rational numerator,\n+                            Polynomial.Rational denominator) {\n+\n+    if (denominator.isZero()) {\n+      throw new ArithmeticException(\"null denominator\");\n+    }\n+\n+    p = new Polynomial.Rational(numerator);\n+    q = new Polynomial.Rational(denominator);\n+\n+    RationalNumber[] a = q.getCoefficients();\n+    if (a[a.length - 1].isNegative()) {\n+      p.negateSelf();\n+      q.negateSelf();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a single integer\n+   * @param l value of the fraction\n+   */\n+  public PolynomialFraction(long l) {\n+    this(l, 1l);\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a single integer\n+   * @param i value of the fraction\n+   */\n+  public PolynomialFraction(BigInteger i) {\n+    this(i, BigInteger.ONE);\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a single rational number\n+   * @param r value of the fraction\n+   */\n+  public PolynomialFraction(RationalNumber r) {\n+    this(r.getNumerator(), r.getDenominator());\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a fraction from a single Polynom\n+   * @param p value of the fraction\n+   */\n+  public PolynomialFraction(Polynomial.Rational p) {\n+    this(p, new Polynomial.Rational(new RationalNumber(1l)));\n+  }\n+\n+  /**\n+   * Copy-constructor.\n+   * @param f fraction to copy\n+   */\n+  public PolynomialFraction(PolynomialFraction f) {\n+    p = new Polynomial.Rational(f.p);\n+    q = new Polynomial.Rational(f.q);\n+  }\n+\n+  /**\n+   * Negate the instance\n+   */\n+  public void negateSelf() {\n+    p.negateSelf();\n+  }\n+\n+  /**\n+   * Negate a fraction.\n+   * @param f fraction to negate\n+   * @return a new fraction which is the opposite of f\n+   */\n+  public static PolynomialFraction negate(PolynomialFraction f) {\n+    PolynomialFraction copy = new PolynomialFraction(f);\n+    copy.negateSelf();\n+    return copy;\n+  }\n+\n+  /**\n+   * Add a fraction to the instance.\n+   * @param f fraction to add.\n+   */\n+  public void addToSelf(PolynomialFraction f) {\n+    PolynomialFraction sum = add(this, f);\n+    p = sum.p;\n+    q = sum.q;\n+  }\n+\n+  /** Add two fractions.\n+   * @param f1 first fraction\n+   * @param f2 second fraction\n+   * @return a new fraction which is the sum of f1 and f2\n+   */\n+  public static PolynomialFraction add(PolynomialFraction f1,\n+                                       PolynomialFraction f2) {\n+    Polynomial.Rational num =\n+      Polynomial.Rational.add(Polynomial.Rational.multiply(f1.p, f2.q),\n+                              Polynomial.Rational.multiply(f2.p, f1.q));\n+    Polynomial.Rational den = Polynomial.Rational.multiply(f1.q, f2.q);\n+    return new PolynomialFraction(num, den);\n+  }\n+\n+  /**\n+   * Subtract a fraction to the instance.\n+   * @param f fraction to subtract.\n+   */\n+  public void subtractFromSelf(PolynomialFraction f) {\n+    PolynomialFraction diff = subtract(this, f);\n+    p = diff.p;\n+    q = diff.q;\n+  }\n+\n+  /** Subtract two fractions.\n+   * @param f1 first fraction\n+   * @param f2 second fraction\n+   * @return a new fraction which is the difference f1 minus f2\n+   */\n+  public static PolynomialFraction subtract(PolynomialFraction f1,\n+                                            PolynomialFraction f2) {\n+    Polynomial.Rational num =\n+      Polynomial.Rational.subtract(Polynomial.Rational.multiply(f1.p, f2.q),\n+                                   Polynomial.Rational.multiply(f2.p, f1.q));\n+    Polynomial.Rational den = Polynomial.Rational.multiply(f1.q, f2.q);\n+    return new PolynomialFraction(num, den);\n+  }\n+\n+  /** Multiply the instance by a fraction.\n+   * @param f fraction to multiply by\n+   */\n+  public void multiplySelf(PolynomialFraction f) {\n+    p.multiplySelf(f.p);\n+    q.multiplySelf(f.q);\n+    simplify();\n+  }\n+\n+  /** Multiply two fractions.\n+   * @param f1 first fraction\n+   * @param f2 second fraction\n+   * @return a new fraction which is the product of f1 and f2\n+   */\n+  public static PolynomialFraction multiply(PolynomialFraction f1,\n+                                            PolynomialFraction f2) {\n+    PolynomialFraction copy = new PolynomialFraction(f1);\n+    copy.multiplySelf(f2);\n+    return copy;\n+  }\n+\n+  /** Divide the instance by a fraction.\n+   * @param f fraction to divide by\n+   * @exception ArithmeticException if f is null\n+   */\n+  public void divideSelf(PolynomialFraction f) {\n+\n+    if (f.p.isZero()) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p.multiplySelf(f.q);\n+    q.multiplySelf(f.p);\n+\n+    RationalNumber[] a = q.getCoefficients();\n+    if (a[a.length - 1].isNegative()) {\n+      p.negateSelf();\n+      q.negateSelf();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Divide two fractions.\n+   * @param f1 first fraction\n+   * @param f2 second fraction\n+   * @return a new fraction which is the quotient of f1 by f2\n+   */\n+  public static PolynomialFraction divide(PolynomialFraction f1,\n+                                          PolynomialFraction f2) {\n+    PolynomialFraction copy = new PolynomialFraction(f1);\n+    copy.divideSelf(f2);\n+    return copy;\n+  }\n+\n+  /** Invert the instance.\n+   * Replace the instance by its inverse.\n+   * @exception ArithmeticException if the instance is null\n+   */\n+  public void invertSelf() {\n+\n+    if (p.isZero()) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    Polynomial.Rational tmp = p;\n+    p = q;\n+    q = tmp;\n+\n+    RationalNumber[] a = q.getCoefficients();\n+    if (a[a.length - 1].isNegative()) {\n+      p.negateSelf();\n+      q.negateSelf();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Invert a fraction.\n+   * @param f fraction to invert\n+   * @return a new fraction which is the inverse of f\n+   */\n+  public static PolynomialFraction invert(PolynomialFraction f) {\n+    PolynomialFraction copy = new PolynomialFraction(f);\n+    copy.invertSelf();\n+    return copy;\n+  }\n+\n+  /** Simplify a fraction.\n+   * If the denominator polynom is a constant polynom, then\n+   * simplification involves merging this constant in the rational\n+   * coefficients of the numerator in order to replace the denominator\n+   * by the constant 1. If the degree of the denominator is non null,\n+   * then simplification involves both removing common polynomial\n+   * factors (by euclidian division) and replacing rational\n+   * coefficients by integer coefficients (multiplying both numerator\n+   * and denominator by the proper value). The signs of both the\n+   * numerator and the denominator are adjusted in order to have a\n+   * positive leeding degree term in the denominator.\n+   */\n+  private void simplify() {\n+\n+    Polynomial.Rational a = new Polynomial.Rational(p);\n+    Polynomial.Rational b = new Polynomial.Rational(q);\n+    if (a.getDegree() < b.getDegree()) {\n+      Polynomial.Rational tmp = a;\n+      a = b;\n+      b = tmp;\n+    }\n+\n+    Polynomial.DivisionResult res =\n+      Polynomial.Rational.euclidianDivision(a, b);\n+    while (res.remainder.getDegree() != 0) {\n+      a = b;\n+      b = res.remainder;\n+      res = Polynomial.Rational.euclidianDivision(a, b);\n+    }\n+\n+    if (res.remainder.isZero()) {\n+      // there is a common factor we can remove\n+      p = Polynomial.Rational.euclidianDivision(p, b).quotient;\n+      q = Polynomial.Rational.euclidianDivision(q, b).quotient;\n+    }\n+\n+    if (q.getDegree() == 0) {\n+      if (! q.isOne()) {\n+        RationalNumber f = q.getCoefficients()[0];\n+        f.invertSelf();\n+        p.multiplySelf(f);\n+        q = new Polynomial.Rational(1l);\n+      }\n+    } else {\n+\n+      BigInteger lcm = p.getDenominatorsLCM();\n+      if (lcm.compareTo(BigInteger.ONE) != 0) {\n+        p.multiplySelf(lcm);\n+        q.multiplySelf(lcm);\n+      }\n+\n+      lcm = q.getDenominatorsLCM();\n+      if (lcm.compareTo(BigInteger.ONE) != 0) {\n+        p.multiplySelf(lcm);\n+        q.multiplySelf(lcm);\n+      }\n+\n+    }\n+\n+    if (q.getCoefficients()[q.getDegree()].isNegative()) {\n+      p.negateSelf();\n+      q.negateSelf();\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the numerator.\n+   * @return the numerator\n+   */\n+  public Polynomial.Rational getNumerator() {\n+    return p;\n+  }\n+\n+  /**\n+   * Get the denominator.\n+   * @return the denominator (leeding coefficient is always positive)\n+   */\n+  public Polynomial.Rational getDenominator() {\n+    return q;\n+  }\n+\n+  /** Set the name of the unknown (to appear during conversions to\n+   * strings).\n+   * @param name name to set (if null, the default 'x' value will be\n+   * used)\n+   */\n+  public void setUnknownName(String name) {\n+    p.setUnknownName(name);\n+    q.setUnknownName(name);\n+  }\n+\n+  public String toString() {\n+    if (p.isZero()) {\n+      return \"0\";\n+    } else if (q.isOne()) {\n+      return p.toString();\n+    } else {\n+\n+      StringBuffer s = new StringBuffer();\n+\n+      String pString = p.toString();\n+      if (pString.indexOf(' ') > 0) {\n+        s.append('(');\n+        s.append(pString);\n+        s.append(')');\n+      } else {\n+        s.append(pString);\n+      }\n+\n+      s.append('/');\n+\n+      String qString = q.toString();\n+      if (qString.indexOf(' ') > 0) {\n+        s.append('(');\n+        s.append(qString);\n+        s.append(')');\n+      } else {\n+        s.append(qString);\n+      }\n+\n+      return s.toString();\n+\n+    }\n+  }\n+\n+  /** Numerator. */\n+  private Polynomial.Rational p;\n+\n+  /** Denominator. */\n+  private Polynomial.Rational q;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.math.BigInteger;\n+/**\n+ * This class implements reduced rational numbers.\n+\n+ * @version $Id: RationalNumber.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class RationalNumber {\n+\n+  /**\n+   * Simple constructor.\n+   * Build a null rational number\n+   */\n+  public RationalNumber() {\n+    p = BigInteger.ZERO;\n+    q = BigInteger.ONE;\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a rational number from a numerator and a denominator.\n+   * @param numerator numerator of the rational number\n+   * @param denominator denominator of the rational number\n+   * @exception ArithmeticException if the denominator is zero\n+   */\n+  public RationalNumber(long numerator, long denominator) {\n+    reset(numerator, denominator);\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a rational number from a numerator and a denominator.\n+   * @param numerator numerator of the rational number\n+   * @param denominator denominator of the rational number\n+   * @exception ArithmeticException if the denominator is zero\n+   */\n+  public RationalNumber(BigInteger numerator, BigInteger denominator) {\n+    reset(numerator, denominator);\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a rational number from a single integer\n+   * @param l value of the rational number\n+   */\n+  public RationalNumber(long l) {\n+    p = BigInteger.valueOf(l);\n+    q = BigInteger.ONE;\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * Build a rational number from a single integer\n+   * @param i value of the rational number\n+   */\n+  public RationalNumber(BigInteger i) {\n+    p = i;\n+    q = BigInteger.ONE;\n+  }\n+\n+  /**\n+   * Copy-constructor.\n+   * @param r rational number to copy\n+   */\n+  public RationalNumber(RationalNumber r) {\n+    p = r.p;\n+    q = r.q;\n+  }\n+\n+  /** Reset the instance from a numerator and a denominator.\n+   * @param numerator numerator of the rational number\n+   * @param denominator denominator of the rational number\n+   * @exception ArithmeticException if the denominator is zero\n+   */\n+  public void reset(long numerator, long denominator) {\n+    if (denominator == 0l) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p = BigInteger.valueOf(numerator);\n+    q = BigInteger.valueOf(denominator);\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Reset the instance from a numerator and a denominator.\n+   * @param numerator numerator of the rational number\n+   * @param denominator denominator of the rational number\n+   * @exception ArithmeticException if the denominator is zero\n+   */\n+  public void reset(BigInteger numerator, BigInteger denominator) {\n+    if (denominator.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p = numerator;\n+    q = denominator;\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Reset the instance from a single integer\n+   * @param l value of the rational number\n+   */\n+  public void reset(long l) {\n+    p = BigInteger.valueOf(l);\n+    q = BigInteger.ONE;\n+  }\n+\n+  /** Reset the instance from a single integer\n+   * @param i value of the rational number\n+   */\n+  public void reset(BigInteger i) {\n+    p = i;\n+    q = BigInteger.ONE;\n+  }\n+\n+  /** Reset the instance from another rational number.\n+   * @param r rational number to copy\n+   */\n+  public void reset(RationalNumber r) {\n+    p = r.p;\n+    q = r.q;\n+  }\n+\n+  /**\n+   * Negate the instance\n+   */\n+  public void negateSelf() {\n+    p = p.negate();\n+  }\n+\n+  /**\n+   * Negate a rational number.\n+   * @param r rational number to negate\n+   * @return a new rational number which is the opposite of r\n+   */\n+  public static RationalNumber negate(RationalNumber r) {\n+    RationalNumber copy = new RationalNumber(r);\n+    copy.negateSelf();\n+    return copy;\n+  }\n+\n+  /**\n+   * Add a rational number to the instance.\n+   * @param r rational number to add.\n+   */\n+  public void addToSelf(RationalNumber r) {\n+    p = p.multiply(r.q).add(r.p.multiply(q));\n+    q = q.multiply(r.q);\n+    simplify();\n+  }\n+\n+  /** Add two rational numbers.\n+   * @param r1 first rational number\n+   * @param r2 second rational number\n+   * @return a new rational number which is the sum of r1 and r2\n+   */\n+  public static RationalNumber add(RationalNumber r1, RationalNumber r2) {\n+    return new RationalNumber(r1.p.multiply(r2.q).add(r2.p.multiply(r1.q)),\n+                              r1.q.multiply(r2.q));\n+  }\n+\n+  /**\n+   * Subtract a rational number to the instance.\n+   * @param r rational number to subtract.\n+   */\n+  public void subtractFromSelf(RationalNumber r) {\n+    p = p.multiply(r.q).subtract(r.p.multiply(q));\n+    q = q.multiply(r.q);\n+    simplify();\n+  }\n+\n+  /** Subtract two rational numbers.\n+   * @param r1 first rational number\n+   * @param r2 second rational number\n+   * @return a new rational number which is the difference r1 minus r2\n+   */\n+  public static RationalNumber subtract(RationalNumber r1, RationalNumber r2) {\n+    return new RationalNumber(r1.p.multiply(r2.q).subtract(r2.p.multiply(r1.q)),\n+                              r1.q.multiply(r2.q));\n+  }\n+\n+  /** Multiply the instance by an integer.\n+   * @param l integer to multiply by\n+   */\n+  public void multiplySelf(long l) {\n+    p = p.multiply(BigInteger.valueOf(l));\n+    simplify();\n+  }\n+\n+  /** Multiply the instance by an integer.\n+   * @param i integer to multiply by\n+   */\n+  public void multiplySelf(BigInteger i) {\n+    p = p.multiply(i);\n+    simplify();\n+  }\n+\n+  /** Multiply a rational number by an integer.\n+   * @param l integer to multiply by\n+   */\n+  public static RationalNumber multiply(RationalNumber r, long l) {\n+    return new RationalNumber(r.p.multiply(BigInteger.valueOf(l)), r.q);\n+  }\n+\n+  /** Multiply a rational number by an integer.\n+   * @param i integer to multiply by\n+   */\n+  public static RationalNumber multiply(RationalNumber r, BigInteger i) {\n+    return new RationalNumber(r.p.multiply(i), r.q);\n+  }\n+\n+  /** Multiply the instance by a rational number.\n+   * @param r rational number to multiply by\n+   */\n+  public void multiplySelf(RationalNumber r) {\n+    p = p.multiply(r.p);\n+    q = q.multiply(r.q);\n+    simplify();\n+  }\n+\n+  /** Multiply two rational numbers.\n+   * @param r1 first rational number\n+   * @param r2 second rational number\n+   * @return a new rational number which is the product of r1 and r2\n+   */\n+  public static RationalNumber multiply(RationalNumber r1, RationalNumber r2) {\n+    return new RationalNumber(r1.p.multiply(r2.p),\n+                              r1.q.multiply(r2.q));\n+  }\n+\n+  /** Divide the instance by an integer.\n+   * @param l integer to divide by\n+   * @exception ArithmeticException if l is zero\n+   */\n+  public void divideSelf(long l) {\n+\n+    if (l == 0l) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    } else if (l > 0l) {\n+      q = q.multiply(BigInteger.valueOf(l));\n+    } else {\n+      p = p.negate();\n+      q = q.multiply(BigInteger.valueOf(-l));\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Divide the instance by an integer.\n+   * @param i integer to divide by\n+   * @exception ArithmeticException if l is zero\n+   */\n+  public void divideSelf(BigInteger i) {\n+\n+    if (i.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    } else if (i.signum() > 0) {\n+      q = q.multiply(i);\n+    } else {\n+      p = p.negate();\n+      q = q.multiply(i.negate());\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Divide a rational number by an integer\n+   * @param r rational number\n+   * @param l integer\n+   * @return a new rational number which is the quotient of r by l\n+   * @exception ArithmeticException if l is zero\n+   */\n+  public static RationalNumber divide(RationalNumber r, long l) {\n+    RationalNumber copy = new RationalNumber(r);\n+    copy.divideSelf(l);\n+    return copy;\n+  }\n+\n+  /** Divide a rational number by an integer\n+   * @param r rational number\n+   * @param i integer\n+   * @return a new rational number which is the quotient of r by l\n+   * @exception ArithmeticException if l is zero\n+   */\n+  public static RationalNumber divide(RationalNumber r, BigInteger i) {\n+    RationalNumber copy = new RationalNumber(r);\n+    copy.divideSelf(i);\n+    return copy;\n+  }\n+\n+  /** Divide the instance by a rational number.\n+   * @param r rational number to divide by\n+   * @exception ArithmeticException if r is zero\n+   */\n+  public void divideSelf(RationalNumber r) {\n+\n+    if (r.p.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p = p.multiply(r.q);\n+    q = q.multiply(r.p);\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Divide two rational numbers.\n+   * @param r1 first rational number\n+   * @param r2 second rational number\n+   * @return a new rational number which is the quotient of r1 by r2\n+   * @exception ArithmeticException if r2 is zero\n+   */\n+  public static RationalNumber divide(RationalNumber r1, RationalNumber r2) {\n+    RationalNumber copy = new RationalNumber(r1);\n+    copy.divideSelf(r2);\n+    return copy;\n+  }\n+\n+  /** Invert the instance.\n+   * Replace the instance by its inverse.\n+   * @exception ArithmeticException if the instance is zero\n+   */\n+  public void invertSelf() {\n+\n+    if (p.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    BigInteger tmp = p;\n+    p = q;\n+    q = tmp;\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+  }\n+\n+  /** Invert a rational number.\n+   * @param r rational number to invert\n+   * @return a new rational number which is the inverse of r\n+   * @exception ArithmeticException if r is zero\n+   */\n+  public static RationalNumber invert(RationalNumber r) {\n+    return new RationalNumber(r.q, r.p);\n+  }\n+\n+  /**\n+   * Add the product of two rational numbers to the instance.\n+   * This operation is equivalent to\n+   * <code>addToSelf(RationalNumber.multiply(r1, r2))</code> except\n+   * that no intermediate simplification is attempted.\n+   * @param r1 first term of the product to add\n+   * @param r2 second term of the product to add\n+   */\n+  public void multiplyAndAddToSelf(RationalNumber r1, RationalNumber r2) {\n+    BigInteger r1qr2q = r1.q.multiply(r2.q);\n+    p = p.multiply(r1qr2q).add(r1.p.multiply(r2.p).multiply(q));\n+    q = q.multiply(r1qr2q);\n+    simplify();\n+  }\n+\n+  /**\n+   * Subtract the product of two rational numbers from the instance.\n+   * This operation is equivalent to\n+   * <code>subtractFromSelf(RationalNumber.multiply(r1, r2))</code>\n+   * except that no intermediate simplification is attempted.\n+   * @param r1 first term of the product to subtract\n+   * @param r2 second term of the product to subtract\n+   */\n+  public void multiplyAndSubtractFromSelf(RationalNumber r1, RationalNumber r2) {\n+    BigInteger r1qr2q = r1.q.multiply(r2.q);\n+    p = p.multiply(r1qr2q).subtract(r1.p.multiply(r2.p).multiply(q));\n+    q = q.multiply(r1qr2q);\n+    simplify();\n+  }\n+\n+  /** Simplify a rational number by removing common factors.\n+   */\n+  private void simplify() {\n+    if (p.signum() == 0) {\n+      q = BigInteger.ONE;\n+    } else {\n+      BigInteger gcd = p.gcd(q);\n+      p = p.divide(gcd);\n+      q = q.divide(gcd);\n+    }\n+  }\n+\n+  /**\n+   * Get the numerator.\n+   * @return the signed numerator\n+   */\n+  public BigInteger getNumerator() {\n+    return p;\n+  }\n+\n+  /**\n+   * Get the denominator.\n+   * @return the denominator (always positive)\n+   */\n+  public BigInteger getDenominator() {\n+    return q;\n+  }\n+\n+  /** Check if the number is zero.\n+   * @return true if the number is zero\n+   */\n+  public boolean isZero() {\n+    return p.signum() == 0;\n+  }\n+\n+  /** Check if the number is one.\n+   * @return true if the number is one\n+   */\n+  public boolean isOne() {\n+    return (p.compareTo(BigInteger.ONE) == 0)\n+        && (q.compareTo(BigInteger.ONE) == 0);\n+  }\n+\n+  /** Check if the number is integer.\n+   * @return true if the number is an integer\n+   */\n+  public boolean isInteger() {\n+    return q.compareTo(BigInteger.ONE) == 0;\n+  }\n+\n+  /** Check if the number is negative.\n+   * @return true if the number is negative\n+   */\n+  public boolean isNegative() {\n+    return p.signum() < 0;\n+  }\n+\n+  /** Get the absolute value of a rational number.\n+   * @param r rational number from which we want the absolute value\n+   * @return a new rational number which is the absolute value of r\n+   */\n+  public static RationalNumber abs(RationalNumber r) {\n+    return new RationalNumber(r.p.abs(), r.q);\n+  }\n+\n+  /** Return the <code>double</code> value of the instance.\n+   * @return the double value of the instance\n+   */\n+  public double doubleValue() {\n+    BigInteger[] result = p.divideAndRemainder(q);\n+    return result[0].doubleValue()\n+        + (result[1].doubleValue() / q.doubleValue());\n+  }\n+\n+  /** Check if the instance is equal to another rational number.\n+   * Equality here is having the same value.\n+   * @return true if the object is a rational number which has the\n+   * same value as the instance\n+   */\n+  public boolean equals(Object o) {\n+    if (o instanceof RationalNumber) {\n+      RationalNumber r = (RationalNumber) o;\n+      return (p.compareTo(r.p) == 0) && (q.compareTo(r.q) == 0);\n+    }\n+    return false;\n+  }\n+\n+  /** Returns a hash code value for the object.\n+   * The hash code value is computed from the reduced numerator and\n+   * denominator, hence equal rational numbers have the same hash code,\n+   * as required by the method specification.\n+   * @return a hash code value for this object.\n+   */\n+  public int hashCode() {\n+    return p.hashCode() ^ q.hashCode();\n+  }\n+\n+  /** Returns a string representation of the rational number.\n+   * The representation is reduced: there is no common factor left\n+   * between the numerator and the denominator. The '/' character and\n+   * the denominator are displayed only if the denominator is not\n+   * one. The sign is on the numerator.\n+   * @return string representation of the rational number\n+   */\n+  public String toString() {\n+    return p + ((q.compareTo(BigInteger.ONE) == 0) ? \"\" : (\"/\" + q));\n+  }\n+\n+  /** Numerator. */\n+  private BigInteger p;\n+\n+  /** Denominator. */\n+  private BigInteger q;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/EstimatedParameter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.io.Serializable;\n+\n+/** This class represent the estimated parameters of an estimation problem.\n+\n+ * <p>The parameters of an estimation problem have a name, a value and\n+ * a bound flag. The value of bound parameters is considered trusted\n+ * and the solvers should not adjust them. On the other hand, the\n+ * solvers should adjust the value of unbounds parameters until they\n+ * satisfy convergence criterions specific to each solver.</p>\n+\n+ * @version $Id: EstimatedParameter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EstimatedParameter\n+  implements Serializable {\n+\n+  /** Simple constructor.\n+   * Build an instance from a first estimate of the parameter,\n+   * initially considered unbound.\n+   * @param name name of the parameter\n+   * @param firstEstimate first estimate of the parameter\n+   */\n+  public EstimatedParameter(String name, double firstEstimate) {\n+    this.name = name;\n+    estimate  = firstEstimate;\n+    bound     = false;\n+  }\n+\n+  /** Simple constructor.\n+   * Build an instance from a first estimate of the parameter and a\n+   * bound flag\n+   * @param name name of the parameter\n+   * @param firstEstimate first estimate of the parameter\n+   * @param bound flag, should be true if the parameter is bound\n+   */\n+  public EstimatedParameter(String name,\n+                            double firstEstimate,\n+                            boolean bound) {\n+    this.name  = name;\n+    estimate   = firstEstimate;\n+    this.bound = bound;\n+  }\n+\n+  /** Copy constructor.\n+   * Build a copy of a parameter\n+   * @param parameter instance to copy\n+   */\n+  public EstimatedParameter(EstimatedParameter parameter) {\n+    name     = parameter.name;\n+    estimate = parameter.estimate;\n+    bound    = parameter.bound;\n+  }\n+\n+  /** Set a new estimated value for the parameter.\n+   * @param estimate new estimate for the parameter\n+   */\n+  public void setEstimate(double estimate) {\n+    this.estimate = estimate;\n+  }\n+\n+  /** Get the current estimate of the parameter\n+   * @return current estimate\n+   */\n+  public double getEstimate() {\n+    return estimate;\n+  }\n+\n+  /** get the name of the parameter\n+   * @return parameter name\n+   */\n+  public String getName() {\n+    return name;\n+  }\n+\n+  /** Set the bound flag of the parameter\n+   * @param bound this flag should be set to true if the parameter is\n+   * bound (i.e. if it should not be adjusted by the solver).\n+   */\n+  public void setBound(boolean bound) {\n+    this.bound = bound;\n+  }\n+\n+  /** Check if the parameter is bound\n+   * @return true if the parameter is bound */\n+  public boolean isBound() {\n+    return bound;\n+  }\n+\n+  /** Name of the parameter */\n+  private   String  name;\n+\n+  /** Current value of the parameter */\n+  protected double  estimate;\n+\n+  /** Indicator for bound parameters\n+   * (ie parameters that should not be estimated)\n+   */\n+  private   boolean bound;\n+\n+  private static final long serialVersionUID = -555440800213416949L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/EstimationException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by the estimation solvers.\n+\n+ * @version $Id: EstimationException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EstimationException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception by translating the specified message\n+   * @param message message to translate\n+   */\n+  public EstimationException(String message) {\n+    super(message);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public EstimationException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a cause\n+   * @param cause cause of this exception\n+   */\n+  public EstimationException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  private static final long serialVersionUID = 1613719630569355278L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/EstimationProblem.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+/** This interface represents an estimation problem.\n+\n+ * <p>This interface should be implemented by all real estimation\n+ * problems before they can be handled by the estimators through the\n+ * {@link Estimator#estimate Estimator.estimate} method.</p>\n+\n+ * <p>An estimation problem, as seen by a solver is a set of\n+ * parameters and a set of measurements. The parameters are adjusted\n+ * during the estimation through the {@link #getUnboundParameters\n+ * getUnboundParameters} and {@link EstimatedParameter#setEstimate\n+ * EstimatedParameter.setEstimate} methods. The measurements both have\n+ * a measured value which is generally fixed at construction and a\n+ * theoretical value which depends on the model and hence varies as\n+ * the parameters are adjusted. The purpose of the solver is to reduce\n+ * the residual between these values, it can retrieve the measurements\n+ * through the {@link #getMeasurements getMeasurements} method.</p>\n+\n+ * @see Estimator\n+ * @see WeightedMeasurement\n+\n+ * @version $Id: EstimationProblem.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface EstimationProblem {\n+  /** Get the measurements of an estimation problem.\n+   * @return measurements\n+   */\n+  public WeightedMeasurement[] getMeasurements();\n+\n+  /** Get the unbound parameters of the problem.\n+   * @return unbound parameters\n+   */\n+  public EstimatedParameter[] getUnboundParameters();\n+\n+  /** Get all the parameters of the problem.\n+   * @return parameters\n+   */\n+  public EstimatedParameter[] getAllParameters();\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/Estimator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+/** This interface represents solvers for estimation problems.\n+\n+ * <p>The classes which are devoted to solve estimation problems\n+ * should implement this interface. The problems which can be handled\n+ * should implement the {@link EstimationProblem} interface which\n+ * gather all the information needed by the solver.</p>\n+\n+ * <p>The interface is composed only of the {@link #estimate estimate}\n+ * method.</p>\n+\n+ * @see EstimationProblem\n+\n+ * @version $Id: Estimator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface Estimator {\n+\n+  /** Solve an estimation problem.\n+\n+   * <p>The method should set the parameters of the problem to several\n+   * trial values until it reaches convergence. If this method returns\n+   * normally (i.e. without throwing an exception), then the best\n+   * estimate of the parameters can be retrieved from the problem\n+   * itself, through the {@link EstimationProblem#getAllParameters\n+   * EstimationProblem.getAllParameters} method.</p>\n+\n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if the problem cannot be solved\n+\n+   */\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException;\n+\n+  /** Get the Root Mean Square value.\n+   * Get the Root Mean Square value, i.e. the root of the arithmetic\n+   * mean of the square of all weighted residuals. This is related to the\n+   * criterion that is minimized by the estimator as follows: if\n+   * <em>c</em> if the criterion, and <em>n</em> is the number of\n+   * measurements, the the RMS is <em>sqrt (c/n)</em>.\n+   * @param problem estimation problem\n+   * @return RMS value\n+   */\n+  public double getRMS(EstimationProblem problem);\n+ \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/GaussNewtonEstimator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.linalg.Matrix;\n+import org.spaceroots.mantissa.linalg.GeneralMatrix;\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+import org.spaceroots.mantissa.linalg.SingularMatrixException;\n+\n+/** This class implements a solver for estimation problems.\n+\n+ * <p>This class solves estimation problems using a weighted least\n+ * squares criterion on the measurement residuals. It uses a\n+ * Gauss-Newton algorithm.</p>\n+\n+ * @version $Id: GaussNewtonEstimator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GaussNewtonEstimator\n+  implements Estimator, Serializable {\n+\n+  /** Simple constructor.\n+\n+   * <p>This constructor build an estimator and store its convergence\n+   * characteristics.</p>\n+\n+   * <p>An estimator is considered to have converged whenever either\n+   * the criterion goes below a physical threshold under which\n+   * improvements are considered useless or when the algorithm is\n+   * unable to improve it (even if it is still high). The first\n+   * condition that is met stops the iterations.</p>\n+\n+   * <p>The fact an estimator has converged does not mean that the\n+   * model accurately fits the measurements. It only means no better\n+   * solution can be found, it does not mean this one is good. Such an\n+   * analysis is left to the caller.</p>\n+\n+   * <p>If neither conditions are fulfilled before a given number of\n+   * iterations, the algorithm is considered to have failed and an\n+   * {@link EstimationException} is thrown.</p>\n+\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has converged has reached a steady state if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(Matrix,double)\n+   * SquareMatrix.solve}).  */\n+  public GaussNewtonEstimator(int maxIterations,\n+                               double convergence,\n+                               double steadyStateThreshold,\n+                               double epsilon) {\n+    this.maxIterations        = maxIterations;\n+    this.steadyStateThreshold = steadyStateThreshold;\n+    this.convergence          = convergence;\n+    this.epsilon              = epsilon;\n+  }\n+\n+  /** Solve an estimation problem using a least squares criterion.\n+\n+   * <p>This method set the unbound parameters of the given problem\n+   * starting from their current values through several iterations. At\n+   * each step, the unbound parameters are changed in order to\n+   * minimize a weighted least square criterion based on the\n+   * measurements of the problem.</p>\n+\n+   * <p>The iterations are stopped either when the criterion goes\n+   * below a physical threshold under which improvement are considered\n+   * useless or when the algorithm is unable to improve it (even if it\n+   * is still high). The first condition that is met stops the\n+   * iterations. If the convergence it nos reached before the maximum\n+   * number of iterations, an {@link EstimationException} is\n+   * thrown.</p>\n+\n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if the problem cannot be solved\n+\n+   * @see EstimationProblem\n+\n+   */\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException {\n+    int    iterations = 0;\n+    double previous   = 0.0;\n+    double current    = 0.0;\n+\n+    // iterate until convergence is reached\n+    do {\n+\n+      if (++iterations > maxIterations) {\n+        throw new EstimationException (\"unable to converge in {0} iterations\",\n+                                       new String[] {\n+                                         Integer.toString(maxIterations)\n+                                       });\n+      }\n+\n+      // perform one iteration\n+      linearEstimate(problem);\n+\n+      previous = current;\n+      current  = evaluateCriterion(problem);\n+\n+    } while ((iterations < 2)\n+             || (Math.abs(previous - current) > (current * steadyStateThreshold)\n+                 && (Math.abs(current) > convergence)));\n+\n+  }\n+\n+  /** Estimate the solution of a linear least square problem.\n+\n+   * <p>The Gauss-Newton algorithm is iterative. Each iteration\n+   * consist in solving a linearized least square problem. Several\n+   * iterations are needed for general problems since the\n+   * linearization is only an approximation of the problem\n+   * behaviour. However, for linear problems one iteration is enough\n+   * to get the solution. This method is provided in the public\n+   * interface in order to handle more efficiently these linear\n+   * problems.</p>\n+\n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if the problem cannot be solved\n+\n+   */\n+  public void linearEstimate(EstimationProblem problem)\n+    throws EstimationException {\n+\n+    EstimatedParameter[]  parameters   = problem.getUnboundParameters();\n+    WeightedMeasurement[] measurements = problem.getMeasurements();\n+\n+    // build the linear problem\n+    GeneralMatrix    b = new GeneralMatrix(parameters.length, 1);\n+    SymetricalMatrix a = new SymetricalMatrix(parameters.length);\n+    for (int i = 0; i < measurements.length; ++i) {\n+      if (! measurements [i].isIgnored()) {\n+        double weight   = measurements[i].getWeight();\n+        double residual = measurements[i].getResidual();\n+\n+        // compute the normal equation\n+        double[] grad     = new double[parameters.length];\n+        Matrix bDecrement = new GeneralMatrix(parameters.length, 1);\n+        for (int j = 0; j < parameters.length; ++j) {\n+          grad[j] = measurements[i].getPartial(parameters[j]);\n+          bDecrement.setElement(j, 0, weight * residual * grad[j]);\n+        }\n+\n+        // update the matrices\n+        a.selfAddWAAt(weight, grad);\n+        b.selfAdd(bDecrement);\n+\n+      }\n+    }\n+\n+    try {\n+\n+      // solve the linearized least squares problem\n+      Matrix dX = a.solve(b, epsilon);\n+\n+      // update the estimated parameters\n+      for (int i = 0; i < parameters.length; ++i) {\n+        parameters[i].setEstimate(parameters[i].getEstimate()\n+                                  + dX.getElement(i, 0));\n+      }\n+\n+    } catch(SingularMatrixException e) {\n+      throw new EstimationException(e);\n+    }\n+\n+  }\n+\n+  private double evaluateCriterion(EstimationProblem problem) {\n+    double criterion = 0.0;\n+    WeightedMeasurement[] measurements = problem.getMeasurements();\n+\n+    for (int i = 0; i < measurements.length; ++i) {\n+      double residual = measurements[i].getResidual();\n+      criterion      += measurements[i].getWeight() * residual * residual;\n+    }\n+\n+    return criterion;\n+\n+  }\n+\n+  /** Get the Root Mean Square value.\n+   * Get the Root Mean Square value, i.e. the root of the arithmetic\n+   * mean of the square of all weighted residuals. This is related to the\n+   * criterion that is minimized by the estimator as follows: if\n+   * <em>c</em> if the criterion, and <em>n</em> is the number of\n+   * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+   * @param problem estimation problem\n+   * @return RMS value\n+   */\n+  public double getRMS(EstimationProblem problem) {\n+    double criterion = evaluateCriterion(problem);\n+    int n = problem.getMeasurements().length;\n+    return Math.sqrt(criterion / n);\n+  }\n+\n+  private int    maxIterations;\n+  private double steadyStateThreshold;\n+  private double convergence;\n+  private double epsilon;\n+\n+  private static final long serialVersionUID = -7606628156644194170L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/LeastSquaresEstimator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.io.Serializable;\n+\n+/** This class implements a solver for estimation problems.\n+ * @deprecated this class has been replaced by the {@link\n+ * org.spaceroots.mantissa.estimation.GaussNewtonEstimator GaussNewtonEstimator}\n+ * class. It is now a simple wrapper delegating everything to {@link\n+ * org.spaceroots.mantissa.estimation.GaussNewtonEstimator GaussNewtonEstimator}\n+ * @version $Id: LeastSquaresEstimator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+public class LeastSquaresEstimator implements Estimator, Serializable {\n+\n+  /** Simple constructor.\n+   * @see org.spaceroots.mantissa.estimation.GaussNewtonEstimator#GaussNewtonEstimator(int,\n+   * double, double, double)\n+   */\n+  public LeastSquaresEstimator(int maxIterations,\n+                               double convergence,\n+                               double steadyStateThreshold,\n+                               double epsilon) {\n+    estimator = new GaussNewtonEstimator(maxIterations,\n+                                         convergence,\n+                                         steadyStateThreshold,\n+                                         epsilon);\n+  }\n+\n+  /** Solve an estimation problem using a least squares criterion.\n+   * @see org.spaceroots.mantissa.estimation.GaussNewtonEstimator#estimate\n+   */\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException {\n+    estimator.estimate(problem);\n+   }\n+\n+  /** Estimate the solution of a linear least square problem.\n+   * @see org.spaceroots.mantissa.estimation.GaussNewtonEstimator#linearEstimate\n+   */\n+  public void linearEstimate(EstimationProblem problem)\n+    throws EstimationException {\n+    estimator.linearEstimate(problem);\n+  }\n+\n+  /** Get the Root Mean Square value.\n+   * @see org.spaceroots.mantissa.estimation.GaussNewtonEstimator#getRMS\n+   */\n+  public double getRMS(EstimationProblem problem) {\n+    return estimator.getRMS(problem);\n+  }\n+\n+  private GaussNewtonEstimator estimator;\n+\n+  private static final long serialVersionUID = -7542643494637247770L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/** This class solves a least squares problem.\n+\n+ * <p>This implementation <em>should</em> work even for over-determined systems\n+ * (i.e. systems having more variables than equations). Over-determined systems\n+ * are solved by ignoring the variables which have the smallest impact according\n+ * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n+ * are changed to implement this. This feature has undergone only basic testing\n+ * for now and should still be considered experimental.</p>\n+\n+ * <p>The resolution engine is a simple translation of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n+ * changes. The changes include the over-determined resolution and the Q.R.\n+ * decomposition which has been rewritten following the algorithm described in the\n+ * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n+ * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986. The\n+ * redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n+ * is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran)\n+ * @author Burton S. Garbow (original fortran)\n+ * @author Kenneth E. Hillstrom (original fortran)\n+ * @author Jorge J. More (original fortran)\n+ * @author Luc Maisonobe (Java translation)\n+ */\n+public class LevenbergMarquardtEstimator implements Serializable, Estimator {\n+\n+  /** Build an estimator for least squares problems.\n+   * <p>The default values for the algorithm settings are:\n+   *   <ul>\n+   *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n+   *    <li>{@link #setMaxCostEval maximal cost evaluations}: 1000</li>\n+   *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n+   *    <li>{@link #setParRelativeTolerance parameters relative tolerance}: 1.0e-10</li>\n+   *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n+   *   </ul>\n+   * </p>\n+   */\n+  public LevenbergMarquardtEstimator() {\n+    // default values for the tuning parameters\n+    setInitialStepBoundFactor(100.0);\n+    setMaxCostEval(1000);\n+    setCostRelativeTolerance(1.0e-10);\n+    setParRelativeTolerance(1.0e-10);\n+    setOrthoTolerance(1.0e-10);\n+  }\n+\n+  /** Set the positive input variable used in determining the initial step bound.\n+   * This bound is set to the product of initialStepBoundFactor and the euclidean norm of diag*x if nonzero,\n+   * or else to initialStepBoundFactor itself. In most cases factor should lie\n+   * in the interval (0.1, 100.0). 100.0 is a generally recommended value\n+   * @param initialStepBoundFactor initial step bound factor\n+   * @see #estimate\n+   */\n+  public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n+    this.initialStepBoundFactor = initialStepBoundFactor;\n+  }\n+\n+  /** Set the maximal number of cost evaluations.\n+  * @param maxCostEval maximal number of cost evaluations\n+   * @see #estimate\n+  */\n+  public void setMaxCostEval(int maxCostEval) {\n+    this.maxCostEval = maxCostEval;\n+  }\n+\n+  /** Set the desired relative error in the sum of squares.\n+   * @param costRelativeTolerance desired relative error in the sum of squares\n+   * @see #estimate\n+   */\n+  public void setCostRelativeTolerance(double costRelativeTolerance) {\n+    this.costRelativeTolerance = costRelativeTolerance;\n+  }\n+\n+  /** Set the desired relative error in the approximate solution parameters.\n+   * @param parRelativeTolerance desired relative error\n+   * in the approximate solution parameters\n+   * @see #estimate\n+   */\n+  public void setParRelativeTolerance(double parRelativeTolerance) {\n+    this.parRelativeTolerance = parRelativeTolerance;\n+  }\n+\n+  /** Set the desired max cosine on the orthogonality.\n+   * @param orthoTolerance desired max cosine on the orthogonality\n+   * between the function vector and the columns of the jacobian\n+   * @see #estimate\n+   */\n+  public void setOrthoTolerance(double orthoTolerance) {\n+    this.orthoTolerance = orthoTolerance;\n+  }\n+\n+  /** Get the number of cost evaluations.\n+   * @return number of cost evaluations\n+   * */\n+  public int getCostEvaluations() {\n+    return costEvaluations;\n+  }\n+\n+  /** Get the number of jacobian evaluations.\n+   * @return number of jacobian evaluations\n+   * */\n+  public int getJacobianEvaluations() {\n+    return jacobianEvaluations;\n+  }\n+\n+  /** Update the jacobian matrix.\n+   */\n+  private void updateJacobian() {\n+    ++jacobianEvaluations;\n+    Arrays.fill(jacobian, 0);\n+    for (int i = 0, index = 0; i < rows; i++) {\n+      WeightedMeasurement wm = measurements[i];\n+      double factor = -Math.sqrt(wm.getWeight());\n+      for (int j = 0; j < cols; ++j) {\n+        jacobian[index++] = factor * wm.getPartial(parameters[j]);\n+      }\n+    }\n+  }\n+\n+  /** Update the residuals array and cost function value.\n+   */\n+  private void updateResidualsAndCost() {\n+    ++costEvaluations;\n+    cost = 0;\n+    for (int i = 0, index = 0; i < rows; i++, index += cols) {\n+      WeightedMeasurement wm = measurements[i];\n+      double residual = wm.getResidual();\n+      residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n+      cost += wm.getWeight() * residual * residual;\n+    }\n+    cost = Math.sqrt(cost);\n+  }\n+\n+  /** Get the Root Mean Square value.\n+   * Get the Root Mean Square value, i.e. the root of the arithmetic\n+   * mean of the square of all weighted residuals. This is related to the\n+   * criterion that is minimized by the estimator as follows: if\n+   * <em>c</em> if the criterion, and <em>n</em> is the number of\n+   * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+   * @param problem estimation problem\n+   * @return RMS value\n+   */\n+  public double getRMS(EstimationProblem problem) {\n+    WeightedMeasurement[] wm = problem.getMeasurements();\n+    double criterion = 0;\n+    for (int i = 0; i < wm.length; ++i) {\n+      double residual = wm[i].getResidual();\n+      criterion += wm[i].getWeight() * residual * residual;\n+    }\n+    return Math.sqrt(criterion / wm.length);\n+  }\n+\n+  /** Solve an estimation problem using the Levenberg-Marquardt algorithm.\n+   * <p>The algorithm used is a modified Levenberg-Marquardt one, based\n+   * on the MINPACK <a href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a>\n+   * routine. The algorithm settings must have been set up before this method\n+   * is called with the {@link #setInitialStepBoundFactor},\n+   * {@link #setMaxCostEval}, {@link #setCostRelativeTolerance},\n+   * {@link #setParRelativeTolerance} and {@link #setOrthoTolerance} methods.\n+   * If these methods have not been called, the default values set up by the\n+   * {@link #LevenbergMarquardtEstimator() constructor} will be used.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   *   </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if convergence cannot be\n+   * reached with the specified algorithm settings or if there are more variables\n+   * than equations\n+   * @see #setInitialStepBoundFactor\n+   * @see #setMaxCostEval\n+   * @see #setCostRelativeTolerance\n+   * @see #setParRelativeTolerance\n+   * @see #setOrthoTolerance\n+   */\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException {\n+\n+    // retrieve the equations and the parameters\n+    measurements = problem.getMeasurements();\n+    parameters   = problem.getUnboundParameters();\n+\n+    // arrays shared with the other private methods\n+    rows        = measurements.length;\n+    cols        = parameters.length;\n+    solvedCols  = Math.min(rows, cols);\n+    jacobian    = new double[rows * cols];\n+    diagR       = new double[cols];\n+    jacNorm     = new double[cols];\n+    beta        = new double[cols];\n+    permutation = new int[cols];\n+    lmDir       = new double[cols];\n+    residuals   = new double[rows];\n+\n+    // local variables\n+    double   delta   = 0, xNorm = 0;\n+    double[] diag    = new double[cols];\n+    double[] oldX    = new double[cols];\n+    double[] oldRes  = new double[rows];\n+    double[] work1   = new double[cols];\n+    double[] work2   = new double[cols];\n+    double[] work3   = new double[cols];\n+\n+    // evaluate the function at the starting point and calculate its norm\n+    updateResidualsAndCost();\n+    \n+    // outer loop\n+    lmPar               = 0;\n+    costEvaluations     = 0;\n+    jacobianEvaluations = 0;\n+    boolean firstIteration = true;\n+    while (costEvaluations < maxCostEval) {\n+\n+      // compute the Q.R. decomposition of the jacobian matrix\n+      updateJacobian();\n+      qrDecomposition();\n+\n+      // compute Qt.res\n+      qTy(residuals);\n+\n+      // now we don't need Q anymore,\n+      // so let jacobian contain the R matrix with its diagonal elements\n+      for (int k = 0; k < solvedCols; ++k) {\n+        int pk = permutation[k];\n+        jacobian[k * cols + pk] = diagR[pk];\n+      }\n+\n+      if (firstIteration) {\n+\n+        // scale the variables according to the norms of the columns\n+        // of the initial jacobian\n+        xNorm = 0;\n+        for (int k = 0; k < cols; ++k) {\n+          double dk = jacNorm[k];\n+          if (dk == 0) {\n+            dk = 1.0;\n+          }\n+          double xk = dk * parameters[k].getEstimate();\n+          xNorm  += xk * xk;\n+          diag[k] = dk;\n+        }\n+        xNorm = Math.sqrt(xNorm);\n+        \n+        // initialize the step bound delta\n+        delta = (xNorm == 0)\n+              ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+ \n+      }\n+\n+      // check orthogonality between function vector and jacobian columns\n+      double maxCosine = 0;\n+      if (cost != 0) {\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int    pj = permutation[j];\n+          double s  = jacNorm[pj];\n+          if (s != 0) {\n+            double sum = 0;\n+            for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+              sum += jacobian[index] * residuals[i];\n+            }\n+            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+          }\n+        }\n+      }\n+      if (maxCosine <= orthoTolerance) {\n+        return;\n+      }\n+\n+      // rescale if necessary\n+      for (int j = 0; j < cols; ++j) {\n+        diag[j] = Math.max(diag[j], jacNorm[j]);\n+      }\n+\n+      // inner loop\n+      for (double ratio = 0; ratio < 1.0e-4;) {\n+\n+        // save the state\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          oldX[pj] = parameters[pj].getEstimate();\n+        }\n+        double previousCost = cost;\n+        double[] tmpVec = residuals;\n+        residuals = oldRes;\n+        oldRes    = tmpVec;\n+        \n+        // determine the Levenberg-Marquardt parameter\n+        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+\n+        // compute the new point and the norm of the evolution direction\n+        double lmNorm = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          lmDir[pj] = -lmDir[pj];\n+          parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);\n+          double s = diag[pj] * lmDir[pj];\n+          lmNorm  += s * s;\n+        }\n+        lmNorm = Math.sqrt(lmNorm);\n+\n+        // on the first iteration, adjust the initial step bound.\n+        if (firstIteration) {\n+          delta = Math.min(delta, lmNorm);\n+        }\n+\n+        // evaluate the function at x + p and calculate its norm\n+        updateResidualsAndCost();\n+\n+        // compute the scaled actual reduction\n+        double actRed = -1.0;\n+        if (0.1 * cost < previousCost) {\n+          double r = cost / previousCost;\n+          actRed = 1.0 - r * r;\n+        }\n+\n+        // compute the scaled predicted reduction\n+        // and the scaled directional derivative\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          double dirJ = lmDir[pj];\n+          work1[j] = 0;\n+          for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+            work1[i] += jacobian[index] * dirJ;\n+          }\n+        }\n+        double coeff1 = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+         coeff1 += work1[j] * work1[j];\n+        }\n+        double pc2 = previousCost * previousCost;\n+        coeff1 = coeff1 / pc2;\n+        double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n+        double preRed = coeff1 + 2 * coeff2;\n+        double dirDer = -(coeff1 + coeff2);\n+\n+        // ratio of the actual to the predicted reduction\n+        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n+\n+        // update the step bound\n+        if (ratio <= 0.25) {\n+          double tmp =\n+            (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n+          if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n+            tmp = 0.1;\n+          }\n+          delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+          lmPar /= tmp;\n+        } else if ((lmPar == 0) || (ratio >= 0.75)) {\n+          delta = 2 * lmNorm;\n+          lmPar *= 0.5;\n+        }\n+\n+        // test for successful iteration.\n+        if (ratio >= 1.0e-4) {\n+          // successful iteration, update the norm\n+          firstIteration = false;\n+          xNorm = 0;\n+          for (int k = 0; k < cols; ++k) {\n+            double xK = diag[k] * parameters[k].getEstimate();\n+            xNorm    += xK * xK;\n+          }\n+          xNorm = Math.sqrt(xNorm);\n+        } else {\n+          // failed iteration, reset the previous values\n+          cost = previousCost;\n+          for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            parameters[pj].setEstimate(oldX[pj]);\n+          }\n+          tmpVec    = residuals;\n+          residuals = oldRes;\n+          oldRes    = tmpVec;\n+        }\n+   \n+        // tests for convergence.\n+        if (((Math.abs(actRed) <= costRelativeTolerance)\n+            && (preRed <= costRelativeTolerance)\n+            && (ratio <= 2.0))\n+            || (delta <= parRelativeTolerance * xNorm)) {\n+          return;\n+        }\n+\n+        // tests for termination and stringent tolerances\n+        // (2.2204e-16 is the machine epsilon for IEEE754)\n+        if (costEvaluations >= maxCostEval) {\n+          break;\n+        }\n+        if ((Math.abs(actRed) <= 2.2204e-16)\n+            && (preRed <= 2.2204e-16)\n+            && (ratio <= 2.0)) {\n+          throw new EstimationException(\"cost relative tolerance is too small ({0}),\"\n+                                      + \" no further reduction in the\"\n+                                      + \" sum of squares is possible\",\n+                                        new String[] {\n+                                          Double.toString(costRelativeTolerance)\n+                                        });\n+        } else if (delta <= 2.2204e-16 * xNorm) {\n+          throw new EstimationException(\"parameters relative tolerance is too small\"\n+                                      + \" ({0}), no further improvement in\"\n+                                      + \" the approximate solution is possible\",\n+                                        new String[] {\n+                                          Double.toString(parRelativeTolerance)\n+                                        });\n+        } else if (maxCosine <= 2.2204e-16)  {\n+          throw new EstimationException(\"orthogonality tolerance is too small ({0}),\"\n+                                      + \" solution is orthogonal to the jacobian\",\n+                                        new String[] {\n+                                          Double.toString(orthoTolerance)\n+                                        });\n+        }\n+\n+      }\n+\n+    }\n+\n+    throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n+                                  new String[] {\n+                                    Integer.toString(maxCostEval)\n+                                  });\n+\n+  }\n+\n+  /** Determine the Levenberg-Marquardt parameter.\n+   * <p>This implementation is a translation in Java of the MINPACK\n+   * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n+   * routine.</p>\n+   * <p>This method sets the lmPar and lmDir attributes.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   * </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * @param qy array containing qTy\n+   * @param delta upper bound on the euclidean norm of diagR * lmDir\n+   * @param diag diagonal matrix\n+   * @param work1 work array\n+   * @param work2 work array\n+   * @param work3 work array\n+   */\n+  private void determineLMParameter(double[] qy, double delta, double[] diag,\n+                                    double[] work1, double[] work2, double[] work3) {\n+\n+    // compute and store in x the gauss-newton direction, if the\n+    // jacobian is rank-deficient, obtain a least squares solution\n+    for (int j = 0; j < rank; ++j) {\n+      lmDir[permutation[j]] = qy[j];\n+    }\n+    for (int j = rank; j < cols; ++j) {\n+      lmDir[permutation[j]] = 0;\n+    }\n+    for (int k = rank - 1; k >= 0; --k) {\n+      int pk = permutation[k];\n+      double ypk = lmDir[pk] / diagR[pk];\n+      for (int i = 0, index = pk; i < k; ++i, index += cols) {\n+        lmDir[permutation[i]] -= ypk * jacobian[index];\n+      }\n+      lmDir[pk] = ypk;\n+    }\n+\n+    // evaluate the function at the origin, and test\n+    // for acceptance of the Gauss-Newton direction\n+    double dxNorm = 0;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      double s = diag[pj] * lmDir[pj];\n+      work1[pj] = s;\n+      dxNorm += s * s;\n+    }\n+    dxNorm = Math.sqrt(dxNorm);\n+    double fp = dxNorm - delta;\n+    if (fp <= 0.1 * delta) {\n+      lmPar = 0;\n+      return;\n+    }\n+\n+    // if the jacobian is not rank deficient, the Newton step provides\n+    // a lower bound, parl, for the zero of the function,\n+    // otherwise set this bound to zero\n+    double sum2, parl = 0;\n+    if (rank == solvedCols) {\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] *= diag[pj] / dxNorm; \n+      }\n+      sum2 = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        double sum = 0;\n+        for (int i = 0, index = pj; i < j; ++i, index += cols) {\n+          sum += jacobian[index] * work1[permutation[i]];\n+        }\n+        double s = (work1[pj] - sum) / diagR[pj];\n+        work1[pj] = s;\n+        sum2 += s * s;\n+      }\n+      parl = fp / (delta * sum2);\n+    }\n+\n+    // calculate an upper bound, paru, for the zero of the function\n+    sum2 = 0;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      double sum = 0;\n+      for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+        sum += jacobian[index] * qy[i];\n+      }\n+      sum /= diag[pj];\n+      sum2 += sum * sum;\n+    }\n+    double gNorm = Math.sqrt(sum2);\n+    double paru = gNorm / delta;\n+    if (paru == 0) {\n+      // 2.2251e-308 is the smallest positive real for IEE754\n+      paru = 2.2251e-308 / Math.min(delta, 0.1);\n+    }\n+\n+    // if the input par lies outside of the interval (parl,paru),\n+    // set par to the closer endpoint\n+    lmPar = Math.min(paru, Math.max(lmPar, parl));\n+    if (lmPar == 0) {\n+      lmPar = gNorm / dxNorm;\n+    }\n+\n+    for (int countdown = 10; countdown >= 0; --countdown) {\n+\n+      // evaluate the function at the current value of lmPar\n+      if (lmPar == 0) {\n+        lmPar = Math.max(2.2251e-308, 0.001 * paru);\n+      }\n+      double sPar = Math.sqrt(lmPar);\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] = sPar * diag[pj];\n+      }\n+      determineLMDirection(qy, work1, work2, work3);\n+\n+      dxNorm = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        double s = diag[pj] * lmDir[pj];\n+        work3[pj] = s;\n+        dxNorm += s * s;\n+      }\n+      dxNorm = Math.sqrt(dxNorm);\n+      double previousFP = fp;\n+      fp = dxNorm - delta;\n+\n+      // if the function is small enough, accept the current value\n+      // of lmPar, also test for the exceptional cases where parl is zero\n+      if ((Math.abs(fp) <= 0.1 * delta)\n+          || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n+        return;\n+      }\n+ \n+      // compute the Newton correction\n+      for (int j = 0; j < solvedCols; ++j) {\n+       int pj = permutation[j];\n+        work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+      }\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] /= work2[j];\n+        double tmp = work1[pj];\n+        for (int i = j + 1; i < solvedCols; ++i) {\n+          work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;\n+        }\n+      }\n+      sum2 = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        double s = work1[permutation[j]];\n+        sum2 += s * s;\n+      }\n+      double correction = fp / (delta * sum2);\n+\n+      // depending on the sign of the function, update parl or paru.\n+      if (fp > 0) {\n+        parl = Math.max(parl, lmPar);\n+      } else if (fp < 0) {\n+        paru = Math.min(paru, lmPar);\n+      }\n+\n+      // compute an improved estimate for lmPar\n+      lmPar = Math.max(parl, lmPar + correction);\n+\n+    }\n+  }\n+\n+  /** Solve a*x = b and d*x = 0 in the least squares sense.\n+   * <p>This implementation is a translation in Java of the MINPACK\n+   * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n+   * routine.</p>\n+   * <p>This method sets the lmDir and lmDiag attributes.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   * </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * @param qy array containing qTy\n+   * @param diag diagonal matrix\n+   * @param lmDiag diagonal elements associated with lmDir\n+   * @param work work array\n+   */\n+  private void determineLMDirection(double[] qy, double[] diag,\n+                                    double[] lmDiag, double[] work) {\n+\n+    // copy R and Qty to preserve input and initialize s\n+    //  in particular, save the diagonal elements of R in lmDir\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      for (int i = j + 1; i < solvedCols; ++i) {\n+        jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];\n+      }\n+      lmDir[j] = diagR[pj];\n+      work[j]  = qy[j];\n+    }\n+\n+    // eliminate the diagonal matrix d using a Givens rotation\n+    for (int j = 0; j < solvedCols; ++j) {\n+\n+      // prepare the row of d to be eliminated, locating the\n+      // diagonal element using p from the Q.R. factorization\n+      int pj = permutation[j];\n+      double dpj = diag[pj];\n+      if (dpj != 0) {\n+        Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n+      }\n+      lmDiag[j] = dpj;\n+\n+      //  the transformations to eliminate the row of d\n+      // modify only a single element of Qty\n+      // beyond the first n, which is initially zero.\n+      double qtbpj = 0;\n+      for (int k = j; k < solvedCols; ++k) {\n+        int pk = permutation[k];\n+\n+        // determine a Givens rotation which eliminates the\n+        // appropriate element in the current row of d\n+        if (lmDiag[k] != 0) {\n+\n+          double sin, cos;\n+          double rkk = jacobian[k * cols + pk];\n+          if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+            double cotan = rkk / lmDiag[k];\n+            sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+            cos   = sin * cotan;\n+          } else {\n+            double tan = lmDiag[k] / rkk;\n+            cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+            sin = cos * tan;\n+          }\n+\n+          // compute the modified diagonal element of R and\n+          // the modified element of (Qty,0)\n+          jacobian[k * cols + pk] = cos * rkk + sin * lmDiag[k];\n+          double temp = cos * work[k] + sin * qtbpj;\n+          qtbpj = -sin * work[k] + cos * qtbpj;\n+          work[k] = temp;\n+\n+          // accumulate the tranformation in the row of s\n+          for (int i = k + 1; i < solvedCols; ++i) {\n+            double rik = jacobian[i * cols + pk];\n+            temp = cos * rik + sin * lmDiag[i];\n+            lmDiag[i] = -sin * rik + cos * lmDiag[i];\n+            jacobian[i * cols + pk] = temp;\n+          }\n+\n+        }\n+      }\n+\n+      // store the diagonal element of s and restore\n+      // the corresponding diagonal element of R\n+      int index = j * cols + permutation[j];\n+      lmDiag[j]       = jacobian[index];\n+      jacobian[index] = lmDir[j];\n+\n+    }\n+\n+    // solve the triangular system for z, if the system is\n+    // singular, then obtain a least squares solution\n+    int nSing = solvedCols;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n+        nSing = j;\n+      }\n+      if (nSing < solvedCols) {\n+        work[j] = 0;\n+      }\n+    }\n+    if (nSing > 0) {\n+      for (int j = nSing - 1; j >= 0; --j) {\n+        int pj = permutation[j];\n+        double sum = 0;\n+        for (int i = j + 1; i < nSing; ++i) {\n+          sum += jacobian[i * cols + pj] * work[i];\n+        }\n+        work[j] = (work[j] - sum) / lmDiag[j];\n+      }\n+    }\n+\n+    // permute the components of z back to components of lmDir\n+    for (int j = 0; j < lmDir.length; ++j) {\n+      lmDir[permutation[j]] = work[j];\n+    }\n+\n+  }\n+\n+  /** Decompose a matrix A as A.P = Q.R using Householder transforms.\n+   * <p>As suggested in the P. Lascaux and R. Theodor book\n+   * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n+   * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n+   * the Householder transforms with u<sub>k</sub> unit vectors such that:\n+   * <pre>\n+   * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n+   * </pre>\n+   * we use <sub>k</sub> non-unit vectors such that:\n+   * <pre>\n+   * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n+   * </pre>\n+   * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n+   * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n+   * them from the v<sub>k</sub> vectors would be costly.</p>\n+   * <p>This decomposition handles rank deficient cases since the tranformations\n+   * are performed in non-increasing columns norms order thanks to columns\n+   * pivoting. The diagonal elements of the R matrix are therefore also in\n+   * non-increasing absolute values order.</p>\n+   */\n+  private void qrDecomposition() {\n+\n+    // initializations\n+    for (int k = 0; k < cols; ++k) {\n+      permutation[k] = k;\n+      double norm2 = 0;\n+      for (int index = k; index < jacobian.length; index += cols) {\n+        double akk = jacobian[index];\n+        norm2 += akk * akk;\n+      }\n+      jacNorm[k] = Math.sqrt(norm2);\n+    }\n+\n+    // transform the matrix column after column\n+    for (int k = 0; k < cols; ++k) {\n+\n+      // select the column with the greatest norm on active components\n+      int nextColumn = -1;\n+      double ak2 = Double.NEGATIVE_INFINITY;\n+      for (int i = k; i < cols; ++i) {\n+        double norm2 = 0;\n+        int iDiag = k * cols + permutation[i];\n+        for (int index = iDiag; index < jacobian.length; index += cols) {\n+          double aki = jacobian[index];\n+          norm2 += aki * aki;\n+        }\n+        if (norm2 > ak2) {\n+          nextColumn = i;\n+          ak2        = norm2;\n+        }\n+      }\n+      if (ak2 == 0) {\n+        rank = k;\n+        return;\n+      }\n+      int pk                  = permutation[nextColumn];\n+      permutation[nextColumn] = permutation[k];\n+      permutation[k]          = pk;\n+\n+      // choose alpha such that Hk.u = alpha ek\n+      int    kDiag = k * cols + pk;\n+      double akk   = jacobian[kDiag];\n+      double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+      double betak = 1.0 / (ak2 - akk * alpha);\n+      beta[pk]     = betak;\n+\n+      // transform the current column\n+      diagR[pk]        = alpha;\n+      jacobian[kDiag] -= alpha;\n+\n+      // transform the remaining columns\n+      for (int dk = cols - 1 - k; dk > 0; --dk) {\n+        int dkp = permutation[k + dk] - pk;\n+        double gamma = 0;\n+        for (int index = kDiag; index < jacobian.length; index += cols) {\n+          gamma += jacobian[index] * jacobian[index + dkp];\n+        }\n+        gamma *= betak;\n+        for (int index = kDiag; index < jacobian.length; index += cols) {\n+          jacobian[index + dkp] -= gamma * jacobian[index];\n+        }\n+      }\n+\n+    }\n+\n+    rank = solvedCols;\n+\n+  }\n+\n+  /** Compute the product Qt.y for some Q.R. decomposition.\n+   * @param y vector to multiply (will be overwritten with the result)\n+   */\n+  private void qTy(double[] y) {\n+    for (int k = 0; k < cols; ++k) {\n+      int pk = permutation[k];\n+      int kDiag = k * cols + pk;\n+      double gamma = 0;\n+      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+        gamma += jacobian[index] * y[i];\n+      }\n+      gamma *= beta[pk];\n+      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+        y[i] -= gamma * jacobian[index];\n+      }\n+    }\n+  }\n+\n+  /** Array of measurements. */\n+  private WeightedMeasurement[] measurements;\n+\n+  /** Array of parameters. */\n+  private EstimatedParameter[] parameters;\n+\n+  /** Jacobian matrix.\n+   * <p>Depending on the computation phase, this matrix is either in\n+   * canonical form (just after the calls to updateJacobian) or in\n+   * Q.R. decomposed form (after calls to qrDecomposition)</p>\n+   */\n+  private double[] jacobian;\n+\n+  /** Number of columns of the jacobian matrix. */\n+  private int cols;\n+\n+  /** Number of solved variables. */\n+  private int solvedCols;\n+\n+  /** Number of rows of the jacobian matrix. */\n+  private int rows;\n+\n+  /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n+  private double[] diagR;\n+\n+  /** Norms of the columns of the jacobian matrix. */\n+  private double[] jacNorm;\n+\n+  /** Coefficients of the Householder transforms vectors. */\n+  private double[] beta;\n+\n+  /** Columns permutation array. */\n+  private int[] permutation;\n+\n+  /** Rank of the jacobian matrix. */\n+  private int rank;\n+\n+  /** Levenberg-Marquardt parameter. */\n+  private double lmPar;\n+\n+  /** Parameters evolution direction associated with lmPar. */\n+  private double[] lmDir;\n+\n+  /** Residuals array.\n+   * <p>Depending on the computation phase, this array is either in\n+   * canonical form (just after the calls to updateResiduals) or in\n+   * premultiplied by Qt form (just after calls to qTy)</p>\n+   */\n+  private double[] residuals;\n+\n+  /** Cost value (square root of the sum of the residuals). */\n+  private double cost;\n+\n+  /** Positive input variable used in determining the initial step bound. */\n+  private double initialStepBoundFactor;\n+\n+  /** Maximal number of cost evaluations. */\n+  private int maxCostEval;\n+\n+  /** Number of cost evaluations. */\n+  private int costEvaluations;\n+\n+  /** Number of jacobian evaluations. */\n+  private int jacobianEvaluations;\n+\n+  /** Desired relative error in the sum of squares. */\n+  private double costRelativeTolerance;\n+\n+  /**  Desired relative error in the approximate solution parameters. */\n+  private double parRelativeTolerance;\n+\n+  /** Desired max cosine on the orthogonality between the function vector\n+   * and the columns of the jacobian. */\n+  private double orthoTolerance;\n+\n+  private static final long serialVersionUID = 5387476316105068340L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/estimation/WeightedMeasurement.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.io.Serializable;\n+\n+/** This class represents measurements in estimation problems.\n+\n+ * <p>This abstract class implements all the methods needed to handle\n+ * measurements in a general way. It defines neither the {@link\n+ * #getTheoreticalValue getTheoreticalValue} nor the {@link\n+ * #getPartial getPartial} methods, which should be defined by\n+ * sub-classes according to the specific problem.</p>\n+\n+ * <p>The {@link #getTheoreticalValue getTheoreticalValue} and {@link\n+ * #getPartial getPartial} methods must always use the current\n+ * estimate of the parameters set by the solver in the problem. These\n+ * parameters can be retrieved through the {@link\n+ * EstimationProblem#getAllParameters\n+ * EstimationProblem.getAllParameters} method if the measurements are\n+ * independant of the problem, or directly if they are implemented as\n+ * inner classes of the problem.</p>\n+\n+ * <p>The instances for which the <code>ignored</code> flag is set\n+ * through the {@link #setIgnored setIgnored} method are ignored by the\n+ * solvers. This can be used to reject wrong measurements at some\n+ * steps of the estimation.</p>\n+\n+ * @see EstimationProblem\n+\n+ * @version $Id: WeightedMeasurement.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class WeightedMeasurement implements Serializable {\n+\n+  /** Simple constructor.\n+   * Build a measurement with the given parameters, and set its ignore\n+   * flag to false.\n+   * @param weight weight of the measurement in the least squares problem\n+   * (two common choices are either to use 1.0 for all measurements, or to\n+   * use a value proportional to the inverse of the variance of the measurement\n+   * type)\n+   * @param measuredValue measured value\n+   */\n+  public WeightedMeasurement(double weight, double measuredValue) {\n+    this.weight        = weight;\n+    this.measuredValue = measuredValue;\n+    ignored            = false;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a measurement with the given parameters\n+   * @param weight weight of the measurement in the least squares problem\n+   * @param measuredValue measured value\n+   * @param ignored true if the measurement should be ignored\n+   */\n+  public WeightedMeasurement(double weight, double measuredValue,\n+                             boolean ignored) {\n+    this.weight        = weight;\n+    this.measuredValue = measuredValue;\n+    this.ignored       = ignored;\n+  }\n+\n+  /** Get the weight of the measurement in the least squares problem\n+   * @return weight\n+   */\n+  public double getWeight() {\n+    return weight;\n+  }\n+\n+  /** Get the measured value\n+   * @return measured value\n+   */\n+  public double getMeasuredValue() {\n+    return measuredValue;\n+  }\n+\n+  /** Get the residual for this measurement\n+   * The residual is the measured value minus the theoretical value.\n+   * @return residual\n+   */\n+  public double getResidual() {\n+    return measuredValue - getTheoreticalValue();\n+  }\n+\n+  /** Get the theoretical value expected for this measurement\n+   * <p>The theoretical value is the value expected for this measurement\n+   * if the model and its parameter were all perfectly known.</p>\n+   * <p>The value must be computed using the current estimate of the parameters\n+   * set by the solver in the problem.</p>\n+   * @return theoretical value\n+   */\n+  public abstract double getTheoreticalValue();\n+\n+  /** Get the partial derivative of the {@link #getTheoreticalValue\n+   * theoretical value} according to the parameter.\n+   * <p>The value must be computed using the current estimate of the parameters\n+   * set by the solver in the problem.</p>\n+   * @param parameter parameter against which the partial derivative\n+   * should be computed\n+   * @return partial derivative of the {@link #getTheoreticalValue\n+   * theoretical value}\n+   */\n+  public abstract double getPartial(EstimatedParameter parameter);\n+\n+  /** Set the ignore flag to the specified value\n+   * Setting the ignore flag to true allow to reject wrong\n+   * measurements, which sometimes can be detected only rather late.\n+   * @param ignored value for the ignore flag\n+   */\n+  public void setIgnored(boolean ignored) {\n+    this.ignored = ignored;\n+  }\n+\n+  /** Check if this measurement should be ignored\n+   * @return true if the measurement should be ignored\n+   */\n+  public boolean isIgnored() {\n+    return ignored;\n+  }\n+\n+  private final double  weight;\n+  private final double  measuredValue;\n+  private       boolean ignored;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Iterator;\n+\n+import org.spaceroots.mantissa.estimation.*;\n+\n+/** This class is the base class for all curve fitting classes in the package.\n+\n+ * <p>This class handles all common features of curve fitting like the\n+ * sample points handling. It declares two methods ({@link\n+ * #valueAt} and {@link #partial}) which should be implemented by\n+ * sub-classes to define the precise shape of the curve they\n+ * represent.</p>\n+\n+ * @version $Id: AbstractCurveFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class AbstractCurveFitter\n+  implements EstimationProblem, Serializable {\n+\n+  /**\n+   * Simple constructor.\n+   * @param n number of coefficients in the underlying function\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+   */\n+  protected AbstractCurveFitter(int n,\n+                                int maxIterations,\n+                                double convergence,\n+                                double steadyStateThreshold,\n+                                double epsilon) {\n+\n+    coefficients              = new EstimatedParameter[n];\n+    measurements              = new ArrayList();\n+    measurementsArray         = null;\n+    this.maxIterations        = maxIterations;\n+    this.steadyStateThreshold = steadyStateThreshold;\n+    this.convergence          = convergence;\n+    this.epsilon              = epsilon;\n+\n+  }\n+\n+  /**\n+   * Simple constructor.\n+   * @param coefficients first estimate of the coefficients. A\n+   * reference to this array is hold by the newly created object. Its\n+   * elements will be adjusted during the fitting process and they will\n+   * be set to the adjusted coefficients at the end.\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+   */\n+  protected AbstractCurveFitter(EstimatedParameter[] coefficients,\n+                                int maxIterations,\n+                                double convergence,\n+                                double steadyStateThreshold,\n+                                double epsilon) {\n+\n+    this.coefficients         = coefficients;\n+    measurements              = new ArrayList();\n+    measurementsArray         = null;\n+    this.maxIterations        = maxIterations;\n+    this.steadyStateThreshold = steadyStateThreshold;\n+    this.convergence          = convergence;\n+    this.epsilon              = epsilon;\n+  }\n+\n+  /** Add a weighted (x,y) pair to the sample.\n+   * @param weight weight of this pair in the fit\n+   * @param x      abscissa\n+   * @param y      ordinate, we have <code>y = f (x)</code>\n+   */\n+  public void addWeightedPair(double weight, double x, double y) {\n+    measurementsArray = null;\n+    measurements.add(new FitMeasurement(weight, x, y));\n+  }\n+\n+  /** Perform the fitting.\n+\n+   * <p>This method compute the coefficients of the curve that best\n+   * fit the sample of weighted pairs previously given through calls\n+   * to the {@link #addWeightedPair addWeightedPair} method.</p>\n+\n+   * @return coefficients of the curve\n+   * @exception EstimationException if the fitting is not possible\n+   * (for example if the sample has to few independant points)\n+\n+   */\n+  public double[] fit()\n+    throws EstimationException {\n+    // perform the fit using a linear least square estimator\n+    new GaussNewtonEstimator(maxIterations, convergence,\n+                             steadyStateThreshold, epsilon).estimate(this);\n+\n+    // extract the coefficients\n+    double[] fittedCoefficients = new double[coefficients.length];\n+    for (int i = 0; i < coefficients.length; ++i) {\n+      fittedCoefficients[i] = coefficients[i].getEstimate();\n+    }\n+\n+    return fittedCoefficients;\n+\n+  }\n+\n+  public WeightedMeasurement[] getMeasurements() {\n+    if (measurementsArray == null) {\n+      measurementsArray = new FitMeasurement[measurements.size()];\n+      int i = 0;\n+      for (Iterator iterator = measurements.iterator(); iterator.hasNext(); ++i) {\n+        measurementsArray[i] = (FitMeasurement) iterator.next();\n+      }\n+    }\n+    return measurementsArray;\n+  }\n+\n+  /** Get the unbound parameters of the problem.\n+   * For a curve fitting, none of the function coefficient is bound.\n+   * @return unbound parameters\n+   */\n+  public EstimatedParameter[] getUnboundParameters() {\n+   return coefficients;\n+  }\n+\n+  /** Get all the parameters of the problem.\n+   * @return parameters\n+   */\n+  public EstimatedParameter[] getAllParameters() {\n+   return coefficients;\n+  }\n+\n+  /** Utility method to sort the measurements with respect to the abscissa.\n+\n+   * <p>This method is provided as a utility for derived classes. As\n+   * an example, the {@link HarmonicFitter} class needs it in order to\n+   * compute a first guess of the coefficients to initialize the\n+   * estimation algorithm.</p>\n+\n+   */\n+  protected void sortMeasurements() {\n+\n+    // Since the samples are almost always already sorted, this\n+    // method is implemented as an insertion sort that reorders the\n+    // elements in place. Insertion sort is very efficient in this case.\n+    FitMeasurement curr = (FitMeasurement) measurements.get(0);\n+    for (int j = 1; j < measurements.size (); ++j) {\n+      FitMeasurement prec = curr;\n+      curr = (FitMeasurement) measurements.get(j);\n+      if (curr.x < prec.x) {\n+        // the current element should be inserted closer to the beginning\n+        int i = j - 1;\n+        FitMeasurement mI = (FitMeasurement) measurements.get(i);\n+        while ((i >= 0) && (curr.x < mI.x)) {\n+          measurements.set(i + 1, mI);\n+          if (i-- != 0) {\n+            mI = (FitMeasurement) measurements.get(i);\n+          } else {\n+            mI = null;\n+          }\n+        }\n+        measurements.set(i + 1, curr);\n+        curr = (FitMeasurement) measurements.get(j);\n+      }\n+    }\n+\n+    // make sure subsequent calls to getMeasurements\n+    // will not use the unsorted array\n+    measurementsArray = null;\n+\n+  }\n+\n+  /** Get the value of the function at x according to the current parameters value.\n+   * @param x abscissa at which the theoretical value is requested\n+   * @return theoretical value at x\n+   */\n+  public abstract double valueAt(double x);\n+\n+  /** Get the derivative of the function at x with respect to parameter p.\n+   * @param x abscissa at which the partial derivative is requested\n+   * @param p parameter with respect to which the derivative is requested\n+   * @return partial derivative\n+   */\n+  public abstract double partial(double x, EstimatedParameter p);\n+\n+  /** This class represents the fit measurements.\n+   * One measurement is a weighted pair (x, y), where <code>y = f\n+   * (x)</code> is the value of the function at x abscissa. This class\n+   * is an inner class because the methods related to the computation\n+   * of f values and derivative are proveded by the fitter\n+   * implementations.\n+   */\n+  public class FitMeasurement\n+    extends WeightedMeasurement {\n+\n+    /** Simple constructor.\n+     * @param weight weight of the measurement in the fitting process\n+     * @param x abscissa of the measurement\n+     * @param y ordinate of the measurement\n+     */\n+    public FitMeasurement(double weight, double x, double y) {\n+      super(weight, y);\n+      this.x = x;\n+    }\n+\n+    /** Get the value of the fitted function at x.\n+     * @return theoretical value at the measurement abscissa\n+     */\n+    public double getTheoreticalValue() {\n+      return valueAt(x);\n+    }\n+\n+    /** Partial derivative with respect to one function coefficient.\n+     * @param p parameter with respect to which the derivative is requested\n+     * @return partial derivative\n+     */\n+    public double getPartial(EstimatedParameter p) {\n+     return partial(x, p);\n+    }\n+\n+    /** Abscissa of the measurement. */\n+    public final double x;\n+\n+    private static final long serialVersionUID = -2682582852369995960L;\n+\n+  }\n+\n+  /** Coefficients of the function */\n+  protected EstimatedParameter[] coefficients;\n+\n+  /** Measurements vector */\n+  protected List measurements;\n+\n+  /** Measurements array.\n+   * This array contains the same entries as measurements_, but in a\n+   * different structure.\n+   */\n+  private FitMeasurement[] measurementsArray;\n+\n+  private int    maxIterations;\n+  private double convergence;\n+  private double steadyStateThreshold;\n+  private double epsilon;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+import org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair;\n+\n+/** This class provides sampled values of the function t -> [f(t)^2, f'(t)^2].\n+\n+ * This class is a helper class used to compute a first guess of the\n+ * harmonic coefficients of a function <code>f (t) = a cos (omega t +\n+ * phi)</code>.\n+\n+ * @see FFPIterator\n+ * @see HarmonicCoefficientsGuesser\n+\n+ * @version $Id: F2FP2Iterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class F2FP2Iterator\n+  implements SampledFunctionIterator, Serializable {\n+\n+  public F2FP2Iterator(AbstractCurveFitter.FitMeasurement[] measurements) {\n+    ffpIterator = new FFPIterator(measurements);\n+  }\n+\n+  public int getDimension() {\n+    return 2;\n+  }\n+\n+  public boolean hasNext() {\n+    return ffpIterator.hasNext();\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    // get the raw values from the underlying FFPIterator\n+    VectorialValuedPair point = ffpIterator.nextSamplePoint();\n+\n+    // hack the values (to avoid building a new object)\n+    double[] y = point.getY();\n+    y[0] *= y[0];\n+    y[1] *= y[1];\n+    return point;\n+\n+  }\n+\n+  private FFPIterator ffpIterator;\n+\n+  private static final long serialVersionUID = -8113110433795298072L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/FFPIterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+import org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair;\n+\n+/** This class provides sampled values of the function t -> [f(t), f'(t)].\n+\n+ * This class is a helper class used to compute a first guess of the\n+ * harmonic coefficients of a function <code>f (t) = a cos (omega t +\n+ * phi)</code>.\n+\n+ * @see F2FP2Iterator\n+ * @see HarmonicCoefficientsGuesser\n+\n+ * @version $Id: FFPIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class FFPIterator\n+  implements SampledFunctionIterator, Serializable {\n+\n+  public FFPIterator(AbstractCurveFitter.FitMeasurement[] measurements) {\n+    this.measurements = measurements;\n+\n+    // initialize the points of the raw sample\n+    current   = measurements[0];\n+    currentY  = current.getMeasuredValue();\n+    next      = measurements[1];\n+    nextY     = next.getMeasuredValue();\n+    nextIndex = 2;\n+\n+  }\n+\n+  public int getDimension() {\n+    return 2;\n+  }\n+\n+  public boolean hasNext() {\n+    return nextIndex < measurements.length;\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    if (nextIndex >= measurements.length) {\n+      throw new ExhaustedSampleException(measurements.length);\n+    }\n+\n+    // shift the points\n+    previous  = current;\n+    previousY = currentY;\n+    current   = next;\n+    currentY  = nextY;\n+    next      = measurements[nextIndex++];\n+    nextY     = next.getMeasuredValue();\n+\n+    // return the two dimensions vector [f(x), f'(x)]\n+    double[] table = new double[2];\n+    table[0] = currentY;\n+    table[1] = (nextY - previousY) / (next.x - previous.x);\n+    return new VectorialValuedPair(current.x, table);\n+\n+  }\n+\n+  private AbstractCurveFitter.FitMeasurement[] measurements;\n+  private int nextIndex;\n+\n+  private AbstractCurveFitter.FitMeasurement previous;\n+  private double previousY;\n+\n+  private AbstractCurveFitter.FitMeasurement current;\n+  private double nextY;\n+\n+  private AbstractCurveFitter.FitMeasurement next;\n+  private double currentY;\n+\n+  private static final long serialVersionUID = -3187229691615380125L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+import org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair;\n+\n+import org.spaceroots.mantissa.quadrature.vectorial.EnhancedSimpsonIntegratorSampler;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+\n+/** This class guesses harmonic coefficients from a sample.\n+\n+ * <p>The algorithm used to guess the coefficients is as follows:</p>\n+\n+ * <p>We know f (t) at some sampling points ti and want to find a,\n+ * omega and phi such that f (t) = a cos (omega t + phi).\n+ * </p>\n+ *\n+ * <p>From the analytical expression, we can compute two primitives :\n+ * <pre>\n+ *     If2  (t) = int (f^2)  = a^2 * [t + S (t)] / 2\n+ *     If'2 (t) = int (f'^2) = a^2 * omega^2 * [t - S (t)] / 2\n+ *     where S (t) = sin (2 * (omega * t + phi)) / (2 * omega)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can remove S between these expressions :\n+ * <pre>\n+ *     If'2 (t) = a^2 * omega ^ 2 * t - omega ^ 2 * If2 (t)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>The preceding expression shows that If'2 (t) is a linear\n+ * combination of both t and If2 (t): If'2 (t) = A * t + B * If2 (t)\n+ * </p>\n+ *\n+ * <p>From the primitive, we can deduce the same form for definite\n+ * integrals between t1 and ti for each ti :\n+ * <pre>\n+ *   If2 (ti) - If2 (t1) = A * (ti - t1) + B * (If2 (ti) - If2 (t1))\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can find the coefficients A and B that best fit the sample\n+ * to this linear expression by computing the definite integrals for\n+ * each sample points.\n+ * </p>\n+ *\n+ * <p>For a bilinear expression z (xi, yi) = A * xi + B * yi, the\n+ * coefficients a and b that minimize a least square criterion\n+ * Sum ((zi - z (xi, yi))^2) are given by these expressions:</p>\n+ * <pre>\n+ *\n+ *         Sum (yi^2) Sum (xi zi) - Sum (xi yi) Sum (yi zi)\n+ *     A = ------------------------------------------------\n+ *         Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n+ *\n+ *         Sum (xi^2) Sum (yi zi) - Sum (xi yi) Sum (xi zi)\n+ *     B = ------------------------------------------------\n+ *         Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>In fact, we can assume both a and omega are positive and\n+ * compute them directly, knowing that A = a^2 * omega^2 and that\n+ * B = - omega^2. The complete algorithm is therefore:</p>\n+ * <pre>\n+ *\n+ * for each ti from t1 to t(n-1), compute:\n+ *   f  (ti)\n+ *   f' (ti) = (f (t(i+1)) - f(t(i-1))) / (t(i+1) - t(i-1))\n+ *   xi = ti - t1\n+ *   yi = int (f^2) from t1 to ti\n+ *   zi = int (f'^2) from t1 to ti\n+ *   update the sums Sum (xi^2), Sum (yi^2),\n+ *                   Sum (xi yi), Sum (xi zi)\n+ *                   and Sum (yi zi)\n+ * end for\n+ *\n+ *            |-------------------------------------------------\n+ *         \\  | Sum (yi^2) Sum (xi zi) - Sum (xi yi) Sum (yi zi)\n+ * a     =  \\ | ------------------------------------------------\n+ *           \\| Sum (xi yi) Sum (xi zi) - Sum (xi^2) Sum (yi zi)\n+ *\n+ *\n+ *            |-------------------------------------------------\n+ *         \\  | Sum (xi yi) Sum (xi zi) - Sum (xi^2) Sum (yi zi)\n+ * omega =  \\ | ------------------------------------------------\n+ *           \\| Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n+ *\n+ * </pre>\n+ * </p>\n+\n+ * <p>Once we know omega, we can compute:\n+ * <pre>\n+ *    fc = omega * f (t) * cos (omega * t) - f' (t) * sin (omega * t)\n+ *    fs = omega * f (t) * sin (omega * t) + f' (t) * cos (omega * t)\n+ * </pre>\n+ * </p>\n+\n+ * <p>It appears that <code>fc = a * omega * cos (phi)</code> and\n+ * <code>fs = -a * omega * sin (phi)</code>, so we can use these\n+ * expressions to compute phi. The best estimate over the sample is\n+ * given by averaging these expressions.\n+ * </p>\n+\n+ * <p>Since integrals and means are involved in the preceding\n+ * estimations, these operations run in O(n) time, where n is the\n+ * number of measurements.</p>\n+\n+ * @version $Id: HarmonicCoefficientsGuesser.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class HarmonicCoefficientsGuesser\n+  implements Serializable{\n+\n+  public HarmonicCoefficientsGuesser(AbstractCurveFitter.FitMeasurement[] measurements) {\n+    this.measurements = measurements;\n+    a                 = Double.NaN;\n+    omega             = Double.NaN;\n+  }\n+\n+  /** Estimate a first guess of the coefficients.\n+\n+   * @exception ExhaustedSampleException if the sample is exhausted.\n+\n+   * @exception FunctionException if the integrator throws one.\n+\n+   * @exception EstimationException if the sample is too short or if\n+   * the first guess cannot be computed (when the elements under the\n+   * square roots are negative).\n+   * */\n+  public void guess()\n+    throws ExhaustedSampleException, FunctionException, EstimationException {\n+    guessAOmega();\n+    guessPhi();\n+  }\n+\n+  /** Estimate a first guess of the a and omega coefficients.\n+\n+   * @exception ExhaustedSampleException if the sample is exhausted.\n+\n+   * @exception FunctionException if the integrator throws one.\n+\n+   * @exception EstimationException if the sample is too short or if\n+   * the first guess cannot be computed (when the elements under the\n+   * square roots are negative).\n+\n+   */\n+  private void guessAOmega()\n+    throws ExhaustedSampleException, FunctionException, EstimationException {\n+\n+    // initialize the sums for the linear model between the two integrals\n+    double sx2 = 0.0;\n+    double sy2 = 0.0;\n+    double sxy = 0.0;\n+    double sxz = 0.0;\n+    double syz = 0.0;\n+\n+    // build the integrals sampler\n+    F2FP2Iterator iter = new F2FP2Iterator(measurements);\n+    SampledFunctionIterator sampler =\n+      new EnhancedSimpsonIntegratorSampler(iter);\n+    VectorialValuedPair p0 = sampler.nextSamplePoint();\n+    double   p0X = p0.getX();\n+    double[] p0Y = p0.getY();\n+\n+    // get the points for the linear model\n+    while (sampler.hasNext()) {\n+\n+      VectorialValuedPair point = sampler.nextSamplePoint();\n+      double   pX = point.getX();\n+      double[] pY = point.getY();\n+\n+      double dx  = pX    - p0X;\n+      double dy0 = pY[0] - p0Y[0];\n+      double dy1 = pY[1] - p0Y[1];\n+\n+      sx2 += dx  * dx;\n+      sy2 += dy0 * dy0;\n+      sxy += dx  * dy0;\n+      sxz += dx  * dy1;\n+      syz += dy0 * dy1;\n+\n+    }\n+\n+    // compute the amplitude and pulsation coefficients\n+    double c1 = sy2 * sxz - sxy * syz;\n+    double c2 = sxy * sxz - sx2 * syz;\n+    double c3 = sx2 * sy2 - sxy * sxy;\n+    if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {\n+      throw new EstimationException(\"unable to guess a first estimate\");\n+    }\n+    a     = Math.sqrt(c1 / c2);\n+    omega = Math.sqrt(c2 / c3);\n+\n+  }\n+\n+  /** Estimate a first guess of the phi coefficient.\n+\n+   * @exception ExhaustedSampleException if the sample is exhausted.\n+\n+   * @exception FunctionException if the sampler throws one.\n+\n+   */\n+  private void guessPhi()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    SampledFunctionIterator iter = new FFPIterator(measurements);\n+\n+    // initialize the means\n+    double fcMean = 0.0;\n+    double fsMean = 0.0;\n+\n+    while (iter.hasNext()) {\n+      VectorialValuedPair point = iter.nextSamplePoint();\n+      double   omegaX = omega * point.getX();\n+      double[] pY     = point.getY();\n+      double   cosine = Math.cos(omegaX);\n+      double   sine   = Math.sin(omegaX);\n+      fcMean += omega * pY[0] * cosine - pY[1] *   sine;\n+      fsMean += omega * pY[0] *   sine + pY[1] * cosine;\n+    }\n+\n+    phi = Math.atan2(-fsMean, fcMean);\n+\n+  }\n+\n+  public double getOmega() {\n+    return omega;\n+  }\n+\n+  public double getA() {\n+    return a;\n+  }\n+\n+  public double getPhi() {\n+    return phi;\n+  }\n+\n+  private AbstractCurveFitter.FitMeasurement[] measurements;\n+  private double a;\n+  private double omega;\n+  private double phi;\n+\n+  private static final long serialVersionUID = 2400399048702758814L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.estimation.*;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class implements a curve fitting specialized for sinusoids.\n+\n+ * <p>Harmonic fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the amplitude a, the pulsation omega and\n+ * the phase phi: <code>f (t) = a cos (omega t + phi)</code>. They are\n+ * searched by a least square estimator initialized with a rough guess\n+ * based on integrals.</p>\n+\n+ * <p>This class <emph>is by no means optimized</emph>, neither versus\n+ * space nor versus time performance.</p>\n+\n+ * @version $Id: HarmonicFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class HarmonicFitter\n+  extends AbstractCurveFitter\n+  implements EstimationProblem, Serializable {\n+\n+  /**\n+   * Simple constructor.\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+   */\n+  public HarmonicFitter(int maxIterations, double convergence,\n+                        double steadyStateThreshold, double epsilon) {\n+    super(3, maxIterations, convergence, steadyStateThreshold, epsilon);\n+    coefficients[0]  = new EstimatedParameter(\"a\", 2.0 * Math.PI);\n+    coefficients[1]  = new EstimatedParameter(\"omega\", 0.0);\n+    coefficients[2]  = new EstimatedParameter(\"phi\", 0.0);\n+    firstGuessNeeded = true;\n+  }\n+\n+  /**\n+   * Simple constructor.\n+\n+   * <p>This constructor can be used when a first estimate of the\n+   * coefficients is already known.</p>\n+\n+   * @param coefficients first estimate of the coefficients.\n+   * A reference to this array is hold by the newly created\n+   * object. Its elements will be adjusted during the fitting process\n+   * and they will be set to the adjusted coefficients at the end.\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+\n+   */\n+  public HarmonicFitter(EstimatedParameter[] coefficients,\n+                        int maxIterations, double convergence,\n+                        double steadyStateThreshold, double epsilon) {\n+    super(coefficients,\n+          maxIterations, convergence,\n+          steadyStateThreshold, epsilon);\n+    firstGuessNeeded = false;\n+  }\n+\n+  public double[] fit()\n+    throws EstimationException {\n+    if (firstGuessNeeded) {\n+      if (measurements.size() < 4) {\n+        throw new EstimationException(\"sample must contain at least {0} points\",\n+                                      new String[] {\n+                                        Integer.toString(4)\n+                                      });\n+      }\n+\n+      sortMeasurements();\n+\n+      try {\n+        HarmonicCoefficientsGuesser guesser =\n+          new HarmonicCoefficientsGuesser((FitMeasurement[]) getMeasurements());\n+        guesser.guess();\n+\n+        coefficients[0].setEstimate(guesser.getA());\n+        coefficients[1].setEstimate(guesser.getOmega());\n+        coefficients[2].setEstimate(guesser.getPhi());\n+      } catch(ExhaustedSampleException e) {\n+        throw new EstimationException(e);\n+      } catch(FunctionException e) {\n+        throw new EstimationException(e);\n+      }\n+\n+      firstGuessNeeded = false;\n+\n+    }\n+\n+    return super.fit();\n+\n+  }\n+\n+  /** Get the current amplitude coefficient estimate.\n+   * Get a, where <code>f (t) = a cos (omega t + phi)</code>\n+   * @return current amplitude coefficient estimate\n+   */\n+  public double getAmplitude() {\n+    return coefficients[0].getEstimate();\n+  }\n+\n+  /** Get the current pulsation coefficient estimate.\n+   * Get omega, where <code>f (t) = a cos (omega t + phi)</code>\n+   * @return current pulsation coefficient estimate\n+   */\n+  public double getPulsation() {\n+    return coefficients[1].getEstimate();\n+  }\n+\n+  /** Get the current phase coefficient estimate.\n+   * Get phi, where <code>f (t) = a cos (omega t + phi)</code>\n+   * @return current phase coefficient estimate\n+   */\n+  public double getPhase() {\n+    return coefficients[2].getEstimate();\n+  }\n+\n+  /** Get the value of the function at x according to the current parameters value.\n+   * @param x abscissa at which the theoretical value is requested\n+   * @return theoretical value at x\n+   */\n+  public double valueAt(double x) {\n+    double a     = coefficients[0].getEstimate();\n+    double omega = coefficients[1].getEstimate();\n+    double phi   = coefficients[2].getEstimate();\n+    return a * Math.cos(omega * x + phi);\n+  }\n+\n+  /** Get the derivative of the function at x with respect to parameter p.\n+   * @param x abscissa at which the partial derivative is requested\n+   * @param p parameter with respect to which the derivative is requested\n+   * @return partial derivative\n+   */\n+  public double partial(double x, EstimatedParameter p) {\n+    double a     = coefficients[0].getEstimate();\n+    double omega = coefficients[1].getEstimate();\n+    double phi   = coefficients[2].getEstimate();\n+    if (p == coefficients[0]) {\n+      return Math.cos(omega * x + phi);\n+    } else if (p == coefficients[1]) {\n+      return -a * x * Math.sin(omega * x + phi);\n+    } else {\n+      return -a * Math.sin(omega * x + phi);\n+    }\n+  }\n+\n+  /** Indicator of the need to compute a first guess of the coefficients. */\n+  private boolean firstGuessNeeded;\n+\n+  private static final long serialVersionUID = -8722683066277473450L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialCoefficient.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import org.spaceroots.mantissa.estimation.EstimatedParameter;\n+\n+/** This class represents a polynomial coefficient.\n+\n+ * <p>Each coefficient is uniquely defined by its degree.</p>\n+\n+ * @see PolynomialFitter\n+\n+ * @version $Id: PolynomialCoefficient.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class PolynomialCoefficient\n+  extends EstimatedParameter {\n+\n+  public PolynomialCoefficient(int degree) {\n+    super(\"a\" + degree, 0.0);\n+    this.degree = degree;\n+  }\n+\n+  public final int degree;\n+\n+  private static final long serialVersionUID = 5775845068390259552L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.estimation.*;\n+\n+/** This class implements a curve fitting specialized for polynomials.\n+\n+ * <p>Polynomial fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the polynom coefficients. They are\n+ * searched by a least square estimator.</p>\n+\n+ * <p>This class <emph>is by no means optimized</emph>, neither in\n+ * space nor in time performance.</p>\n+\n+ * @see PolynomialCoefficient\n+\n+ * @version $Id: PolynomialFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class PolynomialFitter\n+  extends AbstractCurveFitter\n+  implements EstimationProblem, Serializable {\n+\n+  /**\n+   * Simple constructor.\n+\n+   * <p>The polynomial fitter built this way are complete polynoms,\n+   * ie. a n-degree polynom has n+1 coefficients. In order to build\n+   * fitter for sparse polynoms (for example <code>a x^20 - b\n+   * x^30</code>, on should first build the coefficients array and\n+   * provide it to {@link\n+   * #PolynomialFitter(PolynomialCoefficient[], int, double, double,\n+   * double)}.</p>\n+   * @param degree maximal degree of the polynom\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+ \n+   */\n+  public PolynomialFitter(int degree,\n+                          int maxIterations, double convergence,\n+                          double steadyStateThreshold, double epsilon) {\n+\n+    super(degree + 1,\n+          maxIterations, steadyStateThreshold,\n+          convergence, epsilon);\n+\n+    for (int i = 0; i < coefficients.length; ++i) {\n+      coefficients[i] = new PolynomialCoefficient(i);\n+    }\n+\n+  }\n+\n+  /**\n+   * Simple constructor.\n+\n+   * <p>This constructor can be used either when a first estimate of\n+   * the coefficients is already known (which is of little interest\n+   * because the fit cost is the same whether a first guess is known or\n+   * not) or when one needs to handle sparse polynoms like <code>a\n+   * x^20 - b x^30</code>.</p>\n+\n+   * @param coefficients first estimate of the coefficients.\n+   * A reference to this array is hold by the newly created\n+   * object. Its elements will be adjusted during the fitting process\n+   * and they will be set to the adjusted coefficients at the end.\n+   * @param maxIterations maximum number of iterations allowed\n+   * @param convergence criterion threshold below which we do not need\n+   * to improve the criterion anymore\n+   * @param steadyStateThreshold steady state detection threshold, the\n+   * problem has reached a steady state (read converged) if\n+   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n+   * <code>Jn</code> and <code>Jn-1</code> are the current and\n+   * preceding criterion value (square sum of the weighted residuals\n+   * of considered measurements).\n+   * @param epsilon threshold under which the matrix of the linearized\n+   * problem is considered singular (see {@link\n+   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n+   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+\n+   */\n+  public PolynomialFitter(PolynomialCoefficient[] coefficients,\n+                          int maxIterations, double convergence,\n+                          double steadyStateThreshold, double epsilon) {\n+    super(coefficients,\n+          maxIterations, steadyStateThreshold,\n+          convergence, epsilon);\n+  }\n+\n+  /** Get the value of the function at x according to the current parameters value.\n+   * @param x abscissa at which the theoretical value is requested\n+   * @return theoretical value at x\n+   */\n+  public double valueAt(double x) {\n+    double y = coefficients[coefficients.length - 1].getEstimate();\n+    for (int i = coefficients.length - 2; i >= 0; --i) {\n+      y = y * x + coefficients[i].getEstimate();\n+    }\n+    return y;\n+  }\n+\n+  /** Get the derivative of the function at x with respect to parameter p.\n+   * @param x abscissa at which the partial derivative is requested\n+   * @param p parameter with respect to which the derivative is requested\n+   * @return partial derivative\n+   */\n+  public double partial(double x, EstimatedParameter p) {\n+    return Math.pow(x, ((PolynomialCoefficient) p).degree);\n+  }\n+\n+  private static final long serialVersionUID = -226724596015163603L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/ExhaustedSampleException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by sample iterators.\n+\n+ * @version $Id: ExhaustedSampleException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ExhaustedSampleException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * @param size size of the sample\n+   */\n+  public ExhaustedSampleException(int size) {\n+    super(\"sample contains only {0} elements\",\n+          new String[] { Integer.toString(size) });\n+  }\n+\n+  private static final long serialVersionUID = -1490493298938282440L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/FunctionException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by scalar functions.\n+\n+ * @version $Id: FunctionException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class FunctionException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public FunctionException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception by translating the specified message\n+   * @param message message to translate\n+   */\n+  public FunctionException(String message) {\n+    super(message);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a cause\n+   * @param cause cause of this exception\n+   */\n+  public FunctionException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  private static final long serialVersionUID = 1455885104381976115L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class is a simple wrapper allowing to iterate over a\n+ * SampledFunction.\n+\n+ * <p>The basic implementation of the iteration interface does not\n+ * perform any transformation on the sample, it only handles a loop\n+ * over the underlying sampled function.</p>\n+\n+ * @see SampledFunction\n+\n+ * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class BasicSampledFunctionIterator\n+  implements SampledFunctionIterator, Serializable {\n+\n+  /** Underlying sampled function. */\n+  private final SampledFunction function;\n+\n+  /** Next sample element. */\n+  private int next;\n+\n+  /** Simple constructor.\n+   * Build an instance from a SampledFunction\n+   * @param function smapled function over which we want to iterate\n+   */\n+  public BasicSampledFunctionIterator(SampledFunction function) {\n+    this.function = function;\n+    next          = 0;\n+  }\n+\n+  public boolean hasNext() {\n+    return next < function.size();\n+  }\n+\n+  public ScalarValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    if (next >= function.size()) {\n+      throw new ExhaustedSampleException(function.size());\n+    }\n+\n+    int current = next++;\n+    return function.samplePointAt(current);\n+\n+  }\n+\n+  private static final long serialVersionUID = -9106690005598356403L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents scalar functions of one real variable.\n+\n+ * <p>This interface should be implemented by all scalar functions\n+ * that can be evaluated at any point. This does not imply that an\n+ * explicit definition is available, a function given by an implicit\n+ * function that should be numerically solved for each point for\n+ * example is considered a computable function.</p>\n+\n+ * <p>The {@link ComputableFunctionSampler} class can be used to\n+ * transform classes implementing this interface into classes\n+ * implementing the {@link SampledFunction} interface.</p>\n+\n+ * <p>Several numerical algorithms (Gauss-Legendre integrators for\n+ * example) need to choose themselves the evaluation points, so they\n+ * can handle only objects that implement this interface.</p>\n+\n+ * @see org.spaceroots.mantissa.quadrature.scalar.ComputableFunctionIntegrator\n+ * @see SampledFunction\n+\n+ * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface ComputableFunction {\n+\n+  /** Get the value of the function at the specified abscissa.\n+   * @param x current abscissa\n+   * @return function value\n+   * @exception FunctionException if something goes wrong\n+   */\n+  public double valueAt(double x)\n+    throws FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class is a wrapper allowing to sample a\n+ * {@link ComputableFunction}.\n+\n+ * <p>The sample produced is a regular sample. It can be specified by\n+ * several means :\n+ * <ul>\n+ *   <li> from an initial point a step and a number of points</li>\n+ *   <li> from a range and a number of points</li>\n+ *   <li> from a range and a step between points.</li>\n+ * </ul>\n+ * In the latter case, the step can optionaly be adjusted in order to\n+ * have the last point exactly at the upper bound of the range.</p>\n+\n+ * <p>The sample points are computed on demand, they are not\n+ * stored. This allow to use this method for very large sample with\n+ * little memory overhead. The drawback is that if the same sample\n+ * points are going to be requested several times, they will be\n+ * recomputed each time. In this case, the user should consider\n+ * storing the points by some other means.</p>\n+\n+ * @see ComputableFunction\n+\n+ * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class ComputableFunctionSampler\n+  implements SampledFunction, Serializable {\n+\n+  /** Underlying computable function. */\n+  private ComputableFunction function;\n+\n+  /** Beginning abscissa. */\n+  private double begin;\n+\n+  /** Step between points. */\n+  private double step;\n+\n+  /** Total number of points. */\n+  private int n;\n+\n+  /**\n+   * Constructor.\n+\n+   * Build a sample from an {@link ComputableFunction}. Beware of the\n+   * classical off-by-one problem !  If you want to have a sample like\n+   * this : 0.0, 0.1, 0.2 ..., 1.0, then you should specify step = 0.1\n+   * and n = 11 (not n = 10).\n+\n+   * @param begin beginning of the range (will be the abscissa of the\n+   * first point)\n+   * @param step step between points\n+   * @param n number of points\n+\n+   */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double begin, double step, int n) {\n+    this.function = function;\n+    this.begin    = begin;\n+    this.step     = step;\n+    this.n        = n;\n+  }\n+\n+  /**\n+   * Constructor.\n+   * Build a sample from an {@link ComputableFunction}.\n+\n+   * @param range abscissa range (from <code>range [0]</code> to\n+   * <code>range [1]</code>)\n+   * @param n number of points\n+   */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double[] range, int n) {\n+    this.function = function;\n+    begin         = range[0];\n+    step          = (range[1] - range[0]) / (n - 1);\n+    this.n        = n;\n+  }\n+\n+  /**\n+   * Constructor.\n+   * Build a sample from an {@link ComputableFunction}.\n+\n+   * @param range abscissa range (from <code>range [0]</code> to\n+   * <code>range [1]</code>)\n+   * @param step step between points\n+   * @param adjustStep if true, the step is reduced in order to have\n+   * the last point of the sample exactly at <code>range [1]</code>,\n+   * if false the last point will be between <code>range [1] -\n+   * step</code> and <code>range [1]</code> */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double[] range, double step,\n+                                   boolean adjustStep) {\n+    this.function = function;\n+    begin         = range [0];\n+    if (adjustStep) {\n+      n         = (int) Math.ceil((range[1] - range[0]) / step);\n+      this.step = (range[1] - range[0]) / (n - 1);\n+    } else {\n+      n         = (int) Math.floor((range[1] - range[0]) / step);\n+      this.step = step;\n+    }\n+  }\n+\n+  public int size() {\n+    return n;\n+  }\n+\n+  public ScalarValuedPair samplePointAt(int index)\n+    throws ArrayIndexOutOfBoundsException, FunctionException {\n+\n+    if (index < 0 || index >= n) {\n+      throw new ArrayIndexOutOfBoundsException();\n+    }\n+\n+    double x = begin + index * step;\n+    return new ScalarValuedPair(x, function.valueAt(x));\n+\n+  }\n+\n+  private static final long serialVersionUID = -5127043442851795719L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represent sampled scalar functions.\n+\n+ * <p>A function sample is an ordered set of points of the form (x, y)\n+ * where x is the abscissa of the point and y is the function value at\n+ * x. It is typically a function that has been computed by external\n+ * means or the result of measurements.</p>\n+\n+ * <p>The {@link ComputableFunctionSampler} class can be used to\n+ * transform classes implementing the {@link ComputableFunction}\n+ * interface into classes implementing this interface.</p>\n+\n+ * <p>Sampled functions cannot be directly handled by integrators\n+ * implementing the {@link\n+ * org.spaceroots.mantissa.quadrature.scalar.SampledFunctionIntegrator\n+ * SampledFunctionIntegrator}. These integrators need a {@link\n+ * SampledFunctionIterator} object to iterate over the\n+ * sample.</p>\n+\n+ * @see SampledFunctionIterator\n+ * @see ComputableFunctionSampler\n+ * @see ComputableFunction\n+\n+ * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface SampledFunction {\n+\n+  /** Get the number of points in the sample.\n+   * @return number of points in the sample\n+   */\n+  public int size();\n+\n+  /** Get the abscissa and value of the sample at the specified index.\n+   * @param index index in the sample, should be between 0 and\n+   * {@link #size} - 1\n+   * @return abscissa and value of the sample at the specified index\n+   * @exception ArrayIndexOutOfBoundsException if the index is wrong\n+   * @exception FunctionException if an eventual underlying function\n+   * throws one\n+   */\n+  public ScalarValuedPair samplePointAt(int index)\n+    throws ArrayIndexOutOfBoundsException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunctionIterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This interface provides iteration services over scalar functions\n+ * samples.\n+\n+ * @see SampledFunction\n+\n+ * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface SampledFunctionIterator {\n+\n+  /** Check if the iterator can provide another point.\n+   * @return true if the iterator can provide another point.\n+   */\n+  public boolean hasNext();\n+\n+  /** Get the next point of a sampled function.\n+   * @return the next point of the sampled function\n+   * @exception ExhaustedSampleException if the sample has been exhausted\n+   * @exception FunctionException if the underlying function throws one\n+   */\n+  public ScalarValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPair.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import java.io.Serializable;\n+\n+/** This class represents an (x, f(x)) pair for scalar functions.\n+\n+ * <p>A scalar function is a function of one scalar parameter x whose\n+ * value is a scalar. This class is used has a simple placeholder to\n+ * contain both an abscissa and the value of the function at this\n+ * abscissa.</p>\n+\n+ * @see SampledFunction\n+ * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n+\n+ * @version $Id: ScalarValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class ScalarValuedPair\n+  implements Serializable {\n+\n+  /** Simple constructor.\n+   * Build an instance from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate (value of the function)\n+   */\n+  public ScalarValuedPair(double x, double y) {\n+    this.x = x;\n+    this.y = y;\n+  }\n+\n+  /** Copy-constructor.\n+   * @param p point to copy\n+   */\n+  public ScalarValuedPair(ScalarValuedPair p) {\n+    x = p.x;\n+    y = p.y;\n+  }\n+\n+  /**\n+   * Getter for the abscissa.\n+   * @return value of the abscissa\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /**\n+   * Getter for the ordinate.\n+   * @return value of the ordinate\n+   */\n+  public double getY() {\n+    return y;\n+  }\n+\n+  /**\n+   * Setter for the abscissa.\n+   * @param x new value for the abscissa\n+   */\n+  public void setX(double x) {\n+    this.x = x;\n+  }\n+\n+  /**\n+   * Setter for the ordinate.\n+   * @param y new value for the ordinate\n+   */\n+  public void setY(double y) {\n+    this.y = y;\n+  }\n+\n+  /** Abscissa of the point. */\n+  private double x;\n+\n+  /** Scalar ordinate of the point, y = f (x). */\n+  private double y;\n+\n+  private static final long serialVersionUID = 1884346552569300794L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class is a wrapper allowing to iterate over a\n+ * SampledFunction.\n+\n+ * <p>The basic implementation of the iteration interface does not\n+ * perform any transformation on the sample, it only handles a loop\n+ * over the underlying sampled function.</p>\n+\n+ * @see SampledFunction\n+\n+ * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class BasicSampledFunctionIterator\n+  implements SampledFunctionIterator, Serializable {\n+\n+  /** Simple constructor.\n+   * Build an instance from a SampledFunction\n+   * @param function smapled function over which we want to iterate\n+   */\n+  public BasicSampledFunctionIterator(SampledFunction function) {\n+    this.function = function;\n+    next          = 0;\n+  }\n+\n+  public int getDimension() {\n+    return function.getDimension();\n+  }\n+\n+  public boolean hasNext() {\n+    return next < function.size();\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    if (next >= function.size()) {\n+      throw new ExhaustedSampleException(function.size());\n+    }\n+\n+    int current = next++;\n+    return function.samplePointAt(current);\n+\n+  }\n+\n+  /** Underlying sampled function. */\n+  private final SampledFunction function;\n+\n+  /** Next sample element. */\n+  private int next;\n+\n+  private static final long serialVersionUID = -4386278658288500627L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents vectorial functions of one real variable.\n+\n+ * <p>This interface should be implemented by all vectorial functions\n+ * that can be evaluated at any point. This does not imply that an\n+ * explicit definition is available, a function given by an implicit\n+ * function that should be numerically solved for each point for\n+ * example is considered a computable function.</p>\n+\n+ * <p>The {@link ComputableFunctionSampler} class can be used to\n+ * transform classes implementing this interface into classes\n+ * implementing the {@link SampledFunction} interface.</p>\n+\n+ * <p>Several numerical algorithms (Gauss-Legendre integrators for\n+ * example) need to choose themselves the evaluation points, so they\n+ * can handle only objects that implement this interface.</p>\n+\n+ * @see org.spaceroots.mantissa.quadrature.vectorial.ComputableFunctionIntegrator\n+ * @see SampledFunction\n+\n+ * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface ComputableFunction {\n+  /** Get the dimension of the vectorial values of the function.\n+   * @return dimension\n+   */\n+  public int getDimension();\n+\n+  /** Get the value of the function at the specified abscissa.\n+   * @param x current abscissa\n+   * @return function value\n+   * @exception FunctionException if something goes wrong\n+   */\n+  public double[] valueAt(double x)\n+    throws FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import java.io.Serializable;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class is a wrapper allowing to sample a\n+ * {@link ComputableFunction}.\n+\n+ * <p>The sample produced is a regular sample. It can be specified by\n+ * several means :\n+ * <ul>\n+ *   <li> from an initial point a step and a number of points</li>\n+ *   <li> from a range and a number of points</li>\n+ *   <li> from a range and a step between points.</li>\n+ * </ul>\n+ * In the latter case, the step can optionaly be adjusted in order to\n+ * have the last point exactly at the upper bound of the range.</p>\n+\n+ * <p>The sample points are computed on demand, they are not\n+ * stored. This allow to use this method for very large sample with\n+ * little memory overhead. The drawback is that if the same sample\n+ * points are going to be requested several times, they will be\n+ * recomputed each time. In this case, the user should consider\n+ * storing the points by some other means.</p>\n+\n+ * @see ComputableFunction\n+\n+ * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class ComputableFunctionSampler\n+  implements SampledFunction, Serializable {\n+\n+  /**\n+   * Constructor.\n+\n+   * Build a sample from an {@link ComputableFunction}. Beware of the\n+   * classical off-by-one problem !  If you want to have a sample like\n+   * this : 0.0, 0.1, 0.2 ..., 1.0, then you should specify step = 0.1\n+   * and n = 11 (not n = 10).\n+\n+   * @param begin beginning of the range (will be the abscissa of the\n+   * first point)\n+   * @param step step between points\n+   * @param n number of points\n+\n+   */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double begin, double step, int n) {\n+    this.function = function;\n+    this.begin    = begin;\n+    this.step     = step;\n+    this.n        = n;\n+  }\n+\n+  /**\n+   * Constructor.\n+   * Build a sample from an {@link ComputableFunction}.\n+\n+   * @param range abscissa range (from <code>range [0]</code> to\n+   * <code>range [1]</code>)\n+   * @param n number of points\n+   */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double[] range, int n) {\n+    this.function = function;\n+    begin         = range[0];\n+    step          = (range[1] - range[0]) / (n - 1);\n+    this.n        = n;\n+  }\n+\n+  /**\n+   * Constructor.\n+   * Build a sample from an {@link ComputableFunction}.\n+\n+   * @param range abscissa range (from <code>range [0]</code> to\n+   * <code>range [1]</code>)\n+   * @param step step between points\n+   * @param adjustStep if true, the step is reduced in order to have\n+   * the last point of the sample exactly at <code>range [1]</code>,\n+   * if false the last point will be between <code>range [1] -\n+   * step</code> and <code>range [1]</code> */\n+  public ComputableFunctionSampler(ComputableFunction function,\n+                                   double[] range, double step,\n+                                   boolean adjustStep) {\n+    this.function = function;\n+    begin         = range[0];\n+    if (adjustStep) {\n+      n    = (int) Math.ceil((range[1] - range[0]) / step);\n+      this.step = (range[1] - range[0]) / (n - 1);\n+    } else {\n+      n    = (int) Math.floor((range[1] - range[0]) / step);\n+      this.step = step;\n+    }\n+  }\n+\n+  public int size() {\n+    return n;\n+  }\n+\n+  public int getDimension() {\n+    return function.getDimension();\n+  }\n+\n+  public VectorialValuedPair samplePointAt(int index)\n+    throws ArrayIndexOutOfBoundsException, FunctionException {\n+\n+    if (index < 0 || index >= n) {\n+      throw new ArrayIndexOutOfBoundsException();\n+    }\n+\n+    double x = begin + index * step;\n+    return new VectorialValuedPair (x, function.valueAt(x));\n+\n+  }\n+\n+  /** Underlying computable function. */\n+  private ComputableFunction function;\n+\n+  /** Beginning abscissa. */\n+  private double begin;\n+\n+  /** Step between points. */\n+  private double step;\n+\n+  /** Total number of points. */\n+  private int n;\n+\n+  private static final long serialVersionUID = 1368582688313212821L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represent sampled vectorial functions.\n+\n+ * <p>A function sample is an ordered set of points of the form (x, y)\n+ * where x is the abscissa of the point and y is the function value at\n+ * x. It is typically a function that has been computed by external\n+ * means or the result of measurements.</p>\n+\n+ * <p>The {@link ComputableFunctionSampler} class can be used to\n+ * transform classes implementing the {@link ComputableFunction}\n+ * interface into classes implementing this interface.</p>\n+\n+ * <p>Sampled functions cannot be directly handled by integrators\n+ * implementing the {@link\n+ * org.spaceroots.mantissa.quadrature.vectorial.SampledFunctionIntegrator\n+ * SampledFunctionIntegrator}. These integrators need a {@link\n+ * SampledFunctionIterator} object to iterate over the\n+ * sample.</p>\n+\n+ * @see SampledFunctionIterator\n+ * @see ComputableFunctionSampler\n+ * @see ComputableFunction\n+\n+ * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface SampledFunction {\n+\n+  /** Get the number of points in the sample.\n+   * @return number of points in the sample\n+   */\n+  public int size();\n+\n+  /** Get the dimension of the vectorial values of the function.\n+   * @return dimension\n+   */\n+  public int getDimension();\n+\n+  /** Get the abscissa and value of the sample at the specified index.\n+   * @param index index in the sample, should be between 0 and\n+   * {@link #size} - 1\n+   * @return abscissa and value of the sample at the specified index\n+   * @exception ArrayIndexOutOfBoundsException if the index is wrong\n+   * @exception FunctionException if an eventual underlying function\n+   * throws one\n+   */\n+  public VectorialValuedPair samplePointAt(int index)\n+    throws ArrayIndexOutOfBoundsException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunctionIterator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This interface provides iteration services over vectorial functions\n+ * samples.\n+\n+ * @see SampledFunction\n+\n+ * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public interface SampledFunctionIterator {\n+\n+  /** Get the dimension of the vectorial values of the function.\n+   * @return dimension\n+   */\n+  public int getDimension();\n+\n+  /** Check if the iterator can provide another point.\n+   * @return true if the iterator can provide another point.\n+   */\n+  public boolean hasNext();\n+\n+  /** Get the next point of a sampled function.\n+   * @return the next point of the sampled function\n+   * @exception ExhaustedSampleException if the sample has been exhausted\n+   * @exception FunctionException if the underlying function throws one\n+   */\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import java.io.Serializable;\n+\n+/** This class represents an (x, f(x)) pair for vectorial functions.\n+\n+ * <p>A vectorial function is a function of one vectorial parameter x whose\n+ * value is a vector. This class is used has a simple placeholder to\n+ * contain both an abscissa and the value of the function at this\n+ * abscissa.</p>\n+\n+ * @see SampledFunction\n+ * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n+\n+ * @version $Id: VectorialValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public class VectorialValuedPair\n+  implements Serializable {\n+\n+  /**\n+   * Simple constructor.\n+   * Build an instance from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate (value of the function)\n+   */\n+  public VectorialValuedPair(double x, double[] y) {\n+    this.x = x;\n+    this.y = y;\n+  }\n+\n+  /**\n+   * Copy-constructor.\n+   * @param p point to copy\n+   */\n+  public VectorialValuedPair(VectorialValuedPair p) {\n+    x = p.x;\n+    y = p.y;\n+  }\n+\n+  /**\n+   * Getter for the abscissa.\n+   * @return value of the abscissa\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /**\n+   * Getter for the ordinate.\n+   * @return value of the ordinate\n+   */\n+  public double[] getY() {\n+    return y;\n+  }\n+\n+  /**\n+   * Setter for the abscissa.\n+   * @param x new value for the abscissa\n+   */\n+  public void setX(double x) {\n+    this.x = x;\n+  }\n+\n+  /**\n+   * Setter for the ordinate.\n+   * @param y new value for the ordinate\n+   */\n+  public void setY(double[] y) {\n+    this.y = y;\n+  }\n+\n+  /** Abscissa of the point. */\n+  private double x;\n+\n+  /** Vectorial ordinate of the point, y = f (x). */\n+  private double[] y;\n+\n+  private static final long serialVersionUID = -1336411215846160578L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/CardanEulerSingularityException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown while extractiong Cardan\n+ * or Euler angles from a rotation.\n+\n+ * @version $Id: CardanEulerSingularityException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class CardanEulerSingularityException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * build an exception with a default message.\n+   * @param isCardan if true, the rotation is related to Cardan angles,\n+   * if false it is related to EulerAngles\n+   */\n+  public CardanEulerSingularityException(boolean isCardan) {\n+    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n+  }\n+\n+  private static final long serialVersionUID = -1360952845582206770L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/ImmutableVector3D.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+/**\n+ * This class implements immutable vectors in a three-dimensional space.\n+\n+ * @version $Id: ImmutableVector3D.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ImmutableVector3D\n+  extends Vector3D {\n+\n+  /** Simple constructor.\n+   * Build a vector from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate\n+   * @param z height\n+   */\n+  public ImmutableVector3D(double x, double y, double z) {\n+    super(x, y, z);\n+    computeNorm();\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its azimuthal coordinates\n+   * @param alpha azimuth around Z\n+   *              (0 is +X, PI/2 is +Y, PI is -X and 3PI/2 is -Y)\n+   * @param delta elevation above (XY) plane, from -PI to +PI\n+   */\n+  public ImmutableVector3D(double alpha, double delta) {\n+    super(alpha, delta);\n+    computeNorm();\n+  }\n+\n+  /** Copy constructor.\n+   * Build a copy of a vector\n+   * @param v vector to copy\n+   */\n+  public ImmutableVector3D(Vector3D v) {\n+    super(v);\n+    computeNorm();\n+  }\n+\n+  /** Multiplicative constructor\n+   * Build a vector from another one and a scale factor. \n+   * The vector built will be a * u\n+   * @param a scale factor\n+   * @param u base (unscaled) vector\n+   */\n+  public ImmutableVector3D(double a, Vector3D u) {\n+    super(a, u);\n+    computeNorm();\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from two other ones and corresponding scale factors.\n+   * The vector built will be a * u +  b * v\n+   * @param a first scale factor\n+   * @param u first base (unscaled) vector\n+   * @param b second scale factor\n+   * @param v second base (unscaled) vector\n+   */\n+  public ImmutableVector3D(double a, Vector3D u, double b, Vector3D v) {\n+    super(a, u, b, v);\n+    computeNorm();\n+  }\n+\n+  /** Set the abscissa of the vector.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param x new abscissa for the vector\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void setX(double x) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Set the ordinate of the vector.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param y new ordinate for the vector\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void setY(double y) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Set the height of the vector.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param z new height for the vector\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void setZ(double z) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Set all coordinates of the vector.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param x new abscissa for the vector\n+   * @param y new ordinate for the vector\n+   * @param z new height for the vector\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void setCoordinates(double x, double y, double z) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Compute the norm once and for all. */\n+  private void computeNorm() {\n+    norm = Math.sqrt(x * x + y * y + z * z);\n+  }\n+\n+  /** Get the norm for the vector.\n+   * @return euclidian norm for the vector\n+   */\n+  public double getNorm() {\n+    return norm;\n+  }\n+\n+  /** Add a vector to the instance.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param v vector to add\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void addToSelf(Vector3D v) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param v vector to subtract\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void subtractFromSelf(Vector3D v) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Normalize the instance.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void normalizeSelf() {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Revert the instance.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void negateSelf() {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Multiply the instance by a scalar\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param a scalar by which the instance should be multiplied\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void multiplySelf(double a) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Reinitialize internal state from the specified array slice data.\n+   * This method should not be called for immutable vectors, it always\n+   * throws an <code>UnsupportedOperationException</code> exception\n+   * @param start start index in the array\n+   * @param array array holding the data to extract\n+   * @exception UnsupportedOperationException thrown in every case\n+   */\n+  public void mapStateFromArray(int start, double[] array) {\n+    throw new UnsupportedOperationException(\"vector is immutable\");\n+  }\n+\n+  /** Norm of the vector. */\n+  private double norm;\n+\n+  private static final long serialVersionUID = 5377895850033895270L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/NotARotationMatrixException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown while building rotations\n+ * from matrices.\n+\n+ * @version $Id: NotARotationMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class NotARotationMatrixException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public NotARotationMatrixException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  private static final long serialVersionUID = 5647178478658937642L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Rotation.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import org.spaceroots.mantissa.utilities.ArraySliceMappable;\n+import java.io.Serializable;\n+\n+/**\n+ * This class implements rotations in a three-dimensional space.\n+\n+ * <p>Rotations can be represented by several different mathematical\n+ * entities (matrices, axe and angle, Cardan or Euler angles,\n+ * quaternions). This class is an higher level abstraction, more\n+ * user-oriented and hiding this implementation detail. Well, for the\n+ * curious, we use quaternions for the internal representation. The\n+ * user can build a rotation from any of these representations, and\n+ * any of these representations can be retrieved from a\n+ * <code>Rotation</code> instance (see the various constructors and\n+ * getters). In addition, a rotation can also be built implicitely\n+ * from a set of vectors before and after it has been applied. This\n+ * means that this class can be used to compute transformations from\n+ * one representation to another one. For example, extracting a set of\n+ * Cardan angles from a rotation matrix can be done using one single\n+ * line of code:</p>\n+ * <pre>\n+ * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n+ * </pre>\n+ * <p>Focus is more oriented on what a rotation <em>do</em>. Once it\n+ * has been built, and regardless of its representation, a rotation is\n+ * an <em>operator</em> which basically transforms three dimensional\n+ * {@link Vector3D vectors} into other three dimensional {@link\n+ * Vector3D vectors}. Depending on the application, the meaning of\n+ * these vectors can vary. For example in an attitude simulation tool,\n+ * you will often consider the vector is fixed and you transform its\n+ * coordinates in one frame into its coordinates in another frame. In\n+ * this case, the rotation implicitely defines the relation between\n+ * the two frames. Another example could be a telescope control application,\n+ * where the rotation would transform the sighting direction at rest\n+ * into the desired observing direction. In this case the frame is the\n+ * same (probably a topocentric one) and the raw and transformed\n+ * vectors are different. In many case, both approaches will be\n+ * combined, in our telescope example, we will probably also need to\n+ * transform the observing direction in the topocentric frame into the\n+ * observing direction in inertial frame taking into account the\n+ * observatory location and the earth rotation.</p>\n+\n+ * <p>These examples show that a rotation is what the user wants it to\n+ * be, so this class does not push the user towards one specific\n+ * definition and hence does not provide methods like\n+ * <code>projectVectorIntoDestinationFrame</code> or\n+ * <code>computeTransformedDirection</code>. It provides simpler and\n+ * more generic methods: {@link #applyTo(Vector3D) applyTo(Vector3D)}\n+ * and {@link #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n+\n+ * <p>Since a rotation is basically a vectorial operator, several\n+ * rotations can be composed together and the composite operation\n+ * <code>r = r1 o r2</code> (which means that for each vector\n+ * <code>u</code>, <code>r(u) = r1(r2(u))</code>) is also a\n+ * rotation. Hence we can consider that in addition to vectors, a\n+ * rotation can be applied to other rotations (or to itself). With our\n+ * previous notations, we would say we can apply <code>r1</code> to\n+ * <code>r2</code> and the result we get is <code>r = r1 o\n+ * r2</code>. For this purpose, the class provides the methods: {@link\n+ * #applyTo(Rotation) applyTo(Rotation)} and {@link\n+ * #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+\n+ * @version $Id: Rotation.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ * @see Vector3D\n+ * @see RotationOrder\n+\n+ */\n+\n+public class Rotation\n+  implements ArraySliceMappable, Serializable {\n+\n+  /** Build the identity rotation.\n+   */\n+  public Rotation() {\n+    q0 = 1;\n+    q1 = 0;\n+    q2 = 0;\n+    q3 = 0;\n+  }\n+\n+  /** Build a rotation from the quaternion coordinates.\n+   * @param q0 scalar part of the quaternion\n+   * @param q1 first coordinate of the vectorial part of the quaternion\n+   * @param q2 second coordinate of the vectorial part of the quaternion\n+   * @param q3 third coordinate of the vectorial part of the quaternion\n+   * @deprecated since Mantissa 6.3, this method as been deprecated as it\n+   * does not properly handles non-normalized quaternions, it should be\n+   * replaced by {@link #Rotation(double, double, double, double, boolean)}\n+   */\n+  public Rotation(double q0, double q1, double q2, double q3) {\n+    this.q0 = q0;\n+    this.q1 = q1;\n+    this.q2 = q2;\n+    this.q3 = q3;\n+  }\n+\n+  /** Build a rotation from the quaternion coordinates.\n+   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+   * the constructor can normalize it in a preprocessing step.</p>\n+   * <p>This method replaces the {@link #Rotation(double, double,\n+   * double, double) constructor using only 4 doubles} which was deprecated\n+   * as of version 6.3 of Mantissa.</p>\n+   * @param q0 scalar part of the quaternion\n+   * @param q1 first coordinate of the vectorial part of the quaternion\n+   * @param q2 second coordinate of the vectorial part of the quaternion\n+   * @param q3 third coordinate of the vectorial part of the quaternion\n+   * @param needsNormalization if true, the coordinates are considered\n+   * not to be normalized, a normalization preprocessing step is performed\n+   * before using them\n+   */\n+  public Rotation(double q0, double q1, double q2, double q3,\n+                  boolean needsNormalization) {\n+\n+    if (needsNormalization) {\n+      // normalization preprocessing\n+      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n+      q0 *= inv;\n+      q1 *= inv;\n+      q2 *= inv;\n+      q3 *= inv;\n+    }\n+\n+    this.q0 = q0;\n+    this.q1 = q1;\n+    this.q2 = q2;\n+    this.q3 = q3;\n+\n+  }\n+\n+  /** Build a rotation from an axis and an angle.\n+   * <p>We use the convention that angles are oriented according to\n+   * the effect of the rotation on vectors around the axis. That means\n+   * that if (i, j, k) is a direct frame and if we first provide +k as\n+   * the axis and PI/2 as the angle to this constructor, and then\n+   * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n+   * +j.</p>\n+   * @param axis axis around which to rotate\n+   * @param angle rotation angle.\n+   * @exception ArithmeticException if the axis norm is null\n+   */\n+  public Rotation(Vector3D axis, double angle) {\n+\n+    double norm = axis.getNorm();\n+    if (norm == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double halfAngle = -0.5 * angle;\n+    double coeff = Math.sin(halfAngle) / norm;\n+\n+    q0 = Math.cos (halfAngle);\n+    q1 = coeff * axis.getX();\n+    q2 = coeff * axis.getY();\n+    q3 = coeff * axis.getZ();\n+\n+  }\n+\n+  /** Build a rotation from a 3X3 matrix.\n+\n+   * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+   * (which are matrices for which m.mT = I) with real\n+   * coefficients. The module of the determinant of unit matrices is\n+   * 1, among the orthogonal 3X3 matrices, only the ones having a\n+   * positive determinant (+1) are rotation matrices.</p>\n+\n+   * <p>When a rotation is defined by a matrix with truncated values\n+   * (typically when it is extracted from a technical sheet where only\n+   * four to five significant digits are available), the matrix is not\n+   * orthogonal anymore. This constructor handles this case\n+   * transparently by using a copy of the given matrix and applying a\n+   * correction to the copy in order to perfect its orthogonality. If\n+   * the Frobenius norm of the correction needed is above the given\n+   * threshold, then the matrix is considered to be too far from a\n+   * true rotation matrix and an exception is thrown.<p>\n+\n+   * @param m rotation matrix\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+\n+   * @exception NotARotationMatrixException if the matrix is not a 3X3\n+   * matrix, or if it cannot be transformed into an orthogonal matrix\n+   * with the given threshold, or if the determinant of the resulting\n+   * orthogonal matrix is negative\n+\n+   */\n+  public Rotation(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+\n+    // dimension check\n+    if ((m.length != 3) || (m[0].length != 3)\n+        || (m[1].length != 3) || (m[2].length != 3)) {\n+      throw new NotARotationMatrixException(\"a {0}x{1} matrix\"\n+                                            + \" cannot be a rotation matrix\",\n+                                            new String[] {\n+                                              Integer.toString(m.length),\n+                                              Integer.toString(m[0].length)\n+                                            });\n+    }\n+\n+    // compute a \"close\" orthogonal matrix\n+    double[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+    // check the sign of the determinant\n+    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2])\n+               - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2])\n+               + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n+    if (det < 0.0) {\n+      throw new NotARotationMatrixException(\"the closest orthogonal matrix\"\n+                                            + \" has a negative determinant {0}\",\n+                                            new String[] {\n+                                              Double.toString(det)\n+                                            });\n+    }\n+\n+    // There are different ways to compute the quaternions elements\n+    // from the matrix. They all involve computing one element from\n+    // the diagonal of the matrix, and computing the three other ones\n+    // unsing a formula involving a division by the first element,\n+    // which unfortunately can be null. Since the norm of the\n+    // quaternion is 1, we know at least one element has an absolute\n+    // value greater or equal to 0.5, so it is always possible to\n+    // select the right formula and avoid division by zero and even\n+    // numerical inaccuracy. Checking the elements in turn and using\n+    // the first one greater than 0.45 is safe (this leads to a simple\n+    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+    double s = ort[0][0] + ort[1][1] + ort[2][2];\n+    if (s > -0.19) {\n+      // compute q0 and deduce q1, q2 and q3\n+      q0 = 0.5 * Math.sqrt(s + 1.0);\n+      double inv = 0.25 / q0;\n+      q1 = inv * (ort[1][2] - ort[2][1]);\n+      q2 = inv * (ort[2][0] - ort[0][2]);\n+      q3 = inv * (ort[0][1] - ort[1][0]);\n+    } else {\n+      s = ort[0][0] - ort[1][1] - ort[2][2];\n+      if (s > -0.19) {\n+        // compute q1 and deduce q0, q2 and q3\n+        q1 = 0.5 * Math.sqrt(s + 1.0);\n+        double inv = 0.25 / q1;\n+        q0 = inv * (ort[1][2] - ort[2][1]);\n+        q2 = inv * (ort[0][1] + ort[1][0]);\n+        q3 = inv * (ort[0][2] + ort[2][0]);\n+      } else {\n+        s = ort[1][1] - ort[0][0] - ort[2][2];\n+        if (s > -0.19) {\n+          // compute q2 and deduce q0, q1 and q3\n+          q2 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q2;\n+          q0 = inv * (ort[2][0] - ort[0][2]);\n+          q1 = inv * (ort[0][1] + ort[1][0]);\n+          q3 = inv * (ort[2][1] + ort[1][2]);\n+        } else {\n+          // compute q3 and deduce q0, q1 and q2\n+          s = ort[2][2] - ort[0][0] - ort[1][1];\n+          q3 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q3;\n+          q0 = inv * (ort[0][1] - ort[1][0]);\n+          q1 = inv * (ort[0][2] + ort[2][0]);\n+          q2 = inv * (ort[2][1] + ort[1][2]);\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Build the rotation that transforms a pair of vector into another pair.\n+\n+   * <p>Except for possible scale factors, if the instance were\n+   * applied to the pair (u1, u2) it will produce the pair (v1,\n+   * v2).</p>\n+\n+   * <p>If the angular separation between u1 and u2 is not the same as\n+   * the angular separation between v1 and v2, then a corrected v2'\n+   * will be used rather than v2, the corrected vector will be in the\n+   * (v1, v2) plane.</p>\n+\n+   * @param u1 first vector of the origin pair\n+   * @param u2 second vector of the origin pair\n+   * @param v1 desired image of u1 by the rotation\n+   * @param v2 desired image of u2 by the rotation\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n+\n+  // norms computation\n+  double u1u1 = Vector3D.dotProduct(u1, u1);\n+  double u2u2 = Vector3D.dotProduct(u2, u2);\n+  double v1v1 = Vector3D.dotProduct(v1, v1);\n+  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)\n+      || (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))\n+    throw new ArithmeticException(\"null norm\");\n+\n+  double u1x = u1.getX();\n+  double u1y = u1.getY();\n+  double u1z = u1.getZ();\n+\n+  double u2x = u2.getX();\n+  double u2y = u2.getY();\n+  double u2z = u2.getZ();\n+\n+  // renormalize v1 in order to have (v1'|v1') = (u1|u1)\n+  double coeff = Math.sqrt (u1u1 / v1v1);\n+  double v1x   = coeff * v1.getX();\n+  double v1y   = coeff * v1.getY();\n+  double v1z   = coeff * v1.getZ();\n+  v1 = new Vector3D(v1x, v1y, v1z);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n+  double u1u2   = Vector3D.dotProduct(u1, u2);\n+  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  double coeffU = u1u2 / u1u1;\n+  double coeffV = v1v2 / u1u1;\n+  double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n+  double alpha  = coeffU - beta * coeffV;\n+  double v2x    = alpha * v1x + beta * v2.getX();\n+  double v2y    = alpha * v1y + beta * v2.getY();\n+  double v2z    = alpha * v1z + beta * v2.getZ();\n+  v2 = new Vector3D(v2x, v2y, v2z);\n+\n+  // preliminary computation (we use explicit formulation instead\n+  // of relying on the Vector3D class in order to avoid building lots\n+  // of temporary objects)\n+  Vector3D uRef = u1;\n+  Vector3D vRef = v1;\n+  double dx1 = v1x - u1.getX();\n+  double dy1 = v1y - u1.getY();\n+  double dz1 = v1z - u1.getZ();\n+  double dx2 = v2x - u2.getX();\n+  double dy2 = v2y - u2.getY();\n+  double dz2 = v2z - u2.getZ();\n+  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n+                            dz1 * dx2 - dx1 * dz2,\n+                            dx1 * dy2 - dy1 * dx2);\n+  double c = k.getX() * (u1y * u2z - u1z * u2y)\n+           + k.getY() * (u1z * u2x - u1x * u2z)\n+           + k.getZ() * (u1x * u2y - u1y * u2x);\n+\n+  if (c < (1.0e-10 * u1u1 * u2u2)) {\n+    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+    // we try other vectors\n+    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    double u3x  = u3.getX();\n+    double u3y  = u3.getY();\n+    double u3z  = u3.getZ();\n+    double v3x  = v3.getX();\n+    double v3y  = v3.getY();\n+    double v3z  = v3.getZ();\n+    double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;\n+\n+    double dx3 = v3x - u3x;\n+    double dy3 = v3y - u3y;\n+    double dz3 = v3z - u3z;\n+    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n+                     dz1 * dx3 - dx1 * dz3,\n+                     dx1 * dy3 - dy1 * dx3);\n+    c = k.getX() * (u1y * u3z - u1z * u3y)\n+      + k.getY() * (u1z * u3x - u1x * u3z)\n+      + k.getZ() * (u1x * u3y - u1y * u3x);\n+\n+    if (c < (1.0e-10 * u1u1 * u3u3)) {\n+      // the (q1, q2, q3) vector is aligned with u1:\n+      // we try (u2, u3) and (v2, v3)\n+      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n+                       dz2 * dx3 - dx2 * dz3,\n+                       dx2 * dy3 - dy2 * dx3);\n+      c = k.getX() * (u2y * u3z - u2z * u3y)\n+        + k.getY() * (u2z * u3x - u2x * u3z)\n+        + k.getZ() * (u2x * u3y - u2y * u3x);\n+\n+      if (c < (1.0e-10 * u2u2 * u3u3)) {\n+        // the (q1, q2, q3) vector is aligned with everything\n+        // this is really the identity rotation\n+        q0 = 1.0;\n+        q1 = 0.0;\n+        q2 = 0.0;\n+        q3 = 0.0;\n+        return;\n+      }\n+\n+      // we will have to use u2 and v2 to compute the scalar part\n+      uRef = u2;\n+      vRef = v2;\n+\n+    }\n+\n+  }\n+\n+  // compute the vectorial part\n+  c = Math.sqrt(c);\n+  double inv = 1.0 / (c + c);\n+  q1 = inv * k.getX();\n+  q2 = inv * k.getY();\n+  q3 = inv * k.getZ();\n+\n+  // compute the scalar part\n+   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n+                    uRef.getZ() * q1 - uRef.getX() * q3,\n+                    uRef.getX() * q2 - uRef.getY() * q1);\n+   c = Vector3D.dotProduct(k, k);\n+  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+\n+  }\n+\n+  /** Build one of the rotations that transform one vector into another one.\n+\n+   * <p>Except for a possible scale factor, if the instance were\n+   * applied to the vector u it will produce the vector v. There is an\n+   * infinite number of such rotations, this constructor choose the\n+   * one with the smallest associated angle (i.e. the one whose axis\n+   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+   * arbitrary rotation axis is chosen.</p>\n+\n+   * @param u origin vector\n+   * @param v desired image of u by the rotation\n+   * @exception ArithmeticException if the norm of one of the vectors is null\n+   */\n+  public Rotation(Vector3D u, Vector3D v) {\n+\n+    double normProduct = u.getNorm() * v.getNorm();\n+    if (normProduct < 1.0e-15) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double dot = Vector3D.dotProduct(u, v);\n+\n+    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n+      // special case u = -v: we select a PI angle rotation around\n+      // an arbitrary vector orthogonal to u\n+      Vector3D w = u.orthogonal();\n+      q0 = 0.0;\n+      q1 = -w.getX();\n+      q2 = -w.getY();\n+      q3 = -w.getZ();\n+    } else {\n+      // general case: (u, v) defines a plane, we select\n+      // the shortest possible rotation: axis orthogonal to this plane\n+      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));\n+      double coeff = 1.0 / (2.0 * q0 * normProduct);\n+      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n+      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n+      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+    }\n+\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+   * <p>Cardan rotations are three successive rotations around the\n+   * canonical axes X, Y and Z, each axis beeing used once. There are\n+   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+   * rotations are three successive rotations around the canonical\n+   * axes X, Y and Z, the first and last rotations beeing around the\n+   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ. Beware that\n+   * many people routinely use the term Euler angles even for what\n+   * really are Cardan angles (this confusion is especially widespread\n+   * in the aerospace business where Roll, Pitch and Yaw angles are\n+   * often tagged as Euler angles).</p>\n+\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public Rotation(RotationOrder order,\n+                  double alpha1, double alpha2, double alpha3) {\n+\n+    if (order == RotationOrder.XYZ) {\n+\n+      compose(new Rotation(Vector3D.plusI, alpha1),\n+              new Rotation(Vector3D.plusJ, alpha2),\n+              new Rotation(Vector3D.plusK, alpha3));\n+\n+    } else if (order == RotationOrder.XZY) {\n+\n+      compose(new Rotation(Vector3D.plusI, alpha1),\n+              new Rotation(Vector3D.plusK, alpha2),\n+              new Rotation(Vector3D.plusJ, alpha3));\n+\n+    } else if (order == RotationOrder.YXZ) {\n+\n+      compose(new Rotation(Vector3D.plusJ, alpha1),\n+              new Rotation(Vector3D.plusI, alpha2),\n+              new Rotation(Vector3D.plusK, alpha3));\n+\n+    } else if (order == RotationOrder.YZX) {\n+\n+      compose(new Rotation(Vector3D.plusJ, alpha1),\n+              new Rotation(Vector3D.plusK, alpha2),\n+              new Rotation(Vector3D.plusI, alpha3));\n+\n+    } else if (order == RotationOrder.ZXY) {\n+\n+      compose(new Rotation(Vector3D.plusK, alpha1),\n+              new Rotation(Vector3D.plusI, alpha2),\n+              new Rotation(Vector3D.plusJ, alpha3));\n+\n+    } else if (order == RotationOrder.ZYX) {\n+\n+      compose(new Rotation(Vector3D.plusK, alpha1),\n+              new Rotation(Vector3D.plusJ, alpha2),\n+              new Rotation(Vector3D.plusI, alpha3));\n+\n+    } else if (order == RotationOrder.XYX) {\n+\n+      compose(new Rotation(Vector3D.plusI, alpha1),\n+              new Rotation(Vector3D.plusJ, alpha2),\n+              new Rotation(Vector3D.plusI, alpha3));\n+\n+    } else if (order == RotationOrder.XZX) {\n+\n+      compose(new Rotation(Vector3D.plusI, alpha1),\n+              new Rotation(Vector3D.plusK, alpha2),\n+              new Rotation(Vector3D.plusI, alpha3));\n+\n+    } else if (order == RotationOrder.YXY) {\n+\n+      compose(new Rotation(Vector3D.plusJ, alpha1),\n+              new Rotation(Vector3D.plusI, alpha2),\n+              new Rotation(Vector3D.plusJ, alpha3));\n+\n+    } else if (order == RotationOrder.YZY) {\n+\n+      compose(new Rotation(Vector3D.plusJ, alpha1),\n+              new Rotation(Vector3D.plusK, alpha2),\n+              new Rotation(Vector3D.plusJ, alpha3));\n+\n+    } else if (order == RotationOrder.ZXZ) {\n+\n+      compose(new Rotation(Vector3D.plusK, alpha1),\n+              new Rotation(Vector3D.plusI, alpha2),\n+              new Rotation(Vector3D.plusK, alpha3));\n+\n+    } else { // last possibility is ZYZ\n+\n+      compose(new Rotation(Vector3D.plusK, alpha1),\n+              new Rotation(Vector3D.plusJ, alpha2),\n+              new Rotation(Vector3D.plusK, alpha3));\n+\n+    }\n+\n+  }\n+\n+  /** Override the instance by the composition of three rotations.\n+   * @param r1 last (outermost) rotation to compose\n+   * @param r2 intermediate rotation to compose\n+   * @param r3 first (innermost) rotation to compose\n+   */\n+  private void compose(Rotation r1, Rotation r2, Rotation r3) {\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n+  }\n+\n+  /** Copy constructor.\n+   * Build a copy of a rotation\n+   * @param r rotation to copy\n+   */\n+  public Rotation(Rotation r) {\n+    q0 = r.q0;\n+    q1 = r.q1;\n+    q2 = r.q2;\n+    q3 = r.q3;\n+  }\n+\n+  /** Revert a rotation.\n+   * Build a rotation which reverse the effect of another\n+   * rotation. This means that is r(u) = v, then r.revert (v) = u. The\n+   * instance is not changed.\n+   * @return a new rotation whose effect is the reverse of the effect\n+   * of the instance\n+   */\n+  public Rotation revert() {\n+    return new Rotation(-q0, q1, q2, q3);\n+  }\n+\n+  /** Get the scalar coordinate of the quaternion.\n+   * @return scalar coordinate of the quaternion\n+   */\n+  public double getQ0() {\n+    return q0;\n+  }\n+\n+  /** Get the first coordinate of the vectorial part of the quaternion.\n+   * @return first coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ1() {\n+    return q1;\n+  }\n+\n+  /** Get the second coordinate of the vectorial part of the quaternion.\n+   * @return second coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ2() {\n+    return q2;\n+  }\n+\n+  /** Get the third coordinate of the vectorial part of the quaternion.\n+   * @return third coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ3() {\n+    return q3;\n+  }\n+\n+  /** Get the normalized axis of the rotation.\n+   * @return normalized axis of the rotation\n+   */\n+  public Vector3D getAxis() {\n+    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n+    if (squaredSine < 1.0e-12) {\n+      return new Vector3D(1, 0, 0);\n+    } else if (q0 < 0) {\n+      double inverse = 1 / Math.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    } else {\n+      double inverse = -1 / Math.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    }\n+  }\n+\n+  /** Get the angle of the rotation.\n+   * @return angle of the rotation (between 0 and PI)\n+   */\n+  public double getAngle() {\n+    if ((q0 < -0.1) || (q0 > 0.1)) {\n+      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n+    } else if (q0 < 0) {\n+      return 2 * Math.acos(-q0);\n+    } else {\n+      return 2 * Math.acos(q0);\n+    }\n+  }\n+\n+  /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+   * <p>The equations show that each rotation can be defined by two\n+   * different values of the Cardan or Euler angles set. For example\n+   * if Cardan angles are used, the rotation defined by the angles a1,\n+   * a2 and a3 is the same as the rotation defined by the angles PI +\n+   * a1, PI - a2 and PI + a3. This method implements the following\n+   * arbitrary choices. For Cardan angles, the chosen set is the one\n+   * for which the second angle is between -PI/2 and PI/2 (i.e its\n+   * cosine is positive). For Euler angles, the chosen set is the one\n+   * for which the second angle is between 0 and PI (i.e its sine is\n+   * positive).</p>\n+\n+   * <p>Cardan and Euler angle have a very disappointing drawback: all\n+   * of them have singularities. This means that if the instance is\n+   * too close to the singularities corresponding to the given\n+   * rotation order, it will be impossible to retrieve the angles. For\n+   * Cardan angles, this is often called gimbal lock. There is\n+   * <em>nothing</em> to do to prevent this, it is an intrisic problem\n+   * of Cardan and Euler representation (but not a problem with the\n+   * rotation itself, which is perfectly well defined). For Cardan\n+   * angles, singularities occur when the second angle is close to\n+   * -PI/2 or +PI/2, for Euler angle singularities occur when the\n+   * second angle is close to 0 or PI, this means that the identity\n+   * rotation is always singular for Euler angles !\n+\n+   * @param order rotation order to use\n+   * @return an array of three angles, in the order specified by the set\n+   * @exception CardanEulerSingularityException if the rotation is\n+   * singular with respect to the angles set specified\n+   */\n+  public double[] getAngles(RotationOrder order)\n+    throws CardanEulerSingularityException {\n+\n+    final double small        = 1.0e-10;\n+    final double maxThreshold = 1.0 - small;\n+    final double minThreshold = -maxThreshold;\n+\n+    double[] angles = new double[3];\n+    Vector3D v1 = null;\n+    Vector3D v2 = null;\n+\n+    if (order == RotationOrder.XYZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if  ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getY()), v1.getZ());\n+      angles[1] = Math.asin(v2.getZ());\n+      angles[2] = Math.atan2(-(v2.getY()), v2.getX());\n+\n+    } else if (order == RotationOrder.XZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n+      angles[1] = -Math.asin(v2.getY());\n+      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+\n+    } else if (order == RotationOrder.YXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n+      angles[1] = -Math.asin(v2.getZ());\n+      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+\n+    } else if (order == RotationOrder.YZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getZ()), v1.getX());\n+      angles[1] = Math.asin(v2.getX());\n+      angles[2] = Math.atan2(-(v2.getZ()), v2.getY());\n+\n+    } else if (order == RotationOrder.ZXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getX()), v1.getY());\n+      angles[1] = Math.asin(v2.getY());\n+      angles[2] = Math.atan2(-(v2.getX()), v2.getZ());\n+\n+    } else if (order == RotationOrder.ZYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), v1.getX());\n+      angles[1] = -Math.asin(v2.getX());\n+      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+\n+    } else if (order == RotationOrder.XYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), -v1.getZ());\n+      angles[1] = Math.acos(v2.getX());\n+      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+\n+    } else if (order == RotationOrder.XZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n+      angles[1] = Math.acos(v2.getX());\n+      angles[2] = Math.atan2(v2.getZ(), -v2.getY());\n+\n+    } else if (order == RotationOrder.YXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n+      angles[1] = Math.acos(v2.getY());\n+      angles[2] = Math.atan2(v2.getX(), -v2.getZ());\n+\n+    } else if (order == RotationOrder.YZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), -v1.getX());\n+      angles[1] = Math.acos(v2.getY());\n+      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+\n+    } else if (order == RotationOrder.ZXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), -v1.getY());\n+      angles[1] = Math.acos(v2.getZ());\n+      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+\n+    } else { // last possibility is ZYZ\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), v1.getX());\n+      angles[1] = Math.acos(v2.getZ());\n+      angles[2] = Math.atan2(v2.getY(), -v2.getX());\n+\n+    }\n+\n+    return angles;\n+\n+  }\n+\n+  /** Get the 3X3 matrix corresponding to the instance\n+   * @return the matrix corresponding to the instance\n+   */\n+  public double[][] getMatrix() {\n+\n+    // products\n+    double q0q0  = q0 * q0;\n+    double q0q1  = q0 * q1;\n+    double q0q2  = q0 * q2;\n+    double q0q3  = q0 * q3;\n+    double q1q1  = q1 * q1;\n+    double q1q2  = q1 * q2;\n+    double q1q3  = q1 * q3;\n+    double q2q2  = q2 * q2;\n+    double q2q3  = q2 * q3;\n+    double q3q3  = q3 * q3;\n+\n+    // create the matrix\n+    double[][] m = new double[3][];\n+    m[0] = new double[3];\n+    m[1] = new double[3];\n+    m[2] = new double[3];\n+\n+    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n+    m [1][0] = 2.0 * (q1q2 - q0q3);\n+    m [2][0] = 2.0 * (q1q3 + q0q2);\n+\n+    m [0][1] = 2.0 * (q1q2 + q0q3);\n+    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n+    m [2][1] = 2.0 * (q2q3 - q0q1);\n+\n+    m [0][2] = 2.0 * (q1q3 - q0q2);\n+    m [1][2] = 2.0 * (q2q3 + q0q1);\n+    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n+\n+    return m;\n+\n+  }\n+\n+  /** Apply the rotation to a vector.\n+   * @param u vector to apply the rotation to\n+   * @return a new vector which is the image of u by the rotation\n+   */\n+  public Vector3D applyTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+\n+    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the inverse of the rotation to a vector.\n+   * @param u vector to apply the inverse of the rotation to\n+   * @return a new vector which such that u is its image by the rotation\n+   */\n+  public Vector3D applyInverseTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+    double m0 = -q0;\n+\n+    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the instance to another rotation.\n+   * Applying the instance to a rotation is computing the composition\n+   * in an order compliant with the following rule : let u be any\n+   * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+   * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+   * where comp = applyTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the instance\n+   */\n+  public Rotation applyTo(Rotation r) {\n+    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1));\n+  }\n+\n+  /** Apply the inverse of the instance to another rotation.\n+   * Applying the inverse of the instance to a rotation is computing\n+   * the composition in an order compliant with the following rule :\n+   * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+   * let w be the inverse image of v by the instance\n+   * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+   * comp = applyInverseTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the inverse\n+   * of the instance\n+   */\n+  public Rotation applyInverseTo(Rotation r) {\n+    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1));\n+  }\n+\n+  /** Perfect orthogonality on a 3X3 matrix.\n+   * @param m initial matrix (not exactly orthogonal)\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+   * @return an orthogonal matrix close to m\n+   * @exception NotARotationMatrixException if the matrix cannot be\n+   * orthogonalized with the given threshold after 10 iterations\n+   */\n+  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+    double x00 = m[0][0];\n+    double x01 = m[0][1];\n+    double x02 = m[0][2];\n+    double x10 = m[1][0];\n+    double x11 = m[1][1];\n+    double x12 = m[1][2];\n+    double x20 = m[2][0];\n+    double x21 = m[2][1];\n+    double x22 = m[2][2];\n+    double fn = 0;\n+    double fn1;\n+\n+    double[][] o = new double[3][];\n+    o[0] = new double[3];\n+    o[1] = new double[3];\n+    o[2] = new double[3];\n+\n+    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+    int i = 0;\n+    while (++i < 11) {\n+\n+      // Mt.Xn\n+      double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;\n+      double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;\n+      double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;\n+      double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;\n+      double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;\n+      double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;\n+      double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;\n+      double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;\n+      double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;\n+\n+      // Xn+1\n+      o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);\n+      o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);\n+      o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);\n+      o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);\n+      o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);\n+      o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);\n+      o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);\n+      o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);\n+      o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);\n+\n+      // correction on each elements\n+      double corr00 = o[0][0] - m[0][0];\n+      double corr01 = o[0][1] - m[0][1];\n+      double corr02 = o[0][2] - m[0][2];\n+      double corr10 = o[1][0] - m[1][0];\n+      double corr11 = o[1][1] - m[1][1];\n+      double corr12 = o[1][2] - m[1][2];\n+      double corr20 = o[2][0] - m[2][0];\n+      double corr21 = o[2][1] - m[2][1];\n+      double corr22 = o[2][2] - m[2][2];\n+\n+      // Frobenius norm of the correction\n+      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02\n+        + corr10 * corr10 + corr11 * corr11 + corr12 * corr12\n+        + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+      // convergence test\n+      if (Math.abs(fn1 - fn) <= threshold)\n+        return o;\n+\n+      // prepare next iteration\n+      x00 = o[0][0];\n+      x01 = o[0][1];\n+      x02 = o[0][2];\n+      x10 = o[1][0];\n+      x11 = o[1][1];\n+      x12 = o[1][2];\n+      x20 = o[2][0];\n+      x21 = o[2][1];\n+      x22 = o[2][2];\n+      fn  = fn1;\n+\n+    }\n+\n+    // the algorithm did not converge after 10 iterations\n+    throw new NotARotationMatrixException(\"unable to orthogonalize matrix\"\n+                                          + \" in {0} iterations\",\n+                                          new String[] {\n+                                            Integer.toString(i - 1)\n+                                          });\n+  }\n+\n+  public int getStateDimension() {\n+    return 4;\n+  }\n+    \n+  public void mapStateFromArray(int start, double[] array) {\n+    q0 = array[start];\n+    q1 = array[start + 1];\n+    q2 = array[start + 2];\n+    q3 = array[start + 3];\n+  }\n+\n+  public void mapStateToArray(int start, double[] array) {\n+    array[start]     = q0;\n+    array[start + 1] = q1;\n+    array[start + 2] = q2;\n+    array[start + 3] = q3;\n+  }\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private double q3;\n+\n+  private static final long serialVersionUID = 7264384082212242475L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/RotationOrder.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+/**\n+ * This class is a utility representing a rotation order specification\n+ * for Cardan or Euler angles specification.\n+\n+ * This class cannot be instanciated by the user. He can only use one\n+ * of the twelve predefined supported orders as an argument to either\n+ * the {@link Rotation#Rotation(RotationOrder,double,double,double)}\n+ * constructor or the {@link Rotation#getAngles} method.\n+\n+ * @version $Id: RotationOrder.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public final class RotationOrder {\n+\n+  /** Private constructor.\n+   * This is a utility class that cannot be instantiated by the user,\n+   * so its only constructor is private.\n+   * @param name name of the rotation order\n+   */\n+  private RotationOrder(String name) {\n+    this.name = name;\n+  }\n+\n+  /** Get a string representation of the instance.\n+   * @return a string representation of the instance (in fact, its name)\n+   */\n+  public String toString() {\n+    return name;\n+  }\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder XYZ = new RotationOrder(\"XYZ\");\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder XZY = new RotationOrder(\"XZY\");\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder YXZ = new RotationOrder(\"YXZ\");\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder YZX = new RotationOrder(\"YZX\");\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder ZXY = new RotationOrder(\"ZXY\");\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder ZYX = new RotationOrder(\"ZYX\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder XYX = new RotationOrder(\"XYX\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder XZX = new RotationOrder(\"XZX\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder YXY = new RotationOrder(\"YXY\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder YZY = new RotationOrder(\"YZY\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\");\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\");\n+\n+  /** Name of the rotations order. */\n+  private final String name;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Vector3D.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import java.io.Serializable;\n+import org.spaceroots.mantissa.utilities.ArraySliceMappable;\n+\n+\n+/** This class implements vectors in a three-dimensional space.\n+ * @version $Id: Vector3D.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+\n+public class Vector3D\n+  implements ArraySliceMappable, Serializable {\n+\n+  /** First canonical vector (coordinates : 1, 0, 0).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D plusI = new ImmutableVector3D(1, 0, 0);\n+\n+  /** Opposite of the first canonical vector (coordinates : -1, 0, 0).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D minusI = new ImmutableVector3D(-1, 0, 0);\n+\n+  /** Second canonical vector (coordinates : 0, 1, 0).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D plusJ = new ImmutableVector3D(0, 1, 0);\n+\n+  /** Opposite of the second canonical vector (coordinates : 0, -1, 0).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D minusJ = new ImmutableVector3D(0, -1, 0);\n+\n+  /** Third canonical vector (coordinates : 0, 0, 1).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D plusK = new ImmutableVector3D(0, 0, 1);\n+\n+  /** Opposite of the third canonical vector (coordinates : 0, 0, -1).\n+   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n+   * hence it can't be changed in any way.\n+   */\n+  public static final Vector3D minusK = new ImmutableVector3D(0, 0, -1);\n+\n+  /** Simple constructor.\n+   * Build a null vector.\n+   */\n+  public Vector3D() {\n+    x = 0;\n+    y = 0;\n+    z = 0;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate\n+   * @param z height\n+   * @see #getX()\n+   * @see #getY()\n+   * @see #getZ()\n+   */\n+  public Vector3D(double x, double y, double z) {\n+    this.x = x;\n+    this.y = y;\n+    this.z = z;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its azimuthal coordinates\n+   * @param alpha azimuth (&alpha;) around Z\n+   *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+   * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+   * @see #getAlpha()\n+   * @see #getDelta()\n+   */\n+  public Vector3D(double alpha, double delta) {\n+    double cosDelta = Math.cos(delta);\n+    this.x = Math.cos(alpha) * cosDelta;\n+    this.y = Math.sin(alpha) * cosDelta;\n+    this.z = Math.sin(delta);\n+  }\n+\n+  /** Multiplicative constructor\n+   * Build a vector from another one and a scale factor. \n+   * The vector built will be a * u\n+   * @param a scale factor\n+   * @param u base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u) {\n+    this.x = a * u.x;\n+    this.y = a * u.y;\n+    this.z = a * u.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from two other ones and corresponding scale factors.\n+   * The vector built will be a * u +  b * v\n+   * @param a first scale factor\n+   * @param u first base (unscaled) vector\n+   * @param b second scale factor\n+   * @param v second base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u, double b, Vector3D v) {\n+    this.x = a * u.x + b * v.x;\n+    this.y = a * u.y + b * v.y;\n+    this.z = a * u.z + b * v.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from three other ones and corresponding scale factors.\n+   * The vector built will be a * u +  b * v + c * w\n+   * @param a first scale factor\n+   * @param u first base (unscaled) vector\n+   * @param b second scale factor\n+   * @param v second base (unscaled) vector\n+   * @param c third scale factor\n+   * @param w third base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u,\n+                  double b, Vector3D v,\n+                  double c, Vector3D w) {\n+    this.x = a * u.x + b * v.x + c * w.x;\n+    this.y = a * u.y + b * v.y + c * w.y;\n+    this.z = a * u.z + b * v.z + c * w.z;\n+  }\n+\n+  /** Copy constructor.\n+   * Build a copy of a vector\n+   * @param v vector to copy\n+   */\n+  public Vector3D(Vector3D v) {\n+    x = v.x;\n+    y = v.y;\n+    z = v.z;\n+  }\n+\n+  /** Reset the instance.\n+   * @param v vector to copy data from\n+   */\n+  public void reset(Vector3D v) {\n+    x = v.x;\n+    y = v.y;\n+    z = v.z;\n+  }\n+\n+  /** Get the abscissa of the vector.\n+   * @return abscissa of the vector\n+   * @see #Vector3D(double, double, double)\n+   * @see #setX(double)\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /** Set the abscissa of the vector.\n+   * @param x new abscissa for the vector\n+   * @see #getX()\n+   * @see #setCoordinates(double, double, double)\n+   */\n+  public void setX(double x) {\n+    this.x = x;\n+  }\n+\n+  /** Get the ordinate of the vector.\n+   * @return ordinate of the vector\n+   * @see #Vector3D(double, double, double)\n+   * @see #setY(double)\n+   */\n+  public double getY() {\n+    return y;\n+  }\n+\n+  /** Set the ordinate of the vector.\n+   * @param y new ordinate for the vector\n+   * @see #getY()\n+   * @see #setCoordinates(double, double, double)\n+   */\n+  public void setY(double y) {\n+    this.y = y;\n+  }\n+\n+  /** Get the height of the vector.\n+   * @return height of the vector\n+   * @see #Vector3D(double, double, double)\n+   * @see #setZ(double)\n+   */\n+  public double getZ() {\n+    return z;\n+  }\n+\n+  /** Set the height of the vector.\n+   * @param z new height for the vector\n+   * @see #getZ()\n+   * @see #setCoordinates(double, double, double)\n+   */\n+  public void setZ(double z) {\n+    this.z = z;\n+  }\n+\n+  /** Set all coordinates of the vector.\n+   * @param x new abscissa for the vector\n+   * @param y new ordinate for the vector\n+   * @param z new height for the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public void setCoordinates(double x, double y, double z) {\n+    this.x = x;\n+    this.y = y;\n+    this.z = z;\n+  }\n+\n+  /** Get the norm for the vector.\n+   * @return euclidian norm for the vector\n+   */\n+  public double getNorm() {\n+    return Math.sqrt (x * x + y * y + z * z);\n+  }\n+\n+  /** Get the azimuth of the vector.\n+   * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getAlpha() {\n+    return Math.atan2(y, x);\n+  }\n+\n+  /** Get the elevation of the vector.\n+   * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getDelta() {\n+    return Math.asin(z / getNorm());\n+  }\n+\n+  /** Add a vector to the instance.\n+   * Add a vector to the instance. The instance is changed.\n+   * @param v vector to add\n+   */\n+  public void addToSelf(Vector3D v) {\n+    x += v.x;\n+    y += v.y;\n+    z += v.z;\n+  }\n+\n+  /** Add a scaled vector to the instance.\n+   * Add a scaled vector to the instance. The instance is changed.\n+   * @param factor scale factor to apply to v before adding it\n+   * @param v vector to add\n+   */\n+  public void addToSelf(double factor, Vector3D v) {\n+    x += factor * v.x;\n+    y += factor * v.y;\n+    z += factor * v.z;\n+  }\n+\n+  /** Add two vectors.\n+   * Add two vectors and return the sum as a new vector\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return a new vector equal to v1 + v2\n+   */\n+  public static Vector3D add(Vector3D v1, Vector3D v2) {\n+    return new Vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * Subtract a vector from the instance. The instance is changed.\n+   * @param v vector to subtract\n+   */\n+  public void subtractFromSelf(Vector3D v) {\n+    x -= v.x;\n+    y -= v.y;\n+    z -= v.z;\n+  }\n+\n+  /** Subtract two vectors.\n+   * Subtract two vectors and return the difference as a new vector\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return a new vector equal to v1 - v2\n+   */\n+  public static Vector3D subtract(Vector3D v1, Vector3D v2) {\n+    return new Vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n+  }\n+\n+  /** Normalize the instance.\n+   * Divide the instance by its norm in order to have a unit\n+   * vector. The instance is changed.\n+   * @exception ArithmeticException if the norm is null\n+   */\n+  public void normalizeSelf() {\n+    double s = getNorm();\n+    if (s == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+    double invNorm = 1 / s;\n+    x *= invNorm;\n+    y *= invNorm;\n+    z *= invNorm;\n+  }\n+\n+  /** Get a vector orthogonal to the instance.\n+   * <p>There are an infinite number of normalized vectors orthogonal\n+   * to the instance. This method picks up one of them almost\n+   * arbitrarily. It is useful when one needs to compute a reference\n+   * frame with one of the axes in a predefined direction. The\n+   * following example shows how to build a frame having the k axis\n+   * aligned with the known vector u :\n+   * <pre><code>\n+   *   Vector3D k = u;\n+   *   k.normalizeSelf();\n+   *   Vector3D i = k.orthogonal();\n+   *   Vector3D j = Vector3D.crossProduct(k, i);\n+   * </code></pre></p>\n+   * @return a new normalized vector orthogonal to the instance\n+   * @exception ArithmeticException if the norm of the instance is null\n+   */\n+  public Vector3D orthogonal() {\n+\n+    double threshold = 0.6 * getNorm();\n+    if (threshold == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    if ((x >= -threshold) && (x <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(y * y + z * z);\n+      return new Vector3D(0, inverse * z, -inverse * y);\n+    } else if ((y >= -threshold) && (y <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(x * x + z * z);\n+      return new Vector3D(-inverse * z, 0, inverse * x);\n+    } else {\n+      double inverse  = 1 / Math.sqrt(x * x + y * y);\n+      return new Vector3D(inverse * y, -inverse * x, 0);\n+    }\n+\n+  }\n+\n+  /** Compute the angular separation between two vectors.\n+   * <p>This method computes the angular separation between two\n+   * vectors using the dot product for well separated vectors and the\n+   * cross product for almost aligned vectors. This allow to have a\n+   * good accuracy in all cases, even for vectors very close to each\n+   * other.</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @exception ArithmeticException if either vector has a null norm\n+   */\n+  public static double angle(Vector3D v1, Vector3D v2) {\n+\n+    double normProduct = v1.getNorm() * v2.getNorm();\n+    if (normProduct == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double dot = dotProduct(v1, v2);\n+    double threshold = normProduct * 0.9999;\n+    if ((dot < -threshold) || (dot > threshold)) {\n+      // the vectors are almost aligned, compute using the sine\n+      Vector3D v3 = crossProduct(v1, v2);\n+      if (dot >= 0) {\n+        return Math.asin(v3.getNorm() / normProduct);\n+      }\n+      return Math.PI - Math.asin(v3.getNorm() / normProduct);\n+    }\n+    \n+    // the vectors are sufficiently separated to use the cosine\n+    return Math.acos(dot / normProduct);\n+\n+  }\n+\n+  /** Revert the instance.\n+   * Replace the instance u by -u\n+   */\n+  public void negateSelf() {\n+    x = -x;\n+    y = -y;\n+    z = -z;\n+  }\n+\n+  /** Get the opposite of a vector.\n+   * @param u vector to revert\n+   * @return a new vector which is -u\n+   */\n+  public static Vector3D negate(Vector3D u) {\n+    return new Vector3D(-u.x, -u.y, -u.z);\n+  }\n+\n+  /** Multiply the instance by a scalar\n+   * Multiply the instance by a scalar. The instance is changed.\n+   * @param a scalar by which the instance should be multiplied\n+   */\n+  public void multiplySelf(double a) {\n+    x *= a;\n+    y *= a;\n+    z *= a;\n+  }\n+\n+  /** Multiply a vector by a scalar\n+   * Multiply a vectors by a scalar and return the product as a new vector\n+   * @param a scalar\n+   * @param v vector\n+   * @return a new vector equal to a * v\n+   */\n+  public static Vector3D multiply(double a, Vector3D v) {\n+    return new Vector3D(a * v.x, a * v.y, a * v.z);\n+  }\n+\n+  /** Compute the dot-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the dot product v1.v2\n+   */\n+  public static double dotProduct(Vector3D v1, Vector3D v2) {\n+    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n+  }\n+\n+  /** Set the instance to the result of the cross-product of two vectors.\n+   * @param v1 first vector (can be the instance)\n+   * @param v2 second vector (can be the instance)\n+   */\n+  public void setToCrossProduct(Vector3D v1, Vector3D v2) {\n+    double newX = v1.y * v2.z - v1.z * v2.y;\n+    double newY = v1.z * v2.x - v1.x * v2.z;\n+    z = v1.x * v2.y - v1.y * v2.x;\n+    x = newX;\n+    y = newY;\n+  }\n+\n+  /** Compute the cross-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the cross product v1 ^ v2 as a new Vector\n+   */\n+  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n+    return new Vector3D(v1.y * v2.z - v1.z * v2.y,\n+                        v1.z * v2.x - v1.x * v2.z,\n+                        v1.x * v2.y - v1.y * v2.x);\n+  }\n+\n+  public int getStateDimension() {\n+    return 3;\n+  }\n+    \n+  public void mapStateFromArray(int start, double[] array) {\n+    x = array[start];\n+    y = array[start + 1];\n+    z = array[start + 2];\n+  }\n+\n+  public void mapStateToArray(int start, double[] array) {\n+    array[start]     = x;\n+    array[start + 1] = y;\n+    array[start + 2] = z;\n+  }\n+\n+  /** Abscissa. */\n+  protected double x;\n+\n+  /** Ordinate. */\n+  protected double y;\n+\n+  /** Height. */\n+  protected double z;\n+\n+   private static final long serialVersionUID = 4115635019045864211L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class implements diagonal matrices of linear algebra.\n+\n+ * @version $Id: DiagonalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DiagonalMatrix\n+  extends SquareMatrix\n+  implements Serializable, Cloneable {\n+\n+  /** Simple constructor.\n+   * This constructor builds a diagonal matrix of specified order, all\n+   * elements on the diagonal being ones (so this is an identity matrix).\n+   * @param order order of the matrix\n+   */\n+  public DiagonalMatrix(int order) {\n+    this(order, 1.0);\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor builds a diagonal matrix of specified order and\n+   * set all diagonal elements to the same value.\n+   * @param order order of the matrix\n+   * @param value value for the diagonal elements\n+   */\n+  public DiagonalMatrix(int order, double value) {\n+    super(order);\n+    for (int index = 0; index < order * order; index += order + 1) {\n+      data[index] = value;\n+    }\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public DiagonalMatrix(int order, double[] data) {\n+    super(order, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param d diagonal matrix to copy\n+   */\n+  public DiagonalMatrix(DiagonalMatrix d) {\n+    super(d);\n+  }\n+\n+  public Matrix duplicate() {\n+    return new DiagonalMatrix(this);\n+  }\n+\n+  public void setElement(int i, int j, double value) {\n+    if (i != j) {\n+      throw new ArrayIndexOutOfBoundsException(\"cannot set elements\"\n+                                               + \" out of diagonal in a\"\n+                                               + \" diagonal matrix\");\n+    }\n+    super.setElement(i, j, value);\n+  }\n+\n+  public double getDeterminant(double epsilon) {\n+    double determinant = data[0];\n+    for (int index = columns + 1; index < columns * columns; index += columns + 1) {\n+      determinant *= data[index];\n+    }\n+    return determinant;\n+  }\n+\n+  public SquareMatrix getInverse(double epsilon)\n+    throws SingularMatrixException {\n+\n+    DiagonalMatrix inv = new DiagonalMatrix (columns);\n+\n+    for (int index = 0; index < columns * columns; index += columns + 1) {\n+      if (Math.abs(data[index]) < epsilon) {\n+        throw new SingularMatrixException();\n+      }\n+      inv.data[index] = 1.0 / data[index];\n+    }\n+\n+    return inv;\n+\n+  }\n+\n+  public Matrix solve(Matrix b, double epsilon)\n+    throws SingularMatrixException {\n+\n+    Matrix result = b.duplicate();\n+\n+    for (int i = 0; i < columns; ++i) {\n+      double diag = data[i * (columns + 1)];\n+      if (Math.abs(diag) < epsilon) {\n+        throw new SingularMatrixException();\n+      }\n+      double inv = 1.0 / diag;\n+\n+      NonNullRange range = result.getRangeForRow(i);\n+      for (int index = i * b.columns + range.begin;\n+           index < i * b.columns + range.end;\n+           ++index) {\n+        result.data[index] = inv * b.data[index];\n+      }\n+    }\n+\n+    return result;\n+\n+  }\n+\n+  public NonNullRange getRangeForRow(int i) {\n+    return new NonNullRange(i, i + 1);\n+  }\n+\n+  public NonNullRange getRangeForColumn(int j) {\n+    return new NonNullRange(j, j + 1);\n+  }\n+\n+  private static final long serialVersionUID = -2965166085913895323L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class represents matrices of the most general type.\n+\n+ * <p>This class is the basic implementation of matrices to use when\n+ * nothing special is known about the structure of the matrix.</p>\n+\n+ * @version $Id: GeneralMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GeneralMatrix\n+  extends Matrix\n+  implements Serializable {\n+\n+  /** Simple constructor.\n+   * Build a matrix with null elements.\n+   * @param rows number of rows of the matrix\n+   * @param columns number of columns of the matrix\n+   */\n+  public GeneralMatrix(int rows, int columns) {\n+    super(rows, columns);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param rows number of rows of the matrix\n+   * @param columns number of columns of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public GeneralMatrix(int rows, int columns, double[] data) {\n+    super(rows, columns, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param m matrix to copy\n+   */\n+  public GeneralMatrix(Matrix m) {\n+    super(m);\n+  }\n+\n+  public Matrix duplicate() {\n+    return new GeneralMatrix(this);\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It does modify the instance.\n+   * @param m matrix to add\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAdd(Matrix m) {\n+\n+    // validity check\n+    if ((rows != m.rows) || (columns != m.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + m.rows + 'x' + m.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // addition loop\n+    for (int index = 0; index < rows * columns; ++index) {\n+      data[index] += m.data[index];\n+    }\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substracts a matrix from the instance. It does modify the instance.\n+   * @param m matrix to substract\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfSub(Matrix m) {\n+\n+    // validity check\n+    if ((rows != m.rows) || (columns != m.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + m.rows + 'x' + m.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // substraction loop\n+    for (int index = 0; index < rows * columns; ++index) {\n+      data[index] -= m.data[index];\n+    }\n+\n+  }\n+\n+  protected NonNullRange getRangeForRow(int i) {\n+    return new NonNullRange(0, columns);\n+  }\n+\n+  protected NonNullRange getRangeForColumn(int j) {\n+    return new NonNullRange(0, rows);\n+  }\n+\n+  private static final long serialVersionUID = 4350328622456299819L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class implements general square matrices of linear algebra.\n+\n+ * @version $Id: GeneralSquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GeneralSquareMatrix\n+  extends SquareMatrix\n+  implements Serializable, Cloneable {\n+\n+  /** Simple constructor.\n+   * This constructor builds a square matrix of specified order, all\n+   * elements beeing zeros.\n+   * @param order order of the matrix\n+   */\n+  public GeneralSquareMatrix(int order) {\n+    super(order);\n+    permutations     = null;\n+    evenPermutations = true;\n+    lower            = null;\n+    upper            = null;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public GeneralSquareMatrix(int order, double[] data) {\n+    super(order, data);\n+    permutations     = null;\n+    evenPermutations = true;\n+    lower            = null;\n+    upper            = null;\n+  }\n+\n+  /** Copy constructor.\n+   * @param s square matrix to copy\n+   */\n+  public GeneralSquareMatrix(GeneralSquareMatrix s) {\n+    super(s);\n+\n+    if (s.permutations != null) {\n+      permutations     = (int[]) s.permutations.clone();\n+      evenPermutations = s.evenPermutations;\n+      lower            = new LowerTriangularMatrix(s.lower);\n+      upper            = new UpperTriangularMatrix(s.upper);\n+    } else {\n+      permutations     = null;\n+      evenPermutations = true;\n+      lower            = null;\n+      upper            = null;\n+    }\n+\n+  }\n+\n+  public Matrix duplicate() {\n+    return new GeneralSquareMatrix(this);\n+  }\n+\n+  public void setElement(int i, int j, double value) {\n+    super.setElement(i, j, value);\n+    permutations     = null;\n+    evenPermutations = true;\n+    lower            = null;\n+    upper            = null;\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It does modify the instance.\n+   * @param s square matrix to add\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAdd(SquareMatrix s) {\n+\n+    // validity check\n+    if ((rows != s.rows) || (columns != s.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + s.rows + 'x' + s.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // addition loop\n+    for (int index = 0; index < rows * columns; ++index) {\n+      data[index] += s.data[index];\n+    }\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substracts a matrix from the instance. It does modify the instance.\n+   * @param s square matrix to substract\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfSub(SquareMatrix s) {\n+\n+    // validity check\n+    if ((rows != s.rows) || (columns != s.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + s.rows + 'x' + s.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+      \n+    // substraction loop\n+    for (int index = 0; index < rows * columns; ++index) {\n+      data[index] -= s.data[index];\n+    }\n+\n+  }\n+\n+  public double getDeterminant(double epsilon) {\n+    try {\n+      if (permutations == null)\n+        computeLUFactorization(epsilon);\n+      double d = upper.getDeterminant(epsilon);\n+      return evenPermutations ? d : -d;\n+    } catch (SingularMatrixException e) {\n+      return 0.0;\n+    }\n+  }\n+\n+  public Matrix solve(Matrix b, double epsilon)\n+    throws SingularMatrixException {\n+    // validity check\n+    if (b.getRows() != rows) {\n+      throw new IllegalArgumentException(\"dimension mismatch\");\n+    }\n+\n+    if (permutations == null) {\n+      computeLUFactorization(epsilon);\n+    }\n+\n+    // apply the permutations to the second member\n+    double[] permData = new double[b.data.length];\n+    int bCols = b.getColumns();\n+    for (int i = 0; i < rows; ++i) {\n+      NonNullRange range = b.getRangeForRow(permutations[i]);\n+      for (int j = range.begin; j < range.end; ++j) {\n+        permData[i * bCols + j] = b.data[permutations[i] * bCols + j];\n+      }\n+    }\n+    Matrix permB = MatrixFactory.buildMatrix(b.getRows(), bCols, permData);\n+\n+    // solve the permuted system\n+    return upper.solve(lower.solve(permB, epsilon), epsilon);\n+\n+  }\n+\n+  protected NonNullRange getRangeForRow(int i) {\n+    return new NonNullRange(0, columns);\n+  }\n+\n+  protected NonNullRange getRangeForColumn(int j) {\n+    return new NonNullRange(0, rows);\n+  }\n+\n+  private void computeLUFactorization(double epsilon)\n+    throws SingularMatrixException {\n+    // build a working copy of the matrix data\n+    double[] work = new double[rows * columns];\n+    for (int index = 0; index < work.length; ++index) {\n+      work[index] = data[index];\n+    }\n+\n+    // initialize the permutations table to identity\n+    permutations = new int[rows];\n+    for (int i = 0; i < rows; ++i) {\n+      permutations[i] = i;\n+    }\n+    evenPermutations = true;\n+\n+    for (int k = 0; k < rows; ++k) {\n+\n+      // find the maximal element in the column\n+      double maxElt = Math.abs(work[permutations[k] * columns + k]);\n+      int    jMax   = k;\n+      for (int i = k + 1; i < rows; ++i) {\n+        double curElt = Math.abs(work[permutations[i] * columns + k]);\n+        if (curElt > maxElt) {\n+          maxElt = curElt;\n+          jMax   = i;\n+        }\n+      }\n+\n+      if (maxElt < epsilon) {\n+        throw new SingularMatrixException();\n+      }\n+\n+      if (k != jMax) {\n+        // do the permutation to have a large enough diagonal element\n+        int tmp            = permutations[k];\n+        permutations[k]    = permutations[jMax];\n+        permutations[jMax] = tmp;\n+        evenPermutations   = ! evenPermutations;\n+      }\n+\n+      double inv = 1.0 / work[permutations[k] * columns + k];\n+\n+      // compute the contribution of the row to the triangular matrices\n+      for (int i = k + 1; i < rows; ++i) {\n+        double factor = inv * work[permutations[i] * columns + k];\n+\n+        // lower triangular matrix\n+        work[permutations[i] * columns + k] = factor;\n+\n+        // upper triangular matrix\n+        int index1 = permutations[i] * columns + k;\n+        int index2 = permutations[k] * columns + k;\n+        for (int j = k + 1; j < columns; ++j) {\n+          work[++index1] -= factor * work[++index2];\n+        }\n+      }\n+    }\n+\n+    // build the matrices\n+    double[] lowerData = new double[rows * columns];\n+    double[] upperData = new double[rows * columns];\n+\n+    int index = 0;\n+    for (int i = 0; i < rows; ++i) {\n+      int workIndex = permutations[i] * columns;\n+      int j         = 0;\n+\n+      // lower part\n+      while (j++ < i) {\n+        lowerData[index]   = work[workIndex++];\n+        upperData[index++] = 0.0;\n+      }\n+\n+      // diagonal\n+      lowerData[index]   = 1.0;\n+      upperData[index++] = work[workIndex++];\n+\n+      // upper part\n+      while (j++ < columns) {\n+        lowerData[index]   = 0.0;\n+        upperData[index++] = work[workIndex++];\n+      }\n+    }\n+\n+    // release the memory as soon as possible\n+    work = null;\n+\n+    lower = new LowerTriangularMatrix(rows, lowerData);\n+    upper = new UpperTriangularMatrix(rows, upperData);\n+\n+  }\n+\n+  private int[]                 permutations;\n+  private boolean               evenPermutations;\n+  private LowerTriangularMatrix lower;\n+  private UpperTriangularMatrix upper;\n+\n+  private static final long serialVersionUID = -506293526695298279L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class implements lower triangular matrices of linear algebra.\n+\n+ * @version $Id: LowerTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class LowerTriangularMatrix\n+  extends SquareMatrix\n+  implements Serializable, Cloneable {\n+\n+  /** Simple constructor.\n+   * This constructor builds a lower triangular matrix of specified order, all\n+   * elements being zeros.\n+   * @param order order of the matrix\n+   */\n+  public LowerTriangularMatrix(int order) {\n+    super(order);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public LowerTriangularMatrix(int order, double[] data) {\n+    super(order, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param l lower triangular matrix to copy\n+   */\n+  public LowerTriangularMatrix(LowerTriangularMatrix l) {\n+    super(l);\n+  }\n+\n+  public Matrix duplicate() {\n+    return new LowerTriangularMatrix(this);\n+  }\n+\n+  public void setElement(int i, int j, double value) {\n+    if (i < j) {\n+      throw new ArrayIndexOutOfBoundsException(\"cannot set elements\"\n+                                               + \" above diagonal of a\"\n+                                               + \" lower triangular matrix\");\n+    }\n+    super.setElement(i, j, value);\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It does modify the instance.\n+   * @param l lower triangular matrix to add\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAdd(LowerTriangularMatrix l) {\n+\n+    // validity check\n+    if ((rows != l.rows) || (columns != l.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + l.rows + 'x' + l.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // addition loop\n+    for (int i = 0; i < rows; ++i) {\n+      for (int index = i * columns; index < i * (columns + 1) + 1; ++index) {\n+        data[index] += l.data[index];\n+      }\n+    }\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substract a matrix from the instance. It does modify the instance.\n+   * @param l lower triangular matrix to substract\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfSub(LowerTriangularMatrix l) {\n+\n+    // validity check\n+    if ((rows != l.rows) || (columns != l.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + l.rows + 'x' + l.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // substraction loop\n+    for (int i = 0; i < rows; ++i) {\n+      for (int index = i * columns; index < i * (columns + 1) + 1; ++index) {\n+        data[index] -= l.data[index];\n+      }\n+    }\n+\n+  }\n+\n+  public double getDeterminant(double epsilon) {\n+    double determinant = data[0];\n+    for (int index = columns + 1; index < columns * columns; index += columns + 1) {\n+      determinant *= data[index];\n+    }\n+    return determinant;\n+  }\n+\n+  public Matrix solve(Matrix b, double epsilon)\n+    throws SingularMatrixException {\n+    // validity check\n+    if (b.getRows () != rows) {\n+      throw new IllegalArgumentException(\"dimension mismatch\");\n+    }\n+\n+    // prepare the data storage\n+    int bRows  = b.getRows();\n+    int bCols  = b.getColumns();\n+\n+    double[] resultData = new double[bRows * bCols];\n+    int resultIndex     = 0;\n+    int lowerElements   = 0;\n+    int upperElements   = 0;\n+    int minJ            = columns;\n+    int maxJ            = 0;\n+\n+    // solve the linear system\n+    for (int i = 0; i < rows; ++i) {\n+      double diag = data[i * (columns + 1)];\n+      if (Math.abs(diag) < epsilon) {\n+        throw new SingularMatrixException();\n+      }\n+      double inv = 1.0 / diag;\n+\n+      NonNullRange range = b.getRangeForRow(i);\n+      minJ = Math.min(minJ, range.begin);\n+      maxJ = Math.max(maxJ, range.end);\n+\n+      int j = 0;\n+      while (j < minJ) {\n+        resultData[resultIndex] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+\n+      // compute the possibly non null elements\n+      int bIndex = i * bCols + minJ;\n+      while (j < maxJ) {\n+\n+        // compute the current element\n+        int index1 = i * columns;\n+        int index2 = j;\n+        double value = b.data[bIndex];\n+        while (index1 < i * (columns + 1)) {\n+          value -= data[index1] * resultData[index2];\n+          ++index1;\n+          index2 += bCols;\n+        }\n+        value *= inv;\n+        resultData[resultIndex] = value;\n+\n+        // count the affected upper and lower elements\n+        // (in order to deduce the shape of the resulting matrix)\n+        if (j < i) {\n+          ++lowerElements;\n+        } else if (i < j) {\n+          ++upperElements;\n+        }\n+\n+        ++bIndex;\n+        ++resultIndex;\n+        ++j;\n+\n+      }\n+\n+      while (j < bCols) {\n+        resultData[resultIndex] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+\n+    }\n+\n+    return MatrixFactory.buildMatrix(bRows, bCols, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  public NonNullRange getRangeForRow(int i) {\n+    return new NonNullRange(0, i + 1);\n+  }\n+\n+  public NonNullRange getRangeForColumn(int j) {\n+    return new NonNullRange(j, rows);\n+  }\n+\n+  private static final long serialVersionUID = 3592505328858227281L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class factor all services common to matrices.\n+\n+ * <p>This class is the base class of all matrix implementations, it\n+ * is also the base class of the {@link SquareMatrix} class which adds\n+ * methods specific to square matrices.</p>\n+\n+ * <p>This class both handles the storage of matrix elements and\n+ * implements the classical operations on matrices (addition,\n+ * substraction, multiplication, transposition). It relies on two\n+ * protected methods ({@link #getRangeForRow} and {@link\n+ * #getRangeForColumn}) to get tight loop bounds for matrices with\n+ * known structures full of zeros. These methods should be\n+ * implemented by derived classes to provide information about their\n+ * specific shape to the general algorithms implemented by this\n+ * abstract class.</p>\n+\n+ * @version $Id: Matrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class Matrix\n+  implements Serializable {\n+  /** Simple constructor.\n+   * Build a matrix with null elements.\n+   * @param rows number of rows of the matrix\n+   * @param columns number of columns of the matrix\n+   */\n+  protected Matrix(int rows, int columns) {\n+    // sanity check\n+    if (rows <= 0 || columns <= 0) {\n+      throw new IllegalArgumentException(\"cannot build a matrix\"\n+                                         + \" with negative or null dimension\");\n+    }\n+\n+    this.rows    = rows;\n+    this.columns = columns;\n+    data = new double[rows * columns];\n+    for (int i = 0; i < data.length; ++i) {\n+      data[i] = 0.0;\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param rows number of rows of the matrix\n+   * @param columns number of columns of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public Matrix(int rows, int columns, double[] data) {\n+    // sanity check\n+    if (rows <= 0 || columns <= 0) {\n+      throw new IllegalArgumentException(\"cannot build a matrix\"\n+                                         + \" with negative or null dimension\");\n+    }\n+\n+    this.rows    = rows;\n+    this.columns = columns;\n+    this.data    = data;\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param m matrix to copy\n+   */\n+  protected Matrix(Matrix m) {\n+    rows    = m.rows;\n+    columns = m.columns;\n+    data    = new double[rows * columns];\n+    System.arraycopy(m.data, 0, data, 0, m.data.length);\n+  }\n+\n+  /** Polymorphic copy operator.\n+   * This method build a new object of the same type of the\n+   * instance. It is somewhat similar to the {@link Object#clone}\n+   * method, except that it has public access, it doesn't throw any\n+   * specific exception and it returns a Matrix.\n+   *@see Object#clone\n+   */\n+  public abstract Matrix duplicate();\n+\n+  /** Get the number of rows of the matrix.\n+   * @return number of rows\n+   * @see #getColumns\n+   */\n+  public int getRows() {\n+    return rows;\n+  }\n+\n+  /** Get the number of columns of the matrix.\n+   * @return number of columns\n+   * @see #getRows\n+   */\n+  public int getColumns() {\n+    return columns;\n+  }\n+\n+  /** Get a matrix element.\n+   * @param i row index, from 0 to rows - 1\n+   * @param j column index, from 0 to cols - 1\n+   * @return value of the element\n+   * @exception ArrayIndexOutOfBoundsException if the indices are wrong\n+   * @see #setElement\n+   */\n+  public double getElement(int i, int j) {\n+    if (i < 0 || i >= rows || j < 0 || j >= columns) {\n+      throw new IllegalArgumentException(\"cannot get element (\"\n+                                         + i + \", \" + j + \") from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+    return data[i * columns + j];\n+  }\n+\n+  /** Set a matrix element.\n+   * @param i row index, from 0 to rows - 1\n+   * @param j column index, from 0 to cols - 1\n+   * @param value value of the element\n+   * @exception ArrayIndexOutOfBoundsException if the indices are wrong\n+   * @see #getElement\n+   */\n+  public void setElement(int i, int j, double value) {\n+    if (i < 0 || i >= rows || j < 0 || j >= columns) {\n+      throw new IllegalArgumentException(\"cannot set element (\"\n+                                         + i + \", \" + j + \") in a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+    data[i * columns + j] = value;\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It returns a new\n+   * matrix and does not modify the instance.\n+   * @param m matrix to add\n+   * @return a new matrix containing the result\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public Matrix add(Matrix m) {\n+\n+    // validity check\n+    if ((rows != m.rows) || (columns != m.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + m.rows + 'x' + m.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    double[] resultData    = new double[rows * columns];\n+    int      resultIndex   = 0;\n+    int      lowerElements = 0;\n+    int      upperElements = 0;\n+\n+    // external loop through the rows\n+    for (int i = 0; i < rows; ++i) {\n+      // compute the indices of the internal loop\n+      NonNullRange r = NonNullRange.reunion(getRangeForRow(i),\n+                                            m.getRangeForRow(i));\n+\n+      // assign the zeros before the non null range\n+      int j = 0;\n+      while (j < r.begin) {\n+        resultData[resultIndex] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+\n+      // compute the possibly non null elements\n+      while (j < r.end) {\n+\n+        // compute the current element\n+        resultData[resultIndex] = data[resultIndex] + m.data[resultIndex];\n+\n+        // count the affected upper and lower elements\n+        // (in order to deduce the shape of the resulting matrix)\n+        if (j < i) {\n+          ++lowerElements;\n+        } else if (i < j) {\n+          ++upperElements;\n+        }\n+\n+        ++resultIndex;\n+        ++j;\n+\n+      }\n+\n+      // assign the zeros after the non null range\n+      while (j < columns) {\n+        resultData[resultIndex++] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+    }\n+\n+    return MatrixFactory.buildMatrix(rows, columns, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substracts a matrix from the instance. It returns a new\n+   * matrix and does not modify the instance.\n+   * @param m matrix to substract\n+   * @return a new matrix containing the result\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public Matrix sub(Matrix m) {\n+\n+    // validity check\n+    if ((rows != m.rows) || (columns != m.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + m.rows + 'x' + m.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    double[] resultData    = new double[rows * columns];\n+    int      resultIndex   = 0;\n+    int      lowerElements = 0;\n+    int      upperElements = 0;\n+\n+    // external loop through the rows\n+    for (int i = 0; i < rows; ++i) {\n+      // compute the indices of the internal loop\n+      NonNullRange r = NonNullRange.reunion(getRangeForRow(i),\n+                                            m.getRangeForRow(i));\n+\n+      // assign the zeros before the non null range\n+      int j = 0;\n+      while (j < r.begin) {\n+        resultData[resultIndex] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+\n+      // compute the possibly non null elements\n+      while (j < r.end) {\n+\n+        // compute the current element\n+        resultData[resultIndex] = data[resultIndex] - m.data[resultIndex];\n+\n+        // count the affected upper and lower elements\n+        // (in order to deduce the shape of the resulting matrix)\n+        if (j < i) {\n+          ++lowerElements;\n+        } else if (i < j) {\n+          ++upperElements;\n+        }\n+\n+        ++resultIndex;\n+        ++j;\n+\n+      }\n+\n+      // assign the zeros after the non null range\n+      while (j < columns) {\n+        resultData[resultIndex++] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+    }\n+\n+    return MatrixFactory.buildMatrix(rows, columns, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  /** Multiply the instance by a matrix.\n+   * This method multiplies the instance by a matrix. It returns a new\n+   * matrix and does not modify the instance.\n+   * @param m matrix by which to multiply\n+   * @return a new matrix containing the result\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public Matrix mul(Matrix m) {\n+\n+    // validity check\n+    if (columns != m.rows) {\n+      throw new IllegalArgumentException(\"cannot multiply a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix by a \"\n+                                         + m.rows + 'x' + m.columns\n+                                         + \" matrix\");\n+    }\n+\n+    double[] resultData = new double[rows * m.columns];\n+    int resultIndex     = 0;\n+    int lowerElements   = 0;\n+    int upperElements   = 0;\n+\n+    for (int i = 0; i < rows; ++i) {\n+      for (int j = 0; j < m.columns; ++j) {\n+        double value = 0.0;\n+\n+        // compute the tighter possible indices of the internal loop\n+        NonNullRange r = NonNullRange.intersection(getRangeForRow(i),\n+                                                   m.getRangeForColumn(j));\n+\n+        if (r.begin < r.end) {\n+          int k    = r.begin;\n+          int idx  = i * columns + k;\n+          int midx = k * m.columns + j;\n+          while (k++ < r.end) {\n+            value += data[idx++] * m.data[midx];\n+            midx  += m.columns;\n+          }\n+\n+          // count the affected upper and lower elements\n+          // (in order to deduce the shape of the resulting matrix)\n+          if (j < i) {\n+            ++lowerElements;\n+          } else if (i < j) {\n+            ++upperElements;\n+          }\n+\n+        }\n+\n+        // store the element value\n+        resultData[resultIndex++] = value;\n+\n+      }\n+    }\n+\n+    return MatrixFactory.buildMatrix(rows, m.columns, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  /** Multiply the instance by a scalar.\n+   * This method multiplies the instance by a scalar. It returns a new\n+   * matrix and does not modify the instance.\n+   * @param a scalar by which to multiply\n+   * @return a new matrix containing the result\n+   * @see #selfMul(double)\n+   */\n+  public Matrix mul(double a) {\n+    Matrix copy = duplicate();\n+    copy.selfMul(a);\n+    return copy;\n+  }\n+\n+  /** Multiply the instance by a scalar.\n+   * This method multiplies the instance by a scalar.\n+   * It does modify the instance.\n+   * @param a scalar by which to multiply\n+   * @see #mul(double)\n+   */\n+  public void selfMul(double a) {\n+    for (int i = 0; i < rows; ++i) {\n+      NonNullRange r = getRangeForRow(i);\n+      for (int j = r.begin, index = i * columns + r.begin; j < r.end; ++j) {\n+        data[index++] *= a;\n+      }\n+    }\n+\n+  }\n+\n+  /** Compute the transpose of the instance.\n+   * This method transposes the instance. It returns a new\n+   * matrix and does not modify the instance.\n+   * @return a new matrix containing the result\n+   */\n+  public Matrix getTranspose() {\n+\n+    double[] resultData    = new double[columns * rows];\n+    int      resultIndex   = 0;\n+    int      upperElements = 0;\n+    int      lowerElements = 0;\n+\n+    for (int i = 0; i < columns; ++i) {\n+      // compute the indices of the internal loop\n+      NonNullRange range = getRangeForColumn(i);\n+\n+      int j     = 0;\n+      int index = i;\n+\n+      // assign the zeros before the non null range\n+      while (j < range.begin) {\n+        resultData[resultIndex++] = 0.0;\n+        index += columns;\n+        ++j;\n+      }\n+\n+      // compute the possibly non null elements\n+      while (j < range.end) {\n+        resultData[resultIndex] = data[index];\n+\n+        // count the affected upper and lower elements\n+        // (in order to deduce the shape of the resulting matrix)\n+        if (j < i) {\n+          ++lowerElements;\n+        } else if (i < j) {\n+          ++upperElements;\n+        }\n+\n+        index += columns;\n+        ++resultIndex;\n+        ++j;\n+\n+      }\n+\n+      // assign the zeros after the non null range\n+      while (j < rows) {\n+        resultData[resultIndex] = 0.0;\n+        ++resultIndex;\n+        ++j;\n+      }\n+\n+    }\n+\n+    return MatrixFactory.buildMatrix(columns, rows, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  /** Set a range to the non null part covered by a row.\n+   * @param i index of the row\n+   * @return range of non nul elements in the specified row\n+   * @see #getRangeForColumn\n+   */\n+  protected abstract NonNullRange getRangeForRow(int i);\n+\n+  /** Set a range to the non null part covered by a column.\n+   * @param j index of the column\n+   * @return range of non nul elements in the specified column\n+   * @see #getRangeForRow\n+   */\n+  protected abstract NonNullRange getRangeForColumn(int j);\n+\n+  public String toString() {\n+    String separator = System.getProperty(\"line.separator\");\n+\n+    StringBuffer buf = new StringBuffer();\n+    for (int index = 0; index < rows * columns; ++index) {\n+      if (index > 0) {\n+        if (index % columns == 0) {\n+          buf.append(separator);\n+        } else {\n+          buf.append(' ');\n+        }\n+      }\n+      buf.append(Double.toString(data[index]));\n+    }\n+\n+    return buf.toString();\n+\n+  }\n+\n+  /** number of rows of the matrix. */\n+  protected final int rows;\n+\n+  /** number of columns of the matrix. */\n+  protected final int columns;\n+\n+  /** array of the matrix elements.\n+   * the elements are stored in a one dimensional array, row after row\n+   */\n+  protected final double[] data;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/MatrixFactory.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+/** This class is a factory for the linear algebra package.\n+\n+ * <p>This class is devoted to building the right type of matrix\n+ * according to the structure of the non null elements.</p>\n+\n+ * <p>This is a utility class, no instance of this class should be\n+ * built, so the constructor is explicitly made private.</p>\n+\n+ * @version $Id: MatrixFactory.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MatrixFactory {\n+  /** Simple constructor.\n+   * Since the class is a utility class with only static methods, the\n+   * constructor is made private to prevent creating instances of this\n+   * class.\n+   */\n+  private MatrixFactory() {\n+  }\n+\n+  /** Build a matrix of the right subtype.\n+   * Build the right subtype of matrix according to the structure of\n+   * the non null elements of the instance. Note that the information\n+   * provided does not allow to build instances of the {@link\n+   * SymetricalMatrix} class. When the data corresponding to a\n+   * symetrical matrix is given, this method can only build an\n+   * instance of the {@link GeneralSquareMatrix} class.\n+   * @param rows number of row of the matrix\n+   * @param columns number of columns of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   * @param lowerElements number of non null elements in the lower triangle\n+   * @param upperElements number of non null elements in the upper triangle\n+   * @return a matrix containing the instance\n+   */\n+  public static Matrix buildMatrix(int rows, int columns, double[] data,\n+                                   int lowerElements, int upperElements) {\n+    if (rows == columns) {\n+      if (lowerElements == 0 && upperElements == 0) {\n+        return new DiagonalMatrix(rows, data);\n+      } else if (lowerElements == 0) {\n+        return new UpperTriangularMatrix(rows, data);\n+      } else if (upperElements == 0) {\n+        return new LowerTriangularMatrix(rows, data);\n+      } else {\n+        return new GeneralSquareMatrix(rows, data);\n+      }\n+    }\n+    return new GeneralMatrix(rows, columns, data);\n+  }\n+\n+  /** Build a matrix of the right subtype.\n+   * Build the right subtype of matrix according to the dimensions.\n+   * @param rows number of row of the matrix\n+   * @param columns number of columns of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   * @return a matrix containing the instance\n+   */\n+  public static Matrix buildMatrix(int rows, int columns, double[] data) {\n+    if (rows == columns) {\n+      return new GeneralSquareMatrix(rows, data);\n+    }\n+    return new GeneralMatrix(rows, columns, data);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class represents range of non null elements for rows or\n+ * columns of matrices.\n+\n+ * <p>This class is used to reduce the computation loops by avoiding\n+ * using elements that are known to be zeros. For full matrices, the\n+ * range simply spans from 0 to the order of the matrix. For lower and\n+ * upper triangular matrices, its width will depend on the index of\n+ * the row or column considered. For diagonal matrices, the range is\n+ * reduced to one index.</p>\n+\n+ * <p>The indices provided by the class correspond to the elements\n+ * that are non-null only according to the <emph>structure</emph> of\n+ * the matrix. The real value of the element is not\n+ * considered. Consider for example the following lower triangular\n+ * matrix :</p>\n+\n+ * <pre>\n+ *   1 0 0 0\n+ *   2 8 0 0\n+ *   0 5 3 0\n+ *   3 2 4 4\n+ * </pre>\n+\n+ * <p>The third rows begins with zero, but this is not a consequence\n+ * of the lower triangular structure, it is only a\n+ * coincidence. Therefore, the range (in row/columns count)\n+ * corresponding to third row will span from 0 to 2, not from 1 to 2.</p>\n+\n+ * @version $Id: NonNullRange.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+class NonNullRange\n+  implements Serializable, Cloneable {\n+\n+  /** Index in row/column count of the first non-null element. */\n+  public final int begin;\n+\n+  /** Index in row/column count after the last non-null element. */\n+  public final int end;\n+\n+  /** Simple constructor.\n+   * @param begin index in row/column count of the first non-null element\n+   * @param end index in row/column count after the last non-null element\n+   */\n+  public NonNullRange(int begin, int end)\n+  {\n+    this.begin = begin;\n+    this.end   = end;\n+  }\n+\n+  /** Copy constructor.\n+   * @param range range to copy.\n+   */\n+  public NonNullRange(NonNullRange range) {\n+    begin = range.begin;\n+    end   = range.end;\n+  }\n+\n+  /** Build the intersection of two ranges.\n+   * @param first first range to consider\n+   * @param second second range to consider\n+   */\n+  public static NonNullRange intersection(NonNullRange first,\n+                                          NonNullRange second) {\n+    return new NonNullRange(Math.max(first.begin, second.begin),\n+                            Math.min(first.end, second.end));\n+  }\n+\n+  /** Build the reunion of two ranges.\n+   * @param first first range to consider\n+   * @param second second range to consider\n+   */\n+  public static NonNullRange reunion(NonNullRange first,\n+                                     NonNullRange second) {\n+    return new NonNullRange(Math.min(first.begin, second.begin),\n+                            Math.max(first.end, second.end));\n+  }\n+\n+  private static final long serialVersionUID = 8175301560126132666L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SingularMatrixException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represent exceptions thrown by some matrix operations.\n+\n+ * @version $Id: SingularMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class SingularMatrixException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception with a default message\n+   */\n+  public SingularMatrixException() {\n+    super(\"singular matrix\");\n+  }\n+\n+  private static final long serialVersionUID = 7531357987468317564L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class factor all services common to square matrices of linear algebra.\n+\n+ * <p>This class is the base class of all square matrix\n+ * implementations. It extends the {@link Matrix} class with methods\n+ * specific to square matrices.</p>\n+\n+ * @version $Id: SquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class SquareMatrix\n+  extends Matrix\n+  implements Serializable, Cloneable {\n+  /** Simple constructor.\n+   * Build a matrix with null elements.\n+   * @param order order of the matrix\n+   */\n+  protected SquareMatrix(int order) {\n+    super(order, order);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  protected SquareMatrix(int order, double[] data) {\n+    super(order, order, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param m matrix to copy\n+   */\n+  protected SquareMatrix(SquareMatrix m) {\n+    super(m);\n+  }\n+\n+  /** Get the determinant of the matrix.\n+   * @param epsilon threshold on matrix elements below which the\n+   * matrix is considered singular (this is used by the derived\n+   * classes that use a factorization to compute the determinant)\n+   * @return the determinant of the matrix\n+   */\n+  public abstract double getDeterminant(double epsilon);\n+\n+  /** Invert the instance.\n+   * @param epsilon threshold on matrix elements below which the\n+   * matrix is considered singular\n+   * @return the inverse matrix of the instance\n+   * @exception SingularMatrixException if the matrix is singular\n+   */\n+  public SquareMatrix getInverse(double epsilon)\n+    throws SingularMatrixException {\n+    return solve(new DiagonalMatrix (columns), epsilon);\n+  }\n+\n+\n+  /** Solve the <tt>A.X = B</tt> equation.\n+   * @param b second term of the equation\n+   * @param epsilon threshold on matrix elements below which the\n+   * matrix is considered singular\n+   * @return a matrix X such that <tt>A.X = B</tt>, where A is the instance\n+   * @exception SingularMatrixException if the matrix is singular\n+   */\n+  public abstract Matrix solve(Matrix b, double epsilon)\n+    throws SingularMatrixException;\n+\n+  /** Solve the <tt>A.X = B</tt> equation.\n+   * @param b second term of the equation\n+   * @param epsilon threshold on matrix elements below which the\n+   * matrix is considered singular\n+   * @return a matrix X such that <tt>A.X = B</tt>, where A is the instance\n+   * @exception SingularMatrixException if the matrix is singular\n+   */\n+  public SquareMatrix solve(SquareMatrix b, double epsilon)\n+    throws SingularMatrixException {\n+    return (SquareMatrix) solve((Matrix) b, epsilon);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class implements symetrical matrices of linear algebra.\n+\n+ * @version $Id: SymetricalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class SymetricalMatrix\n+  extends GeneralSquareMatrix\n+  implements Serializable, Cloneable {\n+\n+  /** Simple constructor.\n+   * This constructor builds a symetrical matrix of specified order, all\n+   * elements beeing zeros.\n+   * @param order order of the matrix\n+   */\n+  public SymetricalMatrix(int order) {\n+    super(order);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public SymetricalMatrix(int order, double[] data) {\n+    super(order, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param s square matrix to copy\n+   */\n+  public SymetricalMatrix(SymetricalMatrix s) {\n+    super(s);\n+  }\n+\n+  /** Build the symetrical matrix resulting from the product w.A.At.\n+   * @param w multiplicative factor (weight)\n+   * @param a base vector used to compute the symetrical contribution\n+   */\n+  public SymetricalMatrix(double w, double[] a) {\n+    super(a.length, new double[a.length * a.length]);\n+\n+    for (int i = 0; i < a.length; ++i) {\n+      int indexU = i * (columns + 1);\n+      int indexL = indexU;\n+\n+      double factor = w * a[i];\n+      data[indexU] = factor * a[i];\n+\n+      for (int j = i + 1; j < columns; ++j) {\n+        ++indexU;\n+        indexL += columns;\n+        data[indexU] = factor * a[j];\n+        data[indexL] = data[indexU];\n+      }\n+    }\n+\n+  }\n+\n+  public Matrix duplicate() {\n+    return new SymetricalMatrix(this);\n+  }\n+\n+  /** Set a matrix element.\n+   * On symetrical matrices, setting separately elements outside of\n+   * the diagonal is forbidden, so this method throws an\n+   * ArrayIndexOutOfBoundsException in this case. The {@link\n+   * #setElementAndSymetricalElement} can be used to set both elements\n+   * simultaneously.\n+   * @param i row index, from 0 to rows - 1\n+   * @param j column index, from 0 to cols - 1\n+   * @param value value of the element\n+   * @exception ArrayIndexOutOfBoundsException if the indices are wrong\n+   * @see #setElementAndSymetricalElement\n+   * @see Matrix#getElement\n+   */\n+  public void setElement(int i, int j, double value) {\n+    if (i != j) {\n+      throw new ArrayIndexOutOfBoundsException(\"cannot separately set\"\n+                                               + \" elements out of diagonal\"\n+                                               + \" in a symetrical matrix\");\n+    }\n+    super.setElement(i, j, value);\n+  }\n+\n+  /** Set both a matrix element and its symetrical element.\n+   * @param i row index of first element (column index of second\n+   * element), from 0 to order - 1\n+   * @param j column index of first element (row index of second\n+   * element), from 0 to order - 1\n+   * @param value value of the elements\n+   * @exception ArrayIndexOutOfBoundsException if the indices are wrong\n+   * @see #setElement\n+   * @see Matrix#getElement\n+   */\n+  public void setElementAndSymetricalElement(int i, int j, double value) {\n+    super.setElement(i, j, value);\n+    if (i != j) {\n+      super.setElement(j, i, value);\n+    }\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It does modify the instance.\n+   * @param s symetrical matrix to add\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAdd(SymetricalMatrix s) {\n+\n+    // validity check\n+    if ((rows != s.rows) || (columns != s.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + s.rows + 'x' + s.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // addition loop\n+    for (int i = 0; i < rows; ++i) {\n+      int indexU = i * (columns + 1);\n+      int indexL = indexU;\n+\n+      data[indexU] += s.data[indexU];\n+\n+      for (int j = i + 1; j < columns; ++j) {\n+        ++indexU;\n+        indexL += columns;\n+        data[indexU] += s.data[indexU];\n+        data[indexL]  = data[indexU];\n+      }\n+    }\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substracts a matrix from the instance. It does modify the instance.\n+   * @param s symetrical matrix to substract\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfSub(SymetricalMatrix s) {\n+\n+    // validity check\n+    if ((rows != s.rows) || (columns != s.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + s.rows + 'x' + s.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // substraction loop\n+    for (int i = 0; i < rows; ++i) {\n+      int indexU = i * (columns + 1);\n+      int indexL = indexU;\n+\n+      data[indexU] -= s.data[indexU];\n+\n+      for (int j = i + 1; j < columns; ++j) {\n+        ++indexU;\n+        indexL += columns;\n+        data[indexU] -= s.data[indexU];\n+        data[indexL] = data[indexU];\n+      }\n+    }\n+\n+  }\n+\n+  /** Add the symetrical matrix resulting from the product w.A.At to the instance.\n+   * This method can be used to build progressively the matrices of\n+   * least square problems. The instance is modified.\n+   * @param w multiplicative factor (weight)\n+   * @param a base vector used to compute the symetrical contribution\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAddWAAt(double w, double[] a) {\n+    if (rows != a.length) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + a.length + 'x' + a.length\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    for (int i = 0; i < rows; ++i) {\n+      int indexU = i * (columns + 1);\n+      int indexL = indexU;\n+\n+      double factor   = w * a[i];\n+      data[indexU] += factor * a[i];\n+\n+      for (int j = i + 1; j < columns; ++j) {\n+        ++indexU;\n+        indexL += columns;\n+        data[indexU] += factor * a[j];\n+        data[indexL]  = data[indexU];\n+      }\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -2083829252075519221L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import java.io.Serializable;\n+\n+/** This class implements upper triangular matrices of linear algebra.\n+\n+ * @version $Id: UpperTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class UpperTriangularMatrix\n+  extends SquareMatrix\n+  implements Serializable, Cloneable {\n+\n+  /** Simple constructor.\n+   * This constructor builds a upper triangular matrix of specified order, all\n+   * elements being zeros.\n+   * @param order order of the matrix\n+   */\n+  public UpperTriangularMatrix(int order) {\n+    super(order);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a matrix with specified elements.\n+   * @param order order of the matrix\n+   * @param data table of the matrix elements (stored row after row)\n+   */\n+  public UpperTriangularMatrix(int order, double[] data) {\n+    super(order, data);\n+  }\n+\n+  /** Copy constructor.\n+   * @param u upper triangular matrix to copy\n+   */\n+  public UpperTriangularMatrix(UpperTriangularMatrix u) {\n+    super(u);\n+  }\n+\n+  public Matrix duplicate() {\n+    return new UpperTriangularMatrix(this);\n+  }\n+\n+  public void setElement(int i, int j, double value) {\n+    if (i > j) {\n+      throw new ArrayIndexOutOfBoundsException(\"cannot set elements\"\n+                                               + \" below diagonal of a\"\n+                                               + \" upper triangular matrix\");\n+    }\n+    super.setElement(i, j, value);\n+  }\n+\n+  /** Add a matrix to the instance.\n+   * This method adds a matrix to the instance. It does modify the instance.\n+   * @param u upper triangular matrix to add\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfAdd(UpperTriangularMatrix u) {\n+\n+    // validity check\n+    if ((rows != u.rows) || (columns != u.columns)) {\n+      throw new IllegalArgumentException(\"cannot add a \"\n+                                         + u.rows + 'x' + u.columns\n+                                         + \" matrix to a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // addition loop\n+    for (int i = 0; i < rows; ++i) {\n+      for (int index = i * (columns + 1); index < (i + 1) * columns; ++index) {\n+        data[index] += u.data[index];\n+      }\n+    }\n+\n+  }\n+\n+  /** Substract a matrix from the instance.\n+   * This method substract a matrix from the instance. It does modify the instance.\n+   * @param u upper triangular matrix to substract\n+   * @exception IllegalArgumentException if there is a dimension mismatch\n+   */\n+  public void selfSub(UpperTriangularMatrix u) {\n+\n+    // validity check\n+    if ((rows != u.rows) || (columns != u.columns)) {\n+      throw new IllegalArgumentException(\"cannot substract a \"\n+                                         + u.rows + 'x' + u.columns\n+                                         + \" matrix from a \"\n+                                         + rows + 'x' + columns\n+                                         + \" matrix\");\n+    }\n+\n+    // substraction loop\n+    for (int i = 0; i < rows; ++i) {\n+      for (int index = i * (columns + 1); index < (i + 1) * columns; ++index) {\n+        data[index] -= u.data[index];\n+      }\n+    }\n+\n+  }\n+\n+  public double getDeterminant(double epsilon) {\n+    double determinant = data[0];\n+    for (int index = columns + 1; index < columns * columns; index += columns + 1) {\n+      determinant *= data[index];\n+    }\n+    return determinant;\n+  }\n+\n+  public Matrix solve(Matrix b, double epsilon)\n+    throws SingularMatrixException {\n+    // validity check\n+    if (b.getRows() != rows) {\n+      throw new IllegalArgumentException(\"dimension mismatch\");\n+    }\n+\n+    // prepare the data storage\n+    int bRows  = b.getRows();\n+    int bCols  = b.getColumns();\n+\n+    double[] resultData = new double[bRows * bCols];\n+    int resultIndex     = bRows * bCols - 1;\n+    int lowerElements   = 0;\n+    int upperElements   = 0;\n+    int minJ            = columns;\n+    int maxJ            = 0;\n+\n+    // solve the linear system\n+    for (int i = rows - 1; i >= 0; --i) {\n+      double diag = data[i * (columns + 1)];\n+      if (Math.abs(diag) < epsilon) {\n+        throw new SingularMatrixException();\n+      }\n+      double inv = 1.0 / diag;\n+\n+      NonNullRange range = b.getRangeForRow(i);\n+      minJ = Math.min(minJ, range.begin);\n+      maxJ = Math.max(maxJ, range.end);\n+\n+      int j = bCols - 1;\n+      while (j >= maxJ) {\n+        resultData[resultIndex] = 0.0;\n+        --resultIndex;\n+        --j;\n+      }\n+\n+      // compute the possibly non null elements\n+      int bIndex = i * bCols + maxJ - 1;\n+      while (j >= minJ) {\n+\n+        // compute the current element\n+        int index1 = (i + 1) * columns - 1;\n+        int index2 = (bRows - 1) * bCols + j;\n+        double value = b.data[bIndex];\n+        while (index1 >= i * (columns + 1)) {\n+          value -= data[index1] * resultData[index2];\n+          --index1;\n+          index2 -= bCols;\n+        }\n+        value *= inv;\n+        resultData[resultIndex] = value;\n+\n+        // count the affected upper and lower elements\n+        // (in order to deduce the shape of the resulting matrix)\n+        if (j < i) {\n+          ++lowerElements;\n+        } else if (i < j) {\n+          ++upperElements;\n+        }\n+\n+        --bIndex;\n+        --resultIndex;\n+        --j;\n+\n+      }\n+\n+      while (j >= 0) {\n+        resultData[resultIndex] = 0.0;\n+        --resultIndex;\n+        --j;\n+      }\n+\n+    }\n+\n+    return MatrixFactory.buildMatrix(bRows, bCols, resultData,\n+                                     lowerElements, upperElements);\n+\n+  }\n+\n+  public NonNullRange getRangeForRow(int i) {\n+    return new NonNullRange (i, columns);\n+  }\n+\n+  public NonNullRange getRangeForColumn(int j) {\n+    return new NonNullRange (0, j + 1);\n+  }\n+\n+  private static final long serialVersionUID = -197266611942032237L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/AbstractStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This abstract class represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects extending this class\n+ * to the step handlers. The handlers can use these objects to\n+ * retrieve the state vector at intermediate times between the\n+ * previous and the current grid points (dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Id: AbstractStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public abstract class AbstractStepInterpolator\n+  implements StepInterpolator, Cloneable {\n+\n+  /** previous time */\n+  protected double previousTime;\n+\n+  /** current time */\n+  protected double currentTime;\n+\n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** indicate if the step has been finalized or not. */\n+  private boolean finalized;\n+\n+  /** integration direction. */\n+  private boolean forward;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected AbstractStepInterpolator() {\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+    currentState      = null;\n+    interpolatedState = null;\n+    finalized         = false;\n+    this.forward      = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(double[] y, boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any derivative computation and will throw a {@link\n+   * NullPointerException} later. Since we don't want this constructor\n+   * to throw the exceptions finalization may involve and since we\n+   * don't want this method to modify the state of the copied\n+   * interpolator, finalization is <strong>not</strong> done\n+   * automatically, it remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {\n+\n+    previousTime      = interpolator.previousTime;\n+    currentTime       = interpolator.currentTime;\n+    h                 = interpolator.h;\n+    interpolatedTime  = interpolator.interpolatedTime;\n+\n+    if (interpolator.currentState != null) {\n+      int dimension = interpolator.currentState.length;\n+\n+      currentState = new double[dimension];\n+      System.arraycopy(interpolator.currentState, 0, currentState, 0,\n+                       dimension);\n+\n+      interpolatedState = new double[dimension];\n+      System.arraycopy(interpolator.interpolatedState, 0, interpolatedState, 0,\n+                       dimension);\n+    } else {\n+      currentState      = null;\n+      interpolatedState = null;\n+    }\n+\n+    finalized = interpolator.finalized;\n+    forward   = interpolator.forward;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected void reinitialize(double[] y, boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy the instance.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * <p>This method has been redeclared as public instead of protected.</p>\n+\n+  * @return a copy of the instance.\n+\n+  */\n+  public abstract Object clone();\n+\n+  /** Shift one step forward.\n+   * Copy the current time into the previous time, hence preparing the\n+   * interpolator for future calls to {@link #storeTime storeTime}\n+   */\n+  public void shift() {\n+    previousTime = currentTime;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+\n+    currentTime      = t;\n+    h                = currentTime - previousTime;\n+    interpolatedTime = t;\n+    System.arraycopy(currentState, 0, interpolatedState, 0,\n+                     currentState.length);\n+\n+    // the step is not finalized anymore\n+    finalized = false;\n+\n+  }\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime() {\n+    return previousTime;\n+  }\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime() {\n+    return currentTime;\n+  }\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return interpolatedTime;\n+  }\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed\n+   * (it was not allowed up to version 5.4 of Mantissa), but should be\n+   * used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException {\n+    interpolatedTime = time;\n+    double oneMinusThetaH = currentTime - interpolatedTime;\n+    computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);\n+  }\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by the\n+   * integrator itself, it avoid some nasty problems in degenerated\n+   * cases like null steps due to cancellation at step initialization,\n+   * step control or switching function triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward() {\n+    return forward;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected abstract void computeInterpolatedState(double theta,\n+                                                   double oneMinusThetaH)\n+    throws DerivativeException;\n+    \n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState() {\n+    return interpolatedState;\n+  }\n+\n+\n+  /**\n+   * Finalize the step.\n+\n+   * <p>Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. These\n+   * interpolators should perform the last evaluations they need by\n+   * themselves only if they need them. This method triggers these\n+   * extra evaluations. It can be called directly by the user step\n+   * handler and it is called automatically if {@link\n+   * #setInterpolatedTime} is called.</p>\n+\n+   * <p>Once this method has been called, <strong>no</strong> other\n+   * evaluation will be performed on this step. If there is a need to\n+   * have some side effects between the step handler and the\n+   * differential equations (for example update some data in the\n+   * equations once the step has been done), it is advised to call\n+   * this method explicitly from the step handler before these side\n+   * effects are set up. If the step handler induces no side effect,\n+   * then this method can safely be ignored, it will be called\n+   * transparently as needed.</p>\n+\n+   * <p><strong>Warning</strong>: since the step interpolator provided\n+   * to the step handler as a parameter of the {@link\n+   * StepHandler#handleStep handleStep} is valid only for the duration\n+   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n+   * simply store a reference and reuse it later. One should first\n+   * finalize the instance, then copy this finalized instance into a\n+   * new object that can be kept.</p>\n+\n+   * <p>This method calls the protected {@link #doFinalize doFinalize}\n+   * method if it has never been called during this step and set a\n+   * flag indicating that it has been called once. It is the {@link\n+   * #doFinalize doFinalize} method which should perform the\n+   * evaluations. This wrapping prevents from calling {@link\n+   * #doFinalize doFinalize} several times and hence evaluating the\n+   * differential equations too often. Therefore, subclasses are not\n+   * allowed not reimplement it, they should rather reimplement {@link\n+   * #doFinalize doFinalize}.</p>\n+\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+\n+   */\n+  public final void finalizeStep()\n+    throws DerivativeException {\n+    if (! finalized) {\n+      doFinalize();\n+      finalized = true;\n+    }\n+  }\n+\n+  /**\n+   * Really finalize the step.\n+   * The default implementation of this method does nothing.\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+  }\n+\n+  public abstract void writeExternal(ObjectOutput out)\n+    throws IOException;\n+\n+  public abstract void readExternal(ObjectInput in)\n+    throws IOException;\n+\n+  /** Save the base state of the instance.\n+   * This method performs step finalization if it has not been done\n+   * before.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  protected void writeBaseExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    out.writeInt(currentState.length);\n+    out.writeDouble(previousTime);\n+    out.writeDouble(currentTime);\n+    out.writeDouble(h);\n+    out.writeBoolean(forward);\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(currentState[i]);\n+    }\n+\n+    out.writeDouble(interpolatedTime);\n+\n+    // we do not store the interpolated state,\n+    // it will be recomputed as needed after reading\n+\n+    // finalize the step (and don't bother saving the now true flag)\n+    try {\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      IOException ioe = new IOException();\n+      ioe.initCause(e);\n+      throw ioe;\n+    }\n+\n+  }\n+\n+  /** Read the base state of the instance.\n+   * This method does <strong>neither</strong> set the interpolated\n+   * time nor state. It is up to the derived class to reset it\n+   * properly calling the {@link #setInterpolatedTime} method later,\n+   * once all rest of the object state has been set up properly.\n+   * @param in stream where to read the state from\n+   * @return interpolated time be set later by the caller\n+   * @exception IOException in case of read error\n+   */\n+  protected double readBaseExternal(ObjectInput in)\n+    throws IOException {\n+\n+    int dimension = in.readInt();\n+    previousTime  = in.readDouble();\n+    currentTime   = in.readDouble();\n+    h             = in.readDouble();\n+    forward       = in.readBoolean();\n+\n+    currentState  = new double[dimension];\n+    for (int i = 0; i < currentState.length; ++i) {\n+      currentState[i] = in.readDouble();\n+    }\n+\n+    // we do NOT handle the interpolated time and state here\n+    interpolatedTime  = Double.NaN;\n+    interpolatedState = new double[dimension];\n+\n+    finalized = true;\n+\n+    return in.readDouble();\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/AdaptiveStepsizeIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This abstract class holds the common part of all adaptive\n+ * stepsize integrators for Ordinary Differential Equations.\n+\n+ * <p>These algorithms perform integration with stepsize control, which\n+ * means the user does not specify the integration step but rather a\n+ * tolerance on error. The error threshold is computed as\n+ * <pre>\n+ * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))\n+ * </pre>\n+ * where absTol_i is the absolute tolerance for component i of the\n+ * state vector and relTol_i is the relative tolerance for the same\n+ * component. The user can also use only two scalar values absTol and\n+ * relTol which will be used for all components.</p>\n+\n+ * <p>If the estimated error for ym+1 is such that\n+ * <pre>\n+ * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n+ * </pre>\n+\n+ * (where n is the state vector dimension) then the step is accepted,\n+ * otherwise the step is rejected and a new attempt is made with a new\n+ * stepsize.</p>\n+\n+ * @version $Id: AdaptiveStepsizeIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class AdaptiveStepsizeIntegrator\n+  implements FirstOrderIntegrator {\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n+                                    double scalAbsoluteTolerance,\n+                                    double scalRelativeTolerance) {\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n+    this.scalRelativeTolerance = scalRelativeTolerance;\n+    this.vecAbsoluteTolerance  = null;\n+    this.vecRelativeTolerance  = null;\n+\n+    // set the default step handler\n+    handler = DummyStepHandler.getInstance();\n+\n+    switchesHandler = new SwitchingFunctionsHandler();\n+\n+  }\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n+                                    double[] vecAbsoluteTolerance,\n+                                    double[] vecRelativeTolerance) {\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = 0;\n+    this.scalRelativeTolerance = 0;\n+    this.vecAbsoluteTolerance  = vecAbsoluteTolerance;\n+    this.vecRelativeTolerance  = vecRelativeTolerance;\n+\n+    // set the default step handler\n+    handler = DummyStepHandler.getInstance();\n+\n+    switchesHandler = new SwitchingFunctionsHandler();\n+\n+  }\n+\n+  /** Set the initial step size.\n+   * <p>This method allows the user to specify an initial positive\n+   * step size instead of letting the integrator guess it by\n+   * itself. If this method is not called before integration is\n+   * started, the initial step size will be estimated by the\n+   * integrator.</p>\n+   * @param initialStepSize initial step size to use (must be positive even\n+   * for backward integration ; providing a negative value or a value\n+   * outside of the min/max step interval will lead the integrator to\n+   * ignore the value and compute the initial step size by itself)\n+   */\n+  public void setInitialStepSize(double initialStepSize) {\n+    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+      initialStep = -1.0;\n+    } else {\n+      initialStep = initialStepSize;\n+    }\n+  }\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+    this.handler = handler;\n+  }\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler() {\n+    return handler;\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    switchesHandler.add(function, maxCheckInterval, convergence);\n+  }\n+\n+  /** Initialize the integration step.\n+   * @param equations differential equations set\n+   * @param forward forward integration indicator\n+   * @param order order of the method\n+   * @param scale scaling vector for the state vector\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param yDot0 first time derivative of y0\n+   * @param y1 work array for a state vector\n+   * @param yDot1 work array for the first time derivative of y1\n+   * @return first integration step\n+   * @exception DerivativeException this exception is propagated to\n+   * the caller if the underlying user function triggers one\n+   */\n+  public double initializeStep(FirstOrderDifferentialEquations equations,\n+                               boolean forward, int order, double[] scale,\n+                               double t0, double[] y0, double[] yDot0,\n+                               double[] y1, double[] yDot1)\n+    throws DerivativeException {\n+\n+    if (initialStep > 0) {\n+      // use the user provided value\n+      return forward ? initialStep : -initialStep;\n+    }\n+\n+    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n+    // this guess will be used to perform an Euler step\n+    double ratio;\n+    double yOnScale2 = 0;\n+    double yDotOnScale2 = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = y0[j] / scale[j];\n+      yOnScale2    += ratio * ratio;\n+      ratio         = yDot0[j] / scale[j];\n+      yDotOnScale2 += ratio * ratio;\n+    }\n+\n+    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))\n+      ? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    // perform an Euler step using the preceding rough guess\n+    for (int j = 0; j < y0.length; ++j) {\n+      y1[j] = y0[j] + h * yDot0[j];\n+    }\n+    equations.computeDerivatives(t0 + h, y1, yDot1);\n+\n+    // estimate the second derivative of the solution\n+    double yDDotOnScale = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n+      yDDotOnScale += ratio * ratio;\n+    }\n+    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+\n+    // step size is computed such that\n+    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n+    double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    double h1 = (maxInv2 < 1.0e-15)\n+      ? Math.max(1.0e-6, 0.001 * Math.abs(h))\n+      : Math.pow(0.01 / maxInv2, 1.0 / order);\n+    h = Math.min(100.0 * Math.abs(h), h1);\n+    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+    if (h < getMinStep()) {\n+      h = getMinStep();\n+    }\n+    if (h > getMaxStep()) {\n+      h = getMaxStep();\n+    }\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  /** Filter the integration step.\n+   * @param h signed step\n+   * @param acceptSmall if true, steps smaller than the minimal value\n+   * are silently increased up to this value, if false such small\n+   * steps generate an exception\n+   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n+   * @exception IntegratorException if the step is too small and acceptSmall is false\n+   */\n+  protected double filterStep(double h, boolean acceptSmall)\n+    throws IntegratorException {\n+\n+    if (Math.abs(h) < minStep) {\n+      if (acceptSmall) {\n+        h = (h < 0) ? -minStep : minStep;\n+      } else {\n+        throw new IntegratorException(\"minimal step size ({0}) reached,\"\n+                                      + \" integration needs {1}\",\n+                                      new String[] {\n+                                        Double.toString(minStep),\n+                                        Double.toString(Math.abs(h))\n+                                      });\n+      }\n+    }\n+\n+    if (h > maxStep) {\n+      h = maxStep;\n+    } else if (h < -maxStep) {\n+      h = -maxStep;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  public abstract void integrate (FirstOrderDifferentialEquations equations,\n+                                  double t0, double[] y0,\n+                                  double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+  /** Get the minimal step.\n+   * @return minimal step\n+   */\n+  public double getMinStep() {\n+    return minStep;\n+  }\n+\n+  /** Get the maximal step.\n+   * @return maximal step\n+   */\n+  public double getMaxStep() {\n+    return maxStep;\n+  }\n+\n+  /** Minimal step. */\n+  private double minStep;\n+\n+  /** Maximal step. */\n+  private double maxStep;\n+\n+  /** User supplied initial step. */\n+  private double initialStep;\n+\n+  /** Allowed absolute scalar error. */\n+  protected double scalAbsoluteTolerance;\n+\n+  /** Allowed relative scalar error. */\n+  protected double scalRelativeTolerance;\n+\n+  /** Allowed absolute vectorial error. */\n+  protected double[] vecAbsoluteTolerance;\n+\n+  /** Allowed relative vectorial error. */\n+  protected double[] vecRelativeTolerance;\n+\n+  /** Step handler. */\n+  protected StepHandler handler;\n+\n+  /** Switching functions handler. */\n+  protected SwitchingFunctionsHandler switchesHandler;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the classical fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations (it is the most\n+ * often used Runge-Kutta method).\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/2 | 1/2   0    0    0\n+ *   1/2 |  0   1/2   0    0\n+ *    1  |  0    0    1    0\n+ *       |--------------------\n+ *       | 1/6  1/3  1/3  1/6\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: ClassicalRungeKuttaIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ClassicalRungeKuttaIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = new String(\"classical Runge-Kutta\");\n+\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { 0.0, 1.0 / 2.0 },\n+    { 0.0, 0.0, 1.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Runge-Kutta integrator with the given\n+   * step.\n+   * @param step integration step\n+   */\n+  public ClassicalRungeKuttaIntegrator(double step) {\n+    super(false, c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a step interpolator for the classical fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n+ *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n+ *                                          -(4 theta^2 +   theta + 1) y'_4\n+ *                                        ]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see ClassicalRungeKuttaIntegrator\n+\n+ * @version $Id: ClassicalRungeKuttaStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class ClassicalRungeKuttaStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link RungeKuttaStepInterpolator#reinitialize} method should be\n+   * called before using the instance in order to initialize the\n+   * internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. The {@link RungeKuttaIntegrator}\n+   * class uses the prototyping design pattern to create the step\n+   * interpolators by cloning an uninitialized model and latter initializing\n+   * the copy.\n+   */\n+  public ClassicalRungeKuttaStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new ClassicalRungeKuttaStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta = 4 * theta;\n+    double s         = oneMinusThetaH / 6.0;\n+    double coeff1    = s * ((-fourTheta + 5) * theta - 1);\n+    double coeff23   = s * (( fourTheta - 2) * theta - 2);\n+    double coeff4    = s * ((-fourTheta - 1) * theta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            + coeff1  * yDotK[0][i]\n+                            + coeff23 * (yDotK[1][i] + yDotK[2][i])\n+                            + coeff4  * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  private static final long serialVersionUID = -6576285612589783992L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ContinuousOutputModel.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.io.Serializable;\n+\n+/**\n+ * This class stores all information provided by an ODE integrator\n+ * during the integration process and build a continuous model of the\n+ * solution from this.\n+\n+ * <p>This class act as a step handler from the integrator point of\n+ * view. It is called iteratively during the integration process and\n+ * stores a copy of all steps information in a sorted collection for\n+ * later use. Once the integration process is over, the user can use\n+ * the {@link #setInterpolatedTime setInterpolatedTime} and {@link\n+ * #getInterpolatedState getInterpolatedState} to retrieve this\n+ * information at any time. It is important to wait for the\n+ * integration to be over before attempting to call {@link\n+ * #setInterpolatedTime setInterpolatedTime} because some internal\n+ * variables are set only once the last step has been handled.</p>\n+\n+ * <p>This is useful for example if the main loop of the user\n+ * application should remain independant from the integration process\n+ * or if one needs to mimic the behaviour of an analytical model\n+ * despite a numerical model is used (i.e. one needs the ability to\n+ * get the model value at any time or to navigate through the\n+ * data).</p>\n+\n+ * <p>If problem modelization is done with several separate\n+ * integration phases for contiguous intervals, the same\n+ * ContinuousOutputModel can be used as step handler for all\n+ * integration phases as long as they are performed in order and in\n+ * the same direction. As an example, one can extrapolate the\n+ * trajectory of a satellite with one model (i.e. one set of\n+ * differential equations) up to the beginning of a maneuver, use\n+ * another more complex model including thrusters modelization and\n+ * accurate attitude control during the maneuver, and revert to the\n+ * first model after the end of the maneuver. If the same continuous\n+ * output model handles the steps of all integration phases, the user\n+ * do not need to bother when the maneuver begins or ends, he has all\n+ * the data available in a transparent manner.</p>\n+\n+ * <p>An important feature of this class is that it implements the\n+ * <code>Serializable</code> interface. This means that the result of\n+ * an integration can be serialized and reused later (if stored into a\n+ * persistent medium like a filesystem or a database) or elsewhere (if\n+ * sent to another application). Only the result of the integration is\n+ * stored, there is no reference to the integrated problem by\n+ * itself.</p>\n+\n+ * <p>One should be aware that the amount of data stored in a\n+ * ContinuousOutputModel instance can be important if the state vector\n+ * is large, if the integration interval is long or if the steps are\n+ * small (which can result from small tolerance settings in {@link\n+ * AdaptiveStepsizeIntegrator adaptive step size integrators}).</p>\n+\n+ * @see StepHandler\n+ * @see StepInterpolator\n+\n+ * @version $Id: ContinuousOutputModel.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ContinuousOutputModel\n+  implements StepHandler, Serializable {\n+\n+  /** Simple constructor.\n+   * Build an empty continuous output model.\n+   */\n+  public ContinuousOutputModel() {\n+    steps = new ArrayList();\n+    reset();\n+  }\n+\n+  /** Append another model at the end of the instance.\n+   * @param model model to add at the end of the instance\n+   * @exception IllegalArgumentException if the model to append is not\n+   * compatible with the instance (dimension of the state vector,\n+   * propagation direction, hole between the dates)\n+   */\n+  public void append(ContinuousOutputModel model) {\n+\n+    if (model.steps.size() == 0) {\n+      return;\n+    }\n+\n+    if (steps.size() == 0) {\n+      initialTime = model.initialTime;\n+      forward     = model.forward;\n+    } else {\n+\n+      if (getInterpolatedState().length != model.getInterpolatedState().length) {\n+        throw new IllegalArgumentException(\"state vector dimension mismatch\");\n+      }\n+\n+      if (forward ^ model.forward) {\n+        throw new IllegalArgumentException(\"propagation direction mismatch\");\n+      }\n+\n+      StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n+      double current  = lastInterpolator.getCurrentTime();\n+      double previous = lastInterpolator.getPreviousTime();\n+      double step = current - previous;\n+      double gap = model.getInitialTime() - current;\n+      if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n+        throw new IllegalArgumentException(\"hole between time ranges\");\n+      }\n+\n+    }\n+\n+    for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {\n+      AbstractStepInterpolator ai = (AbstractStepInterpolator) iter.next();\n+      steps.add(ai.clone());\n+    }\n+\n+    index = steps.size() - 1;\n+    finalTime = ((StepInterpolator) steps.get(index)).getCurrentTime();\n+\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>The essence of this class is to provide dense output over all\n+   * steps, hence it requires the internal steps to provide themselves\n+   * dense output. The method therefore returns always true.</p>\n+   * @return always true\n+   */\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+    initialTime = Double.NaN;\n+    finalTime   = Double.NaN;\n+    forward     = true;\n+    index       = 0;\n+    steps.clear();\n+   }\n+\n+  /** Handle the last accepted step.\n+   * A copy of the information provided by the last step is stored in\n+   * the instance for later use.\n+   * @param interpolator interpolator for the last accepted step.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException {\n+\n+    AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;\n+\n+    if (steps.size() == 0) {\n+      initialTime = interpolator.getPreviousTime();\n+      forward     = interpolator.isForward();\n+    }\n+\n+    ai.finalizeStep();\n+    steps.add(ai.clone());\n+\n+    if (isLast) {\n+      finalTime = ai.getCurrentTime();\n+      index     = steps.size() - 1;\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the initial integration time.\n+   * @return initial integration time\n+   */\n+  public double getInitialTime() {\n+    return initialTime;\n+  }\n+    \n+  /**\n+   * Get the final integration time.\n+   * @return final integration time\n+   */\n+  public double getFinalTime() {\n+    return finalTime;\n+  }\n+\n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the final integration time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return ((StepInterpolator) steps.get(index)).getInterpolatedTime();\n+  }\n+    \n+  /** Set the time of the interpolated point.\n+   * <p>This method should <strong>not</strong> be called before the\n+   * integration is over because some internal variables are set only\n+   * once the last step has been handled.</p>\n+   * <p>Setting the time outside of the integration interval is now\n+   * allowed (it was not allowed up to version 5.9 of Mantissa), but\n+   * should be used with care since the accuracy of the interpolator\n+   * will probably be very poor far from this interval. This allowance\n+   * has been added to simplify implementation of search algorithms\n+   * near the interval endpoints.</p>\n+   * @param time time of the interpolated point\n+   */\n+  public void setInterpolatedTime(double time) {\n+\n+    try {\n+      // initialize the search with the complete steps table\n+      int iMin = 0;\n+      StepInterpolator sMin = (StepInterpolator) steps.get(iMin);\n+      double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n+\n+      int iMax = steps.size() - 1;\n+      StepInterpolator sMax = (StepInterpolator) steps.get(iMax);\n+      double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n+\n+      // handle points outside of the integration interval\n+      // or in the first and last step\n+      if (locatePoint(time, sMin) <= 0) {\n+        index = iMin;\n+        sMin.setInterpolatedTime(time);\n+        return;\n+      }\n+      if (locatePoint(time, sMax) >= 0) {\n+        index = iMax;\n+        sMax.setInterpolatedTime(time);\n+        return;\n+      }\n+\n+      // reduction of the table slice size\n+      while (iMax - iMin > 5) {\n+\n+        // use the last estimated index as the splitting index\n+        StepInterpolator si = (StepInterpolator) steps.get(index);\n+        int location = locatePoint(time, si);\n+        if (location < 0) {\n+          iMax = index;\n+          tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else if (location > 0) {\n+          iMin = index;\n+          tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else {\n+          // we have found the target step, no need to continue searching\n+          si.setInterpolatedTime(time);\n+          return;\n+        }\n+\n+        // compute a new estimate of the index in the reduced table slice\n+        int iMed = (iMin + iMax) / 2;\n+        StepInterpolator sMed = (StepInterpolator) steps.get(iMed);\n+        double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n+\n+        if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n+          // too close to the bounds, we estimate using a simple dichotomy\n+          index = iMed;\n+        } else {\n+          // estimate the index using a reverse quadratic polynom\n+          // (reverse means we have i = P(t), thus allowing to simply\n+          // compute index = P(time) rather than solving a quadratic equation)\n+          double d12 = tMax - tMed;\n+          double d23 = tMed - tMin;\n+          double d13 = tMax - tMin;\n+          double dt1 = time - tMax;\n+          double dt2 = time - tMed;\n+          double dt3 = time - tMin;\n+          double iLagrange = (  (dt2 * dt3 * d23) * iMax\n+                              - (dt1 * dt3 * d13) * iMed\n+                              + (dt1 * dt2 * d12) * iMin)\n+                           / (d12 * d23 * d13);\n+          index = (int) Math.rint(iLagrange);\n+        }\n+\n+        // force the next size reduction to be at least one tenth\n+        int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        if (index < low) {\n+          index = low;\n+        } else if (index > high) {\n+          index = high;\n+        }\n+\n+      }\n+\n+      // now the table slice is very small, we perform an iterative search\n+      index = iMin;\n+      while ((index <= iMax)\n+             && (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n+        ++index;\n+      }\n+\n+      StepInterpolator si = (StepInterpolator) steps.get(index);\n+\n+      si.setInterpolatedTime(time);\n+\n+    } catch (DerivativeException de) {\n+      throw new RuntimeException(\"unexpected DerivativeException caught\", de);\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState() {\n+    return ((StepInterpolator) steps.get(index)).getInterpolatedState();\n+  }\n+\n+  /** Compare a step interval and a double. \n+   * @param time point to locate\n+   * @param interval step interval\n+   * @return -1 if the double is before the interval, 0 if it is in\n+   * the interval, and +1 if it is after the interval, according to\n+   * the interval direction\n+   */\n+  private int locatePoint(double time, StepInterpolator interval) {\n+    if (forward) {\n+      if (time < interval.getPreviousTime()) {\n+        return -1;\n+      } else if (time > interval.getCurrentTime()) {\n+        return +1;\n+      } else {\n+        return 0;\n+      }\n+    }\n+    if (time > interval.getPreviousTime()) {\n+      return -1;\n+    } else if (time < interval.getCurrentTime()) {\n+      return +1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  /** Initial integration time. */\n+  private double initialTime;\n+\n+  /** Final integration time. */\n+  private double finalTime;\n+\n+  /** Integration direction indicator. */\n+  private boolean forward;\n+\n+  /** Current interpolator index. */\n+  private int index;\n+\n+  /** Steps table. */\n+  private ArrayList steps;\n+\n+  private static final long serialVersionUID = 2259286184268533249L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DerivativeException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are trigegred while computing\n+ * the differential equations.\n+ * @author Luc Maisonobe\n+ * @version $Id: DerivativeException.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class DerivativeException\n+  extends MantissaException {\n+    \n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public DerivativeException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Build an instance from an underlying cause.\n+   * @param cause cause for the exception\n+   */\n+  public DerivativeException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  private static final long serialVersionUID = -4100440615830558122L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step. However, since this\n+ * is an <i>fsal</i>, the last evaluation of one step is the same as\n+ * the first evaluation of the next step and hence can be avoided. So\n+ * the cost is really 6 functions evaluations per step.</p>\n+\n+ * <p>This method has been published (whithout the continuous output\n+ * that was added by Shampine in 1986) in the following article :\n+ * <pre>\n+ *  A family of embedded Runge-Kutta formulae\n+ *  J. R. Dormand and P. J. Prince\n+ *  Journal of Computational and Applied Mathematics\n+ *  volume 6, no 1, 1980, pp. 19-26\n+ * </pre></p>\n+\n+ * @version $Id: DormandPrince54Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DormandPrince54Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = new String(\"Dormand-Prince 5(4)\");\n+\n+  private static final double[] c = {\n+    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {1.0/5.0},\n+    {3.0/40.0, 9.0/40.0},\n+    {44.0/45.0, -56.0/15.0, 32.0/9.0},\n+    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0,  -212.0/729.0},\n+    {9017.0/3168.0, -355.0/33.0, 46732.0/5247.0, 49.0/176.0, -5103.0/18656.0},\n+    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n+  };\n+\n+  private static final double[] b = {\n+    35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n+  };\n+\n+  private static final double e1 =     71.0 / 57600.0;\n+  private static final double e3 =    -71.0 / 16695.0;\n+  private static final double e4 =     71.0 / 1920.0;\n+  private static final double e5 = -17253.0 / 339200.0;\n+  private static final double e6 =     22.0 / 525.0;\n+  private static final double e7 =     -1.0 / 40.0;\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(double minStep, double maxStep,\n+                                   double scalAbsoluteTolerance,\n+                                   double scalRelativeTolerance) {\n+    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(double minStep, double maxStep,\n+                                   double[] vecAbsoluteTolerance,\n+                                   double[] vecRelativeTolerance) {\n+    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j]\n+                    + e4 * yDotK[3][j] +  e5 * yDotK[4][j]\n+                    + e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince54Integrator\n+ *\n+ * @version $Id: DormandPrince54StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class DormandPrince54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince54StepInterpolator() {\n+    super();\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.v1 == null) {\n+\n+      v1 = null;\n+      v2 = null;\n+      v3 = null;\n+      v4 = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      int dimension = interpolator.v1.length;\n+\n+      v1 = new double[dimension];\n+      v2 = new double[dimension];\n+      v3 = new double[dimension];\n+      v4 = new double[dimension];\n+\n+      System.arraycopy(interpolator.v1, 0, v1, 0, dimension);\n+      System.arraycopy(interpolator.v2, 0, v2, 0, dimension);\n+      System.arraycopy(interpolator.v3, 0, v3, 0, dimension);\n+      System.arraycopy(interpolator.v4, 0, v4, 0, dimension);\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new DormandPrince54StepInterpolator(this);\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+    super.reinitialize(equations, y, yDotK, forward);\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v1 == null) {\n+        v1 = new double[interpolatedState.length];\n+        v2 = new double[interpolatedState.length];\n+        v3 = new double[interpolatedState.length];\n+        v4 = new double[interpolatedState.length];\n+      }\n+\n+      // no step finalization is needed for this interpolator\n+\n+      // we need to compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i]\n+                     + a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n+        v2[i] = h * yDotK[0][i] - v1[i];\n+        v3[i] = v1[i] - v2[i] - h * yDotK[6][i];\n+        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i]\n+                     + d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    // interpolate\n+    double eta = oneMinusThetaH / h;\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           - eta * (v1[i]\n+                                    - theta * (v2[i]\n+                                               + theta * (v3[i]\n+                                                          + eta * v4[i])));\n+    }\n+\n+  }\n+\n+  /** First vector for interpolation. */\n+  private double[] v1;\n+\n+  /** Second vector for interpolation. */\n+  private double[] v2;\n+\n+  /** Third vector for interpolation. */\n+  private double[] v3;\n+\n+  /** Fourth vector for interpolation. */\n+  private double[] v4;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  // last row of the Butcher-array internal weights, note that a71 is null\n+  private static final double a70 =    35.0 /  384.0;\n+  private static final double a72 =   500.0 / 1113.0;\n+  private static final double a73 =   125.0 /  192.0;\n+  private static final double a74 = -2187.0 / 6784.0;\n+  private static final double a75 =    11.0 /   84.0;\n+\n+  // dense output of Shampine (1986), note that d1 is null\n+  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+  private static final double d2 =   87487479700.0 /  32700410799.0;\n+  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+  private static final double d4 =  701980252875.0 / 199316789632.0;\n+  private static final double d5 =   -1453857185.0 /    822651844.0;\n+  private static final double d6 =      69997945.0 /     29380423.0;\n+\n+  private static final long serialVersionUID = 4104157279605906956L;\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince853Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 12 functions evaluations per step for integration and 4\n+ * evaluations for interpolation. However, since the first\n+ * interpolation evaluation is the same as the first integration\n+ * evaluation of the next step, we have included it in the integrator\n+ * rather than in the interpolator and specified the method was an\n+ * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n+ * really 12 evaluations per step even if no interpolation is done,\n+ * and the overcost of interpolation is only 3 evaluations.</p>\n+\n+ * <p>This method is based on an 8(6) method by Dormand and Prince\n+ * (i.e. order 8 for the integration and order 6 for error estimation)\n+ * modified by Hairer and Wanner to use a 5th order error estimator\n+ * with 3rd order correction. This modification was introduced because\n+ * the original method failed in some cases (wrong steps can be\n+ * accepted when step size is too large, for example in the\n+ * Brusselator problem) and also had <i>severe difficulties when\n+ * applied to problems with discontinuities</i>. This modification is\n+ * explained in the second edition of the first volume (Nonstiff\n+ * Problems) of the reference book by Hairer, Norsett and Wanner:\n+ * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n+ * ISBN 3-540-56670-8).</p>\n+\n+ * @version $Id: DormandPrince853Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DormandPrince853Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = new String(\"Dormand-Prince 8 (5, 3)\");\n+\n+  private static final double sqrt6 = Math.sqrt(6.0);\n+\n+  private static final double[] c = {\n+    (12.0 - 2.0 * sqrt6) / 135.0, (6.0 - sqrt6) / 45.0, (6.0 - sqrt6) / 30.0,\n+    (6.0 + sqrt6) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    6.0/7.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+\n+    // k2\n+    {(12.0 - 2.0 * sqrt6) / 135.0},\n+\n+    // k3\n+    {(6.0 - sqrt6) / 180.0, (6.0 - sqrt6) / 60.0},\n+\n+    // k4\n+    {(6.0 - sqrt6) / 120.0, 0.0, (6.0 - sqrt6) / 40.0},\n+\n+    // k5\n+    {(462.0 + 107.0 * sqrt6) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * sqrt6) / 1000.0, (168.0 + 73.0 * sqrt6) / 375.0},\n+\n+    // k6\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + sqrt6) / 108.0, (16.0 - sqrt6) / 108.0},\n+\n+    // k7\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * sqrt6) / 1024.0,\n+     (118.0 - 23.0 * sqrt6) / 1024.0, -9.0 / 512.0},\n+\n+    // k8\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * sqrt6) / 371293.0,\n+     (51544.0 - 4784.0 * sqrt6) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+\n+    // k9\n+    {58656157643.0 / 93983540625.0, 0.0, 0.0,\n+     (-1324889724104.0 - 318801444819.0 * sqrt6) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * sqrt6) / 626556937500.0,\n+     96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n+     -165125654.0 / 3796875.0},\n+\n+    // k10\n+    {8909899.0 / 18653125.0, 0.0, 0.0,\n+     (-4521408.0 - 1137963.0 * sqrt6) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * sqrt6) / 2937500.0,\n+     96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n+     -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n+\n+    // k11\n+    {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n+     (354216.0 + 94326.0 * sqrt6) / 112847.0,\n+     (354216.0 - 94326.0 * sqrt6) / 112847.0,\n+     -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n+     14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n+     -1477884375.0 / 485066827.0},\n+\n+    // k12\n+    {39815761.0 / 17514443.0, 0.0, 0.0,\n+     (-3457480.0 - 960905.0 * sqrt6) / 551636.0,\n+     (-3457480.0 + 960905.0 * sqrt6) / 551636.0,\n+     -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n+     -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n+     226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n+\n+    // k13 should be for interpolation only, but since it is the same\n+    // stage as the first evaluation of the next step, we perform it\n+    // here at no cost by specifying this is an fsal method\n+    {104257.0/1920240.0, 0.0, 0.0, 0.0, 0.0, 3399327.0/763840.0,\n+     66578432.0/35198415.0, -1674902723.0/288716400.0,\n+     54980371265625.0/176692375811392.0, -734375.0/4826304.0,\n+     171414593.0/851261400.0, 137909.0/3084480.0}\n+\n+  };\n+\n+  private static final double[] b = {\n+      104257.0/1920240.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      3399327.0/763840.0,\n+      66578432.0/35198415.0,\n+      -1674902723.0/288716400.0,\n+      54980371265625.0/176692375811392.0,\n+      -734375.0/4826304.0,\n+      171414593.0/851261400.0,\n+      137909.0/3084480.0,\n+      0.0\n+  };\n+\n+  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+  private static final double e1_12 =           -137909.0 / 6168960.0;\n+\n+  private static final double e2_01 =           -364463.0 / 1920240.0;\n+  private static final double e2_06 =           3399327.0 / 763840.0;\n+  private static final double e2_07 =          66578432.0 / 35198415.0;\n+  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+  private static final double e2_10 =           -734375.0 / 4826304.0;\n+  private static final double e2_11 =         171414593.0 / 851261400.0;\n+  private static final double e2_12 =             69869.0 / 3084480.0;\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(double minStep, double maxStep,\n+                                    double scalAbsoluteTolerance,\n+                                    double scalRelativeTolerance) {\n+    super(true, c, a, b,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(double minStep, double maxStep,\n+                                    double[] vecAbsoluteTolerance,\n+                                    double[] vecRelativeTolerance) {\n+    super(true, c, a, b,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 8;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+    double error1 = 0;\n+    double error2 = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j]\n+                     + e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j]\n+                     + e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j]\n+                     + e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j]\n+                     + e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j]\n+                     + e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j]\n+                     + e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio1  = errSum1 / tol;\n+      error1        += ratio1 * ratio1;\n+      double ratio2  = errSum2 / tol;\n+      error2        += ratio2 * ratio2;\n+    }\n+\n+    double den = error1 + 0.01 * error2;\n+    if (den <= 0.0) {\n+      den = 1.0;\n+    }\n+\n+    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince853StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.ObjectOutput;\n+import java.io.ObjectInput;\n+import java.io.IOException;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 8(5,3) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince853Integrator\n+ *\n+ * @version $Id: DormandPrince853StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class DormandPrince853StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince853StepInterpolator() {\n+    super();\n+    yDotKLast = null;\n+    yTmp      = null;\n+    v         = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState == null) {\n+\n+      yDotKLast = null;\n+      v         = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      int dimension = interpolator.currentState.length;\n+\n+      yDotKLast    = new double[3][];\n+      for (int k = 0; k < yDotKLast.length; ++k) {\n+        yDotKLast[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n+                         dimension);\n+      }\n+\n+      v = new double[7][];\n+      for (int k = 0; k < v.length; ++k) {\n+        v[k] = new double[dimension];\n+        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n+      }\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+    // the step has been finalized, we don't need this anymore\n+    yTmp = null;\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new DormandPrince853StepInterpolator(this);\n+  }\n+\n+  /** Reinitialize the instance\n+   * Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. So the\n+   * interpolator should perform the last evaluations they need by\n+   * themselves. The {@link RungeKuttaFehlbergIntegrator\n+   * RungeKuttaFehlbergIntegrator} abstract class calls this method in\n+   * order to let the step interpolator perform the evaluations it\n+   * needs. These evaluations will be performed during the call to\n+   * <code>doFinalize</code> if any, i.e. only if the step handler\n+   * either calls the {@link AbstractStepInterpolator#finalizeStep\n+   * finalizeStep} method or the {@link\n+   * AbstractStepInterpolator#getInterpolatedState getInterpolatedState}\n+   * method (for an interpolator which needs a finalization) or if it clones\n+   * the step interpolator.\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+\n+    super.reinitialize(equations, y, yDotK, forward);\n+\n+    int dimension = currentState.length;\n+\n+    yDotKLast = new double[3][];\n+    for (int k = 0; k < yDotKLast.length; ++k) {\n+      yDotKLast[k] = new double[dimension];\n+    }\n+\n+    yTmp = new double[dimension];\n+\n+    v = new double[7][];\n+    for (int k = 0; k < v.length; ++k) {\n+      v[k]  = new double[dimension];\n+    }\n+\n+    vectorsInitialized = false;\n+\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v == null) {\n+        v = new double[7][];\n+        for (int k = 0; k < 7; ++k) {\n+          v[k] = new double[interpolatedState.length];\n+        }\n+      }\n+\n+      // perform the last evaluations if they have not been done yet\n+      finalizeStep();\n+\n+      // compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i]\n+                     + b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i]\n+                     + b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n+        v[1][i] = h * yDotK[0][i] - v[0][i];\n+        v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n+        for (int k = 0; k < d.length; ++k) {\n+          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i]\n+                         + d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i]\n+                         + d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i]\n+                         + d[k][9]  * yDotKLast[0][i]\n+                         + d[k][10] * yDotKLast[1][i]\n+                         + d[k][11] * yDotKLast[2][i]);\n+        }\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    double eta = oneMinusThetaH / h;\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           -   eta * (v[0][i]\n+                           - theta * (v[1][i]\n+                           + theta * (v[2][i]\n+                           +   eta * (v[3][i]\n+                           + theta * (v[4][i]\n+                           +   eta * (v[5][i]\n+                           + theta * (v[6][i])))))));\n+    }\n+\n+  }\n+ \n+  /**\n+   * Really finalize the step.\n+   * Perform the last 3 functions evaluations (k14, k15, k16)\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+\n+    double s;\n+\n+    // k14\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j]\n+        + k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j]\n+        + k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+\n+    // k15\n+    for (int j = 0; j < currentState.length; ++j) {\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j]\n+       + k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j]\n+       + k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j]\n+       + k15_14 * yDotKLast[0][j];\n+     yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+\n+    // k16\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j]\n+        + k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j]\n+        + k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j]\n+        + k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+\n+  }\n+\n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    try {\n+      // save the local attributes\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      IOException ioe = new IOException();\n+      ioe.initCause(e);\n+      throw ioe;\n+    }\n+    out.writeInt(currentState.length);\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(yDotKLast[0][i]);\n+      out.writeDouble(yDotKLast[1][i]);\n+      out.writeDouble(yDotKLast[2][i]);\n+    }\n+\n+    // save the state of the base class\n+    super.writeExternal(out);\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the local attributes\n+    yDotKLast = new double[3][];\n+    int dimension = in.readInt();\n+    yDotKLast[0] = new double[dimension];\n+    yDotKLast[1] = new double[dimension];\n+    yDotKLast[2] = new double[dimension];\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      yDotKLast[0][i] = in.readDouble();\n+      yDotKLast[1][i] = in.readDouble();\n+      yDotKLast[2][i] = in.readDouble();\n+    }\n+\n+    // read the base state\n+    super.readExternal(in);\n+\n+  }\n+\n+  /** Last evaluations. */\n+  private double[][] yDotKLast;\n+\n+  /** Temporary state vector. */\n+  private double[] yTmp;\n+\n+  /** Vectors for interpolation. */\n+  private double[][] v;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  // external weights of the integrator,\n+  // note that b_02 through b_05 are null\n+  private static double b_01 =         104257.0 / 1920240.0;\n+  private static double b_06 =        3399327.0 / 763840.0;\n+  private static double b_07 =       66578432.0 / 35198415.0;\n+  private static double b_08 =    -1674902723.0 / 288716400.0;\n+  private static double b_09 = 54980371265625.0 / 176692375811392.0;\n+  private static double b_10 =        -734375.0 / 4826304.0;\n+  private static double b_11 =      171414593.0 / 851261400.0;\n+  private static double b_12 =         137909.0 / 3084480.0;\n+\n+  // k14 for interpolation only\n+  private static double c14    = 1.0 / 10.0;\n+\n+  private static double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+  private static double k14_06 =                 0.0                       - b_06;\n+  private static double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+  private static double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+  private static double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+  private static double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+  private static double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+  private static double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+  private static double k14_13 =             -4149.0 / 500000.0;\n+\n+  // k15 for interpolation only\n+  private static double c15    = 1.0 / 5.0;\n+\n+  private static double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+  private static double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+  private static double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+  private static double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+  private static double k15_09 =                 0.0                       - b_09;\n+  private static double k15_10 =                 0.0                       - b_10;\n+  private static double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+  private static double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+  private static double k15_13 =      -11518334563.0 / 33831184612500.0;\n+  private static double k15_14 =        1912306948.0 / 13532473845.0;\n+\n+  // k16 for interpolation only\n+  private static double c16    = 7.0 / 9.0;\n+\n+  private static double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+  private static double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+  private static double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+  private static double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+  private static double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+  private static double k16_10 =                 0.0                       - b_10;\n+  private static double k16_11 =                 0.0                       - b_11;\n+  private static double k16_12 =                 0.0                       - b_12;\n+  private static double k16_13 =       -1199007803.0 / 857031517296.0;\n+  private static double k16_14 =      157882067000.0 / 53564469831.0;\n+  private static double k16_15 =     -290468882375.0 / 31741908048.0;\n+\n+  // interpolation weights\n+  // (beware that only the non-null values are in the table)\n+  private static double[][] d = {\n+\n+    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+  };\n+\n+  private static final long serialVersionUID = 4165537490327432186L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DummyStepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is a step handler that do nothing.\n+\n+ * <p>This class is provided as a convenience for users who are only\n+ * interested in the final state of an integration and not in the\n+ * intermediate steps. Its handleStep method does nothing.</p>\n+\n+ * <p>Since this class has no internal state, it is implemented using\n+ * the Singleton design pattern. This means that only one instance is\n+ * ever created, which can be retrieved using the getInstance\n+ * method. This explains why there is no public constructor.</p>\n+\n+ * @see StepHandler\n+\n+ * @version $Id: DummyStepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DummyStepHandler\n+  implements StepHandler {\n+\n+  /** Private constructor.\n+   * The constructor is private to prevent users from creating\n+   * instances (Singleton design-pattern).\n+   */\n+  private DummyStepHandler() {\n+  }\n+\n+  /** Get the only instance.\n+   * @return the only instance\n+   */\n+  public static DummyStepHandler getInstance() {\n+    if (instance == null) {\n+      instance = new DummyStepHandler();\n+    }\n+    return instance;\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * Since this handler does nothing, it does not require dense output.\n+   * @return always false\n+   */\n+  public boolean requiresDenseOutput() {\n+    return false;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+  }\n+\n+  /**\n+   * Handle the last accepted step.\n+   * This method does nothing in this class.\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+  }\n+\n+  /** The only instance. */\n+  private static DummyStepHandler instance = null;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DummyStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Id: DummyStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected DummyStepInterpolator() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected DummyStepInterpolator(double[] y, boolean forward) {\n+    super(y, forward);\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any interpolation and will throw a {@link NullPointerException}\n+   * later. Since we don't want this constructor to throw the\n+   * exceptions finalization may involve and since we don't want this\n+   * method to modify the state of the copied interpolator,\n+   * finalization is <strong>not</strong> done automatically, it\n+   * remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected DummyStepInterpolator(DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Copy the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance.\n+   */\n+  public Object clone() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta, double oneMinusThetaH)\n+    throws DerivativeException {\n+  }\n+    \n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+  }\n+\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      IOException ioe = new IOException();\n+      ioe.initCause(e);\n+      throw ioe;\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/EulerIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a simple Euler integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>The Euler algorithm is the simplest one that can be used to\n+ * integrate ordinary differential equations. It is a simple inversion\n+ * of the forward difference expression :\n+ * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n+ * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n+ * dense output is the linear scheme already used for integration.</p>\n+\n+ * <p>This algorithm looks cheap because it needs only one function\n+ * evaluation per step. However, as it uses linear estimates, it needs\n+ * very small steps to achieve high accuracy, and small steps lead to\n+ * numerical errors and instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a comparison reference for more useful\n+ * integrators.</p>\n+\n+ * @see MidpointIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: EulerIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EulerIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = new String(\"Euler\");\n+\n+  private static final double[] c = {\n+  };\n+\n+  private static final double[][] a = {\n+  };\n+\n+  private static final double[] b = {\n+    1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build an Euler integrator with the given step.\n+   * @param step integration step\n+   */\n+  public EulerIntegrator(double step) {\n+    super(false, c, a, b, new EulerStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/EulerStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a linear interpolator for step.\n+\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * the derivatives already computed during the step.</p>\n+\n+ * @see EulerIntegrator\n+\n+ * @version $Id: EulerStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class EulerStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public EulerStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public EulerStepInterpolator(EulerStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new EulerStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -7179861704951334960L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/FirstOrderConverter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This class converts second order differential equations to first\n+ * order ones.\n+\n+ * <p>This class is a wrapper around a {@link\n+ * SecondOrderDifferentialEquations} which allow to use a {@link\n+ * FirstOrderIntegrator} to integrate it.</p>\n+\n+ * <p>The transformation is done by changing the n dimension state\n+ * vector to a 2n dimension vector, where the first n components are\n+ * the initial state variables and the n last components are their\n+ * first time derivative. The first time derivative of this state\n+ * vector then really contains both the first and second time\n+ * derivative of the initial state vector, which can be handled by the\n+ * underlying second order equations set.</p>\n+\n+ * <p>One should be aware that the data is duplicated during the\n+ * transformation process and that for each call to {@link\n+ * #computeDerivatives computeDerivatives}, this wrapper does copy 4n\n+ * scalars : 2n before the call to {@link\n+ * SecondOrderDifferentialEquations#computeSecondDerivatives\n+ * computeSecondDerivatives} in order to dispatch the y state vector\n+ * into z and zDot, and 2n after the call to gather zDot and zDDot\n+ * into yDot. Since the underlying problem by itself perhaps also\n+ * needs to copy data and dispatch the arrays into domain objects,\n+ * this has an impact on both memory and CPU usage. The only way to\n+ * avoid this duplication is to perform the transformation at the\n+ * problem level, i.e. to implement the problem as a first order one\n+ * and then avoid using this class.</p>\n+\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderDifferentialEquations\n+ * @see SecondOrderDifferentialEquations\n+\n+ * @version $Id: FirstOrderConverter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class FirstOrderConverter\n+  implements FirstOrderDifferentialEquations {\n+\n+  /** Simple constructor.\n+   * Build a converter around a second order equations set.\n+   * @param equations second order equations set to convert\n+   */\n+  public FirstOrderConverter (SecondOrderDifferentialEquations equations) {\n+      this.equations = equations;\n+      dimension      = equations.getDimension();\n+      z              = new double[dimension];\n+      zDot           = new double[dimension];\n+      zDDot          = new double[dimension];\n+  }\n+\n+  public int getDimension() {\n+    return 2 * dimension;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot)\n+  throws DerivativeException {\n+\n+    // split the state vector in two\n+    System.arraycopy(y, 0,         z,    0, dimension);\n+    System.arraycopy(y, dimension, zDot, 0, dimension);\n+\n+    // apply the underlying equations set\n+    equations.computeSecondDerivatives(t, z, zDot, zDDot);\n+\n+    // build the result state derivative\n+    System.arraycopy(zDot,  0, yDot, 0,         dimension);\n+    System.arraycopy(zDDot, 0, yDot, dimension, dimension);\n+    \n+  }\n+\n+  /** Underlying second order equations set. */\n+  private SecondOrderDifferentialEquations equations;\n+\n+  /** second order problem dimension. */\n+  private int dimension;\n+\n+  /** state vector. */\n+  private double[] z;\n+\n+  /** first time derivative of the state vector. */\n+  private double[] zDot;\n+\n+  /** second time derivative of the state vector. */\n+  private double[] zDDot;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/FirstOrderDifferentialEquations.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This interface represents a first order differential equations set.\n+ *\n+ * <p>This interface should be implemented by all real first order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link FirstOrderIntegrator#integrate} method.</p>\n+ *\n+ * <p>A first order differential equations problem, as seen by an\n+ * integrator is the time derivative <code>dY/dt</code> of a state\n+ * vector <code>Y</code>, both being one dimensional arrays. From the\n+ * integrator point of view, this derivative depends only on the\n+ * current time <code>t</code> and on the state vector\n+ * <code>Y</code>.</p>\n+ *\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see SecondOrderDifferentialEquations\n+ * @see org.spaceroots.mantissa.utilities.ArraySliceMappable\n+ *\n+ * @version $Id: FirstOrderDifferentialEquations.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface FirstOrderDifferentialEquations {\n+    \n+    /** Get the dimension of the problem.\n+     * @return dimension of the problem\n+     */\n+    public int getDimension();\n+    \n+    /** Get the current time derivative of the state vector.\n+     * @param t current value of the independant <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    public void computeDerivatives(double t, double[] y, double[] yDot)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/FirstOrderIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This interface represents a first order integrator for\n+ * differential equations.\n+\n+ * <p>The classes which are devoted to solve first order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * FirstOrderDifferentialEquations} interface.</p>\n+\n+ * @see FirstOrderDifferentialEquations\n+ * @see StepHandler\n+ * @see SwitchingFunction\n+\n+ * @version $Id: FirstOrderIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface FirstOrderIntegrator {\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler);\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler();\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence);\n+\n+  /** Integrate the differential equations up to the given time\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each successful\n+   *  step (and hence at the end of integration), can be the same object as y0\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if\n+   * the underlying user function triggers one\n+   */\n+  public void integrate (FirstOrderDifferentialEquations equations,\n+                         double t0, double[] y0,\n+                         double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/FixedStepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful fixed step.\n+\n+ * <p>This interface should be implemented by anyone who is interested\n+ * in getting the solution of an ordinary differential equation at\n+ * fixed time steps. Objects implementing this interface should be\n+ * wrapped within an instance of {@link StepNormalizer} that itself\n+ * is used as the general {@link StepHandler} by the integrator. The\n+ * {@link StepNormalizer} object is called according to the integrator\n+ * internal algorithms and it calls objects implementing this\n+ * interface as necessary at fixed time steps.</p>\n+\n+ * @see StepHandler\n+ * @see StepNormalizer\n+\n+ * @version $Id: FixedStepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface FixedStepHandler {\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param t time of the current step\n+\n+   * @param y state vector at t. For efficiency purposes, the {@link\n+   * StepNormalizer} class reuse the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(double t, double[] y, boolean isLast);\n+    \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GillIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the Gill fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations .\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |    0        0       0      0\n+ *   1/2 |   1/2       0       0      0\n+ *   1/2 | (q-1)/2  (2-q)/2    0      0\n+ *    1  |    0       -q/2  (2+q)/2   0\n+ *       |-------------------------------\n+ *       |   1/6    (2-q)/6 (2+q)/6  1/6\n+ * </pre>\n+ * where q = sqrt(2)</p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: GillIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GillIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = new String(\"Gill\");\n+\n+  private static final double sqrt2 = Math.sqrt(2.0);\n+\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { (sqrt2 - 1.0) / 2.0, (2.0 - sqrt2) / 2.0 },\n+    { 0.0, -sqrt2 / 2.0, (2.0 + sqrt2) / 2.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 6.0, (2.0 - sqrt2) / 6.0, (2.0 + sqrt2) / 6.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Gill integrator with the given step.\n+   * @param step integration step\n+   */\n+  public GillIntegrator(double step) {\n+    super(false, c, a, b, new GillStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GillStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a step interpolator for the Gill fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n+ *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n+ *                                        + (1 + theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * are the four evaluations of the derivatives already computed during\n+ * the step.</p>\n+\n+ * @see GillIntegrator\n+\n+ * @version $Id: GillStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class GillStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public GillStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GillStepInterpolator(GillStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new GillStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta = 4 * theta;\n+    double s         = oneMinusThetaH / 6.0;\n+    double soMt      = s * (1 - theta);\n+    double c23       = soMt * (1 + 2 * theta);\n+    double coeff1    = soMt * (1 - fourTheta);\n+    double coeff2    = c23  * tMq;\n+    double coeff3    = c23  * tPq;\n+    double coeff4    = s * (1 + theta * (1 + fourTheta));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n+                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  /** First Gill coefficient. */\n+  private static final double tMq = 2 - Math.sqrt(2.0);\n+\n+  /** Second Gill coefficient. */\n+  private static final double tPq = 2 + Math.sqrt(2.0);\n+\n+  private static final long serialVersionUID = -107804074496313322L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a Gragg-Bulirsch-Stoer integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n+ * ones currently available for smooth problems. It uses Richardson\n+ * extrapolation to estimate what would be the solution if the step\n+ * size could be decreased down to zero.</p>\n+\n+ * <p>\n+ * This method changes both the step size and the order during\n+ * integration, in order to minimize computation cost. It is\n+ * particularly well suited when a very high precision is needed. The\n+ * limit where this method becomes more efficient than high-order\n+ * Runge-Kutta-Fehlberg methods like {@link DormandPrince853Integrator\n+ * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n+ * Hairer, Norsett and Wanner book show for example that this limit\n+ * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n+ * equations (the authors note this problem is <i>extremely sensitive\n+ * to the errors in the first integration steps</i>), and around 1e-11\n+ * for a two dimensional celestial mechanics problems with seven\n+ * bodies (pleiades problem, involving quasi-collisions for which\n+ * <i>automatic step size control is essential</i>).\n+ * </p>\n+\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @author L. Maisonobe (Java port)\n+ * @version $Id: GraggBulirschStoerIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+\n+ */\n+\n+public class GraggBulirschStoerIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  private static final String methodName = new String(\"Gragg-Bulirsch-Stoer\");\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(double minStep, double maxStep,\n+                                      double scalAbsoluteTolerance,\n+                                      double scalRelativeTolerance) {\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(double minStep, double maxStep,\n+                                      double[] vecAbsoluteTolerance,\n+                                      double[] vecRelativeTolerance) {\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Set the stability check controls.\n+   * <p>The stability check is performed on the first few iterations of\n+   * the extrapolation scheme. If this test fails, the step is rejected\n+   * and the stepsize is reduced.</p>\n+   * <p>By default, the test is performed, at most during two\n+   * iterations at each step, and at most once for each of these\n+   * iterations. The default stepsize reduction factor is 0.5.</p>\n+   * @param performTest if true, stability check will be performed,\n+     if false, the check will be skipped\n+   * @param maxIter maximal number of iterations for which checks are\n+   * performed (the number of iterations is reset to default if negative\n+   * or null)\n+   * @param maxChecks maximal number of checks for each iteration\n+   * (the number of checks is reset to default if negative or null)\n+   * @param stabilityReduction stepsize reduction factor in case of\n+   * failure (the factor is reset to default if lower than 0.0001 or\n+   * greater than 0.9999)\n+   */\n+  public void setStabilityCheck(boolean performTest,\n+                                int maxIter, int maxChecks,\n+                                double stabilityReduction) {\n+\n+    this.performTest = performTest;\n+    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n+    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n+\n+    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+      this.stabilityReduction = 0.5;\n+    } else {\n+      this.stabilityReduction = stabilityReduction;\n+    }\n+\n+  }\n+\n+  /** Set the step size control factors.\n+\n+   * <p>The new step size hNew is computed from the old one h by:\n+   * <pre>\n+   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))\n+   * </pre>\n+   * where err is the scaled error and k the iteration number of the\n+   * extrapolation scheme (counting from 0). The default values are\n+   * 0.65 for stepControl1 and 0.94 for stepControl2.</p>\n+   * <p>The step size is subject to the restriction:\n+   * <pre>\n+   * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))\n+   * </pre>\n+   * The default values are 0.02 for stepControl3 and 4.0 for\n+   * stepControl4.</p>\n+   * @param stepControl1 first stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl2 second stepsize control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl3 third stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl4 fourth stepsize control factor (the factor\n+   * is reset to default if lower than 1.0001 or greater than 999.9)\n+   */\n+  public void setStepsizeControl(double stepControl1, double stepControl2,\n+                                 double stepControl3, double stepControl4) {\n+\n+    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+      this.stepControl1 = 0.65;\n+    } else {\n+      this.stepControl1 = stepControl1;\n+    }\n+\n+    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl2 = 0.94;\n+    } else {\n+      this.stepControl2 = stepControl2;\n+    }\n+\n+    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl3 = 0.02;\n+    } else {\n+      this.stepControl3 = stepControl3;\n+    }\n+\n+    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl4 = 4.0;\n+    } else {\n+      this.stepControl4 = stepControl4;\n+    }\n+\n+  }\n+\n+  /** Set the order control parameters.\n+   * <p>The Gragg-Bulirsch-Stoer method changes both the step size and\n+   * the order during integration, in order to minimize computation\n+   * cost. Each extrapolation step increases the order by 2, so the\n+   * maximal order that will be used is always even, it is twice the\n+   * maximal number of columns in the extrapolation table.</p>\n+   * <pre>\n+   * order is decreased if w(k-1) <= w(k)   * orderControl1\n+   * order is increased if w(k)   <= w(k-1) * orderControl2\n+   * </pre>\n+   * <p>where w is the table of work per unit step for each order\n+   * (number of function calls divided by the step length), and k is\n+   * the current order.</p>\n+   * <p>The default maximal order after construction is 18 (i.e. the\n+   * maximal number of columns is 9). The default values are 0.8 for\n+   * orderControl1 and 0.9 for orderControl2.</p>\n+   * @param maxOrder maximal order in the extrapolation table (the\n+   * maximal order is reset to default if order <= 6 or odd)\n+   * @param orderControl1 first order control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param orderControl2 second order control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   */\n+  public void setOrderControl(int maxOrder,\n+                              double orderControl1, double orderControl2) {\n+\n+    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+      this.maxOrder = 18;\n+    }\n+\n+    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+      this.orderControl1 = 0.8;\n+    } else {\n+      this.orderControl1 = orderControl1;\n+    }\n+\n+    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl2 = 0.9;\n+    } else {\n+      this.orderControl2 = orderControl2;\n+    }\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+\n+    super.setStepHandler(handler);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    super.addSwitchingFunction(function, maxCheckInterval, convergence);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Initialize the integrator internal arrays. */\n+  private void initializeArrays() {\n+\n+    int size = maxOrder / 2;\n+\n+    if ((sequence == null) || (sequence.length != size)) {\n+      // all arrays should be reallocated with the right size\n+      sequence        = new int[size];\n+      costPerStep     = new int[size];\n+      coeff           = new double[size][];\n+      costPerTimeUnit = new double[size];\n+      optimalStep     = new double[size];\n+    }\n+\n+    if (denseOutput) {\n+      // step size sequence: 2, 6, 10, 14, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 4 * k + 2;\n+      }\n+    } else {\n+      // step size sequence: 2, 4, 6, 8, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 2 * (k + 1); \n+      }\n+    }\n+\n+    // initialize the order selection cost array\n+    // (number of function calls for each column of the extrapolation table)\n+    costPerStep[0] = sequence[0] + 1;\n+    for (int k = 1; k < size; ++k) {\n+      costPerStep[k] = costPerStep[k-1] + sequence[k];\n+    }\n+\n+    // initialize the extrapolation tables\n+    for (int k = 0; k < size; ++k) {\n+      coeff[k] = (k > 0) ? new double[k] : null;\n+      for (int l = 0; l < k; ++l) {\n+        double ratio = ((double) sequence[k]) / sequence[k-l-1];\n+        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);\n+      }\n+    }\n+\n+  }\n+\n+  /** Set the interpolation order control parameter.\n+   * The interpolation order for dense output is 2k - mudif + 1. The\n+   * default value for mudif is 4 and the interpolation error is used\n+   * in stepsize control by default.\n+\n+   * @param useInterpolationError if true, interpolation error is used\n+   * for stepsize control\n+   * @param mudif interpolation order control parameter (the parameter\n+   * is reset to default if <= 0 or >= 7)\n+   */\n+  public void setInterpolationControl(boolean useInterpolationError,\n+                                      int mudif) {\n+\n+    this.useInterpolationError = useInterpolationError;\n+\n+    if ((mudif <= 0) || (mudif >= 7)) {\n+      this.mudif = 4;\n+    } else {\n+      this.mudif = mudif;\n+    }\n+\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Update scaling array.\n+   * @param y1 first state vector to use for scaling\n+   * @param y2 second state vector to use for scaling\n+   * @param scale scaling array to update\n+   */\n+  private void rescale(double[] y1, double[] y2, double[] scale) {\n+    if (vecAbsoluteTolerance == null) {\n+      for (int i = 0; i < scale.length; ++i) {\n+        double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n+      }\n+    } else {\n+      for (int i = 0; i < scale.length; ++i) {\n+        double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n+      }\n+    }\n+  }\n+\n+  /** Perform integration over one step using substeps of a modified\n+   * midpoint method.\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param step global step\n+   * @param k iteration number (from 0 to sequence.length - 1)\n+   * @param scale scaling array\n+   * @param f placeholder where to put the state vector derivatives at each substep\n+   *          (element 0 already contains initial derivative)\n+   * @param yMiddle placeholder where to put the state vector at the middle of the step\n+   * @param yEnd placeholder where to put the state vector at the end\n+   * @param yTmp placeholder for one state vector\n+   * @return true if computation was done properly,\n+   *         false if stability check failed before end of computation\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  private boolean tryStep(FirstOrderDifferentialEquations equations,\n+                          double t0, double[] y0, double step, int k,\n+                          double[] scale, double[][] f,\n+                          double[] yMiddle, double[] yEnd,\n+                          double[] yTmp)\n+    throws DerivativeException {\n+\n+    int    n        = sequence[k];\n+    double subStep  = step / n;\n+    double subStep2 = 2 * subStep;\n+\n+    // first substep\n+    double t = t0 + subStep;\n+    for (int i = 0; i < y0.length; ++i) {\n+      yTmp[i] = y0[i];\n+      yEnd[i] = y0[i] + subStep * f[0][i];\n+    }\n+    equations.computeDerivatives(t, yEnd, f[1]);\n+\n+    // other substeps\n+    for (int j = 1; j < n; ++j) {\n+\n+      if (2 * j == n) {\n+        // save the point at the middle of the step\n+        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n+      }\n+\n+      t += subStep;\n+      for (int i = 0; i < y0.length; ++i) {\n+        double middle = yEnd[i];\n+        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n+        yTmp[i]       = middle;\n+      }\n+\n+      equations.computeDerivatives(t, yEnd, f[j+1]);\n+\n+      // stability check\n+      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n+        double initialNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          double ratio = f[0][l] / scale[l];\n+          initialNorm += ratio * ratio;\n+        }\n+        double deltaNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n+          deltaNorm += ratio * ratio;\n+        }\n+        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+          return false;\n+        }\n+      }\n+\n+    }\n+\n+    // correction of the last substep (at t0 + step)\n+    for (int i = 0; i < y0.length; ++i) {\n+      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  /** Extrapolate a vector.\n+   * @param offset offset to use in the coefficients table\n+   * @param k index of the last updated point\n+   * @param diag working diagonal of the Aitken-Neville's\n+   * triangle, without the last element\n+   * @param last last element\n+   */\n+  private void extrapolate(int offset, int k, double[][] diag, double[] last) {\n+\n+    // update the diagonal\n+    for (int j = 1; j < k; ++j) {\n+      for (int i = 0; i < last.length; ++i) {\n+        // Aitken-Neville's recursive formula\n+        diag[k-j-1][i] = diag[k-j][i]\n+                       + coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+      }\n+    }\n+\n+    // update the last element\n+    for (int i = 0; i < last.length; ++i) {\n+      // Aitken-Neville's recursive formula\n+      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);\n+    }\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0, double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: \"\n+                                    + \"ODE problem has dimension {0}\"\n+                                    + \", state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+\n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    double[] yDot0   = new double[y0.length];\n+    double[] y1      = new double[y0.length];\n+    double[] yTmp    = new double[y0.length];\n+    double[] yTmpDot = new double[y0.length];\n+\n+    double[][] diagonal = new double[sequence.length-1][];\n+    double[][] y1Diag = new double[sequence.length-1][];\n+    for (int k = 0; k < sequence.length-1; ++k) {\n+      diagonal[k] = new double[y0.length];\n+      y1Diag[k] = new double[y0.length];\n+    }\n+\n+    double[][][] fk  = new double[sequence.length][][];\n+    for (int k = 0; k < sequence.length; ++k) {\n+\n+      fk[k]    = new double[sequence[k] + 1][];\n+\n+      // all substeps start at the same point, so share the first array\n+      fk[k][0] = yDot0;\n+\n+      for (int l = 0; l < sequence[k]; ++l) {\n+        fk[k][l+1] = new double[y0.length];\n+      }\n+\n+    }\n+\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+\n+    double[] yDot1      = null;\n+    double[][] yMidDots = null;\n+    if (denseOutput) {\n+      yDot1    = new double[y0.length];\n+      yMidDots = new double[1 + 2 * sequence.length][];\n+      for (int j = 0; j < yMidDots.length; ++j) {\n+        yMidDots[j] = new double[y0.length];\n+      }\n+    } else {\n+      yMidDots    = new double[1][];\n+      yMidDots[0] = new double[y0.length];\n+    }\n+\n+    // initial scaling\n+    double[] scale = new double[y0.length];\n+    rescale(y, y, scale);\n+\n+    // initial order selection\n+    double log10R = Math.log(Math.max(1.0e-10,\n+                                      (vecRelativeTolerance == null)\n+                                      ? scalRelativeTolerance\n+                                      : vecRelativeTolerance[0]))\n+                  / Math.log(10.0);\n+    int targetIter = Math.max(1,\n+                              Math.min(sequence.length - 2,\n+                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator = null;\n+    if (denseOutput || (! switchesHandler.isEmpty())) {\n+      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n+                                                            y1, yDot1,\n+                                                            yMidDots, forward);\n+    } else {\n+      interpolator = new DummyStepInterpolator(y, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    double  currentT         = t0;\n+    double  hNew             = 0;\n+    double  maxError         = Double.MAX_VALUE;\n+    boolean previousRejected = false;\n+    boolean firstTime        = true;\n+    boolean newStep          = true;\n+    boolean lastStep         = false;\n+    boolean firstStepAlreadyComputed = false;\n+    handler.reset();\n+    costPerTimeUnit[0] = 0;\n+    while (! lastStep) {\n+\n+      double h;\n+      double error;\n+      boolean reject = false;\n+\n+      if (newStep) {\n+\n+        interpolator.shift();\n+\n+        // first evaluation, at the beginning of the step\n+        if (! firstStepAlreadyComputed) {\n+          equations.computeDerivatives(currentT, y, yDot0);\n+        }\n+\n+        if (firstTime) {\n+\n+          hNew = initializeStep(equations, forward,\n+                                2 * targetIter + 1, scale,\n+                                currentT, y, yDot0, yTmp, yTmpDot);\n+\n+          if (! forward) {\n+            hNew = -hNew;\n+          }\n+\n+        }\n+\n+        newStep = false;\n+\n+      }\n+\n+      h = hNew;\n+\n+      // step adjustment near bounds\n+      if ((forward && (currentT + h > t))\n+          || ((! forward) && (currentT + h < t))) {\n+        h = t - currentT;\n+      }\n+      double nextT = currentT + h;\n+      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+\n+      // iterate over several substep sizes\n+      int k = -1;\n+      for (boolean loop = true; loop; ) {\n+\n+        ++k;\n+\n+        // modified midpoint integration with the current substep\n+        if ( ! tryStep(equations, currentT, y, h, k, scale, fk[k],\n+                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n+                       (k == 0) ? y1 : y1Diag[k-1],\n+                       yTmp)) {\n+\n+          // the stability check failed, we reduce the global step\n+          hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+          reject = true;\n+          loop   = false;\n+\n+        } else {\n+\n+          // the substep was computed successfully\n+          if (k > 0) {\n+\n+            // extrapolate the state at the end of the step\n+            // using last iteration data\n+            extrapolate(0, k, y1Diag, y1);\n+            rescale(y, y1, scale);\n+\n+            // estimate the error at the end of the step.\n+            error = 0;\n+            for (int j = 0; j < y0.length; ++j) {\n+              double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              error += e * e;\n+            }\n+            error = Math.sqrt(error / y0.length);\n+\n+            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n+              // error is too big, we reduce the global step\n+              hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+              reject = true;\n+              loop   = false;\n+            } else {\n+\n+              maxError = Math.max(4 * error, 1.0);\n+\n+              // compute optimal stepsize for this order\n+              double exp = 1.0 / (2 * k + 1);\n+              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n+              double pow = Math.pow(stepControl3, exp);\n+              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n+              optimalStep[k]     = Math.abs(filterStep(h * fac, true));\n+              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n+\n+              // check convergence\n+              switch (k - targetIter) {\n+\n+              case -1 :\n+                if ((targetIter > 1) && ! previousRejected) {\n+\n+                  // check if we can stop iterations now\n+                  if (error <= 1.0) {\n+                    // convergence have been reached just before targetIter\n+                    loop = false;\n+                  } else {\n+                    // estimate if there is a chance convergence will\n+                    // be reached on next iteration, using the\n+                    // asymptotic evolution of error\n+                    double ratio = sequence [k] * sequence[k+1]\n+                                 / (sequence[0] * sequence[0]);\n+                    if (error > ratio * ratio) {\n+                      // we don't expect to converge on next iteration\n+                      // we reject the step immediately and reduce order\n+                      reject = true;\n+                      loop   = false;\n+                      targetIter = k;\n+                      if ((targetIter > 1)\n+                          && (costPerTimeUnit[targetIter-1]\n+                              < orderControl1 * costPerTimeUnit[targetIter])) {\n+                        --targetIter;\n+                      }\n+                      hNew = optimalStep[targetIter];\n+                    }\n+                  }\n+                }\n+                break;\n+\n+              case 0:\n+                if (error <= 1.0) {\n+                  // convergence has been reached exactly at targetIter\n+                  loop = false;\n+                } else {\n+                  // estimate if there is a chance convergence will\n+                  // be reached on next iteration, using the\n+                  // asymptotic evolution of error\n+                  double ratio = sequence[k+1] / sequence[0];\n+                  if (error > ratio * ratio) {\n+                    // we don't expect to converge on next iteration\n+                    // we reject the step immediately\n+                    reject = true;\n+                    loop = false;\n+                    if ((targetIter > 1)\n+                        && (costPerTimeUnit[targetIter-1]\n+                            < orderControl1 * costPerTimeUnit[targetIter])) {\n+                      --targetIter;\n+                    }\n+                    hNew = optimalStep[targetIter];\n+                  }\n+                }\n+                break;\n+\n+              case 1 :\n+                if (error > 1.0) {\n+                  reject = true;\n+                  if ((targetIter > 1)\n+                      && (costPerTimeUnit[targetIter-1]\n+                          < orderControl1 * costPerTimeUnit[targetIter])) {\n+                    --targetIter;\n+                  }\n+                  hNew = optimalStep[targetIter];\n+                }\n+                loop = false;\n+                break;\n+\n+              default :\n+                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                  loop = false;\n+                }\n+                break;\n+\n+              }\n+\n+            }\n+          }\n+        }\n+      }\n+\n+      // dense output handling\n+      double hInt = getMaxStep();\n+      if (denseOutput && ! reject) {\n+\n+        // extrapolate state at middle point of the step\n+        for (int j = 1; j <= k; ++j) {\n+          extrapolate(0, j, diagonal, yMidDots[0]);\n+        }\n+\n+        // derivative at end of step\n+        equations.computeDerivatives(currentT + h, y1, yDot1);\n+\n+        int mu = 2 * k - mudif + 3;\n+\n+        for (int l = 0; l < mu; ++l) {\n+\n+          // derivative at middle point of the step\n+          int l2 = l / 2;\n+          double factor = Math.pow(0.5 * sequence[l2], l);\n+          int middleIndex = fk[l2].length / 2;\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n+          }\n+          for (int j = 1; j <= k - l2; ++j) {\n+            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            middleIndex = fk[l2+j].length / 2;\n+            for (int i = 0; i < y0.length; ++i) {\n+              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n+            }\n+            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n+          }\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] *= h;\n+          }\n+\n+          // compute centered differences to evaluate next derivatives\n+          for (int j = (l + 1) / 2; j <= k; ++j) {\n+            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n+              for (int i = 0; i < y0.length; ++i) {\n+                fk[j][m][i] -= fk[j][m-2][i];\n+              }\n+            }\n+          }\n+\n+        }\n+\n+        if (mu >= 0) {\n+\n+          // estimate the dense output coefficients\n+          GraggBulirschStoerStepInterpolator gbsInterpolator\n+            = (GraggBulirschStoerStepInterpolator) interpolator;\n+          gbsInterpolator.computeCoefficients(mu, h);\n+\n+          if (useInterpolationError) {\n+            // use the interpolation error to limit stepsize\n+            double interpError = gbsInterpolator.estimateError(scale);\n+            hInt = Math.abs(h / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                         0.01));\n+            if (interpError > 10.0) {\n+              hNew = hInt;\n+              reject = true;\n+            }\n+          }\n+\n+          // Switching functions handling\n+          if (!reject) {\n+            interpolator.storeTime(currentT + h);\n+            if (switchesHandler.evaluateStep(interpolator)) {\n+              reject = true;\n+              hNew = Math.abs(switchesHandler.getEventTime() - currentT);\n+            }\n+          }\n+\n+        }\n+\n+        if (!reject) {\n+          // we will reuse the slope for the beginning of next step\n+          firstStepAlreadyComputed = true;\n+          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        }\n+\n+      }\n+\n+      if (! reject) {\n+\n+        // store end of step state\n+        currentT += h;\n+        System.arraycopy(y1, 0, y, 0, y0.length);\n+\n+        switchesHandler.stepAccepted(currentT, y);\n+        if (switchesHandler.stop()) {\n+          lastStep = true;\n+        }\n+\n+        // provide the step data to the step handler\n+        interpolator.storeTime(currentT);\n+        handler.handleStep(interpolator, lastStep);\n+\n+        switchesHandler.reset(currentT, y);\n+\n+        int optimalIter;\n+        if (k == 1) {\n+          optimalIter = 2;\n+          if (previousRejected) {\n+            optimalIter = 1;\n+          }\n+        } else if (k <= targetIter) {\n+          optimalIter = k;\n+          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n+            optimalIter = k-1;\n+          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n+            optimalIter = Math.min(k+1, sequence.length - 2);\n+          }\n+        } else {\n+          optimalIter = k - 1;\n+          if ((k > 2)\n+              && (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+            optimalIter = k - 2;\n+          }\n+          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n+            optimalIter = Math.min(k, sequence.length - 2);\n+          }\n+        }\n+\n+        if (previousRejected) {\n+          // after a rejected step neither order nor stepsize\n+          // should increase\n+          targetIter = Math.min(optimalIter, k);\n+          hNew = Math.min(Math.abs(h), optimalStep[targetIter]);\n+        } else {\n+          // stepsize control\n+          if (optimalIter <= k) {\n+            hNew = optimalStep[optimalIter];\n+          } else {\n+            if ((k < targetIter)\n+                && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k]\n+                                * costPerStep[optimalIter+1] / costPerStep[k],\n+                                false);\n+            } else {\n+              hNew = filterStep(optimalStep[k]\n+                                * costPerStep[optimalIter] / costPerStep[k],\n+                                false);\n+            }\n+          }\n+\n+          targetIter = optimalIter;\n+\n+        }\n+\n+        newStep = true;\n+\n+      }\n+\n+      hNew = Math.min(hNew, hInt);\n+      if (! forward) {\n+        hNew = -hNew;\n+      }\n+\n+      firstTime = false;\n+\n+      if (reject) {\n+        lastStep = false;\n+        previousRejected = true;\n+      } else {\n+        previousRejected = false;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** maximal order. */\n+  private int maxOrder;\n+\n+  /** step size sequence. */\n+  private int[] sequence;\n+\n+  /** overall cost of applying step reduction up to iteration k+1,\n+   *  in number of calls.\n+   */\n+  private int[] costPerStep;\n+\n+  /** cost per unit step. */\n+  private double[] costPerTimeUnit;\n+\n+  /** optimal steps for each order. */\n+  private double[] optimalStep;\n+\n+  /** extrapolation coefficients. */\n+  private double[][] coeff;\n+\n+  /** stability check enabling parameter. */\n+  private boolean performTest;\n+\n+  /** maximal number of checks for each iteration. */\n+  private int maxChecks;\n+\n+  /** maximal number of iterations for which checks are performed. */\n+  private int maxIter;\n+\n+  /** stepsize reduction factor in case of stability check failure. */\n+  private double stabilityReduction;\n+\n+  /** first stepsize control factor. */\n+  private double stepControl1;\n+\n+  /** second stepsize control factor. */\n+  private double stepControl2;\n+\n+  /** third stepsize control factor. */\n+  private double stepControl3;\n+\n+  /** fourth stepsize control factor. */\n+  private double stepControl4;\n+\n+  /** first order control factor. */\n+  private double orderControl1;\n+\n+  /** second order control factor. */\n+  private double orderControl2;\n+\n+  /** dense outpute required. */\n+  private boolean denseOutput;\n+\n+  /** use interpolation error in stepsize control. */\n+  private boolean useInterpolationError;\n+\n+  /** interpolation order control parameter. */\n+  private int mudif;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/**\n+ * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n+ * integrator.\n+\n+ * <p>This interpolator compute dense output inside the last step\n+ * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n+\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+\n+ * @see GraggBulirschStoerIntegrator\n+\n+ * @version $Id: GraggBulirschStoerStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @author L. Maisonobe (Java port)\n+\n+ */\n+\n+class GraggBulirschStoerStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Slope at the beginning of the step. */\n+  private double[] y0Dot;\n+\n+  /** State at the end of the step. */\n+  private double[] y1;\n+\n+  /** Slope at the end of the step. */\n+  private double[] y1Dot;\n+\n+  /** Derivatives at the middle of the step.\n+   * element 0 is state at midpoint, element 1 is first derivative ...\n+   */\n+  private double[][] yMidDots;\n+\n+  /** Interpolation polynoms. */\n+  private double[][] polynoms;\n+\n+  /** Error coefficients for the interpolation. */\n+  private double[] errfac;\n+\n+  /** Degree of the interpolation polynoms. */\n+  private int currentDegree;\n+\n+  /** Reallocate the internal tables.\n+   * Reallocate the internal tables in order to be able to handle\n+   * interpolation polynoms up to the given degree\n+   * @param maxDegree maximal degree to handle\n+   */\n+  private void resetTables(int maxDegree) {\n+\n+    if (maxDegree < 0) {\n+      polynoms      = null;\n+      errfac        = null;\n+      currentDegree = -1;\n+    } else {\n+\n+      double[][] newPols = new double[maxDegree + 1][];\n+      if (polynoms != null) {\n+        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n+        for (int i = polynoms.length; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      } else {\n+        for (int i = 0; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      }\n+      polynoms = newPols;\n+\n+      // initialize the error factors array for interpolation\n+      if (maxDegree <= 4) {\n+        errfac = null;\n+      } else {\n+        errfac = new double[maxDegree - 4];\n+        for (int i = 0; i < errfac.length; ++i) {\n+          int ip5 = i + 5;\n+          errfac[i] = 1.0 / (ip5 * ip5);\n+          double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          for (int j = 0; j <= i; ++j) {\n+            errfac[i] *= e / (j + 1);\n+          }\n+        }\n+      }\n+\n+      currentDegree = 0;\n+\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,\n+                                            double[] y1, double[] y1Dot,\n+                                            double[][] yMidDots,\n+                                            boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new GraggBulirschStoerStepInterpolator(this);\n+  }\n+\n+  /** Compute the interpolation coefficients for dense output.\n+   * @param mu degree of the interpolation polynom\n+   * @param h current step\n+   */\n+  public void computeCoefficients(int mu, double h) {\n+\n+    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+      resetTables(mu + 4);\n+    }\n+\n+    currentDegree = mu + 4;\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+\n+      double yp0   = h * y0Dot[i];\n+      double yp1   = h * y1Dot[i];\n+      double ydiff = y1[i] - currentState[i];\n+      double aspl  = ydiff - yp1;\n+      double bspl  = yp0 - ydiff;\n+\n+      polynoms[0][i] = currentState[i];\n+      polynoms[1][i] = ydiff;\n+      polynoms[2][i] = aspl;\n+      polynoms[3][i] = bspl;\n+\n+      if (mu < 0) {\n+        return;\n+      }\n+\n+      // compute the remaining coefficients\n+      double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n+      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+\n+      if (mu > 0) {\n+        double ph1 = ydiff + 0.25 * (aspl - bspl);\n+        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+\n+        if (mu > 1) {\n+          double ph2 = yp1 - yp0;\n+          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+\n+          if (mu > 2) {\n+            double ph3 = 6 * (bspl - aspl);\n+            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+\n+            for (int j = 4; j <= mu; ++j) {\n+              double fac1 = 0.5 * j * (j - 1);\n+              double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n+              polynoms[j+4][i] = 16 * (yMidDots[j][i]\n+                                       + fac1 * polynoms[j+2][i]\n+                                       - fac2 * polynoms[j][i]);\n+            }\n+\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Estimate interpolation error.\n+   * @param scale scaling array\n+   * @return estimate of the interpolation error\n+   */\n+  public double estimateError(double[] scale) {\n+    double error = 0;\n+    if (currentDegree >= 5) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        double e = polynoms[currentDegree][i] / scale[i];\n+        error += e * e;\n+      }\n+      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+    }\n+    return error;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    int dimension = currentState.length;\n+\n+    double oneMinusTheta = 1.0 - theta;\n+    double theta05       = theta - 0.5;\n+    double t4            = theta * oneMinusTheta;\n+    t4 = t4 * t4;\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      interpolatedState[i] = polynoms[0][i]\n+        + theta * (polynoms[1][i]\n+                   + oneMinusTheta * (polynoms[2][i] * theta\n+                                      + polynoms[3][i] * oneMinusTheta));\n+\n+      if (currentDegree > 3) {\n+        double c = polynoms[currentDegree][i];\n+        for (int j = currentDegree - 1; j > 3; --j) {\n+          c = polynoms[j][i] + c * theta05 / (j - 3);\n+        }\n+        interpolatedState[i] += t4 * c;\n+      }\n+    }\n+\n+  }\n+    \n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    int dimension = currentState.length;\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes (but not the temporary vectors)\n+    out.writeInt(currentDegree);\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        out.writeDouble(polynoms[k][l]);\n+      }\n+    }\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+    int dimension = currentState.length;\n+\n+    // read the local attributes\n+    int degree = in.readInt();\n+    resetTables(degree);\n+    currentDegree = degree;\n+\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        polynoms[k][l] = in.readDouble();\n+      }\n+    }\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      IOException ioe = new IOException();\n+      ioe.initCause(e);\n+      throw ioe;\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = 7320613236731409847L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/HighamHall54Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the 5(4) Higham and Hall integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step.</p>\n+\n+ * @version $Id: HighamHall54Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class HighamHall54Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = new String(\"Higham-Hall 5(4)\");\n+\n+  private static final double[] c = {\n+    2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {2.0/9.0},\n+    {1.0/12.0, 1.0/4.0},\n+    {1.0/8.0, 0.0, 3.0/8.0},\n+    {91.0/500.0, -27.0/100.0, 78.0/125.0, 8.0/125.0},\n+    {-11.0/20.0, 27.0/20.0, 12.0/5.0, -36.0/5.0, 5.0},\n+    {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n+  };\n+\n+  private static final double[] b = {\n+    1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n+  };\n+\n+  private static final double[] e = {\n+    -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(double minStep, double maxStep,\n+                                double scalAbsoluteTolerance,\n+                                double scalRelativeTolerance) {\n+    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(double minStep, double maxStep,\n+                                double[] vecAbsoluteTolerance,\n+                                double[] vecRelativeTolerance) {\n+    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = e[0] * yDotK[0][j];\n+      for (int l = 1; l < e.length; ++l) {\n+        errSum += e[l] * yDotK[l][j];\n+      }\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/HighamHall54StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Higham and Hall integrator.\n+ *\n+ * @see HighamHall54Integrator\n+ *\n+ * @version $Id: HighamHall54StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class HighamHall54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public HighamHall54StepInterpolator() {\n+    super();\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new HighamHall54StepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double theta2 = theta * theta;\n+\n+    double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+    double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+    double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+    double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+    double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           + b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i]\n+                           + b4 * yDotK[4][i] + b5 * yDotK[5][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -3583240427587318654L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/IntegratorException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered during integration\n+ * @author Luc Maisonobe\n+ * @version $Id: IntegratorException.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class IntegratorException\n+  extends MantissaException {\n+    \n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public IntegratorException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  private static final long serialVersionUID = -1390328069787882608L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/MidpointIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a second order Runge-Kutta integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0\n+ *   1/2 | 1/2   0\n+ *       |----------\n+ *       |  0    1\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+\n+ * @version $Id: MidpointIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MidpointIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = new String(\"midpoint\");\n+\n+  private static final double[] c = {\n+    1.0 / 2.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 }\n+  };\n+\n+  private static final double[] b = {\n+    0.0, 1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a midpoint integrator with the given step.\n+   * @param step integration step\n+   */\n+  public MidpointIntegrator(double step) {\n+    super(false, c, a, b, new MidpointStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/MidpointStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a step interpolator for second order\n+ * Runge-Kutta integrator.\n+\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: MidpointStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class MidpointStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public MidpointStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new MidpointStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double coeff1 = oneMinusThetaH * theta;\n+    double coeff2 = oneMinusThetaH * (1.0 + theta);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           + coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -865524111506042509L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaFehlbergIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the common part of all Runge-Kutta-Fehlberg\n+ * integrators for Ordinary Differential Equations.\n+\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+\n+ * @version $Id: RungeKuttaFehlbergIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class RungeKuttaFehlbergIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected RungeKuttaFehlbergIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double minStep, double maxStep,\n+                                         double scalAbsoluteTolerance,\n+                                         double scalRelativeTolerance) {\n+\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    this.safety = 0.9;\n+\n+    // set the default values of the algorithm control parameters\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected RungeKuttaFehlbergIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double   minStep, double maxStep,\n+                                         double[] vecAbsoluteTolerance,\n+                                         double[] vecRelativeTolerance) {\n+\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    this.safety = 0.9;\n+\n+    // set the default values of the algorithm control parameters\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public abstract String getName();\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(double safety) {\n+    this.safety = safety;\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0,\n+                        double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\"\n+                                    + \" state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+    \n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    double  currentT  = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    boolean lastStep;\n+    handler.reset();\n+    do {\n+\n+      interpolator.shift();\n+\n+      double h     = 0;\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(currentT, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance;\n+            }\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                currentT, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        h = hNew;\n+\n+        // step adjustment near bounds\n+        if ((forward && (currentT + h > t))\n+            || ((! forward) && (currentT + h < t))) {\n+          h = t - currentT;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + h * sum;\n+          }\n+\n+          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + h * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, h);\n+        if (error <= 1.0) {\n+\n+          // Switching functions handling\n+          interpolator.storeTime(currentT + h);\n+          if (switchesHandler.evaluateStep(interpolator)) {\n+            // reject the step to match exactly the next switch time\n+            hNew = switchesHandler.getEventTime() - currentT;\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          double factor = Math.min(maxGrowth,\n+                                   Math.max(minReduction,\n+                                            safety * Math.pow(error, exp)));\n+          hNew = filterStep(h * factor, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      currentT += h;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      switchesHandler.stepAccepted(currentT, y);\n+      if (switchesHandler.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = forward ? (currentT >= t) : (currentT <= t);\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(currentT);\n+      handler.handleStep(interpolator, lastStep);\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      switchesHandler.reset(currentT, y);\n+\n+      if (! lastStep) {\n+        // stepsize control for next step\n+        double  factor     = Math.min(maxGrowth,\n+                                      Math.max(minReduction,\n+                                               safety * Math.pow(error, exp)));\n+        double  scaledH    = h * factor;\n+        double  nextT      = currentT + scaledH;\n+        boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, nextIsLast);\n+      }\n+\n+    } while (! lastStep);\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the common part of all fixed step Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+\n+ * <p>These methods are explicit Runge-Kutta methods, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ * </pre>\n+ * </p>\n+\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: RungeKuttaIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class RungeKuttaIntegrator\n+  implements FirstOrderIntegrator {\n+\n+  /** Simple constructor.\n+   * Build a Runge-Kutta integrator with the given\n+   * step. The default step handler does nothing.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param step integration step\n+   */\n+  protected RungeKuttaIntegrator(boolean fsal,\n+                                 double[] c, double[][] a, double[] b,\n+                                 RungeKuttaStepInterpolator prototype,\n+                                 double step) {\n+    this.fsal       = fsal;\n+    this.c          = c;\n+    this.a          = a;\n+    this.b          = b;\n+    this.prototype  = prototype;\n+    this.step       = step;\n+    handler         = DummyStepHandler.getInstance();\n+    switchesHandler = new SwitchingFunctionsHandler();\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public abstract String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+    this.handler = handler;\n+  }\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler() {\n+    return handler;\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    switchesHandler.add(function, maxCheckInterval, convergence);\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0,\n+                        double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\"\n+                                    + \" state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+    \n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // recompute the step\n+    double  currentT  = t0;\n+    long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));\n+    double  h         = (t - t0) / nbStep;\n+    boolean firstTime = true;\n+    boolean lastStep  = false;\n+    handler.reset();\n+    for (long i = 0; ! lastStep; ++i) {\n+\n+      interpolator.shift();\n+\n+      boolean needUpdate = false;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(currentT, y, yDotK[0]);\n+          firstTime = false;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + h * sum;\n+          }\n+\n+          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + h * sum;\n+        }\n+\n+        // Switching functions handling\n+        interpolator.storeTime(currentT + h);\n+        if (switchesHandler.evaluateStep(interpolator)) {\n+          needUpdate = true;\n+          h = switchesHandler.getEventTime() - currentT;\n+        } else {\n+          loop = false;\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      currentT += h;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      switchesHandler.stepAccepted(currentT, y);\n+      if (switchesHandler.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = (i == (nbStep - 1));\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(currentT);\n+      handler.handleStep(interpolator, lastStep);\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      switchesHandler.reset(currentT, y);\n+\n+      if (needUpdate) {\n+        // a switching function has changed the step\n+        // we need to recompute stepsize\n+        nbStep = Math.max(1l, Math.abs(Math.round((t - currentT) / step)));\n+        h = (t - currentT) / nbStep;\n+        i = -1;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Integration step. */\n+  private double step;\n+\n+  /** Step handler. */\n+  private StepHandler handler;\n+\n+  /** Switching functions handler. */\n+  protected SwitchingFunctionsHandler switchesHandler;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for Runge-Kutta and Runge-Kutta-Fehlberg\n+ * integrators.\n+ *\n+ * @see RungeKuttaIntegrator\n+ * @see RungeKuttaFehlbergIntegrator\n+ *\n+ * @version $Id: RungeKuttaStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+abstract class RungeKuttaStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} and {@link\n+   * RungeKuttaFehlbergIntegrator} classes uses the prototyping design\n+   * pattern to create the step interpolators by cloning an\n+   * uninitialized model and latter initializing the copy.\n+   */\n+  protected RungeKuttaStepInterpolator() {\n+    super();\n+    yDotK     = null;\n+    equations = null;\n+  }\n+\n+  /** Copy constructor.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * @param interpolator interpolator to copy from.\n+\n+  */\n+  public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState != null) {\n+      int dimension = currentState.length;\n+\n+      yDotK = new double[interpolator.yDotK.length][];\n+      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n+        yDotK[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotK[k], 0,\n+                         yDotK[k], 0, dimension);\n+      }\n+\n+    } else {\n+      yDotK = null;\n+    }\n+\n+    // we cannot keep any reference to the equations in the copy\n+    // the interpolator should have been finalized before\n+    equations = null;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n+   * than their counterpart step interpolators. So the interpolator\n+   * should perform the last evaluations they need by themselves. The\n+   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n+   * RungeKuttaFehlbergIntegrator RungeKuttaFehlbergIntegrator}\n+   * abstract classes call this method in order to let the step\n+   * interpolator perform the evaluations it needs. These evaluations\n+   * will be performed during the call to <code>doFinalize</code> if\n+   * any, i.e. only if the step handler either calls the {@link\n+   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n+   * {@link AbstractStepInterpolator#getInterpolatedState\n+   * getInterpolatedState} method (for an interpolator which needs a\n+   * finalization) or if it clones the step interpolator.</p>\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+    reinitialize(y, forward);\n+    this.yDotK = yDotK;\n+    this.equations = equations;\n+  }\n+\n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes\n+    out.writeInt(yDotK.length);\n+    for (int k = 0; k < yDotK.length; ++k) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        out.writeDouble(yDotK[k][i]);\n+      }\n+    }\n+\n+    // we do not save any reference to the equations\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+\n+    // read the local attributes\n+    int kMax = in.readInt();\n+    yDotK = new double[kMax][];\n+    for (int k = 0; k < kMax; ++k) {\n+      yDotK[k] = new double[currentState.length];\n+      for (int i = 0; i < currentState.length; ++i) {\n+        yDotK[k][i] = in.readDouble();\n+      }\n+    }\n+\n+    equations = null;\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      IOException ioe = new IOException();\n+      ioe.initCause(e);\n+      throw ioe;\n+    }\n+\n+  }\n+\n+  /** Slopes at the intermediate points */\n+  protected double[][] yDotK;\n+\n+  /** Reference to the differential equations beeing integrated. */\n+  protected FirstOrderDifferentialEquations equations;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SecondOrderDifferentialEquations.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This interface represents a second order differential equations set.\n+\n+ * <p>This interface should be implemented by all real second order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link SecondOrderIntegrator#integrate} method.</p>\n+\n+ * <p>A second order differential equations problem, as seen by an\n+ * integrator is the second time derivative <code>d2Y/dt^2</code> of a\n+ * state vector <code>Y</code>, both being one dimensional\n+ * arrays. From the integrator point of view, this derivative depends\n+ * only on the current time <code>t</code>, on the state vector\n+ * <code>Y</code> and on the first time derivative of the state\n+ * vector.</p>\n+\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+\n+ * @see SecondOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see FirstOrderDifferentialEquations\n+ * @see org.spaceroots.mantissa.utilities.ArraySliceMappable\n+\n+ * @version $Id: SecondOrderDifferentialEquations.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SecondOrderDifferentialEquations {\n+\n+  /** Get the dimension of the problem.\n+   * @return dimension of the problem\n+   */\n+  public int getDimension();\n+    \n+  /** Get the current time derivative of the state vector.\n+   * @param t current value of the independant <I>time</I> variable\n+   * @param y array containing the current value of the state vector\n+   * @param yDot array containing the current value of the first derivative\n+   * of the state vector\n+   * @param yDDot placeholder array where to put the second time derivative\n+   * of the state vector\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                       double[] yDDot)\n+  throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SecondOrderIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This interface represents a second order integrator for\n+ * differential equations.\n+\n+ * <p>The classes which are devoted to solve second order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * SecondOrderDifferentialEquations} interface.</p>\n+\n+ * @see SecondOrderDifferentialEquations\n+\n+ * @version $Id: SecondOrderIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SecondOrderIntegrator {\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler);\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler();\n+\n+  /** Integrate the differential equations up to the given time\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param yDot0 initial value of the first derivative of the state\n+   * vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each\n+   * successful step (and hence at the end of integration), can be the\n+   * same object as y0\n+   * @param yDot placeholder where to put the first derivative of\n+   * the state vector at time t, can be the same object as yDot0\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void integrate(SecondOrderDifferentialEquations equations,\n+                        double t0, double[] y0, double[] yDot0,\n+                        double t, double[] y, double[] yDot)\n+  throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/StepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepInterpolator\n+\n+ * @version $Id: StepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface StepHandler {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  public boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link ContinuousOutputModel ContinuousOutputModel} class does),\n+   * it should build a local copy using the clone method of the\n+   * interpolator and store this copy. Keeping only a reference to the\n+   * interpolator and reusing it will result in unpredictable\n+   * behaviour (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import java.io.Externalizable;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Id: StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface StepInterpolator\n+  extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime();\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime();\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime();\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed\n+   * (it was not allowed up to version 5.4 of Mantissa), but should be\n+   * used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException;\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState();\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or switching function\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward();\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/StepNormalizer.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class wraps an object implementing {@link FixedStepHandler}\n+ * into a {@link StepHandler}.\n+\n+ * <p>This wrapper allows to use fixed step handlers with general\n+ * integrators which cannot guaranty their integration steps will\n+ * remain constant and therefore only accept general step\n+ * handlers.</p>\n+\n+ * <p>The stepsize used is selected at construction time. The {@link\n+ * FixedStepHandler#handleStep handleStep} method of the underlying\n+ * {@link FixedStepHandler} object is called at the beginning time of\n+ * the integration t0 and also at times t0+h, t0+2h, ... If the\n+ * integration range is an integer multiple of the stepsize, then the\n+ * last point handled will be the endpoint of the integration tend, if\n+ * not, the last point will belong to the interval [tend - h ;\n+ * tend].</p>\n+\n+ * <p>There is no constraint on the integrator, it can use any\n+ * timestep it needs (time steps longer or shorter than the fixed time\n+ * step and non-integer ratios are all allowed).</p>\n+\n+ * @see StepHandler\n+ * @see FixedStepHandler\n+\n+ * @version $Id: StepNormalizer.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class StepNormalizer\n+  implements StepHandler {\n+\n+  /** Simple constructor.\n+   * @param h fixed time step (sign is not used)\n+   * @param handler fixed time step handler to wrap\n+   */\n+  public StepNormalizer(double h, FixedStepHandler handler) {\n+    this.h       = Math.abs(h);\n+    this.handler = handler;\n+    reset();\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * This handler needs dense output in order to provide data at\n+   * regularly spaced steps regardless of the steps the integrator\n+   * uses, so this method always returns true.\n+   * @return always true\n+   */\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+    lastTime  = Double.NaN;\n+    lastState = null;\n+    forward   = true;\n+  }\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException {\n+\n+    double nextTime;\n+\n+    if (lastState == null) {\n+\n+      lastTime = interpolator.getPreviousTime();\n+      interpolator.setInterpolatedTime(lastTime);\n+\n+      double[] state = interpolator.getInterpolatedState();\n+      lastState = new double[state.length];\n+      System.arraycopy(state, 0, lastState, 0, lastState.length);\n+\n+      // take the integration direction into account\n+      forward = (interpolator.getCurrentTime() >= lastTime);\n+      if (! forward) {\n+        h = -h;\n+      }\n+\n+    }\n+\n+    nextTime = lastTime + h;\n+    boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+    while (nextInStep) {\n+\n+      // output the stored previous step\n+      handler.handleStep(lastTime, lastState, false);\n+\n+      // store the next step\n+      lastTime = nextTime;\n+      interpolator.setInterpolatedTime(lastTime);\n+      System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                       lastState, 0, lastState.length);\n+\n+      nextTime  += h;\n+      nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+\n+    }\n+\n+    if (isLast) {\n+      // there will be no more steps,\n+      // the stored one should be flagged as being the last\n+      handler.handleStep(lastTime, lastState, true);\n+    }\n+\n+  }\n+\n+  /** Fixed time step. */\n+  private double h;\n+\n+  /** Underlying step handler. */\n+  private FixedStepHandler handler;\n+\n+  /** Last step time. */\n+  private double lastTime;\n+\n+  /** Last State vector. */\n+  private double[] lastState;\n+\n+  /** Integration direction indicator. */\n+  private boolean forward;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchState.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+\n+import org.spaceroots.mantissa.roots.ConvergenceChecker;\n+import org.spaceroots.mantissa.roots.RootsFinder;\n+import org.spaceroots.mantissa.roots.BrentSolver;\n+\n+/** This class handles the state for one {@link SwitchingFunction\n+ * switching function} during integration steps.\n+ *\n+ * <p>Each time the integrator proposes a step, the switching function\n+ * should be checked. This class handles the state of one function\n+ * during one integration step, with references to the state at the\n+ * end of the preceding step. This information is used to determine if\n+ * the function should trigger an event or not during the proposed\n+ * step (and hence the step should be reduced to ensure the event\n+ * occurs at a bound rather than inside the step).</p>\n+ *\n+ * @version $Id: SwitchState.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+class SwitchState\n+  implements ComputableFunction, ConvergenceChecker {\n+\n+  /** Switching function. */\n+  private SwitchingFunction function;\n+\n+  /** Maximal time interval between switching function checks. */\n+  private double maxCheckInterval;\n+\n+  /** Convergence threshold for event localisation. */\n+  private double convergence;\n+\n+  /** Time at the beginning of the step. */\n+  private double t0;\n+\n+  /** Value of the switching function at the beginning of the step. */\n+  private double g0;\n+\n+  /** Simulated sign of g0 (we cheat when crossing events). */\n+  private boolean g0Positive;\n+\n+  /** Indicator of event expected during the step. */\n+  private boolean pendingEvent;\n+\n+  /** Occurrence time of the pending event. */\n+  private double pendingEventTime;\n+\n+  /** Occurrence time of the previous event. */\n+  private double previousEventTime;\n+\n+  /** Variation direction around pending event.\n+   *  (this is considered with respect to the integration direction)\n+   */\n+  private boolean increasing;\n+\n+  /** Next action indicator. */\n+  private int nextAction;\n+\n+  /** Interpolator valid for the current step. */\n+  private StepInterpolator interpolator;\n+\n+  /** Simple constructor.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public SwitchState(SwitchingFunction function,\n+                     double maxCheckInterval, double convergence) {\n+    this.function         = function;\n+    this.maxCheckInterval = maxCheckInterval;\n+    this.convergence      = Math.abs(convergence);\n+\n+    // some dummy values ...\n+    t0                = Double.NaN;\n+    g0                = Double.NaN;\n+    g0Positive        = true;\n+    pendingEvent      = false;\n+    pendingEventTime  = Double.NaN;\n+    previousEventTime = Double.NaN;\n+    increasing        = true;\n+    nextAction        = SwitchingFunction.CONTINUE;\n+\n+    interpolator      = null;\n+\n+  }\n+\n+  /** Reinitialize the beginning of the step.\n+   * @param t0 value of the independant <i>time</i> variable at the\n+   * beginning of the step\n+   * @param y0 array containing the current value of the state vector\n+   * at the beginning of the step\n+   */\n+  public void reinitializeBegin(double t0, double[] y0) {\n+    this.t0 = t0;\n+    g0 = function.g(t0, y0);\n+    g0Positive = (g0 >= 0);\n+  }\n+\n+  /** Evaluate the impact of the proposed step on the switching function.\n+   * @param interpolator step interpolator for the proposed step\n+   * @return true if the switching function triggers an event before\n+   * the end of the proposed step (this implies the step should be\n+   * rejected)\n+   */\n+  public boolean evaluateStep(StepInterpolator interpolator) {\n+\n+    try {\n+\n+      this.interpolator = interpolator;\n+\n+      double t1 = interpolator.getCurrentTime();\n+      int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+      double h  = (t1 - t0) / n;\n+\n+      double ta = t0;\n+      double ga = g0;\n+      double tb = t0 + ((t1 > t0) ? convergence : -convergence);\n+      for (int i = 0; i < n; ++i) {\n+\n+        // evaluate function value at the end of the substep\n+        tb += h;\n+        interpolator.setInterpolatedTime(tb);\n+        double gb = function.g(tb, interpolator.getInterpolatedState());\n+\n+        // check events occurrence\n+        if (g0Positive ^ (gb >= 0)) {\n+          // there is a sign change: an event is expected during this step\n+\n+          // variation direction, with respect to the integration direction\n+          increasing = (gb >= ga);\n+\n+          RootsFinder solver = new BrentSolver();\n+          if (solver.findRoot(this, this, 1000, ta, ga, tb, gb)) {\n+            if (Double.isNaN(previousEventTime)\n+                || (Math.abs(previousEventTime - solver.getRoot()) > convergence)) {\n+              pendingEventTime = solver.getRoot();\n+              if (pendingEvent\n+                  && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                // we were already waiting for this event which was\n+                // found during a previous call for a step that was\n+                // rejected, this step must now be accepted since it\n+                // properly ends exactly at the event occurrence\n+                return false;\n+              }\n+              // either we were not waiting for the event or it has\n+              // moved in such a way the step cannot be accepted\n+              pendingEvent = true;\n+              return true;\n+            }\n+          } else {\n+            throw new RuntimeException(\"internal error\");\n+          }\n+\n+        } else {\n+          // no sign change: there is no event for now\n+          ta = tb;\n+          ga = gb;\n+        }\n+\n+      }\n+\n+      // no event during the whole step\n+      pendingEvent     = false;\n+      pendingEventTime = Double.NaN;\n+      return false;\n+\n+    } catch (DerivativeException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    } catch (FunctionException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+  }\n+\n+  /** Get the occurrence time of the event triggered in the current\n+   * step.\n+   * @return occurrence time of the event triggered in the current\n+   * step.\n+   */\n+  public double getEventTime() {\n+    return pendingEventTime;\n+  }\n+\n+  /** Acknowledge the fact the step has been accepted by the integrator.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * end of the step\n+   * @param y array containing the current value of the state vector\n+   * at the end of the step\n+   */\n+  public void stepAccepted(double t, double[] y) {\n+\n+    t0 = t;\n+    g0 = function.g(t, y);\n+\n+    if (pendingEvent) {\n+      // force the sign to its value \"just after the event\"\n+      previousEventTime = t;\n+      g0Positive        = increasing;\n+      nextAction        = function.eventOccurred(t, y);\n+    } else {\n+      g0Positive = (g0 >= 0);\n+      nextAction = SwitchingFunction.CONTINUE;\n+    }\n+  }\n+\n+  /** Check if the integration should be stopped at the end of the\n+   * current step.\n+   * @return true if the integration should be stopped\n+   */\n+  public boolean stop() {\n+    return nextAction == SwitchingFunction.STOP;\n+  }\n+\n+  /** Let the switching function reset the state if it wants.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * beginning of the next step\n+   * @param y array were to put the desired state vector at the beginning\n+   * of the next step\n+   */\n+  public void reset(double t, double[] y) {\n+    if (pendingEvent) {\n+      if (nextAction == SwitchingFunction.RESET) {\n+        function.resetState(t, y);\n+      }\n+      pendingEvent      = false;\n+      pendingEventTime  = Double.NaN;\n+    }\n+  }\n+\n+  /** Get the value of the g function at the specified time.\n+   * @param t current time\n+   * @return g function value\n+   * @exception FunctionException if the underlying interpolator is\n+   * unable to interpolate the state at the specified time\n+   */\n+  public double valueAt(double t)\n+    throws FunctionException {\n+    try {\n+      interpolator.setInterpolatedTime(t);\n+      return function.g(t, interpolator.getInterpolatedState());\n+    } catch (DerivativeException e) {\n+      throw new FunctionException(e);\n+    }\n+  }\n+\n+  /** Check if the event time has been found.\n+   * @param x0 lower bound of the interval\n+   * @param y0 value of the function at x0\n+   * @param x1 higher bound of the interval\n+   * @param y1 value of the function at x1\n+   * @return convergence indicator\n+   */\n+  public int converged(double x0, double y0, double x1, double y1) {\n+    if (Math.abs(x1 - x0) < convergence) {\n+      return (Math.abs(y0) < Math.abs(y1))\n+        ? ConvergenceChecker.LOW : ConvergenceChecker.HIGH;\n+    }\n+    return ConvergenceChecker.NONE;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/** This interface represents a switching function.\n+ *\n+ * <p>A switching function allows to handle discrete events in\n+ * integration problems. These events occur for example when the\n+ * integration process should be stopped as some value is reached\n+ * (G-stop facility), or when the derivatives has\n+ * discontinuities. These events are traditionally defined as\n+ * occurring when a <code>g</code> function sign changes.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independant <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time. The integrators will take care to\n+ * avoid sign changes inside the steps, they will reduce the step size\n+ * when such an event is detected in order to put this event exactly\n+ * at the end of the current step. This guarantees that step\n+ * interpolation (which always has a one step scope) is relevant even\n+ * in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this feature is available on all integrators, including\n+ * fixed step ones).</p>\n+ *\n+ * @version $Id: SwitchingFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface SwitchingFunction {\n+\n+  /** Stop indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should be\n+   * stopped after the event ending the current step.</p>\n+   */\n+  public static final int STOP = 0;\n+\n+  /** Reset indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new state\n+   * vector (which will be retrieved through the {@link #resetState\n+   * resetState} method).</p>\n+   */\n+  public static final int RESET = 1;\n+\n+  /** Continue indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should go\n+   * on after the event ending the current step.</p>\n+   */\n+  public static final int CONTINUE = 2;\n+\n+  /** Compute the value of the switching function.\n+\n+   * <p>Discrete events are generated when the sign of this function\n+   * changes, the integrator will take care to change the stepsize in\n+   * such a way these events occur exactly at step boundaries. This\n+   * function must be continuous, as the integrator will need to find\n+   * its roots to locate the events.</p>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return value of the g function\n+   */\n+  public double g(double t, double[] y);\n+\n+  /** Handle an event and choose what to do next.\n+\n+   * <p>This method is called when the integrator has accepted a step\n+   * ending exactly on a sign change of the function, just before the\n+   * step handler itself is called. It allows the user to update his\n+   * internal data to acknowledge the fact the event has been handled\n+   * (for example setting a flag to switch the derivatives computation\n+   * in case of discontinuity), and it allows to direct the integrator\n+   * to either stop or continue integration, possibly with a reset\n+   * state.</p>\n+\n+   * <p>If {@link #STOP} is returned, the step handler will be called\n+   * with the <code>isLast</code> flag of the {@link\n+   * StepHandler#handleStep handleStep} method set to true. If {@link\n+   * #RESET} is returned, the {@link #resetState resetState} method\n+   * will be called once the step handler has finished its task.</p>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return indication of what the integrator should do next, this\n+   * value must be one of {@link #STOP}, {@link #RESET} or {@link\n+   * #CONTINUE}\n+   */\n+  public int eventOccurred(double t, double[] y);\n+  \n+  /** Reset the state prior to continue the integration.\n+\n+   * <p>This method is called after the step handler has returned and\n+   * before the next step is started, but only when {@link\n+   * #eventOccurred} has itself returned the {@link #RESET}\n+   * indicator. It allows the user to reset the state vector for the\n+   * next step, without perturbing the step handler of the finishing\n+   * step. If the {@link #eventOccurred} never returns the {@link\n+   * #RESET} indicator, this function will never be called, and it is\n+   * safe to leave its body empty.</p>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * the new state should be put in the same array\n+   */\n+  public void resetState(double t, double[] y);\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunctionsHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import org.spaceroots.mantissa.ode.DerivativeException;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+/** This class handles several {@link SwitchingFunction switching\n+ * functions} during integration.\n+ *\n+ * @see SwitchingFunction\n+ *\n+ * @version $Id: SwitchingFunctionsHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public class SwitchingFunctionsHandler {\n+\n+  /** Simple constructor.\n+   * Create an empty handler\n+   */\n+  public SwitchingFunctionsHandler() {\n+    functions   = new ArrayList();\n+    first       = null;\n+    initialized = false;\n+  }\n+\n+  /** Add a switching function.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void add(SwitchingFunction function,\n+                  double maxCheckInterval, double convergence) {\n+    functions.add(new SwitchState(function, maxCheckInterval, convergence));\n+  }\n+\n+  /** Check if the handler does not have any condition.\n+   * @return true if handler is empty\n+   */\n+  public boolean isEmpty() {\n+    return functions.isEmpty();\n+  }\n+\n+  /** Evaluate the impact of the proposed step on all handled\n+   * switching functions.\n+   * @param interpolator step interpolator for the proposed step\n+   * @return true if at least one switching function triggers an event\n+   * before the end of the proposed step (this implies the step should\n+   * be rejected)\n+   */\n+  public boolean evaluateStep(StepInterpolator interpolator) {\n+\n+    try {\n+\n+      first = null;\n+      if (functions.isEmpty()) {\n+        // there is nothing to do, return now to avoid setting the\n+        // interpolator time (and hence avoid unneeded calls to the\n+        // user function due to interpolator finalization)\n+        return false;\n+      }\n+\n+      if (! initialized) {\n+\n+        // initialize the switching functions\n+        double t0 = interpolator.getPreviousTime();\n+        interpolator.setInterpolatedTime(t0);\n+        double [] y = interpolator.getInterpolatedState();\n+        for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+          ((SwitchState) iter.next()).reinitializeBegin(t0, y);\n+        }\n+\n+        initialized = true;\n+\n+      }\n+\n+      // check events occurrence\n+      for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+\n+        SwitchState state = (SwitchState) iter.next();\n+        if (state.evaluateStep(interpolator)) {\n+          if (first == null) {\n+            first = state;\n+          } else {\n+            if (interpolator.isForward()) {\n+              if (state.getEventTime() < first.getEventTime()) {\n+                first = state;\n+              }\n+            } else {\n+              if (state.getEventTime() > first.getEventTime()) {\n+                first = state;\n+              }\n+            }\n+          }\n+        }\n+\n+      }\n+\n+      return first != null;\n+\n+    } catch (DerivativeException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+  }\n+\n+  /** Get the occurrence time of the first event triggered in the\n+   * last evaluated step.\n+   * @return occurrence time of the first event triggered in the last\n+   * evaluated step, or </code>Double.NaN</code> if no event is\n+   * triggered\n+   */\n+  public double getEventTime() {\n+    return (first == null) ? Double.NaN : first.getEventTime();\n+  }\n+\n+  /** Inform the switching functions that the step has been accepted\n+   * by the integrator.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * end of the step\n+   * @param y array containing the current value of the state vector\n+   * at the end of the step\n+   */\n+  public void stepAccepted(double t, double[] y) {\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      ((SwitchState) iter.next()).stepAccepted(t, y);\n+    }\n+  }\n+\n+  /** Check if the integration should be stopped at the end of the\n+   * current step.\n+   * @return true if the integration should be stopped\n+   */\n+  public boolean stop() {\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      if (((SwitchState) iter.next()).stop()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** Let the switching functions reset the state if they want.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * beginning of the next step\n+   * @param y array were to put the desired state vector at the beginning\n+   * of the next step\n+   */\n+  public void reset(double t, double[] y) {\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      ((SwitchState) iter.next()).reset(t, y);\n+    }\n+  }\n+\n+  /** Switching functions. */\n+  private ArrayList functions;\n+\n+  /** First active switching function. */\n+  private SwitchState first;\n+\n+  /** Initialization indicator. */\n+  private boolean initialized;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ThreeEighthesIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements the 3/8 fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations.\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/3 | 1/3   0    0    0\n+ *   2/3 |-1/3   1    0    0\n+ *    1  |  1   -1    1    0\n+ *       |--------------------\n+ *       | 1/8  3/8  3/8  1/8\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: ThreeEighthesIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ThreeEighthesIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = new String(\"3/8\");\n+\n+  private static final double[] c = {\n+    1.0 / 3.0, 2.0 / 3.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {  1.0 / 3.0 },\n+    { -1.0 / 3.0, 1.0 },\n+    {  1.0, -1.0, 1.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a 3/8 integrator with the given step.\n+   * @param step integration step\n+   */\n+  public ThreeEighthesIntegrator(double step) {\n+    super(false, c, a, b, new ThreeEighthesStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ThreeEighthesStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class implements a step interpolator for the 3/8 fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n+ *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n+ *                                      + 3 (1 +   theta)             y'_3\n+ *                                      +   (1 +   theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: ThreeEighthesStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class ThreeEighthesStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public ThreeEighthesStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new ThreeEighthesStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta2 = 4 * theta * theta;\n+    double s          = oneMinusThetaH / 8.0;\n+    double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+    double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+    double coeff3     = 3 * s * (1 + theta);\n+    double coeff4     = s * (1 + theta + fourTheta2);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n+                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  private static final long serialVersionUID = -3345024435978721931L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/ConvergenceChecker.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+/** This interface specifies how to check if a {@link\n+ * DirectSearchOptimizer direct search method} has converged.\n+\n+ * <p>Deciding if convergence has been reached is a problem-dependent\n+ * issue. The user should provide a class implementing this interface\n+ * to allow the optimization algorithm to stop its search according to\n+ * the problem at hand.</p>\n+\n+ * @version $Id: ConvergenceChecker.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface ConvergenceChecker {\n+\n+  /** Check if the optimization algorithm has converged on the simplex.\n+   * @param simplex ordered simplex (all points in the simplex have\n+   * been eavluated and are sorted from lowest to largest cost)\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  public boolean converged (PointCostPair[] simplex);\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/CostException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by cost functions.\n+\n+ * @version $Id: CostException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class CostException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception with a default message\n+   */\n+  public CostException() {\n+    super(\"cost exception\");\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception with the specified message\n+   * @param message exception message\n+   */\n+  public CostException(String message) {\n+    super(message);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a cause\n+   * @param cause cause of this exception\n+   */\n+  public CostException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception from a message and a cause\n+   * @param message exception message\n+   * @param cause cause of this exception\n+   */\n+  public CostException(String message, Throwable cause) {\n+    super(message, cause);\n+  }\n+\n+  private static final long serialVersionUID = -6099968585593678071L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/CostFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+/** This interface represents a cost function to be minimized.\n+ * @author Luc Maisonobe\n+ * @version $Id: CostFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public interface CostFunction {\n+\n+\n+  /** Compute the cost associated to the given parameters array.\n+   * @param x parameters array\n+   * @return cost associated to the parameters array\n+   * @exception CostException if no cost can be computed for the parameters\n+   * @see PointCostPair\n+   */\n+  public double cost(double[] x) throws CostException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/DirectSearchOptimizer.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import org.spaceroots.mantissa.random.RandomVectorGenerator;\n+import org.spaceroots.mantissa.random.UncorrelatedRandomVectorGenerator;\n+import org.spaceroots.mantissa.random.CorrelatedRandomVectorGenerator;\n+import org.spaceroots.mantissa.random.UniformRandomGenerator;\n+import org.spaceroots.mantissa.random.VectorialSampleStatistics;\n+import org.spaceroots.mantissa.random.NotPositiveDefiniteMatrixException;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+/** This class implements simplex-based direct search optimization\n+ * algorithms.\n+\n+ * <p>Direct search method only use cost function values, they don't\n+ * need derivatives and don't either try to compute approximation of\n+ * the derivatives. According to a 1996 paper by Margaret H. Wright\n+ * (<a href=\"http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz\">Direct\n+ * Search Methods: Once Scorned, Now Respectable</a>), they are used\n+ * when either the computation of the derivative is impossible (noisy\n+ * functions, unpredictable dicontinuities) or difficult (complexity,\n+ * computation cost). In the first cases, rather than an optimum, a\n+ * <em>not too bad</em> point is desired. In the latter cases, an\n+ * optimum is desired but cannot be reasonably found. In all cases\n+ * direct search methods can be useful.</p>\n+\n+ * <p>Simplex-based direct search methods are based on comparison of\n+ * the cost function values at the vertices of a simplex (which is a\n+ * set of n+1 points in dimension n) that is updated by the algorithms\n+ * steps.</p>\n+\n+ * <p>The instances can be built either in single-start or in\n+ * multi-start mode. Multi-start is a traditional way to try to avoid\n+ * beeing trapped in a local minimum and miss the global minimum of a\n+ * function. It can also be used to verify the convergence of an\n+ * algorithm. In multi-start mode, the {@link #minimizes(CostFunction,\n+ * int, ConvergenceChecker, double[], double[]) minimizes}\n+ * method returns the best minimum found after all starts, and the\n+ * {@link #getMinima getMinima} method can be used to retrieve all\n+ * minima from all starts (including the one already provided by the\n+ * {@link #minimizes(CostFunction, int, ConvergenceChecker, double[],\n+ * double[]) minimizes} method).</p>\n+\n+ * <p>This class is the base class performing the boilerplate simplex\n+ * initialization and handling. The simplex update by itself is\n+ * performed by the derived classes according to the implemented\n+ * algorithms.</p>\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: DirectSearchOptimizer.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see CostFunction\n+ * @see NelderMead\n+ * @see MultiDirectional\n+ */\n+public abstract class DirectSearchOptimizer {\n+\n+  /** Simple constructor.\n+   */\n+  protected DirectSearchOptimizer() {\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The initial simplex is built from two vertices that are\n+   * considered to represent two opposite vertices of a box parallel\n+   * to the canonical axes of the space. The simplex is the subset of\n+   * vertices encountered while going from vertexA to vertexB\n+   * travelling along the box edges only. This can be seen as a scaled\n+   * regular simplex using the projected separation between the given\n+   * points as the scaling factor along each coordinate axis.</p>\n+   * <p>The optimization is performed in single-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param vertexA first vertex\n+   * @param vertexB last vertex\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 double[] vertexA, double[] vertexB)\n+    throws CostException, NoConvergenceException {\n+\n+    // set up optimizer\n+    buildSimplex(vertexA, vertexB);\n+    setSingleStart();\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The initial simplex is built from two vertices that are\n+   * considered to represent two opposite vertices of a box parallel\n+   * to the canonical axes of the space. The simplex is the subset of\n+   * vertices encountered while going from vertexA to vertexB\n+   * travelling along the box edges only. This can be seen as a scaled\n+   * regular simplex using the projected separation between the given\n+   * points as the scaling factor along each coordinate axis.</p>\n+   * <p>The optimization is performed in multi-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param vertexA first vertex\n+   * @param vertexB last vertex\n+   * @param starts number of starts to perform (including the\n+   * first one), multi-start is disabled if value is less than or\n+   * equal to 1\n+   * @param seed seed for the random vector generator\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 double[] vertexA, double[] vertexB,\n+                                 int starts, long seed)\n+    throws CostException, NoConvergenceException {\n+\n+    // set up the simplex travelling around the box\n+    buildSimplex(vertexA, vertexB);\n+\n+    // we consider the simplex could have been produced by a generator\n+    // having its mean value at the center of the box, the standard\n+    // deviation along each axe beeing the corresponding half size\n+    double[] mean              = new double[vertexA.length];\n+    double[] standardDeviation = new double[vertexA.length];\n+    for (int i = 0; i < vertexA.length; ++i) {\n+      mean[i]              = 0.5 * (vertexA[i] + vertexB[i]);\n+      standardDeviation[i] = 0.5 * Math.abs(vertexA[i] - vertexB[i]);\n+    }\n+\n+    RandomVectorGenerator rvg =\n+      new UncorrelatedRandomVectorGenerator(mean, standardDeviation,\n+                                            new UniformRandomGenerator(seed));\n+    setMultiStart(starts, rvg);\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The simplex is built from all its vertices.</p>\n+   * <p>The optimization is performed in single-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param vertices array containing all vertices of the simplex\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 double[][] vertices)\n+    throws CostException, NoConvergenceException {\n+\n+    // set up optimizer\n+    buildSimplex(vertices);\n+    setSingleStart();\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The simplex is built from all its vertices.</p>\n+   * <p>The optimization is performed in multi-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param vertices array containing all vertices of the simplex\n+   * @param starts number of starts to perform (including the\n+   * first one), multi-start is disabled if value is less than or\n+   * equal to 1\n+   * @param seed seed for the random vector generator\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception NotPositiveDefiniteMatrixException if the vertices\n+   * array is degenerated\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 double[][] vertices,\n+                                 int starts, long seed)\n+    throws NotPositiveDefiniteMatrixException,\n+           CostException, NoConvergenceException {\n+\n+    // store the points into the simplex\n+    buildSimplex(vertices);\n+\n+    // compute the statistical properties of the simplex points\n+    VectorialSampleStatistics statistics = new VectorialSampleStatistics();\n+    for (int i = 0; i < vertices.length; ++i) {\n+      statistics.add(vertices[i]);\n+    }\n+\n+    RandomVectorGenerator rvg =\n+      new CorrelatedRandomVectorGenerator(statistics.getMean(null),\n+                                          statistics.getCovarianceMatrix(null),\n+                                          new UniformRandomGenerator(seed));\n+    setMultiStart(starts, rvg);\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The simplex is built randomly.</p>\n+   * <p>The optimization is performed in single-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param generator random vector generator\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 RandomVectorGenerator generator)\n+    throws CostException, NoConvergenceException {\n+\n+    // set up optimizer\n+    buildSimplex(generator);\n+    setSingleStart();\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Minimizes a cost function.\n+   * <p>The simplex is built randomly.</p>\n+   * <p>The optimization is performed in multi-start mode.</p>\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @param generator random vector generator\n+   * @param starts number of starts to perform (including the\n+   * first one), multi-start is disabled if value is less than or\n+   * equal to 1\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                 ConvergenceChecker checker,\n+                                 RandomVectorGenerator generator,\n+                                 int starts)\n+    throws CostException, NoConvergenceException {\n+\n+    // set up optimizer\n+    buildSimplex(generator);\n+    setMultiStart(starts, generator);\n+\n+    // compute minimum\n+    return minimizes(f, maxEvaluations, checker);\n+\n+  }\n+\n+  /** Build a simplex from two extreme vertices.\n+   * <p>The two vertices are considered to represent two opposite\n+   * vertices of a box parallel to the canonical axes of the\n+   * space. The simplex is the subset of vertices encountered while\n+   * going from vertexA to vertexB travelling along the box edges\n+   * only. This can be seen as a scaled regular simplex using the\n+   * projected separation between the given points as the scaling\n+   * factor along each coordinate axis.</p>\n+   * @param vertexA first vertex\n+   * @param vertexB last vertex\n+   */\n+  private void buildSimplex(double[] vertexA, double[] vertexB) {\n+\n+    int n = vertexA.length;\n+    simplex = new PointCostPair[n + 1];\n+\n+    // set up the simplex travelling around the box\n+    for (int i = 0; i <= n; ++i) {\n+      double[] vertex = new double[n];\n+      if (i > 0) {\n+        System.arraycopy(vertexB, 0, vertex, 0, i);\n+      }\n+      if (i < n) {\n+        System.arraycopy(vertexA, i, vertex, i, n - i);\n+      }\n+      simplex[i] = new PointCostPair(vertex);\n+    }\n+\n+  }\n+\n+  /** Build a simplex from all its points.\n+   * @param vertices array containing all vertices of the simplex\n+   */\n+  private void buildSimplex(double[][] vertices) {\n+    int n = vertices.length - 1;\n+    simplex = new PointCostPair[n + 1];\n+    for (int i = 0; i <= n; ++i) {\n+      simplex[i] = new PointCostPair(vertices[i]);\n+    }\n+  }\n+\n+  /** Build a simplex randomly.\n+   * @param generator random vector generator\n+   */\n+  private void buildSimplex(RandomVectorGenerator generator) {\n+\n+    // use first vector size to compute the number of points\n+    double[] vertex = generator.nextVector();\n+    int n = vertex.length;\n+    simplex = new PointCostPair[n + 1];\n+    simplex[0] = new PointCostPair(vertex);\n+\n+    // fill up the vertex\n+    for (int i = 1; i <= n; ++i) {\n+      simplex[i] = new PointCostPair(generator.nextVector());\n+    }\n+\n+  }\n+\n+  /** Set up single-start mode.\n+   */\n+  private void setSingleStart() {\n+    starts    = 1;\n+    generator = null;\n+    minima    = null;\n+  }\n+\n+  /** Set up multi-start mode.\n+   * @param starts number of starts to perform (including the\n+   * first one), multi-start is disabled if value is less than or\n+   * equal to 1\n+   * @param generator random vector generator to use for restarts\n+   */\n+  public void setMultiStart(int starts, RandomVectorGenerator generator) {\n+    if (starts < 2) {\n+      this.starts    = 1;\n+      this.generator = null;\n+      minima         = null;\n+    } else {\n+      this.starts    = starts;\n+      this.generator = generator;\n+      minima         = null;\n+    }\n+  }\n+\n+  /** Get all the minima found during the last call to {@link\n+   * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+   * minimizes}.\n+   * <p>The optimizer stores all the minima found during a set of\n+   * restarts when multi-start mode is enabled. The {@link\n+   * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+   * minimizes} method returns the best point only. This method\n+   * returns all the points found at the end of each starts, including\n+   * the best one already returned by the {@link #minimizes(CostFunction,\n+   * int, ConvergenceChecker, double[], double[]) minimizes} method.\n+   * The array as one element for each start as specified in the constructor\n+   * (it has one element only if optimizer has been set up for single-start).</p>\n+   * <p>The array containing the minima is ordered with the results\n+   * from the runs that did converge first, sorted from lowest to\n+   * highest minimum cost, and null elements corresponding to the runs\n+   * that did not converge (all elements will be null if the {@link\n+   * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+   * minimizes} method throwed a {@link NoConvergenceException\n+   * NoConvergenceException}).</p>\n+   * @return array containing the minima, or null if {@link\n+   * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+   * minimizes} has not been called\n+   */\n+  public PointCostPair[] getMinima() {\n+    return minima;\n+  }\n+\n+  /** Minimizes a cost function.\n+   * @param f cost function\n+   * @param maxEvaluations maximal number of function calls for each\n+   * start (note that the number will be checked <em>after</em>\n+   * complete simplices have been evaluated, this means that in some\n+   * cases this number will be exceeded by a few units, depending on\n+   * the dimension of the problem)\n+   * @param checker object to use to check for convergence\n+   * @return the point/cost pairs giving the minimal cost\n+   * @exception CostException if the cost function throws one during\n+   * the search\n+   * @exception NoConvergenceException if none of the starts did\n+   * converge (it is not thrown if at least one start did converge)\n+   */\n+  private PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                  ConvergenceChecker checker)\n+    throws CostException, NoConvergenceException {\n+\n+    this.f = f;\n+    minima = new PointCostPair[starts];\n+    \n+    // multi-start loop\n+    for (int i = 0; i < starts; ++i) {\n+\n+      evaluations = 0;\n+      evaluateSimplex();\n+\n+      for (boolean loop = true; loop;) {\n+        if (checker.converged(simplex)) {\n+          // we have found a minimum\n+          minima[i] = simplex[0];\n+          loop = false;\n+        } else if (evaluations >= maxEvaluations) {\n+          // this start did not converge, try a new one\n+          minima[i] = null;\n+          loop = false;\n+        } else {\n+          iterateSimplex();\n+        }\n+      }\n+\n+      if (i < (starts - 1)) {\n+        // restart\n+        buildSimplex(generator);\n+      }\n+\n+    }\n+\n+    // sort the minima from lowest cost to highest cost, followed by\n+    // null elements\n+    Arrays.sort(minima, pointCostPairComparator);\n+\n+    // return the found point given the lowest cost\n+    if (minima[0] == null) {\n+      throw new NoConvergenceException(\"none of the {0} start points\"\n+                                       + \" lead to convergence\",\n+                                       new String[] {\n+                                         Integer.toString(starts)\n+                                       });\n+    }\n+    return minima[0];\n+\n+  }\n+\n+  /** Compute the next simplex of the algorithm.\n+   */\n+  protected abstract void iterateSimplex()\n+    throws CostException;\n+\n+  /** Evaluate the cost on one point.\n+   * <p>A side effect of this method is to count the number of\n+   * function evaluations</p>\n+   * @param x point on which the cost function should be evaluated\n+   * @return cost at the given point\n+   * @exception CostException if no cost can be computed for the parameters\n+   */\n+  protected double evaluateCost(double[] x)\n+    throws CostException {\n+    evaluations++;\n+    return f.cost(x);\n+  }\n+\n+  /** Evaluate all the non-evaluated points of the simplex.\n+   * @exception CostException if no cost can be computed for the parameters\n+   */\n+  protected void evaluateSimplex()\n+    throws CostException {\n+\n+    // evaluate the cost at all non-evaluated simplex points\n+    for (int i = 0; i < simplex.length; ++i) {\n+      PointCostPair pair = simplex[i];\n+      if (! pair.isEvaluated()) {\n+        pair.setCost(evaluateCost(pair.getPoint()));\n+      }\n+    }\n+\n+    // sort the simplex from lowest cost to highest cost\n+    Arrays.sort(simplex, pointCostPairComparator);\n+\n+  }\n+\n+  /** Replace the worst point of the simplex by a new point.\n+   * @param pointCostPair point to insert\n+   */\n+  protected void replaceWorstPoint(PointCostPair pointCostPair) {\n+    int n = simplex.length - 1;\n+    for (int i = 0; i < n; ++i) {\n+      if (simplex[i].getCost() > pointCostPair.getCost()) {\n+        PointCostPair tmp = simplex[i];\n+        simplex[i]        = pointCostPair;\n+        pointCostPair     = tmp;\n+      }\n+    }\n+    simplex[n] = pointCostPair;\n+  }\n+\n+  /** Comparator for {@link PointCostPair PointCostPair} objects. */\n+  private static Comparator pointCostPairComparator = new Comparator() {\n+      public int compare(Object o1, Object o2) {\n+        if (o1 == null) {\n+          return (o2 == null) ? 0 : +1;\n+        } else if (o2 == null) {\n+          return -1;\n+        } else {\n+          double cost1 = ((PointCostPair) o1).getCost();\n+          double cost2 = ((PointCostPair) o2).getCost();\n+          return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n+        }\n+      }\n+    };\n+\n+  /** Simplex. */\n+  protected PointCostPair[] simplex;\n+\n+  /** Cost function. */\n+  private CostFunction f;\n+\n+  /** Number of evaluations already performed. */\n+  private int evaluations;\n+\n+  /** Number of starts to go. */\n+  private int starts;\n+\n+  /** Random generator for multi-start. */\n+  private RandomVectorGenerator generator;\n+\n+  /** Found minima. */\n+  private PointCostPair[] minima;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/MultiDirectional.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+/** This class implements the multi-directional direct search method.\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: MultiDirectional.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see NelderMead\n+ */\n+public class MultiDirectional\n+  extends DirectSearchOptimizer {\n+\n+  /** Build a multi-directional optimizer with default coefficients.\n+   * <p>The default values are 2.0 for khi and 0.5 for gamma.</p>\n+   */\n+  public MultiDirectional() {\n+    super();\n+    this.khi   = 2.0;\n+    this.gamma = 0.5;\n+  }\n+\n+  /** Build a multi-directional optimizer with specified coefficients.\n+   * @param khi expansion coefficient\n+   * @param gamma contraction coefficient\n+   */\n+  public MultiDirectional(double khi, double gamma) {\n+    super();\n+    this.khi   = khi;\n+    this.gamma = gamma;\n+  }\n+\n+  /** Compute the next simplex of the algorithm.\n+   */\n+  protected void iterateSimplex()\n+    throws CostException {\n+\n+    while (true) {\n+\n+      // save the original vertex\n+      PointCostPair[] original = simplex;\n+      double originalCost = original[0].getCost();\n+\n+      // perform a reflection step\n+      double reflectedCost = evaluateNewSimplex(original, 1.0);\n+      if (reflectedCost < originalCost) {\n+\n+        // compute the expanded simplex\n+        PointCostPair[] reflected = simplex;\n+        double expandedCost = evaluateNewSimplex(original, khi);\n+        if (reflectedCost <= expandedCost) {\n+          // accept the reflected simplex\n+          simplex = reflected;\n+        }\n+\n+        return;\n+\n+      }\n+\n+      // compute the contracted simplex\n+      double contractedCost = evaluateNewSimplex(original, gamma);\n+      if (contractedCost < originalCost) {\n+        // accept the contracted simplex\n+        return;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** Compute and evaluate a new simplex.\n+   * @param original original simplex (to be preserved)\n+   * @param coeff linear coefficient\n+   * @return smallest cost in the transformed simplex\n+   * @exception CostException if the function cannot be evaluated at\n+   * some point\n+   */\n+  private double evaluateNewSimplex(PointCostPair[] original, double coeff)\n+    throws CostException {\n+\n+    double[] xSmallest = original[0].getPoint();\n+    int n = xSmallest.length;\n+\n+    // create the linearly transformed simplex\n+    simplex = new PointCostPair[n + 1];\n+    simplex[0] = original[0];\n+    for (int i = 1; i <= n; ++i) {\n+      double[] xOriginal    = original[i].getPoint();\n+      double[] xTransformed = new double[n];\n+      for (int j = 0; j < n; ++j) {\n+        xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n+      }\n+      simplex[i] = new PointCostPair(xTransformed);\n+    }\n+\n+    // evaluate it\n+    evaluateSimplex();\n+    return simplex[0].getCost();\n+\n+  }\n+\n+  /** Expansion coefficient. */\n+  private double khi;\n+\n+  /** Contraction coefficient. */\n+  private double gamma;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/NelderMead.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+/** This class implements the Nelder-Mead direct search method.\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: NelderMead.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see MultiDirectional\n+ */\n+public class NelderMead\n+  extends DirectSearchOptimizer {\n+\n+  /** Build a Nelder-Mead optimizer with default coefficients.\n+   * <p>The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+   * for both gamma and sigma.</p>\n+   */\n+  public NelderMead() {\n+    super();\n+    this.rho   = 1.0;\n+    this.khi   = 2.0;\n+    this.gamma = 0.5;\n+    this.sigma = 0.5;\n+  }\n+\n+  /** Build a Nelder-Mead optimizer with specified coefficients.\n+   * @param rho reflection coefficient\n+   * @param khi expansion coefficient\n+   * @param gamma contraction coefficient\n+   * @param sigma shrinkage coefficient\n+   */\n+  public NelderMead(double rho, double khi, double gamma, double sigma) {\n+    super();\n+    this.rho   = rho;\n+    this.khi   = khi;\n+    this.gamma = gamma;\n+    this.sigma = sigma;\n+  }\n+\n+  /** Compute the next simplex of the algorithm.\n+   */\n+  protected void iterateSimplex()\n+    throws CostException {\n+\n+    // the simplex has n+1 point if dimension is n\n+    int n = simplex.length - 1;\n+\n+    // interesting costs\n+    double   smallest      = simplex[0].getCost();\n+    double   secondLargest = simplex[n-1].getCost();\n+    double   largest       = simplex[n].getCost();\n+    double[] xLargest      = simplex[n].getPoint();\n+\n+    // compute the centroid of the best vertices\n+    // (dismissing the worst point at index n)\n+    double[] centroid = new double[n];\n+    for (int i = 0; i < n; ++i) {\n+      double[] x = simplex[i].getPoint();\n+      for (int j = 0; j < n; ++j) {\n+        centroid[j] += x[j];\n+      }\n+    }\n+    double scaling = 1.0 / n;\n+    for (int j = 0; j < n; ++j) {\n+      centroid[j] *= scaling;\n+    }\n+\n+    // compute the reflection point\n+    double[] xR       = new double[n];\n+    for (int j = 0; j < n; ++j) {\n+      xR[j] = centroid[j] + rho * (centroid[j] - xLargest[j]);\n+    }\n+    double costR = evaluateCost(xR);\n+\n+    if ((smallest <= costR) && (costR < secondLargest)) {\n+\n+      // accept the reflected point\n+      PointCostPair r = new PointCostPair(xR);\n+      r.setCost(costR);\n+      replaceWorstPoint(r);\n+\n+    } else if (costR < smallest) {\n+\n+      // compute the expansion point\n+      double[] xE = new double[n];\n+      for (int j = 0; j < n; ++j) {\n+        xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n+      }\n+      double costE = evaluateCost(xE);\n+\n+      if (costE < costR) {\n+        // accept the expansion point\n+        PointCostPair e = new PointCostPair(xE);\n+        e.setCost(costE);\n+        replaceWorstPoint(e);\n+      } else {\n+        // accept the reflected point\n+        PointCostPair r = new PointCostPair(xR);\n+        r.setCost(costR);\n+        replaceWorstPoint(r);\n+      }\n+\n+    } else {\n+\n+      if (costR < largest) {\n+\n+        // perform an outside contraction\n+        double[] xC = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n+        }\n+        double costC = evaluateCost(xC);\n+\n+        if (costC <= costR) {\n+          // accept the contraction point\n+          PointCostPair c = new PointCostPair(xC);\n+          c.setCost(costC);\n+          replaceWorstPoint(c);\n+          return;\n+        }\n+\n+      } else {\n+\n+        // perform an inside contraction\n+        double[] xC = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);\n+        }\n+        double costC = evaluateCost(xC);\n+\n+        if (costC < largest) {\n+          // accept the contraction point\n+          PointCostPair c = new PointCostPair(xC);\n+          c.setCost(costC);\n+          replaceWorstPoint(c);\n+          return;\n+        }\n+\n+      }\n+\n+      // perform a shrink\n+      double[] xSmallest = simplex[0].getPoint();\n+      for (int i = 1; i < simplex.length; ++i) {\n+        PointCostPair pair = simplex[i];\n+        double[] x = pair.getPoint();\n+        for (int j = 0; j < n; ++j) {\n+          x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n+        }\n+        pair.setCost(Double.NaN);\n+      }\n+      evaluateSimplex();\n+\n+    }\n+\n+  }\n+\n+  /** Reflection coefficient. */\n+  private double rho;\n+\n+  /** Expansion coefficient. */\n+  private double khi;\n+\n+  /** Contraction coefficient. */\n+  private double gamma;\n+\n+  /** Shrinkage coefficient. */\n+  private double sigma;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/NoConvergenceException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by optimization algorithms.\n+\n+ * @version $Id: NoConvergenceException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class NoConvergenceException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public NoConvergenceException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  private static final long serialVersionUID = 4854864422540042859L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/PointCostPair.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+/** This class holds a point and its associated cost.\n+ * <p>A cost/point pair is not evaluated at build time. Its associated\n+ * cost set to <code>Double.NaN</code> until it is evaluated.</p>\n+ * @author Luc Maisonobe\n+ * @version $Id: PointCostPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see CostFunction\n+ */\n+public class PointCostPair {\n+\n+  /** Build a point/cost pair with non-evaluated cost.\n+   * @param point point coordinates\n+   */\n+  public PointCostPair(double[] point) {\n+    this.point = point;\n+    cost = Double.NaN;\n+  }\n+\n+  /** Reset the point coordinates.\n+   * <p>Resetting the points coordinates automatically reset the cost\n+   * to non-evaluated</p>\n+   * @param point new point coordinates\n+   * @return old point coordinates (this can be re-used to put the\n+   * coordinates of another point without re-allocating an array)\n+   */\n+  public double[] setPoint(double[] point) {\n+    double[] oldPoint = this.point;\n+    this.point = point;\n+    cost = Double.NaN;\n+    return oldPoint;\n+  }\n+\n+  /** Get the point coordinates.\n+   * @return point coordinates\n+   */\n+  public double[] getPoint() {\n+    return point;\n+  }\n+\n+  /** Set the cost.\n+   * @param cost cost to store in the instance (can be\n+   * <code>Double.NaN</code> to reset the instance to non-evaluated)\n+   */\n+  public void setCost(double cost) {\n+    this.cost = cost;\n+  }\n+\n+  /** Get the cost.\n+   * @return cost associated to the point (or <code>Double.NaN</code>\n+   * if the instance is not evaluated)\n+   */\n+  public double getCost() {\n+    return cost;\n+  }\n+\n+  /** Check if the cost has been evaluated.\n+   * <p>The cost is considered to be non-evaluated if it is\n+   * <code>Double.isNaN(pair.getCost())</code> would return true</p>\n+   * @return true if the cost has been evaluated\n+   */\n+  public boolean isEvaluated() {\n+    return ! Double.isNaN(cost);\n+  }\n+\n+  /** Point coordinates. */\n+  private double[] point;\n+\n+  /** Cost associated to the point. */\n+  private double cost;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/ComputableFunctionIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents an integrator for scalar functions.\n+\n+ * <p>The classes which are devoted to integrate scalar functions\n+ * should implement this interface. The functions which can be handled\n+ * should implement the {@link\n+ * org.spaceroots.mantissa.functions.scalar.ComputableFunction\n+ * ComputableFunction} interface.</p>\n+\n+ * @see org.spaceroots.mantissa.functions.scalar.ComputableFunction\n+\n+ * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface ComputableFunctionIntegrator {\n+  /** Integrate a function over a defined range.\n+   * @param f function to integrate\n+   * @param a first bound of the range (can be lesser or greater than b)\n+   * @param b second bound of the range (can be lesser or greater than a)\n+   * @return value of the integral over the range\n+   * @exception FunctionException if the underlying function throws one\n+   */\n+  public double integrate(ComputableFunction f, double a, double b)\n+    throws FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator;\n+\n+/** This class implements an enhanced Simpson-like integrator.\n+\n+ * <p>A traditional Simpson integrator is based on a quadratic\n+ * approximation of the function on three equally spaced points. This\n+ * integrator does the same thing but can handle non-equally spaced\n+ * points. If it is used on a regular sample, it behaves exactly as a\n+ * traditional Simpson integrator.</p>\n+\n+ * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EnhancedSimpsonIntegrator\n+  implements SampledFunctionIntegrator {\n+  public double integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    EnhancedSimpsonIntegratorSampler sampler\n+      = new EnhancedSimpsonIntegratorSampler(iter);\n+    double sum = 0.0;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch(ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements an enhanced Simpson integrator as a sample.\n+\n+ * <p>A traditional Simpson integrator is based on a quadratic\n+ * approximation of the function on three equally spaced points. This\n+ * integrator does the same thing but can handle non-equally spaced\n+ * points. If it is used on a regular sample, it behaves exactly as a\n+ * traditional Simpson integrator.</p>\n+\n+ * @see EnhancedSimpsonIntegrator\n+\n+ * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EnhancedSimpsonIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sampled function iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Next point. */\n+  private ScalarValuedPair next;\n+\n+  /** Current running sum. */\n+  private double sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public EnhancedSimpsonIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    next = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = 0.0;\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext();\n+  }\n+\n+  public ScalarValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    // performs one step of an enhanced Simpson scheme\n+    ScalarValuedPair previous = next;\n+    ScalarValuedPair current  = iter.nextSamplePoint();\n+\n+    try {\n+      next = iter.nextSamplePoint();\n+\n+      double h1 = current.getX() - previous.getX();\n+      double h2 = next.getX()    - current.getX();\n+      double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);\n+      double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);\n+      double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);\n+\n+      sum += cP * previous.getY() + cC * current.getY() + cN * next.getY();\n+\n+    } catch(ExhaustedSampleException e) {\n+      // we have an incomplete step at the end of the sample\n+      // we use a trapezoid scheme for this last step\n+      sum += 0.5 * (current.getX() - previous.getX()) * (previous.getY() + current.getY());\n+      return new ScalarValuedPair(current.getX(), sum);\n+    }\n+\n+    return new ScalarValuedPair(next.getX(), sum);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class implements a Gauss-Legendre integrator.\n+\n+ * <p>Gauss-Legendre integrators are efficient integrators that can\n+ * accurately integrate functions with few functions evaluations. A\n+ * Gauss-Legendre integrator using an n-points quadrature formula can\n+ * integrate exactly 2n-1 degree polynoms.</p>\n+\n+ * <p>These integrators evaluate the function on n carefully chosen\n+ * points in each step interval. These points are not evenly\n+ * spaced. The function is <emph>never</emph> evaluated at the\n+ * boundary points, which means it can be undefined at these\n+ * points.</p>\n+\n+ * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GaussLegendreIntegrator\n+  implements ComputableFunctionIntegrator {\n+  /** Build a Gauss-Legendre integrator.\n+\n+   * <p>A Gauss-Legendre integrator is a formula like:\n+   * <pre>\n+   *    int (f) from -1 to +1 = Sum (ai * f(xi))\n+   * </pre>\n+   * </p>\n+   *\n+   * <p>The coefficients of the formula are computed as follow:\n+   * <pre>\n+   *   let n be the desired number of points\n+   *   the xi are the roots of the degree n Legendre polynomial\n+   *   the ai are the integrals int (Li^2) from -1 to +1\n+   *   where Li (x) = Prod (x-xk)/(xi-xk) for k != i\n+   * </pre>\n+   * </p>\n+   *\n+   * <p>A formula in n points can integrate exactly polynoms of degree\n+   * up to 2n-1.</p>\n+   *\n+   * @param minPoints minimal number of points desired\n+   * @param rawStep raw integration step (the precise step will be\n+   * adjusted in order to have an integer number of steps in the\n+   * integration range).\n+   * */\n+  public GaussLegendreIntegrator(int minPoints, double rawStep) {\n+    if (minPoints <= 2) {\n+      weightedRoots = new double[][] {\n+        { 1.0, -1.0 / Math.sqrt(3.0) },\n+        { 1.0,  1.0 / Math.sqrt(3.0) }\n+      };\n+    } else if (minPoints <= 3) {\n+      weightedRoots = new double[][] {\n+        { 5.0 / 9.0, -Math.sqrt(0.6) },\n+        { 8.0 / 9.0,            0.0  },\n+        { 5.0 / 9.0,  Math.sqrt(0.6) }\n+      };\n+    } else if (minPoints <= 4) {\n+      weightedRoots = new double[][] {\n+        { (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0,\n+             -Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) },\n+        { (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+             -Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },\n+        { (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+              Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },\n+        { (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0,\n+              Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) }\n+      };\n+    } else {\n+      weightedRoots = new double[][] {\n+        { (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0,\n+             -Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) },\n+        { (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+             -Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },\n+        { 128.0 / 225.0,\n+              0.0 },\n+        { (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+              Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },\n+        { (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0,\n+              Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) }\n+      };\n+    }\n+\n+    this.rawStep = rawStep;\n+\n+  }\n+\n+  /** Get the number of functions evaluation per step.\n+   * @return number of function evaluation per step\n+   */\n+  public int getEvaluationsPerStep() {\n+    return weightedRoots.length;\n+  }\n+\n+  public double integrate(ComputableFunction f, double a, double b)\n+    throws FunctionException {\n+\n+    // swap the bounds if they are not in ascending order\n+    if (b < a) {\n+      double tmp = b;\n+      b          = a;\n+      a          = tmp;\n+    }\n+\n+    // adjust the step according to the bounds\n+    long   n     = Math.round(0.5 + (b - a) / rawStep);\n+    double step  = (b - a) / n;\n+\n+    // integrate over all elementary steps\n+    double halfStep = step / 2.0;\n+    double midPoint = a + halfStep;\n+    double sum = 0.0;\n+    for (long i = 0; i < n; ++i) {\n+      for (int j = 0; j < weightedRoots.length; ++j) {\n+        sum += weightedRoots[j][0]\n+          * f.valueAt(midPoint + halfStep * weightedRoots[j][1]);\n+      }\n+      midPoint += step;\n+    }\n+\n+    return halfStep * sum;\n+\n+  }\n+\n+  double[][] weightedRoots;\n+\n+  double rawStep;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator;\n+\n+/** This class implements a Riemann integrator.\n+\n+ * <p>A Riemann integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see TrapezoidIntegrator\n+\n+ * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class RiemannIntegrator\n+  implements SampledFunctionIntegrator {\n+  public double integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    RiemannIntegratorSampler sampler = new RiemannIntegratorSampler(iter);\n+    double sum = 0.0;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch(ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements a Riemann integrator as a sample.\n+\n+ * <p>A Riemann integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see RiemannIntegrator\n+\n+ * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class RiemannIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sample iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Current point. */\n+  private ScalarValuedPair current;\n+\n+  /** Current running sum. */\n+  private double sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public RiemannIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    current = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = 0.0;\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext();\n+  }\n+\n+  public ScalarValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    // performs one step of a Riemann scheme\n+    ScalarValuedPair previous = current;\n+    current = iter.nextSamplePoint();\n+    sum    += (current.getX() - previous.getX()) * previous.getY();\n+\n+    return new ScalarValuedPair(current.getX(), sum);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/SampledFunctionIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents an integrator for scalar samples.\n+\n+ * <p>The classes which are devoted to integrate scalar samples\n+ * should implement this interface.</p>\n+\n+ * @see org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator\n+ * @see ComputableFunctionIntegrator\n+\n+ * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SampledFunctionIntegrator {\n+  /** Integrate a sample over its overall range\n+   * @param iter iterator over the sample to integrate\n+   * @return value of the integral over the sample range\n+   * @exception ExhaustedSampleException if the sample does not have\n+   * enough points for the integration scheme\n+   * @exception FunctionException if the underlying sampled function throws one\n+   */\n+  public double integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator;\n+\n+/** This class implements a trapezoid integrator.\n+\n+ * <p>A trapezoid integrator is a very simple one that assumes the\n+ * function is linear over the integration step.</p>\n+\n+ * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class TrapezoidIntegrator\n+  implements SampledFunctionIntegrator {\n+  public double integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    TrapezoidIntegratorSampler sampler = new TrapezoidIntegratorSampler(iter);\n+    double sum = 0.0;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch (ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements a trapezoid integrator as a sample.\n+\n+ * <p>A trapezoid integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see TrapezoidIntegrator\n+\n+ * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class TrapezoidIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sample iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Current point. */\n+  private ScalarValuedPair current;\n+\n+  /** Current running sum. */\n+  private double sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public TrapezoidIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    current = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = 0.0;\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext ();\n+  }\n+\n+  public ScalarValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    // performs one step of a trapezoid scheme\n+    ScalarValuedPair previous = current;\n+    current = iter.nextSamplePoint();\n+    sum    += 0.5\n+            * (current.getX() - previous.getX())\n+            * (previous.getY() + current.getY());\n+\n+    return new ScalarValuedPair(current.getX(), sum);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/ComputableFunctionIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents an integrator for vectorial functions.\n+\n+ * <p>The classes which are devoted to integrate vectorial functions\n+ * should implement this interface. The functions which can be handled\n+ * should implement the {@link\n+ * org.spaceroots.mantissa.functions.vectorial.ComputableFunction\n+ * ComputableFunction} interface.</p>\n+\n+ * @see org.spaceroots.mantissa.functions.vectorial.ComputableFunction\n+\n+ * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface ComputableFunctionIntegrator {\n+  /** Integrate a function over a defined range.\n+   * @param f function to integrate\n+   * @param a first bound of the range (can be lesser or greater than b)\n+   * @param b second bound of the range (can be lesser or greater than a)\n+   * @return value of the integral over the range\n+   * @exception FunctionException if the underlying function throws one\n+   */\n+  public double[] integrate(ComputableFunction f, double a, double b)\n+    throws FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+\n+/** This class implements an enhanced Simpson-like integrator.\n+\n+ * <p>A traditional Simpson integrator is based on a quadratic\n+ * approximation of the function on three equally spaced points. This\n+ * integrator does the same thing but can handle non-equally spaced\n+ * points. If it is used on a regular sample, it behaves exactly as a\n+ * traditional Simpson integrator.</p>\n+\n+ * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EnhancedSimpsonIntegrator\n+  implements SampledFunctionIntegrator {\n+  public double[] integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    EnhancedSimpsonIntegratorSampler sampler =\n+      new EnhancedSimpsonIntegratorSampler(iter);\n+    double[] sum = null;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch(ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements an enhanced Simpson integrator as a sample.\n+\n+ * <p>A traditional Simpson integrator is based on a quadratic\n+ * approximation of the function on three equally spaced points. This\n+ * integrator does the same thing but can handle non-equally spaced\n+ * points. If it is used on a regular sample, it behaves exactly as a\n+ * traditional Simpson integrator.</p>\n+\n+ * @see EnhancedSimpsonIntegrator\n+\n+ * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EnhancedSimpsonIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sample iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Next point. */\n+  private VectorialValuedPair next;\n+\n+  /** Current running sum. */\n+  private double[] sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public EnhancedSimpsonIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    next = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = new double[iter.getDimension()];\n+    for (int i = 0; i < sum.length; ++i) {\n+      sum[i] = 0.0;\n+    }\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext();\n+  }\n+\n+  public int getDimension() {\n+    return iter.getDimension();\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+    // performs one step of an enhanced Simpson scheme\n+    VectorialValuedPair previous = next;\n+    VectorialValuedPair current  = iter.nextSamplePoint();\n+\n+    try {\n+      next = iter.nextSamplePoint();\n+\n+      double h1 = current.getX() - previous.getX();\n+      double h2 = next.getX()    - current.getX();\n+      double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);\n+      double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);\n+      double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);\n+\n+      double[] pY = previous.getY();\n+      double[] cY = current.getY();\n+      double[] nY = next.getY();\n+      for (int i = 0; i < sum.length; ++i) {\n+        sum [i] += cP * pY[i] + cC * cY[i] + cN * nY[i];\n+      }\n+\n+    } catch(ExhaustedSampleException e) {\n+      // we have an incomplete step at the end of the sample\n+      // we use a trapezoid scheme for this last step\n+      double halfDx = 0.5 * (current.getX() - previous.getX());\n+      double[] pY = previous.getY();\n+      double[] cY = current.getY();\n+      for (int i = 0; i < sum.length; ++i) {\n+        sum [i] += halfDx * (pY[i] + cY[i]);\n+      }\n+      return new VectorialValuedPair(current.getX(), sum);\n+    }\n+\n+    double[] values = new double[sum.length];\n+    System.arraycopy(sum, 0, values, 0, sum.length);\n+    return new VectorialValuedPair(next.getX(), values);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class implements a Gauss-Legendre integrator.\n+\n+ * <p>Gauss-Legendre integrators are efficient integrators that can\n+ * accurately integrate functions with few functions evaluations. A\n+ * Gauss-Legendre integrator using an n-points quadrature formula can\n+ * integrate exactly 2n-1 degree polynoms.</p>\n+\n+ * <p>These integrators evaluate the function on n carefully chosen\n+ * points in each step interval. These points are not evenly\n+ * spaced. The function is <emph>never</emph> evaluated at the\n+ * boundary points, which means it can be undefined at these\n+ * points.</p>\n+\n+ * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GaussLegendreIntegrator\n+  implements ComputableFunctionIntegrator {\n+  /** Build a Gauss-Legendre integrator.\n+\n+   * <p>A Gauss-Legendre integrator is a formula like:\n+   * <pre>\n+   *    int (f) from -1 to +1 = Sum (ai * f(xi))\n+   * </pre>\n+   * </p>\n+   *\n+   * <p>The coefficients of the formula are computed as follow:\n+   * <pre>\n+   *   let n be the desired number of points\n+   *   the xi are the roots of the degree n Legendre polynomial\n+   *   the ai are the integrals int (Li^2) from -1 to +1\n+   *   where Li (x) = Prod (x-xk)/(xi-xk) for k != i\n+   * </pre>\n+   * </p>\n+   *\n+   * <p>A formula in n points can integrate exactly polynoms of degree\n+   * up to 2n-1.</p>\n+   *\n+   * @param minPoints minimal number of points desired\n+   * @param rawStep raw integration step (the precise step will be\n+   * adjusted in order to have an integer number of steps in the\n+   * integration range).\n+   * */\n+  public GaussLegendreIntegrator(int minPoints, double rawStep) {\n+    if (minPoints <= 2) {\n+      weightedRoots = new double[][] {\n+        { 1.0, -1.0 / Math.sqrt (3.0) },\n+        { 1.0,  1.0 / Math.sqrt (3.0) }\n+      };\n+    } else if (minPoints <= 3) {\n+      weightedRoots = new double[][] {\n+        { 5.0 / 9.0, -Math.sqrt (0.6) },\n+        { 8.0 / 9.0,             0.0  },\n+        { 5.0 / 9.0,  Math.sqrt (0.6) }\n+      };\n+    } else if (minPoints <= 4) {\n+      weightedRoots = new double[][] {\n+        { (90.0 - 5.0 * Math.sqrt (30.0)) / 180.0,\n+             -Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) },\n+        { (90.0 + 5.0 * Math.sqrt (30.0)) / 180.0,\n+             -Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },\n+        { (90.0 + 5.0 * Math.sqrt (30.0)) / 180.0,\n+              Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },\n+        { (90.0 - 5.0 * Math.sqrt (30.0)) / 180.0,\n+              Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) }\n+      };\n+    } else {\n+      weightedRoots = new double[][] {\n+        { (322.0 - 13.0 * Math.sqrt (70.0)) / 900.0,\n+             -Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) },\n+        { (322.0 + 13.0 * Math.sqrt (70.0)) / 900.0,\n+             -Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },\n+        { 128.0 / 225.0,\n+              0.0 },\n+        { (322.0 + 13.0 * Math.sqrt (70.0)) / 900.0,\n+              Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },\n+        { (322.0 - 13.0 * Math.sqrt (70.0)) / 900.0,\n+              Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) }\n+      };\n+    }\n+\n+    this.rawStep = rawStep;\n+\n+  }\n+\n+  /** Get the number of functions evaluation per step.\n+   * @return number of function evaluation per step\n+   */\n+  public int getEvaluationsPerStep() {\n+    return weightedRoots.length;\n+  }\n+\n+  public double[] integrate(ComputableFunction f, double a, double b)\n+    throws FunctionException {\n+\n+    // swap the integration bounds if they are not in ascending order\n+    if (b < a) {\n+      double tmp = b;\n+      b          = a;\n+      a          = tmp;\n+    }\n+\n+    // adjust the integration step according to the bounds\n+    long   n     = Math.round(0.5 + (b - a) / rawStep);\n+    double step  = (b - a) / n;\n+\n+    // integrate over all elementary steps\n+    double halfStep = step / 2.0;\n+    double midPoint = a + halfStep;\n+\n+    double[] sum = new double[f.getDimension()];\n+    for (int k = 0; k < sum.length; ++k) {\n+      sum[k] = 0.0;\n+    }\n+\n+    for (long i = 0; i < n; ++i) {\n+      for (int j = 0; j < weightedRoots.length; ++j) {\n+        double[] value = f.valueAt(midPoint + halfStep * weightedRoots[j][1]);\n+        for (int k = 0; k < sum.length; ++k) {\n+          sum[k] += weightedRoots[j][0] * value[k];\n+        }\n+      }\n+      midPoint += step;\n+    }\n+\n+    for (int k = 0; k < sum.length; ++k) {\n+      sum [k] *= halfStep;\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+  double[][] weightedRoots;\n+\n+  double rawStep;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+\n+/** This class implements a Riemann integrator.\n+\n+ * <p>A Riemann integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see TrapezoidIntegrator\n+\n+ * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class RiemannIntegrator\n+  implements SampledFunctionIntegrator {\n+\n+  public double[] integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    RiemannIntegratorSampler sampler = new RiemannIntegratorSampler(iter);\n+    double[] sum = null;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch(ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements a Riemann integrator as a sample.\n+\n+ * <p>A Riemann integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see RiemannIntegrator\n+\n+ * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class RiemannIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sample iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Current point. */\n+  private VectorialValuedPair current;\n+\n+  /** Current running sum. */\n+  private double[] sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public RiemannIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    current = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = new double[iter.getDimension()];\n+    for (int i = 0; i < sum.length; ++i) {\n+      sum[i] = 0.0;\n+    }\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext();\n+  }\n+\n+  public int getDimension() {\n+    return iter.getDimension();\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    // performs one step of a Riemann scheme\n+    VectorialValuedPair previous = current;\n+    current = iter.nextSamplePoint();\n+    double step =  (current.getX() - previous.getX());\n+    double[] pY = previous.getY();\n+    for (int i = 0; i < sum.length; ++i) {\n+      sum[i] += step * pY[i];\n+    }\n+\n+    double[] values = new double[sum.length];\n+    System.arraycopy(sum, 0, values, 0, sum.length);\n+    return new VectorialValuedPair (current.getX(), values);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/SampledFunctionIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface represents an integrator for vectorial samples.\n+\n+ * <p>The classes which are devoted to integrate vectorial samples\n+ * should implement this interface.</p>\n+\n+ * @see org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator\n+ * @see ComputableFunctionIntegrator\n+\n+ * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SampledFunctionIntegrator {\n+\n+  /** Integrate a sample over its overall range\n+   * @param iter iterator over the sample to integrate\n+   * @return value of the integral over the sample range\n+   * @exception ExhaustedSampleException if the sample does not have\n+   * enough points for the integration scheme\n+   * @exception FunctionException if the underlying sampled function throws one\n+   */\n+  public double[] integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+import org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator;\n+\n+/** This class implements a trapezoid integrator.\n+\n+ * <p>A trapezoid integrator is a very simple one that assumes the\n+ * function is linear over the integration step.</p>\n+\n+ * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class TrapezoidIntegrator\n+  implements SampledFunctionIntegrator {\n+  public double[] integrate(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    TrapezoidIntegratorSampler sampler =\n+      new TrapezoidIntegratorSampler(iter);\n+    double[] sum = null;\n+\n+    try {\n+      while (true) {\n+        sum = sampler.nextSamplePoint().getY();\n+      }\n+    } catch(ExhaustedSampleException e) {\n+    }\n+\n+    return sum;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.*;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+/** This class implements a trapezoid integrator as a sample.\n+\n+ * <p>A trapezoid integrator is a very simple one that assumes the\n+ * function is constant over the integration step. Since it is very\n+ * simple, this algorithm needs very small steps to achieve high\n+ * accuracy, and small steps lead to numerical errors and\n+ * instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a simple template for more useful\n+ * integrators.</p>\n+\n+ * @see TrapezoidIntegrator\n+\n+ * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class TrapezoidIntegratorSampler\n+  implements SampledFunctionIterator {\n+\n+  /** Underlying sample iterator. */\n+  private SampledFunctionIterator iter;\n+\n+  /** Current point. */\n+  private VectorialValuedPair current;\n+\n+  /** Current running sum. */\n+  private double[] sum;\n+\n+  /** Constructor.\n+   * Build an integrator from an underlying sample iterator.\n+   * @param iter iterator over the base function\n+   */\n+  public TrapezoidIntegratorSampler(SampledFunctionIterator iter)\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    this.iter = iter;\n+\n+    // get the first point\n+    current = iter.nextSamplePoint();\n+\n+    // initialize the sum\n+    sum = new double[iter.getDimension()];\n+    for (int i = 0; i < sum.length; ++i) {\n+      sum[i] = 0.0;\n+    }\n+\n+  }\n+\n+  public boolean hasNext() {\n+    return iter.hasNext();\n+  }\n+\n+  public int getDimension() {\n+    return iter.getDimension();\n+  }\n+\n+  public VectorialValuedPair nextSamplePoint()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    // performs one step of a trapezoid scheme\n+    VectorialValuedPair previous = current;\n+    current = iter.nextSamplePoint();\n+\n+    double halfDx = 0.5 * (current.getX() - previous.getX());\n+    double[] pY = previous.getY();\n+    double[] cY = current.getY();\n+    for (int i = 0; i < sum.length; ++i) {\n+      sum[i] += halfDx * (pY[i] + cY[i]);\n+    }\n+\n+    double[] values = new double[sum.length];\n+    System.arraycopy(sum, 0, values, 0, sum.length);\n+    return new VectorialValuedPair (current.getX(), values);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+import org.spaceroots.mantissa.linalg.Matrix;\n+import org.spaceroots.mantissa.linalg.GeneralMatrix;\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+\n+import java.io.Serializable;\n+\n+/** This class allows to generate random vectors with correlated components.\n+\n+ * <p>Random vectors with correlated components are built by combining\n+ * the uncorrelated components of another random vector in such a way\n+ * the resulting correlations are the ones specified by a positive\n+ * definite covariance matrix.</p>\n+\n+ * <p>Sometimes, the covariance matrix for a given simulation is not\n+ * strictly positive definite. This means that the correlations are\n+ * not all independant from each other. In this case, however, the non\n+ * strictly positive elements found during the Cholesky decomposition\n+ * of the covariance matrix should not be negative either, they\n+ * should be null. This implies that rather than computing <code>C =\n+ * L.Lt</code> where <code>C</code> is the covariance matrix and\n+ * <code>L</code> is a lower-triangular matrix, we compute <code>C =\n+ * B.Bt</code> where <code>B</code> is a rectangular matrix having\n+ * more rows than columns. The number of columns of <code>B</code> is\n+ * the rank of the covariance matrix, and it is the dimension of the\n+ * uncorrelated random vector that is needed to compute the component\n+ * of the correlated vector. This class does handle this situation\n+ * automatically.</p>\n+\n+ * @version $Id: CorrelatedRandomVectorGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class CorrelatedRandomVectorGenerator\n+  implements Serializable, RandomVectorGenerator {\n+\n+  /** Simple constructor.\n+   * <p>Build a correlated random vector generator from its mean\n+   * vector and covariance matrix.</p>\n+   * @param mean expected mean values for all components\n+   * @param covariance covariance matrix\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   * @exception IllegalArgumentException if there is a dimension\n+   * mismatch between the mean vector and the covariance matrix\n+   * @exception NotPositiveDefiniteMatrixException if the\n+   * covariance matrix is not strictly positive definite\n+   */\n+  public CorrelatedRandomVectorGenerator(double[] mean,\n+                                         SymetricalMatrix covariance,\n+                                         NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+    int order = covariance.getRows();\n+    if (mean.length != order) {\n+      String message =\n+        MantissaException.translate(\"dimension mismatch {0} != {1}\",\n+                                    new String[] {\n+                                      Integer.toString(mean.length),\n+                                      Integer.toString(order)\n+                                    });\n+      throw new IllegalArgumentException(message);\n+    }\n+    this.mean = mean;\n+\n+    factorize(covariance);\n+\n+    this.generator = generator;\n+    normalized = new double[rank];\n+    correlated = new double[order];\n+\n+  }\n+\n+  /** Simple constructor.\n+   * <p>Build a null mean random correlated vector generator from its\n+   * covariance matrix.</p>\n+   * @param covariance covariance matrix\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   * @exception NotPositiveDefiniteMatrixException if the\n+   * covariance matrix is not strictly positive definite\n+   */\n+  public CorrelatedRandomVectorGenerator(SymetricalMatrix covariance,\n+                                         NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+    int order = covariance.getRows();\n+    mean = new double[order];\n+    for (int i = 0; i < order; ++i) {\n+      mean[i] = 0;\n+    }\n+\n+    factorize(covariance);\n+\n+    this.generator = generator;\n+    normalized = new double[rank];\n+    correlated = new double[order];\n+\n+  }\n+\n+  /** Get the root of the covariance matrix.\n+   * The root is the matrix <code>B</code> such that <code>B.Bt</code>\n+   * is equal to the covariance matrix\n+   * @return root of the square matrix\n+   */\n+  public Matrix getRootMatrix() {\n+    return root;\n+  }\n+\n+  /** Get the underlying normalized components generator.\n+   * @return underlying uncorrelated components generator\n+   */\n+  public NormalizedRandomGenerator getGenerator() {\n+    return generator;\n+  }\n+\n+  /** Get the rank of the covariance matrix.\n+   * The rank is the number of independant rows in the covariance\n+   * matrix, it is also the number of columns of the rectangular\n+   * matrix of the factorization.\n+   * @return rank of the square matrix.\n+   */\n+  public int getRank() {\n+    return rank;\n+  }\n+\n+  /** Factorize the original square matrix.\n+   * @param covariance covariance matrix\n+   * @exception NotPositiveDefiniteMatrixException if the\n+   * covariance matrix is not strictly positive definite\n+   */\n+  private void factorize(SymetricalMatrix covariance)\n+  throws NotPositiveDefiniteMatrixException {\n+\n+    int order = covariance.getRows();\n+    SymetricalMatrix c = (SymetricalMatrix) covariance.duplicate();\n+    GeneralMatrix    b = new GeneralMatrix(order, order);\n+\n+    int[] swap  = new int[order];\n+    int[] index = new int[order];\n+    for (int i = 0; i < order; ++i) {\n+      index[i] = i;\n+    }\n+\n+    rank = 0;\n+    for (boolean loop = true; loop;) {\n+\n+      // find maximal diagonal element\n+      swap[rank] = rank;\n+      for (int i = rank + 1; i < order; ++i) {\n+        if (c.getElement(index[i], index[i])\n+            > c.getElement(index[swap[i]], index[swap[i]])) {\n+          swap[rank] = i;\n+        }\n+      }\n+\n+\n+      // swap elements\n+      if (swap[rank] != rank) {\n+        int tmp = index[rank];\n+        index[rank] = index[swap[rank]];\n+        index[swap[rank]] = tmp;\n+      }\n+\n+      // check diagonal element\n+      if (c.getElement(index[rank], index[rank]) < 1.0e-12) {\n+\n+        if (rank == 0) {\n+          throw new NotPositiveDefiniteMatrixException();\n+        }\n+\n+        // check remaining diagonal elements\n+        for (int i = rank; i < order; ++i) {\n+          if (c.getElement(index[rank], index[rank]) < -1.0e-12) {\n+            // there is at least one sufficiently negative diagonal element,\n+            // the covariance matrix is wrong\n+            throw new NotPositiveDefiniteMatrixException();\n+          }\n+        }\n+\n+        // all remaining diagonal elements are close to zero,\n+        // we consider we have found the rank of the covariance matrix\n+        ++rank;\n+        loop = false;\n+\n+      } else {\n+\n+        // transform the matrix\n+        double sqrt = Math.sqrt(c.getElement(index[rank], index[rank]));\n+        b.setElement(rank, rank, sqrt);\n+        double inverse = 1 / sqrt;\n+        for (int i = rank + 1; i < order; ++i) {\n+          double e = inverse * c.getElement(index[i], index[rank]);\n+          b.setElement(i, rank, e);\n+          c.setElement(index[i], index[i],\n+                          c.getElement(index[i], index[i]) - e * e);\n+          for (int j = rank + 1; j < i; ++j) {\n+            double f = b.getElement(j, rank);\n+            c.setElementAndSymetricalElement(index[i], index[j],\n+                                             c.getElement(index[i], index[j])\n+                                             - e * f);\n+          }\n+        }\n+\n+        // prepare next iteration\n+        loop = ++rank < order;\n+\n+      }\n+\n+    }\n+\n+    // build the root matrix\n+    root = new GeneralMatrix(order, rank);\n+    for (int i = 0; i < order; ++i) {\n+      for (int j = 0; j < rank; ++j) {\n+        root.setElement(swap[i], j, b.getElement(i, j));\n+      }\n+    }\n+\n+  }\n+\n+  /** Generate a correlated random vector.\n+   * @return a random vector as an array of double. The generator\n+   * <em>will</em> reuse the same array for each call, in order to\n+   * save the allocation time, so the user should keep a copy by\n+   * himself if he needs so.\n+   */\n+  public double[] nextVector() {\n+\n+    // generate uncorrelated vector\n+    for (int i = 0; i < rank; ++i) {\n+      normalized[i] = generator.nextDouble();\n+    }\n+\n+    // compute correlated vector\n+    for (int i = 0; i < correlated.length; ++i) {\n+      correlated[i] = mean[i];\n+      for (int j = 0; j < rank; ++j) {\n+        correlated[i] += root.getElement(i, j) * normalized[j];\n+      }\n+    }\n+\n+    return correlated;\n+\n+  }\n+\n+  /** Mean vector. */\n+  private double[] mean;\n+\n+  /** Permutated Cholesky root of the covariance matrix. */\n+  private Matrix root;\n+\n+  /** Rank of the covariance matrix. */\n+  private int rank;\n+\n+  /** Underlying generator. */\n+  NormalizedRandomGenerator generator;\n+\n+  /** Storage for the normalized vector. */\n+  private double[] normalized;\n+\n+  /** Storage for the random vector. */\n+  private double[] correlated;\n+\n+  private static final long serialVersionUID = -4754497552287369719L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/GaussianRandomGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import java.util.Random;\n+\n+/** This class is a gaussian normalized random generator\n+ * for scalars.\n+\n+ * <p>This class is a simple interface adaptor around the {@link\n+ * java.util.Random#nextGaussian nextGaussian} method.</p>\n+\n+ * @version $Id: GaussianRandomGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GaussianRandomGenerator\n+  implements NormalizedRandomGenerator {\n+\n+  /** Underlying generator. */\n+  Random generator;\n+\n+  /** Create a new generator.\n+   * The seed of the generator is related to the current time.\n+   */\n+  public GaussianRandomGenerator() {\n+    generator = new Random();\n+  }\n+\n+  /** Creates a new random number generator using a single int seed.\n+   * @param seed the initial seed (32 bits integer)\n+   */\n+  public GaussianRandomGenerator(int seed) {\n+    generator = new Random(seed);\n+  }\n+\n+  /** Create a new generator initialized with a single long seed.\n+   * @param seed seed for the generator (64 bits integer)\n+   */\n+  public GaussianRandomGenerator(long seed) {\n+    generator = new Random(seed);\n+  }\n+\n+  /** Generate a random scalar with null mean and unit standard deviation.\n+   * @return a random scalar with null mean and unit standard deviation\n+   */\n+  public double nextDouble() {\n+    return generator.nextGaussian();\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/NormalizedRandomGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+/** This interface represent a normalized random generator for\n+ * scalars.\n+ * Normalized generator should provide null mean and unit standard\n+ * deviation scalars.\n+ * @version $Id: NormalizedRandomGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+public interface NormalizedRandomGenerator {\n+\n+  /** Generate a random scalar with null mean and unit standard deviation.\n+   * <p>This method does <strong>not</strong> specify the shape of the\n+   * distribution, it is the implementing class that provides it. The\n+   * only contract here is to generate numbers with null mean and unit\n+   * standard deviation.</p>\n+   * @return a random scalar\n+   */\n+  public double nextDouble();\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/NotPositiveDefiniteMatrixException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.MantissaException;\n+\n+/** This class represents exceptions thrown by the correlated random\n+ * vector generator.\n+\n+ * @version $Id: NotPositiveDefiniteMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class NotPositiveDefiniteMatrixException\n+  extends MantissaException {\n+\n+  /** Simple constructor.\n+   * build an exception with a default message.\n+   */\n+  public NotPositiveDefiniteMatrixException() {\n+    super(\"not positive definite matrix\");\n+  }\n+\n+  /** Simple constructor.\n+   * build an exception with the specified message.\n+   * @param message message to use to build the exception\n+   */\n+  public NotPositiveDefiniteMatrixException(String message) {\n+    super(message);\n+  }\n+\n+  private static final long serialVersionUID = -6801349873804445905L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/RandomVectorGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+/** This interface represent a random generator for whole vectors.\n+\n+ * @version $Id: RandomVectorGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface RandomVectorGenerator {\n+\n+  /** Generate a random vector.\n+   * @return a random vector as an array of double. The generator\n+   * <em>will</em> reuse the same array for each call, in order to\n+   * save the allocation time, so the user should keep a copy by\n+   * himself if he needs so.\n+   */\n+  public double[] nextVector();\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/ScalarSampleStatistics.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+/** This class compute basic statistics on a scalar sample.\n+ * @version $Id: ScalarSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+public class ScalarSampleStatistics {\n+\n+  /** Number of sample points. */\n+  private int n;\n+\n+  /** Minimal value in the sample. */\n+  private double min;\n+\n+  /** Maximal value in the sample. */\n+  private double max;\n+\n+  /** Sum of the sample values. */\n+  private double sum;\n+\n+  /** Sum of the squares of the sample values. */\n+  private double sum2;\n+\n+  /** Simple constructor.\n+   * Build a new empty instance\n+   */\n+  public ScalarSampleStatistics() {\n+    n    = 0;\n+    min  = Double.NaN;\n+    max  = min;\n+    sum  = 0;\n+    sum2 = 0;\n+  }\n+\n+  /** Add one point to the instance.\n+   * @param x value of the sample point\n+   */\n+  public void add(double x) {\n+\n+    if (n++ == 0) {\n+      min  = x;\n+      max  = x;\n+      sum  = x;\n+      sum2 = x * x;\n+    } else {\n+\n+      if (x < min) {\n+        min = x;\n+      } else if (x > max) {\n+        max = x;\n+      }\n+\n+      sum  += x;\n+      sum2 += x * x;\n+\n+    }\n+\n+  }\n+\n+  /** Add all points of an array to the instance.\n+   * @param points array of points\n+   */\n+  public void add(double[] points) {\n+    for (int i = 0; i < points.length; ++i) {\n+      add(points[i]);\n+    }\n+  }\n+\n+  /** Add all the points of another sample to the instance.\n+   * @param s sample to add\n+   */\n+  public void add(ScalarSampleStatistics s) {\n+\n+    if (s.n == 0) {\n+      // nothing to add\n+      return;\n+    }\n+\n+    if (n == 0) {\n+      n    = s.n;\n+      min  = s.min;\n+      max  = s.max;\n+      sum  = s.sum;\n+      sum2 = s.sum2;\n+    } else {\n+\n+      n += s.n;\n+\n+      if (s.min < min) {\n+        min = s.min;\n+      } else if (s.max > max) {\n+        max = s.max;\n+      }\n+\n+      sum  += s.sum;\n+      sum2 += s.sum2;\n+\n+    }\n+\n+  }\n+\n+  /** Get the number of points in the sample.\n+   * @return number of points in the sample\n+   */\n+  public int size() {\n+    return n;\n+  }\n+\n+  /** Get the minimal value in the sample.\n+   * @return minimal value in the sample\n+   */\n+  public double getMin() {\n+    return min;\n+  }\n+\n+  /** Get the maximal value in the sample.\n+   * @return maximal value in the sample\n+   */\n+  public double getMax() {\n+    return max;\n+  }\n+\n+  /** Get the mean value of the sample.\n+   * @return mean value of the sample\n+   */\n+  public double getMean() {\n+    return (n == 0) ? 0 : (sum / n);\n+  }\n+\n+  /** Get the standard deviation of the underlying probability law.\n+   * This method estimate the standard deviation considering that the\n+   * data available are only a <em>sample</em> of all possible\n+   * values. This value is often called the sample standard deviation\n+   * (as opposed to the population standard deviation).\n+   * @return standard deviation of the underlying probability law\n+   */\n+  public double getStandardDeviation() {\n+    if (n < 2) {\n+      return 0;\n+    }\n+    return Math.sqrt((n * sum2 - sum * sum) / (n * (n - 1)));\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import java.io.Serializable;\n+\n+/** This class allows to generate random vectors with uncorrelated components.\n+\n+ * @version $Id: UncorrelatedRandomVectorGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class UncorrelatedRandomVectorGenerator\n+  implements Serializable, RandomVectorGenerator {\n+\n+  /** Simple constructor.\n+   * <p>Build an uncorrelated random vector generator from its mean\n+   * and standard deviation vectors.</p>\n+   * @param mean expected mean values for all components\n+   * @param standardDeviation standard deviation for all components\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   * @exception IllegalArgumentException if there is a dimension\n+   * mismatch between the mean and standard deviation vectors\n+   */\n+  public UncorrelatedRandomVectorGenerator(double[] mean,\n+                                           double[] standardDeviation,\n+                                           NormalizedRandomGenerator generator) {\n+\n+    if (mean.length != standardDeviation.length) {\n+      throw new IllegalArgumentException(\"dimension mismatch\");\n+    }\n+    this.mean              = mean;\n+    this.standardDeviation = standardDeviation;\n+\n+    this.generator = generator;\n+    random = new double[mean.length];\n+\n+  }\n+\n+  /** Simple constructor.\n+   * <p>Build a null mean random and unit standard deviation\n+   * uncorrelated vector generator</p>\n+   * @param dimension dimension of the vectors to generate\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   */\n+  public UncorrelatedRandomVectorGenerator(int dimension,\n+                                           NormalizedRandomGenerator generator) {\n+\n+    mean              = new double[dimension];\n+    standardDeviation = new double[dimension];\n+    for (int i = 0; i < dimension; ++i) {\n+      mean[i]              = 0;\n+      standardDeviation[i] = 1;\n+    }\n+\n+    this.generator = generator;\n+    random = new double[dimension];\n+\n+  }\n+\n+  /** Get the underlying normalized components generator.\n+   * @return underlying uncorrelated components generator\n+   */\n+  public NormalizedRandomGenerator getGenerator() {\n+    return generator;\n+  }\n+\n+  /** Generate a correlated random vector.\n+   * @return a random vector as an array of double. The generator\n+   * <em>will</em> reuse the same array for each call, in order to\n+   * save the allocation time, so the user should keep a copy by\n+   * himself if he needs so.\n+   */\n+  public double[] nextVector() {\n+\n+    for (int i = 0; i < random.length; ++i) {\n+      random[i] = mean[i] + standardDeviation[i] * generator.nextDouble();\n+    }\n+\n+    return random;\n+\n+  }\n+\n+  /** Mean vector. */\n+  private double[] mean;\n+\n+  /** Standard deviation vector. */\n+  private double[] standardDeviation;\n+\n+  /** Underlying scalar generator. */\n+  NormalizedRandomGenerator generator;\n+\n+  /** Storage for the random vector. */\n+  private double[] random;\n+\n+  private static final long serialVersionUID = -3323293740860311151L;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/UniformRandomGenerator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import java.util.Random;\n+\n+/** This class implements a normalized uniform random generator.\n+\n+ * <p>Since this is a normalized random generator, it has a null mean\n+ * and a unit standard deviation. Being also a uniform\n+ * generator, it produces numbers in the range [-sqrt(3) ;\n+ * sqrt(3)].</p>\n+\n+ * @version $Id: UniformRandomGenerator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class UniformRandomGenerator\n+  implements NormalizedRandomGenerator {\n+\n+  private static final double SQRT3 = Math.sqrt(3.0);\n+\n+  private static final double TWOSQRT3 = 2.0 * Math.sqrt(3.0);\n+\n+  /** Underlying generator. */\n+  Random generator;\n+\n+  /** Create a new generator.\n+   * The seed of the generator is related to the current time.\n+   */\n+  public UniformRandomGenerator() {\n+    generator = new Random();\n+  }\n+\n+  /** Creates a new random number generator using a single int seed.\n+   * @param seed the initial seed (32 bits integer)\n+   */\n+  public UniformRandomGenerator(int seed) {\n+    generator = new Random(seed);\n+  }\n+\n+  /** Create a new generator initialized with a single long seed.\n+   * @param seed seed for the generator (64 bits integer)\n+   */\n+  public UniformRandomGenerator(long seed) {\n+    generator = new Random(seed);\n+  }\n+\n+  /** Generate a random scalar with null mean and unit standard deviation.\n+   * <p>The number generated is uniformly distributed between -sqrt(3)\n+   * and sqrt(3).</p>\n+   * @return a random scalar with null mean and unit standard deviation\n+   */\n+  public double nextDouble() {\n+    return TWOSQRT3 * generator.nextDouble() - SQRT3;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+\n+import java.util.Arrays;\n+\n+/** This class compute basic statistics on a scalar sample.\n+ * @version $Id: VectorialSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ */\n+public class VectorialSampleStatistics {\n+\n+  /** Dimension of the vectors to handle. */\n+  private int dimension;\n+\n+  /** Number of sample points. */\n+  private int n;\n+\n+  /** Indices of the minimal values occurrence in the sample. */\n+  private int[] minIndices;\n+\n+  /** Minimal value in the sample. */\n+  private double[] min;\n+\n+  /** Maximal value in the sample. */\n+  private double[] max;\n+\n+  /** Indices of the maximal values occurrence in the sample. */\n+  private int[] maxIndices;\n+\n+  /** Sum of the sample values. */\n+  private double[] sum;\n+\n+  /** Sum of the squares of the sample values. */\n+  private double[] sum2;\n+\n+  /** Simple constructor.\n+   * Build a new empty instance\n+   */\n+  public VectorialSampleStatistics() {\n+    dimension  = -1;\n+    n          = 0;\n+    min        = null;\n+    minIndices = null;\n+    max        = null;\n+    maxIndices = null;\n+    sum        = null;\n+    sum2       = null;\n+  }\n+\n+  /** Allocate all the arrays. */\n+  private void allocate() {\n+    min        = new double[dimension];\n+    minIndices = new int[dimension];\n+    max        = new double[dimension];\n+    maxIndices = new int[dimension];\n+    sum        = new double[dimension];\n+    sum2       = new double[dimension * (dimension + 1) / 2];\n+  }\n+\n+  /** Add one point to the instance.\n+   * @param x value of the sample point\n+   * @exception IllegalArgumentException if there is a dimension\n+   * mismatch between this point and the ones already added (this\n+   * cannot happen when the instance is empty)\n+   */\n+  public void add(double[] x) {\n+\n+    if (n == 0) {\n+\n+      dimension = x.length;\n+      allocate();\n+\n+      Arrays.fill(minIndices, 0);\n+      Arrays.fill(maxIndices, 0);\n+      System.arraycopy(x, 0, min, 0, dimension);\n+      System.arraycopy(x, 0, max, 0, dimension);\n+      System.arraycopy(x, 0, sum, 0, dimension);\n+\n+      int k = 0;\n+      for (int i = 0; i < dimension; ++i) {\n+        for (int j = 0; j <= i; ++j) {\n+          sum2[k++] = x[i] * x[j];\n+        }\n+      }\n+\n+    } else {\n+      int k = 0;\n+      for (int i = 0; i < dimension; ++i) {\n+\n+        if (x[i] < min[i]) {\n+          min[i]        = x[i];\n+          minIndices[i] = n;\n+        } else if (x[i] > max[i]) {\n+          max[i]        = x[i];\n+          maxIndices[i] = n;\n+        }\n+\n+        sum[i] += x[i];\n+        for (int j = 0; j <= i; ++j) {\n+          sum2[k++] += x[i] * x[j];\n+        }\n+\n+      }\n+    }\n+\n+    ++n;\n+\n+  }\n+\n+  /** Add all points of an array to the instance.\n+   * @param points array of points\n+   * @exception IllegalArgumentException if there is a dimension\n+   * mismatch between these points and the ones already added (this\n+   * cannot happen when the instance is empty)\n+   */\n+  public void add(double[][] points) {\n+    for (int i = 0; i < points.length; ++i) {\n+      add(points[i]);\n+    }\n+  }\n+\n+  /** Add all the points of another sample to the instance.\n+   * @param s samples to add\n+   * @exception IllegalArgumentException if there is a dimension\n+   * mismatch between this sample points and the ones already added\n+   * (this cannot happen when the instance is empty)\n+   */\n+  public void add(VectorialSampleStatistics s) {\n+\n+    if (s.n == 0) {\n+      // nothing to add\n+      return;\n+    }\n+\n+    if (n == 0) {\n+\n+      dimension = s.dimension;\n+      allocate();\n+\n+      System.arraycopy(s.min,         0, min,         0, dimension);\n+      System.arraycopy(s.minIndices,  0, minIndices,  0, dimension);\n+      System.arraycopy(s.max,         0, max,         0, dimension);\n+      System.arraycopy(s.maxIndices,  0, maxIndices,  0, dimension);\n+      System.arraycopy(s.sum,         0, sum,         0, dimension);\n+      System.arraycopy(s.sum2,        0, sum2,        0, sum2.length);\n+\n+    } else {\n+      int k = 0;\n+\n+      for (int i = 0; i < dimension; ++i) {\n+\n+        if (s.min[i] < min[i]) {\n+          min[i]        = s.min[i];\n+          minIndices[i] = n;\n+        } else if (s.max[i] > max[i]) {\n+          max[i]        = s.max[i];\n+          maxIndices[i] = n;\n+        }\n+\n+        sum[i] += s.sum[i];\n+        for (int j = 0; j <= i; ++j) {\n+          sum2[k] += s.sum2[k];\n+          ++k;\n+        }\n+\n+      }\n+\n+    }\n+\n+    n += s.n;\n+\n+  }\n+\n+  /** Get the number of points in the sample.\n+   * @return number of points in the sample\n+   */\n+  public int size() {\n+    return n;\n+  }\n+\n+  /** Get the minimal value in the sample.\n+   * <p>Since all components of the sample vector can reach their\n+   * minimal value at different times, this vector should be\n+   * considered as gathering all minimas of all components. The index\n+   * of the sample at which the minimum was encountered can be\n+   * retrieved with the {@link #getMinIndices getMinIndices}\n+   * method.</p>\n+   * @return minimal value in the sample (the array is a reference to\n+   * an internal array that changes each time something is added to\n+   * the instance, the caller should neither change it nor rely on its\n+   * value in the long term)\n+   * @see #getMinIndices\n+   */\n+  public double[] getMin() {\n+    return min;\n+  }\n+\n+  /** Get the indices at which the minimal value occurred in the sample.\n+   * @return a vector reporting at which occurrence each component of\n+   * the sample reached its minimal value (the array is a reference to\n+   * an internal array that changes each time something is added to\n+   * the instance, the caller should neither change it nor rely on its\n+   * value in the long term)\n+   * @see #getMin\n+   */\n+  public int[] getMinIndices() {\n+    return minIndices;\n+  }\n+\n+  /** Get the maximal value in the sample.\n+   * <p>Since all components of the sample vector can reach their\n+   * maximal value at different times, this vector should be\n+   * considered as gathering all maximas of all components. The index\n+   * of the sample at which the maximum was encountered can be\n+   * retrieved with the {@link #getMaxIndices getMaxIndices}\n+   * method.</p>\n+   * @return maximal value in the sample (the array is a reference to\n+   * an internal array that changes each time something is added to\n+   * the instance, the caller should neither change it nor rely on its\n+   * value in the long term)\n+   * @see #getMaxIndices\n+   */\n+  public double[] getMax() {\n+    return max;\n+  }\n+\n+  /** Get the indices at which the maximal value occurred in the sample.\n+   * @return a vector reporting at which occurrence each component of\n+   * the sample reached its maximal value (the array is a reference to\n+   * an internal array that changes each time something is added to\n+   * the instance, the caller should neither change it nor rely on its\n+   * value in the long term)\n+   * @see #getMax\n+   */\n+  public int[] getMaxIndices() {\n+    return maxIndices;\n+  }\n+\n+  /** Get the mean value of the sample.\n+   * @param mean placeholder where to store the array, if null a new\n+   * array will be allocated\n+   * @return mean value of the sample or null if the sample is empty\n+   * and hence the dimension of the vectors is still unknown\n+   * (reference to mean if it was non-null, reference to a new array\n+   * otherwise)\n+   */\n+  public double[] getMean(double[] mean) {\n+    if (n == 0) {\n+      return null;\n+    }\n+    if (mean == null) {\n+      mean = new double[dimension];\n+    }\n+    for (int i = 0; i < dimension; ++i) {\n+      mean[i] = sum[i] / n;\n+    }\n+    return mean;\n+  }\n+\n+  /** Get the covariance matrix of the underlying law.\n+   * This method estimate the covariance matrix considering that the\n+   * data available are only a <em>sample</em> of all possible\n+   * values. This value is the sample covariance matrix (as opposed\n+   * to the population covariance matrix).\n+   * @param covariance placeholder where to store the matrix, if null\n+   * a new matrix will be allocated\n+   * @return covariance matrix of the underlying or null if the\n+   * sample has less than 2 points (reference to covariance if it was\n+   * non-null, reference to a new matrix otherwise)\n+   */\n+  public SymetricalMatrix getCovarianceMatrix(SymetricalMatrix covariance) {\n+\n+    if (n < 2) {\n+      return null;\n+    }\n+\n+    if (covariance == null) {\n+      covariance = new SymetricalMatrix(dimension);\n+    }\n+\n+    double c = 1.0 / (n * (n - 1));\n+    int k = 0;\n+    for (int i = 0; i < dimension; ++i) {\n+      for (int j = 0; j <= i; ++j) {\n+        double e = c * (n * sum2[k] - sum[i] * sum[j]);\n+        covariance.setElementAndSymetricalElement(i, j, e);\n+        ++k;\n+      }\n+    }\n+\n+    return covariance;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/BrentSolver.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This class implements the Brent algorithm to compute the roots of\n+ * a function in an interval.\n+\n+ * This class is basically a translation in Java of a fortran\n+ * implementation found at netlib (<a\n+ * href=\"http://www.netlib.org/fmm/zeroin.f\">zeroin.f</a>).\n+\n+ * @version $Id: BrentSolver.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class BrentSolver implements RootsFinder {\n+\n+  /** IEEE 754 epsilon . */\n+  private static final double epsilon = Math.pow(2.0, -52);\n+\n+  /** Root found. */\n+  private double root;\n+\n+  /** Simple constructor.\n+   * Build a Brent solver\n+   */\n+  public BrentSolver() {\n+    root = Double.NaN;\n+  }\n+\n+  /** Solve a function in a given interval known to contain a root.\n+   * @param function function for which a root should be found\n+   * @param checker checker for the convergence of the function\n+   * @param maxIter maximal number of iteration allowed\n+   * @param x0 abscissa of the lower bound of the interval\n+   * @param f0 value of the function the lower bound of the interval\n+   * @param x1 abscissa of the higher bound of the interval\n+   * @param f1 value of the function the higher bound of the interval\n+   * @return true if a root has been found in the given interval\n+   */\n+  public boolean findRoot(ComputableFunction function,\n+                          ConvergenceChecker checker,\n+                          int maxIter,\n+                          double x0, double f0, double x1, double f1)\n+    throws FunctionException {\n+\n+    double a  = x0;\n+    double fa = f0;\n+    double b  = x1;\n+    double fb = f1;\n+\n+    double c  = a;\n+    double fc = fa;\n+\n+    double d  = b - a;\n+    double e  = d;\n+\n+    double tolS;\n+    for (int iter = 0; iter < maxIter; ++iter) {\n+\n+      if (Math.abs(fc) < Math.abs(fb)) {\n+        // invert points\n+        a  = b;\n+        b  = c;\n+        c  = a;\n+        fa = fb;\n+        fb = fc;\n+        fc = fa;\n+      }\n+\n+      tolS = 2 * epsilon * Math.abs(b);\n+      double xm = 0.5 * (c - b);\n+\n+      // convergence test\n+      double xLow, fLow, xHigh, fHigh;\n+      if (b < c) {\n+        xLow   = b;\n+        fLow   = fb;\n+        xHigh  = c;\n+        fHigh  = fc;\n+      } else {\n+        xLow   = c;\n+        fLow   = fc;\n+        xHigh  = b;\n+        fHigh  = fb;\n+      }\n+\n+      switch (checker.converged(xLow, fLow, xHigh, fHigh)) {\n+      case ConvergenceChecker.LOW :\n+        root = xLow;\n+        return true;\n+      case ConvergenceChecker.HIGH :\n+        root = xHigh;\n+        return true;\n+      default :\n+        if ((Math.abs(xm) < tolS) || (Math.abs(fb) < Double.MIN_VALUE)) {\n+          root = b;\n+          return true;\n+        }\n+      }\n+\n+      if ((Math.abs(e) < tolS) || (Math.abs(fa) <= Math.abs(fb))) {\n+        // use bisection method\n+        d = xm;\n+        e = d;\n+      } else {\n+        // use secant method\n+        double p, q, r, s;\n+        s = fb / fa;\n+        if (Math.abs(a - c) < epsilon * Math.max(Math.abs(a), Math.abs(c))) {\n+          // linear interpolation using only b and c points\n+          p = 2.0 * xm * s;\n+          q = 1.0 - s;\n+        } else {\n+          // inverse quadratic interpolation using a, b and c points\n+          q = fa / fc;\n+          r = fb / fc;\n+          p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0));\n+          q = (q - 1.0) * (r - 1.0) * (s - 1.0);\n+        }\n+\n+        // signs adjustment\n+        if (p > 0.0) {\n+          q = -q;\n+        } else {\n+          p = -p;\n+        }\n+\n+        // is interpolation acceptable ?\n+        if (((2.0 * p) < (3.0 * xm * q - Math.abs(tolS * q)))\n+            &&\n+            (p < Math.abs(0.5 * e * q))) {\n+          e = d;\n+          d = p / q;\n+        } else {\n+          // no, we need to fall back to bisection\n+          d = xm;\n+          e = d;\n+        }\n+      }\n+\n+      // complete step\n+      a  = b;\n+      fa = fb;\n+      b += ((Math.abs(d) > tolS) ? d : (xm > 0.0 ? tolS : -tolS));\n+      fb = function.valueAt(b);\n+\n+      if (fb * fc > 0) {\n+        c  = a;\n+        fc = fa;\n+        d  = b - a;\n+        e  = d;\n+      }\n+\n+    }\n+\n+    // we have exceeded the maximal number of iterations\n+    return false;\n+\n+  }\n+\n+  /** Get the abscissa of the root.\n+   * @return abscissa of the root\n+   */\n+  public double getRoot() {\n+    return root;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/ConvergenceChecker.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+/** This interface specifies methods to check if a root-finding\n+ * algorithm has converged.\n+\n+ * Deciding if convergence has been reached is a problem-dependent\n+ * issue. The user should provide a class implementing this interface\n+ * to allow the root-finding algorithm to stop its search according to\n+ * the problem at hand.\n+\n+ * @version $Id: ConvergenceChecker.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface ConvergenceChecker {\n+\n+  /** Indicator for no convergence. */\n+  public static final int NONE = 0;\n+\n+  /** Indicator for convergence on the lower bound of the interval. */\n+  public static final int LOW  = 1;\n+\n+  /** Indicator for convergence on the higher bound of the interval. */\n+  public static final int HIGH = 2;\n+\n+  /** Check if the root-finding algorithm has converged on the interval.\n+   * The interval defined by the arguments contains one root (if there\n+   * was at least one in the initial interval given by the user to the\n+   * root-finding algorithm, of course)\n+   * @param xLow abscissa of the lower bound of the interval\n+   * @param fLow value of the function the lower bound of the interval\n+   * @param xHigh abscissa of the higher bound of the interval\n+   * @param fHigh value of the function the higher bound of the interval\n+   * @return convergence indicator, must be one of {@link #NONE},\n+   * {@link #LOW} or {@link #HIGH}\n+   */\n+  public int converged (double xLow, double fLow, double xHigh, double fHigh);\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/RootsFinder.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+/** This interface specifies root-finding methods for scalar\n+ * functions.\n+\n+ * @version $Id: RootsFinder.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface RootsFinder {\n+\n+  /** Solve a function in a given interval known to contain a root.\n+   * @param function function for which a root should be found\n+   * @param checker checker for the convergence of the function\n+   * @param maxIter maximal number of iteration allowed\n+   * @param x0 abscissa of the lower bound of the interval\n+   * @param f0 value of the function the lower bound of the interval\n+   * @param x1 abscissa of the higher bound of the interval\n+   * @param f1 value of the function the higher bound of the interval\n+   * @return true if a root has been found in the given interval\n+   */\n+  public boolean findRoot(ComputableFunction function,\n+                          ConvergenceChecker checker,\n+                          int maxIter,\n+                          double x0, double f0, double x1, double f1)\n+    throws FunctionException;\n+\n+  /** Get the abscissa of the root.\n+   * @return abscissa of the root\n+   */\n+  public double getRoot();\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+/**\n+ * This class dispatch data between an array and several domain objects.\n+\n+ * This class handles all the burden of mapping each domain object it\n+ * handles to a slice of a single array.\n+\n+ * @see ArraySliceMappable\n+\n+ * @version $Id: ArrayMapper.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ArrayMapper {\n+\n+  /** Simple constructor.\n+   * Build an empty array mapper\n+   */\n+  public ArrayMapper() {\n+    domainObjects = new ArrayList();\n+    size          = 0;\n+    internalData  = null;\n+  }\n+\n+  /** Simple constructor.\n+   * Build an array mapper managing one object. Other objects can be\n+   * added later using the {@link #manageMappable manageMappable}\n+   * method. This call is equivalent to build the mapper with the\n+   * default constructor and adding the object.\n+   * @param object domain object to handle\n+   */\n+  public ArrayMapper(ArraySliceMappable object) {\n+\n+    domainObjects = new ArrayList();\n+    domainObjects.add(new ArrayMapperEntry(object, 0));\n+\n+    size = object.getStateDimension();\n+\n+    internalData = new double [size];\n+\n+  }\n+\n+  /** Take a new domain object into account.\n+   * @param object domain object to handle\n+   */\n+  public void manageMappable(ArraySliceMappable object) {\n+\n+    domainObjects.add(new ArrayMapperEntry(object, size));\n+\n+    size += object.getStateDimension();\n+\n+    if (internalData != null) {\n+      internalData = new double [size];\n+    }\n+\n+  }\n+\n+  /** Get the internal data array.\n+   * @return internal data array\n+   */\n+  public double[] getInternalDataArray() {\n+    if (internalData == null) {\n+      internalData = new double [size];\n+    }\n+    return internalData;\n+  }\n+\n+  /** Map data from the internal array to the domain objects.\n+   */\n+  public void updateObjects() {\n+    if (internalData == null) {\n+      internalData = new double [size];\n+    }\n+    updateObjects(internalData);\n+  }\n+\n+  /** Map data from the specified array to the domain objects.\n+   * @param data flat array holding the data to dispatch\n+   */\n+  public void updateObjects(double[] data) {\n+    for (Iterator iter = domainObjects.iterator(); iter.hasNext();) {\n+      ArrayMapperEntry entry = (ArrayMapperEntry) iter.next();\n+      entry.object.mapStateFromArray(entry.offset, data);\n+    }\n+  }\n+\n+  /** Map data from the domain objects to the internal array.\n+   */\n+  public void updateArray() {\n+    if (internalData == null) {\n+      internalData = new double [size];\n+    }\n+    updateArray(internalData);\n+  }\n+\n+  /** Map data from the domain objects to the specified array.\n+   * @param data flat array where to put the data\n+   */\n+  public void updateArray(double[] data) {\n+    for (Iterator iter = domainObjects.iterator(); iter.hasNext();) {\n+      ArrayMapperEntry entry = (ArrayMapperEntry) iter.next();\n+      entry.object.mapStateToArray(entry.offset, data);\n+    }\n+  }\n+\n+  /** Container for all handled objects. */\n+  private ArrayList domainObjects;\n+\n+  /** Total number of scalar elements handled.\n+   * (size of the array)\n+   */\n+  private int size;\n+\n+  /** Flat array holding all data.\n+   * This is null as long as nobody uses it (lazy creation)\n+   */\n+  private double[] internalData;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapperEntry.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+/**\n+ * This class is a simple container for an offset and an\n+ * {@link ArraySliceMappable} object.\n+\n+ * @version $Id: ArrayMapperEntry.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class ArrayMapperEntry {\n+\n+  /** Mappable object. */\n+  public final ArraySliceMappable object;\n+\n+  /** Offset from start of array. */\n+  public final int offset;\n+\n+  /** Simple constructor.\n+   * @param object mappable object\n+   * @param offset offset from start of array\n+   */\n+  public ArrayMapperEntry(ArraySliceMappable object, int offset) {\n+    this.object = object;\n+    this.offset = offset;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArraySliceMappable.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+/** This interface is used to map objects to and from simple arrays.\n+ *\n+ * <p> Lots of mathematical algorithms are generic ones which can\n+ * process the data from domain objects despite they ignore what\n+ * this data represent. As an example, the same algorithm can\n+ * integrate either the orbit evolution of a spacecraft under a\n+ * specified force model or the electrical characteristics of a\n+ * circuit after a switch is opened.  </p>\n+\n+ * <p> The approach of the Mantissa library is to define an interface\n+ * for each such algorithm to represent the type of problem they can\n+ * handle ({@link\n+ * org.spaceroots.mantissa.ode.FirstOrderDifferentialEquations\n+ * FirstOrderDifferentialEquations} for an ODE integrators, {@link\n+ * org.spaceroots.mantissa.estimation.EstimationProblem\n+ * EstimationProblem} for least squares estimators, ...). Furthermore,\n+ * the state data that is handled by these algorithms is often a\n+ * mixture of data coming from several domain objects (the orbit,\n+ * plus the aerodynamical coefficients of the spacecraft, plus the\n+ * characteristics of the thrusters, plus ...). Therefore, the user\n+ * needs to gather and dispatch data between different objects\n+ * representing different levels of abstraction.  </p>\n+\n+ * <p> This interface is designed to copy data back and forth between\n+ * existing objects during the iterative processing of these\n+ * algorithms and avoid the cost of recreating the objects.  </p>\n+\n+ * <p> The nominal way to use this interface is to have the domain\n+ * objects implement it (either directly or using inheritance to add\n+ * this feature to already existing objects) and to create one class\n+ * that implements the problem interface (for example {@link\n+ * org.spaceroots.mantissa.ode.FirstOrderDifferentialEquations}) and\n+ * uses the {@link ArrayMapper} class to dispatch the data to and from\n+ * the domain objects.</p>\n+\n+ * @see ArrayMapper\n+ *\n+ * @version $Id: ArraySliceMappable.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface ArraySliceMappable {\n+    \n+    /** Get the dimension of the object.\n+     * @return dimension of the object\n+     */\n+    public int getStateDimension();\n+    \n+    /** Reinitialize internal state from the specified array slice data.\n+     * @param start start index in the array\n+     * @param array array holding the data to extract\n+     */\n+    public void mapStateFromArray(int start, double[] array);\n+    \n+    /** Store internal state data into the specified array slice.\n+     * @param start start index in the array\n+     * @param array array where data should be stored\n+     */\n+    public void mapStateToArray(int start, double[] array);\n+    \n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/Interval.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+/** This class represents an interval on the real line.\n+\n+ * <p>This class allows to perform simple interval operations like\n+ * point inclusion tests and intersection operations.</p>\n+\n+ * <p>There is no distinction between open and closed intervals\n+ * because real numbers cannot be represented exactly.</p>\n+\n+ * @see IntervalsList\n+ * @author Luc Maisonobe\n+ * @version $Id: Interval.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class Interval {\n+\n+  /** Build the [0, 0] interval.\n+   */\n+  public Interval() {\n+    inf = 0;\n+    sup = 0;\n+  }\n+\n+  /** Build an interval with the given bounds.\n+   * <p>The given bounds do not need to be ordered, they will be\n+   * reordered by the constructor.</p>\n+   * @param a first bound\n+   * @param b second bound\n+   */\n+  public Interval(double a, double b) {\n+    if (a <= b) {\n+      inf = a;\n+      sup = b;\n+    } else {\n+      inf = b;\n+      sup = a;\n+    }\n+  }\n+\n+  /** Copy-constructor.\n+   * @param i interval to copy\n+   */\n+  public Interval(Interval i) {\n+    inf = i.inf;\n+    sup = i.sup;\n+  }\n+\n+  /** Get the lower bound of the interval.\n+   * @return lower bound of the interval\n+   */\n+  public double getInf() {\n+    return inf;\n+  }\n+\n+  /** Get the upper bound of the interval.\n+   * @return upper bound of the interval\n+   */\n+  public double getSup() {\n+    return sup;\n+  }\n+\n+  /** Get the length of the interval.\n+   * @return length of the interval\n+   */\n+  public double getLength() {\n+    return sup - inf;\n+  }\n+\n+  /** Check if the interval contains a point.\n+   * @param x point to check\n+   * @return true if the interval contains x\n+   */\n+  public boolean contains(double x) {\n+    return (inf <= x) && (x <= sup);\n+  }\n+\n+  /** Check if the interval contains another interval.\n+   * @param i interval to check\n+   * @return true if i is completely included in the instance\n+   */\n+  public boolean contains(Interval i) {\n+    return (inf <= i.inf) && (i.sup <= sup);\n+  }\n+\n+  /** Check if an interval intersects the instance.\n+   * @param i interval to check\n+   * @return true if i intersects the instance\n+   */\n+  public boolean intersects(Interval i) {\n+    return (inf <= i.sup) && (i.inf <= sup);\n+  }\n+\n+  /** Add an interval to the instance.\n+   * <p>This method expands the instance.</p>\n+   * <p>This operation is <strong>not</strong> a union operation. If\n+   * the instance and the interval are disjoints (i.e. if {@link\n+   * #intersects intersects(i)} would return <code>false</code>), then\n+   * the hole between the intervals is filled in.</p>\n+   * @param i interval to add to the instance\n+   */\n+  public void addToSelf(Interval i) {\n+    inf = Math.min(inf, i.inf);\n+    sup = Math.max(sup, i.sup);\n+  }\n+\n+  /** Add two intervals.\n+   * <p>This operation is <strong>not</strong> a union operation. If\n+   * the intervals are disjoints (i.e. if {@link\n+   * #intersects i1.intersects(i2)} would return <code>false</code>), then\n+   * the hole between the intervals is filled in.</p>\n+   * @param i1 first interval\n+   * @param i2 second interval\n+   * @return a new interval\n+   */\n+  public static Interval add(Interval i1, Interval i2) {\n+    Interval copy = new Interval(i1);\n+    copy.addToSelf(i2);\n+    return copy;\n+  }\n+\n+  /** Intersects the instance with an interval.\n+   * <p>This method reduces the instance, it could even become empty\n+   * if the interval does not intersects the instance.</p>\n+   * @param i interval with which the instance should be intersected\n+   */\n+  public void intersectSelf(Interval i) {\n+    inf = Math.max(inf, i.inf);\n+    sup = Math.max(Math.min(sup, i.sup), inf);\n+  }\n+\n+  /** Intersect two intervals.\n+   * @param i1 first interval\n+   * @param i2 second interval\n+   * @return a new interval which is the intersection of i1 with i2\n+   */\n+  public static Interval intersection(Interval i1, Interval i2) {\n+    Interval copy = new Interval(i1);\n+    copy.intersectSelf(i2);\n+    return copy;\n+  }\n+\n+  /** Lower bound of the interval. */\n+  private double inf;\n+\n+  /** Upper bound of the interval. */\n+  private double sup;\n+\n+}\n+\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/IntervalsList.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Iterator;\n+\n+/** This class represents an intervals list.\n+ * <p>An interval list represent a list of contiguous regions on the\n+ * real line. All intervals of the list are disjoints to each other,\n+ * they are stored in ascending order.</p>\n+ * <p>The class supports the main set operations like union and\n+ * intersection.</p>\n+ * @see Interval\n+ * @author Luc Maisonobe\n+ * @version $Id: IntervalsList.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class IntervalsList {\n+\n+  /** Build an empty intervals list.\n+   */\n+  public IntervalsList() {\n+    intervals = new ArrayList();\n+  }\n+\n+  /** Build an intervals list containing only one interval.\n+   * @param a first bound of the interval\n+   * @param b second bound of the interval\n+   */\n+  public IntervalsList(double a, double b) {\n+    intervals = new ArrayList();\n+    intervals.add(new Interval(a, b));\n+  }\n+\n+  /** Build an intervals list containing only one interval.\n+   * @param i interval\n+   */\n+  public IntervalsList(Interval i) {\n+    intervals = new ArrayList();\n+    intervals.add(i);\n+  }\n+\n+  /** Build an intervals list containing two intervals.\n+   * @param i1 first interval\n+   * @param i2 second interval\n+   */\n+  public IntervalsList(Interval i1, Interval i2) {\n+    intervals = new ArrayList();\n+    if (i1.intersects(i2)) {\n+      intervals.add(new Interval(Math.min(i1.getInf(), i2.getInf()),\n+                                 Math.max(i1.getSup(), i2.getSup())));\n+    } else  if (i1.getSup () < i2.getInf()) {\n+      intervals.add(i1);\n+      intervals.add(i2);\n+    } else {\n+      intervals.add(i2);\n+      intervals.add(i1);\n+    }\n+  }\n+\n+  /** Copy constructor.\n+   * <p>The copy operation is a deep copy: the underlying intervals\n+   * are independant of the instances of the copied list.</p>\n+   * @param list intervals list to copy\n+   */\n+  public IntervalsList(IntervalsList list) {\n+    intervals = new ArrayList(list.intervals.size());\n+    for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {\n+      intervals.add(new Interval((Interval) iterator.next()));\n+    }\n+  }\n+\n+  /** Check if the instance is empty.\n+   * @return true if the instance is empty\n+   */\n+  public boolean isEmpty() {\n+    return intervals.isEmpty();\n+  }\n+\n+  /** Check if the instance is connected.\n+   * <p>An interval list is connected if it contains only one\n+   * interval.</p>\n+   * @return true is the instance is connected\n+   */\n+  public boolean isConnex() {\n+    return intervals.size() == 1;\n+  }\n+\n+  /** Get the lower bound of the list.\n+   * @return lower bound of the list or Double.NaN if the list does\n+   * not contain any interval\n+   */\n+  public double getInf() {\n+    return intervals.isEmpty()\n+         ? Double.NaN : ((Interval) intervals.get(0)).getInf();\n+  }\n+\n+  /** Get the upper bound of the list.\n+   * @return upper bound of the list or Double.NaN if the list does\n+   * not contain any interval\n+   */\n+  public double getSup() {\n+    return intervals.isEmpty()\n+         ? Double.NaN : ((Interval) intervals.get(intervals.size() - 1)).getSup();\n+  }\n+\n+  /** Get the number of intervals of the list.\n+   * @return number of intervals in the list\n+   */\n+  public int getSize() {\n+    return intervals.size();\n+  }\n+\n+  /** Get an interval from the list.\n+   * @param i index of the interval\n+   * @return interval at index i\n+   */\n+  public Interval getInterval(int i) {\n+    return (Interval) intervals.get(i);\n+  }\n+\n+  /** Get the ordered list of disjoints intervals.\n+   * @return list of disjoints intervals in ascending order\n+   */\n+  public List getIntervals() {\n+    return intervals;\n+  }\n+\n+  /** Check if the list contains a point.\n+   * @param x point to check\n+   * @return true if the list contains x\n+   */\n+  public boolean contains(double x) {\n+    for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {\n+      if (((Interval) iterator.next()).contains(x)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** Check if the list contains an interval.\n+   * @param i interval to check\n+   * @return true if i is completely included in the instance\n+   */\n+  public boolean contains(Interval i) {\n+    for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {\n+      if (((Interval) iterator.next()).contains(i)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** Check if an interval intersects the instance.\n+   * @param i interval to check\n+   * @return true if i intersects the instance\n+   */\n+  public boolean intersects(Interval i) {\n+    for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {\n+      if (((Interval) iterator.next()).intersects(i)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** Add an interval to the instance.\n+   * <p>This method expands the instance.</p>\n+   * <p>This operation is a union operation. The number of intervals\n+   * in the list can decrease if the interval fills some holes between\n+   * existing intervals in the list.</p>\n+   * @param i interval to add to the instance\n+   */\n+  public void addToSelf(Interval i) {\n+\n+    List    newIntervals = new ArrayList();\n+    double  inf          = Double.NaN;\n+    double  sup          = Double.NaN;\n+    boolean pending      = false;\n+    boolean processed    = false;\n+    for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {\n+      Interval local = (Interval) iterator.next();\n+      \n+      if (local.getSup() < i.getInf()) {\n+        newIntervals.add(local);\n+      } else if (local.getInf() < i.getSup()) {\n+        if (! pending) {\n+          inf     = Math.min(local.getInf(), i.getInf());\n+          pending   = true;\n+          processed = true;\n+        }\n+        sup = Math.max(local.getSup(), i.getSup());\n+      } else {\n+        if (pending) {\n+          newIntervals.add(new Interval(inf, sup));\n+          pending   = false;\n+        } else if (! processed) {\n+          newIntervals.add(i);\n+        }\n+        processed = true;\n+        newIntervals.add(local);\n+      }\n+    }\n+\n+    if (pending) {\n+      newIntervals.add(new Interval(inf, sup));\n+    } else if (! processed) {\n+      newIntervals.add(i);\n+    }\n+\n+    intervals = newIntervals;\n+\n+  }\n+\n+  /** Add an intervals list and an interval.\n+   * @param list intervals list\n+   * @param i interval\n+   * @return a new intervals list which is the union of list and i\n+   */\n+  public static IntervalsList add(IntervalsList list, Interval i) {\n+    IntervalsList copy = new IntervalsList(list);\n+    copy.addToSelf(i);\n+    return copy;\n+  }\n+\n+  /** Remove an interval from the list.\n+   * <p>This method reduces the instance. This operation is defined in\n+   * terms of points set operation. As an example, if the [2, 3]\n+   * interval is subtracted from the list containing only the [0, 10]\n+   * interval, the result will be the [0, 2] U [3, 10] intervals\n+   * list.</p>\n+   * @param i interval to remove\n+   */\n+  public void subtractFromSelf(Interval i) {\n+    double a = Math.min(getInf(), i.getInf());\n+    double b = Math.max(getSup(), i.getSup());\n+    intersectSelf(new IntervalsList(new Interval(a - 1.0, i.getInf()),\n+                                   new Interval(i.getSup(), b + 1.0)));\n+  }\n+\n+  /** Remove an interval from a list.\n+   * @param list intervals list\n+   * @param i interval to remove\n+   * @return a new intervals list\n+   */\n+  public static IntervalsList subtract(IntervalsList list, Interval i) {\n+    IntervalsList copy = new IntervalsList(list);\n+    copy.subtractFromSelf(i);\n+    return copy;\n+  }\n+\n+  /** Intersects the instance and an interval.\n+   * @param i interval\n+   */\n+  public void intersectSelf(Interval i) {\n+    List newIntervals = new ArrayList();\n+    for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {\n+      Interval local = (Interval) iterator.next();\n+      if (local.intersects(i)) {\n+        newIntervals.add(Interval.intersection(local, i));\n+      }\n+    }\n+    intervals = newIntervals;\n+  }\n+\n+  /** Intersect a list and an interval.\n+   * @param list intervals list\n+   * @param i interval\n+   * @return the intersection of list and i\n+   */\n+  public static IntervalsList intersection(IntervalsList list, Interval i) {\n+    IntervalsList copy = new IntervalsList(list);\n+    copy.intersectSelf(i);\n+    return copy;\n+  }\n+\n+  /** Add an intervals list to the instance.\n+   * <p>This method expands the instance.</p>\n+   * <p>This operation is a union operation. The number of intervals\n+   * in the list can decrease if the list fills some holes between\n+   * existing intervals in the instance.</p>\n+   * @param list intervals list to add to the instance\n+   */\n+  public void addToSelf(IntervalsList list) {\n+    for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {\n+      addToSelf((Interval) iterator.next());\n+    }\n+  }\n+\n+  /** Add two intervals lists.\n+   * @param list1 first intervals list\n+   * @param list2 second intervals list\n+   * @return a new intervals list which is the union of list1 and list2\n+   */\n+  public static IntervalsList add(IntervalsList list1, IntervalsList list2) {\n+    IntervalsList copy = new IntervalsList(list1);\n+    copy.addToSelf(list2);\n+    return copy;\n+  }\n+\n+  /** Remove an intervals list from the instance.\n+   * @param list intervals list to remove\n+   */\n+  public void subtractFromSelf(IntervalsList list) {\n+    for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {\n+      subtractFromSelf((Interval) iterator.next());\n+    }\n+  }\n+\n+  /** Remove an intervals list from another one.\n+   * @param list1 intervals list\n+   * @param list2 intervals list to remove\n+   * @return a new intervals list\n+   */\n+  public static IntervalsList subtract(IntervalsList list1, IntervalsList list2) {\n+    IntervalsList copy = new IntervalsList(list1);\n+    copy.subtractFromSelf(list2);\n+    return copy;\n+  }\n+\n+  /** Intersect the instance and another intervals list.\n+   * @param list list to intersect with the instance\n+   */\n+  public void intersectSelf(IntervalsList list) {\n+    intervals = intersection(this, list).intervals;\n+  }\n+\n+  /** Intersect two intervals lists.\n+   * @param list1 first intervals list\n+   * @param list2 second intervals list\n+   * @return a new list which is the intersection of list1 and list2\n+   */\n+  public static IntervalsList intersection(IntervalsList list1, IntervalsList list2) {\n+    IntervalsList list = new IntervalsList();\n+    for (Iterator iterator = list2.intervals.iterator(); iterator.hasNext();) {\n+      list.addToSelf(intersection(list1, (Interval) iterator.next()));\n+    }\n+    return list;\n+  }\n+\n+  /** The list of intervals. */\n+  private List intervals;\n+\n+}\n+\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+/**\n+ * Wrapper class around an array in order to have it implement the\n+ * {@link ArraySliceMappable} interface.\n+\n+ * @version $Id: MappableArray.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MappableArray\n+  implements ArraySliceMappable {\n+\n+  /** Simple constructor.\n+   * Build a mappable array from its dimension\n+   * @param dimension dimension of the array\n+   */\n+  public MappableArray(int dimension) {\n+    internalArray = new double[dimension];\n+    for (int i = 0; i < dimension; ++i) {\n+      internalArray[i] = 0;\n+    }\n+  }\n+\n+  /** Simple constructor.\n+   * Build a mappable array from an existing array\n+   * @param array array to use\n+   * @param doReallocate true if a new array should be allocated and\n+   * initialized using the other argument, false if the instance\n+   * should reference the existing array throughout its lifetime\n+   */\n+  public MappableArray(double[] array, boolean doReallocate) {\n+    if (doReallocate) {\n+      internalArray = new double[array.length];\n+      System.arraycopy(array, 0, internalArray, 0, array.length);\n+    } else {\n+      internalArray = array;\n+    }\n+  }\n+\n+  /** Get the array stored in the instance.\n+   * @return array stored in the instance\n+   */\n+  public double[] getArray () {\n+    return internalArray;\n+  }\n+\n+  /** Get the dimension of the internal array.\n+   * @return dimension of the array\n+   */\n+  public int getStateDimension() {\n+    return internalArray.length;\n+  }\n+    \n+  /** Reinitialize internal state from the specified array slice data.\n+   * @param start start index in the array\n+   * @param array array holding the data to extract\n+   */\n+  public void mapStateFromArray(int start, double[] array) {\n+    System.arraycopy(array, start, internalArray, 0, internalArray.length);\n+  }\n+    \n+  /** Store internal state data into the specified array slice.\n+   * @param start start index in the array\n+   * @param array array where data should be stored\n+   */\n+  public void mapStateToArray(int start, double[] array) {\n+    System.arraycopy(internalArray, 0, array, start, internalArray.length);\n+  }\n+\n+  /** Internal array holding all data.\n+   */\n+  double[] internalArray;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableScalar.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+/**\n+ * Wrapper class around a scalar in order to have it implement the\n+ * {@link ArraySliceMappable} interface.\n+\n+ * @version $Id: MappableScalar.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MappableScalar\n+  implements ArraySliceMappable {\n+\n+  /** Simple constructor.\n+   * Build a mappable scalar\n+   */\n+  public MappableScalar() {\n+    value = 0;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a mappable scalar from its initial value\n+   * @param value initial value of the scalar\n+   */\n+  public MappableScalar(double value) {\n+    this.value = value;\n+  }\n+\n+  /** Get the value stored in the instance.\n+   * @return value stored in the instance\n+   */\n+  public double getValue () {\n+    return value;\n+  }\n+\n+  /** Set the value stored in the instance.\n+   * @param value value to store in the instance\n+   */\n+  public void setValue (double value) {\n+    this.value = value;\n+  }\n+\n+  /** Get the dimension of the internal array.\n+   * @return dimension of the array (always 1 for this class)\n+   */\n+  public int getStateDimension() {\n+    return 1;\n+  }\n+    \n+  /** Reinitialize internal state from the specified array slice data.\n+   * @param start start index in the array\n+   * @param array array holding the data to extract\n+   */\n+  public void mapStateFromArray(int start, double[] array) {\n+    value = array[start];\n+  }\n+    \n+  /** Store internal state data into the specified array slice.\n+   * @param start start index in the array\n+   * @param array array where data should be stored\n+   */\n+  public void mapStateToArray(int start, double[] array) {\n+    array[start] = value;\n+  }\n+\n+  /** Internal scalar.\n+   */\n+  double value;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+  public static Test suite() { \n+\n+    TestSuite suite= new TestSuite(\"org.spaceroots.mantissa\"); \n+\n+    suite.addTest(org.spaceroots.mantissa.linalg.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.estimation.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.functions.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.roots.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.fitting.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.ode.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.quadrature.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.utilities.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.geometry.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.algebra.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.optimization.AllTests.suite()); \n+\n+    return suite; \n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.algebra\"); \n+\n+    suite.addTest(RationalNumberTest.suite());\n+    suite.addTest(PolynomialRationalTest.suite());\n+    suite.addTest(PolynomialDoubleTest.suite());\n+    suite.addTest(ChebyshevTest.suite());\n+    suite.addTest(HermiteTest.suite());\n+    suite.addTest(LegendreTest.suite());\n+    suite.addTest(LaguerreTest.suite());\n+    suite.addTest(PolynomialFractionTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/ChebyshevTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class ChebyshevTest\n+  extends TestCase {\n+\n+  public ChebyshevTest(String name) {\n+    super(name);\n+  }\n+\n+  public void aatestOne() {\n+    assertTrue(new Chebyshev().isOne());\n+  }\n+\n+  public void testFirstPolynomials() {\n+\n+    checkPolynomial(new Chebyshev(3), \"-3 x + 4 x^3\");\n+    checkPolynomial(new Chebyshev(2), \"-1 + 2 x^2\");\n+    checkPolynomial(new Chebyshev(1), \"x\");\n+    checkPolynomial(new Chebyshev(0), \"1\");\n+\n+    checkPolynomial(new Chebyshev(7), \"-7 x + 56 x^3 - 112 x^5 + 64 x^7\");\n+    checkPolynomial(new Chebyshev(6), \"-1 + 18 x^2 - 48 x^4 + 32 x^6\");\n+    checkPolynomial(new Chebyshev(5), \"5 x - 20 x^3 + 16 x^5\");\n+    checkPolynomial(new Chebyshev(4), \"1 - 8 x^2 + 8 x^4\");\n+\n+  }\n+\n+  public void aatestBounds() {\n+    for (int k = 0; k < 12; ++k) {\n+      Chebyshev Tk = new Chebyshev(k);\n+      for (double x = -1.0; x <= 1.0; x += 0.02) {\n+        assertTrue(Math.abs(Tk.valueAt(x)) < (1.0 + 1.0e-12));\n+      }\n+    }\n+  }\n+\n+  public void aatestDifferentials() {\n+    for (int k = 0; k < 12; ++k) {\n+\n+      Polynomial.Rational Tk0 = new Chebyshev(k);\n+      Polynomial.Rational Tk1 = (Polynomial.Rational) Tk0.getDerivative();\n+      Polynomial.Rational Tk2 = (Polynomial.Rational) Tk1.getDerivative();\n+\n+      Polynomial.Rational g0 = new Polynomial.Rational(k * k);\n+      Polynomial.Rational g1 = new Polynomial.Rational(-1l, 0l);\n+      Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);\n+\n+      Polynomial.Rational Tk0g0 = Polynomial.Rational.multiply(Tk0, g0);\n+      Polynomial.Rational Tk1g1 = Polynomial.Rational.multiply(Tk1, g1);\n+      Polynomial.Rational Tk2g2 = Polynomial.Rational.multiply(Tk2, g2);\n+\n+      Polynomial.Rational d =\n+        Polynomial.Rational.add(Tk0g0, Polynomial.Rational.add(Tk1g1, Tk2g2));\n+      assertTrue(d.isZero());\n+\n+    }\n+  }\n+\n+  public void checkPolynomial(Polynomial.Rational p, String reference) {\n+    assertTrue(p.toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ChebyshevTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/HermiteTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class HermiteTest\n+  extends TestCase {\n+\n+  public HermiteTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testOne() {\n+    assertTrue(new Hermite().isOne());\n+  }\n+\n+  public void testFirstPolynomials() {\n+\n+    checkPolynomial(new Hermite(3), \"-12 x + 8 x^3\");\n+    checkPolynomial(new Hermite(2), \"-2 + 4 x^2\");\n+    checkPolynomial(new Hermite(1), \"2 x\");\n+    checkPolynomial(new Hermite(0), \"1\");\n+\n+    checkPolynomial(new Hermite(7), \"-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7\");\n+    checkPolynomial(new Hermite(6), \"-120 + 720 x^2 - 480 x^4 + 64 x^6\");\n+    checkPolynomial(new Hermite(5), \"120 x - 160 x^3 + 32 x^5\");\n+    checkPolynomial(new Hermite(4), \"12 - 48 x^2 + 16 x^4\");\n+\n+  }\n+\n+  public void testDifferentials() {\n+    for (int k = 0; k < 12; ++k) {\n+\n+      Polynomial.Rational Hk0 = new Hermite(k);\n+      Polynomial.Rational Hk1 = (Polynomial.Rational) Hk0.getDerivative();\n+      Polynomial.Rational Hk2 = (Polynomial.Rational) Hk1.getDerivative();\n+\n+      Polynomial.Rational g0 = new Polynomial.Rational(2l * k);\n+      Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);\n+      Polynomial.Rational g2 = new Polynomial.Rational(1l);\n+\n+      Polynomial.Rational Hk0g0 = Polynomial.Rational.multiply(Hk0, g0);\n+      Polynomial.Rational Hk1g1 = Polynomial.Rational.multiply(Hk1, g1);\n+      Polynomial.Rational Hk2g2 = Polynomial.Rational.multiply(Hk2, g2);\n+\n+      Polynomial.Rational d =\n+        Polynomial.Rational.add(Hk0g0, Polynomial.Rational.add(Hk1g1, Hk2g2));\n+      assertTrue(d.isZero());\n+\n+    }\n+  }\n+\n+  public void checkPolynomial(Polynomial.Rational p, String reference) {\n+    assertTrue(p.toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HermiteTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LaguerreTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class LaguerreTest\n+  extends TestCase {\n+\n+  public LaguerreTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testOne() {\n+    assertTrue(new Laguerre().isOne());\n+  }\n+\n+  public void testFirstPolynomials() {\n+\n+    checkLaguerre(new Laguerre(3), 6l, \"6 - 18 x + 9 x^2 - x^3\");\n+    checkLaguerre(new Laguerre(2), 2l, \"2 - 4 x + x^2\");\n+    checkLaguerre(new Laguerre(1), 1l, \"1 - x\");\n+    checkLaguerre(new Laguerre(0), 1l, \"1\");\n+\n+    checkLaguerre(new Laguerre(7), 5040l,\n+                  \"5040 - 35280 x + 52920 x^2 - 29400 x^3\"\n+                  + \" + 7350 x^4 - 882 x^5 + 49 x^6 - x^7\");\n+    checkLaguerre(new Laguerre(6),  720l,\n+                  \"720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4\"\n+                  + \" - 36 x^5 + x^6\");\n+    checkLaguerre(new Laguerre(5),  120l,\n+                  \"120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5\");\n+    checkLaguerre(new Laguerre(4),   24l,\n+                  \"24 - 96 x + 72 x^2 - 16 x^3 + x^4\");\n+\n+  }\n+\n+  public void testDifferentials() {\n+    for (int k = 0; k < 12; ++k) {\n+\n+      Polynomial.Rational Lk0 = new Laguerre(k);\n+      Polynomial.Rational Lk1 = (Polynomial.Rational) Lk0.getDerivative();\n+      Polynomial.Rational Lk2 = (Polynomial.Rational) Lk1.getDerivative();\n+\n+      Polynomial.Rational g0 = new Polynomial.Rational(k);\n+      Polynomial.Rational g1 = new Polynomial.Rational(-1l, 1l);\n+      Polynomial.Rational g2 = new Polynomial.Rational(1l, 0l);\n+\n+      Polynomial.Rational Lk0g0 = Polynomial.Rational.multiply(Lk0, g0);\n+      Polynomial.Rational Lk1g1 = Polynomial.Rational.multiply(Lk1, g1);\n+      Polynomial.Rational Lk2g2 = Polynomial.Rational.multiply(Lk2, g2);\n+\n+      Polynomial.Rational d =\n+        Polynomial.Rational.add(Lk0g0, Polynomial.Rational.add(Lk1g1, Lk2g2));\n+      assertTrue(d.isZero());\n+\n+    }\n+  }\n+\n+  public void checkLaguerre(Laguerre p, long denominator, String reference) {\n+    assertTrue(Laguerre.multiply(p, denominator).toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(LaguerreTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LegendreTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class LegendreTest\n+  extends TestCase {\n+\n+  public LegendreTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testOne() {\n+    assertTrue(new Legendre().isOne());\n+  }\n+\n+  public void testFirstPolynomials() {\n+\n+    checkLegendre(new Legendre(3),  2l, \"-3 x + 5 x^3\");\n+    checkLegendre(new Legendre(2),  2l, \"-1 + 3 x^2\");\n+    checkLegendre(new Legendre(1),  1l, \"x\");\n+    checkLegendre(new Legendre(0),  1l, \"1\");\n+\n+    checkLegendre(new Legendre(7), 16l, \"-35 x + 315 x^3 - 693 x^5 + 429 x^7\");\n+    checkLegendre(new Legendre(6), 16l, \"-5 + 105 x^2 - 315 x^4 + 231 x^6\");\n+    checkLegendre(new Legendre(5),  8l, \"15 x - 70 x^3 + 63 x^5\");\n+    checkLegendre(new Legendre(4),  8l, \"3 - 30 x^2 + 35 x^4\");\n+\n+  }\n+\n+  public void testDifferentials() {\n+    for (int k = 0; k < 12; ++k) {\n+\n+      Polynomial.Rational Pk0 = new Legendre(k);\n+      Polynomial.Rational Pk1 = (Polynomial.Rational) Pk0.getDerivative();\n+      Polynomial.Rational Pk2 = (Polynomial.Rational) Pk1.getDerivative();\n+\n+      Polynomial.Rational g0 = new Polynomial.Rational(k * (k + 1));\n+      Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);\n+      Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);\n+\n+      Polynomial.Rational Pk0g0 = Polynomial.Rational.multiply(Pk0, g0);\n+      Polynomial.Rational Pk1g1 = Polynomial.Rational.multiply(Pk1, g1);\n+      Polynomial.Rational Pk2g2 = Polynomial.Rational.multiply(Pk2, g2);\n+\n+      Polynomial.Rational d =\n+        Polynomial.Rational.add(Pk0g0, Polynomial.Rational.add(Pk1g1, Pk2g2));\n+      assertTrue(d.isZero());\n+\n+    }\n+  }\n+\n+  public void testHighDegree() {\n+    checkLegendre(new Legendre(40), 274877906944l,\n+                  \"34461632205\"\n+                + \" - 28258538408100 x^2\"\n+                + \" + 3847870979902950 x^4\"\n+                + \" - 207785032914759300 x^6\"\n+                + \" + 5929294332103310025 x^8\"\n+                + \" - 103301483474866556880 x^10\"\n+                + \" + 1197358103913226000200 x^12\"\n+                + \" - 9763073770369381232400 x^14\"\n+                + \" + 58171647881784229843050 x^16\"\n+                + \" - 260061484647976556945400 x^18\"\n+                + \" + 888315281771246239250340 x^20\"\n+                + \" - 2345767627188139419665400 x^22\"\n+                + \" + 4819022625419112503443050 x^24\"\n+                + \" - 7710436200670580005508880 x^26\"\n+                + \" + 9566652323054238154983240 x^28\"\n+                + \" - 9104813935044723209570256 x^30\"\n+                + \" + 6516550296251767619752905 x^32\"\n+                + \" - 3391858621221953912598660 x^34\"\n+                + \" + 1211378079007840683070950 x^36\"\n+                + \" - 265365894974690562152100 x^38\"\n+                + \" + 26876802183334044115405 x^40\");\n+  }\n+\n+  public void checkLegendre(Legendre p, long denominator, String reference) {\n+    assertTrue(Legendre.multiply(p, denominator).toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(LegendreTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialDoubleTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class PolynomialDoubleTest\n+  extends TestCase {\n+\n+  public PolynomialDoubleTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstructors() {\n+\n+    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);\n+    double[] a = p.getCoefficients();\n+    assertEquals(a.length, 3);\n+    assertEquals(-5.0, a[0], 1.0e-12);\n+    assertEquals(3.0,  a[1], 1.0e-12);\n+    assertEquals(1.0,  a[2], 1.0e-12);\n+    assertEquals(p.getDegree(), 2);\n+\n+    assertEquals(1, new Polynomial.Double(0.0, 3.0, 5.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(0.0, 0.0, 5.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(0.0, 0.0, 0.0).getDegree());\n+    assertEquals(1, new Polynomial.Double(3.0, 5.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(0.0, 5.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(0.0, 0.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(5.0).getDegree());\n+    assertEquals(0, new Polynomial.Double(0.0).getDegree());\n+\n+  }\n+\n+  public void testConversion() {\n+    Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);\n+    r.multiplySelf(new RationalNumber(1l, 2l));\n+    Polynomial.Double p = new Polynomial.Double(r);\n+    checkPolynomial(p, \"-2.5 + 1.5 x + 0.5 x^2\");\n+  }\n+\n+  public void testString() {\n+\n+    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);\n+    checkPolynomial(p, \"-5.0 + 3.0 x + x^2\");\n+    p.setUnknownName(\"alpha\");\n+    checkPolynomial(p, \"-5.0 + 3.0 alpha + alpha^2\");\n+    p.setUnknownName(null);\n+    checkPolynomial(p, \"-5.0 + 3.0 x + x^2\");\n+\n+    checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),\n+                    \"-2.0 x + 3.0 x^2\");\n+    checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),\n+                    \"1.0 - 2.0 x + 3.0 x^2\");\n+    checkPolynomial(new Polynomial.Double(3.0,  2.0, 0.0),\n+                    \"2.0 x + 3.0 x^2\");\n+    checkPolynomial(new Polynomial.Double(3.0,  2.0, 1.0),\n+                    \"1.0 + 2.0 x + 3.0 x^2\");\n+    checkPolynomial(new Polynomial.Double(3.0,  0.0, 1.0),\n+                    \"1.0 + 3.0 x^2\");\n+    checkPolynomial(new Polynomial.Double(0.0),\n+                    \"0\");\n+\n+  }\n+\n+  public void testAddition() {\n+\n+    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);\n+    Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);\n+    assertTrue(Polynomial.Double.add(p1, p2).isZero());\n+\n+    p2 = new Polynomial.Double(p1);\n+    p2.addToSelf(p2);\n+    checkPolynomial(p2, \"-4.0 + 2.0 x\");\n+\n+    p1 = new Polynomial.Double(2.0, -4.0, 1.0);\n+    p2 = new Polynomial.Double(-2.0, 3.0, -1.0);\n+    p1.addToSelf(p2);\n+    assertEquals(1, p1.getDegree());\n+    checkPolynomial(p1, \"-x\");\n+\n+  }\n+\n+  public void testSubtraction() {\n+\n+    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);\n+    assertTrue(Polynomial.Double.subtract(p1, p1).isZero());\n+\n+    Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);\n+    p2.subtractFromSelf(p1);\n+    checkPolynomial(p2, \"5.0 x\");\n+\n+    p1 = new Polynomial.Double(2.0, -4.0, 1.0);\n+    p2 = new Polynomial.Double(2.0, 3.0, -1.0);\n+    p1.subtractFromSelf(p2);\n+    assertEquals(1, p1.getDegree());\n+    checkPolynomial(p1, \"2.0 - 7.0 x\");\n+\n+  }\n+\n+  public void testMultiplication() {\n+\n+    Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);\n+    Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);\n+    checkPolynomial(Polynomial.Double.multiply(p1, p2), \"-9.0 + x^2 + 2.0 x^3\");\n+\n+    p1 = new Polynomial.Double(1.0, 0.0);\n+    p2 = new Polynomial.Double(p1);\n+    for (int i = 2; i < 10; ++i) {\n+      p2.multiplySelf(p1);\n+      checkPolynomial(p2, \"x^\" + i);\n+    }\n+\n+  }\n+\n+  public void checkPolynomial(Polynomial.Double p, String reference) {\n+    assertEquals(reference, p.toString());\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(PolynomialDoubleTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialFractionTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class PolynomialFractionTest\n+  extends TestCase {\n+\n+  public PolynomialFractionTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNullDenominator() {\n+    try {\n+      new PolynomialFraction(1l, 0l);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+  }\n+\n+  public void testToString() {\n+    checkValue(new PolynomialFraction(1l, 2l),  \"1/2\");\n+    checkValue(new PolynomialFraction(-1l, 2l), \"-1/2\");\n+    checkValue(new PolynomialFraction(1l, -2l), \"-1/2\");\n+    checkValue(new PolynomialFraction(-1l, -2l), \"1/2\");\n+    checkValue(new PolynomialFraction(0l, 500l), \"0\");\n+    checkValue(new PolynomialFraction(-12l), \"-12\");\n+    checkValue(new PolynomialFraction(12l), \"12\");\n+  }\n+\n+  public void testSimplification() {\n+    checkValue(new PolynomialFraction(2l, 4l), \"1/2\");\n+    checkValue(new PolynomialFraction(307692l, 999999l), \"4/13\");\n+    checkValue(new PolynomialFraction(999999l, 307692l), \"13/4\");\n+  }\n+\n+  public void testInvert() {\n+\n+    PolynomialFraction f = new PolynomialFraction(2l, 4l);\n+    f.invertSelf();\n+    checkValue(f, \"2\");\n+    f.invertSelf();\n+    checkValue(f, \"1/2\");\n+\n+    f = new PolynomialFraction(120l);\n+    f.invertSelf();\n+    checkValue(f, \"1/120\");\n+\n+    f = new PolynomialFraction(0l, 4l);\n+    try {\n+      f.invertSelf();\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+    f = new PolynomialFraction(307692l, 999999l);\n+    PolynomialFraction fInverse = PolynomialFraction.invert(f);\n+    checkValue(fInverse, \"13/4\");\n+    checkValue(f, \"4/13\");\n+\n+  }\n+\n+  public void testAddition() {\n+\n+    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);\n+    f1.addToSelf(f1);\n+    checkValue(f1, \"4/3\");\n+\n+    checkValue(PolynomialFraction.add(new PolynomialFraction(17l, 3l),\n+                                      new PolynomialFraction(-17l, 3l)),\n+               \"0\");\n+    checkValue(PolynomialFraction.add(new PolynomialFraction(2l, 3l),\n+                                      new PolynomialFraction(3l, 4l)),\n+               \"17/12\");\n+    checkValue(PolynomialFraction.add(new PolynomialFraction(1l, 6l),\n+                                      new PolynomialFraction(2l, 6l)),\n+               \"1/2\");\n+    checkValue(PolynomialFraction.add(new PolynomialFraction(4l, 5l),\n+                                      new PolynomialFraction(-3l, 4l)),\n+               \"1/20\");\n+    checkValue(PolynomialFraction.add(new PolynomialFraction(-3l, 4l),\n+                                      new PolynomialFraction(4l, 5l)),\n+               \"1/20\");\n+\n+  }\n+\n+  public void testSubtraction() {\n+\n+    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);\n+    f1.subtractFromSelf(f1);\n+    checkValue(f1, \"0\");\n+\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(7l, 3l),\n+                                           new PolynomialFraction(-7l, 3l)),\n+               \"14/3\");\n+\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(3l, 4l),\n+                                           new PolynomialFraction(2l, 3l)),\n+               \"1/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(3l, 4l),\n+                                           new PolynomialFraction(-2l, 3l)),\n+               \"17/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-3l, 4l),\n+                                           new PolynomialFraction(2l, 3l)),\n+               \"-17/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-3l, 4l),\n+                                           new PolynomialFraction(-2l, 3l)),\n+               \"-1/12\");\n+\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(2l, 3l),\n+                                           new PolynomialFraction(3l, 4l)),\n+               \"-1/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-2l, 3l),\n+                                           new PolynomialFraction(3l, 4l)),\n+               \"-17/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(2l, 3l),\n+                                           new PolynomialFraction(-3l, 4l)),\n+               \"17/12\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-2l, 3l),\n+                                           new PolynomialFraction(-3l, 4l)),\n+               \"1/12\");\n+\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(1l, 6l),\n+                                           new PolynomialFraction(2l, 6l)),\n+               \"-1/6\");\n+    checkValue(PolynomialFraction.subtract(new PolynomialFraction(1l, 2l),\n+                                           new PolynomialFraction(1l, 6l)),\n+               \"1/3\");\n+\n+  }\n+\n+  public void testMultiplication() {\n+\n+    PolynomialFraction f = new PolynomialFraction(2l, 3l);\n+    f.multiplySelf(new PolynomialFraction(9l,4l));\n+    checkValue(f, \"3/2\");\n+\n+    checkValue(PolynomialFraction.multiply(new PolynomialFraction(1l, 2l),\n+                                           new PolynomialFraction(0l)),\n+               \"0\");\n+    checkValue(PolynomialFraction.multiply(new PolynomialFraction(4l, 15l),\n+                                           new PolynomialFraction(-5l, 2l)),\n+               \"-2/3\");\n+    checkValue(PolynomialFraction.multiply(new PolynomialFraction(-4l, 15l),\n+                                           new PolynomialFraction(5l, 2l)),\n+               \"-2/3\");\n+    checkValue(PolynomialFraction.multiply(new PolynomialFraction(4l, 15l),\n+                                           new PolynomialFraction(5l, 2l)),\n+               \"2/3\");\n+    checkValue(PolynomialFraction.multiply(new PolynomialFraction(-4l, 15l),\n+                                           new PolynomialFraction(-5l, 2l)),\n+               \"2/3\");\n+\n+  }\n+\n+  public void testDivision() {\n+\n+    PolynomialFraction f = new PolynomialFraction(2l, 3l);\n+    f.divideSelf(new PolynomialFraction(4l,9l));\n+    checkValue(f, \"3/2\");\n+\n+    try {\n+      PolynomialFraction.divide(new PolynomialFraction(1l, 2l),\n+                                new PolynomialFraction(0l));\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+    checkValue(PolynomialFraction.divide(new PolynomialFraction(4l, 15l),\n+                                         new PolynomialFraction(-2l, 5l)),\n+               \"-2/3\");\n+    checkValue(PolynomialFraction.divide(new PolynomialFraction(-4l, 15l),\n+                                         new PolynomialFraction(2l, 5l)),\n+               \"-2/3\");\n+    checkValue(PolynomialFraction.divide(new PolynomialFraction(4l, 15l),\n+                                         new PolynomialFraction(2l, 5l)),\n+               \"2/3\");\n+    checkValue(PolynomialFraction.divide(new PolynomialFraction(-4l, 15l),\n+                                         new PolynomialFraction(-2l, 5l)),\n+               \"2/3\");\n+\n+  }\n+\n+  public void testEuclidianDivision() {\n+    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 0l, -1l),\n+                                      new Polynomial.Rational(2l, 2l)),\n+               \"-1/2 + 1/2 x\");\n+    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 3l, 2l),\n+                                      new Polynomial.Rational(2l, 10l, 12l)),\n+               \"(1 + x)/(6 + 2 x)\");\n+  }\n+\n+  private void checkValue(PolynomialFraction f, String reference) {\n+    assertTrue(f.toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(PolynomialFractionTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialRationalTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.math.BigInteger;\n+\n+import junit.framework.*;\n+\n+public class PolynomialRationalTest\n+  extends TestCase {\n+\n+  public PolynomialRationalTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testZero() {\n+    assertTrue(new Polynomial.Rational().isZero());\n+  }\n+\n+  public void testConstructors() {\n+\n+    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);\n+    RationalNumber[]  a = p.getCoefficients();\n+    assertEquals(a.length, 3);\n+    assertEquals(new RationalNumber(-5l), a[0]);\n+    assertEquals(new RationalNumber(3l), a[1]);\n+    assertEquals(new RationalNumber(1l), a[2]);\n+    assertEquals(2, p.getDegree());\n+\n+    assertEquals(1, new Polynomial.Rational(0l, 3l, 5l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(0l, 0l, 5l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(0l, 0l, 0l).getDegree());\n+    assertEquals(1, new Polynomial.Rational(3l, 5l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(0l, 5l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(0l, 0l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(5l).getDegree());\n+    assertEquals(0, new Polynomial.Rational(0l).getDegree());\n+\n+  }\n+\n+  public void testString() {\n+\n+    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);\n+    checkPolynomial(p, \"-5 + 3 x + x^2\");\n+    p.setUnknownName(\"alpha\");\n+    checkPolynomial(p, \"-5 + 3 alpha + alpha^2\");\n+    p.setUnknownName(null);\n+    checkPolynomial(p, \"-5 + 3 x + x^2\");\n+\n+    checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), \"-2 x + 3 x^2\");\n+    checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), \"1 - 2 x + 3 x^2\");\n+    checkPolynomial(new Polynomial.Rational(3l,  2l, 0l), \"2 x + 3 x^2\");\n+    checkPolynomial(new Polynomial.Rational(3l,  2l, 1l), \"1 + 2 x + 3 x^2\");\n+    checkPolynomial(new Polynomial.Rational(3l,  0l, 1l), \"1 + 3 x^2\");\n+    checkPolynomial(new Polynomial.Rational(0l), \"0\");\n+\n+  }\n+\n+  public void testAddition() {\n+\n+    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);\n+    Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);\n+    assertTrue(Polynomial.Rational.add(p1, p2).isZero());\n+\n+    p2 = new Polynomial.Rational(p1);\n+    p2.addToSelf(p2);\n+    checkPolynomial(p2, \"-4 + 2 x\");\n+\n+    p1 = new Polynomial.Rational(2l, -4l, 1l);\n+    p2 = new Polynomial.Rational(-2l, 3l, -1l);\n+    p1.addToSelf(p2);\n+    assertEquals(1, p1.getDegree());\n+    checkPolynomial(p1, \"-x\");\n+\n+  }\n+\n+  public void testSubtraction() {\n+\n+    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);\n+    assertTrue(Polynomial.Rational.subtract(p1, p1).isZero());\n+\n+    Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);\n+    p2.subtractFromSelf(p1);\n+    checkPolynomial(p2, \"5 x\");\n+\n+    p1 = new Polynomial.Rational(2l, -4l, 1l);\n+    p2 = new Polynomial.Rational(2l, 3l, -1l);\n+    p1.subtractFromSelf(p2);\n+    assertEquals(1, p1.getDegree());\n+    checkPolynomial(p1, \"2 - 7 x\");\n+\n+  }\n+\n+  public void testMultiplication() {\n+\n+    Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);\n+    Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);\n+    checkPolynomial(Polynomial.Rational.multiply(p1, p2), \"-9 + x^2 + 2 x^3\");\n+\n+    p1 = new Polynomial.Rational(1l, 0l);\n+    p2 = new Polynomial.Rational(p1);\n+    for (int i = 2; i < 10; ++i) {\n+      p2.multiplySelf(p1);\n+      checkPolynomial(p2, \"x^\" + i);\n+    }\n+\n+  }\n+\n+  public void testLCM() {\n+    Polynomial.Rational p = new Polynomial.Rational(new RationalNumber(2l, 5l),\n+                                                    new RationalNumber(-1l, 6l),\n+                                                    new RationalNumber(3l, 4l));\n+    checkPolynomial(p, \"3/4 - 1/6 x + 2/5 x^2\");\n+    BigInteger lcm = p.getDenominatorsLCM();\n+    assertEquals(BigInteger.valueOf(60l), lcm);\n+    p.multiplySelf(lcm);\n+    checkPolynomial(p, \"45 - 10 x + 24 x^2\");\n+  }\n+\n+  public void testEuclidianDivision() {\n+    Polynomial.Rational p = new Polynomial.Rational(4l, 6l, -3l);\n+    Polynomial.Rational q = new Polynomial.Rational(3l, 2l);\n+    Polynomial.DivisionResult res = Polynomial.Rational.euclidianDivision(p, q);\n+    checkPolynomial(res.quotient,  \"10/9 + 4/3 x\");\n+    checkPolynomial(res.remainder, \"-47/9\");\n+  }\n+\n+  public void checkPolynomial(Polynomial.Rational p, String reference) {\n+    assertEquals(reference, p.toString());\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(PolynomialRationalTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/RationalNumberTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.algebra;\n+\n+import junit.framework.*;\n+\n+public class RationalNumberTest\n+  extends TestCase {\n+\n+  public RationalNumberTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNullDenominator() {\n+    try {\n+      new RationalNumber(1l, 0l);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+  }\n+\n+  public void testToString() {\n+    checkValue(new RationalNumber(1l, 2l),  \"1/2\");\n+    checkValue(new RationalNumber(-1l, 2l), \"-1/2\");\n+    checkValue(new RationalNumber(1l, -2l), \"-1/2\");\n+    checkValue(new RationalNumber(-1l, -2l), \"1/2\");\n+    checkValue(new RationalNumber(0l, 500l), \"0\");\n+    checkValue(new RationalNumber(-12l), \"-12\");\n+    checkValue(new RationalNumber(12l), \"12\");\n+  }\n+\n+  public void testSimplification() {\n+    checkValue(new RationalNumber(2l, 4l), \"1/2\");\n+    checkValue(new RationalNumber(307692l, 999999l), \"4/13\");\n+    checkValue(new RationalNumber(999999l, 307692l), \"13/4\");\n+  }\n+\n+  public void testInvert() {\n+\n+    RationalNumber f = new RationalNumber(2l, 4l);\n+    f.invertSelf();\n+    checkValue(f, \"2\");\n+    f.invertSelf();\n+    checkValue(f, \"1/2\");\n+\n+    f = new RationalNumber(120l);\n+    f.invertSelf();\n+    checkValue(f, \"1/120\");\n+\n+    f = new RationalNumber(0l, 4l);\n+    try {\n+      f.invertSelf();\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+    f = new RationalNumber(307692l, 999999l);\n+    RationalNumber fInverse = RationalNumber.invert(f);\n+    checkValue(fInverse, \"13/4\");\n+    checkValue(f, \"4/13\");\n+\n+  }\n+\n+  public void testAddition() {\n+\n+    RationalNumber f1 = new RationalNumber(4l, 6l);\n+    f1.addToSelf(f1);\n+    checkValue(f1, \"4/3\");\n+\n+    checkValue(RationalNumber.add(new RationalNumber(17l, 3l),\n+                                  new RationalNumber(-17l, 3l)),\n+               \"0\");\n+    checkValue(RationalNumber.add(new RationalNumber(2l, 3l),\n+                                  new RationalNumber(3l, 4l)),\n+               \"17/12\");\n+    checkValue(RationalNumber.add(new RationalNumber(1l, 6l),\n+                                  new RationalNumber(2l, 6l)),\n+               \"1/2\");\n+    checkValue(RationalNumber.add(new RationalNumber(4l, 5l),\n+                                  new RationalNumber(-3l, 4l)),\n+               \"1/20\");\n+    checkValue(RationalNumber.add(new RationalNumber(-3l, 4l),\n+                                  new RationalNumber(4l, 5l)),\n+               \"1/20\");\n+\n+  }\n+\n+  public void testSubtraction() {\n+\n+    RationalNumber f1 = new RationalNumber(4l, 6l);\n+    f1.subtractFromSelf(f1);\n+    checkValue(f1, \"0\");\n+\n+    checkValue(RationalNumber.subtract(new RationalNumber(7l, 3l),\n+                                       new RationalNumber(-7l, 3l)),\n+               \"14/3\");\n+\n+    checkValue(RationalNumber.subtract(new RationalNumber(3l, 4l),\n+                                       new RationalNumber(2l, 3l)),\n+               \"1/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(3l, 4l),\n+                                       new RationalNumber(-2l, 3l)),\n+               \"17/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(-3l, 4l),\n+                                       new RationalNumber(2l, 3l)),\n+               \"-17/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(-3l, 4l),\n+                                       new RationalNumber(-2l, 3l)),\n+               \"-1/12\");\n+\n+    checkValue(RationalNumber.subtract(new RationalNumber(2l, 3l),\n+                                       new RationalNumber(3l, 4l)),\n+               \"-1/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(-2l, 3l),\n+                                       new RationalNumber(3l, 4l)),\n+               \"-17/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(2l, 3l),\n+                                       new RationalNumber(-3l, 4l)),\n+               \"17/12\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(-2l, 3l),\n+                                       new RationalNumber(-3l, 4l)),\n+               \"1/12\");\n+\n+    checkValue(RationalNumber.subtract(new RationalNumber(1l, 6l),\n+                                       new RationalNumber(2l, 6l)),\n+               \"-1/6\");\n+    checkValue(RationalNumber.subtract(new RationalNumber(1l, 2l),\n+                                       new RationalNumber(1l, 6l)),\n+               \"1/3\");\n+\n+  }\n+\n+  public void testMultiplication() {\n+\n+    RationalNumber f = new RationalNumber(2l, 3l);\n+    f.multiplySelf(new RationalNumber(9l,4l));\n+    checkValue(f, \"3/2\");\n+\n+    checkValue(RationalNumber.multiply(new RationalNumber(1l, 2l),\n+                                       new RationalNumber(0l)),\n+               \"0\");\n+    checkValue(RationalNumber.multiply(new RationalNumber(4l, 15l),\n+                                       new RationalNumber(-5l, 2l)),\n+               \"-2/3\");\n+    checkValue(RationalNumber.multiply(new RationalNumber(-4l, 15l),\n+                                       new RationalNumber(5l, 2l)),\n+               \"-2/3\");\n+    checkValue(RationalNumber.multiply(new RationalNumber(4l, 15l),\n+                                       new RationalNumber(5l, 2l)),\n+               \"2/3\");\n+    checkValue(RationalNumber.multiply(new RationalNumber(-4l, 15l),\n+                                       new RationalNumber(-5l, 2l)),\n+               \"2/3\");\n+\n+  }\n+\n+  public void testDivision() {\n+\n+    RationalNumber f = new RationalNumber(2l, 3l);\n+    f.divideSelf(new RationalNumber(4l,9l));\n+    checkValue(f, \"3/2\");\n+\n+    try {\n+      RationalNumber.divide(new RationalNumber(1l, 2l),\n+                            new RationalNumber(0l));\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+    checkValue(RationalNumber.divide(new RationalNumber(4l, 15l),\n+                                     new RationalNumber(-2l, 5l)),\n+               \"-2/3\");\n+    checkValue(RationalNumber.divide(new RationalNumber(-4l, 15l),\n+                                     new RationalNumber(2l, 5l)),\n+               \"-2/3\");\n+    checkValue(RationalNumber.divide(new RationalNumber(4l, 15l),\n+                                     new RationalNumber(2l, 5l)),\n+               \"2/3\");\n+    checkValue(RationalNumber.divide(new RationalNumber(-4l, 15l),\n+                                     new RationalNumber(-2l, 5l)),\n+               \"2/3\");\n+\n+  }\n+\n+  private void checkValue(RationalNumber f, String reference) {\n+    assertTrue(f.toString().equals(reference));\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RationalNumberTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.estimation\"); \n+\n+    suite.addTest(EstimatedParameterTest.suite());\n+    suite.addTest(WeightedMeasurementTest.suite());\n+    suite.addTest(GaussNewtonEstimatorTest.suite());\n+    suite.addTest(LevenbergMarquardtEstimatorTest.suite());\n+\n+    return suite; \n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/EstimatedParameterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import junit.framework.*;\n+\n+public class EstimatedParameterTest\n+  extends TestCase {\n+\n+  public EstimatedParameterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstruction() {\n+\n+    EstimatedParameter p1 = new EstimatedParameter(\"p1\", 1.0);\n+    assertTrue(p1.getName().equals(\"p1\"));\n+    checkValue(p1.getEstimate(), 1.0);\n+    assertTrue(! p1.isBound());\n+\n+    EstimatedParameter p2 = new EstimatedParameter(\"p2\", 2.0, true);\n+    assertTrue(p2.getName().equals(\"p2\"));\n+    checkValue(p2.getEstimate(), 2.0);\n+    assertTrue(p2.isBound());\n+\n+  }\n+\n+  public void testBound() {\n+\n+    EstimatedParameter p = new EstimatedParameter(\"p\", 0.0);\n+    assertTrue(! p.isBound());\n+    p.setBound(true);\n+    assertTrue(p.isBound());\n+    p.setBound(false);\n+    assertTrue(! p.isBound());\n+\n+  }\n+\n+  public void testEstimate() {\n+\n+    EstimatedParameter p = new EstimatedParameter(\"p\", 0.0);\n+    checkValue(p.getEstimate(), 0.0);\n+\n+    for (double e = 0.0; e < 10.0; e += 0.5) {\n+      p.setEstimate(e);\n+      checkValue(p.getEstimate(), e);\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EstimatedParameterTest.class);\n+  }\n+\n+  private void checkValue(double value, double expected) {\n+    assertTrue(Math.abs(value - expected) < 1.0e-10);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/GaussNewtonEstimatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.util.Random;\n+import junit.framework.*;\n+\n+public class GaussNewtonEstimatorTest\n+  extends TestCase\n+  implements EstimationProblem {\n+\n+  public GaussNewtonEstimatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoMeasurementError()\n+    throws EstimationException {\n+    initRandomizedGrid(2.3);\n+    initProblem(0.0);\n+    GaussNewtonEstimator estimator =\n+      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);\n+    estimator.estimate(this);\n+    checkGrid(0.01);\n+  }\n+\n+  public void testSmallMeasurementError()\n+    throws EstimationException {\n+    initRandomizedGrid(2.3);\n+    initProblem(0.02);\n+    GaussNewtonEstimator estimator =\n+      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);\n+    estimator.estimate(this);\n+    checkGrid(0.1);\n+  }\n+\n+  public void testNoError()\n+    throws EstimationException {\n+    initRandomizedGrid(0.0);\n+    initProblem(0.0);\n+    GaussNewtonEstimator estimator =\n+      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);\n+    estimator.estimate(this);\n+    checkGrid(1.0e-10);\n+  }\n+\n+  public void testUnsolvableProblem() {\n+\n+    initRandomizedGrid(2.3);\n+    initProblem(0.0);\n+\n+    // reduce the number of measurements below the limit threshold\n+    int unknowns = unboundPars.length;\n+    WeightedMeasurement[] reducedSet = new WeightedMeasurement[unknowns - 1];\n+    for (int i = 0; i < reducedSet.length; ++i) {\n+      reducedSet[i] = measurements[i];\n+    }\n+    measurements = reducedSet;\n+\n+    boolean gotIt = false;\n+    try {\n+      GaussNewtonEstimator estimator =\n+        new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);\n+      estimator.estimate(this);\n+    } catch(EstimationException e) {\n+      gotIt = true;\n+    }\n+\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GaussNewtonEstimatorTest.class);\n+  }\n+\n+  public void setUp() {\n+    initPerfectGrid(5);\n+  }\n+\n+  public void tearDown() {\n+    perfectPars    = null;\n+    randomizedPars = null;\n+    unboundPars    = null;\n+    measurements   = null;\n+  }\n+\n+  private void initPerfectGrid(int gridSize) {\n+    perfectPars = new EstimatedParameter[gridSize * gridSize * 2];\n+\n+    int k = 0;\n+    for (int i = 0; i < gridSize; ++i) {\n+      for (int j = 0; j < gridSize; ++j) {\n+\n+        String name            = new Integer(k).toString();\n+        perfectPars[2 * k]     = new EstimatedParameter(\"x\" + name, i);\n+        perfectPars[2 * k + 1] = new EstimatedParameter(\"y\" + name, j);\n+        ++k;\n+      }\n+    }\n+\n+  }\n+\n+  private void initRandomizedGrid(double initialGuessError) {\n+    Random randomizer = new Random(2353995334l);\n+    randomizedPars    = new EstimatedParameter[perfectPars.length];\n+\n+    // add an error to every point coordinate\n+    for (int k = 0; k < randomizedPars.length; ++k) {\n+      String name  = perfectPars[k].getName();\n+      double value = perfectPars[k].getEstimate();\n+      double error = randomizer.nextGaussian() * initialGuessError;\n+      randomizedPars[k] = new EstimatedParameter(name, value + error);\n+    }\n+\n+  }\n+\n+  private void initProblem(double measurementError) {\n+\n+    int pointsNumber       = randomizedPars.length / 2;\n+    int measurementsNumber = pointsNumber * (pointsNumber - 1) / 2;\n+    measurements           = new WeightedMeasurement[measurementsNumber];\n+\n+    Random randomizer = new Random(5785631926l);\n+\n+    // for the test, we consider that the perfect grid is the reality\n+    // and that the randomized grid is the first (wrong) estimate.\n+    int i = 0;\n+    for (int l = 0; l < (pointsNumber - 1); ++l) {\n+      for (int m = l + 1; m < pointsNumber; ++m) {\n+        // perfect measurements on the real data\n+        double dx = perfectPars[2 * l].getEstimate()\n+          - perfectPars[2 * m].getEstimate();\n+        double dy = perfectPars[2 * l + 1].getEstimate()\n+          - perfectPars[2 * m + 1].getEstimate();\n+        double d = Math.sqrt(dx * dx + dy * dy);\n+\n+        // adding a noise to the measurements\n+        d += randomizer.nextGaussian() * measurementError;\n+\n+        // add the measurement to the current problem\n+        measurements[i++] = new Distance(1.0, d,\n+                                         randomizedPars[2 * l],\n+                                         randomizedPars[2 * l + 1],\n+                                         randomizedPars[2 * m],\n+                                         randomizedPars[2 * m + 1]);\n+\n+      }\n+    }\n+\n+    // fix three values in the randomized grid and bind them (there\n+    // are two abscissas and one ordinate, so if there were no error\n+    // at all, the estimated grid should be correctly centered on the\n+    // perfect grid)\n+    int oddNumber = 2 * (randomizedPars.length / 4) - 1;\n+    for (int k = 0; k < 2 * oddNumber + 1; k += oddNumber) {\n+      randomizedPars[k].setEstimate(perfectPars[k].getEstimate());\n+      randomizedPars[k].setBound(true);\n+    }\n+\n+    // store the unbound parameters in a specific table\n+    unboundPars = new EstimatedParameter[randomizedPars.length - 3];\n+    for (int src = 0, dst = 0; src < randomizedPars.length; ++src) {\n+      if (! randomizedPars[src].isBound()) {\n+        unboundPars[dst++] = randomizedPars[src];\n+      }\n+    }\n+\n+  }\n+\n+  private void checkGrid(double threshold) {\n+\n+    double rms = 0;\n+    for (int i = 0; i < perfectPars.length; ++i) {\n+      rms += perfectPars[i].getEstimate() - randomizedPars[i].getEstimate();\n+    }\n+    rms = Math.sqrt(rms / perfectPars.length);\n+\n+    assertTrue(rms <= threshold);\n+\n+  }\n+\n+  private class Distance extends WeightedMeasurement {\n+\n+    public Distance(double weight, double measuredValue,\n+                    EstimatedParameter x1, EstimatedParameter y1,\n+                    EstimatedParameter x2, EstimatedParameter y2) {\n+      super(weight, measuredValue);\n+      this.x1 = x1;\n+      this.y1 = y1;\n+      this.x2 = x2;\n+      this.y2 = y2;\n+    }\n+\n+    public double getTheoreticalValue() {\n+      double dx = x2.getEstimate() - x1.getEstimate();\n+      double dy = y2.getEstimate() - y1.getEstimate();\n+      return Math.sqrt(dx * dx + dy * dy);\n+    }\n+\n+    public double getPartial(EstimatedParameter p) {\n+\n+      // first quick answer for most parameters\n+      if ((p != x1) && (p != y1) && (p != x2) && (p != y2)) {\n+        return 0.0;\n+      }\n+\n+      // compute the value now as we know we depend on the specified parameter\n+      double distance = getTheoreticalValue();\n+\n+      if (p == x1) {\n+        return (x1.getEstimate() - x2.getEstimate()) / distance;\n+      } else if (p == x2) {\n+        return (x2.getEstimate() - x1.getEstimate()) / distance;\n+      } else if (p == y1) {\n+        return (y1.getEstimate() - y2.getEstimate()) / distance;\n+      } else {\n+        return (y2.getEstimate() - y1.getEstimate()) / distance;\n+      }\n+\n+    }\n+\n+    private EstimatedParameter x1;\n+    private EstimatedParameter y1;\n+    private EstimatedParameter x2;\n+    private EstimatedParameter y2;\n+    private static final long serialVersionUID = 4090004243280980746L;\n+\n+  }\n+\n+  public WeightedMeasurement[] getMeasurements() {\n+    return measurements;\n+  }\n+\n+  public EstimatedParameter[] getUnboundParameters() {\n+    return unboundPars;\n+  }\n+\n+  public EstimatedParameter[] getAllParameters() {\n+    return randomizedPars;\n+  }\n+\n+  private EstimatedParameter[]  perfectPars;\n+  private EstimatedParameter[]  randomizedPars;\n+  private EstimatedParameter[]  unboundPars;\n+  private WeightedMeasurement[] measurements;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import junit.framework.*;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class LevenbergMarquardtEstimatorTest\n+  extends TestCase {\n+\n+  public LevenbergMarquardtEstimatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testTrivial() throws EstimationException {\n+    LinearProblem problem =\n+      new LinearProblem(new LinearMeasurement[] {\n+        new LinearMeasurement(new double[] {2},\n+                              new EstimatedParameter[] {\n+                                 new EstimatedParameter(\"p0\", 0)\n+                              }, 3.0)\n+      });\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(1.5,\n+                 problem.getUnboundParameters()[0].getEstimate(),\n+                 1.0e-10);\n+   }\n+\n+  public void testQRColumnsPermutation() throws EstimationException {\n+\n+    EstimatedParameter[] x = {\n+       new EstimatedParameter(\"p0\", 0), new EstimatedParameter(\"p1\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            4.0),\n+      new LinearMeasurement(new double[] { 2.0 },\n+                            new EstimatedParameter[] { x[1] },\n+                            6.0),\n+      new LinearMeasurement(new double[] { 1.0, -2.0 },\n+                            new EstimatedParameter[] { x[0], x[1] },\n+                            1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNoDependency() throws EstimationException {\n+    EstimatedParameter[] p = new EstimatedParameter[] {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 0),\n+      new EstimatedParameter(\"p2\", 0),\n+      new EstimatedParameter(\"p3\", 0),\n+      new EstimatedParameter(\"p4\", 0),\n+      new EstimatedParameter(\"p5\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),\n+      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)\n+    });\n+  LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+  estimator.estimate(problem);\n+  assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+  for (int i = 0; i < p.length; ++i) {\n+    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);\n+  }\n+}\n+\n+  public void testOneSet() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0 },\n+                            new EstimatedParameter[] { p[0] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -1.0, 1.0 },\n+                            new EstimatedParameter[] { p[1], p[2] },\n+                            1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testTwoSets() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3),\n+      new EstimatedParameter(\"p4\", 4),\n+      new EstimatedParameter(\"p5\", 5)\n+    };\n+\n+    double epsilon = 1.0e-7;\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+\n+      // 4 elements sub-problem\n+      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },\n+                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                           -9.0),\n+      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            2.0),\n+      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },\n+                           new EstimatedParameter[] { p[1], p[2], p[3] },\n+                           2.0),\n+\n+      // 2 elements sub-problem\n+      new LinearMeasurement(new double[] { epsilon, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            1.0 + epsilon * epsilon),\n+      new LinearMeasurement(new double[] {  1.0, 1.0 },\n+                            new EstimatedParameter[] { p[4], p[5] },\n+                            2.0)\n+\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);\n+    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testNonInversible() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 0),\n+       new EstimatedParameter(\"p1\", 0),\n+       new EstimatedParameter(\"p2\", 0)\n+    };\n+    LinearMeasurement[] m = new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { -3.0, -9.0 },\n+                            new EstimatedParameter[] { p[0], p[2] },\n+                            1.0)\n+    };\n+    LinearProblem problem = new LinearProblem(m);\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    double initialCost = estimator.getRMS(problem);\n+    estimator.estimate(problem);\n+    assertTrue(estimator.getRMS(problem) < initialCost);\n+    assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);\n+    double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])\n+                    + m[1].getResidual() * m[1].getPartial(p[0])\n+                    + m[2].getResidual() * m[2].getPartial(p[0]));\n+    double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])\n+                    + m[1].getResidual() * m[1].getPartial(p[1]));\n+    double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])\n+                    + m[1].getResidual() * m[1].getPartial(p[2])\n+                    + m[2].getResidual() * m[2].getPartial(p[2]));\n+    assertEquals(0, dJ0, 1.0e-10);\n+    assertEquals(0, dJ1, 1.0e-10);\n+    assertEquals(0, dJ2, 1.0e-10);\n+\n+  }\n+\n+  public void testIllConditioned() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 0),\n+      new EstimatedParameter(\"p1\", 1),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 3)\n+    };\n+\n+    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();\n+    estimator1.estimate(problem1);\n+    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);\n+    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);\n+\n+    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            32.0),\n+      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },\n+                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            23.0),\n+      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            33.0),\n+      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },\n+                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },\n+                            31.0)\n+    });\n+    LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();\n+    estimator2.estimate(problem2);\n+    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);\n+    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);\n+    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);\n+    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);\n+    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);\n+\n+  }\n+\n+  public void testMoreEstimatedParametersSimple() throws EstimationException {\n+\n+    EstimatedParameter[] p = {\n+       new EstimatedParameter(\"p0\", 7),\n+       new EstimatedParameter(\"p1\", 6),\n+       new EstimatedParameter(\"p2\", 5),\n+       new EstimatedParameter(\"p3\", 4)\n+     };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 3.0, 2.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                             new EstimatedParameter[] { p[1], p[2], p[3] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 2.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[2] },\n+                             5.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+\n+  }\n+\n+  public void testMoreEstimatedParametersUnsorted() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 2),\n+      new EstimatedParameter(\"p1\", 2),\n+      new EstimatedParameter(\"p2\", 2),\n+      new EstimatedParameter(\"p3\", 2),\n+      new EstimatedParameter(\"p4\", 2),\n+      new EstimatedParameter(\"p5\", 2)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[0], p[1] },\n+                           3.0),\n+      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n+                           new EstimatedParameter[] { p[2], p[3], p[4] },\n+                           12.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[5] },\n+                           -1.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n+                           new EstimatedParameter[] { p[3], p[2], p[5] },\n+                           7.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                           new EstimatedParameter[] { p[4], p[3] },\n+                           1.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);\n+    assertEquals(4.0, p[3].getEstimate(), 1.0e-10);\n+    assertEquals(5.0, p[4].getEstimate(), 1.0e-10);\n+    assertEquals(6.0, p[5].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testRedundantEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                             new EstimatedParameter[] { p[0], p[1] },\n+                             5.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertEquals(0, estimator.getRMS(problem), 1.0e-10);\n+    assertEquals(2.0, p[0].getEstimate(), 1.0e-10);\n+    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);\n+\n+  }\n+\n+  public void testInconsistentEquations() throws EstimationException {\n+    EstimatedParameter[] p = {\n+      new EstimatedParameter(\"p0\", 1),\n+      new EstimatedParameter(\"p1\", 1)\n+    };\n+    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n+      new LinearMeasurement(new double[] { 1.0, 1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            3.0),\n+      new LinearMeasurement(new double[] { 1.0, -1.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            1.0),\n+      new LinearMeasurement(new double[] { 1.0, 3.0 },\n+                            new EstimatedParameter[] { p[0], p[1] },\n+                            4.0)\n+    });\n+\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(problem);\n+    assertTrue(estimator.getRMS(problem) > 0.1);\n+\n+  }\n+\n+  public void testCircleFitting() throws EstimationException {\n+    Circle circle = new Circle(98.680, 47.345);\n+    circle.addPoint( 30.0,  68.0);\n+    circle.addPoint( 50.0,  -6.0);\n+    circle.addPoint(110.0, -20.0);\n+    circle.addPoint( 35.0,  15.0);\n+    circle.addPoint( 45.0,  97.0);\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(circle);\n+    assertTrue(estimator.getCostEvaluations() < 10);\n+    assertTrue(estimator.getJacobianEvaluations() < 10);\n+    double rms = estimator.getRMS(circle);\n+    assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);\n+    assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);\n+    assertEquals(96.07590211815305, circle.getX(),      1.0e-10);\n+    assertEquals(48.13516790438953, circle.getY(),      1.0e-10);\n+  }\n+\n+  public void testCircleFittingBadInit() throws EstimationException {\n+    Circle circle = new Circle(-12, -12);\n+    double[][] points = new double[][] {\n+      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+    };\n+    for (int i = 0; i < points.length; ++i) {\n+      circle.addPoint(points[i][0], points[i][1]);\n+    }\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.estimate(circle);\n+    assertTrue(estimator.getCostEvaluations() < 15);\n+    assertTrue(estimator.getJacobianEvaluations() < 10);\n+    assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);\n+    assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);\n+    assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);\n+    assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);\n+  }\n+\n+  public void testMinpackLinearFullRank()\n+    throws EstimationException {\n+    minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n+                                           5.0, 2.23606797749979), false);\n+    minpackTest(new LinearFullRankFunction(50, 5, 1.0,\n+                                           8.06225774829855, 6.70820393249937), false);\n+  }\n+\n+  public void testMinpackLinearRank1()\n+    throws EstimationException {\n+    minpackTest(new LinearRank1Function(10, 5, 1.0,\n+                                        291.521868819476, 1.4638501094228), false);\n+    minpackTest(new LinearRank1Function(50, 5, 1.0,\n+                                        3101.60039334535, 3.48263016573496), false);\n+  }\n+\n+  public void testMinpackLinearRank1ZeroColsAndRows()\n+    throws EstimationException {\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n+  }\n+\n+  public void testMinpackRosenbrok()\n+    throws EstimationException {\n+    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n+                                       Math.sqrt(24.2)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n+                                       Math.sqrt(1795769.0)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n+                                       11.0 * Math.sqrt(169000121.0)), false);\n+  }\n+\n+  public void testMinpackHelicalValley()\n+    throws EstimationException {\n+    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n+                                          50.0), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },\n+                                          102.95630140987), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n+                                          991.261822123701), false);\n+  }\n+    \n+  public void testMinpackPowellSingular()\n+    throws EstimationException {\n+    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n+                                           14.6628782986152), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },\n+                                           1270.9838708654), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n+                                           126887.903284750), false);\n+  }\n+    \n+  public void testMinpackFreudensteinRoth()\n+    throws EstimationException {\n+    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n+                                             20.0124960961895, 6.99887517584575,\n+                                             new double[] {\n+                                               11.4124844654993,\n+                                               -0.896827913731509\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n+                                             12432.833948863, 6.9988751744895,\n+                                             new double[] {\n+                                               11.4130046614746,\n+                                               -0.896796038685958\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n+                                             11426454.595762, 6.99887517242903,\n+                                             new double[] {\n+                                               11.4127817857886,\n+                                               -0.89680510749204\n+                                             }), false);\n+  }\n+    \n+  public void testMinpackBard()\n+    throws EstimationException {\n+    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n+                                 new double[] {\n+                                   0.0824105765758334,\n+                                   1.1330366534715,\n+                                   2.34369463894115\n+                                 }), false);\n+    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,\n+                                 new double[] {\n+                                   0.840666673818329,\n+                                   -158848033.259565,\n+                                   -164378671.653535\n+                                 }), false);\n+    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,\n+                                 new double[] {\n+                                   0.840666673867645,\n+                                   -158946167.205518,\n+                                   -164464906.857771\n+                                 }), false);\n+  }\n+    \n+  public void testMinpackKowalikOsborne()\n+    throws EstimationException {\n+    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n+                                           0.0728915102882945,\n+                                           0.017535837721129,\n+                                           new double[] {\n+                                             0.192807810476249,\n+                                             0.191262653354071,\n+                                             0.123052801046931,\n+                                             0.136053221150517\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },\n+                                           2.97937007555202,\n+                                           0.032052192917937,\n+                                           new double[] {\n+                                             728675.473768287,\n+                                             -14.0758803129393,\n+                                             -32977797.7841797,\n+                                             -20571594.1977912\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },\n+                                           29.9590617016037,\n+                                           0.0175364017658228,\n+                                           new double[] {\n+                                             0.192948328597594,\n+                                             0.188053165007911,\n+                                             0.122430604321144,\n+                                             0.134575665392506\n+                                           }), true);\n+  }\n+    \n+  public void testMinpackMeyer()\n+    throws EstimationException {\n+    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n+                                  41153.4665543031, 9.37794514651874,\n+                                  new double[] {\n+                                    0.00560963647102661,\n+                                    6181.34634628659,\n+                                    345.223634624144\n+                                  }), false);\n+    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },\n+                                  4168216.89130846, 792.917871779501,\n+                                  new double[] {\n+                                    1.42367074157994e-11,\n+                                    33695.7133432541,\n+                                    901.268527953801\n+                                  }), true);\n+  }\n+    \n+  public void testMinpackWatson()\n+    throws EstimationException {\n+  \n+    minpackTest(new WatsonFunction(6, 0.0,\n+                                   5.47722557505166, 0.0478295939097601,\n+                                   new double[] {\n+                                     -0.0157249615083782, 1.01243488232965,\n+                                     -0.232991722387673,  1.26043101102818,\n+                                     -1.51373031394421,   0.99299727291842\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 10.0,\n+                                   6433.12578950026, 0.0478295939096951,\n+                                   new double[] {\n+                                     -0.0157251901386677, 1.01243485860105,\n+                                     -0.232991545843829,  1.26042932089163,\n+                                     -1.51372776706575,   0.99299573426328\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 100.0,\n+                                   674256.040605213, 0.047829593911544,\n+                                   new double[] {\n+                                    -0.0157247019712586, 1.01243490925658,\n+                                    -0.232991922761641,  1.26043292929555,\n+                                    -1.51373320452707,   0.99299901922322\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(9, 0.0,\n+                                   5.47722557505166, 0.00118311459212420,\n+                                   new double[] {\n+                                    -0.153070644166722e-4, 0.999789703934597,\n+                                     0.0147639634910978,   0.146342330145992,\n+                                     1.00082109454817,    -2.61773112070507,\n+                                     4.10440313943354,    -3.14361226236241,\n+                                     1.05262640378759\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 10.0,\n+                                   12088.127069307, 0.00118311459212513,\n+                                   new double[] {\n+                                   -0.153071334849279e-4, 0.999789703941234,\n+                                    0.0147639629786217,   0.146342334818836,\n+                                    1.00082107321386,    -2.61773107084722,\n+                                    4.10440307655564,    -3.14361222178686,\n+                                    1.05262639322589\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 100.0,\n+                                   1269109.29043834, 0.00118311459212384,\n+                                   new double[] {\n+                                    -0.153069523352176e-4, 0.999789703958371,\n+                                     0.0147639625185392,   0.146342341096326,\n+                                     1.00082104729164,    -2.61773101573645,\n+                                     4.10440301427286,    -3.14361218602503,\n+                                     1.05262638516774\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(12, 0.0,\n+                                   5.47722557505166, 0.217310402535861e-4,\n+                                   new double[] {\n+                                    -0.660266001396382e-8, 1.00000164411833,\n+                                    -0.000563932146980154, 0.347820540050756,\n+                                    -0.156731500244233,    1.05281515825593,\n+                                    -3.24727109519451,     7.2884347837505,\n+                                   -10.271848098614,       9.07411353715783,\n+                                    -4.54137541918194,     1.01201187975044\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 10.0,\n+                                   19220.7589790951, 0.217310402518509e-4,\n+                                   new double[] {\n+                                    -0.663710223017410e-8, 1.00000164411787,\n+                                    -0.000563932208347327, 0.347820540486998,\n+                                    -0.156731503955652,    1.05281517654573,\n+                                    -3.2472711515214,      7.28843489430665,\n+                                   -10.2718482369638,      9.07411364383733,\n+                                    -4.54137546533666,     1.01201188830857\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 100.0,\n+                                   2018918.04462367, 0.217310402539845e-4,\n+                                   new double[] {\n+                                    -0.663806046485249e-8, 1.00000164411786,\n+                                    -0.000563932210324959, 0.347820540503588,\n+                                    -0.156731504091375,    1.05281517718031,\n+                                    -3.24727115337025,     7.28843489775302,\n+                                   -10.2718482410813,      9.07411364688464,\n+                                    -4.54137546660822,     1.0120118885369\n+                                   }), false);\n+\n+  }\n+    \n+  public void testMinpackBox3Dimensional()\n+  throws EstimationException {\n+    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n+                                            32.1115837449572), false);\n+  }\n+    \n+  public void testMinpackJennrichSampson()\n+    throws EstimationException {\n+    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n+                                            64.5856498144943, 11.1517793413499,\n+                                            new double[] {\n+                                             0.257819926636811, 0.257829976764542\n+                                            }), false);\n+  }\n+\n+  public void testMinpackBrownDennis()\n+    throws EstimationException {\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 25.0, 5.0, -5.0, -1.0 },\n+                                        2815.43839161816, 292.954288244866,\n+                                        new double[] {\n+                                         -11.59125141003, 13.2024883984741,\n+                                         -0.403574643314272, 0.236736269844604\n+                                        }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 250.0, 50.0, -50.0, -10.0 },\n+                                        555073.354173069, 292.954270581415,\n+                                        new double[] {\n+                                         -11.5959274272203, 13.2041866926242,\n+                                         -0.403417362841545, 0.236771143410386\n+                                       }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },\n+                                        61211252.2338581, 292.954306151134,\n+                                        new double[] {\n+                                         -11.5902596937374, 13.2020628854665,\n+                                         -0.403688070279258, 0.236665033746463\n+                                        }), false);\n+  }\n+    \n+  public void testMinpackChebyquad()\n+    throws EstimationException {\n+    minpackTest(new ChebyquadFunction(1, 8, 1.0,\n+                                      1.88623796907732, 1.88623796907732,\n+                                      new double[] { 0.5 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 10.0,\n+                                      5383344372.34005, 1.88424820499951,\n+                                      new double[] { 0.9817314924684 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 100.0,\n+                                      0.118088726698392e19, 1.88424820499347,\n+                                      new double[] { 0.9817314852934 }), false);\n+    minpackTest(new ChebyquadFunction(8, 8, 1.0,\n+                                      0.196513862833975, 0.0593032355046727,\n+                                      new double[] {\n+                                        0.0431536648587336, 0.193091637843267,\n+                                        0.266328593812698,  0.499999334628884,\n+                                        0.500000665371116,  0.733671406187302,\n+                                        0.806908362156733,  0.956846335141266\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(9, 9, 1.0,\n+                                      0.16994993465202, 0.0,\n+                                      new double[] {\n+                                        0.0442053461357828, 0.199490672309881,\n+                                        0.23561910847106,   0.416046907892598,\n+                                        0.5,                0.583953092107402,\n+                                        0.764380891528940,  0.800509327690119,\n+                                        0.955794653864217\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(10, 10, 1.0,\n+                                      0.183747831178711, 0.0806471004038253,\n+                                      new double[] {\n+                                        0.0596202671753563, 0.166708783805937,\n+                                        0.239171018813509,  0.398885290346268,\n+                                        0.398883667870681,  0.601116332129320,\n+                                        0.60111470965373,   0.760828981186491,\n+                                        0.833291216194063,  0.940379732824644\n+                                      }), false);\n+  }\n+    \n+  public void testMinpackBrownAlmostLinear()\n+    throws EstimationException {\n+    minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n+                                              16.5302162063499, 0.0,\n+                                              new double[] {\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 1.20569696650138\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(10, 5.0,\n+                                              9765624.00089211, 0.0,\n+                                              new double[] {\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 1.20569696650135\n+                                              }), false);  \n+    minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n+                                              0.9765625e17, 0.0,\n+                                              new double[] {\n+                                                1.0, 1.0, 1.0, 1.0, 1.0,\n+                                                1.0, 1.0, 1.0, 1.0, 1.0\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(30, 0.5,\n+                                              83.476044467848, 0.0,\n+                                              new double[] {\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 1.06737350671578\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(40, 0.5,\n+                                              128.026364472323, 0.0,\n+                                              new double[] {\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                0.999999999999121\n+                                              }), false);\n+    }\n+    \n+  public void testMinpackOsborne1()\n+    throws EstimationException {\n+      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n+                                       0.937564021037838, 0.00739249260904843,\n+                                       new double[] {\n+                                         0.375410049244025, 1.93584654543108,\n+                                        -1.46468676748716, 0.0128675339110439,\n+                                         0.0221227011813076\n+                                       }), false);\n+    }\n+    \n+  public void testMinpackOsborne2()\n+    throws EstimationException {\n+      \n+    minpackTest(new Osborne2Function(new double[] {\n+                                       1.3, 0.65, 0.65, 0.7, 0.6,\n+                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n+                                     },\n+                                     1.44686540984712, 0.20034404483314,\n+                                     new double[] {\n+                                       1.30997663810096,  0.43155248076,\n+                                       0.633661261602859, 0.599428560991695,\n+                                       0.754179768272449, 0.904300082378518,\n+                                       1.36579949521007, 4.82373199748107,\n+                                       2.39868475104871, 4.56887554791452,\n+                                       5.67534206273052\n+                                     }), false);\n+  }\n+\n+  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.setMaxCostEval(100 * (function.getN() + 1));\n+    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setOrthoTolerance(2.22044604926e-16);\n+    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n+    try {\n+      estimator.estimate(function);\n+      assertFalse(exceptionExpected);\n+    } catch (EstimationException lsse) {\n+      assertTrue(exceptionExpected);\n+    }\n+    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));\n+    assertTrue(function.checkTheoreticalMinParams());\n+  }\n+\n+  private static class LinearProblem implements EstimationProblem {\n+\n+    public LinearProblem(LinearMeasurement[] measurements) {\n+      this.measurements = measurements;\n+    }\n+\n+    public WeightedMeasurement[] getMeasurements() {\n+      return measurements;\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return getAllParameters();\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      IdentityHashMap map = new IdentityHashMap();\n+      for (int i = 0; i < measurements.length; ++i) {\n+        EstimatedParameter[] parameters = measurements[i].getParameters();\n+        for (int j = 0; j < parameters.length; ++j) {\n+          map.put(parameters[j], null);\n+        }\n+      }\n+      Set set = map.keySet();\n+      return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);\n+    }\n+  \n+    private LinearMeasurement[] measurements;\n+\n+  }\n+\n+  private static class LinearMeasurement extends WeightedMeasurement {\n+\n+    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,\n+                             double setPoint) {\n+      super(1.0, setPoint);\n+      this.factors = factors;\n+      this.parameters = parameters;\n+    }\n+\n+    public double getTheoreticalValue() {\n+      double v = 0;\n+      for (int i = 0; i < factors.length; ++i) {\n+        v += factors[i] * parameters[i].getEstimate();\n+      }\n+      return v;\n+    }\n+\n+    public double getPartial(EstimatedParameter parameter) {\n+      for (int i = 0; i < parameters.length; ++i) {\n+        if (parameters[i] == parameter) {\n+          return factors[i];\n+        }\n+      }\n+      return 0;\n+    }\n+\n+    public EstimatedParameter[] getParameters() {\n+      return parameters;\n+    }\n+\n+    private double[] factors;\n+    private EstimatedParameter[] parameters;\n+    private static final long serialVersionUID = -3922448707008868580L;\n+\n+  }\n+\n+  private static class Circle implements EstimationProblem {\n+\n+    public Circle(double cx, double cy) {\n+      this.cx = new EstimatedParameter(\"cx\", cx);\n+      this.cy = new EstimatedParameter(\"cy\", cy);\n+      points  = new ArrayList();\n+    }\n+\n+    public void addPoint(double px, double py) {\n+      points.add(new PointModel(px, py));\n+    }\n+\n+    public int getM() {\n+      return points.size();\n+    }\n+\n+    public WeightedMeasurement[] getMeasurements() {\n+      return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]);\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return new EstimatedParameter[] { cx, cy };\n+    }\n+\n+    public double getPartialRadiusX() {\n+      double dRdX = 0;\n+      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n+        dRdX += ((PointModel) iterator.next()).getPartialDiX();\n+      }\n+      return dRdX / points.size();\n+    }\n+\n+    public double getPartialRadiusY() {\n+      double dRdY = 0;\n+      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n+        dRdY += ((PointModel) iterator.next()).getPartialDiY();\n+      }\n+      return dRdY / points.size();\n+    }\n+\n+   public double getRadius() {\n+      double r = 0;\n+      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n+        r += ((PointModel) iterator.next()).getCenterDistance();\n+      }\n+      return r / points.size();\n+    }\n+\n+    public double getX() {\n+      return cx.getEstimate();\n+    }\n+\n+    public double getY() {\n+      return cy.getEstimate();\n+    }\n+\n+    private class PointModel extends WeightedMeasurement {\n+\n+      public PointModel(double px, double py) {\n+        super(1.0, 0.0);\n+        this.px = px;\n+        this.py = py;\n+      }\n+\n+      public double getPartial(EstimatedParameter parameter) {\n+        if (parameter == cx) {\n+          return getPartialDiX() - getPartialRadiusX();\n+        } else if (parameter == cy) {\n+          return getPartialDiY() - getPartialRadiusY();\n+        }\n+        return 0;\n+      }\n+\n+      public double getCenterDistance() {\n+        double dx = px - cx.getEstimate();\n+        double dy = py - cy.getEstimate();\n+        return Math.sqrt(dx * dx + dy * dy);\n+      }\n+\n+      public double getPartialDiX() {\n+        return (cx.getEstimate() - px) / getCenterDistance();\n+      }\n+\n+      public double getPartialDiY() {\n+        return (cy.getEstimate() - py) / getCenterDistance();\n+      }\n+\n+      public double getTheoreticalValue() {\n+        return getCenterDistance() - getRadius();\n+      }\n+\n+      private double px;\n+      private double py;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private EstimatedParameter cx;\n+    private EstimatedParameter cy;\n+    private ArrayList points;\n+\n+  }\n+\n+  private static abstract class MinpackFunction implements EstimationProblem {\n+ \n+    protected MinpackFunction(int m,\n+                              double[] startParams,\n+                              double   theoreticalStartCost,\n+                              double   theoreticalMinCost,\n+                              double[] theoreticalMinParams) {\n+      this.m = m;\n+      this.n = startParams.length;\n+      parameters = new EstimatedParameter[n];\n+      for (int i = 0; i < n; ++i) {\n+        parameters[i] = new EstimatedParameter(\"p\" + i, startParams[i]);\n+      }\n+      this.theoreticalStartCost = theoreticalStartCost;\n+      this.theoreticalMinCost   = theoreticalMinCost;\n+      this.theoreticalMinParams = theoreticalMinParams;\n+      this.costAccuracy         = 1.0e-8;\n+      this.paramsAccuracy       = 1.0e-5;\n+    }\n+\n+    protected static double[] buildArray(int n, double x) {\n+      double[] array = new double[n];\n+      Arrays.fill(array, x);\n+      return array;\n+    }\n+\n+    protected void setCostAccuracy(double costAccuracy) {\n+      this.costAccuracy = costAccuracy;\n+    }\n+\n+    protected void setParamsAccuracy(double paramsAccuracy) {\n+      this.paramsAccuracy = paramsAccuracy;\n+    }\n+\n+    public int getN() {\n+      return parameters.length;\n+    }\n+\n+    public boolean checkTheoreticalStartCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n+      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n+     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinParams() {\n+      if (theoreticalMinParams != null) {\n+        for (int i = 0; i < theoreticalMinParams.length; ++i) {\n+          double mi = theoreticalMinParams[i];\n+          double vi = parameters[i].getEstimate();\n+          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+            return false;\n+          }\n+        }\n+      }\n+      return true;\n+    }\n+ \n+    public WeightedMeasurement[] getMeasurements() {\n+      WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n+      for (int i = 0; i < m; ++i) {\n+        measurements[i] = new MinpackMeasurement(i);\n+      }\n+      return measurements;\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return parameters;\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return parameters;\n+    }\n+\n+    protected abstract double[][] getJacobian();\n+\n+    protected abstract double[] getResiduals();\n+\n+    private class MinpackMeasurement extends WeightedMeasurement {\n+\n+      public MinpackMeasurement(int index) {\n+        super(1.0, 0.0);\n+        this.index = index;\n+      }\n+\n+      public double getTheoreticalValue() {\n+        // this is obviously NOT efficient as we recompute the whole vector\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        return getResiduals()[index];\n+      }\n+\n+      public double getPartial(EstimatedParameter parameter) {\n+        // this is obviously NOT efficient as we recompute the whole jacobian\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        for (int j = 0; j < n; ++j) {\n+          if (parameter == parameters[j]) {\n+            return getJacobian()[index][j];\n+          }\n+        }\n+        return 0;\n+      }\n+\n+      private int index;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    protected int                  n;\n+    protected int                  m;\n+    protected EstimatedParameter[] parameters;\n+    protected double               theoreticalStartCost;\n+    protected double               theoreticalMinCost;\n+    protected double[]             theoreticalMinParams;\n+    protected double               costAccuracy;\n+    protected double               paramsAccuracy;\n+\n+  }\n+\n+  private static class LinearFullRankFunction extends MinpackFunction {\n+\n+    public LinearFullRankFunction(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, buildArray(n, -1.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double t = 2.0 / m;\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i == j) ? (1 - t) : -t;\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += parameters[i].getEstimate();\n+      }\n+      double t  = 1 + 2 * sum / m;\n+      double[] f = new double[m];\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() - t;\n+      }\n+      Arrays.fill(f, n, m, -t);\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1Function extends MinpackFunction {\n+\n+    public LinearRank1Function(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i + 1) * (j + 1);\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = (i + 1) * sum - 1;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n+\n+    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n+      super(m, buildArray(n, x0),\n+            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n+            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            null);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        jacobian[i][0] = 0;\n+        for (int j = 1; j < (n - 1); ++j) {\n+          if (i == 0) {\n+            jacobian[i][j] = 0;\n+          } else if (i != (m - 1)) {\n+            jacobian[i][j] = i * (j + 1);\n+          } else {\n+            jacobian[i][j] = 0;\n+          }\n+        }\n+        jacobian[i][n - 1] = 0;\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 1; i < (n - 1); ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < (m - 1); ++i) {\n+        f[i] = i * sum - 1;\n+      }\n+      f[m - 1] = -1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class RosenbrockFunction extends MinpackFunction {\n+\n+    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n+      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n+    }\n+\n+  }\n+\n+  private static class HelicalValleyFunction extends MinpackFunction {\n+\n+    public HelicalValleyFunction(double[] startParams,\n+                                 double theoreticalStartCost) {\n+      super(3, startParams, theoreticalStartCost, 0.0,\n+            new double[] { 1.0, 0.0, 0.0 });\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double tmpSquare = x1 * x1 + x2 * x2;\n+      double tmp1 = twoPi * tmpSquare;\n+      double tmp2 = Math.sqrt(tmpSquare);\n+      return new double[][] {\n+        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n+        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n+        { 0, 0, 1 }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double tmp1;\n+      if (x1 == 0) {\n+        tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n+      } else {\n+        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        if (x1 < 0) {\n+          tmp1 += 0.5;\n+        }\n+      }\n+      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      return new double[] {\n+        10.0 * (x3 - 10 * tmp1),\n+        10.0 * (tmp2 - 1),\n+        x3\n+      };\n+    }\n+\n+    private static final double twoPi = 2.0 * Math.PI;\n+\n+  }\n+\n+  private static class PowellSingularFunction extends MinpackFunction {\n+\n+    public PowellSingularFunction(double[] startParams,\n+                                  double theoreticalStartCost) {\n+      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[][] {\n+        { 1, 10, 0, 0 },\n+        { 0, 0, sqrt5, -sqrt5 },\n+        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },\n+        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[] {\n+        x1 + 10 * x2,\n+        sqrt5 * (x3 - x4),\n+        (x2 - 2 * x3) * (x2 - 2 * x3),\n+        sqrt10 * (x1 - x4) * (x1 - x4)\n+      };\n+    }\n+\n+    private static final double sqrt5  = Math.sqrt( 5.0);\n+    private static final double sqrt10 = Math.sqrt(10.0);\n+\n+  }\n+\n+  private static class FreudensteinRothFunction extends MinpackFunction {\n+\n+    public FreudensteinRothFunction(double[] startParams,\n+                                    double theoreticalStartCost,\n+                                    double theoreticalMinCost,\n+                                    double[] theoreticalMinParams) {\n+      super(2, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x2 = parameters[1].getEstimate();\n+      return new double[][] {\n+        { 1, x2 * (10 - 3 * x2) -  2 },\n+        { 1, x2 * ( 2 + 3 * x2) - 14, }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] {\n+       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n+       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n+      };\n+    }\n+\n+  }\n+\n+  private static class BardFunction extends MinpackFunction {\n+\n+    public BardFunction(double x0,\n+                        double theoreticalStartCost,\n+                        double theoreticalMinCost,\n+                        double[] theoreticalMinParams) {\n+      super(15, buildArray(3, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i  + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        double tmp4 = x2 * tmp2 + x3 * tmp3;\n+        tmp4 *= tmp4;\n+        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.14, 0.18, 0.22, 0.25, 0.29,\n+      0.32, 0.35, 0.39, 0.37, 0.58,\n+      0.73, 0.96, 1.34, 2.10, 4.39\n+    };\n+\n+  }\n+\n+  private static class KowalikOsborneFunction extends MinpackFunction {\n+\n+    public KowalikOsborneFunction(double[] startParams,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost,\n+                                  double[] theoreticalMinParams) {\n+      super(11, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 20.0) {\n+        setCostAccuracy(2.0e-4);\n+        setParamsAccuracy(5.0e-3);\n+      }\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = v[i] * (v[i] + x3) + x4;\n+        double j1  = -v[i] * (v[i] + x2) / tmp;\n+        double j2  = -v[i] * x1 / tmp;\n+        double j3  = j1 * j2;\n+        double j4  = j3 / v[i];\n+        jacobian[i] = new double[] { j1, j2, j3, j4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] v = {\n+      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625\n+    };\n+\n+    private static final double[] y = {\n+      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,\n+      0.0456, 0.0342, 0.0323, 0.0235, 0.0246\n+    };\n+\n+  }\n+\n+  private static class MeyerFunction extends MinpackFunction {\n+\n+    public MeyerFunction(double[] startParams,\n+                         double theoreticalStartCost,\n+                         double theoreticalMinCost,\n+                         double[] theoreticalMinParams) {\n+      super(16, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 1.0e6) {\n+        setCostAccuracy(7.0e-3);\n+        setParamsAccuracy(2.0e-2);\n+      }\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 5.0 * (i + 1) + 45.0 + x3;\n+        double tmp1 = x2 / temp;\n+        double tmp2 = Math.exp(tmp1);\n+        double tmp3 = x1 * tmp2 / temp;\n+        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+      }\n+     return f;\n+    }\n+\n+    private static final double[] y = {\n+      34780.0, 28610.0, 23650.0, 19630.0,\n+      16370.0, 13720.0, 11540.0,  9744.0,\n+       8261.0,  7030.0,  6005.0,  5147.0,\n+       4427.0,  3820.0,  3307.0,  2872.0                  \n+    };\n+\n+  }\n+\n+  private static class WatsonFunction extends MinpackFunction {\n+\n+    public WatsonFunction(int n, double x0,\n+                          double theoreticalStartCost,\n+                          double theoreticalMinCost,\n+                          double[] theoreticalMinParams) {\n+      super(31, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+\n+      for (int i = 0; i < (m - 2); ++i) {\n+        double div = (i + 1) / 29.0;\n+        double s2  = 0.0;\n+        double dx  = 1.0;\n+        for (int j = 0; j < n; ++j) {\n+          s2 += dx * parameters[j].getEstimate();\n+          dx *= div;\n+        }\n+        double temp= 2 * div * s2;\n+        dx = 1.0 / div;\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = dx * (j - temp);\n+          dx *= div;\n+        }\n+      }\n+\n+      jacobian[m - 2]    = new double[n];\n+      jacobian[m - 2][0] = 1;\n+\n+      jacobian[m - 1]   = new double[n];\n+      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();\n+      jacobian[m - 1][1]= 1;\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+     double[] f = new double[m];\n+     for (int i = 0; i < (m - 2); ++i) {\n+       double div = (i + 1) / 29.0;\n+       double s1 = 0;\n+       double dx = 1;\n+       for (int j = 1; j < n; ++j) {\n+         s1 += j * dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       double s2 =0;\n+       dx =1;\n+       for (int j = 0; j < n; ++j) {\n+         s2 += dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       f[i] = s1 - s2 * s2 - 1;\n+     }\n+\n+     double x1 = parameters[0].getEstimate();\n+     double x2 = parameters[1].getEstimate();\n+     f[m - 2] = x1;\n+     f[m - 1] = x2 - x1 * x1 - 1;\n+\n+     return f;\n+\n+    }\n+\n+  }\n+\n+  private static class Box3DimensionalFunction extends MinpackFunction {\n+\n+    public Box3DimensionalFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost) {\n+      super(m, startParams, theoreticalStartCost,\n+            0.0, new double[] { 1.0, 10.0, 1.0 });\n+   }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        jacobian[i] = new double[] {\n+          -tmp * Math.exp(-tmp * x1),\n+           tmp * Math.exp(-tmp * x2),\n+          Math.exp(-i - 1) - Math.exp(-tmp)\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n+             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class JennrichSampsonFunction extends MinpackFunction {\n+\n+    public JennrichSampsonFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost,\n+                                   double theoreticalMinCost,\n+                                   double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double t = i + 1;\n+        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i + 1;\n+        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class BrownDennisFunction extends MinpackFunction {\n+\n+    public BrownDennisFunction(int m, double[] startParams,\n+                               double theoreticalStartCost,\n+                               double theoreticalMinCost,\n+                               double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double ti   = Math.sin(temp);\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        jacobian[i] = new double[] {\n+          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class ChebyquadFunction extends MinpackFunction {\n+\n+    private static double[] buildChebyquadArray(int n, double factor) {\n+      double[] array = new double[n];\n+      double inv = factor / (n + 1);\n+      for (int i = 0; i < n; ++i) {\n+        array[i] = (i + 1) * inv;\n+      }\n+      return array;\n+    }\n+\n+    public ChebyquadFunction(int n, int m, double factor,\n+                             double theoreticalStartCost,\n+                             double theoreticalMinCost,\n+                             double[] theoreticalMinParams) {\n+      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double dx = 1.0 / n;\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        double tmp3 = 0;\n+        double tmp4 = 2;\n+        for (int i = 0; i < m; ++i) {\n+          jacobian[i][j] = dx * tmp4;\n+          double ti = 4 * tmp2 + temp * tmp4 - tmp3;\n+          tmp3 = tmp4;\n+          tmp4 = ti;\n+          ti   = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+\n+      double[] f = new double[m];\n+\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        for (int i = 0; i < m; ++i) {\n+          f[i] += tmp2;\n+          double ti = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      double dx = 1.0 / n;\n+      boolean iev = false;\n+      for (int i = 0; i < m; ++i) {\n+        f[i] *= dx;\n+        if (iev) {\n+          f[i] += 1.0 / (i * (i + 2));\n+        }\n+        iev = ! iev;\n+      }\n+\n+      return f;\n+\n+    }\n+\n+  }\n+\n+  private static class BrownAlmostLinearFunction extends MinpackFunction {\n+\n+    public BrownAlmostLinearFunction(int m, double factor,\n+                                     double theoreticalStartCost,\n+                                     double theoreticalMinCost,\n+                                     double[] theoreticalMinParams) {\n+      super(m, buildArray(m, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        prod *= parameters[j].getEstimate();\n+        for (int i = 0; i < n; ++i) {\n+          jacobian[i][j] = 1;\n+        }\n+        jacobian[j][j] = 2;\n+      }\n+\n+      for (int j = 0; j < n; ++j) {\n+        EstimatedParameter vj = parameters[j];\n+        double temp = vj.getEstimate();\n+        if (temp == 0) {\n+          temp = 1;\n+          prod = 1;\n+          for (int k = 0; k < n; ++k) {\n+            if (k != j) {\n+              prod *= parameters[k].getEstimate();\n+            }\n+          }\n+        }\n+        jacobian[n - 1][j] = prod / temp;\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum  = -(n + 1);\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        sum  += parameters[j].getEstimate();\n+        prod *= parameters[j].getEstimate();\n+      }\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() + sum;\n+      }\n+      f[n - 1] = prod - 1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class Osborne1Function extends MinpackFunction {\n+\n+    public Osborne1Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(33, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double   x5 = parameters[4].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        jacobian[i] = new double[] {\n+          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double x5 = parameters[4].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,\n+      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,\n+      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406\n+    };\n+\n+  }\n+\n+  private static class Osborne2Function extends MinpackFunction {\n+\n+    public Osborne2Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(65, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x01 = parameters[0].getEstimate();\n+      double   x02 = parameters[1].getEstimate();\n+      double   x03 = parameters[2].getEstimate();\n+      double   x04 = parameters[3].getEstimate();\n+      double   x05 = parameters[4].getEstimate();\n+      double   x06 = parameters[5].getEstimate();\n+      double   x07 = parameters[6].getEstimate();\n+      double   x08 = parameters[7].getEstimate();\n+      double   x09 = parameters[8].getEstimate();\n+      double   x10 = parameters[9].getEstimate();\n+      double   x11 = parameters[10].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        jacobian[i] = new double[] {\n+          -tmp1,\n+          -tmp2,\n+          -tmp3,\n+          -tmp4,\n+          temp * x01 * tmp1,\n+          x02 * (temp - x09) * (temp - x09) * tmp2,\n+          x03 * (temp - x10) * (temp - x10) * tmp3,\n+          x04 * (temp - x11) * (temp - x11) * tmp4,\n+          -2 * x02 * x06 * (temp - x09) * tmp2,\n+          -2 * x03 * x07 * (temp - x10) * tmp3,\n+          -2 * x04 * x08 * (temp - x11) * tmp4\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x01 = parameters[0].getEstimate();\n+      double x02 = parameters[1].getEstimate();\n+      double x03 = parameters[2].getEstimate();\n+      double x04 = parameters[3].getEstimate();\n+      double x05 = parameters[4].getEstimate();\n+      double x06 = parameters[5].getEstimate();\n+      double x07 = parameters[6].getEstimate();\n+      double x08 = parameters[7].getEstimate();\n+      double x09 = parameters[8].getEstimate();\n+      double x10 = parameters[9].getEstimate();\n+      double x11 = parameters[10].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      1.366, 1.191, 1.112, 1.013, 0.991,\n+      0.885, 0.831, 0.847, 0.786, 0.725,\n+      0.746, 0.679, 0.608, 0.655, 0.616,\n+      0.606, 0.602, 0.626, 0.651, 0.724,\n+      0.649, 0.649, 0.694, 0.644, 0.624,\n+      0.661, 0.612, 0.558, 0.533, 0.495,\n+      0.500, 0.423, 0.395, 0.375, 0.372,\n+      0.391, 0.396, 0.405, 0.428, 0.429,\n+      0.523, 0.562, 0.607, 0.653, 0.672,\n+      0.708, 0.633, 0.668, 0.645, 0.632,\n+      0.591, 0.559, 0.597, 0.625, 0.739,\n+      0.710, 0.729, 0.720, 0.636, 0.581,\n+      0.428, 0.292, 0.162, 0.098, 0.054\n+    };\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(LevenbergMarquardtEstimatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/WeightedMeasurementTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.estimation;\n+\n+import junit.framework.*;\n+\n+public class WeightedMeasurementTest\n+  extends TestCase {\n+\n+  public WeightedMeasurementTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstruction() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    checkValue(m.getWeight(), 3.0);\n+    checkValue(m.getMeasuredValue(), theoretical() + 0.1);\n+  }\n+\n+  public void testIgnored() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    assertTrue(!m.isIgnored());\n+    m.setIgnored(true);\n+    assertTrue(m.isIgnored());\n+    m.setIgnored(false);\n+    assertTrue(!m.isIgnored());\n+  }\n+\n+  public void testTheory() {\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    checkValue(m.getTheoreticalValue(), theoretical());\n+    checkValue(m.getResidual(), 0.1);\n+\n+    double oldP1 = p1.getEstimate();\n+    p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));\n+    checkValue(m.getResidual(), 0.0);\n+    p1.setEstimate(oldP1);\n+    checkValue(m.getResidual(), 0.1);\n+\n+    double oldP2 = p2.getEstimate();\n+    p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));\n+    checkValue(m.getResidual(), 0.0);\n+    p2.setEstimate(oldP2);\n+    checkValue(m.getResidual(), 0.1);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(WeightedMeasurementTest.class);\n+  }\n+\n+  public void setUp() {\n+    p1 = new EstimatedParameter(\"p1\", 1.0);\n+    p2 = new EstimatedParameter(\"p2\", 2.0);\n+  }\n+\n+  public void tearDown() {\n+    p1 = null;\n+    p2 = null;\n+  }\n+\n+  private void checkValue(double value, double expected) {\n+   assertTrue(Math.abs(value - expected) < 1.0e-10);\n+  }\n+\n+  private double theoretical() {\n+   return 3 * p1.getEstimate() - p2.getEstimate();\n+  }\n+\n+  private double partial(EstimatedParameter p) {\n+    if (p == p1) {\n+      return 3.0;\n+    } else if (p == p2) {\n+      return -1.0;\n+    } else {\n+      return 0.0;\n+    }\n+  }\n+\n+  private class MyMeasurement\n+    extends WeightedMeasurement {\n+\n+    public MyMeasurement(double weight, double measuredValue) {\n+      super(weight, measuredValue);\n+    }\n+\n+    public double getTheoreticalValue() {\n+      return theoretical();\n+    }\n+\n+    public double getPartial(EstimatedParameter p) {\n+      return partial(p);\n+    }\n+\n+    private static final long serialVersionUID = -246712922500792332L;\n+\n+  }\n+\n+  private EstimatedParameter p1;\n+  private EstimatedParameter p2;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/AbstractCurveFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.util.Random;\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimatedParameter;\n+import org.spaceroots.mantissa.estimation.WeightedMeasurement;\n+\n+public class AbstractCurveFitterTest\n+  extends TestCase {\n+\n+  public AbstractCurveFitterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testAlreadySorted() {\n+    for (double x = 0.0; x < 100.0; x += 1.0) {\n+      fitter.addWeightedPair(1.0, x, 0.0);\n+    }\n+    checkSorted();\n+  }\n+\n+  public void testReversed() {\n+    for (double x = 0.0; x < 100.0; x += 1.0) {\n+      fitter.addWeightedPair(1.0, 100.0 - x, 0.0);\n+    }\n+    checkSorted();\n+  }\n+\n+  public void testRandom() {\n+    Random randomizer = new Random(86757343594l);\n+    for (int i = 0; i < 100; ++i) {\n+      fitter.addWeightedPair(1.0, 10.0 * randomizer.nextDouble(), 0.0);\n+    }\n+    checkSorted();\n+  }\n+\n+  public void checkSorted() {\n+    fitter.doSort();\n+\n+    WeightedMeasurement[] measurements = fitter.getMeasurements();\n+    for (int i = 1; i < measurements.length; ++i) {\n+      AbstractCurveFitter.FitMeasurement m1\n+        = (AbstractCurveFitter.FitMeasurement) measurements[i-1];\n+      AbstractCurveFitter.FitMeasurement m2\n+        = (AbstractCurveFitter.FitMeasurement) measurements[i];\n+      assertTrue(m1.x <= m2.x);\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(AbstractCurveFitterTest.class);\n+  }\n+\n+  public void setUp() {\n+    fitter = new DummyFitter();\n+  }\n+\n+  public void tearOff() {\n+    fitter = null;\n+  }\n+\n+  private class DummyFitter\n+    extends AbstractCurveFitter {\n+\n+    public DummyFitter() {\n+      super(10, 10, 0.0, 0.0, 0.0);\n+    }\n+\n+    public double valueAt(double x) {\n+      return 0.0;\n+    }\n+\n+    public double partial(double x, EstimatedParameter p) {\n+      return 0.0;\n+    }\n+\n+    public void doSort() {\n+      sortMeasurements();\n+    }\n+\n+    private static final long serialVersionUID = -5453139487565082528L;\n+\n+  }\n+\n+  private DummyFitter fitter;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite= new TestSuite(\"org.spaceroots.mantissa.fitting\"); \n+\n+    suite.addTest(AbstractCurveFitterTest.suite());\n+    suite.addTest(PolynomialFitterTest.suite());\n+    suite.addTest(HarmonicFitterTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/HarmonicFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.util.Random;\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.WeightedMeasurement;\n+\n+public class HarmonicFitterTest\n+  extends TestCase {\n+\n+  public HarmonicFitterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoError()\n+    throws EstimationException {\n+    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+    HarmonicFitter fitter = new HarmonicFitter(20, 1.0e-7,\n+                                               1.0e-10, 1.0e-10);\n+    for (double x = 0.0; x < 1.3; x += 0.01) {\n+      fitter.addWeightedPair(1.0, x, f.valueAt(x));\n+    }\n+\n+    double[] coeffs = fitter.fit();\n+\n+    HarmonicFunction fitted = new HarmonicFunction(coeffs[0],\n+                                                   coeffs[1],\n+                                                   coeffs[2]);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-12);\n+    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-12);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-12);\n+\n+    for (double x = -1.0; x < 1.0; x += 0.01) {\n+      assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-12);\n+    }\n+\n+  }\n+\n+  public void test1PercentError()\n+    throws EstimationException {\n+    Random randomizer = new Random(64925784252l);\n+    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+    HarmonicFitter fitter = new HarmonicFitter(20, 1.0e-7,\n+                                               1.0e-10, 1.0e-10);\n+    for (double x = 0.0; x < 10.0; x += 0.1) {\n+      fitter.addWeightedPair(1.0, x,\n+                             f.valueAt(x) + 0.01 * randomizer.nextGaussian());\n+    }\n+\n+    double[] coeffs = fitter.fit();\n+\n+    new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-3);\n+    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 2.0e-2);\n+\n+    WeightedMeasurement[] measurements = fitter.getMeasurements();\n+    for (int i = 0; i < measurements.length; ++i) {\n+      WeightedMeasurement m = measurements[i];\n+      assertTrue(Math.abs(measurements[i].getMeasuredValue()\n+                          - m.getTheoreticalValue()) < 0.04);\n+    }\n+\n+  }\n+\n+  public void testUnsorted()\n+    throws EstimationException {\n+    Random randomizer = new Random(64925784252l);\n+    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+    HarmonicFitter fitter = new HarmonicFitter(100, 1.0e-7,\n+                                               1.0e-10, 1.0e-10);\n+\n+    // build a regularly spaced array of measurements\n+    int size = 100;\n+    double[] xTab = new double[size];\n+    double[] yTab = new double[size];\n+    for (int i = 0; i < size; ++i) {\n+      xTab[i] = 0.1 * i;\n+      yTab[i] = f.valueAt (xTab[i]) + 0.01 * randomizer.nextGaussian();\n+    }\n+\n+    // shake it\n+    for (int i = 0; i < size; ++i) {\n+      int i1 = randomizer.nextInt(size);\n+      int i2 = randomizer.nextInt(size);\n+      double xTmp = xTab[i1];\n+      double yTmp = yTab[i1];\n+      xTab[i1] = xTab[i2];\n+      yTab[i1] = yTab[i2];\n+      xTab[i2] = xTmp;\n+      yTab[i2] = yTmp;\n+    }\n+\n+    // pass it to the fitter\n+    for (int i = 0; i < size; ++i) {\n+      fitter.addWeightedPair(1.0, xTab[i], yTab[i]);\n+    }\n+\n+    double[] coeffs = fitter.fit();\n+\n+    new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-3);\n+    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 2.0e-2);\n+\n+    WeightedMeasurement[] measurements = fitter.getMeasurements();\n+    for (int i = 0; i < measurements.length; ++i) {\n+      WeightedMeasurement m = measurements[i];\n+      assertTrue(Math.abs(m.getMeasuredValue() - m.getTheoreticalValue())\n+                 < 0.04);\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HarmonicFitterTest.class);\n+  }\n+\n+  /** Center an angle with respect to another one. */\n+  private static double center(double a, double ref) {\n+    double twoPi = Math.PI + Math.PI;\n+    return a - twoPi * Math.floor((a + Math.PI - ref) / twoPi);\n+  }\n+\n+  private class HarmonicFunction {\n+    public HarmonicFunction(double a, double omega, double phi) {\n+      this.a     = a;\n+      this.omega = omega;\n+      this.phi   = phi;\n+    }\n+\n+    public double valueAt(double x) {\n+      return a * Math.cos(omega * x + phi);\n+    }\n+\n+    public double getA() {\n+      return a;\n+    }\n+\n+    public double getOmega() {\n+      return omega;\n+    }\n+\n+    public double getPhi() {\n+      return phi;\n+    }\n+\n+    private double a;\n+    private double omega;\n+    private double phi;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/PolynomialFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.fitting;\n+\n+import java.util.Random;\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+\n+public class PolynomialFitterTest\n+  extends TestCase {\n+\n+  public PolynomialFitterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoError()\n+    throws EstimationException {\n+    Random randomizer = new Random(64925784252l);\n+    for (int degree = 0; degree < 10; ++degree) {\n+      Polynom p = new Polynom(degree);\n+      for (int i = 0; i <= degree; ++i) {\n+        p.initCoeff (i, randomizer.nextGaussian());\n+      }\n+\n+      PolynomialFitter fitter = new PolynomialFitter(degree,\n+                                                     10, 1.0e-7,\n+                                                     1.0e-10, 1.0e-10);\n+      for (int i = 0; i <= degree; ++i) {\n+        fitter.addWeightedPair(1.0, i, p.valueAt(i));\n+      }\n+\n+      Polynom fitted = new Polynom(fitter.fit());\n+\n+      for (double x = -1.0; x < 1.0; x += 0.01) {\n+        double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))\n+          / (1.0 + Math.abs(p.valueAt(x)));\n+        assertTrue(Math.abs(error) < 1.0e-5);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallError()\n+    throws EstimationException {\n+    Random randomizer = new Random(53882150042l);\n+    for (int degree = 0; degree < 10; ++degree) {\n+      Polynom p = new Polynom(degree);\n+      for (int i = 0; i <= degree; ++i) {\n+        p.initCoeff(i, randomizer.nextGaussian());\n+      }\n+\n+      PolynomialFitter fitter = new PolynomialFitter(degree,\n+                                                     10, 1.0e-7,\n+                                                     1.0e-10, 1.0e-10);\n+      for (double x = -1.0; x < 1.0; x += 0.01) {\n+        fitter.addWeightedPair(1.0, x,\n+                               p.valueAt(x) + 0.1 * randomizer.nextGaussian());\n+      }\n+\n+      Polynom fitted = new Polynom(fitter.fit());\n+\n+      for (double x = -1.0; x < 1.0; x += 0.01) {\n+        double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))\n+          / (1.0 + Math.abs(p.valueAt(x)));\n+        assertTrue(Math.abs(error) < 0.1);\n+      }\n+    }\n+\n+  }\n+\n+  public void testUnsolvableProblem()\n+    throws EstimationException {\n+    Random randomizer = new Random(1248788532l);\n+    for (int degree = 0; degree < 10; ++degree) {\n+      Polynom p = new Polynom(degree);\n+      for (int i = 1; i <= degree; ++i) {\n+        p.initCoeff(i, randomizer.nextGaussian());\n+      }\n+\n+      PolynomialFitter fitter = new PolynomialFitter(degree,\n+                                                     10, 1.0e-7,\n+                                                     1.0e-10, 1.0e-10);\n+\n+      // reusing the same point over and over again does not bring\n+      // information, the problem cannot be solved in this case for\n+      // degrees greater than 1 (but one point is sufficient for\n+      // degree 0)\n+      for (double x = -1.0; x < 1.0; x += 0.01) {\n+        fitter.addWeightedPair(1.0, 0.0, p.valueAt(0.0));\n+      }\n+\n+      boolean gotIt = false;\n+      try {\n+        fitter.fit();\n+      } catch(EstimationException e) {\n+        gotIt = true;\n+      }\n+      assertTrue((degree == 0 && ! gotIt) || (degree > 0 && gotIt));\n+\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(PolynomialFitterTest.class);\n+  }\n+\n+  private class Polynom {\n+\n+    public Polynom(int degree) {\n+      coeffs = new double[degree + 1];\n+      for (int i = 0; i < coeffs.length; ++i) {\n+        coeffs[i] = 0.0;\n+      }\n+    }\n+\n+    public Polynom(double[]coeffs) {\n+      this.coeffs = coeffs;\n+    }\n+\n+    public void initCoeff(int i, double c) {\n+      coeffs[i] = c;\n+    }\n+\n+    public double valueAt(double x) {\n+      double y = coeffs[coeffs.length - 1];\n+      for (int i = coeffs.length - 2; i >= 0; --i) {\n+        y = y * x + coeffs[i];\n+      }\n+      return y;\n+    }\n+\n+    private double[] coeffs;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.functions\"); \n+\n+    suite.addTest(org.spaceroots.mantissa.functions.scalar.AllTests.suite()); \n+    suite.addTest(org.spaceroots.mantissa.functions.vectorial.AllTests.suite()); \n+\n+    return suite;\n+ \n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.functions.scalar\"); \n+\n+    suite.addTest(ScalarValuedPairTest.suite()); \n+    suite.addTest(ComputableFunctionSamplerTest.suite()); \n+    suite.addTest(BasicSampledFunctionIteratorTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIteratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+import junit.framework.*;\n+\n+public class BasicSampledFunctionIteratorTest\n+  extends TestCase {\n+\n+  public BasicSampledFunctionIteratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testIteration()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));\n+\n+    for (int i = 0; i < 10; ++i) {\n+      assertTrue(iter.hasNext());\n+      ScalarValuedPair pair = iter.nextSamplePoint();\n+      assertTrue(Math.abs(pair.getX() - 0.1 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.getY() + 0.1 * i) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testExhausted()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));\n+\n+    for (int i = 0; i < 10; ++i) {\n+      assertTrue(iter.hasNext());\n+      iter.nextSamplePoint();\n+    }\n+\n+    assertTrue(! iter.hasNext());\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch(ExhaustedSampleException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public void testUnderlyingException()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new SampledFunction() {\n+\n+          private boolean fireException = false;\n+\n+          public int size() {\n+            return 2;\n+          }\n+\n+          public ScalarValuedPair samplePointAt(int i)\n+            throws FunctionException {\n+            if (fireException) {\n+              throw new FunctionException(\"boom\");\n+            }\n+            fireException = true;\n+            return new ScalarValuedPair(0.0, 0.0);\n+          }\n+\n+        });\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(! exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch (FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(BasicSampledFunctionIteratorTest.class);\n+  }\n+\n+  private class Function\n+    implements SampledFunction {\n+\n+    private double begin;\n+    private double step;\n+    private int    n;\n+\n+    public Function(double begin, double step, int n) {\n+      this.begin = begin;\n+      this.step  = step;\n+      this.n     = n;\n+    }\n+\n+    public int size() {\n+      return n;\n+    }\n+\n+    public ScalarValuedPair samplePointAt(int i)\n+      throws FunctionException {\n+\n+      if (i < 0 || i >= n) {\n+        throw new FunctionException(\"outside of range\");\n+      }\n+\n+      double x = begin + i * step;\n+      return new ScalarValuedPair(x, -x);\n+\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSamplerTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+import junit.framework.*;\n+\n+public class ComputableFunctionSamplerTest\n+  extends TestCase {\n+\n+  public ComputableFunctionSamplerTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBeginStepNumber()\n+    throws FunctionException {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0),\n+                                    0.0, 0.099, 11);\n+\n+    assertTrue(sampler.size() == 11);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 0.990) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeNumber()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0), range, 11);\n+\n+    assertTrue(sampler.size() == 11);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 1.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeStepNoAdjust()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0),\n+                                    range, 0.083, false);\n+\n+    assertTrue(sampler.size() == 12);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).getX() - 0.913) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).getY() + 0.913) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeStepAdjust()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0),\n+                                    range, 0.083, true);\n+\n+    assertTrue(sampler.size() == 13);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).getX()  - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).getY()  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).getX() - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).getY() + 1.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testOutOfRange()\n+    throws FunctionException {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(-1);\n+    } catch(ArrayIndexOutOfBoundsException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(10);\n+    } catch(ArrayIndexOutOfBoundsException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public void testUnderlyingException() {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new ComputableFunction() {\n+          public double valueAt(double x)\n+            throws FunctionException {\n+            if (x < 0.5) {\n+              return -x;\n+            }\n+            throw new FunctionException(\"upper half range exception\");\n+          }\n+        },\n+                                    0.0, 0.1, 11);\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(2);\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(! exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(8);\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ComputableFunctionSamplerTest.class);\n+  }\n+\n+  private class Function\n+    implements ComputableFunction {\n+\n+    private double min;\n+    private double max;\n+\n+    public Function(double min, double max) {\n+      this.min = min;\n+      this.max = max;\n+    }\n+\n+    public double valueAt(double x)\n+      throws FunctionException {\n+\n+      if (x < min || x > max) {\n+        throw new FunctionException(\"outside of range\");\n+      }\n+\n+      return -x;\n+\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPairTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.scalar;\n+\n+import junit.framework.*;\n+\n+public class ScalarValuedPairTest\n+  extends TestCase {\n+\n+  public ScalarValuedPairTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstructor() {\n+    ScalarValuedPair pair = new ScalarValuedPair(1.2, -8.4);\n+    assertTrue(Math.abs(pair.getX() - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(pair.getY() + 8.4) < 1.0e-10);\n+  }\n+\n+  public void testCopyConstructor() {\n+\n+    ScalarValuedPair pair1 = new ScalarValuedPair(1.2, -8.4);\n+    ScalarValuedPair pair2 = new ScalarValuedPair(pair1);\n+\n+    assertTrue(Math.abs(pair2.getX() - pair1.getX()) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY() - pair1.getY()) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getX() - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY() + 8.4) < 1.0e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ScalarValuedPairTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.functions.vectorial\"); \n+\n+    suite.addTest(VectorialValuedPairTest.suite()); \n+    suite.addTest(ComputableFunctionSamplerTest.suite()); \n+    suite.addTest(BasicSampledFunctionIteratorTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIteratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n+\n+import junit.framework.*;\n+\n+public class BasicSampledFunctionIteratorTest\n+  extends TestCase {\n+\n+  public BasicSampledFunctionIteratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testIteration()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));\n+\n+    for (int i = 0; i < 10; ++i) {\n+      assertTrue(iter.hasNext());\n+      VectorialValuedPair pair = iter.nextSamplePoint();\n+      assertTrue(Math.abs(pair.getX()    - 0.1 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.getY()[0] + 0.1 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.getY()[1] + 0.2 * i) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testExhausted()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));\n+\n+    for (int i = 0; i < 10; ++i) {\n+      assertTrue(iter.hasNext());\n+      iter.nextSamplePoint();\n+    }\n+\n+    assertTrue(! iter.hasNext());\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch(ExhaustedSampleException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public void testUnderlyingException()\n+    throws ExhaustedSampleException, FunctionException {\n+\n+    BasicSampledFunctionIterator iter =\n+      new BasicSampledFunctionIterator(new SampledFunction() {\n+\n+          private boolean fireException = false;\n+\n+          public int size() {\n+            return 2;\n+          }\n+\n+          public int getDimension() {\n+            return 2;\n+          }\n+\n+          public VectorialValuedPair samplePointAt(int i)\n+            throws FunctionException {\n+            if (fireException) {\n+              throw new FunctionException(\"boom\");\n+            }\n+            fireException = true;\n+            return new VectorialValuedPair(0.0, null);\n+          }\n+        });\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(! exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      iter.nextSamplePoint();\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(BasicSampledFunctionIteratorTest.class);\n+  }\n+\n+  private class Function\n+    implements SampledFunction {\n+\n+    private double   begin;\n+    private double   step;\n+    private int      n;\n+    private double[] values;\n+\n+    public Function(double begin, double step, int n) {\n+      this.begin  = begin;\n+      this.step   = step;\n+      this.n      = n;\n+      values      = new double[2];\n+    }\n+\n+    public int size() {\n+      return n;\n+    }\n+\n+    public int getDimension() {\n+      return 2;\n+    }\n+\n+    public VectorialValuedPair samplePointAt(int i)\n+      throws FunctionException {\n+\n+      if (i < 0 || i >= n) {\n+        throw new FunctionException(\"outside of range\");\n+      }\n+\n+      double x = begin + i * step;\n+      values[0] = -x;\n+      values[1] = 2.0 * values[0];\n+      return new VectorialValuedPair(x, values);\n+\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSamplerTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+import junit.framework.*;\n+\n+public class ComputableFunctionSamplerTest\n+  extends TestCase {\n+\n+  public ComputableFunctionSamplerTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBeginStepNumber()\n+    throws FunctionException {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 0.099, 11);\n+\n+    assertTrue(sampler.size() == 11);\n+    assertTrue(sampler.getDimension() == 2);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getX()    - 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[0] + 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[1] + 1.980) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeNumber()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function (0.0, 1.0), range, 11);\n+\n+    assertTrue(sampler.size() == 11);\n+    assertTrue(sampler.getDimension() == 2);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getX()    - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[0] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[1] + 2.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeStepNoAdjust()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0),\n+                                     range, 0.083, false);\n+\n+    assertTrue(sampler.size() == 12);\n+    assertTrue(sampler.getDimension() == 2);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 0.830) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).getX()    - 0.913) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).getY()[0] + 0.913) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).getY()[1] + 1.826) < 1.0e-10);\n+\n+  }\n+\n+  public void testRangeStepAdjust()\n+    throws FunctionException {\n+\n+    double[] range = new double[2];\n+    range[0] = 0.0;\n+    range[1] = 1.0;\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0),\n+                                    range, 0.083, true);\n+\n+    assertTrue(sampler.size() == 13);\n+    assertTrue(sampler.getDimension() == 2);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).getX()     - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).getY()[0]  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).getY()[1]  + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).getX()    - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).getY()[0] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).getY()[1] + 2.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testOutOfRange()\n+    throws FunctionException {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(-1);\n+    } catch(ArrayIndexOutOfBoundsException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(10);\n+    } catch(ArrayIndexOutOfBoundsException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public void testUnderlyingException() {\n+\n+    ComputableFunctionSampler sampler =\n+      new ComputableFunctionSampler(new ComputableFunction() {\n+\n+          public int getDimension() {\n+            return 2;\n+          }\n+\n+          public double[] valueAt(double x)\n+            throws FunctionException {\n+            if (x < 0.5) {\n+              double[] res = new double[2];\n+              res[0] = -x;\n+              res[1] = -2.0 * x;\n+              return res;\n+            }\n+            throw new FunctionException(\"upper half range exception\");\n+           }\n+\n+        },\n+                                    0.0, 0.1, 11);\n+\n+    boolean exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(2);\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(! exceptionOccurred);\n+\n+    exceptionOccurred = false;\n+    try {\n+      sampler.samplePointAt(8);\n+    } catch(FunctionException e) {\n+      exceptionOccurred = true;\n+    }\n+    assertTrue(exceptionOccurred);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ComputableFunctionSamplerTest.class);\n+  }\n+\n+  private class Function\n+    implements ComputableFunction {\n+    private double   min;\n+    private double   max;\n+    private double[] values;\n+\n+    public int getDimension() {\n+      return 2;\n+    }\n+\n+    public Function(double min, double max) {\n+      this.min = min;\n+      this.max = max;\n+      values   = new double[2];\n+    }\n+\n+    public double[] valueAt(double x)\n+      throws FunctionException {\n+\n+      if (x < min || x > max) {\n+        throw new FunctionException(\"outside of range\");\n+      }\n+\n+      values[0] = -x;\n+      values[1] = -2.0 * x;\n+      return values;\n+\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPairTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.functions.vectorial;\n+\n+import junit.framework.*;\n+\n+public class VectorialValuedPairTest\n+  extends TestCase {\n+\n+  public VectorialValuedPairTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstructor() {\n+    double[] tab = new double[2];\n+    tab[0] = -8.4;\n+    tab[1] = -3.2;\n+    VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);\n+    assertTrue(Math.abs(pair.getX()    - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(pair.getY()[0] + 8.4) < 1.0e-10);\n+    assertTrue(Math.abs(pair.getY()[1] + 3.2) < 1.0e-10);\n+  }\n+\n+  public void testCopyConstructor() {\n+    double[] tab = new double[2];\n+    tab[0] = -8.4;\n+    tab[1] = -3.2;\n+    VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);\n+    VectorialValuedPair pair2 = new VectorialValuedPair(pair1);\n+    assertTrue(Math.abs(pair2.getX()    - pair1.getX())    < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY()[0] - pair1.getY()[0]) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY()[1] - pair1.getY()[1]) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getX()    - 1.2)        < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY()[0] + 8.4)        < 1.0e-10);\n+    assertTrue(Math.abs(pair2.getY()[1] + 3.2)        < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(VectorialValuedPairTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.geometry\"); \n+\n+    suite.addTest(Vector3DTest.suite());\n+    suite.addTest(ImmutableVector3DTest.suite());\n+    suite.addTest(RotationTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/ImmutableVector3DTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import junit.framework.*;\n+\n+public class ImmutableVector3DTest\n+  extends TestCase {\n+\n+  public ImmutableVector3DTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testCanonical() {\n+    try {\n+      Vector3D.plusK.normalizeSelf();\n+      fail(\"an exception should have been thrown\");\n+    } catch (UnsupportedOperationException uoe) {\n+    } catch (Exception e) {\n+      fail (\"wrong exception caught\");\n+    }\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(ImmutableVector3DTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/RotationTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import junit.framework.*;\n+\n+public class RotationTest\n+  extends TestCase {\n+\n+  public RotationTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testIdentity() {\n+\n+    Rotation r = new Rotation();\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(-1, 0, 0, 0, false);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(42, 0, 0, 0, true);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+  }\n+\n+  public void testAxisAngle() {\n+\n+    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);\n+    double s = 1 / Math.sqrt(3);\n+    checkVector(r.getAxis(), new Vector3D(s, s, s));\n+    checkAngle(r.getAngle(), 2 * Math.PI / 3);\n+\n+    try {\n+      r = new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"unexpected exception\");\n+    }\n+\n+    r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);\n+    checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n+    checkAngle(r.getAngle(), 0.5 * Math.PI);\n+\n+    r = new Rotation(Vector3D.plusJ, Math.PI);\n+    checkVector(r.getAxis(), Vector3D.plusJ);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testVectorOnePair() {\n+\n+    Vector3D u = new Vector3D(3, 2, 1);\n+    Vector3D v = new Vector3D(-4, 2, 2);\n+    Rotation r = new Rotation(u, v);\n+    checkVector(r.applyTo(Vector3D.multiply(v.getNorm(), u)),\n+                Vector3D.multiply(u.getNorm(), v));\n+\n+    checkAngle(new Rotation(u, Vector3D.negate(u)).getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testVectorTwoPairs() {\n+\n+    Vector3D u1 = new Vector3D(3, 0, 0);\n+    Vector3D u2 = new Vector3D(0, 5, 0);\n+    Vector3D v1 = new Vector3D(0, 0, 2);\n+    Vector3D v2 = new Vector3D(-2, 0, 2);\n+    Rotation r = new Rotation(u1, u2, v1, v2);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.negate(Vector3D.plusI));\n+\n+    r = new Rotation(u1, u2, Vector3D.negate(u1), Vector3D.negate(u2));\n+    Vector3D axis = r.getAxis();\n+    if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {\n+      checkVector(axis, Vector3D.plusK);\n+    } else {\n+      checkVector(axis, Vector3D.negate(Vector3D.plusK));\n+    }\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testMatrix()\n+    throws NotARotationMatrixException {\n+\n+    double[][] m1 = { { 0.0, 1.0, 0.0 },\n+                      { 0.0, 0.0, 1.0 },\n+                      { 1.0, 0.0, 0.0 } };\n+    Rotation r = new Rotation(m1, 1.0e-7);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);\n+\n+    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+                      { 0.48293,  0.78164, -0.39474 },\n+                      { 0.27296,  0.29396,  0.91602 } };\n+    r = new Rotation(m2, 1.0e-12);\n+\n+    double[][] m3 = r.getMatrix();\n+    double d00 = m2[0][0] - m3[0][0];\n+    double d01 = m2[0][1] - m3[0][1];\n+    double d02 = m2[0][2] - m3[0][2];\n+    double d10 = m2[1][0] - m3[1][0];\n+    double d11 = m2[1][1] - m3[1][1];\n+    double d12 = m2[1][2] - m3[1][2];\n+    double d20 = m2[2][0] - m3[2][0];\n+    double d21 = m2[2][1] - m3[2][1];\n+    double d22 = m2[2][2] - m3[2][2];\n+\n+    assertTrue(Math.abs(d00) < 6.0e-6);\n+    assertTrue(Math.abs(d01) < 6.0e-6);\n+    assertTrue(Math.abs(d02) < 6.0e-6);\n+    assertTrue(Math.abs(d10) < 6.0e-6);\n+    assertTrue(Math.abs(d11) < 6.0e-6);\n+    assertTrue(Math.abs(d12) < 6.0e-6);\n+    assertTrue(Math.abs(d20) < 6.0e-6);\n+    assertTrue(Math.abs(d21) < 6.0e-6);\n+    assertTrue(Math.abs(d22) < 6.0e-6);\n+\n+    assertTrue(Math.abs(d00) > 4.0e-7);\n+    assertTrue(Math.abs(d01) > 4.0e-7);\n+    assertTrue(Math.abs(d02) > 4.0e-7);\n+    assertTrue(Math.abs(d10) > 4.0e-7);\n+    assertTrue(Math.abs(d11) > 4.0e-7);\n+    assertTrue(Math.abs(d12) > 4.0e-7);\n+    assertTrue(Math.abs(d20) > 4.0e-7);\n+    assertTrue(Math.abs(d21) > 4.0e-7);\n+    assertTrue(Math.abs(d22) > 4.0e-7);\n+\n+    for (int i = 0; i < 3; ++i) {\n+      for (int j = 0; j < 3; ++j) {\n+        double m3tm3 = m3[i][0] * m3[j][0]\n+                     + m3[i][1] * m3[j][1]\n+                     + m3[i][2] * m3[j][2];\n+        if (i == j) {\n+          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);\n+        } else {\n+          assertTrue(Math.abs(m3tm3) < 1.0e-10);\n+        }\n+      }\n+    }\n+\n+    checkVector(r.applyTo(Vector3D.plusI),\n+                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n+    checkVector(r.applyTo(Vector3D.plusJ),\n+                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n+    checkVector(r.applyTo(Vector3D.plusK),\n+                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n+\n+    double[][] m4 = { { 1.0,  0.0,  0.0 },\n+                      { 0.0, -1.0,  0.0 },\n+                      { 0.0,  0.0, -1.0 } };\n+    r = new Rotation(m4, 1.0e-7);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+    try {\n+      double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                        { 0.0, 1.0, 0.0 },\n+                        { 1.0, 0.0, 0.0 } };\n+      r = new Rotation(m5, 1.0e-7);\n+      fail(\"an exception should have been thrown\");\n+    } catch (NotARotationMatrixException e) {\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  public void testAngles()\n+    throws CardanEulerSingularityException {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    RotationOrder[] EulerOrders = {\n+      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+    };\n+\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(CardanOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(CardanOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(EulerOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(EulerOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testQuaternion() {\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    double n = 23.5;\n+    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),\n+                               n * r1.getQ2(), n * r1.getQ3(),\n+                               true);\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(u), r1.applyTo(u));\n+        }\n+      }\n+    }\n+  }\n+\n+  public void testCompose() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testComposeInverse() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyInverseTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testApplyInverseTo() {\n+\n+    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          r.applyInverseTo(r.applyTo(u));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation();\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation(Vector3D.plusK, Math.PI);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    assertTrue(Vector3D.subtract(v1, v2).getNorm() < 1.0e-10);\n+  }\n+\n+  private void checkAngle(double a1, double a2) {\n+    a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));\n+    assertTrue(Math.abs(a1 - a2) < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RotationTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/Vector3DTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.geometry;\n+\n+import junit.framework.*;\n+\n+public class Vector3DTest\n+  extends TestCase {\n+\n+  public Vector3DTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testCoordinates() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);\n+    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);\n+    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);\n+  }\n+  \n+  public void testNorm() {\n+    assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);\n+    assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))\n+               < 1.0e-12);\n+  }\n+\n+  public void testSubtract() {\n+\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1.subtractFromSelf(v2);\n+    checkVector(v1, new Vector3D(4, 4, 4));\n+\n+    checkVector(Vector3D.subtract(v2, v1), new Vector3D(-7, -6, -5));\n+\n+  }\n+\n+  public void testAdd() {\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1.addToSelf(v2);\n+    checkVector(v1, new Vector3D(-2, 0, 2));\n+\n+    checkVector(Vector3D.add(v2, v1), new Vector3D(-5, -2, 1));\n+\n+  }\n+\n+  public void testScalarProduct() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    v.multiplySelf(3);\n+    checkVector(v, new Vector3D(3, 6, 9));\n+\n+    checkVector(Vector3D.multiply(0.5, v), new Vector3D(1.5, 3, 4.5));\n+\n+  }\n+\n+  public void testVectorialProducts() {\n+    Vector3D v1 = new Vector3D(2, 1, -4);\n+    Vector3D v2 = new Vector3D(3, 1, -1);\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n+\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    checkVector(v3, new Vector3D(3, -10, -1));\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n+    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n+\n+  }\n+\n+  public void testAngular() {\n+\n+    assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);\n+\n+    Vector3D u = new Vector3D(-1, 1, -1);\n+    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n+    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);\n+\n+  }\n+\n+  public void testAngularSeparation() {\n+    Vector3D v1 = new Vector3D(2, -1, 4);\n+\n+    Vector3D  k = v1;\n+    k.normalizeSelf();\n+    Vector3D  i = k.orthogonal();\n+\n+    Vector3D v2 = Vector3D.multiply(Math.cos(1.2), k);\n+    v2.addToSelf(Vector3D.multiply(Math.sin(1.2), i));\n+\n+    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    assertTrue(Vector3D.subtract(v1, v2).getNorm() < 1.0e-12);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(Vector3DTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() {\n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.linalg\"); \n+\n+    suite.addTest(NonNullRangeTest.suite()); \n+    suite.addTest(GeneralMatrixTest.suite()); \n+    suite.addTest(DiagonalMatrixTest.suite()); \n+    suite.addTest(LowerTriangularMatrixTest.suite()); \n+    suite.addTest(UpperTriangularMatrixTest.suite()); \n+    suite.addTest(GeneralSquareMatrixTest.suite()); \n+    suite.addTest(SymetricalMatrixTest.suite()); \n+    suite.addTest(MatrixFactoryTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/DiagonalMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class DiagonalMatrixTest\n+  extends TestCase {\n+\n+  public DiagonalMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testConstantDiagonal() {\n+    checkMatrix(new DiagonalMatrix(5, 2.7), 2.7);\n+  }\n+\n+  public void testNoSetOutsideOfDiagonal() {\n+\n+    DiagonalMatrix d = new DiagonalMatrix(4);\n+\n+    for (int i = 0; i < d.getRows(); ++i) {\n+      for (int j = 0; j < d.getColumns(); ++j) {\n+        if (i == j) {\n+          d.setElement(i, j, 2.7);\n+        } else {\n+          boolean gotIt = false;\n+          try {\n+            d.setElement(i, j, -1.3);\n+          } catch (ArrayIndexOutOfBoundsException e) {\n+            gotIt = true;\n+          }\n+          assertTrue(gotIt);\n+        }\n+      }\n+    }\n+\n+    checkMatrix(d, 2.7);\n+\n+  }\n+\n+  public void testCopy() {\n+    DiagonalMatrix d1 = new DiagonalMatrix(7, 4.3);\n+    DiagonalMatrix d2 = new DiagonalMatrix(d1);\n+\n+    for (int i = 0; i < d1.getRows(); ++i) {\n+      d1.setElement(i, i, -1.0);\n+    }\n+\n+    assertTrue(d2.getRows() == d1.getRows());\n+    assertTrue(d2.getColumns() == d1.getColumns());\n+\n+    checkMatrix(d2, 4.3);\n+\n+  }\n+\n+  public void testDuplicate() {\n+    DiagonalMatrix d1 = new DiagonalMatrix(6, -8.8);\n+\n+    Matrix d2 = d1.duplicate();\n+    assertTrue(d2 instanceof DiagonalMatrix);\n+\n+    for (int i = 0; i < d1.getRows(); ++i) {\n+      d1.setElement(i, i, -1.0);\n+    }\n+\n+    assertTrue(d2.getRows() == d1.getRows());\n+    assertTrue(d2.getColumns() == d1.getColumns());\n+\n+    checkMatrix(d2, -8.8);\n+\n+  }\n+\n+  public void testTranspose() {\n+\n+    DiagonalMatrix d = new DiagonalMatrix(5, 3.4);\n+\n+    Matrix transposed = d.getTranspose();\n+    assertTrue(transposed instanceof DiagonalMatrix);\n+\n+    checkMatrix(transposed, 3.4);\n+\n+  }\n+\n+  public void testDeterminant() {\n+\n+    double expected;\n+\n+    expected = 1.0;\n+    for (int k = 1; k < 10; ++k) {\n+      expected *= 2;\n+      DiagonalMatrix d = new DiagonalMatrix(k, 2.0);\n+      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);\n+    }\n+\n+    expected = 1.0;\n+    for (int k = 1; k < 10; ++k) {\n+      expected *= k;\n+      DiagonalMatrix d = new DiagonalMatrix(k);\n+      for (int i = 0; i < k; ++i) {\n+        d.setElement(i, i, i + 1);\n+      }\n+      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testSolve()\n+    throws SingularMatrixException {\n+\n+    DiagonalMatrix d = new DiagonalMatrix(6);\n+    for (int i = 0; i < d.getRows(); ++i) {\n+      d.setElement(i, i, i + 1.0);\n+    }\n+\n+    GeneralMatrix b = new GeneralMatrix(6, 3);\n+    for (int i = 0; i < b.getRows(); ++i) {\n+      b.setElement(i, 0, i + 1.0);\n+      b.setElement(i, 1, (i + 1.0) * (i + 1.0));\n+      b.setElement(i, 2, 0.0);\n+    }\n+\n+    Matrix result = d.solve(b, 1.0e-10);\n+\n+    assertTrue(result.getRows() == b.getRows());\n+    assertTrue(result.getColumns() == b.getColumns());\n+\n+    for (int i = 0; i < result.getRows(); ++i) {\n+      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);\n+    }\n+\n+    boolean gotIt = false;\n+    try {\n+      d.setElement(3, 3, 0.0);\n+      result = d.solve(b, 1.0e-10);\n+    } catch (SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testInverse()\n+    throws SingularMatrixException {\n+\n+    DiagonalMatrix d = new DiagonalMatrix(4);\n+    for (int i = 0; i < d.getRows (); ++i) {\n+      d.setElement(i, i, i + 1.0);\n+    }\n+\n+    Matrix inverse = d.getInverse(1.0e-10);\n+    assertTrue(inverse instanceof DiagonalMatrix);\n+\n+    for (int i = 0; i < inverse.getRows(); ++i) {\n+      assertTrue(Math.abs(inverse.getElement(i, i) - 1.0 / (i + 1.0)) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DiagonalMatrixTest.class);\n+  }\n+\n+  public void checkMatrix(Matrix d, double value) {\n+    for (int i = 0; i < d.getRows(); ++i) {\n+      for (int j = 0; j < d.getColumns(); ++j) {\n+        double expected = (i == j) ? value : 0.0;\n+        assertTrue(Math.abs(d.getElement(i, j) - expected) < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class GeneralMatrixTest\n+  extends TestCase {\n+\n+  public GeneralMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensions() {\n+    GeneralMatrix m = new GeneralMatrix(3, 4);\n+    assertTrue(m.getRows() == 3);\n+    assertTrue(m.getColumns() == 4);\n+  }\n+\n+  public void testInvalidDimensions() {\n+    boolean gotIt;\n+\n+    gotIt = false;\n+    try {\n+      new GeneralMatrix(0, 2);\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+    gotIt = false;\n+    try {\n+      new GeneralMatrix(1, -3, null);\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testElements() {\n+    Matrix m = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    checkMatrix(m, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testCopy() {\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    GeneralMatrix m2 = new GeneralMatrix(m1);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = 0; j < m1.getColumns(); ++j) {\n+        m1.setElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDuplicate() {\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = m1.duplicate();\n+    assertTrue(m2 instanceof GeneralMatrix);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = 0; j < m1.getColumns(); ++j) {\n+        m1.setElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix (m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testAddKO() {\n+    boolean gotIt = false;\n+    try {\n+      new GeneralMatrix(2, 3).add(new GeneralMatrix(3, 2));\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+  }\n+\n+  public void testAddOK() {\n+\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new ElementPattern() {\n+                              public double value(int i, int j) {\n+                                return 100 * i - 0.01 * j;\n+                              }\n+                            });\n+\n+    Matrix m3 = m1.add(m2);\n+\n+    checkMatrix(m3, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 101 * i;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfAdd() {\n+\n+    GeneralMatrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new ElementPattern() {\n+                              public double value(int i, int j) {\n+                                return 100 * i - 0.01 * j;\n+                              }\n+                            });\n+\n+    m1.selfAdd(m2);\n+\n+    checkMatrix(m1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 101 * i;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSubKO() {\n+    boolean gotIt = false;\n+    try {\n+      new GeneralMatrix(2, 3).sub(new GeneralMatrix(3, 2));\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+  }\n+\n+  public void testSubOK() {\n+\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new ElementPattern() {\n+                              public double value(int i, int j) {\n+                                return 100 * i - 0.01 * j;\n+                              }\n+                            });\n+\n+    Matrix m3 = m1.sub(m2);\n+\n+    checkMatrix(m3, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.02 * j - 99 * i;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfSub() {\n+\n+    GeneralMatrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new ElementPattern() {\n+                              public double value(int i, int j) {\n+                                return 100 * i - 0.01 * j;\n+                              }\n+                            });\n+\n+    m1.selfSub(m2);\n+\n+    checkMatrix(m1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.02 * j - 99 * i;\n+        }\n+      });\n+\n+  }\n+\n+  public void testMulMKO() {\n+    boolean gotIt = false;\n+    try {\n+      new GeneralMatrix(2, 3).mul(new GeneralMatrix(2, 3));\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+  }\n+\n+  public void testMulMOK() {\n+\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = buildMatrix(m1.getColumns(), 4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - j;\n+        }\n+      });\n+\n+    Matrix m3 = m1.mul(m2);\n+\n+    checkMatrix(m3, new ElementPattern() {\n+        public double value(int i, int j) {\n+          int p = 10; // must be equal to m1.getColumns()\n+          return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0\n+                      - i* j\n+                      + (p - 1) * (2 * p - 1) / 300.0);\n+        }\n+      });\n+\n+  }\n+\n+  public void testMulD() {\n+\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = m1.mul(2.5);\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2.5 * (i + 0.01 * j);\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfMul() {\n+\n+    Matrix m = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    m.selfMul(2.5);\n+\n+    checkMatrix(m, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2.5 * (i + 0.01 * j);\n+        }\n+      });\n+\n+  }\n+\n+  public void testTranspose() {\n+\n+    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = m1.getTranspose();\n+\n+    assertTrue(m1.getRows() == m2.getColumns());\n+    assertTrue(m1.getColumns() == m2.getRows());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.01 * i + j;\n+        }\n+      });\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GeneralMatrixTest.class);\n+  }\n+\n+  public interface ElementPattern {\n+    public double value(int i, int j);\n+  }\n+\n+  public GeneralMatrix buildMatrix(int rows, int columns,\n+                                   ElementPattern pattern) {\n+    GeneralMatrix m = new GeneralMatrix(rows, columns);\n+\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j){\n+        m.setElement(i, j, pattern.value(i, j));\n+      }\n+    }\n+\n+    return m;\n+\n+  }\n+\n+  public void checkMatrix(Matrix m, ElementPattern pattern) {\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j) {\n+        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))\n+                   < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralSquareMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class GeneralSquareMatrixTest\n+  extends TestCase {\n+\n+  public GeneralSquareMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensions() {\n+    GeneralSquareMatrix m = new GeneralSquareMatrix(3);\n+    assertTrue(m.getRows() == 3);\n+    assertTrue(m.getColumns() == 3);\n+  }\n+\n+  public void testInvalidDimensions() {\n+    boolean gotIt;\n+\n+    gotIt = false;\n+    try {\n+      new GeneralSquareMatrix(0);\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+    gotIt = false;\n+    try {\n+      new GeneralSquareMatrix(-3, null);\n+    } catch(IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testElements() {\n+    Matrix m = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    checkMatrix(m, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testCopy() {\n+    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = 0; j < m1.getColumns(); ++j) {\n+        m1.setElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDuplicate() {\n+    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    Matrix m2 = m1.duplicate();\n+    assertTrue(m2 instanceof GeneralSquareMatrix);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = 0; j < m1.getColumns(); ++j) {\n+        m1.setElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfAdd() {\n+    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    GeneralSquareMatrix m2 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.03 * j;\n+        }\n+      });\n+\n+\n+    m1.selfAdd(m2);\n+\n+    checkMatrix(m1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 3 * i - 0.02 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfSub() {\n+    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.01 * j;\n+        }\n+      });\n+\n+    GeneralSquareMatrix m2 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.03 * j;\n+        }\n+      });\n+\n+\n+    m1.selfSub(m2);\n+\n+    checkMatrix(m1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.04 * j - i;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDeterminant() {\n+\n+    GeneralSquareMatrix m1 = buildProblem1().a;\n+    assertTrue(Math.abs(m1.getDeterminant(1.0e-10) - 6.0) < 1.0e-10);\n+\n+    GeneralSquareMatrix m2 = buildProblem2().a;\n+    assertTrue(Math.abs(m2.getDeterminant(1.0e-10) + 0.9999999) < 1.0e-10);\n+\n+    GeneralSquareMatrix m3 = buildProblem3().a;\n+    assertTrue(Math.abs(m3.getDeterminant(1.0e-10) - 0.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testSolve()\n+    throws SingularMatrixException {\n+\n+    LinearProblem p;\n+    Matrix result;\n+\n+    p = buildProblem1();\n+    result = p.a.solve(p.b, 1.0e-10);\n+    checkSolve(p, result);\n+\n+    p = buildProblem2();\n+    result = p.a.solve(p.b, 1.0e-10);\n+    checkSolve(p, result);\n+\n+    boolean gotIt = false;\n+    try {\n+      p = buildProblem3();\n+      result = p.a.solve(p.b, 1.0e-10);\n+    } catch(SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testInverse()\n+    throws SingularMatrixException {\n+\n+    SquareMatrix a, inverse;\n+\n+    a = buildProblem1().a;\n+    inverse = a.getInverse(1.0e-10);\n+    checkMatrix(a.mul(inverse), new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 1.0 : 0.0;\n+        }\n+      });\n+    \n+    a = buildProblem2().a;\n+    inverse = a.getInverse(1.0e-10);\n+    checkMatrix(a.mul(inverse), new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 1.0 : 0.0;\n+        }\n+      });\n+\n+    boolean gotIt = false;\n+    try {\n+      a = buildProblem3().a;\n+      inverse = a.getInverse(1.0e-10);\n+    } catch(SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GeneralSquareMatrixTest.class);\n+  }\n+\n+  public interface ElementPattern {\n+    public double value(int i, int j);\n+  }\n+\n+  public GeneralSquareMatrix buildMatrix(int order,\n+                                         ElementPattern pattern) {\n+    GeneralSquareMatrix m = new GeneralSquareMatrix(order);\n+\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j){\n+        m.setElement(i, j, pattern.value(i, j));\n+      }\n+    }\n+\n+    return m;\n+\n+  }\n+\n+  public void checkMatrix(Matrix m, ElementPattern pattern) {\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j) {\n+        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))\n+                   < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+  private class LinearProblem {\n+    public GeneralSquareMatrix a;\n+    public Matrix              x;\n+    public Matrix              b;\n+    public LinearProblem(GeneralSquareMatrix a, Matrix x, Matrix b) {\n+      this.a = a;\n+      this.x = x;\n+      this.b = b;\n+    }\n+  }\n+\n+  private LinearProblem buildProblem1() {\n+\n+    GeneralSquareMatrix a = new GeneralSquareMatrix(4);\n+\n+    a.setElement(0, 0,   2.0);\n+    a.setElement(0, 1,   1.0);\n+    a.setElement(0, 2,   0.0);\n+    a.setElement(0, 3,   4.0);\n+\n+    a.setElement(1, 0,  -4.0);\n+    a.setElement(1, 1,  -2.0);\n+    a.setElement(1, 2,   3.0);\n+    a.setElement(1, 3,  -7.0);\n+\n+    a.setElement(2, 0,   4.0);\n+    a.setElement(2, 1,   1.0);\n+    a.setElement(2, 2,  -2.0);\n+    a.setElement(2, 3,   8.0);\n+\n+    a.setElement(3, 0,   0.0);\n+    a.setElement(3, 1,  -3.0);\n+    a.setElement(3, 2, -12.0);\n+    a.setElement(3, 3,  -1.0);\n+\n+    GeneralMatrix x = new GeneralMatrix(4, 1);\n+\n+    x.setElement(0, 0,  3.0);\n+    x.setElement(1, 0,  4.0);\n+    x.setElement(2, 0, -1.0);\n+    x.setElement(3, 0, -2.0);\n+\n+    GeneralMatrix b = new GeneralMatrix(4, 1);\n+\n+    b.setElement(0, 0,  2.0);\n+    b.setElement(1, 0, -9.0);\n+    b.setElement(2, 0,  2.0);\n+    b.setElement(3, 0,  2.0);\n+\n+    return new LinearProblem(a, x, b);\n+\n+  }\n+\n+  private LinearProblem buildProblem2()\n+  {\n+\n+    double epsilon = 1.0e-7;\n+\n+    GeneralSquareMatrix a = new GeneralSquareMatrix(2);\n+\n+    a.setElement(0, 0, epsilon);\n+    a.setElement(0, 1, 1.0);\n+\n+    a.setElement(1, 0, 1.0);\n+    a.setElement(1, 1, 1.0);\n+\n+    GeneralMatrix x = new GeneralMatrix(2, 2);\n+\n+    x.setElement(0, 0, 1.0 + epsilon);\n+    x.setElement(1, 0, 1.0 - epsilon);\n+\n+    x.setElement(0, 1, epsilon);\n+    x.setElement(1, 1, 1.0);\n+\n+    GeneralMatrix b = new GeneralMatrix(2, 2);\n+\n+    b.setElement(0, 0, 1.0 + epsilon * epsilon);\n+    b.setElement(1, 0, 2.0);\n+\n+    b.setElement(0, 1, 1.0 + epsilon * epsilon);\n+    b.setElement(1, 1, 1.0 + epsilon);\n+\n+    return new LinearProblem(a, x, b);\n+\n+  }\n+\n+  private LinearProblem buildProblem3 ()\n+  {\n+\n+    GeneralSquareMatrix a = new GeneralSquareMatrix(3);\n+\n+    a.setElement(0, 0,  1.0);\n+    a.setElement(0, 1,  2.0);\n+    a.setElement(0, 1, -3.0);\n+\n+    a.setElement(1, 0,  2.0);\n+    a.setElement(1, 1,  1.0);\n+    a.setElement(1, 1,  3.0);\n+\n+    a.setElement(2, 0, -3.0);\n+    a.setElement(2, 1,  0.0);\n+    a.setElement(2, 1, -9.0);\n+\n+    GeneralMatrix x = new GeneralMatrix(3, 1);\n+    GeneralMatrix b = new GeneralMatrix(3, 1);\n+\n+    return new LinearProblem(a, x, b);\n+\n+  }\n+\n+  private void checkSolve(LinearProblem p, Matrix result)\n+  {\n+\n+    Matrix residual = p.a.mul(result).sub(p.b);\n+    for (int i = 0; i < residual.getRows(); ++i) {\n+      for (int j = 0; j < residual.getColumns(); ++j) {\n+        assertTrue(Math.abs(residual.getElement(i, j)) < 1.0e-10);\n+      }\n+    }\n+\n+    for (int i = 0; i < result.getRows(); ++i) {\n+      for (int j = 0; j < result.getColumns(); ++j) {\n+        assertTrue(Math.abs(result.getElement(i, j) - p.x.getElement(i, j))\n+                   < 1.0e-10);\n+      }\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/LowerTriangularMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class LowerTriangularMatrixTest\n+  extends TestCase {\n+\n+  public LowerTriangularMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoSetOutsideOfLowerTriangle() {\n+\n+    LowerTriangularMatrix l = new LowerTriangularMatrix(4);\n+\n+    for (int i = 0; i < l.getRows(); ++i) {\n+      for (int j = 0; j < l.getColumns(); ++j) {\n+\n+        if (i >= j) {\n+          l.setElement(i, j, i + 0.1 * j);\n+        } else {\n+          boolean gotIt = false;\n+          try {\n+            l.setElement\n+              (i, j, -1.3);\n+          } catch(ArrayIndexOutOfBoundsException e) {\n+            gotIt = true;\n+          }\n+          assertTrue(gotIt);\n+        }\n+      }\n+    }\n+\n+    checkMatrix(l, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testCopy() {\n+\n+    LowerTriangularMatrix l1 = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);\n+\n+    checkMatrix (l2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDuplicate() {\n+\n+    LowerTriangularMatrix l1 = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    Matrix l2 = l1.duplicate();\n+    assertTrue(l2 instanceof LowerTriangularMatrix);\n+\n+    checkMatrix(l2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testTranspose() {\n+\n+    LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    Matrix transposed = l.getTranspose();\n+    assertTrue(transposed instanceof UpperTriangularMatrix);\n+\n+    for (int i = 0; i < transposed.getRows(); ++i){\n+      for (int j = 0; j < transposed.getColumns(); ++j) {\n+        double expected = (i > j) ? 0.0 : (j + 0.1 * i);\n+        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);\n+      }\n+    }\n+\n+  }\n+\n+  public void testSelfAdd() {\n+    LowerTriangularMatrix l1 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 3 * i - 0.2 * j;\n+        }\n+      });\n+\n+    LowerTriangularMatrix l2 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.4 * j; }\n+      });\n+\n+    l1.selfAdd(l2);\n+\n+    checkMatrix(l1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 5 * i - 0.6 * j;\n+        }\n+      });\n+  }\n+\n+  public void testSelfSub() {\n+    LowerTriangularMatrix l1 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 3 * i - 0.2 * j;\n+        }\n+      });\n+\n+    LowerTriangularMatrix l2 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.4 * j;\n+        }\n+      });\n+\n+    l1.selfSub(l2);\n+\n+    checkMatrix(l1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.2 * j;\n+        }\n+      });\n+  }\n+\n+  public void testDeterminant() {\n+\n+    LowerTriangularMatrix l = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 2.0 : 1.0;\n+        }\n+      });\n+\n+    assertTrue(Math.abs(l.getDeterminant(1.0e-10) - Math.pow(2.0, l.getRows()))\n+               < 1.0e-10);\n+\n+  }\n+\n+  public void testSolve()\n+    throws SingularMatrixException {\n+\n+    LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.0;\n+        }\n+      });\n+\n+    GeneralMatrix b = new GeneralMatrix(l.getRows(), 3);\n+    for (int i = 0; i < b.getRows(); ++i) {\n+      b.setElement(i, 0, i + 1.0);\n+      b.setElement(i, 1, (i + 1.0) * (i + 2.0) / 2.0);\n+      b.setElement(i, 2, 0.0);\n+    }\n+\n+    Matrix result = l.solve(b, 1.0e-10);\n+\n+    assertTrue(result.getRows() == b.getRows());\n+    assertTrue(result.getColumns() == b.getColumns());\n+\n+    for (int i = 0; i < result.getRows(); ++i) {\n+      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);\n+    }\n+\n+    boolean gotIt = false;\n+    try {\n+      l.setElement(3, 3, 0.0);\n+      result = l.solve(b, 1.0e-10);\n+    } catch(SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testInverse()\n+    throws SingularMatrixException {\n+\n+    LowerTriangularMatrix l = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.0;\n+        }\n+      });\n+\n+    Matrix inverse = l.getInverse(1.0e-10);\n+    assertTrue(inverse instanceof LowerTriangularMatrix);\n+\n+    checkMatrix(inverse, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 1.0 : ((i == j + 1) ? -1.0 : 0.0);\n+        }\n+      });\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(LowerTriangularMatrixTest.class);\n+  }\n+\n+  public interface ElementPattern {\n+    public double value(int i, int j);\n+  }\n+\n+  public LowerTriangularMatrix buildMatrix(int order,\n+                                           ElementPattern pattern) {\n+    LowerTriangularMatrix m = new LowerTriangularMatrix(order);\n+\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j <= i; ++j) {\n+        m.setElement(i, j, pattern.value(i, j));\n+      }\n+    }\n+\n+    return m;\n+\n+  }\n+\n+  public void checkMatrix(Matrix m, ElementPattern pattern) {\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j) {\n+        double expected = (j <= i) ? pattern.value(i, j) : 0.0;\n+        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/MatrixFactoryTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class MatrixFactoryTest\n+  extends TestCase {\n+\n+  public MatrixFactoryTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testInvalidDimensions() {\n+    boolean gotIt;\n+\n+    gotIt = false;\n+    try {\n+      MatrixFactory.buildMatrix(0, 2, null, 1, 1);\n+    } catch (IllegalArgumentException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testDiagonal() {\n+    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 0);\n+    assertTrue(m instanceof DiagonalMatrix);\n+  }\n+\n+  public void testLowerTriangular() {\n+    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 0);\n+    assertTrue(m instanceof LowerTriangularMatrix);\n+  }\n+\n+  public void testUpperTriangular() {\n+    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 1);\n+    assertTrue(m instanceof UpperTriangularMatrix);\n+  }\n+\n+  public void testSquare() {\n+    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 1);\n+    assertTrue(m instanceof GeneralSquareMatrix);\n+  }\n+\n+  public void testGeneral() {\n+    Matrix m = MatrixFactory.buildMatrix(3, 4, null, 0, 0);\n+    assertTrue(m instanceof GeneralMatrix);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MatrixFactoryTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/NonNullRangeTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class NonNullRangeTest\n+  extends TestCase {\n+\n+  public NonNullRangeTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testPublicAttributes() {\n+    NonNullRange r = new NonNullRange(2, 7);\n+    assertTrue(r.begin == 2);\n+    assertTrue(r.end   == 7);\n+  }\n+\n+  public void testCopy() {\n+    NonNullRange r1 = new NonNullRange(2, 7);\n+    NonNullRange r2 = new NonNullRange(r1);\n+    assertTrue(r2.begin == r1.begin);\n+    assertTrue(r1.end   == r1.end);\n+  }\n+\n+  public void testIntersection() {\n+    NonNullRange r1 = new NonNullRange(-4, 8);\n+    NonNullRange r2 = new NonNullRange(3, 12);\n+    NonNullRange r3 = NonNullRange.intersection(r1, r2);\n+    assertTrue(r3.begin == 3);\n+    assertTrue(r3.end   == 8);\n+  }\n+\n+  public void testReunion() {\n+    NonNullRange r1 = new NonNullRange(-4, 8);\n+    NonNullRange r2 = new NonNullRange(3, 12);\n+    NonNullRange r3 = NonNullRange.reunion(r1, r2);\n+    assertTrue(r3.begin == -4);\n+    assertTrue(r3.end   == 12);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(NonNullRangeTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/SymetricalMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class SymetricalMatrixTest\n+  extends TestCase {\n+\n+  public SymetricalMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBuildWAAt() {\n+\n+    double[] a = { 1.0, 2.0, 3.0 };\n+    SymetricalMatrix s = new SymetricalMatrix(0.99, a);\n+\n+    checkMatrix(s, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.99 * (i + 1) * (j + 1);\n+        }\n+      });\n+\n+  }\n+\n+  public void testNoSetOutsideOfDiagonal() {\n+\n+    SymetricalMatrix s = new SymetricalMatrix(4);\n+\n+    for (int i = 0; i < s.getRows(); ++i) {\n+      for (int j = 0; j < s.getColumns(); ++j) {\n+        if (i == j) {\n+          s.setElement(i, j, 0.5);\n+        } else {\n+          boolean gotIt = false;\n+          try {\n+            s.setElement\n+              (i, j, -1.3);\n+          } catch(ArrayIndexOutOfBoundsException e) {\n+            gotIt = true;\n+          }\n+          assertTrue(gotIt);\n+        }\n+      }\n+    }\n+\n+    checkMatrix(s, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 0.5 : 0.0;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSetElementAndSymetricalElement() {\n+    SymetricalMatrix s = new SymetricalMatrix(5);\n+    s.setElementAndSymetricalElement(1, 2, 3.4);\n+    assertTrue(Math.abs(s.getElement(1, 2) - 3.4) < 1.0e-10);\n+    assertTrue(Math.abs(s.getElement(2, 1) - 3.4) < 1.0e-10);\n+  }\n+\n+  public void testCopy() {\n+    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i * i + j * j;\n+        }\n+      });\n+\n+    SymetricalMatrix m2 = new SymetricalMatrix(m1);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = i; j < m1.getColumns(); ++j) {\n+        m1.setElementAndSymetricalElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i * i + j * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDuplicate() {\n+    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i * j;\n+        }\n+      });\n+\n+    Matrix m2 = m1.duplicate();\n+    assertTrue(m2 instanceof SymetricalMatrix);\n+\n+    for (int i = 0; i < m1.getRows(); ++i) {\n+      for (int j = i; j < m1.getColumns(); ++j) {\n+        m1.setElementAndSymetricalElement(i, j, -1.0);\n+      }\n+    }\n+\n+    assertTrue(m2.getRows() == m1.getRows());\n+    assertTrue(m2.getColumns() == m1.getColumns());\n+\n+    checkMatrix(m2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testSelfAdd() {\n+    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };\n+    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);\n+\n+    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };\n+    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);\n+\n+    s1.selfAdd(s2);\n+\n+    checkMatrix(s1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)\n+            + Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);\n+        }\n+      });\n+  }\n+\n+  public void testSelfSub() {\n+    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };\n+    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);\n+\n+    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };\n+    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);\n+\n+    s1.selfSub(s2);\n+\n+    checkMatrix(s1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)\n+            - Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);\n+        }\n+      });\n+  }\n+\n+  public void testSelfAddWAAt() {\n+\n+    SymetricalMatrix s = new SymetricalMatrix(3);\n+\n+    double[] a1 = { 1.0, 2.0, 3.0 };\n+    s.selfAddWAAt(1.0, a1);\n+\n+    double[] a2 = { 0.1, 0.2, 0.3 };\n+    s.selfAddWAAt(2.0, a2);\n+\n+    checkMatrix(s, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.02 * (i + 1) * (j + 1);\n+        }\n+      });\n+\n+  }\n+\n+  public void testSingular()\n+    throws SingularMatrixException {\n+    SymetricalMatrix s = new SymetricalMatrix(3);\n+\n+    double[] a1 = { 1.0, 2.0, 3.0 };\n+    s.selfAddWAAt(1.0, a1);\n+\n+    double[] a2 = { 0.1, 0.2, 0.3 };\n+    s.selfAddWAAt(2.0, a2);\n+\n+    Matrix b = new GeneralMatrix(3, 1);\n+    b.setElement(0, 0,  6.12);\n+    b.setElement(1, 0, 12.24);\n+    b.setElement(2, 0, 18.36);\n+\n+    boolean gotIt = false;\n+    try {\n+      s.solve(b, 1.0e-10);\n+    } catch(SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testSolve()\n+    throws SingularMatrixException {\n+    SymetricalMatrix s = new SymetricalMatrix(3);\n+\n+    double[] a1 = { 1.0, 2.0, 3.0 };\n+    s.selfAddWAAt(1.0, a1);\n+\n+    double[] a2 = { 0.1, 0.2, 0.3 };\n+    s.selfAddWAAt(2.0, a2);\n+\n+    double[] a3 = { 1.2, -3.0, 2.1 };\n+    s.selfAddWAAt(3.0, a3);\n+\n+    double[] a4 = { 0.4, 0.1, 3.1 };\n+    s.selfAddWAAt(2.0, a4);\n+\n+    Matrix b = new GeneralMatrix(3, 1);\n+    b.setElement(0, 0, 10.08);\n+    b.setElement(1, 0, 10.26);\n+    b.setElement(2, 0, 42.57);\n+\n+    Matrix x = s.solve(b, 1.0e-10);\n+\n+    checkMatrix (x, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.0;\n+        }\n+      });\n+\n+    assertTrue(Math.abs(s.getDeterminant(1.0e-10) - 782.846532) < 1.0e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(SymetricalMatrixTest.class);\n+  }\n+\n+  public interface ElementPattern {\n+    public double value(int i, int j);\n+  }\n+\n+  public SymetricalMatrix buildMatrix(int order,\n+                                      ElementPattern pattern) {\n+    SymetricalMatrix m = new SymetricalMatrix(order);\n+\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = i; j < m.getColumns(); ++j) {\n+        m.setElementAndSymetricalElement(i, j, pattern.value(i, j));\n+      }\n+    }\n+\n+    return m;\n+\n+  }\n+\n+  public void checkMatrix(Matrix m, ElementPattern pattern) {\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j) {\n+        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))\n+                   < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/UpperTriangularMatrixTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.linalg;\n+\n+import junit.framework.*;\n+\n+public class UpperTriangularMatrixTest\n+  extends TestCase {\n+\n+  public UpperTriangularMatrixTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoSetOutsideOfUpperTriangle() {\n+\n+    UpperTriangularMatrix u = new UpperTriangularMatrix(4);\n+\n+    for (int i = 0; i < u.getRows(); ++i) {\n+      for (int j = 0; j < u.getColumns(); ++j) {\n+        if (i <= j) {\n+          u.setElement(i, j, i + 0.1 * j);\n+        } else {\n+          boolean gotIt = false;\n+          try {\n+            u.setElement(i, j, -1.3);\n+          } catch(ArrayIndexOutOfBoundsException e) {\n+            gotIt = true;\n+          }\n+          assertTrue(gotIt);\n+        }\n+      }\n+    }\n+\n+    checkMatrix(u, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testCopy() {\n+\n+    UpperTriangularMatrix u1 = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);\n+\n+    checkMatrix(u2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testDuplicate() {\n+\n+    UpperTriangularMatrix u1 = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    Matrix u2 = u1.duplicate();\n+    assertTrue(u2 instanceof UpperTriangularMatrix);\n+\n+    checkMatrix(u2, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+  }\n+\n+  public void testTranspose() {\n+\n+    UpperTriangularMatrix u = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.1 * j;\n+        }\n+      });\n+\n+    Matrix transposed = u.getTranspose();\n+    assertTrue(transposed instanceof LowerTriangularMatrix);\n+\n+    for (int i = 0; i < transposed.getRows(); ++i){\n+      for (int j = 0; j < transposed.getColumns(); ++j) {\n+        double expected = (i < j) ? 0.0 : (j + 0.1 * i);\n+        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);\n+      }\n+    }\n+\n+  }\n+\n+  public void testSelfAdd() {\n+    UpperTriangularMatrix u1 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 3 * i - 0.2 * j;\n+        }\n+      });\n+\n+    UpperTriangularMatrix u2 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.4 * j;\n+        }\n+      });\n+\n+    u1.selfAdd(u2);\n+\n+    checkMatrix(u1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 5 * i - 0.6 * j;\n+        }\n+      });\n+  }\n+\n+  public void testSelfSub() {\n+    UpperTriangularMatrix u1 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 3 * i - 0.2 * j;\n+        }\n+      });\n+\n+    UpperTriangularMatrix u2 = buildMatrix(7, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 2 * i - 0.4 * j;\n+        }\n+      });\n+\n+    u1.selfSub(u2);\n+\n+    checkMatrix(u1, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return i + 0.2 * j;\n+        }\n+      });\n+  }\n+\n+  public void testDeterminant() {\n+\n+    UpperTriangularMatrix u = buildMatrix(4, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 2.0 : 1.0;\n+        }\n+      });\n+\n+    assertTrue(Math.abs(u.getDeterminant(1.0e-10) - Math.pow(2.0, u.getRows()))\n+               < 1.0e-10);\n+\n+  }\n+\n+  public void testSolve()\n+    throws SingularMatrixException {\n+\n+    int rows = 7;\n+    UpperTriangularMatrix u = buildMatrix(rows, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.0;\n+        }\n+      });\n+\n+    GeneralMatrix b = new GeneralMatrix(rows, 3);\n+    for (int i = 0; i < rows; ++i) {\n+      b.setElement(i, 0, rows - i);\n+      b.setElement(i, 1, (rows - i) * (rows + 1 - i) / 2.0);\n+      b.setElement(i, 2, 0.0);\n+    }\n+\n+    Matrix result = u.solve(b, 1.0e-10);\n+\n+    assertTrue(result.getRows() == b.getRows());\n+    assertTrue(result.getColumns() == b.getColumns());\n+\n+    for (int i = 0; i < result.getRows(); ++i) {\n+      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)        < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 1) - (rows - i)) < 1.0e-10);\n+      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)        < 1.0e-10);\n+    }\n+\n+    boolean gotIt = false;\n+    try {\n+      u.setElement(3, 3, 0.0);\n+      result = u.solve(b, 1.0e-10);\n+    } catch(SingularMatrixException e) {\n+      gotIt = true;\n+    }\n+    assertTrue(gotIt);\n+\n+  }\n+\n+  public void testInverse()\n+    throws SingularMatrixException {\n+\n+    UpperTriangularMatrix u = buildMatrix(5, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return 1.0;\n+        }\n+      });\n+\n+    Matrix inverse = u.getInverse(1.0e-10);\n+    assertTrue(inverse instanceof UpperTriangularMatrix);\n+\n+    checkMatrix(inverse, new ElementPattern() {\n+        public double value(int i, int j) {\n+          return (i == j) ? 1.0 : ((i == j - 1) ? -1.0 : 0.0);\n+        }\n+      });\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(UpperTriangularMatrixTest.class);\n+  }\n+\n+  public interface ElementPattern {\n+    public double value(int i, int j);\n+  }\n+\n+  public UpperTriangularMatrix buildMatrix(int order,\n+                                           ElementPattern pattern) {\n+    UpperTriangularMatrix m = new UpperTriangularMatrix (order);\n+\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = i; j < m.getColumns(); ++j) {\n+        m.setElement(i, j, pattern.value(i, j));\n+      }\n+    }\n+\n+    return m;\n+\n+  }\n+\n+  public void checkMatrix(Matrix m, ElementPattern pattern) {\n+    for (int i = 0; i < m.getRows(); ++i) {\n+      for (int j = 0; j < m.getColumns(); ++j) {\n+        double expected = (i <= j) ? pattern.value(i, j) : 0.0;\n+        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.ode\"); \n+\n+    suite.addTest(EulerStepInterpolatorTest.suite());\n+    suite.addTest(EulerIntegratorTest.suite());\n+    suite.addTest(MidpointIntegratorTest.suite());\n+    suite.addTest(ClassicalRungeKuttaIntegratorTest.suite());\n+    suite.addTest(GillIntegratorTest.suite());\n+    suite.addTest(ThreeEighthesIntegratorTest.suite());\n+    suite.addTest(HighamHall54IntegratorTest.suite());\n+    suite.addTest(DormandPrince54IntegratorTest.suite());\n+    suite.addTest(DormandPrince853IntegratorTest.suite());\n+    suite.addTest(GraggBulirschStoerIntegratorTest.suite());\n+    suite.addTest(FirstOrderConverterTest.suite());\n+    suite.addTest(StepNormalizerTest.suite());\n+    suite.addTest(ContinuousOutputModelTest.suite());\n+    suite.addTest(ClassicalRungeKuttaStepInterpolatorTest.suite());\n+    suite.addTest(GillStepInterpolatorTest.suite());\n+    suite.addTest(ThreeEighthesStepInterpolatorTest.suite());\n+    suite.addTest(DormandPrince853StepInterpolatorTest.suite());\n+    suite.addTest(DormandPrince54StepInterpolatorTest.suite());\n+    suite.addTest(HighamHall54StepInterpolatorTest.suite());\n+    suite.addTest(MidpointStepInterpolatorTest.suite());\n+    suite.addTest(GraggBulirschStoerStepInterpolatorTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.fitting.PolynomialFitter;\n+\n+public class ClassicalRungeKuttaIntegratorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()],\n+                                                        0.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testOrder()\n+  throws EstimationException, DerivativeException,\n+         IntegratorException {\n+    PolynomialFitter fitter = new PolynomialFitter(1,\n+                                                   10, 1.0e-7, 1.0e-10,\n+                                                   1.0e-10);\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      for (int i = 0; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -(i + 1));\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        fitter.addWeightedPair(1.0,\n+                               Math.log(Math.abs(step)),\n+                               Math.log(handler.getLastError()));\n+\n+      }\n+\n+      // this is an order 4 method\n+      double[] coeffs = fitter.fit();\n+      assertTrue(coeffs[1] > 3.2);\n+      assertTrue(coeffs[1] < 4.8);\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new StepHandler() {\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double[] interpolatedY = interpolator.getInterpolatedState ();\n+                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+                        double dx = interpolatedY[0] - theoreticalY[0];\n+                        double dy = interpolatedY[1] - theoreticalY[1];\n+                        double error = dx * dx + dy * dy;\n+                        if (error > maxError) {\n+                          maxError = error;\n+                        }\n+                        if (isLast) {\n+                          // even with more than 1000 evaluations per period,\n+                          // RK4 is not able to integrate such an eccentric\n+                          // orbit with a good accuracy\n+                          assertTrue(maxError > 0.005);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class ClassicalRungeKuttaStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ContinuousOutputModelTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+\n+public class ContinuousOutputModelTest\n+  extends TestCase {\n+\n+  public ContinuousOutputModelTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();\n+    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());\n+    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());\n+    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n+  }\n+\n+  public void testRandomAccess()\n+    throws DerivativeException, IntegratorException {\n+\n+    ContinuousOutputModel cm = new ContinuousOutputModel();\n+    integ.setStepHandler(cm);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-9);\n+\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ContinuousOutputModelTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince54IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince54IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n+                                                                           1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testSmallLastStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract pb = new TestProblem5();\n+    double minStep = 1.25;\n+    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double scalAbsoluteTolerance = 6.0e-4;\n+    double scalRelativeTolerance = 6.0e-4;\n+\n+    AdaptiveStepsizeIntegrator integ =\n+      new DormandPrince54Integrator(minStep, maxStep,\n+                                    scalAbsoluteTolerance,\n+                                    scalRelativeTolerance);\n+\n+    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n+    integ.setStepHandler(handler);\n+    integ.setInitialStepSize(1.7);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(handler.wasLastSeen());\n+\n+  }\n+\n+  private class DP54SmallLastHandler implements StepHandler {\n+\n+    public DP54SmallLastHandler(double minStep) {\n+      lastSeen = false;\n+      this.minStep = minStep;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+      if (isLast) {\n+        lastSeen = true;\n+        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n+        assertTrue(Math.abs(h) < minStep);\n+      }\n+    }\n+\n+    public boolean wasLastSeen() {\n+      return lastSeen;\n+    }\n+\n+    private boolean lastSeen;\n+    private double  minStep;\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 0.7 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    if (functions != null) {\n+      for (int l = 0; l < functions.length; ++l) {\n+        integ.addSwitchingFunction(functions[l],\n+                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+      }\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-6);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private int nbSteps = 0;\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return true;\n+                      }\n+                      public void reset() {\n+                        nbSteps = 0;\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast)\n+                        throws DerivativeException {\n+\n+                        ++nbSteps;\n+                        for (int a = 1; a < 10; ++a) {\n+\n+                          double prev   = interpolator.getPreviousTime();\n+                          double curr   = interpolator.getCurrentTime();\n+                          double interp = ((10 - a) * prev + a * curr) / 10;\n+                          interpolator.setInterpolatedTime(interp);\n+\n+                          double[] interpolatedY = interpolator.getInterpolatedState ();\n+                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+                          double dx = interpolatedY[0] - theoreticalY[0];\n+                          double dy = interpolatedY[1] - theoreticalY[1];\n+                          double error = dx * dx + dy * dy;\n+                          if (error > maxError) {\n+                            maxError = error;\n+                          }\n+                        }\n+                        if (isLast) {\n+                          assertTrue(maxError < 7.0e-10);\n+                          assertTrue(nbSteps < 400);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private boolean firstTime = true;\n+                      private double  minStep = 0;\n+                      private double  maxStep = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        firstTime = true;\n+                        minStep = 0;\n+                        maxStep = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double step = Math.abs(interpolator.getCurrentTime()\n+                                               - interpolator.getPreviousTime());\n+                        if (firstTime) {\n+                          minStep   = Math.abs(step);\n+                          maxStep   = minStep;\n+                          firstTime = false;\n+                        } else {\n+                          if (step < minStep) {\n+                            minStep = step;\n+                          }\n+                          if (step > maxStep) {\n+                            maxStep = step;\n+                          }\n+                        }\n+\n+                        if (isLast) {\n+                          assertTrue(minStep < (1.0 / 450.0));\n+                          assertTrue(maxStep > (1.0 / 4.2));\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince54StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class DormandPrince54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 119500);\n+    assertTrue(bos.size () < 120500);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 7.0e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince853IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince853IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-9;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    if (functions != null) {\n+      for (int l = 0; l < functions.length; ++l) {\n+        integ.addSwitchingFunction(functions[l],\n+                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+      }\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private int nbSteps = 0;\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return true;\n+                      }\n+                      public void reset() {\n+                        nbSteps = 0;\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast)\n+                        throws DerivativeException {\n+\n+                        ++nbSteps;\n+                        for (int a = 1; a < 10; ++a) {\n+\n+                          double prev   = interpolator.getPreviousTime();\n+                          double curr   = interpolator.getCurrentTime();\n+                          double interp = ((10 - a) * prev + a * curr) / 10;\n+                          interpolator.setInterpolatedTime(interp);\n+\n+                          double[] interpolatedY = interpolator.getInterpolatedState ();\n+                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+                          double dx = interpolatedY[0] - theoreticalY[0];\n+                          double dy = interpolatedY[1] - theoreticalY[1];\n+                          double error = dx * dx + dy * dy;\n+                          if (error > maxError) {\n+                            maxError = error;\n+                          }\n+                        }\n+                        if (isLast) {\n+                          assertTrue(maxError < 2.4e-10);\n+                          assertTrue(nbSteps < 150);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2900);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private boolean firstTime = true;\n+                      private double  minStep = 0;\n+                      private double  maxStep = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        firstTime = true;\n+                        minStep = 0;\n+                        maxStep = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double step = Math.abs(interpolator.getCurrentTime()\n+                                               - interpolator.getPreviousTime());\n+                        if (firstTime) {\n+                          minStep   = Math.abs(step);\n+                          maxStep   = minStep;\n+                          firstTime = false;\n+                        } else {\n+                          if (step < minStep) {\n+                            minStep = step;\n+                          }\n+                          if (step > maxStep) {\n+                            maxStep = step;\n+                          }\n+                        }\n+\n+                        if (isLast) {\n+                          assertTrue(minStep < (1.0 / 100.0));\n+                          assertTrue(maxStep > (1.0 / 2.0));\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testNoDenseOutput()\n+    throws DerivativeException, IntegratorException {\n+    TestProblem1 pb1 = new TestProblem1();\n+    TestProblem1 pb2 = (TestProblem1) pb1.clone();\n+    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n+    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-4;\n+    double scalRelativeTolerance = 1.0e-4;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+                      }\n+      });\n+    integ.integrate(pb1,\n+                    pb1.getInitialTime(), pb1.getInitialState(),\n+                    pb1.getFinalTime(), new double[pb1.getDimension()]);\n+    int callsWithoutDenseOutput = pb1.getCalls();\n+\n+    integ.setStepHandler(new StepHandler() {\n+                      public boolean requiresDenseOutput() {\n+                        return true;\n+                      }\n+                      public void reset() {\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast)\n+                        throws DerivativeException {\n+                        double prev = interpolator.getPreviousTime();\n+                        double curr = interpolator.getCurrentTime();\n+                        interpolator.setInterpolatedTime(0.5*(prev + curr));\n+                      }\n+      });\n+    integ.integrate(pb2,\n+                    pb2.getInitialTime(), pb2.getInitialState(),\n+                    pb2.getFinalTime(), new double[pb2.getDimension()]);\n+    int callsWithDenseOutput = pb2.getCalls();\n+\n+    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class DormandPrince853StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince853StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 86000);\n+    assertTrue(bos.size () < 87000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 2.4e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.fitting.PolynomialFitter;\n+\n+public class EulerIntegratorTest\n+  extends TestCase {\n+\n+  public EulerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new EulerIntegrator(0.01).integrate(pb,\n+                                          0.0, new double[pb.getDimension()+10],\n+                                          1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      \n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testOrder()\n+  throws EstimationException, DerivativeException,\n+         IntegratorException {\n+    PolynomialFitter fitter = new PolynomialFitter(1,\n+                                                   10, 1.0e-7, 1.0e-10,\n+                                                   1.0e-10);\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      for (int i = 0; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step  = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -(i + 1));\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        fitter.addWeightedPair(1.0,\n+                               Math.log(Math.abs(step)),\n+                               Math.log(handler.getLastError()));\n+\n+      }\n+\n+      // this is an order 1 method\n+      double[] coeffs = fitter.fit();\n+      assertTrue(coeffs[1] > 0.2);\n+      assertTrue(coeffs[1] < 1.8);\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-4);\n+   assertTrue(handler.getMaximalError() < 1.0e-3);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalError() > 0.2);\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(EulerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class EulerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public EulerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationAtBounds()\n+    throws DerivativeException {\n+\n+    double   t0 = 0;\n+    double[] y0 = {0.0, 1.0, -2.0};\n+\n+    double[] y = new double[y0.length];\n+    System.arraycopy(y0, 0, y, 0, y0.length);\n+    double[][] yDot = { new double[y0.length] };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(t0);\n+\n+    double dt = 1.0;\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n+    yDot[0][0] = (y[0] - y0[0]) / dt;\n+    yDot[0][1] = (y[1] - y0[1]) / dt;\n+    yDot[0][2] = (y[2] - y0[2]) / dt;\n+    interpolator.shift();\n+    interpolator.storeTime(t0 + dt);\n+\n+    interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationInside()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 82000);\n+    assertTrue(bos.size () < 83000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.001);\n+\n+  }\n+\n+  private class DummyEquations\n+    implements FirstOrderDifferentialEquations {\n+    public int getDimension() {\n+      return 0;\n+    }\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/FirstOrderConverterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class FirstOrderConverterTest\n+  extends TestCase {\n+\n+  public FirstOrderConverterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDoubleDimension() {\n+    for (int i = 1; i < 10; ++i) {\n+      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);\n+      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);\n+      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+      \n+    double previousError = Double.NaN;\n+    for (int i = 0; i < 10; ++i) {\n+\n+      double step  = Math.pow(2.0, -(i + 1));\n+      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)\n+                   - Math.sin(4.0);\n+      if (i > 0) {\n+        assertTrue(Math.abs(error) < Math.abs(previousError));\n+      }\n+      previousError = error;\n+      \n+    }\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) < 1.0e-10);\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) > 0.1);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(FirstOrderConverterTest.class);\n+  }\n+\n+  private class Equations\n+    implements SecondOrderDifferentialEquations {\n+      \n+      private int n;\n+\n+      private double omega2;\n+      \n+      public Equations(int n, double omega) {\n+        this.n = n;\n+        omega2 = omega * omega;\n+      }\n+      \n+      public int getDimension() {\n+        return n;\n+      }\n+      \n+      public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                           double[] yDDot) {\n+        for (int i = 0; i < n; ++i) {\n+          yDDot[i] = -omega2 * y[i];\n+        }\n+    }\n+      \n+  }\n+\n+  private double integrateWithSpecifiedStep(double omega,\n+                                            double t0, double t,\n+                                            double step)\n+  throws DerivativeException, IntegratorException {\n+    double[] y0 = new double[2];\n+    y0[0] = Math.sin(omega * t0);\n+    y0[1] = omega * Math.cos(omega * t0);\n+    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);\n+    double[] y = new double[2];\n+    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);\n+    return y[0];\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.fitting.PolynomialFitter;\n+\n+public class GillIntegratorTest\n+  extends TestCase {\n+\n+  public GillIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new GillIntegrator(0.01).integrate(pb,\n+                                         0.0, new double[pb.getDimension()+10],\n+                                         1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 5; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 5) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testOrder()\n+  throws EstimationException, DerivativeException,\n+         IntegratorException {\n+    PolynomialFitter fitter = new PolynomialFitter(1,\n+                                                   10, 1.0e-7, 1.0e-10,\n+                                                   1.0e-10);\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      for (int i = 0; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -(i + 1));\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        fitter.addWeightedPair(1.0,\n+                               Math.log(Math.abs(step)),\n+                               Math.log(handler.getLastError()));\n+\n+      }\n+\n+      // this is an order 4 method\n+      double[] coeffs = fitter.fit();\n+      assertTrue(coeffs[1] > 3.2);\n+      assertTrue(coeffs[1] < 4.8);\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new StepHandler() {\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double[] interpolatedY = interpolator.getInterpolatedState ();\n+                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+                        double dx = interpolatedY[0] - theoreticalY[0];\n+                        double dy = interpolatedY[1] - theoreticalY[1];\n+                        double error = dx * dx + dy * dy;\n+                        if (error > maxError) {\n+                          maxError = error;\n+                        }\n+                        if (isLast) {\n+                          // even with more than 1000 evaluations per period,\n+                          // RK4 is not able to integrate such an eccentric\n+                          // orbit with a good accuracy\n+                          assertTrue(maxError > 0.001);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class GillStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GillStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.003);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class GraggBulirschStoerIntegratorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb  = new TestProblem1();\n+      double minStep   = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = 1.0e-20;\n+      double relTolerance = 1.0e-20;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -4; ++i) {\n+      TestProblem1 pb     = new TestProblem1();\n+      double minStep      = 0;\n+      double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = Math.pow(10.0, i);\n+      double relTolerance = absTolerance;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the coefficients are only valid for this test\n+      // and have been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      double ratio =  handler.getMaximalError() / absTolerance;\n+      assertTrue(ratio < 2.4);\n+      assertTrue(ratio > 0.02);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-10;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    if (functions != null) {\n+      for (int l = 0; l < functions.length; ++l) {\n+        integ.addSwitchingFunction(functions[l],\n+                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+      }\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-6;\n+    double relTolerance   = 1.0e-6;\n+\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private int nbSteps = 0;\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return true;\n+                      }\n+                      public void reset() {\n+                        nbSteps = 0;\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast)\n+                        throws DerivativeException {\n+\n+                        ++nbSteps;\n+                        for (int a = 1; a < 100; ++a) {\n+\n+                          double prev   = interpolator.getPreviousTime();\n+                          double curr   = interpolator.getCurrentTime();\n+                          double interp = ((100 - a) * prev + a * curr) / 100;\n+                          interpolator.setInterpolatedTime(interp);\n+\n+                          double[] interpolatedY = interpolator.getInterpolatedState ();\n+                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+                          double dx = interpolatedY[0] - theoreticalY[0];\n+                          double dy = interpolatedY[1] - theoreticalY[1];\n+                          double error = dx * dx + dy * dy;\n+                          if (error > maxError) {\n+                            maxError = error;\n+                          }\n+                        }\n+                        if (isLast) {\n+                          assertTrue(maxError < 2.7e-6);\n+                          assertTrue(nbSteps < 80);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-8;\n+    double relTolerance   = 1.0e-8;\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private boolean firstTime = true;\n+                      private double  minStep = 0;\n+                      private double  maxStep = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        firstTime = true;\n+                        minStep = 0;\n+                        maxStep = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double step = Math.abs(interpolator.getCurrentTime()\n+                                               - interpolator.getPreviousTime());\n+                        if (firstTime) {\n+                          minStep   = Math.abs(step);\n+                          maxStep   = minStep;\n+                          firstTime = false;\n+                        } else {\n+                          if (step < minStep) {\n+                            minStep = step;\n+                          }\n+                          if (step > maxStep) {\n+                            maxStep = step;\n+                          }\n+                        }\n+\n+                        if (isLast) {\n+                          assertTrue(minStep < 8.2e-3);\n+                          assertTrue(maxStep > 1.7);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class GraggBulirschStoerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 5.0e-11);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/HighamHall54IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class HighamHall54IntegratorTest\n+  extends TestCase {\n+\n+  public HighamHall54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0,\n+                                                                     1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    if (functions != null) {\n+      for (int l = 0; l < functions.length; ++l) {\n+        integ.addSwitchingFunction(functions[l],\n+                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+      }\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 1.0e-7);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+                      private int nbSteps = 0;\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        nbSteps = 0;\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        ++nbSteps;\n+                        double[] interpolatedY = interpolator.getInterpolatedState ();\n+                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+                        double dx = interpolatedY[0] - theoreticalY[0];\n+                        double dy = interpolatedY[1] - theoreticalY[1];\n+                        double error = dx * dx + dy * dy;\n+                        if (error > maxError) {\n+                          maxError = error;\n+                        }\n+                        if (isLast) {\n+                          assertTrue(maxError < 1.54e-10);\n+                          assertTrue(nbSteps < 520);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/HighamHall54StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class HighamHall54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public HighamHall54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 158000);\n+    assertTrue(bos.size () < 159000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.6e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/MidpointIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.fitting.PolynomialFitter;\n+\n+public class MidpointIntegratorTest\n+  extends TestCase {\n+\n+  public MidpointIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new MidpointIntegrator(0.01).integrate(pb,\n+                                             0.0, new double[pb.getDimension()+10],\n+                                             1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testOrder()\n+  throws EstimationException, DerivativeException, IntegratorException {\n+    PolynomialFitter fitter = new PolynomialFitter(1,\n+                                                   10, 1.0e-7, 1.0e-10,\n+                                                   1.0e-10);\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      for (int i = 0; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step  = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -(i + 1));\n+\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        fitter.addWeightedPair(1.0,\n+                               Math.log(Math.abs(step)),\n+                               Math.log(handler.getLastError()));\n+\n+      }\n+\n+      // this is an order 2 method\n+      double[] coeffs = fitter.fit();\n+      assertTrue(coeffs[1] > 1.2);\n+      assertTrue(coeffs[1] < 2.8);\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-7);\n+    assertTrue(handler.getMaximalError() < 1.0e-6);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalError() > 0.05);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/MidpointStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class MidpointStepInterpolatorTest\n+  extends TestCase {\n+\n+  public MidpointStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 98000);\n+    assertTrue(bos.size () < 99000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-6);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/StepNormalizerTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+public class StepNormalizerTest\n+  extends TestCase {\n+\n+  public StepNormalizerTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.0,\n+                                       new FixedStepHandler() {\n+                                         private boolean firstCall = true;\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (firstCall) {\n+                                             checkValue(t, pb.getInitialTime());\n+                                             firstCall = false;\n+                                           }\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t, pb.getFinalTime());\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void testBeforeEnd()\n+    throws DerivativeException, IntegratorException {\n+    final double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.5,\n+                                       new FixedStepHandler() {\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t,\n+                                                        pb.getFinalTime() - range / 21.0);\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public void setLastSeen(boolean lastSeen) {\n+    this.lastSeen = lastSeen;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(StepNormalizerTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);\n+    lastSeen = false;\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+  boolean lastSeen;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem1.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = -y\n+ * </pre>\n+ * the solution of this equation is a simple exponential function :\n+ * <pre>\n+ *   y (t) = y (t0) exp (t0-t)\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem1\n+  extends TestProblemAbstract {\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem1() {\n+    super();\n+    double[] y0 = { 1.0, 0.1 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(4.0);\n+    double[] errorScale = { 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem1(TestProblem1 problem) {\n+    super(problem);\n+    y = new double[problem.y.length];\n+    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem1(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = -y[i];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double c = Math.exp (t0 - t);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c * y0[i];\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem2.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = t^3 - t y\n+ * </pre>\n+ * with the initial condition y (0) = 0. The solution of this equation\n+ * is the following function :\n+ * <pre>\n+ *   y (t) = t^2 + 2 (ext (- t^2 / 2) - 1)\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem2\n+  extends TestProblemAbstract {\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem2() {\n+    super();\n+    double[] y0 = { 0.0 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(1.0);\n+    double[] errorScale = { 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem2(TestProblem2 problem) {\n+    super(problem);\n+    y = new double[problem.y.length];\n+    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem2(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = t * (t * t - y[i]);\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double t2 = t * t;\n+    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c;\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem3.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0\n+ *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))\n+ *    r = sqrt (y1^2 + y2^2), e = 0.9\n+ * </pre>\n+ * This is a two-body problem in the plane which can be solved by\n+ * Kepler's equation\n+ * <pre>\n+ *   y1 (t) = ...\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem3\n+  extends TestProblemAbstract {\n+\n+  /** Eccentricity */\n+  double e;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   * @param e eccentricity\n+   */\n+  public TestProblem3(double e) {\n+    super();\n+    this.e = e;\n+    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(20.0);\n+    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem3() {\n+    this(0.1);\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem3(TestProblem3 problem) {\n+    super(problem);\n+    e = problem.e;\n+    y = new double[problem.y.length];\n+    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem3(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // current radius\n+    double r2 = y[0] * y[0] + y[1] * y[1];\n+    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+\n+    // compute the derivatives\n+    yDot[0] = y[2];\n+    yDot[1] = y[3];\n+    yDot[2] = -invR3  * y[0];\n+    yDot[3] = -invR3  * y[1];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+\n+    // solve Kepler's equation\n+    double E = t;\n+    double d = 0;\n+    double corr = 0;\n+    do {\n+      double f2  = e * Math.sin(E);\n+      double f0  = d - f2;\n+      double f1  = 1 - e * Math.cos(E);\n+      double f12 = f1 + f1;\n+      corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n+      d -= corr;\n+      E = t + d;\n+    } while (Math.abs(corr) > 1.0e-12);\n+\n+    double cosE = Math.cos(E);\n+    double sinE = Math.sin(E);\n+\n+    y[0] = cosE - e;\n+    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[2] = -sinE / (1 - e * cosE);\n+    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem4.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    x'' = -x\n+ * </pre>\n+ * And when x decreases down to 0, the state should be changed as follows :\n+ * <pre>\n+ *   x' -> -x'\n+ * </pre>\n+ * The theoretical solution of this problem is x = |sin(t+a)|\n+ * </p>\n+\n+ */\n+class TestProblem4\n+  extends TestProblemAbstract {\n+\n+  /** Time offset. */\n+  private double a;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /** Simple constructor. */\n+  public TestProblem4() {\n+    super();\n+    a = 1.2;\n+    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(15);\n+    double[] errorScale = { 1.0, 0.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem4(TestProblem4 problem) {\n+    super(problem);\n+    a = problem.a;\n+    y = new double[problem.y.length];\n+    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem4(this);\n+  }\n+\n+  public SwitchingFunction[] getSwitchingFunctions() {\n+    return new SwitchingFunction[] { new Bounce(), new Stop() };\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] =  y[1];\n+    yDot[1] = -y[0];\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double sin = Math.sin(t + a);\n+    double cos = Math.cos(t + a);\n+    y[0] = Math.abs(sin);\n+    y[1] = (sin >= 0) ? cos : -cos;\n+    return y;\n+  }\n+\n+  private static class Bounce implements SwitchingFunction {\n+\n+    private int sign;\n+\n+    public Bounce() {\n+      sign = +1;\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return sign * y[0];\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      // this sign change is needed because the state will be reset soon\n+      sign = -sign;\n+      return SwitchingFunction.RESET;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+      y[1] = -y[1];\n+    }\n+\n+  }\n+\n+  private static class Stop implements SwitchingFunction {\n+\n+    public Stop() {\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return t - 12.0;\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      return SwitchingFunction.STOP;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem5.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ * <p>This is the same as problem 1 except integration is done\n+ * backward in time</p>\n+ */\n+class TestProblem5\n+  extends TestProblem1 {\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem5() {\n+    super();\n+    setFinalConditions(2 * t0 - t1);\n+  }\n+ \n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblemAbstract.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used as the base class of the problems that are\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+abstract class TestProblemAbstract\n+  implements FirstOrderDifferentialEquations, Cloneable {\n+\n+  /** Dimension of the problem. */\n+  protected int n;\n+\n+  /** Number of functions calls. */\n+  protected int calls;\n+\n+  /** Initial time */\n+  protected double t0;\n+\n+  /** Initial state */\n+  protected double[] y0;\n+\n+  /** Final time */\n+  protected double t1;\n+\n+  /** Error scale */\n+  protected double[] errorScale;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  protected TestProblemAbstract() {\n+    n          = 0;\n+    calls      = 0;\n+    t0         = 0;\n+    y0         = null;\n+    t1         = 0;\n+    errorScale = null;\n+  }\n+\n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  protected TestProblemAbstract(TestProblemAbstract problem) {\n+    n     = problem.n;\n+    calls = problem.calls;\n+    t0    = problem.t0;\n+    if (problem.y0 == null) {\n+      y0 = null;\n+    } else {\n+      y0 = new double[problem.y0.length];\n+      System.arraycopy(problem.y0, 0, y0, 0, problem.y0.length);\n+    }\n+    if (problem.errorScale == null) {\n+      errorScale = null;\n+    } else {\n+      errorScale = new double[problem.errorScale.length];\n+      System.arraycopy(problem.errorScale, 0, errorScale, 0,\n+                       problem.errorScale.length);\n+    }\n+    t1 = problem.t1;\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public abstract Object clone();\n+\n+  /**\n+   * Set the initial conditions\n+   * @param t0 initial time\n+   * @param y0 initial state vector\n+   */\n+  protected void setInitialConditions(double t0, double[] y0) {\n+    calls     = 0;\n+    n         = y0.length;\n+    this.t0   = t0;\n+    this.y0   = new double[y0.length];\n+    System.arraycopy(y0, 0, this.y0, 0, y0.length); \n+   }\n+\n+  /**\n+   * Set the final conditions.\n+   * @param t1 final time\n+   */\n+  protected void setFinalConditions(double t1) {\n+    this.t1 = t1;\n+  }\n+\n+  /**\n+   * Set the error scale\n+   * @param errorScale error scale\n+   */\n+  protected void setErrorScale(double[] errorScale) {\n+    this.errorScale = new double[errorScale.length];\n+    System.arraycopy(errorScale, 0, this.errorScale, 0,\n+                     errorScale.length); \n+  }\n+\n+  public int getDimension() {\n+    return n;\n+  }\n+\n+  /**\n+   * Get the initial time.\n+   * @return initial time\n+   */\n+  public double getInitialTime() {\n+    return t0;\n+  }\n+\n+  /**\n+   * Get the initial state vector.\n+   * @return initial state vector\n+   */\n+  public double[] getInitialState() {\n+    return y0;\n+  }\n+\n+  /**\n+   * Get the final time.\n+   * @return final time\n+   */\n+  public double getFinalTime() {\n+    return t1;\n+  }\n+\n+  /**\n+   * Get the error scale.\n+   * @return error scale\n+   */\n+  public double[] getErrorScale() {\n+    return errorScale;\n+  }\n+\n+  /**\n+   * Get the switching functions.\n+   * @return switching functions\n+   */\n+  public SwitchingFunction[] getSwitchingFunctions() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the number of calls.\n+   * @return nuber of calls\n+   */\n+  public int getCalls() {\n+    return calls;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    ++calls;\n+    doComputeDerivatives(t, y, yDot);\n+  }\n+\n+  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);\n+\n+  /**\n+   * Compute the theoretical state at the specified time.\n+   * @param t time at which the state is required\n+   * @return state vector at time t\n+   */\n+  abstract public double[] computeTheoreticalState(double t);\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblemFactory.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ */\n+class TestProblemFactory {\n+\n+  /** Problems pool. */\n+  private static TestProblemAbstract[] pool = {\n+    new TestProblem1(),\n+    new TestProblem2(),\n+    new TestProblem3(),\n+    new TestProblem4(),\n+    new TestProblem5()\n+  };\n+\n+  /**\n+   * Private constructor.\n+   * This is a utility class, so there are no instance at all.\n+   */\n+  private TestProblemFactory() {\n+  }\n+\n+  /**\n+   * Get the problems.\n+   * @return array of problems to solve\n+   */\n+  public static TestProblemAbstract[] getProblems() {\n+    return pool;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblemHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+/**\n+ * This class is used to handle steps for the test problems\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+class TestProblemHandler\n+  implements StepHandler {\n+\n+  /** Associated problem. */\n+  private TestProblemAbstract problem;\n+\n+  /** Maximal error encountered during the integration. */\n+  private double maxError;\n+\n+  /** Error at the end of the integration. */\n+  private double lastError;\n+\n+  /** Time at the end of integration. */\n+  private double lastTime;\n+\n+  /**\n+   * Simple constructor.\n+   * @param problem problem for which steps should be handled\n+   */\n+  public TestProblemHandler(TestProblemAbstract problem) {\n+    this.problem = problem;\n+    reset();\n+  }\n+\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  public void reset() {\n+    maxError  = 0;\n+    lastError = 0;\n+  }\n+\n+  public void handleStep(StepInterpolator interpolator,\n+                         boolean isLast)\n+    throws DerivativeException {\n+\n+    double pT = interpolator.getPreviousTime();\n+    double cT = interpolator.getCurrentTime();\n+    double[] errorScale = problem.getErrorScale();\n+\n+    // store the error at the last step\n+    if (isLast) {\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(cT);\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > lastError) {\n+          lastError = error;\n+        }\n+      }\n+      lastTime = cT;\n+    }\n+\n+    // walk through the step\n+    for (int k = 0; k <= 20; ++k) {\n+\n+      double time = pT + (k * (cT - pT)) / 20;\n+      interpolator.setInterpolatedTime(time);\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());\n+\n+      // update the errors\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  /**\n+   * Get the maximal error encountered during integration.\n+   * @return maximal error\n+   */\n+  public double getMaximalError() {\n+    return maxError;\n+  }\n+\n+  /**\n+   * Get the error at the end of the integration.\n+   * @return error at the end of the integration\n+   */\n+  public double getLastError() {\n+    return lastError;\n+  }\n+\n+  /**\n+   * Get the time at the end of the integration.\n+   * @return time at the end of the integration.\n+   */\n+  public double getLastTime() {\n+    return lastTime;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ThreeEighthesIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.fitting.PolynomialFitter;\n+\n+public class ThreeEighthesIntegratorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ThreeEighthesIntegrator(0.01).integrate(pb,\n+                                                  0.0, new double[pb.getDimension()+10],\n+                                                  1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testOrder()\n+  throws EstimationException, DerivativeException,\n+         IntegratorException {\n+    PolynomialFitter fitter = new PolynomialFitter(1,\n+                                                   10, 1.0e-7, 1.0e-10,\n+                                                   1.0e-10);\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      for (int i = 0; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -(i + 1));\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        if (functions != null) {\n+          for (int l = 0; l < functions.length; ++l) {\n+            integ.addSwitchingFunction(functions[l],\n+                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+          }\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        fitter.addWeightedPair(1.0,\n+                               Math.log(Math.abs(step)),\n+                               Math.log(handler.getLastError()));\n+\n+      }\n+\n+      // this is an order 4 method\n+      double[] coeffs = fitter.fit();\n+      assertTrue(coeffs[1] > 3.2);\n+      assertTrue(coeffs[1] < 4.8);\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new StepHandler() {\n+                      private double maxError = 0;\n+                      public boolean requiresDenseOutput() {\n+                        return false;\n+                      }\n+                      public void reset() {\n+                        maxError = 0;\n+                      }\n+                      public void handleStep(StepInterpolator interpolator,\n+                                             boolean isLast) {\n+\n+                        double[] interpolatedY = interpolator.getInterpolatedState ();\n+                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+                        double dx = interpolatedY[0] - theoreticalY[0];\n+                        double dy = interpolatedY[1] - theoreticalY[1];\n+                        double error = dx * dx + dy * dy;\n+                        if (error > maxError) {\n+                          maxError = error;\n+                        }\n+                        if (isLast) {\n+                          // even with more than 1000 evaluations per period,\n+                          // RK4 is not able to integrate such an eccentric\n+                          // orbit with a good accuracy\n+                          assertTrue(maxError > 0.005);\n+                        }\n+                      }\n+      });\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ThreeEighthesStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+public class ThreeEighthesStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+  public static Test suite() { \n+\n+    TestSuite suite= new TestSuite(\"org.spaceroots.mantissa.optimization\"); \n+\n+    suite.addTest(NelderMeadTest.suite()); \n+    suite.addTest(MultiDirectionalTest.suite()); \n+\n+    return suite; \n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/MultiDirectionalTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import junit.framework.*;\n+\n+public class MultiDirectionalTest\n+  extends TestCase {\n+\n+  public MultiDirectionalTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testRosenbrock()\n+    throws CostException, NoConvergenceException {\n+\n+    CostFunction rosenbrock =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                                       new double[] { -1.2,  1.0 },\n+                                       new double[] {  3.5, -2.3 });\n+\n+    assertTrue(count > 60);\n+    assertTrue(optimum.getCost() > 0.02);\n+\n+  }\n+\n+  public void testPowell()\n+    throws CostException, NoConvergenceException {\n+\n+    CostFunction powell =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),\n+                                       new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                                       new double[] {  4.0,  0.0, 1.0, 2.0 });\n+    assertTrue(count > 850);\n+    assertTrue(optimum.getCost() > 0.015);\n+\n+  }\n+\n+  private class ValueChecker implements ConvergenceChecker {\n+\n+    public ValueChecker(double threshold) {\n+      this.threshold = threshold;\n+    }\n+\n+    public boolean converged(PointCostPair[] simplex) {\n+      PointCostPair smallest = simplex[0];\n+      PointCostPair largest  = simplex[simplex.length - 1];\n+      return (largest.getCost() - smallest.getCost()) < threshold;\n+    }\n+\n+    private double threshold;\n+\n+  };\n+\n+  public static Test suite() {\n+    return new TestSuite(MultiDirectionalTest.class);\n+  }\n+\n+  private int count;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/NelderMeadTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.optimization;\n+\n+import junit.framework.*;\n+\n+public class NelderMeadTest\n+  extends TestCase {\n+\n+  public NelderMeadTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testRosenbrock()\n+    throws CostException, NoConvergenceException {\n+\n+    CostFunction rosenbrock =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new NelderMead().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                                 new double[] { -1.2,  1.0 },\n+                                 new double[] {  3.5, -2.3 });\n+\n+    assertTrue(count < 50);\n+    assertEquals(0.0, optimum.getCost(), 6.0e-4);\n+    assertEquals(1.0, optimum.getPoint()[0], 0.05);\n+    assertEquals(1.0, optimum.getPoint()[1], 0.05);\n+\n+  }\n+\n+  public void testPowell()\n+    throws CostException, NoConvergenceException {\n+\n+    CostFunction powell =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new NelderMead().minimizes(powell, 200, new ValueChecker(1.0e-3),\n+                                 new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                                 new double[] {  4.0,  0.0, 1.0, 2.0 });\n+    assertTrue(count < 150);\n+    assertEquals(0.0, optimum.getCost(), 6.0e-4);\n+    assertEquals(0.0, optimum.getPoint()[0], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[1], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[2], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[3], 0.07);\n+\n+  }\n+\n+  private class ValueChecker implements ConvergenceChecker {\n+\n+    public ValueChecker(double threshold) {\n+      this.threshold = threshold;\n+    }\n+\n+    public boolean converged(PointCostPair[] simplex) {\n+      PointCostPair smallest = simplex[0];\n+      PointCostPair largest  = simplex[simplex.length - 1];\n+      return (largest.getCost() - smallest.getCost()) < threshold;\n+    }\n+\n+    private double threshold;\n+\n+  };\n+\n+  public static Test suite() {\n+    return new TestSuite(NelderMeadTest.class);\n+  }\n+\n+  private int count;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests\n+{\n+  public static Test suite ()\n+  { \n+    TestSuite suite= new TestSuite (\"org.spaceroots.mantissa.quadrature\"); \n+    suite.addTest (org.spaceroots.mantissa.quadrature.scalar.AllTests.suite ());\n+    suite.addTest (org.spaceroots.mantissa.quadrature.vectorial.AllTests.suite ());\n+    return suite; \n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/scalar/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.quadrature.scalar\"); \n+\n+    suite.addTest(GaussLegendreIntegratorTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.scalar;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+import java.util.Random;\n+\n+import junit.framework.*;\n+\n+public class GaussLegendreIntegratorTest\n+  extends TestCase {\n+\n+  public GaussLegendreIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testExactIntegration()\n+    throws FunctionException {\n+    Random random = new Random(86343623467878363l);\n+    int order = 0;\n+    while (true) {\n+      GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,\n+                                                                       7.0);\n+      int availableOrder = integrator.getEvaluationsPerStep();\n+      if (availableOrder < order) {\n+        // we have tested all available orders\n+        return;\n+      }\n+\n+      // an order n Gauss-Legendre integrator integrates\n+      // 2n-1 degree polynoms exactly\n+      for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {\n+        for (int i = 0; i < 10; ++i) {\n+          Polynom p = new Polynom(degree, random, 100.0);\n+          double s0 = integrator.integrate(p, -5.0, 15.0);\n+          double s1 = p.exactIntegration(-5.0, 15.0);\n+          assertTrue(Math.abs(s0 - s1) < 1.0e-12 * (1.0 + Math.abs(s0)));\n+        }\n+      }\n+\n+      ++order;\n+\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GaussLegendreIntegratorTest.class);\n+  }\n+\n+  private class Polynom implements ComputableFunction {\n+    public Polynom(int degree, Random random, double max) {\n+      coeffs = new double[degree + 1];\n+      for (int i = 0; i <= degree; ++i) {\n+        coeffs[i] = 2.0 * max * (random.nextDouble() - 0.5);\n+      }\n+    }\n+\n+    public double valueAt(double t)\n+      throws FunctionException {\n+      double y = coeffs[coeffs.length - 1];\n+      for (int i = coeffs.length - 2; i >= 0; --i) {\n+        y = y * t + coeffs[i];\n+      }\n+      return y;\n+    }\n+\n+    public double exactIntegration(double a, double b)\n+      throws FunctionException {\n+      double yb = coeffs[coeffs.length - 1] / coeffs.length;\n+      double ya = yb;\n+      for (int i = coeffs.length - 2; i >= 0; --i) {\n+        yb = yb * b + coeffs[i] / (i + 1);\n+        ya = ya * a + coeffs[i] / (i + 1);\n+      }\n+      return yb * b - ya * a;\n+    }\n+\n+    private double[] coeffs;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/vectorial/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.quadrature.vectorial\"); \n+\n+    suite.addTest(GaussLegendreIntegratorTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.quadrature.vectorial;\n+\n+import org.spaceroots.mantissa.functions.vectorial.ComputableFunction;\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+import java.util.Random;\n+\n+import junit.framework.*;\n+\n+public class GaussLegendreIntegratorTest\n+  extends TestCase {\n+\n+  public GaussLegendreIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testExactIntegration()\n+    throws FunctionException {\n+    Random random = new Random(86343623467878363l);\n+    int order = 0;\n+    while (true) {\n+      GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,\n+                                                                       7.0);\n+      int availableOrder = integrator.getEvaluationsPerStep();\n+      if (availableOrder < order) {\n+        // we have tested all available orders\n+        return;\n+      }\n+\n+      // an order n Gauss-Legendre integrator integrates\n+      // 2n-1 degree polynoms exactly\n+      for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {\n+        for (int i = 0; i < 10; ++i) {\n+          Polynom p = new Polynom(degree, random, 100.0);\n+          double[] s0 = integrator.integrate(p, -5.0, 15.0);\n+          double[] s1 = p.exactIntegration(-5.0, 15.0);\n+          for (int j = 0; j < p.getDimension(); ++j) {\n+            assertTrue(Math.abs(s0[j] - s1[j]) < 1.0e-12 * (1.0 + Math.abs(s0[j])));\n+          }\n+        }\n+      }\n+\n+      ++order;\n+\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GaussLegendreIntegratorTest.class);\n+  }\n+\n+  private class Polynom implements ComputableFunction {\n+    public Polynom (int degree, Random random, double max) {\n+      coeffs0 = new double[degree + 1];\n+      coeffs1 = new double[degree + 1];\n+      for (int i = 0; i <= degree; ++i) {\n+        coeffs0[i] = 2.0 * max * (random.nextDouble() - 0.5);\n+        coeffs1[i] = 2.0 * max * (random.nextDouble() - 0.5);\n+      }\n+    }\n+\n+    public int getDimension() {\n+      return 2;\n+    }\n+\n+    public double[] valueAt(double t)\n+      throws FunctionException {\n+      double[] y = new double[2];\n+      y[0] = coeffs0[coeffs0.length - 1];\n+      for (int i = coeffs0.length - 2; i >= 0; --i) {\n+        y[0] = y[0] * t + coeffs0[i];\n+      }\n+      y[1] = coeffs1 [coeffs1.length - 1];\n+      for (int i = coeffs1.length - 2; i >= 0; --i) {\n+        y[1] = y[1] * t + coeffs1[i];\n+      }\n+      return y;\n+    }\n+\n+    public double[] exactIntegration(double a, double b)\n+      throws FunctionException {\n+      double[] res = new double[2];\n+      double yb = coeffs0[coeffs0.length - 1] / coeffs0.length;\n+      double ya = yb;\n+      for (int i = coeffs0.length - 2; i >= 0; --i) {\n+        yb = yb * b + coeffs0[i] / (i + 1);\n+        ya = ya * a + coeffs0[i] / (i + 1);\n+      }\n+      res[0] = yb * b - ya * a;\n+      yb = coeffs1[coeffs1.length - 1] / coeffs1.length;\n+      ya = yb;\n+      for (int i = coeffs1.length - 2; i >= 0; --i) {\n+        yb = yb * b + coeffs1[i] / (i + 1);\n+        ya = ya * a + coeffs1[i] / (i + 1);\n+      }\n+      res[1] = yb * b - ya * a;\n+      return res;\n+    }\n+\n+    private double[] coeffs0;\n+    private double[] coeffs1;\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() {\n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.random\"); \n+\n+    suite.addTest(ScalarSampleStatisticsTest.suite());\n+    suite.addTest(VectorialSampleStatisticsTest.suite());\n+    suite.addTest(UniformRandomGeneratorTest.suite()); \n+    suite.addTest(GaussianRandomGeneratorTest.suite()); \n+    suite.addTest(UncorrelatedRandomVectorGeneratorTest.suite()); \n+    suite.addTest(CorrelatedRandomVectorGeneratorTest.suite()); \n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGeneratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.linalg.Matrix;\n+import org.spaceroots.mantissa.linalg.GeneralMatrix;\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+\n+import junit.framework.*;\n+\n+public class CorrelatedRandomVectorGeneratorTest\n+  extends TestCase {\n+\n+  public CorrelatedRandomVectorGeneratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testRank() {\n+    assertEquals(3, generator.getRank());\n+  }\n+\n+  public void testRootMatrix() {\n+    Matrix b = generator.getRootMatrix();\n+    Matrix bbt = b.mul(b.getTranspose());\n+    for (int i = 0; i < covariance.getRows(); ++i) {\n+      for (int j = 0; j < covariance.getColumns(); ++j) {\n+        assertEquals(covariance.getElement(i, j),\n+                     bbt.getElement(i, j),\n+                     1.0e-12);\n+      }\n+    }\n+  }\n+\n+  public void testMeanAndCovariance() {\n+\n+    VectorialSampleStatistics sample = new VectorialSampleStatistics();\n+    for (int i = 0; i < 5000; ++i) {\n+      sample.add(generator.nextVector());\n+    }\n+\n+    double[] estimatedMean = sample.getMean(null);\n+    SymetricalMatrix estimatedCovariance = sample.getCovarianceMatrix(null);\n+    for (int i = 0; i < estimatedMean.length; ++i) {\n+      assertEquals(mean[i], estimatedMean[i], 0.07);\n+      for (int j = 0; j <= i; ++j) {\n+        assertEquals(covariance.getElement(i, j),\n+                     estimatedCovariance.getElement(i, j),\n+                     0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));\n+      }\n+    }\n+\n+  }\n+\n+  public void setUp() {\n+    try {\n+      mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n+\n+      GeneralMatrix b = new GeneralMatrix(4, 3);\n+      int counter = 0;\n+      for (int i = 0; i < b.getRows(); ++i) {\n+        for (int j = 0; j < b.getColumns(); ++j) {\n+          b.setElement(i, j, 1.0 + 0.1 * ++counter);\n+        }\n+      }\n+      Matrix bbt = b.mul(b.getTranspose());\n+      covariance = new SymetricalMatrix(mean.length);\n+      for (int i = 0; i < covariance.getRows(); ++i) {\n+        covariance.setElement(i, i, bbt.getElement(i, i));\n+        for (int j = 0; j < covariance.getColumns(); ++j) {\n+          covariance.setElementAndSymetricalElement(i, j,\n+                                                    bbt.getElement(i, j));\n+        }\n+      }\n+\n+      GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(17399225432l);\n+      generator = new CorrelatedRandomVectorGenerator(mean, covariance, rawGenerator);\n+    } catch (NotPositiveDefiniteMatrixException e) {\n+      fail(\"not positive definite matrix\");\n+    }\n+  }\n+\n+  public void tearDown() {\n+    mean       = null;\n+    covariance = null;\n+    generator  = null;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);\n+  }\n+\n+  private double[] mean;\n+  private SymetricalMatrix covariance;\n+  private CorrelatedRandomVectorGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/GaussianRandomGeneratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import junit.framework.*;\n+\n+public class GaussianRandomGeneratorTest\n+  extends TestCase {\n+\n+  public GaussianRandomGeneratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMeanAndStandardDeviation() {\n+    GaussianRandomGenerator generator = new GaussianRandomGenerator(17399225432l);\n+    ScalarSampleStatistics sample = new ScalarSampleStatistics();\n+    for (int i = 0; i < 10000; ++i) {\n+      sample.add(generator.nextDouble());\n+    }\n+    assertEquals(0.0, sample.getMean(), 0.012);\n+    assertEquals(1.0, sample.getStandardDeviation(), 0.01);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GaussianRandomGeneratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/ScalarSampleStatisticsTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import junit.framework.*;\n+\n+public class ScalarSampleStatisticsTest\n+  extends TestCase {\n+\n+  public ScalarSampleStatisticsTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testBasicStats() {\n+\n+    ScalarSampleStatistics sample = new ScalarSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      sample.add(points[i]);\n+    }\n+\n+    assertEquals(points.length, sample.size());\n+    assertEquals(-5.0, sample.getMin(), 1.0e-12);\n+    assertEquals(10.4, sample.getMax(), 1.0e-12);\n+    assertEquals( 3.0, sample.getMean(), 1.0e-12);\n+    assertEquals( 3.920034013457876, sample.getStandardDeviation(),\n+                  1.0e-12);\n+\n+  }\n+\n+  public void testAddSample() {\n+\n+    ScalarSampleStatistics all  = new ScalarSampleStatistics();\n+    ScalarSampleStatistics even = new ScalarSampleStatistics();\n+    ScalarSampleStatistics odd  = new ScalarSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      all.add(points[i]);\n+      if (i % 2 == 0) {\n+        even.add(points[i]);\n+      } else {\n+        odd.add(points[i]);\n+      }\n+    }\n+\n+    even.add(odd);\n+\n+    assertEquals(all.size(), even.size());\n+    assertEquals(all.getMin(), even.getMin(), 1.0e-12);\n+    assertEquals(all.getMax(), even.getMax(), 1.0e-12);\n+    assertEquals(all.getMean(), even.getMean(), 1.0e-12);\n+    assertEquals(all.getStandardDeviation(), even.getStandardDeviation(),\n+                 1.0e-12);\n+\n+  }\n+\n+  public void testAddArray() {\n+\n+    ScalarSampleStatistics loop   = new ScalarSampleStatistics();\n+    ScalarSampleStatistics direct = new ScalarSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      loop.add(points[i]);\n+    }\n+    direct.add(points);\n+\n+    assertEquals(loop.size(), direct.size());\n+    assertEquals(loop.getMin(), direct.getMin(), 1.0e-12);\n+    assertEquals(loop.getMax(), direct.getMax(), 1.0e-12);\n+    assertEquals(loop.getMean(), direct.getMean(), 1.0e-12);\n+    assertEquals(loop.getStandardDeviation(), direct.getStandardDeviation(),\n+                 1.0e-12);\n+\n+  }\n+\n+  public void setUp() {\n+    points = new double[] {1.0, 4.2, -5, 4.0, 2.9, 10.4, 0.0, 4.1, 4.2, 4.2};\n+  }\n+\n+  public void tearDown() {\n+    points = null;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ScalarSampleStatisticsTest.class);\n+  }\n+\n+  private double[] points;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGeneratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+\n+import junit.framework.*;\n+\n+public class UncorrelatedRandomVectorGeneratorTest\n+  extends TestCase {\n+\n+  public UncorrelatedRandomVectorGeneratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMeanAndCorrelation() {\n+\n+    VectorialSampleStatistics sample = new VectorialSampleStatistics();\n+    for (int i = 0; i < 10000; ++i) {\n+      sample.add(generator.nextVector());\n+    }\n+\n+    double[] estimatedMean = sample.getMean(null);\n+    double scale;\n+    SymetricalMatrix estimatedCorrelation = sample.getCovarianceMatrix(null);\n+    for (int i = 0; i < estimatedMean.length; ++i) {\n+      assertEquals(mean[i], estimatedMean[i], 0.07);\n+      for (int j = 0; j < i; ++j) {\n+        scale = standardDeviation[i] * standardDeviation[j];\n+        assertEquals(0, estimatedCorrelation.getElement(i, j) / scale, 0.03);\n+      }\n+      scale = standardDeviation[i] * standardDeviation[i];\n+      assertEquals(1, estimatedCorrelation.getElement(i, i) / scale, 0.025);\n+    }\n+\n+  }\n+\n+  public void setUp() {\n+    mean              = new double[] {0.0, 1.0, -3.0, 2.3};\n+    standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};\n+    generator =\n+      new UncorrelatedRandomVectorGenerator(mean, standardDeviation,\n+                                            new GaussianRandomGenerator(17399225432l));\n+  }\n+\n+  public void tearDown() {\n+    mean = null;\n+    standardDeviation = null;\n+    generator = null;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);\n+  }\n+\n+  private double[] mean;\n+  private double[] standardDeviation;\n+  private UncorrelatedRandomVectorGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/UniformRandomGeneratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import junit.framework.*;\n+\n+public class UniformRandomGeneratorTest\n+  extends TestCase {\n+\n+  public UniformRandomGeneratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMeanAndStandardDeviation() {\n+    UniformRandomGenerator generator = new UniformRandomGenerator(17399225432l);\n+    ScalarSampleStatistics sample = new ScalarSampleStatistics();\n+    for (int i = 0; i < 1000; ++i) {\n+      sample.add(generator.nextDouble());\n+    }\n+    assertEquals(0.0, sample.getMean(), 0.07);\n+    assertEquals(1.0, sample.getStandardDeviation(), 0.02);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(UniformRandomGeneratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/VectorialSampleStatisticsTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.random;\n+\n+import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n+\n+import junit.framework.*;\n+\n+public class VectorialSampleStatisticsTest\n+  extends TestCase {\n+\n+  public VectorialSampleStatisticsTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSimplistic() {\n+    VectorialSampleStatistics sample = new VectorialSampleStatistics();\n+    sample.add(new double[] {-1.0,  1.0});\n+    sample.add(new double[] { 1.0, -1.0});\n+    SymetricalMatrix c = sample.getCovarianceMatrix(null);\n+    assertEquals( 2.0, c.getElement(0, 0), 1.0e-12);\n+    assertEquals(-2.0, c.getElement(1, 0), 1.0e-12);\n+    assertEquals( 2.0, c.getElement(1, 1), 1.0e-12);\n+  }\n+\n+  public void testBasicStats() {\n+\n+    VectorialSampleStatistics sample = new VectorialSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      sample.add(points[i]);\n+    }\n+\n+    assertEquals(points.length, sample.size());\n+\n+    double[] min = sample.getMin();\n+    double[] max = sample.getMax();\n+    double[] mean = sample.getMean(null);\n+    SymetricalMatrix c = sample.getCovarianceMatrix(null);\n+\n+    double[]   refMin  = new double[] {-0.70, 0.00, -3.10};\n+    double[]   refMax  = new double[] { 6.00, 2.30,  5.00};\n+    double[]   refMean = new double[] { 1.78, 1.62,  3.12};\n+    double[][] refC    = new double[][] {\n+      { 8.0470, -1.9195, -3.4445},\n+      {-1.9195,  1.0470,  3.2795},\n+      {-3.4445,  3.2795, 12.2070}\n+    };\n+\n+    for (int i = 0; i < min.length; ++i) {\n+      assertEquals(refMin[i],  min[i],  1.0e-12);\n+      assertEquals(refMax[i],  max[i],  1.0e-12);\n+      assertEquals(refMean[i], mean[i], 1.0e-12);\n+      for (int j = 0; j <= i; ++j) {\n+        assertEquals(refC[i][j], c.getElement(i, j), 1.0e-12);\n+      }\n+    }\n+\n+  }\n+\n+  public void testAddSample() {\n+\n+    VectorialSampleStatistics all  = new VectorialSampleStatistics();\n+    VectorialSampleStatistics even = new VectorialSampleStatistics();\n+    VectorialSampleStatistics odd  = new VectorialSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      all.add(points[i]);\n+      if (i % 2 == 0) {\n+        even.add(points[i]);\n+      } else {\n+        odd.add(points[i]);\n+      }\n+    }\n+\n+    even.add(odd);\n+\n+    assertEquals(all.size(), even.size());\n+\n+    double[] min = even.getMin();\n+    double[] max = even.getMax();\n+    double[] mean = even.getMean(null);\n+    SymetricalMatrix c = even.getCovarianceMatrix(null);\n+\n+    double[] refMin = all.getMin();\n+    double[] refMax = all.getMax();\n+    double[] refMean = all.getMean(null);\n+    SymetricalMatrix refC = all.getCovarianceMatrix(null);\n+\n+    for (int i = 0; i < min.length; ++i) {\n+      assertEquals(refMin[i],  min[i],  1.0e-12);\n+      assertEquals(refMax[i],  max[i],  1.0e-12);\n+      assertEquals(refMean[i], mean[i], 1.0e-12);\n+      for (int j = 0; j <= i; ++j) {\n+        assertEquals(refC.getElement(i, j), c.getElement(i, j), 1.0e-12);\n+      }\n+    }\n+\n+  }\n+\n+  public void testAddArray() {\n+\n+    VectorialSampleStatistics loop   = new VectorialSampleStatistics();\n+    VectorialSampleStatistics direct = new VectorialSampleStatistics();\n+    for (int i = 0; i < points.length; ++i) {\n+      loop.add(points[i]);\n+    }\n+    direct.add(points);\n+\n+    assertEquals(loop.size(), direct.size());\n+\n+    double[] min = direct.getMin();\n+    double[] max = direct.getMax();\n+    double[] mean = direct.getMean(null);\n+    SymetricalMatrix c = direct.getCovarianceMatrix(null);\n+\n+    double[] refMin = loop.getMin();\n+    double[] refMax = loop.getMax();\n+    double[] refMean = loop.getMean(null);\n+    SymetricalMatrix refC = loop.getCovarianceMatrix(null);\n+\n+    for (int i = 0; i < min.length; ++i) {\n+      assertEquals(refMin[i],  min[i],  1.0e-12);\n+      assertEquals(refMax[i],  max[i],  1.0e-12);\n+      assertEquals(refMean[i], mean[i], 1.0e-12);\n+      for (int j = 0; j <= i; ++j) {\n+        assertEquals(refC.getElement(i, j), c.getElement(i, j), 1.0e-12);\n+      }\n+    }\n+\n+  }\n+\n+  public void setUp() {\n+    points = new double[][] {\n+      { 1.2, 2.3,  4.5},\n+      {-0.7, 2.3,  5.0},\n+      { 3.1, 0.0, -3.1},\n+      { 6.0, 1.2,  4.2},\n+      {-0.7, 2.3,  5.0}\n+    };\n+  }\n+\n+  public void tearDown() {\n+    points = null;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(VectorialSampleStatisticsTest.class);\n+  }\n+\n+  private double [][] points;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/roots/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.roots\"); \n+\n+    suite.addTest(BrentSolverTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/roots/BrentSolverTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+import org.spaceroots.mantissa.functions.FunctionException;\n+\n+import junit.framework.*;\n+\n+public class BrentSolverTest\n+  extends TestCase {\n+\n+  public BrentSolverTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testAlefeldPotraShi()\n+  throws FunctionException {\n+\n+    TestProblem[] problems = TestProblem.getAPSProblems();\n+    BrentSolver solver     = new BrentSolver();\n+\n+    for (int i = 0; i < problems.length; ++i) {\n+      TestProblem p = problems[i];\n+      double tol = 1.0e-10 * Math.abs(p.getExpectedRoot());\n+      assertTrue(solver.findRoot(p, new Checker(tol), 1000,\n+                                 p.getA(), p.valueAt(p.getA()),\n+                                 p.getB(), p.valueAt(p.getB())));\n+      assertTrue(p.checkResult(solver.getRoot(), tol));\n+    }\n+\n+  }\n+\n+  private class Checker implements ConvergenceChecker {\n+\n+    private double tolerance;\n+\n+    public Checker (double tolerance) {\n+      this.tolerance = tolerance;\n+    }\n+\n+    public int converged (double xLow, double fLow,\n+                          double xHigh, double fHigh) {\n+      return (Math.abs(xHigh - xLow) <= tolerance)\n+        ? ((Math.abs(fLow) <= Math.abs(fHigh))\n+           ? ConvergenceChecker.LOW\n+           : ConvergenceChecker.HIGH)\n+        : ConvergenceChecker.NONE;\n+    }\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(BrentSolverTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/roots/TestProblem.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.roots;\n+\n+import org.spaceroots.mantissa.functions.scalar.ComputableFunction;\n+\n+import java.util.ArrayList;\n+\n+/** This class implement a reference problem for junit tests. */\n+public abstract class TestProblem implements ComputableFunction {\n+\n+  private double a;\n+  private double b;\n+  private double expectedRoot;\n+\n+  protected TestProblem(double a, double b, double expectedRoot) {\n+    this.a            = a;\n+    this.b            = b;\n+    this.expectedRoot = expectedRoot;\n+  }\n+\n+  public double getA() {\n+    return a;\n+  }\n+\n+  public double getB() {\n+    return b;\n+  }\n+\n+  public double getExpectedRoot() {\n+    return expectedRoot;\n+  }\n+\n+  public boolean checkResult(double foundRoot, double tol) {\n+    return Math.abs(foundRoot - expectedRoot) <= tol;\n+  }\n+\n+  /** Get the reference problems from G. E. Alefeld, F. A. Potra and Y. Shi. */\n+  public static TestProblem[] getAPSProblems() {\n+\n+    ArrayList problems = new ArrayList();\n+\n+    // problem 1\n+    problems.add(new APSProblem1(Math.PI / 2, Math.PI, 1.8954942670340));\n+\n+    // problems 2 to 11\n+    double[] roots2To11 = {\n+      3.0229153472731,  6.6837535608081, 11.238701655002, 19.676000080623,\n+     29.828227326505,  41.906116195289,  55.953595800143, 71.985665586588,\n+     90.008868539167, 110.02653274833\n+    };\n+    for (int k = 0, n = 1; n <= 10; ++n) {\n+      problems.add(new APSProblems2To11(1.0e-9 + n * n,\n+                                        (n+1) * (n+1) - 1.0e-9,\n+                                        roots2To11[k++]));\n+    }\n+\n+    // problems 12 to 14\n+    problems.add(new APSProblems12To14( -40, -9.0, 31.0, 0.0));\n+    problems.add(new APSProblems12To14(-100, -9.0, 31.0, 0.0));\n+    problems.add(new APSProblems12To14(-200, -9.0, 31.0, 0.0));\n+\n+    // problems 15 to 17\n+    int[] n15 = { 4, 6, 8, 10, 12 };\n+    double[] roots15 = {\n+      0.66874030497642, 0.76472449133173, 0.81776543395794,\n+      0.85133992252078, 0.87448527222117\n+    };\n+    for (int k = 0; k < n15.length; ++k) {\n+      problems.add(new APSProblems15To17(n15[k], 0.2, 0.0, 5.0, roots15[k]));\n+    }\n+\n+    int[] n16 = { 4, 6, 8, 10, 12 };\n+    for (int k = 0; k < n16.length; ++k) {\n+      problems.add(new APSProblems15To17(n16[k], 1.0, 0.0, 5.0, 1.0));\n+    }\n+\n+    int[] n17 = { 8, 10, 12, 14 };\n+    for (int k = 0; k < n17.length; ++k) {\n+      problems.add(new APSProblems15To17(n17[k], 1.0, -0.95, 4.05, 1.0));\n+    }\n+\n+    // problem 18\n+    problems.add(new APSProblem18(0.0, 1.5, 0.52359877559830));\n+\n+    // problem 19\n+    int[] n19 = { 1, 2, 3, 4, 5, 20, 40, 60, 80, 100 };\n+    double[] roots19 = {\n+      0.42247770964124,   0.30669941048320,   0.22370545765466,\n+      0.17171914751951,   0.13825715505682,   3.4657359020854e-2,\n+      1.7328679513999e-2, 1.1552453009332e-2, 8.6643397569993e-3,\n+      6.9314718055995e-3\n+    };\n+    for (int k = 0; k < n19.length; ++k) {\n+      problems.add(new APSProblem19(n19[k], 0.0, 1.0, roots19[k]));\n+    }\n+\n+    // problem 20\n+    int[] n20 = { 5, 10, 20 };\n+    double[] roots20 = {\n+      3.8402551840622e-2, 9.9000099980005e-3, 2.4937500390620e-3\n+    };\n+    for (int k = 0; k < n20.length; ++k) {\n+      problems.add(new APSProblem20(n20[k], 0.0, 1.0, roots20[k]));\n+    }\n+\n+    // problem 21\n+    int[] n21 = { 2, 5, 10, 15, 20 };\n+    double[] roots21 = {\n+      0.5, 0.34595481584824, 0.24512233375331,\n+      0.19554762353657, 0.16492095727644\n+    };\n+    for (int k = 0; k < n21.length; ++k) {\n+      problems.add(new APSProblem21(n21[k], 0.0, 1.0, roots21[k]));\n+    }\n+\n+    // problem 22\n+    int[] n22 = { 1, 2, 4, 5, 8, 15, 20 };\n+    double[] roots22 = {\n+      0.27550804099948,   0.13775402049974,   1.0305283778156e-2,\n+      3.6171081789041e-3, 4.1087291849640e-4, 2.5989575892908e-5,\n+      7.6685951221853e-6\n+    };\n+    for (int k = 0; k < n22.length; ++k) {\n+      problems.add(new APSProblem22(n22[k], 0.0, 1.0, roots22[k]));\n+    }\n+\n+    // problem 23\n+    int[] n23 = { 1, 5, 10, 15, 20 };\n+    double[] roots23 = {\n+      0.40105813754155, 0.51615351875793, 0.53952222690842,\n+      0.54818229434066, 0.55270466667849\n+    };\n+    for (int k = 0; k < n23.length; ++k) {\n+      problems.add(new APSProblem23(n23[k], 0.0, 1.0, roots23[k]));\n+    }\n+\n+    // problem 24\n+    int[] n24 = { 2, 5, 15, 20 };\n+    for (int k = 0; k < n24.length; ++k) {\n+      problems.add(new APSProblem24(n24[k], 0.01, 1, 1.0 / n24[k]));\n+    }\n+\n+    // problem 25\n+    int[] n25 = {\n+       2,  3,  4,  5,  6,\n+       7,  9, 11, 13, 15,\n+      17, 19, 21, 23, 25,\n+      27, 29, 31, 33\n+    };\n+    for (int k = 0; k < n25.length; ++k) {\n+      problems.add(new APSProblem25(n25[k], 1.0, 100.0, n25[k]));\n+    }\n+\n+    // problem 26\n+    problems.add(new APSProblem26(-1.0, 4.0, 0.0));\n+\n+    // problem 27\n+    int[] n27 = {\n+      1,  2,  3,  4,  5,  6,  7,  8,  9,  10,\n+     11, 12, 13, 14, 15, 16, 17, 18, 19,  20,\n+     21, 22, 23, 24, 25, 26, 27, 28, 29,  30,\n+     31, 32, 33, 34, 35, 36, 37, 38, 39,  40\n+    };\n+    for (int k = 0; k < n27.length; ++k) {\n+      problems.add(new APSProblem27(n27[k], -10000.0, Math.PI / 2,\n+                                    0.62380651896161));\n+    }\n+\n+    // problem 28\n+    int[] n28 = {\n+       20,  21,  22,  23,  24,  25,  26,  27,  28,   29,\n+       30,  31,  32,  33,  34,  35,  36,  37,  38,   39, 40,\n+      100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };\n+    double[] roots28 = {\n+      5.9051305594220e-5, 5.6367155339937e-5, 5.3916409455592e-5,\n+      5.1669892394942e-5, 4.9603096699145e-5, 4.7695285287639e-5,\n+      4.5928793239949e-5, 4.4288479195665e-5, 4.2761290257883e-5,\n+      4.1335913915954e-5, 4.0002497338020e-5, 3.8752419296207e-5,\n+      3.7578103559958e-5, 3.6472865219959e-5, 3.5430783356532e-5,\n+      3.4446594929961e-5, 3.3515605877800e-5, 3.2633616249437e-5,\n+      3.1796856858426e-5, 3.1001935436965e-5, 3.0245790670210e-5,\n+      1.2277994232462e-5, 6.1695393904409e-6, 4.1198585298293e-6,\n+      3.0924623877272e-6, 2.4752044261050e-6, 2.0633567678513e-6,\n+      1.7690120078154e-6, 1.5481615698859e-6, 1.3763345366022e-6,\n+      1.2388385788997e-6\n+    };\n+    for (int k = 0; k < n28.length; ++k) {\n+      problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));\n+    }\n+\n+    return (TestProblem[]) problems.toArray(new TestProblem[0]);\n+\n+  }\n+\n+  private static class APSProblem1 extends TestProblem {\n+    public APSProblem1(double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+    }\n+    public double valueAt(double x) {\n+      return Math.sin(x) - x / 2;\n+    }\n+  }\n+\n+  private static class APSProblems2To11 extends TestProblem {\n+    public APSProblems2To11(double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+    }\n+    public double valueAt(double x) {\n+      double f = 0;\n+      for (int i = 1; i <= 20; ++i) {\n+        double n = 2.0 * i - 5.0;\n+        double d = x - i * i;\n+        f += n * n / (d * d * d);\n+      }\n+      return -2 * f;\n+    }\n+  }\n+\n+  private static class APSProblems12To14 extends TestProblem {\n+    private int n;\n+    public APSProblems12To14(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+    }\n+    public double valueAt(double x) {\n+      return n * x * Math.exp(-x);\n+    }\n+  }\n+\n+  private static class APSProblems15To17 extends TestProblem {\n+    private int    n;\n+    private double u;\n+    public APSProblems15To17(int n, double u,\n+                             double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+      this.u = u;\n+    }\n+    public double valueAt(double x) {\n+      return Math.pow(x, n) - u;\n+    }\n+  }\n+\n+  private static class APSProblem18 extends TestProblem {\n+    public APSProblem18(double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+    }\n+    public double valueAt(double x) {\n+      return Math.sin(x) - 0.5;\n+    }\n+  }\n+\n+  private static class APSProblem19 extends TestProblem {\n+    private int n;\n+    public APSProblem19(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+    }\n+    public double valueAt(double x) {\n+      return 2.0 * x * Math.exp(-n) - 2.0 *Math.exp(-n * x) + 1.0;\n+    }\n+  }\n+\n+  private static class APSProblem20 extends TestProblem {\n+    private int n;\n+    private int oPoMn2;\n+    public APSProblem20(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+      int oMn =  1 - n;\n+      oPoMn2 = 1 + oMn * oMn;\n+    }\n+    public double valueAt(double x) {\n+      double v = 1.0 - n * x;\n+      return oPoMn2 * x - v * v;\n+    }\n+  }\n+\n+  private static class APSProblem21 extends TestProblem {\n+    private int n;\n+    public APSProblem21(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+    }\n+    public double valueAt(double x) {\n+      return x * x - Math.pow(1 - x, n);\n+    }\n+  }\n+\n+  private static class APSProblem22 extends TestProblem {\n+    private int n;\n+    private int oPoMn4;\n+    public APSProblem22(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n   = n;\n+      int oMn  = 1 - n;\n+      int oMn2 = oMn * oMn;\n+      oPoMn4   = 1 + oMn2 * oMn2;\n+    }\n+    public double valueAt(double x) {\n+      double oMnx  = 1 - n * x;\n+      double oMnx2 = oMnx * oMnx;\n+      return oPoMn4 * x - oMnx2 * oMnx2;\n+    }\n+  }\n+\n+  private static class APSProblem23 extends TestProblem {\n+    private int n;\n+    public APSProblem23(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+    }\n+    public double valueAt(double x) {\n+      return (x - 1.0) * Math.exp(-n * x) + Math.pow(x, n);\n+    }\n+  }\n+\n+  private static class APSProblem24 extends TestProblem {\n+    private int n;\n+    public APSProblem24(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      this.n = n;\n+    }\n+    public double valueAt(double x) {\n+      return (n * x - 1.0) / ((n - 1) * x);\n+    }\n+  }\n+\n+  private static class APSProblem25 extends TestProblem {\n+    private double u;\n+    private double v;;\n+    public APSProblem25(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      u = 1.0 / n;\n+      v = Math.pow(n, u);\n+    }\n+    public double valueAt(double x) {\n+      return Math.pow(x, u) - v;\n+    }\n+  }\n+\n+  private static class APSProblem26 extends TestProblem {\n+    public APSProblem26(double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+    }\n+    public double valueAt(double x) {\n+      if (x == 0.0) {\n+        return 0;\n+      }\n+      return x / Math.exp(1 / (x * x));\n+    }\n+\n+    // this is a very special case since there is a wide range around\n+    // the true root (which is 0) for which |f(x)| is smaller than the\n+    // smallest representable positive number (according to IEEE 754):\n+    //    f(0.03762210865...) = 2^-1024\n+    //    f(0.03764056462...) = 2^-1023\n+    //    f(0.03765904777...) = 2^-1022\n+    //    f(0.03767755816...) = 2^-1021\n+    // any root between -0.03768 and +0.03768 should be considered good\n+    public boolean checkResult(double foundRoot, double tol) {\n+      return Math.abs(foundRoot) <= 0.03768;\n+    }\n+\n+  }\n+\n+  private static class APSProblem27 extends TestProblem {\n+    private double u;\n+    public APSProblem27(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      u = n / 20.0;\n+    }\n+    public double valueAt(double x) {\n+      if (x >= 0.0) {\n+        return (x / 1.5 + Math.sin(x) - 1.0) * u;\n+      }\n+      return -u;\n+    }\n+  }\n+\n+  private static class APSProblem28 extends TestProblem {\n+    private double threshold;\n+    private double yHigh;\n+    private int    u;\n+    public APSProblem28(int n, double a, double b, double expectedRoot) {\n+      super(a, b, expectedRoot);\n+      threshold = 0.002 / (1 + n);\n+      yHigh     = Math.exp(1.0) - 1.859;\n+      u         = (n + 1) * 500;\n+    }\n+    public double valueAt(double x) {\n+      if (x >= threshold) {\n+        return yHigh;\n+      } else if (x >= 0) {\n+        return Math.exp(u * x) - 1.859;\n+      } else {\n+        return -0.859;\n+      }\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/AllTests.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+  public static Test suite() { \n+\n+    TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.utilities\"); \n+\n+    suite.addTest(ArrayMapperTest.suite());\n+    suite.addTest(MappableArrayTest.suite());\n+    suite.addTest(MappableScalarTest.suite());\n+    suite.addTest(IntervalTest.suite());\n+    suite.addTest(IntervalsListTest.suite());\n+\n+    return suite; \n+\n+  }\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/ArrayMapperTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import junit.framework.*;\n+\n+public class ArrayMapperTest\n+  extends TestCase {\n+\n+  public ArrayMapperTest(String name) {\n+    super(name);\n+    mapper = null;\n+  }\n+\n+  public void testDimensionCheck() {\n+    int size = b1.getStateDimension();\n+    size += b2.getStateDimension();\n+    size += b3.getStateDimension();\n+    assertTrue(mapper.getInternalDataArray().length == size);\n+  }\n+\n+  public void testUpdateObjects() {\n+\n+    double[] data = new double [7];\n+    for (int i = 0; i < 7; ++i) {\n+      data [i] = i * 0.1;\n+    }\n+\n+    mapper.updateObjects(data);\n+\n+    assertTrue(Math.abs(b1.getElement(0) - 0.0) < 1.0e-10);\n+\n+    assertTrue(Math.abs(b2.getElement(0) - 0.4) < 1.0e-10);\n+    assertTrue(Math.abs(b2.getElement(1) - 0.3) < 1.0e-10);\n+    assertTrue(Math.abs(b2.getElement(2) - 0.2) < 1.0e-10);\n+    assertTrue(Math.abs(b2.getElement(3) - 0.1) < 1.0e-10);\n+\n+    assertTrue(Math.abs(b3.getElement(0) - 0.6) < 1.0e-10);\n+    assertTrue(Math.abs(b3.getElement(1) - 0.5) < 1.0e-10);\n+\n+  }\n+  \n+  public void testUpdateArray() {\n+\n+    b1.setElement(0,  0.0);\n+\n+    b2.setElement(0, 40.0);\n+    b2.setElement(1, 30.0);\n+    b2.setElement(2, 20.0);\n+    b2.setElement(3, 10.0);\n+\n+    b3.setElement(0, 60.0);\n+    b3.setElement(1, 50.0);\n+\n+    mapper.updateArray();\n+\n+    double[] data = mapper.getInternalDataArray();\n+    for (int i = 0; i < 7; ++i) {\n+      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n+    }\n+\n+  }\n+  \n+  public void setUp() {\n+\n+    b1 = new DomainObject(1);\n+    b2 = new DomainObject(4);\n+    b3 = new DomainObject(2);\n+\n+    mapper = new ArrayMapper();\n+    mapper.manageMappable(b1);\n+    mapper.manageMappable(b2);\n+    mapper.manageMappable(b3);\n+\n+  }\n+\n+  public void tearOff() {\n+\n+    b1 = null;\n+    b2 = null;\n+    b3 = null;\n+\n+    mapper = null;\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ArrayMapperTest.class);\n+  }\n+\n+  private class DomainObject implements ArraySliceMappable {\n+\n+    private double[] data;\n+\n+    public DomainObject(int size) {\n+      data = new double [size];\n+    }\n+\n+    public int getStateDimension() {\n+      return data.length;\n+    }\n+\n+    public void mapStateFromArray(int start, double[] array) {\n+      for (int i = 0; i < data.length; ++i) {\n+        data [data.length - 1 - i] = array [start + i];\n+      }\n+    }\n+    \n+    public void mapStateToArray(int start, double[] array) {\n+      for (int i = 0; i < data.length; ++i) {\n+        array [start + i] = data [data.length - 1 - i];\n+      }\n+    }\n+\n+    public double getElement(int i) {\n+      return data [i];\n+    }\n+\n+    public void setElement(int i, double value) {\n+      data [i] = value;\n+    }\n+\n+  }\n+\n+  private DomainObject b1;\n+  private DomainObject b2;\n+  private DomainObject b3;\n+\n+  private ArrayMapper mapper;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/IntervalTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import junit.framework.*;\n+\n+public class IntervalTest\n+  extends TestCase {\n+\n+  public IntervalTest(String name) {\n+    super(name);\n+  }\n+\n+  public void test1() {\n+    check(new Interval(-10.0, 10.0), new Interval(11.0, 12.0), 2.5,\n+          true, false, false,\n+          new Interval(-10.0, 12.0), new Interval(11.0, 11.0));\n+  }\n+\n+  public void test2() {\n+    check(new Interval(-10.0, 10.0), new Interval(9.0, 12.0), 50.0,\n+          false, false, true,\n+          new Interval(-10.0, 12.0), new Interval(9.0, 10.0));\n+  }\n+\n+  public void test3() {\n+    check(new Interval(-10.0, 10.0), new Interval(-12.0, -11.0), 0.0,\n+          true, false, false,\n+          new Interval(-12.0, 10.0), new Interval(-10.0, -10.0));\n+  }\n+\n+  public void test4() {\n+    check(new Interval(-10.0, 10.0), new Interval(-4.0, 5.0), 0.0,\n+          true, true, true,\n+          new Interval(-10.0, 10.0), new Interval(-4.0, 5.0));\n+  }\n+\n+  public void test5() {\n+    check(new Interval(-10.0, 10.0), new Interval(-10.0, 10.0), 0.0,\n+          true, true, true,\n+          new Interval(-10.0, 10.0), new Interval(-10.0, 10.0));\n+  }\n+\n+  private void check(Interval i1, Interval i2, double x,\n+                     boolean b1, boolean b2, boolean b3,\n+                     Interval add, Interval inter) {\n+\n+    assertTrue(i1.contains(x)    ^ (!b1));\n+    assertTrue(i1.contains(i2)   ^ (!b2));\n+    assertTrue(i1.intersects(i2) ^ (!b3));\n+\n+    assertEquals(add.getInf(), Interval.add(i1, i2).getInf(), 1.0e-10);\n+    assertEquals(add.getSup(), Interval.add(i1, i2).getSup(), 1.0e-10);\n+    assertEquals(inter.getInf(), Interval.intersection(i1, i2).getInf(), 1.0e-10);\n+    assertEquals(inter.getSup(), Interval.intersection(i1, i2).getSup(), 1.0e-10);\n+\n+    Interval ia = new Interval(i1);\n+    ia.addToSelf(i2);\n+    assertEquals(add.getInf(), ia.getInf(), 1.0e-10);\n+    assertEquals(add.getSup(), ia.getSup(), 1.0e-10);\n+\n+    Interval ib = new Interval(i1);\n+    ib.intersectSelf(i2);\n+    assertEquals(inter.getInf(), ib.getInf(), 1.0e-10);\n+    assertEquals(inter.getSup(), ib.getSup(), 1.0e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(IntervalTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/IntervalsListTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import java.util.Iterator;\n+\n+import junit.framework.*;\n+\n+public class IntervalsListTest\n+  extends TestCase {\n+\n+  public IntervalsListTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testAddBetween() {\n+    IntervalsList il =\n+      new IntervalsList (new Interval(10, 20), new Interval(50, 60));\n+    il.addToSelf(new Interval(30, 40));\n+    checkEquals(new Interval[] {\n+                  new Interval(10, 20),\n+                  new Interval(30, 40),\n+                  new Interval(50, 60)\n+                }, il);\n+  }\n+\n+  public void testAddReducingLastHole() {\n+    IntervalsList il =\n+      new IntervalsList (new Interval(10, 20), new Interval(50, 60));\n+    il.addToSelf(new Interval(30, 55));\n+    checkEquals(new Interval[] {\n+                  new Interval(10, 20),\n+                  new Interval(30, 60)\n+                }, il);\n+  }\n+\n+  public void test1() {\n+\n+    IntervalsList list1 = new IntervalsList(-2.0, -1.0);\n+    IntervalsList list2 = new IntervalsList(new Interval(-0.9, -0.8));\n+    check(list1, list2, 2.5,\n+          true, false, 1, true, false, 1, false,\n+          new Interval[] { new Interval(-2.0, -1.0),\n+                           new Interval(-0.9, -0.8) },\n+          new Interval[0]);\n+\n+    list2.addToSelf(new Interval(1.0, 3.0));\n+    check(list1, list2, 2.5,\n+          true, false, 1, false, false, 2, false,\n+          new Interval[] { new Interval(-2.0, -1.0),\n+                           new Interval(-0.9, -0.8),\n+                           new Interval( 1.0,  3.0) },\n+          new Interval[0]);\n+\n+    list1.addToSelf(new Interval(-1.2, 0.0));\n+    check(list1, list2, -1.1,\n+          true, false, 1, false, false, 2, true,\n+          new Interval[] { new Interval(-2.0,  0.0),\n+                           new Interval( 1.0,  3.0) },\n+          new Interval[] { new Interval(-0.9, -0.8) });\n+\n+    IntervalsList list = new IntervalsList(new Interval(-10.0, -8.0));\n+    list.addToSelf(new Interval(-6.0, -4.0));\n+    list.addToSelf(new Interval(-0.85, 1.2));\n+    list1.addToSelf(list);\n+    check(list1, list2, 0,\n+          false, false, 3, false, false, 2, true,\n+          new Interval[] { new Interval(-10.0, -8.0),\n+                           new Interval( -6.0, -4.0),\n+                           new Interval( -2.0,  3.0) },\n+          new Interval[] { new Interval( -0.9, -0.8),\n+                           new Interval(  1.0,  1.2) });\n+\n+  }\n+\n+  private void check(IntervalsList l1, IntervalsList l2, double x,\n+                     boolean b1, boolean b2, int i1,\n+                     boolean b3, boolean b4, int i2,\n+                     boolean b5, Interval[] add, Interval[] inter) {\n+    assertTrue(l1.isConnex()     ^ (!b1));\n+    assertTrue(l1.isEmpty()      ^ (!b2));\n+    assertEquals(i1, l1.getIntervals().size());\n+    assertTrue(l2.isConnex()     ^ (!b3));\n+    assertTrue(l2.isEmpty()      ^ (!b4));\n+    assertEquals(i2, l2.getIntervals().size());\n+    assertTrue(l1.contains(x)    ^ (!b5));\n+    checkEquals(add,   IntervalsList.add(l1, l2));\n+    checkEquals(inter, IntervalsList.intersection(l1, l2));\n+  }\n+\n+  private void checkEquals(Interval[] sa, IntervalsList sb) {\n+    assertEquals(sa.length, sb.getIntervals().size());\n+    Iterator iterB = sb.getIntervals().iterator();\n+    for (int i = 0; i < sa.length; ++i) {\n+      Interval ib = (Interval) iterB.next();\n+      assertEquals(sa[i].getInf(), ib.getInf(), 1.0e-10);\n+      assertEquals(sa[i].getSup(), ib.getSup(), 1.0e-10);\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(IntervalsListTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableArrayTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import junit.framework.*;\n+\n+public class MappableArrayTest\n+  extends TestCase {\n+\n+  public MappableArrayTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    assertTrue(mapper.getInternalDataArray().length == 9);\n+  }\n+\n+  public void testRealloc() {\n+\n+    for (int i = 0; i < reusedArray.length; ++i) {\n+      reusedArray[i] = -1.0;\n+    }\n+\n+    for (int i = 0; i < clonedArray.length; ++i) {\n+      clonedArray[i] = -1.0;\n+    }\n+\n+    double[] data = new double [mapper.getInternalDataArray().length];\n+    for (int i = 0; i < data.length; ++i) {\n+      data [i] = i * 0.1;\n+    }\n+\n+    mapper.updateObjects(data);\n+\n+    assertTrue(Math.abs(reusedArray[0] - 0.4) < 1.0e-10);\n+    assertTrue(Math.abs(reusedArray[1] - 0.5) < 1.0e-10);\n+\n+    assertTrue(Math.abs(clonedArray[0] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(clonedArray[1] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(clonedArray[2] + 1.0) < 1.0e-10);\n+\n+  }\n+  \n+  public void testUpdateObjects() {\n+\n+    double[] data = new double [mapper.getInternalDataArray().length];\n+    for (int i = 0; i < data.length; ++i) {\n+      data [i] = i * 0.1;\n+    }\n+\n+    mapper.updateObjects(data);\n+\n+    assertTrue(Math.abs(array1.getArray()[0] - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(array1.getArray()[1] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(array1.getArray()[2] - 0.2) < 1.0e-10);\n+    assertTrue(Math.abs(array1.getArray()[3] - 0.3) < 1.0e-10);\n+\n+    assertTrue(Math.abs(array2.getArray()[0] - 0.4) < 1.0e-10);\n+    assertTrue(Math.abs(array2.getArray()[1] - 0.5) < 1.0e-10);\n+\n+    assertTrue(Math.abs(array3.getArray()[0] - 0.6) < 1.0e-10);\n+    assertTrue(Math.abs(array3.getArray()[1] - 0.7) < 1.0e-10);\n+    assertTrue(Math.abs(array3.getArray()[2] - 0.8) < 1.0e-10);\n+\n+  }\n+  \n+  public void testUpdateArray() {\n+\n+    array1.getArray()[0] = 00.0;\n+    array1.getArray()[1] = 10.0;\n+    array1.getArray()[2] = 20.0;\n+    array1.getArray()[3] = 30.0;\n+\n+    array2.getArray()[0] = 40.0;\n+    array2.getArray()[1] = 50.0;\n+\n+    array3.getArray()[0] = 60.0;\n+    array3.getArray()[1] = 70.0;\n+    array3.getArray()[2] = 80.0;\n+\n+    mapper.updateArray();\n+\n+    double[] data = mapper.getInternalDataArray();\n+    for (int i = 0; i < data.length; ++i) {\n+      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n+    }\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(MappableArrayTest.class);\n+  }\n+\n+  public void setUp() {\n+\n+    reusedArray = new double[2];\n+    clonedArray = new double[3];\n+\n+    array1 = new MappableArray(4);\n+    array2 = new MappableArray(reusedArray, false);\n+    array3 = new MappableArray(clonedArray, true);\n+\n+    mapper = new ArrayMapper();\n+    mapper.manageMappable(array1);\n+    mapper.manageMappable(array2);\n+    mapper.manageMappable(array3);\n+\n+  }\n+\n+  public void tearDown() {\n+    reusedArray = null;\n+    clonedArray = null;\n+\n+    array1 = null;\n+    array2 = null;\n+    array3 = null;\n+\n+    mapper = null;\n+\n+  }\n+\n+  private double[] reusedArray;\n+  private double[] clonedArray;\n+\n+  private MappableArray array1;\n+  private MappableArray array2;\n+  private MappableArray array3;\n+\n+  private ArrayMapper mapper;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableScalarTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.spaceroots.mantissa.utilities;\n+\n+import junit.framework.*;\n+\n+public class MappableScalarTest\n+  extends TestCase {\n+\n+  public MappableScalarTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    assertTrue(mapper.getInternalDataArray().length == 3);\n+  }\n+\n+  public void testUpdateObjects() {\n+\n+    double[] data = new double [mapper.getInternalDataArray().length];\n+    for (int i = 0; i < data.length; ++i) {\n+      data [i] = i * 0.1;\n+    }\n+\n+    mapper.updateObjects(data);\n+\n+    assertTrue(Math.abs(scalar1.getValue() - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(scalar2.getValue() - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(scalar3.getValue() - 0.2) < 1.0e-10);\n+\n+  }\n+  \n+  public void testUpdateArray() {\n+\n+    scalar1.setValue(00.0);\n+    scalar2.setValue(10.0);\n+    scalar3.setValue(20.0);\n+\n+    mapper.updateArray();\n+\n+    double[] data = mapper.getInternalDataArray();\n+    for (int i = 0; i < data.length; ++i) {\n+      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n+    }\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(MappableScalarTest.class);\n+  }\n+\n+  public void setUp() {\n+\n+    scalar1 = new MappableScalar();\n+    scalar2 = new MappableScalar(2);\n+    scalar3 = new MappableScalar(-3);\n+\n+    mapper = new ArrayMapper();\n+    mapper.manageMappable(scalar1);\n+    mapper.manageMappable(scalar2);\n+    mapper.manageMappable(scalar3);\n+\n+  }\n+\n+  public void tearDown() {\n+\n+    scalar1 = null;\n+    scalar2 = null;\n+    scalar3 = null;\n+\n+    mapper = null;\n+\n+  }\n+\n+  private MappableScalar scalar1;\n+  private MappableScalar scalar2;\n+  private MappableScalar scalar3;\n+\n+  private ArrayMapper mapper;\n+\n+}", "timestamp": 1163972175, "metainfo": ""}