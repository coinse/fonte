{"sha": "7bbad398dd4da51c933414be9a17b07179dee5e4", "log": "MATH-397. Modified \"AbstractUnivariateRealOptimizer\" so that its usage is more similar to what is done in package \"optimization.general\". Deprecated many methods as a consequence of the new layout. New utility methods in \"ConvergingAlgorithmImpl\". Temporary workaround in \"BrentOptimizer\" (requirement from base class) to avoid committing two issues at the same time...   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n \n package org.apache.commons.math;\n \n-\n /**\n  * Provide a default implementation for several functions useful to generic\n  * converging algorithms.\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public abstract class ConvergingAlgorithmImpl implements ConvergingAlgorithm{\n+public abstract class ConvergingAlgorithmImpl implements ConvergingAlgorithm {\n \n     /** Maximum absolute error. */\n     protected double absoluteAccuracy;\n     /** Default maximum number of iterations. */\n     protected int defaultMaximalIterationCount;\n \n-    // Mainly for test framework.\n     /** The last iteration count. */\n     protected int iterationCount;\n \n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n+     * @deprecated in 2.2. Derived classes should use the \"setter\" methods\n+     * in order to assign meaningful values to all the instances variables.\n      */\n     protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                       final double defaultAbsoluteAccuracy) {\n         this.maximalIterationCount = defaultMaximalIterationCount;\n         this.iterationCount = 0;\n     }\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @since 2.2\n+     * @deprecated in 2.2 (to be removed as soon as the single non-default one\n+     * has been removed).\n+     */\n+    protected ConvergingAlgorithmImpl() {}\n \n     /** {@inheritDoc} */\n     public int getIterationCount() {\n         relativeAccuracy = defaultRelativeAccuracy;\n     }\n \n+    /**\n+     * Reset the iterations counter to 0.\n+     *\n+     * @since 2.2\n+     */\n+    protected void resetIterationsCounter() {\n+        iterationCount = 0;\n+    }\n+\n+    /**\n+     * Increment the iterations counter by 1.\n+     *\n+     * @throws OptimizationException if the maximal number\n+     * of iterations is exceeded.\n+     * @since 2.2\n+     */\n+    protected void incrementIterationsCounter()\n+        throws ConvergenceException {\n+        if (++iterationCount > maximalIterationCount) {\n+            throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n \n import org.apache.commons.math.ConvergingAlgorithmImpl;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.optimization.GoalType;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n  */\n public abstract class AbstractUnivariateRealOptimizer\n     extends ConvergingAlgorithmImpl implements UnivariateRealOptimizer {\n-\n     /** Indicates where a root has been computed. */\n-    protected boolean resultComputed;\n-\n+    private boolean resultComputed;\n     /** The last computed root. */\n-    protected double result;\n-\n+    private double result;\n     /** Value of the function at the last computed result. */\n-    protected double functionValue;\n-\n+    private double functionValue;\n     /** Maximal number of evaluations allowed. */\n     private int maxEvaluations;\n-\n     /** Number of evaluations already performed. */\n     private int evaluations;\n+    /** Optimization type */\n+    private GoalType goal;\n+    /** Lower end of search interval. */\n+    private double min;\n+    /** Higher end of search interval. */\n+    private double max;\n+    /** Initial guess . */\n+    private double startValue;\n+    /** Function to optimize. */\n+    private UnivariateRealFunction function;\n \n     /**\n      * Construct a solver with given iteration count and accuracy.\n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n+     * @deprecated in 2.2. Please use the \"setter\" methods to assign meaningful\n+     * values to the maximum numbers of iterations and evaluations, and to the\n+     * absolute and relative accuracy thresholds.\n      */\n     protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n                                               final double defaultAbsoluteAccuracy) {\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n-    /** Check if a result has been computed.\n-     * @exception IllegalStateException if no result has been computed\n-     */\n-    protected void checkResultComputed() throws IllegalStateException {\n+    /**\n+     * Default constructor.\n+     * To be removed once the single non-default one has been removed.\n+     */\n+    protected AbstractUnivariateRealOptimizer() {}\n+\n+    /**\n+     * Check whether a result has been computed.\n+     * @throws NoDataException if no result has been computed\n+     * @deprecated in 2.2 (no alternative).\n+     */\n+    protected void checkResultComputed() {\n         if (!resultComputed) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n+            throw new NoDataException();\n         }\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        checkResultComputed();\n+        if (!resultComputed) {\n+            throw new NoDataException();\n+        }\n         return result;\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        checkResultComputed();\n+        if (functionValue == Double.NaN) {\n+            final double opt = getResult();\n+            try {\n+                functionValue = function.value(opt);\n+            } catch (FunctionEvaluationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n         return functionValue;\n     }\n \n      * @param x the result to set\n      * @param fx the result to set\n      * @param iterationCount the iteration count to set\n+     * @deprecated in 2.2 (no alternative).\n      */\n     protected final void setResult(final double x, final double fx,\n                                    final int iterationCount) {\n \n     /**\n      * Convenience function for implementations.\n+     * @deprecated in 2.2 (no alternative).\n      */\n     protected final void clearResult() {\n         this.resultComputed = false;\n     /** {@inheritDoc} */\n     public int getEvaluations() {\n         return evaluations;\n+    }\n+\n+    /**\n+     * @return the optimization type.\n+     */\n+    public GoalType getGoalType() {\n+        return goal;\n+    }\n+    /**\n+     * @return the lower of the search interval.\n+     */\n+    public double getMin() {\n+        return min;\n+    }\n+    /**\n+     * @return the higher of the search interval.\n+     */\n+    public double getMax() {\n+        return max;\n+    }\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double getStartValue() {\n+        return startValue;\n     }\n \n     /**\n      * @return objective function value at specified point\n      * @exception FunctionEvaluationException if the function cannot be evaluated\n      * or the maximal number of iterations is exceeded\n+     * @deprecated in 2.2. Use this {@link #computeObjectiveValue(double)\n+     * replacement} instead.\n      */\n     protected double computeObjectiveValue(final UnivariateRealFunction f,\n                                            final double point)\n         return f.value(point);\n     }\n \n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n+     * or the maximal number of iterations is exceeded.\n+     */\n+    protected double computeObjectiveValue(double point)\n+        throws FunctionEvaluationException {\n+        if (++evaluations > maxEvaluations) {\n+            resultComputed = false;\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(UnivariateRealFunction function, GoalType goal,\n+                           double min, double max, double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        // Initialize.\n+        this.min = min;\n+        this.max = max;\n+        this.startValue = startValue;\n+        this.goal = goal;\n+        this.function = function;\n+\n+        // Reset.\n+        functionValue = Double.NaN;\n+        evaluations = 0;\n+        resetIterationsCounter();\n+\n+        // Perform computation.\n+        result = doOptimize();\n+        resultComputed = true;\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Set the value at the optimum.\n+     *\n+     * @param functionValue Value of the objective function at the optimum.\n+     */\n+    protected void setFunctionValue(double functionValue) {\n+        this.functionValue = functionValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(UnivariateRealFunction f, GoalType goal,\n+                           double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /**\n+     * Method for implementing actual optimization algorithms in derived\n+     * classes.\n+     *\n+     * @return the optimum.\n+     */\n+    protected abstract double doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n+\n+    /** Temporary workaround. */\n+    protected double doOptimize() {\n+        throw new UnsupportedOperationException();\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n         try {\n             minimizer.getResult();\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalStateException ise) {\n+        } catch (NoDataException ise) {\n             // expected\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");", "timestamp": 1280312822, "metainfo": ""}