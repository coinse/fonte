{"sha": "8afbbb7af8f4e174419afa42cee2f9e5a055b769", "log": "More efficient implementation: Removed unnecessary arrays. Added another test.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n             prodLowSum += prodLow;\n         }\n \n+\n+        final double prodHighCur = prodHigh[0];\n+        double prodHighNext = prodHigh[1];\n+        double sHighPrev = prodHighCur + prodHighNext;\n+        double sPrime = sHighPrev - prodHighNext;\n+        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n+\n         final int lenMinusOne = len - 1;\n-        final double[] sHigh = new double[lenMinusOne];\n-\n-        sHigh[0] = prodHigh[0] + prodHigh[1];\n-        double sPrime = sHigh[0] - prodHigh[1];\n-        double sLowSum = (prodHigh[1] - (sHigh[0] - sPrime)) + (prodHigh[0] - sPrime);\n-\n         for (int i = 1; i < lenMinusOne; i++) {\n-            final int prev = i - 1;\n-            final int next = i + 1;\n-            sHigh[i] = sHigh[prev] + prodHigh[next];\n-            sPrime = sHigh[i] - prodHigh[next];\n-            sLowSum += (prodHigh[next] - (sHigh[i] - sPrime)) + (sHigh[prev] - sPrime);\n-        }\n-\n-        return sHigh[lenMinusOne - 1] + (prodLowSum + sLowSum);\n+            prodHighNext = prodHigh[i + 1];\n+            final double sHighCur = sHighPrev + prodHighNext;\n+            sPrime = sHighCur - prodHighNext;\n+            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+            sHighPrev = sHighCur;\n+        }\n+\n+        return sHighPrev + (prodLowSum + sLowSum);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.random.Well1024a;\n import org.junit.Assert;\n import org.junit.Test;\n \n \n         Assert.assertEquals(abSumInline, abSumArray, 0);\n     }\n+\n+    @Test\n+    public void testLinearCombination2() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(553267312521321234l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final double ux = 1e17 * random.nextDouble();\n+            final double uy = 1e17 * random.nextDouble();\n+            final double uz = 1e17 * random.nextDouble();\n+            final double vx = 1e17 * random.nextDouble();\n+            final double vy = 1e17 * random.nextDouble();\n+            final double vz = 1e17 * random.nextDouble();\n+            final double sInline = MathUtils.linearCombination(ux, vx,\n+                                                               uy, vy,\n+                                                               uz, vz);\n+            final double sArray = MathUtils.linearCombination(new double[] {ux, uy, uz},\n+                                                              new double[] {vx, vy, vz});\n+            Assert.assertEquals(sInline, sArray, 0);\n+        }\n+    }\n }", "timestamp": 1312628521, "metainfo": ""}