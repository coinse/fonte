{"sha": "7cac17f918f3e895e5091724967c7e7c3547916a", "log": "MATH-797 Initial version for Gauss-Legendre quadrature rules: the integration is performed on the whole interval using a single rule. [Whereas the approach used in class \"analysis.integration.LegendreGaussIntegrator\" is to divide iteratively into sub-intervals (over which the integration rule is used) until some covergence criterion is met.] Adapted from an original code donated by S\u00e9bastien Brisard. In the current implementation, the Gauss-Legendre rules are computed in double precision in \"LegendreRuleFactory\" and high precision (using \"java.math.BigDecimal\") in \"LegendreHighPrecisionRuleFactory\". However, the \"GaussIntegrator\" class performs the integration using \"double\"s whatever the precision of the rule. The framework of \"BaseRuleFactory\" enables the addition of other quadrature schemes (by overriding the \"computeRule\" method). [S\u00e9bastien's code already provides Gauss-Chebyshev and Gauss-Hermite schemes (in double precision).]   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+\n+/**\n+ * Base class for rules that determines the integration nodes and their\n+ * weights.\n+ * Subclasses must implement the {@link #computeRule(int) computeRule} method.\n+ *\n+ * <T> Type of the number used to represent the points and weights of the\n+ * quadrature rules.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public abstract class BaseRuleFactory<T extends Number> {\n+    /** List of points and weights, indexed by the order of the rule. */\n+    private final Map<Integer, Pair<T[], T[]>> pointsAndWeights\n+        = new TreeMap<Integer, Pair<T[], T[]>>();\n+\n+    /**\n+     * Gets a copy of the quadrature rule with given number of integration points.\n+     *\n+     * @param numberOfPoints Number of integration points.\n+     * @return a copy of the integration rule.\n+     */\n+    public Pair<double[], double[]> getRule(int numberOfPoints) {\n+        return convertToDouble(getRuleInternal(numberOfPoints));\n+    }\n+\n+    /**\n+     * Gets a rule.\n+     * Rules are computed once, and cached.\n+     * The returned rule is a reference into the cache.\n+     *\n+     * @param numberOfPoints Order of the rule to be retrieved.\n+     * @return the points and weights corresponding to the given order.\n+     */\n+    protected Pair<T[], T[]> getRuleInternal(int numberOfPoints) {\n+        final Pair<T[], T[]> rule = pointsAndWeights.get(numberOfPoints);\n+        if (rule == null) {\n+            addRule(computeRule(numberOfPoints));\n+            // The rule should be available now.\n+            return getRuleInternal(numberOfPoints);\n+        }\n+        return rule;\n+    }\n+    \n+    /**\n+     * Stores a rule.\n+     *\n+     * @param rule Rule to be stored.\n+     * @throws DimensionMismatchException if the elements of the pair do not\n+     * have the same length.\n+     */\n+    protected void addRule(Pair<T[], T[]> rule) {\n+        if (rule.getFirst().length != rule.getSecond().length) {\n+            throw new DimensionMismatchException(rule.getFirst().length,\n+                                                 rule.getSecond().length);\n+        }\n+\n+        pointsAndWeights.put(rule.getFirst().length, rule);\n+    }\n+\n+    /**\n+     * Computes the rule for the given order.\n+     *\n+     * @param numberOfPoints Order of the rule to be computed.\n+     * @return the computed rule.\n+     */\n+    protected abstract Pair<T[], T[]> computeRule(int numberOfPoints);\n+\n+    /**\n+     * Converts the from the actual {@code Number} type to {@code double}\n+     *\n+     * @param rule Points and weights.\n+     * @return points and weights as {@code double}s.\n+     */\n+    private static <T extends Number> Pair<double[], double[]> convertToDouble(Pair<T[], T[]> rule) {\n+        final T[] pT = rule.getFirst();\n+        final T[] wT = rule.getSecond();\n+\n+        final int len = pT.length;\n+        final double[] pD = new double[len];\n+        final double[] wD = new double[len];\n+\n+        for (int i = 0; i < len; i++) {\n+            pD[i] = pT[i].doubleValue();\n+            wD[i] = wT[i].doubleValue();\n+        }\n+\n+        return new Pair<double[], double[]>(pD, wD);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Class that implements the Gaussian rule for\n+ * {@link #integrate(UnivariateFunction) integrating} a weighted\n+ * function.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class GaussIntegrator {\n+    /** Nodes. */\n+    private final double[] points;\n+    /** Nodes weights. */\n+    private final double[] weights;\n+\n+    /**\n+     * Creates an integrator from the given {@code points} and {@code weights}.\n+     * The integration interval is defined by the first and last value of\n+     * {@code points} which must be sorted in increasing order.\n+     *\n+     * @param points Integration points.\n+     * @param weights Weights of the corresponding integration nodes.\n+     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n+     * if the {@code points} are not sorted in increasing order.\n+     */\n+    public GaussIntegrator(double[] points,\n+                           double[] weights) {\n+        if (points.length != weights.length) {\n+            throw new DimensionMismatchException(points.length,\n+                                                 weights.length);\n+        }\n+\n+        MathArrays.checkOrder(points, MathArrays.OrderDirection.INCREASING, true, true);\n+\n+        this.points = points.clone();\n+        this.weights = weights.clone();\n+    }\n+\n+    /**\n+     * Creates an integrator from the given pair of points (first element of\n+     * the pair) and weights (second element of the pair.\n+     *\n+     * @param pointsAndWeights Integration points and corresponding weights.\n+     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n+     * if the {@code points} are not sorted in increasing order.\n+     *\n+     * @see #GaussIntegrator(double[], double[])\n+     */\n+    public GaussIntegrator(Pair<double[], double[]> pointsAndWeights) {\n+        this(pointsAndWeights.getFirst(), pointsAndWeights.getSecond());\n+    }\n+\n+    /**\n+     * Returns an estimate of the integral of {@code f(x) * w(x)},\n+     * where {@code w} is a weight function that depends on the actual\n+     * flavor of the Gauss integration scheme.\n+     * The algorithm uses the points and associated weights, as passed\n+     * to the {@link #GaussIntegrator(double[],double[]) constructor}.\n+     *\n+     * @param f Function to integrate.\n+     * @return the integral of the weighted function.\n+     */\n+    public double integrate(UnivariateFunction f) {\n+        double s = 0;\n+        double c = 0;\n+        for (int i = 0; i < points.length; i++) {\n+            final double x = points[i];\n+            final double w = weights[i];\n+            final double y = w * f.value(x) - c;\n+            final double t = s + y;\n+            c = (t - s) - y;\n+            s = t;\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * @return the order of the integration rule (the number of integration\n+     * points).\n+     */\n+    public int getNumberOfPoints() {\n+        return points.length;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+\n+/**\n+ * Class that provides different ways to compute the nodes and weights to be\n+ * used by the {@link GaussIntegrator Gaussian integration rule}.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class GaussIntegratorFactory {\n+    /** Generator of Gauss-Legendre integrators. */\n+    private final BaseRuleFactory legendre = new LegendreRuleFactory();\n+    /** Generator of Gauss-Legendre integrators. */\n+    private final BaseRuleFactory legendreHighPrecision = new LegendreHighPrecisionRuleFactory();\n+\n+    /**\n+     * Creates an integrator of the given order, and whose call to the\n+     * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method will perform an integration on the natural interval\n+     * {@code [-1 , 1]}.\n+     *\n+     * @param numberOfPoints Order of the integration rule.\n+     * @return a Gauss-Legendre integrator.\n+     */\n+    public GaussIntegrator legendre(int numberOfPoints) {\n+        return new GaussIntegrator(getRule(legendre, numberOfPoints));\n+    }\n+\n+    /**\n+     * Creates an integrator of the given order, and whose call to the\n+     * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method will perform an integration on the given interval.\n+     *\n+     * @param numberOfPoints Order of the integration rule.\n+     * @param lowerBound Lower bound of the integration interval.\n+     * @param upperBound Upper bound of the integration interval.\n+     * @return a Gauss-Legendre integrator.\n+     */\n+    public GaussIntegrator legendre(int numberOfPoints,\n+                                    double lowerBound,\n+                                    double upperBound) {\n+        return new GaussIntegrator(transform(getRule(legendre, numberOfPoints),\n+                                             lowerBound, upperBound));\n+    }\n+\n+    /**\n+     * Creates an integrator of the given order, and whose call to the\n+     * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method will perform an integration on the natural interval\n+     * {@code [-1 , 1]}.\n+     *\n+     * @param numberOfPoints Order of the integration rule.\n+     * @return a Gauss-Legendre integrator.\n+     */\n+    public GaussIntegrator legendreHighPrecision(int numberOfPoints) {\n+        return new GaussIntegrator(getRule(legendreHighPrecision, numberOfPoints));\n+    }\n+\n+    /**\n+     * Creates an integrator of the given order, and whose call to the\n+     * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method will perform an integration on the given interval.\n+     *\n+     * @param numberOfPoints Order of the integration rule.\n+     * @param lowerBound Lower bound of the integration interval.\n+     * @param upperBound Upper bound of the integration interval.\n+     * @return a Gauss-Legendre integrator.\n+     */\n+    public GaussIntegrator legendreHighPrecision(int numberOfPoints,\n+                                                 double lowerBound,\n+                                                 double upperBound) {\n+        return new GaussIntegrator(transform(getRule(legendreHighPrecision, numberOfPoints),\n+                                             lowerBound, upperBound));\n+    }\n+\n+    /**\n+     * @param factory Integration rule factory.\n+     * @param numberOfPoints Order of the integration rule.\n+     * @return the integration nodes and weights.\n+     */\n+    private static Pair<double[], double[]> getRule(BaseRuleFactory factory,\n+                                                    int numberOfPoints) {\n+        return factory.getRule(numberOfPoints);\n+    }\n+\n+    /**\n+     * Performs a change of variable so that the integration can be performed\n+     * on an arbitrary interval {@code [a, b]}.\n+     * It is assumed that the natural interval is {@code [-1, 1]}.\n+     * \n+     * @param rule Original points and weights.\n+     * @param a Lower bound of the integration interval.\n+     * @param b Lower bound of the integration interval.\n+     * @return the points and weights adapted to the new interval.\n+     */\n+    private static Pair<double[], double[]> transform(Pair<double[], double[]> rule,\n+                                                      double a,\n+                                                      double b) {\n+        final double[] points = rule.getFirst();\n+        final double[] weights = rule.getSecond();\n+\n+        // Scaling\n+        final double scale = (b - a) / 2;\n+        final double shift = a + scale;\n+\n+        for (int i = 0; i < points.length; i++) {\n+            points[i] = points[i] * scale + shift;\n+            weights[i] *= scale;\n+        }\n+\n+        return new Pair<double[], double[]>(points, weights);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionRuleFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.math.MathContext;\n+import java.math.BigDecimal;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Factory that creates Gauss-type quadrature rule using Legendre polynomials.\n+ * In this implementation, the lower and upper bounds of the natural interval\n+ * of integration are -1 and 1, respectively.\n+ * The Legendre polynomials are evaluated using the recurrence relation\n+ * presented in <a href=\"http://en.wikipedia.org/wiki/Abramowitz_and_Stegun\"\n+ * Abramowitz and Stegun, 1964</a>.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class LegendreHighPrecisionRuleFactory extends BaseRuleFactory<BigDecimal> {\n+    private final MathContext mContext;\n+    /** The number {@code 2}. */\n+    private final BigDecimal two;\n+    /** The number {@code -1}. */\n+    private final BigDecimal minusOne;\n+    /** The number {@code 0.5}. */\n+    private final BigDecimal oneHalf;\n+\n+    /**\n+     * Default precision is {@link MathContext#DECIMAL128 DECIMAL128}.\n+     */\n+    public LegendreHighPrecisionRuleFactory() {\n+        this(MathContext.DECIMAL128);\n+    }\n+\n+    /**\n+     * @param mContext Precision setting for computing the quadrature rules.\n+     */\n+    public LegendreHighPrecisionRuleFactory(MathContext mContext) {\n+        this.mContext = mContext;\n+        two = new BigDecimal(\"2\", mContext);\n+        minusOne = new BigDecimal(\"-1\", mContext);\n+        oneHalf = new BigDecimal(\"0.5\", mContext);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected Pair<BigDecimal[], BigDecimal[]> computeRule(int numberOfPoints) {\n+        if (numberOfPoints == 1) {\n+            // Break recursion.\n+            return new Pair<BigDecimal[], BigDecimal[]>(new BigDecimal[] { BigDecimal.ZERO },\n+                                                        new BigDecimal[] { two });\n+        }\n+\n+        // Get previous rule.\n+        // If it has not been computed yet it will trigger a recursive call\n+        // to this method.\n+        final BigDecimal[] previousPoints = getRuleInternal(numberOfPoints - 1).getFirst();\n+\n+        // Compute next rule.\n+        final BigDecimal[] points = new BigDecimal[numberOfPoints];\n+        final BigDecimal[] weights = new BigDecimal[numberOfPoints];\n+\n+        // Find i-th root of P[n+1] by bracketing.\n+        final int iMax = numberOfPoints / 2;\n+        for (int i = 0; i < iMax; i++) {\n+            // Lower-bound of the interval.\n+            BigDecimal a = (i == 0) ? minusOne : previousPoints[i - 1];\n+            // Upper-bound of the interval.\n+            BigDecimal b = (iMax == 1) ? BigDecimal.ONE : previousPoints[i];\n+            // P[j-1](a)\n+            BigDecimal pma = BigDecimal.ONE;\n+            // P[j](a)\n+            BigDecimal pa = a;\n+            // P[j-1](b)\n+            BigDecimal pmb = BigDecimal.ONE;\n+            // P[j](b)\n+            BigDecimal pb = b;\n+            for (int j = 1; j < numberOfPoints; j++) {\n+                final BigDecimal b_two_j_p_1 = new BigDecimal(2 * j + 1, mContext);\n+                final BigDecimal b_j = new BigDecimal(j, mContext);\n+                final BigDecimal b_j_p_1 = new BigDecimal(j + 1, mContext);\n+\n+                // Compute P[j+1](a)\n+                // ppa = ((2 * j + 1) * a * pa - j * pma) / (j + 1);\n+\n+                BigDecimal tmp1 = a.multiply(b_two_j_p_1, mContext);\n+                tmp1 = pa.multiply(tmp1, mContext);\n+                BigDecimal tmp2 = pma.multiply(b_j, mContext);\n+                // P[j+1](a)\n+                BigDecimal ppa = tmp1.subtract(tmp2, mContext);\n+                ppa = ppa.divide(b_j_p_1, mContext);\n+\n+                // Compute P[j+1](b)\n+                // ppb = ((2 * j + 1) * b * pb - j * pmb) / (j + 1);\n+\n+                tmp1 = b.multiply(b_two_j_p_1, mContext);\n+                tmp1 = pb.multiply(tmp1, mContext);\n+                tmp2 = pmb.multiply(b_j, mContext);\n+                // P[j+1](b)\n+                BigDecimal ppb = tmp1.subtract(tmp2, mContext);\n+                ppb = ppb.divide(b_j_p_1, mContext);\n+\n+                pma = pa;\n+                pa = ppa;\n+                pmb = pb;\n+                pb = ppb;\n+            }\n+            // Now pa = P[n+1](a), and pma = P[n](a). Same holds for b.\n+            // Middle of the interval.\n+            BigDecimal c = a.add(b, mContext).multiply(oneHalf, mContext);\n+            // P[j-1](c)\n+            BigDecimal pmc = BigDecimal.ONE;\n+            // P[j](c)\n+            BigDecimal pc = c;\n+            boolean done = false;\n+            while (!done) {\n+                BigDecimal tmp1 = b.subtract(a, mContext);\n+                BigDecimal tmp2 = c.ulp().multiply(BigDecimal.TEN, mContext);\n+                done = tmp1.compareTo(tmp2) <= 0;\n+                pmc = BigDecimal.ONE;\n+                pc = c;\n+                for (int j = 1; j < numberOfPoints; j++) {\n+                    final BigDecimal b_two_j_p_1 = new BigDecimal(2 * j + 1, mContext);\n+                    final BigDecimal b_j = new BigDecimal(j, mContext);\n+                    final BigDecimal b_j_p_1 = new BigDecimal(j + 1, mContext);\n+\n+                    // Compute P[j+1](c)\n+                    tmp1 = c.multiply(b_two_j_p_1, mContext);\n+                    tmp1 = pc.multiply(tmp1, mContext);\n+                    tmp2 = pmc.multiply(b_j, mContext);\n+                    // P[j+1](c)\n+                    BigDecimal ppc = tmp1.subtract(tmp2, mContext);\n+                    ppc = ppc.divide(b_j_p_1, mContext);\n+\n+                    pmc = pc;\n+                    pc = ppc;\n+                }\n+                // Now pc = P[n+1](c) and pmc = P[n](c).\n+                if (!done) {\n+                    if (pa.signum() * pc.signum() <= 0) {\n+                        b = c;\n+                        pmb = pmc;\n+                        pb = pc;\n+                    } else {\n+                        a = c;\n+                        pma = pmc;\n+                        pa = pc;\n+                    }\n+                    c = a.add(b, mContext).multiply(oneHalf, mContext);\n+                }\n+            }\n+            final BigDecimal nP = new BigDecimal(numberOfPoints, mContext);\n+            BigDecimal tmp1 = pmc.subtract(c.multiply(pc, mContext), mContext);\n+            tmp1 = tmp1.multiply(nP);\n+            tmp1 = tmp1.pow(2, mContext);\n+            BigDecimal tmp2 = c.pow(2, mContext);\n+            tmp2 = BigDecimal.ONE.subtract(tmp2, mContext);\n+            tmp2 = tmp2.multiply(two, mContext);\n+            tmp2 = tmp2.divide(tmp1, mContext);\n+\n+            points[i] = c;\n+            weights[i] = tmp2;\n+\n+            final int idx = numberOfPoints - i - 1;\n+            points[idx] = c.negate(mContext);\n+            weights[idx] = tmp2;\n+        }\n+        // If \"numberOfPoints\" is odd, 0 is a root.\n+        if (numberOfPoints % 2 == 1) {\n+            BigDecimal pmc = BigDecimal.ONE;\n+            for (int j = 1; j < numberOfPoints; j += 2) {\n+                final BigDecimal b_j = new BigDecimal(j, mContext);\n+                final BigDecimal b_j_p_1 = new BigDecimal(j + 1, mContext);\n+\n+                // pmc = -j * pmc / (j + 1);\n+                pmc = pmc.multiply(b_j, mContext);\n+                pmc = pmc.divide(b_j_p_1, mContext);\n+                pmc = pmc.negate(mContext);\n+            }\n+\n+            // 2 / pow(numberOfPoints * pmc, 2);\n+            final BigDecimal nP = new BigDecimal(numberOfPoints, mContext);\n+            BigDecimal tmp1 = pmc.multiply(nP, mContext);\n+            tmp1 = tmp1.pow(2, mContext);\n+            BigDecimal tmp2 = two.divide(tmp1, mContext);\n+\n+            points[iMax] = BigDecimal.ZERO;\n+            weights[iMax] = tmp2;\n+        }\n+\n+        return new Pair<BigDecimal[], BigDecimal[]>(points, weights);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreRuleFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.math.MathContext;\n+import java.math.BigDecimal;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Factory that creates Gauss-type quadrature rule using Legendre polynomials.\n+ * In this implementation, the lower and upper bounds of the natural interval\n+ * of integration are -1 and 1, respectively.\n+ * The Legendre polynomials are evaluated using the recurrence relation\n+ * presented in <a href=\"http://en.wikipedia.org/wiki/Abramowitz_and_Stegun\"\n+ * Abramowitz and Stegun, 1964</a>.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class LegendreRuleFactory extends BaseRuleFactory<Double> {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected Pair<Double[], Double[]> computeRule(int numberOfPoints) {\n+        if (numberOfPoints == 1) {\n+            // Break recursion.\n+            return new Pair<Double[], Double[]>(new Double[] { 0d },\n+                                                new Double[] { 2d });\n+        }\n+\n+        // Get previous rule.\n+        // If it has not been computed yet it will trigger a recursive call\n+        // to this method.\n+        final Double[] previousPoints = getRuleInternal(numberOfPoints - 1).getFirst();\n+\n+        // Compute next rule.\n+        final Double[] points = new Double[numberOfPoints];\n+        final Double[] weights = new Double[numberOfPoints];\n+\n+        // Find i-th root of P[n+1] by bracketing.\n+        final int iMax = numberOfPoints / 2;\n+        for (int i = 0; i < iMax; i++) {\n+            // Lower-bound of the interval.\n+            double a = (i == 0) ? -1 : previousPoints[i - 1].doubleValue();\n+            // Upper-bound of the interval.\n+            double b = (iMax == 1) ? 1 : previousPoints[i].doubleValue();\n+            // P[j-1](a)\n+            double pma = 1;\n+            // P[j](a)\n+            double pa = a;\n+            // P[j-1](b)\n+            double pmb = 1;\n+            // P[j](b)\n+            double pb = b;\n+            for (int j = 1; j < numberOfPoints; j++) {\n+                final int two_j_p_1 = 2 * j + 1;\n+                final int j_p_1 = j + 1;\n+                // P[j+1](a)\n+                final double ppa = (two_j_p_1 * a * pa - j * pma) / j_p_1;\n+                // P[j+1](b)\n+                final double ppb = (two_j_p_1 * b * pb - j * pmb) / j_p_1;\n+                pma = pa;\n+                pa = ppa;\n+                pmb = pb;\n+                pb = ppb;\n+            }\n+            // Now pa = P[n+1](a), and pma = P[n](a) (same holds for b).\n+            // Middle of the interval.\n+            double c = 0.5 * (a + b);\n+            // P[j-1](c)\n+            double pmc = 1;\n+            // P[j](c)\n+            double pc = c;\n+            boolean done = false;\n+            while (!done) {\n+                done = b - a <= Math.ulp(c);\n+                pmc = 1;\n+                pc = c;\n+                for (int j = 1; j < numberOfPoints; j++) {\n+                    // P[j+1](c)\n+                    final double ppc = ((2 * j + 1) * c * pc - j * pmc) / (j + 1);\n+                    pmc = pc;\n+                    pc = ppc;\n+                }\n+                // Now pc = P[n+1](c) and pmc = P[n](c).\n+                if (!done) {\n+                    if (pa * pc <= 0) {\n+                        b = c;\n+                        pmb = pmc;\n+                        pb = pc;\n+                    } else {\n+                        a = c;\n+                        pma = pmc;\n+                        pa = pc;\n+                    }\n+                    c = 0.5 * (a + b);\n+                }\n+            }\n+            final double d = numberOfPoints * (pmc - c * pc);\n+            final double w = 2 * (1 - c * c) / (d * d);\n+\n+            points[i] = c;\n+            weights[i] = w;\n+\n+            final int idx = numberOfPoints - i - 1;\n+            points[idx] = -c;\n+            weights[idx] = w;\n+        }\n+        // If \"numberOfPoints\" is odd, 0 is a root.\n+        if (numberOfPoints % 2 == 1) {\n+            double pmc = 1;\n+            for (int j = 1; j < numberOfPoints; j += 2) {\n+                pmc = -j * pmc / (j + 1);\n+            }\n+            final double d = numberOfPoints * pmc;\n+            final double w = 2 / (d * d);\n+\n+            points[iMax] = 0d;\n+            weights[iMax] = w;\n+        }\n+ \n+        return new Pair<Double[], Double[]>(points, weights);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/GaussianQuadratureAbstractTest.java\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.function.Power;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Base class for standard testing of Gaussian quadrature rules,\n+ * which are exact for polynomials up to a certain degree. In this test, each\n+ * monomial in turn is tested against the specified quadrature rule.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class GaussianQuadratureAbstractTest {\n+    /**\n+     * The maximum absolute error (for zero testing).\n+     */\n+    private final double eps;\n+    /**\n+     * The maximum relative error (in ulps).\n+     */\n+    private final double numUlps;\n+    /**\n+     * The quadrature rule under test.\n+     */\n+    private final GaussIntegrator integrator;\n+    /**\n+     * Maximum degree of monomials to be tested.\n+     */\n+    private final int maxDegree;\n+\n+    /**\n+     * Creates a new instance of this abstract test with the specified\n+     * quadrature rule.\n+     * If the expected value is non-zero, equality of actual and expected values\n+     * is checked in the relative sense <center>\n+     * |x<sub>act</sub>&nbsp;-&nbsp;x<sub>exp</sub>|&nbsp;&le;&nbsp; n&nbsp;\n+     * <code>Math.ulp(</code>x<sub>exp</sub><code>)</code>, </center> where n is\n+     * the maximum relative error (in ulps). If the expected value is zero, the\n+     * test checks that <center> |x<sub>act</sub>|&nbsp;&le;&nbsp;&epsilon;,\n+     * </center> where &epsilon; is the maximum absolute error.\n+     *\n+     * @param integrator Quadrature rule under test.\n+     * @param maxDegree Maximum degree of monomials to be tested.\n+     * @param eps &epsilon;.\n+     * @param numUlps Value of the maximum relative error (in ulps).\n+     */\n+    public GaussianQuadratureAbstractTest(GaussIntegrator integrator,\n+                                          int maxDegree,\n+                                          double eps,\n+                                          double numUlps) {\n+        this.integrator = integrator;\n+        this.maxDegree = maxDegree;\n+        this.eps = eps;\n+        this.numUlps = numUlps;\n+    }\n+\n+    /**\n+     * Returns the expected value of the integral of the specified monomial.\n+     * The integration is carried out on the natural interval of the quadrature\n+     * rule under test.\n+     *\n+     * @param n Degree of the monomial.\n+     * @return the expected value of the integral of x<sup>n</sup>.\n+     */\n+    public abstract double getExpectedValue(final int n);\n+\n+\t/**\n+\t * Checks that the value of the integral of each monomial\n+     *   <code>x<sup>0</sup>, ... , x<sup>p</sup></code>\n+     * returned by the quadrature rule under test conforms with the expected\n+     * value.\n+     * Here {@code p} denotes the degree of the highest polynomial for which\n+     * exactness is to be expected.\n+     */\n+    @Test\n+    public void testAllMonomials() {\n+        for (int n = 0; n <= maxDegree; n++) {\n+            final double expected = getExpectedValue(n);\n+\n+            final Power monomial = new Power(n);\n+            final double actual = integrator.integrate(monomial);\n+\n+            // System.out.println(n + \"/\" + maxDegree + \" \" + integrator.getNumberOfPoints()\n+            //                    + \" \" + expected + \" \" + actual + \" \" + Math.ulp(expected));\n+            if (expected == 0) {\n+                Assert.assertEquals(\"while integrating monomial x**\" + n +\n+                                    \" with a \" +\n+                                    integrator.getNumberOfPoints() + \"-point quadrature rule\",\n+                                    expected, actual, eps);\n+\t\t\t} else {\n+                double err = Math.abs(actual - expected) / Math.ulp(expected);\n+                Assert.assertEquals(\"while integrating monomial x**\" + n + \" with a \" +\n+                                    + integrator.getNumberOfPoints() + \"-point quadrature rule, \" +\n+                                    \" error was \" + err + \" ulps\",\n+                                    expected, actual, Math.ulp(expected) * numUlps);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionParametricTest.java\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test of the {@link LegendreHighPrecisionRuleFactory}.\n+ * This parameterized test extends the standard test for Gaussian quadrature\n+ * rule, where each monomial is tested in turn.\n+ * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}\n+ * quadrature rules.\n+ *\n+ * @version $Id$\n+ */\n+@RunWith(value=Parameterized.class)\n+public class LegendreHighPrecisionParametricTest extends GaussianQuadratureAbstractTest {\n+    private static GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    /**\n+     * The highest order quadrature rule to be tested.\n+     */\n+    public static final int MAX_NUM_POINTS = 30;\n+\n+    /**\n+     * Creates a new instance of this test, with the specified number of nodes\n+     * for the Gauss-Legendre quadrature rule.\n+     *\n+     * @param numberOfPoints Order of integration rule.\n+     * @param maxDegree Maximum degree of monomials to be tested.\n+     * @param eps Value of &epsilon;.\n+     * @param numUlps Value of the maximum relative error (in ulps).\n+     */\n+    public LegendreHighPrecisionParametricTest(int numberOfPoints,\n+                                               int maxDegree,\n+                                               double eps,\n+                                               double numUlps) {\n+        super(factory.legendreHighPrecision(numberOfPoints),\n+              maxDegree, eps, numUlps);\n+    }\n+\n+    /**\n+     * Returns the collection of parameters to be passed to the constructor of\n+     * this class.\n+     * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}\n+     * will be constructed.\n+     *\n+     * @return the collection of parameters for this parameterized test.\n+     */\n+    @Parameters\n+    public static Collection<Object[]> getParameters() {\n+        final ArrayList<Object[]> parameters = new ArrayList<Object[]>();\n+        for (int k = 1; k <= MAX_NUM_POINTS; k++) {\n+            parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 13d });\n+        }\n+        return parameters;\n+    }\n+\n+    @Override\n+    public double getExpectedValue(final int n) {\n+        if (n % 2 == 1) {\n+            return 0;\n+        }\n+        return 2d / (n + 1);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionTest.java\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.function.Cos;\n+import org.apache.commons.math3.analysis.function.Inverse;\n+import org.apache.commons.math3.analysis.function.Log;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Test of the {@link LegendreHighPrecisionRuleFactory}.\n+ *\n+ * @version $Id$\n+ */\n+public class LegendreHighPrecisionTest {\n+    private static GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    @Test\n+    public void testCos() {\n+        final UnivariateFunction cos = new Cos();\n+\n+        final GaussIntegrator integrator = factory.legendreHighPrecision(7, 0, Math.PI / 2);\n+        final double s = integrator.integrate(cos);\n+        // System.out.println(\"s=\" + s + \" e=\" + 1);\n+        Assert.assertEquals(1, s, Math.ulp(1d));\n+    }\n+\n+\n+    @Test\n+    public void testInverse() {\n+        final UnivariateFunction inv = new Inverse();\n+        final UnivariateFunction log = new Log();\n+\n+        final double lo = 12.34;\n+        final double hi = 456.78;\n+\n+        final GaussIntegrator integrator = factory.legendreHighPrecision(60, lo, hi);\n+        final double s = integrator.integrate(inv);\n+        final double expected = log.value(hi) - log.value(lo);\n+        // System.out.println(\"s=\" + s + \" e=\" + expected);\n+        Assert.assertEquals(expected, s, 1e-15);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreParametricTest.java\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test of the {@link LegendreRuleFactory}.\n+ * This parameterized test extends the standard test for Gaussian quadrature\n+ * rule, where each monomial is tested in turn.\n+ * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}\n+ * quadrature rules.\n+ *\n+ * @version $Id$\n+ */\n+@RunWith(value=Parameterized.class)\n+public class LegendreParametricTest extends GaussianQuadratureAbstractTest {\n+    private static GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    /**\n+     * The highest order quadrature rule to be tested.\n+     */\n+    public static final int MAX_NUM_POINTS = 30;\n+\n+    /**\n+     * Creates a new instance of this test, with the specified number of nodes\n+     * for the Gauss-Legendre quadrature rule.\n+     *\n+     * @param numberOfPoints Order of integration rule.\n+     * @param maxDegree Maximum degree of monomials to be tested.\n+     * @param eps Value of &epsilon;.\n+     * @param numUlps Value of the maximum relative error (in ulps).\n+     */\n+    public LegendreParametricTest(int numberOfPoints,\n+                                  int maxDegree,\n+                                  double eps,\n+                                  double numUlps) {\n+        super(factory.legendre(numberOfPoints),\n+              maxDegree, eps, numUlps);\n+    }\n+\n+    /**\n+     * Returns the collection of parameters to be passed to the constructor of\n+     * this class.\n+     * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}\n+     * will be constructed.\n+     *\n+     * @return the collection of parameters for this parameterized test.\n+     */\n+    @Parameters\n+    public static Collection<Object[]> getParameters() {\n+        final ArrayList<Object[]> parameters = new ArrayList<Object[]>();\n+        for (int k = 1; k <= MAX_NUM_POINTS; k++) {\n+            parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 91d });\n+        }\n+        return parameters;\n+    }\n+\n+    @Override\n+    public double getExpectedValue(final int n) {\n+        if (n % 2 == 1) {\n+            return 0;\n+        }\n+        return 2d / (n + 1);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/LegendreTest.java\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.function.Cos;\n+import org.apache.commons.math3.analysis.function.Inverse;\n+import org.apache.commons.math3.analysis.function.Log;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Test of the {@link LegendreRuleFactory}.\n+ *\n+ * @version $Id$\n+ */\n+public class LegendreTest {\n+    private static GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    @Test\n+    public void testCos() {\n+        final UnivariateFunction cos = new Cos();\n+\n+        final GaussIntegrator integrator = factory.legendre(7, 0, Math.PI / 2);\n+        final double s = integrator.integrate(cos);\n+        // System.out.println(\"s=\" + s + \" e=\" + 1);\n+        Assert.assertEquals(1, s, Math.ulp(1d));\n+    }\n+\n+\n+    @Test\n+    public void testInverse() {\n+        final UnivariateFunction inv = new Inverse();\n+        final UnivariateFunction log = new Log();\n+\n+        final double lo = 12.34;\n+        final double hi = 456.78;\n+\n+        final GaussIntegrator integrator = factory.legendre(60, lo, hi);\n+        final double s = integrator.integrate(inv);\n+        final double expected = log.value(hi) - log.value(lo);\n+        // System.out.println(\"s=\" + s + \" e=\" + expected);\n+        Assert.assertEquals(expected, s, 1e-14);\n+    }\n+}", "timestamp": 1342104198, "metainfo": ""}