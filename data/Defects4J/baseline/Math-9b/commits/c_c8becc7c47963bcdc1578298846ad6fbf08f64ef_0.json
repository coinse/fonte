{"sha": "c8becc7c47963bcdc1578298846ad6fbf08f64ef", "log": "Fixed bracketing interval balancing in BracketingNthOrderBrentSolver.  Jira: MATH-716  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n+                final int p = agingA - MAXIMAL_AGING;\n+                final double weightA = (1 << p) - 1;\n+                final double weightB = p + 1;\n+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+                final int p = agingB - MAXIMAL_AGING;\n+                final double weightA = p + 1;\n+                final double weightB = (1 << p) - 1;\n+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n     /** {@inheritDoc} */\n     @Override\n     protected int[] getQuinticEvalCounts() {\n-        return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 14};\n+        return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 16};\n     }\n \n     @Test(expected=NumberIsTooSmallException.class)\n     }\n \n     @Test\n+    public void testIssue716() {\n+        BracketingNthOrderBrentSolver solver =\n+                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\n+        UnivariateFunction sharpTurn = new UnivariateFunction() {\n+            public double value(double x) {\n+                return (2 * x + 1) / (1.0e9 * (x + 1));\n+            }\n+        };\n+        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);\n+        Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());\n+        Assert.assertTrue(sharpTurn.value(result) >= 0);\n+        Assert.assertEquals(-0.5, result, 1.0e-10);\n+    }\n+\n+    @Test\n     public void testFasterThanNewton() {\n         // the following test functions come from Beny Neta's paper:\n         // \"Several New Methods for solving Equations\"", "timestamp": 1322781876, "metainfo": ""}