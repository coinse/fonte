{"sha": "711d6b94a120d413e9d8bd21bb26ec7d0aeecc39", "log": "Modifications to the hierarchy of distributions, according to MATH-692. Patch contributed by Christian Winter.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n \n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for integer-valued discrete distributions.  Default\n      * {@inheritDoc}\n      *\n      * The default implementation uses the identity\n-     * <p>{@code P(x0 <= X <= x1) = P(X <= x1) - P(X <= x0 - 1)}</p>\n-     */\n-    public double cumulativeProbability(int x0, int x1) {\n+     * <p>{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}</p>\n+     */\n+    public double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException {\n         if (x1 < x0) {\n-            throw new NumberIsTooSmallException(\n-                    LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                    x1, x0, true);\n-        }\n-        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int inverseCumulativeProbability(final double p) {\n-        if (p < 0 || p > 1) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                    x0, x1, true);\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The default implementation returns\n+     * <ul>\n+     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n+     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n+     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n+     *     {@code 0 < p < 1}.</li>\n+     * </ul>\n+     */\n+    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple bisection.\n-        // subclasses can override if there is a better method.\n-        int x0 = getDomainLowerBound(p);\n-        int x1 = getDomainUpperBound(p);\n-        double pm;\n-        while (x0 < x1) {\n-            int xm = x0 + (x1 - x0) / 2;\n-            pm = checkedCumulativeProbability(xm);\n-            if (pm > p) {\n-                // update x1\n-                if (xm == x1) {\n-                    // this can happen with integer division\n-                    // simply decrement x1\n-                    --x1;\n-                } else {\n-                    // update x1 normally\n-                    x1 = xm;\n-                }\n+        int lower = getSupportLowerBound();\n+        if (p == 0.0) {\n+            return lower;\n+        }\n+        if (lower == Integer.MIN_VALUE) {\n+            if (checkedCumulativeProbability(lower) >= p) {\n+                return lower;\n+            }\n+        } else {\n+            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n+                        // is important for the solving step\n+        }\n+\n+        int upper = getSupportUpperBound();\n+        if (p == 1.0) {\n+            return upper;\n+        }\n+\n+        // use the one-sided Chebyshev inequality to narrow the bracket\n+        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n+        final double mu = getNumericalMean();\n+        final double sigma = FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n+        if (chebyshevApplies) {\n+            double k = FastMath.sqrt((1.0 - p) / p);\n+            double tmp = mu - k * sigma;\n+            if (tmp > lower) {\n+                lower = ((int) Math.ceil(tmp)) - 1;\n+            }\n+            k = 1.0 / k;\n+            tmp = mu + k * sigma;\n+            if (tmp < upper) {\n+                upper = ((int) Math.ceil(tmp)) - 1;\n+            }\n+        }\n+\n+        return solveInverseCumulativeProbability(p, lower, upper);\n+    }\n+\n+    /**\n+     * This is a utility function used by {@link\n+     * #inverseCumulativeProbability(double)}. It assumes {@code 0 < p < 1} and\n+     * that the inverse cumulative probability lies in the bracket {@code\n+     * (lower, upper]}. The implementation does simple bisection to find the\n+     * smallest {@code p}-quantile <code>inf{x in Z | P(X<=x) >= p}</code>.\n+     *\n+     * @param p the cumulative probability\n+     * @param lower a value satisfying {@code cumulativeProbability(lower) < p}\n+     * @param upper a value satisfying {@code p <= cumulativeProbability(upper)}\n+     * @return the smallest {@code p}-quantile of this distribution\n+     */\n+    protected int solveInverseCumulativeProbability(final double p, int lower, int upper) {\n+        while (lower + 1 < upper) {\n+            int xm = (lower + upper) / 2;\n+            if (xm < lower || xm > upper) {\n+                /*\n+                 * Overflow.\n+                 * There will never be an overflow in both calculation methods\n+                 * for xm at the same time\n+                 */\n+                xm = lower + (upper - lower) / 2;\n+            }\n+\n+            double pm = checkedCumulativeProbability(xm);\n+            if (pm >= p) {\n+                upper = xm;\n             } else {\n-                // update x0\n-                if (xm == x0) {\n-                    // this can happen with integer division\n-                    // simply increment x0\n-                    ++x0;\n-                } else {\n-                    // update x0 normally\n-                    x0 = xm;\n-                }\n-            }\n-        }\n-\n-        // insure x0 is the correct critical point\n-        pm = checkedCumulativeProbability(x0);\n-        while (pm > p) {\n-            --x0;\n-            pm = checkedCumulativeProbability(x0);\n-        }\n-\n-        return x0;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on {@code p}, used to\n-     * bracket a CDF root. This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value ({@code 0 < p < 1})\n-     * @return a domain value lower bound, i.e. a value {@code x} such that\n-     * {@code P(X <= x) < p}\n-     */\n-    protected abstract int getDomainLowerBound(double p);\n-\n-    /**\n-     * Access the domain value upper bound, based on {@code p}, used to\n-     * bracket a CDF root. This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p the desired probability for the critical value ({@code 0 < p < 1})\n-     * @return a domain value upper bound, i.e. a value {@code x} such that\n-     * {@code P(X <= x) >= p}\n-     */\n-    protected abstract int getDomainUpperBound(double p);\n+                lower = xm;\n+            }\n+        }\n+        return upper;\n+    }\n \n     /** {@inheritDoc} */\n     public void reseedRandomGenerator(long seed) {\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n         } else if (x >= numberOfTrials) {\n             ret = 1.0;\n         } else {\n-            ret = 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),\n+            ret = 1.0 - Beta.regularizedBeta(probabilityOfSuccess,\n                     x + 1.0, numberOfTrials - x);\n         }\n         return ret;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * This implementation return -1 when {@code p == 0} and\n-     * {@code Integer.MAX_VALUE} when {@code p == 1}.\n-     */\n-    @Override\n-    public int inverseCumulativeProbability(final double p) {\n-        // handle extreme values explicitly\n-        if (p == 0) {\n-            return -1;\n-        }\n-        if (p == 1) {\n-            return Integer.MAX_VALUE;\n-        }\n-\n-        // use default bisection impl\n-        return super.inverseCumulativeProbability(p);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return numberOfTrials;\n     }\n \n     /**\n      * {@code n * p}.\n      */\n     public double getNumericalMean() {\n-        return getNumberOfTrials() * getProbabilityOfSuccess();\n+        return numberOfTrials * probabilityOfSuccess;\n     }\n \n     /**\n      * {@code n * p * (1 - p)}.\n      */\n     public double getNumericalVariance() {\n-        final double p = getProbabilityOfSuccess();\n-        return getNumberOfTrials() * p * (1 - p);\n+        final double p = probabilityOfSuccess;\n+        return numberOfTrials * p * (1 - p);\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n-     * The lower bound of the support is always 0 no matter the number of trials\n-     * and probability parameter.\n+     * The lower bound of the support is always 0 except for the probability\n+     * parameter {@code p = 1}.\n      *\n-     * @return lower bound of the support (always 0)\n+     * @return lower bound of the support (0 or the number of trials)\n      */\n     public int getSupportLowerBound() {\n-        return 0;\n+        return probabilityOfSuccess < 1.0 ? 0 : numberOfTrials;\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n-     * The upper bound of the support is the number of trials.\n+     * The upper bound of the support is the number of trials except for the\n+     * probability parameter {@code p = 0}.\n      *\n-     * @return upper bound of the support (equal to number of trials)\n+     * @return upper bound of the support (number of trials or 0)\n      */\n     public int getSupportUpperBound() {\n-        return getNumberOfTrials();\n+        return probabilityOfSuccess > 0.0 ? numberOfTrials : 0;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n         return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return getLowerDomain(populationSize, numberOfSuccesses, sampleSize);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return getUpperDomain(sampleSize, numberOfSuccesses);\n-    }\n-\n     /**\n      * Return the lowest domain value for the given hypergeometric distribution\n      * parameters.\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+\n /**\n  * Interface for distributions on the integers.\n  *\n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * to this distribution, this method returns {@code P(X = x)}. In other\n-     * words, this method represents the probability mass function for the\n-     * distribution.\n+     * words, this method represents the probability mass function (PMF)\n+     * for the distribution.\n      *\n-     * @param x the point at which the probability density function is evaluated.\n-     * @return the value of the probability density function at {@code x}\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at {@code x}\n      */\n     double probability(int x);\n \n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * to this distribution, this method returns {@code P(X <= x)}.  In other\n-     * words, this method represents the probability distribution function, or\n-     * PDF for the distribution.\n+     * words, this method represents the (cumulative) distribution function\n+     * (CDF) for this distribution.\n      *\n-     * @param x the point at which the PDF is evaluated\n-     * @return PDF for this distribution.\n+     * @param x the point at which the CDF is evaluated\n+     * @return the probability that a random variable with this\n+     * distribution takes a value less than or equal to {@code x}\n      */\n     double cumulativeProbability(int x);\n \n     /**\n      * For a random variable {@code X} whose values are distributed according\n-     * to this distribution, this method returns {@code P(x0 <= X <= x1)}.\n+     * to this distribution, this method returns {@code P(x0 < X <= x1)}.\n      *\n-     * @param x0 the inclusive lower bound\n+     * @param x0 the exclusive lower bound\n      * @param x1 the inclusive upper bound\n-     * @return the cumulative probability\n-     * @throws IllegalArgumentException if {@code x0 > x1}\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between {@code x0} and {@code x1},\n+     * excluding the lower and including the upper endpoint\n+     * @throws NumberIsTooLargeException if {@code x0 > x1}\n      */\n-    double cumulativeProbability(int x0, int x1);\n+    double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException;\n \n     /**\n-     * For this distribution, {@code X}, this method returns the largest\n-     * {@code x} such that {@code P(X <= x) <= p}.\n-     * <br/>\n-     * Note that this definition implies:\n+     * Computes the quantile function of this distribution.\n+     * For a random variable {@code X} distributed according to this distribution,\n+     * the returned value is\n      * <ul>\n-     *  <li> If there is a minimum value, {@code m}, with positive\n-     *   probability under (the density of) {@code X}, then {@code m - 1} is\n-     *   returned by {@code inverseCumulativeProbability(0).}  If there is\n-     *   no such value {@code m},  {@code Integer.MIN_VALUE} is returned.\n-     *  </li>\n-     *  <li> If there is a maximum value, {@code M}, such that\n-     *   {@code P(X <= M) = 1}, then {@code M} is returned by\n-     *   {@code inverseCumulativeProbability(1)}.\n-     *   If there is no such value, {@code M}, {@code Integer.MAX_VALUE} is\n-     *   returned.\n-     *  </li>\n+     * <li><code>inf{x in Z | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>\n+     * <li><code>inf{x in Z | P(X<=x) > 0}</code> for {@code p = 0}.</li>\n      * </ul>\n+     * If the result exceeds the range of the data type {@code int},\n+     * then {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.\n      *\n      * @param p the cumulative probability\n-     * @return the largest {@code x} such that {@code P(X < x) <= p}\n-     * @throws IllegalArgumentException if {@code p} is not between 0 and 1\n-     * (inclusive)\n+     * @return the smallest {@code p}-quantile of this distribution\n+     * (largest 0-quantile for {@code p = 0})\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}\n      */\n-    int inverseCumulativeProbability(double p);\n+    int inverseCumulativeProbability(double p) throws OutOfRangeException;\n \n     /**\n      * Use this method to get the numerical value of the mean of this\n     double getNumericalVariance();\n \n     /**\n-     * Access the lower bound of the support.\n+     * Access the lower bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(0)}. In other words, this\n+     * method must return\n+     * <p><code>inf {x in Z | P(X <= x) > 0}</code>.</p>\n      *\n      * @return lower bound of the support ({@code Integer.MIN_VALUE}\n      * for negative infinity)\n     int getSupportLowerBound();\n \n     /**\n-     * Access the upper bound of the support.\n+     * Access the upper bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(1)}. In other words, this\n+     * method must return\n+     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>\n      *\n      * @return upper bound of the support ({@code Integer.MAX_VALUE}\n      * for positive infinity)\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.ArithmeticUtils;\n     private final double probabilityOfSuccess;\n \n     /**\n-     * Create a Pascal distribution with the given number of trials and\n+     * Create a Pascal distribution with the given number of successes and\n      * probability of success.\n      *\n      * @param r Number of successes.\n      * @param p Probability of success.\n-     * @throws NotPositiveException if the number of successes is not positive\n+     * @throws NotStrictlyPositiveException if the number of successes is not positive\n      * @throws OutOfRangeException if the probability of success is not in the\n      * range [0, 1]\n      */\n     public PascalDistribution(int r, double p)\n-        throws NotPositiveException, OutOfRangeException {\n-        if (r < 0) {\n-            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+        throws NotStrictlyPositiveException, OutOfRangeException {\n+        if (r <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n                                            r);\n         }\n         if (p < 0 || p > 1) {\n     /**\n      * {@inheritDoc}\n      *\n-     * Returns {@code -1} when {@code p == 0} and\n-     * {@code Integer.MAX_VALUE} when {@code p == 1}.\n-     */\n-    @Override\n-    public int inverseCumulativeProbability(final double p) {\n-        int ret;\n-\n-        // handle extreme values explicitly\n-        if (p == 0) {\n-            ret = -1;\n-        } else if (p == 1) {\n-            ret = Integer.MAX_VALUE;\n-        } else {\n-            ret = super.inverseCumulativeProbability(p);\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return -1;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        // use MAX - 1 because MAX causes loop\n-        return Integer.MAX_VALUE - 1;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n      * For number of successes {@code r} and probability of success {@code p},\n      * the mean is {@code r * (1 - p) / p}.\n      */\n      * {@inheritDoc}\n      *\n      * The upper bound of the support is always positive infinity no matter the\n-     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}.\n+     * parameters. Positive infinity is symbolized by {@code Integer.MAX_VALUE}.\n      *\n      * @return upper bound of the support (always {@code Integer.MAX_VALUE}\n      * for positive infinity)\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n         return normal.cumulativeProbability(x + 0.5);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(double p) {\n-        return Integer.MAX_VALUE;\n-    }\n-\n     /**\n      * {@inheritDoc}\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n         return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainLowerBound(final double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected int getDomainUpperBound(final double p) {\n-        return numberOfElements;\n-    }\n-\n     /**\n      * {@inheritDoc}\n      *\n     }\n \n     /**\n-     * used by {@link #getNumericalVariance()}\n+     * Used by {@link #getNumericalVariance()}.\n      *\n      * @return the variance of this distribution\n      */\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n      * @since 2.2\n      */\n     public int nextInversionDeviate(IntegerDistribution distribution) {\n-        final double target = nextUniform(0, 1);\n-        final int glb = distribution.inverseCumulativeProbability(target);\n-        if (distribution.cumulativeProbability(glb) == 1.0d) { // No mass above\n-            return glb;\n-        } else {\n-            return glb + 1;\n-        }\n+        return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n     }\n \n     // ------------------------Private methods----------------------------------\n--- a/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n  * @version $Id$\n  */\n public class AbtractIntegerDistributionTest {\n-\n     protected final DiceDistribution diceDistribution = new DiceDistribution();\n     protected final double p = diceDistribution.probability(1);\n-    \n+\n     @Test\n-    public void testCumulativeProbabilitiesSingleIntegerArguments() throws Exception {\n-        int lower = 1;\n+    public void testCumulativeProbabilitiesSingleArguments() throws Exception {\n         for (int i = 1; i < 7; i++) {\n             Assert.assertEquals(p * i,\n-                    diceDistribution.cumulativeProbability(lower), Double.MIN_VALUE);\n-            lower++;\n+                    diceDistribution.cumulativeProbability(i), Double.MIN_VALUE);\n         }\n-        Assert.assertEquals(0,\n-                diceDistribution.cumulativeProbability(-1), Double.MIN_VALUE);\n-        Assert.assertEquals(1,\n+        Assert.assertEquals(0.0,\n+                diceDistribution.cumulativeProbability(0), Double.MIN_VALUE);\n+        Assert.assertEquals(1.0,\n                 diceDistribution.cumulativeProbability(7), Double.MIN_VALUE);\n     }\n-    \n+\n     @Test\n     public void testCumulativeProbabilitiesRangeArguments() throws Exception {\n-        int lower = 1;\n+        int lower = 0;\n         int upper = 6;\n         for (int i = 0; i < 2; i++) {\n-            // cum(1,6) = p(1 <= X <= 6) = 1, cum(2,5) = 4/6, cum(3,4) = 2/6 \n-            Assert.assertEquals(1 - p * 2 * i, \n+            // cum(0,6) = p(0 < X <= 6) = 1, cum(1,5) = 4/6, cum(2,4) = 2/6\n+            Assert.assertEquals(1 - p * 2 * i,\n                     diceDistribution.cumulativeProbability(lower, upper), 1E-12);\n             lower++;\n             upper--;\n         }\n-        for (int i = 1; i < 7; i++) {\n-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(i, i), 1E-12);\n+        for (int i = 0; i < 6; i++) {\n+            Assert.assertEquals(p, diceDistribution.cumulativeProbability(i, i+1), 1E-12);\n         }\n     }\n-    \n+\n     /**\n      * Simple distribution modeling a 6-sided die\n      */\n             }\n         }\n \n-        @Override\n-        protected int getDomainLowerBound(double p) {\n-            return 1;\n-        }\n-\n-        @Override\n-        protected int getDomainUpperBound(double p) {\n-            return 6;\n-        }\n-\n         public double getNumericalMean() {\n             return 3.5;\n         }\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n      */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-        return new int[] { -1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE };\n+        return new int[] { 0, 2, 3, 4, 5, 5, 10, 10, 10, 9, 9, 10 };\n     }\n \n     // ----------------- Additional test cases ---------------------------------\n     /** Test degenerate case p = 0 */\n     @Test\n     public void testDegenerate0() throws Exception {\n-        setDistribution(new BinomialDistribution(5, 0.0d));\n+        BinomialDistribution dist = new BinomialDistribution(5, 0.0d);\n+        setDistribution(dist);\n         setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });\n         setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });\n         setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });\n         setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });\n         setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });\n-        setInverseCumulativeTestValues(new int[] { -1, -1 });\n+        setInverseCumulativeTestValues(new int[] { 0, 0 });\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        Assert.assertEquals(dist.getSupportLowerBound(), 0);\n+        Assert.assertEquals(dist.getSupportUpperBound(), 0);\n     }\n \n     /** Test degenerate case p = 1 */\n     @Test\n     public void testDegenerate1() throws Exception {\n-        setDistribution(new BinomialDistribution(5, 1.0d));\n+        BinomialDistribution dist = new BinomialDistribution(5, 1.0d);\n+        setDistribution(dist);\n         setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });\n         setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });\n         setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });\n         setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });\n         setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });\n-        setInverseCumulativeTestValues(new int[] { 4, 4 });\n+        setInverseCumulativeTestValues(new int[] { 5, 5 });\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        Assert.assertEquals(dist.getSupportLowerBound(), 5);\n+        Assert.assertEquals(dist.getSupportUpperBound(), 5);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new HypergeometricDistribution(10,5, 5);\n+        return new HypergeometricDistribution(10, 5, 5);\n     }\n \n     /** Creates the default probability density test input values */\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};\n+        return new int[] {0, 0, 1, 1, 1, 1, 5, 4, 4, 4, 4, 5};\n     }\n \n     //-------------------- Additional test cases ------------------------------\n     /** Verify that if there are no failures, mass is concentrated on sampleSize */\n     @Test\n     public void testDegenerateNoFailures() throws Exception {\n-        setDistribution(new HypergeometricDistribution(5,5,3));\n+        HypergeometricDistribution dist = new HypergeometricDistribution(5,5,3);\n+        setDistribution(dist);\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n         setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});\n         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {2, 2});\n+        setInverseCumulativeTestValues(new int[] {3, 3});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        Assert.assertEquals(dist.getSupportLowerBound(), 3);\n+        Assert.assertEquals(dist.getSupportUpperBound(), 3);\n     }\n \n     /** Verify that if there are no successes, mass is concentrated on 0 */\n     @Test\n     public void testDegenerateNoSuccesses() throws Exception {\n-        setDistribution(new HypergeometricDistribution(5,0,3));\n+        HypergeometricDistribution dist = new HypergeometricDistribution(5,0,3);\n+        setDistribution(dist);\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n         setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});\n         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        setInverseCumulativeTestValues(new int[] {0, 0});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        Assert.assertEquals(dist.getSupportLowerBound(), 0);\n+        Assert.assertEquals(dist.getSupportUpperBound(), 0);\n     }\n \n     /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */\n     @Test\n     public void testDegenerateFullSample() throws Exception {\n-        setDistribution(new HypergeometricDistribution(5,3,5));\n+        HypergeometricDistribution dist = new HypergeometricDistribution(5,3,5);\n+        setDistribution(dist);\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n         setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});\n         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {2, 2});\n+        setInverseCumulativeTestValues(new int[] {3, 3});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n+        Assert.assertEquals(dist.getSupportLowerBound(), 3);\n+        Assert.assertEquals(dist.getSupportUpperBound(), 3);\n     }\n \n     @Test\n         HypergeometricDistribution dist = new HypergeometricDistribution(populationSize, numberOfSucceses, sampleSize);\n         for (int i = 0; i < data.length; ++i) {\n             int x = (int)data[i][0];\n-            double pdf = data[i][1];\n-            double actualPdf = dist.probability(x);\n-            TestUtils.assertRelativelyEquals(\"Expected equals for <\"+x+\"> pdf\",pdf, actualPdf, 1.0e-9);\n+            double pmf = data[i][1];\n+            double actualPmf = dist.probability(x);\n+            TestUtils.assertRelativelyEquals(\"Expected equals for <\"+x+\"> pmf\",pmf, actualPmf, 1.0e-9);\n \n             double cdf = data[i][2];\n             double actualCdf = dist.cumulativeProbability(x);\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    @Test\n+    public void testConsistencyAtSupportBounds() {\n+        final int lower = distribution.getSupportLowerBound();\n+        Assert.assertEquals(\"Cumulative probability mmust be 0 below support lower bound.\",\n+                0.0, distribution.cumulativeProbability(lower - 1), 0.0);\n+        Assert.assertEquals(\"Cumulative probability of support lower bound must be equal to probability mass at this point.\",\n+                distribution.probability(lower), distribution.cumulativeProbability(lower), tolerance);\n+        Assert.assertEquals(\"Inverse cumulative probability of 0 must be equal to support lower bound.\",\n+                lower, distribution.inverseCumulativeProbability(0.0));\n+\n+        final int upper = distribution.getSupportUpperBound();\n+        if (upper != Integer.MAX_VALUE)\n+            Assert.assertEquals(\"Cumulative probability of support upper bound must be equal to 1.\",\n+                    1.0, distribution.cumulativeProbability(upper), 0.0);\n+        Assert.assertEquals(\"Inverse cumulative probability of 1 must be equal to support upper bound.\",\n+                upper, distribution.inverseCumulativeProbability(1.0));\n+    }\n+\n     /**\n      * Verifies that illegal arguments are correctly handled\n      */\n             // expected\n         }\n     }\n-    \n+\n     /**\n      * Test sampling\n      */\n--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n-      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n-          0.990d, 0.975d, 0.950d, 0.900d, 1};\n+      return new double[] {0.0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.999,\n+          0.990, 0.975, 0.950, 0.900, 1.0};\n         }\n \n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};\n+      return new int[] {0, 0, 0, 0, 1, 1, 14, 11, 10, 9, 8, Integer.MAX_VALUE};\n     }\n \n     //----------------- Additional test cases ---------------------------------\n     /** Test degenerate case p = 0   */\n     @Test\n     public void testDegenerate0() throws Exception {\n-        setDistribution(new PascalDistribution(5,0.0d));\n+        setDistribution(new PascalDistribution(5, 0.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});\n         setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});\n         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});\n+        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE, Integer.MAX_VALUE});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n     /** Test degenerate case p = 1   */\n     @Test\n     public void testDegenerate1() throws Exception {\n-        setDistribution(new PascalDistribution(5,1.0d));\n+        setDistribution(new PascalDistribution(5, 1.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});\n         setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});\n         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});\n-        setInverseCumulativeTestValues(new int[] {-1, -1});\n+        setInverseCumulativeTestValues(new int[] {0, 0});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n \n     /**\n      * Creates the default inverse cumulative probability test input values.\n-     * Increased 3rd and 7th values slightly as computed cumulative\n-     * probabilities for corresponding values exceeds the target value (still\n-     * within tolerance).\n      */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n-        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,\n-                0.238103305554d, 0.433470120367d, 0.62883693518,\n-                0.78513038704d,  0.99716023388d, 0.999999998077 };\n+        IntegerDistribution dist = getDistribution();\n+        return new double[] { 0d, 0.018315638886d, 0.018315638890d,\n+                0.091578194441d, 0.091578194445d, 0.238103305552d,\n+                0.238103305556d, dist.cumulativeProbability(3),\n+                dist.cumulativeProbability(4), dist.cumulativeProbability(5),\n+                dist.cumulativeProbability(10), dist.cumulativeProbability(20)};\n     }\n \n     /**\n      */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};\n+        return new int[] { 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 10, 20};\n     }\n \n     /**\n     public void testDegenerateInverseCumulativeProbability() throws Exception {\n         PoissonDistribution dist = new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);\n         Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n-        Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));\n+        Assert.assertEquals(0, dist.inverseCumulativeProbability(0d));\n     }\n \n     @Test(expected=NotStrictlyPositiveException.class)\n                 try {\n                     int ret = dist.inverseCumulativeProbability(p);\n                     // Verify that returned value satisties definition\n-                    Assert.assertTrue(p >= dist.cumulativeProbability(ret));\n-                    Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));\n+                    Assert.assertTrue(p <= dist.cumulativeProbability(ret));\n+                    Assert.assertTrue(p > dist.cumulativeProbability(ret - 1));\n                 } catch (Exception ex) {\n                     Assert.fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n                 }\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n-        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d, 1};\n+        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.3413d, 0.3415d, 0.999d,\n+                0.990d, 0.975d, 0.950d, 0.900d, 1d};\n         }\n \n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n-        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n+        return new int[] {1, 1, 1, 1, 1, 1, 2, 10, 10, 10, 9, 8, 10};\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/random/ISAACTest.java\n+++ b/src/test/java/org/apache/commons/math/random/ISAACTest.java\n \n     @Override\n     protected RandomGenerator makeGenerator() {\n-        return new ISAACRandom(1000);\n+        return new ISAACRandom(500);\n     }\n \n     private static final int[] SEED_1 = {\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n         }\n \n         // Set bin width for interior bins.  For poisson, only need to look at end bins.\n-        int binWidth = 1;\n+        int binWidth = 0;\n         boolean widthSufficient = false;\n         double lowerBinMass = 0;\n         double upperBinMass = 0;\n         while (!widthSufficient) {\n-            lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);\n-            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);\n+            binWidth++;\n+            lowerBinMass = poissonDistribution.cumulativeProbability(lower - 1, lower + binWidth - 1);\n+            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth - 1, upper - 1);\n             widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n-            binWidth++;\n         }\n \n         /*\n             binBounds.add(bound);\n             bound += binWidth;\n         }\n-        binBounds.add(bound);\n-        binBounds.add(upper);\n+        binBounds.add(upper); // The size of bin [binBounds[binCount - 2], upper) satisfies binWidth <= size < 2*binWidth.\n \n         // Compute observed and expected bin counts\n         final int binCount = binBounds.size() + 1;\n             observed[i] = 0;\n             for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {\n                 observed[i] += frequency.getCount(j);\n-            } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize\n+            } // Expected count is (mass in [binBounds[i-1], binBounds[i])) * sampleSize\n             expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -\n                 poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;\n         }\n         }\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n-    \n+\n     @Test\n     /**\n      * MATH-720\n--- a/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n- \n+\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n /**\n  * Base class for RandomGenerator tests.\n- * \n- * Tests RandomGenerator methods directly and also executes RandomDataTest \n+ *\n+ * Tests RandomGenerator methods directly and also executes RandomDataTest\n  * test cases against a RandomDataImpl created using the provided generator.\n- * \n+ *\n  * RandomGenerator test classes should extend this class, implementing\n  * makeGenerator() to provide a concrete generator to test. The generator\n  * returned by makeGenerator should be seeded with a fixed seed.\n \n     /** RandomGenerator under test */\n     protected RandomGenerator generator;\n-    \n-    /** \n-     * Override this method in subclasses to provide a concrete generator to test.  \n+\n+    /**\n+     * Override this method in subclasses to provide a concrete generator to test.\n      * Return a generator seeded with a fixed seed.\n      */\n     protected abstract RandomGenerator makeGenerator();\n         generator = makeGenerator();\n         randomData = new RandomDataImpl(generator);\n     }\n-    \n+\n     /**\n      * Set a fixed seed for the tests\n      */\n      * the expected uniform distribution.  Tests are performed at the .01\n      * level and an average failure rate higher than 2% (i.e. more than 20\n      * null hypothesis rejections) causes the test case to fail.\n-     * \n+     *\n      * All random values are generated using the generator instance used by\n      * other tests and the generator is not reseeded, so this is a fixed seed\n      * test.\n             final int val = generator.nextInt();\n             testValues[i] = val < 0 ? -val : val + 1;\n         }\n-        \n+\n         final int numTests = 1000;\n         for (int i = 0; i < testValues.length; i++) {\n             final int n = testValues[i];\n                     binUpperBounds[k] = (k + 1) * step;\n                 }\n                 binUpperBounds[9] = n - 1;\n-            }  \n+            }\n             // Run the tests\n             int numFailures = 0;\n             final int binCount = binUpperBounds.length;\n             expected[0] = binUpperBounds[0] == 0 ? (double) smallSampleSize / (double) n :\n                 (double) ((binUpperBounds[0] + 1) * smallSampleSize) / (double) n;\n             for (int k = 1; k < binCount; k++) {\n-                expected[k] = (double) smallSampleSize * \n+                expected[k] = (double) smallSampleSize *\n                 (double) (binUpperBounds[k] - binUpperBounds[k - 1]) / (double) n;\n             }\n             for (int j = 0; j < numTests; j++) {\n                 }\n                 if (testStatistic.chiSquareTest(expected, observed) < 0.01) {\n                     numFailures++;\n-                }  \n+                }\n             }\n             if ((double) numFailures / (double) numTests > 0.02) {\n                 Assert.fail(\"Too many failures for n = \" + n +\n             }\n         }\n     }\n-    \n+\n     @Test(expected=MathIllegalArgumentException.class)\n     public void testNextIntIAE() {\n         try {\n     @Test\n     public void testDoubleDirect() {\n         SummaryStatistics sample = new SummaryStatistics();\n-        for (int i = 0; i < 10000; ++i) {\n+        final int N = 10000;\n+        for (int i = 0; i < N; ++i) {\n             sample.addValue(generator.nextDouble());\n         }\n-        Assert.assertEquals(0.5, sample.getMean(), 0.02);\n+        Assert.assertEquals(\"Note: This test will fail randomly about 1 in 100 times.\",\n+                0.5, sample.getMean(), FastMath.sqrt(N/12.0) * 2.576);\n         Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n-                     sample.getStandardDeviation(),\n-                     0.01);\n+                     sample.getStandardDeviation(), 0.01);\n     }\n \n     @Test\n     public void testFloatDirect() {\n         SummaryStatistics sample = new SummaryStatistics();\n-        for (int i = 0; i < 1000; ++i) {\n+        final int N = 1000;\n+        for (int i = 0; i < N; ++i) {\n             sample.addValue(generator.nextFloat());\n         }\n-        Assert.assertEquals(0.5, sample.getMean(), 0.01);\n+        Assert.assertEquals(\"Note: This test will fail randomly about 1 in 100 times.\",\n+                0.5, sample.getMean(), FastMath.sqrt(N/12.0) * 2.576);\n         Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n-                     sample.getStandardDeviation(),\n-                     0.01);\n+                     sample.getStandardDeviation(), 0.01);\n     }\n \n     @Test(expected=MathIllegalArgumentException.class)\n     @Test\n     public void testNextInt2() {\n         int walk = 0;\n-        for (int k = 0; k < 10000; ++k) {\n+        final int N = 10000;\n+        for (int k = 0; k < N; ++k) {\n            if (generator.nextInt() >= 0) {\n                ++walk;\n            } else {\n                --walk;\n            }\n         }\n-        Assert.assertTrue(\"Walked too far astray: \" + walk, FastMath.abs(walk) < 120);\n+        Assert.assertTrue(\"Walked too far astray: \" + walk + \"\\nNote: This \" +\n+        \t\t\"test will fail randomly about 1 in 100 times.\",\n+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);\n     }\n \n     @Test\n     public void testNextLong2() {\n         int walk = 0;\n-        for (int k = 0; k < 1000; ++k) {\n+        final int N = 1000;\n+        for (int k = 0; k < N; ++k) {\n            if (generator.nextLong() >= 0) {\n                ++walk;\n            } else {\n                --walk;\n            }\n         }\n-        Assert.assertTrue(\"Walked too far astray: \" + walk, FastMath.abs(walk) < 100);\n+        Assert.assertTrue(\"Walked too far astray: \" + walk + \"\\nNote: This \" +\n+        \t\t\"test will fail randomly about 1 in 100 times.\",\n+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);\n     }\n \n     @Test\n     public void testNexBoolean2() {\n         int walk = 0;\n-        for (int k = 0; k < 10000; ++k) {\n+        final int N = 10000;\n+        for (int k = 0; k < N; ++k) {\n            if (generator.nextBoolean()) {\n                ++walk;\n            } else {\n                --walk;\n            }\n         }\n-        Assert.assertTrue(FastMath.abs(walk) < 250);\n+        Assert.assertTrue(\"Walked too far astray: \" + walk + \"\\nNote: This \" +\n+        \t\t\"test will fail randomly about 1 in 100 times.\",\n+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);\n     }\n \n     @Test\n         byte[] bytes = new byte[10];\n         double[] expected = new double[256];\n         final int sampleSize = 100000;\n-        \n+\n         for (int i = 0; i < 256; i++) {\n             expected[i] = (double) sampleSize / 265f;\n         }\n-        \n+\n         for (int k = 0; k < sampleSize; ++k) {\n            generator.nextBytes(bytes);\n            for (byte b : bytes) {\n                ++count[b + 128];\n            }\n         }\n-        \n+\n         TestUtils.assertChiSquareAccept(expected, count, 0.001);\n-        \n-    }\n-    \n+\n+    }\n+\n     @Test\n     public void testSeeding() throws Exception {\n         // makeGenerator initializes with fixed seed\n         gen1.setSeed(100);\n         checkSameSequence(gen, gen1);\n     }\n-    \n+\n     private void checkSameSequence(RandomGenerator gen1, RandomGenerator gen2) throws Exception {\n         final int len = 11;  // Needs to be an odd number to check MATH-723\n         final double[][] values = new double[2][len];\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextDouble();\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextFloat();\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextFloat();\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextInt();\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextInt();\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextLong();\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextLong();\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextInt(len);\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextInt(len);\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextBoolean() ? 1 : 0;\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextBoolean() ? 1 : 0;\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1]));  \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n         for (int i = 0; i < len; i++) {\n             values[0][i] = gen1.nextGaussian();\n         }\n         for (int i = 0; i < len; i++) {\n             values[1][i] = gen2.nextGaussian();\n         }\n-        Assert.assertTrue(Arrays.equals(values[0], values[1])); \n+        Assert.assertTrue(Arrays.equals(values[0], values[1]));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/random/Well1024aTest.java\n+++ b/src/test/java/org/apache/commons/math/random/Well1024aTest.java\n \n     @Override\n     protected RandomGenerator makeGenerator() {\n-        return new Well1024a(100);\n+        return new Well1024a(1000);\n     }\n-    \n+\n     @Test\n     public void testReferenceCode() {\n         Well1024a mt = new Well1024a(new int[] {", "timestamp": 1325308728, "metainfo": ""}