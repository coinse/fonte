{"sha": "1a1471b9ad5ca60a345e5c85a902bab167426538", "log": "fixed behavior of nextAfter(double, double) for infinity, added nextAfter(float, float) and nextUp(float) JIRA: MATH-478  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n         return nextAfter(a, Double.POSITIVE_INFINITY);\n     }\n \n+    /** Compute next number towards positive infinity.\n+     * @param a number to which neighbor should be computed\n+     * @return neighbor of a towards positive infinity\n+     */\n+    public static float nextUp(final float a) {\n+        return nextAfter(a, Float.POSITIVE_INFINITY);\n+    }\n+\n     /** Returns a pseudo-random number between 0.0 and 1.0.\n      * @return a random number between 0.0 and 1.0\n      */\n     public static double nextAfter(double d, double direction) {\n \n         // handling of some important special cases\n-        if (Double.isNaN(d) || Double.isInfinite(d)) {\n+        if (Double.isNaN(d)) {\n             return d;\n+        } else if (Double.isInfinite(d)) {\n+            if (d < direction) {\n+                return -Double.MAX_VALUE;\n+            } else if (direction < d) {\n+                return Double.MAX_VALUE;\n+            } else {\n+                return d;\n+            }\n         } else if (d == 0) {\n             return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n         }\n \n     }\n \n+    /**\n+     * Get the next machine representable number after a number, moving\n+     * in the direction of another number.\n+     * <p>\n+     * If <code>direction</code> is greater than or equal to<code>d</code>,\n+     * the smallest machine representable number strictly greater than\n+     * <code>d</code> is returned; otherwise the largest representable number\n+     * strictly less than <code>d</code> is returned.</p>\n+     * <p>\n+     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n+     *\n+     * @param f base number\n+     * @param direction (the only important thing is whether\n+     * direction is greater or smaller than f)\n+     * @return the next machine representable number in the specified direction\n+     */\n+    public static float nextAfter(float f, float direction) {\n+\n+        // handling of some important special cases\n+        if (Float.isNaN(f)) {\n+            return f;\n+        } else if (Float.isInfinite(f)) {\n+            if (f < direction) {\n+                return -Float.MAX_VALUE;\n+            } else if (direction < f) {\n+                return Float.MAX_VALUE;\n+            } else {\n+                return f;\n+            }\n+        } else if (f == 0f) {\n+            return (direction < 0f) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n+        }\n+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n+        // are handled just as normal numbers\n+\n+        // split the double in raw components\n+        int bits     = Float.floatToIntBits(f);\n+        int sign     = bits & 0x80000000;\n+        int exponent = bits & 0x7f800000;\n+        int mantissa = bits & 0x007fffff;\n+\n+        if (f * (direction - f) >= 0f) {\n+            // we should increase the mantissa\n+            if (mantissa == 0x000fffff) {\n+                return Float.intBitsToFloat(sign | (exponent + 0x00800000));\n+            } else {\n+                return Float.intBitsToFloat(sign | exponent | (mantissa + 1));\n+            }\n+        } else {\n+            // we should decrease the mantissa\n+            if (mantissa == 0) {\n+                return Float.intBitsToFloat(sign | (exponent - 0x00800000) | 0x007fffff);\n+            } else {\n+                return Float.intBitsToFloat(sign | exponent | (mantissa - 1));\n+            }\n+        }\n+\n+    }\n+\n     /** Get the largest whole number smaller than x.\n      * @param x number from which floor is requested\n      * @return a double number f such that f is an integer f <= x < f + 1.0\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n         }\n         void check(Method mathMethod, double d, Object expected, Object actual, int entry){\n             if (!expected.equals(actual)){\n-                reportError(mathMethod.getName()+\"(float \"+d+\") expected \"+expected+\" actual \"+actual+ \" entry \"+entry);\n+                reportError(mathMethod.getName()+\"(double \"+d+\") expected \"+expected+\" actual \"+actual+ \" entry \"+entry);\n             }            \n         }\n     }", "timestamp": 1295562836, "metainfo": ""}