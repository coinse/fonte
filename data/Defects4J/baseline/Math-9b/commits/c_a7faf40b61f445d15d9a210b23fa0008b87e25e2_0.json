{"sha": "a7faf40b61f445d15d9a210b23fa0008b87e25e2", "log": "separated iteration counter from function evaluation counters, some optimizers are based on gradient/jacobian only and cannot reliably be protected by monitoring the objective function calls.  We now have two or three counters for each algorithm:  - iteration counter, which is checked against a max allowance    to prevent infinite loops if no convergence is reached  - objective function evaluations, for user information only  - objective function gradient/jacobian if the function is    differentiable, for user information only  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"equals vertices {0} and {1} in simplex configuration\",\n       \"sommets {0} et {1} \\u00e9gaux dans la configuration du simplex\" },\n \n-    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n-    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n+    // org.apache.commons.math.estimation.AbstractEstimation\n     { \"maximal number of evaluations exceeded ({0})\",\n       \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n \n--- a/src/java/org/apache/commons/math/optimization/MultiStartScalarDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartScalarDifferentiableOptimizer.java\n public class MultiStartScalarDifferentiableOptimizer implements ScalarDifferentiableOptimizer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 9008747186334431824L;\n+    private static final long serialVersionUID = 6185821146433609962L;\n \n     /** Underlying classical optimizer. */\n     private final ScalarDifferentiableOptimizer optimizer;\n \n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n \n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n+    /** Number of gradient evaluations already performed for all starts. */\n+    private int totalGradientEvaluations;\n \n     /** Number of starts to go. */\n     private int starts;\n     public MultiStartScalarDifferentiableOptimizer(final ScalarDifferentiableOptimizer optimizer,\n                                                    final int starts,\n                                                    final RandomVectorGenerator generator) {\n-        this.optimizer        = optimizer;\n-        this.totalEvaluations = 0;\n-        this.maxEvaluations   = Integer.MAX_VALUE;\n-        this.starts           = starts;\n-        this.generator        = generator;\n-        this.optima           = null;\n+        this.optimizer                = optimizer;\n+        this.maxIterations            = Integer.MAX_VALUE;\n+        this.totalIterations          = 0;\n+        this.totalEvaluations         = 0;\n+        this.totalGradientEvaluations = 0;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n     }\n \n     /** Get all the optima found during the last call to {@link\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getEvaluations() {\n         return totalEvaluations;\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n+    public int getGradientEvaluations() {\n+        return totalGradientEvaluations;\n     }\n \n     /** {@inheritDoc} */\n                                          double[] startPoint)\n         throws ObjectiveException, OptimizationException {\n \n-        optima = new ScalarPointValuePair[starts];\n-        totalEvaluations = 0;\n+        optima                   = new ScalarPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n+        totalGradientEvaluations = 0;\n \n         // multi-start loop\n         for (int i = 0; i < starts; ++i) {\n \n             try {\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n                 optima[i] = optimizer.optimize(f, goalType,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (ObjectiveException obe) {\n                 optima[i] = null;\n             }\n \n-            totalEvaluations += optimizer.getEvaluations();\n+            totalIterations          += optimizer.getIterations();\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalGradientEvaluations += optimizer.getGradientEvaluations();\n \n         }\n \n--- a/src/java/org/apache/commons/math/optimization/MultiStartScalarOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartScalarOptimizer.java\n public class MultiStartScalarOptimizer implements ScalarOptimizer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 6648351778723282863L;\n+    private static final long serialVersionUID = -7333253288301713047L;\n \n     /** Underlying classical optimizer. */\n     private final ScalarOptimizer optimizer;\n \n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n \n     /** Number of starts to go. */\n     private int starts;\n     public MultiStartScalarOptimizer(final ScalarOptimizer optimizer, final int starts,\n                                      final RandomVectorGenerator generator) {\n         this.optimizer        = optimizer;\n+        this.maxIterations    = Integer.MAX_VALUE;\n+        this.totalIterations  = 0;\n         this.totalEvaluations = 0;\n-        this.maxEvaluations   = Integer.MAX_VALUE;\n         this.starts           = starts;\n         this.generator        = generator;\n         this.optima           = null;\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getEvaluations() {\n         return totalEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n     }\n \n     /** {@inheritDoc} */\n                                          double[] startPoint)\n         throws ObjectiveException, OptimizationException {\n \n-        optima = new ScalarPointValuePair[starts];\n+        optima           = new ScalarPointValuePair[starts];\n+        totalIterations  = 0;\n         totalEvaluations = 0;\n \n         // multi-start loop\n         for (int i = 0; i < starts; ++i) {\n \n             try {\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n                 optima[i] = optimizer.optimize(f, goalType,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (ObjectiveException obe) {\n                 optima[i] = null;\n             }\n \n+            totalIterations  += optimizer.getIterations();\n             totalEvaluations += optimizer.getEvaluations();\n \n         }\n--- a/src/java/org/apache/commons/math/optimization/MultiStartVectorialDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartVectorialDifferentiableOptimizer.java\n public class MultiStartVectorialDifferentiableOptimizer implements VectorialDifferentiableOptimizer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -6671992853686531955L;\n+    private static final long serialVersionUID = -9109278856437190136L;\n \n     /** Underlying classical optimizer. */\n     private final VectorialDifferentiableOptimizer optimizer;\n \n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n \n     /** Number of jacobian evaluations already performed for all starts. */\n     private int totalJacobianEvaluations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n \n     /** Number of starts to go. */\n     private int starts;\n                                                       final int starts,\n                                                       final RandomVectorGenerator generator) {\n         this.optimizer                = optimizer;\n+        this.maxIterations            = Integer.MAX_VALUE;\n+        this.totalIterations          = 0;\n         this.totalEvaluations         = 0;\n         this.totalJacobianEvaluations = 0;\n-        this.maxEvaluations           = Integer.MAX_VALUE;\n         this.starts                   = starts;\n         this.generator                = generator;\n         this.optima                   = null;\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getEvaluations() {\n         return totalEvaluations;\n     }\n     /** {@inheritDoc} */\n     public int getJacobianEvaluations() {\n         return totalJacobianEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n     }\n \n     /** {@inheritDoc} */\n                                             final double[] startPoint)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n-        optima = new VectorialPointValuePair[starts];\n-        totalEvaluations = 0;\n+        optima                   = new VectorialPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n         totalJacobianEvaluations = 0;\n \n         // multi-start loop\n         for (int i = 0; i < starts; ++i) {\n \n             try {\n-                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n                 optima[i] = optimizer.optimize(f, target, weights,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (ObjectiveException obe) {\n                 optima[i] = null;\n             }\n \n+            totalIterations          += optimizer.getIterations();\n             totalEvaluations         += optimizer.getEvaluations();\n             totalJacobianEvaluations += optimizer.getJacobianEvaluations();\n \n--- a/src/java/org/apache/commons/math/optimization/OptimizationException.java\n+++ b/src/java/org/apache/commons/math/optimization/OptimizationException.java\n public class OptimizationException extends ConvergenceException {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -781139167958631145L;\n+    private static final long serialVersionUID = -357696069587075016L;\n \n     /** \n      * Simple constructor.\n         super(specifier, parts);\n     }\n \n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public OptimizationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/optimization/ScalarDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/ScalarDifferentiableOptimizer.java\n  */\n public interface ScalarDifferentiableOptimizer extends Serializable {\n \n-    /** Set the maximal number of objective function calls.\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n      * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(ScalarDifferentiableObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n      * </p>\n-     * @param maxEvaluations maximal number of function calls\n-     * .\n+     * @return number of iterations\n      */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /** Get the maximal number of objective function calls.\n-     * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n-     * </p>\n-      * @return maximal number of function calls\n-     */\n-    int getMaxEvaluations();\n+    int getIterations();\n \n     /** Get the number of evaluations of the objective function.\n      * <p>\n-     * The number of evaluation correspond to the last call to the\n-     * {@link #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(ScalarDifferentiableObjectiveFunction, GoalType, double[]) optimize}\n      * method. It is 0 if the method has not been called yet.\n      * </p>\n      * @return number of evaluations of the objective function\n      */\n-   int getEvaluations();\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function gradient.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(ScalarDifferentiableObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function gradient\n+     */\n+    int getGradientEvaluations();\n \n     /** Set the convergence checker.\n      * @param checker object to use to check for convergence\n--- a/src/java/org/apache/commons/math/optimization/ScalarOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/ScalarOptimizer.java\n  */\n public interface ScalarOptimizer extends Serializable {\n \n-    /** Set the maximal number of objective function calls.\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n      * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n      * </p>\n-     * @param maxEvaluations maximal number of function calls\n-     * .\n+     * @return number of iterations\n      */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /** Get the maximal number of objective function calls.\n-     * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n-     * </p>\n-      * @return maximal number of function calls\n-     */\n-    int getMaxEvaluations();\n+    int getIterations();\n \n     /** Get the number of evaluations of the objective function.\n      * <p>\n-     * The number of evaluation correspond to the last call to the\n+     * The number of evaluations corresponds to the last call to the\n      * {@link #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n      * method. It is 0 if the method has not been called yet.\n      * </p>\n      * @return number of evaluations of the objective function\n      */\n-   int getEvaluations();\n+    int getEvaluations();\n \n     /** Set the convergence checker.\n      * @param checker object to use to check for convergence\n--- a/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n  */\n public interface VectorialDifferentiableOptimizer extends Serializable {\n \n-    /** Set the maximal number of objective function calls.\n-     * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n-     * </p>\n-     * @param maxEvaluations maximal number of function calls\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n      * .\n      */\n-    void setMaxEvaluations(int maxEvaluations);\n+    void setMaxIterations(int maxIterations);\n \n-    /** Get the maximal number of objective function calls.\n-     * <p>\n-     * The number of objective function calls may be checked <em>after</em> a few\n-     * related calls have been made. This implies that in some cases this number may\n-     * be exceeded by a few units, depending on the dimension of the problem and kind\n-     * of optimizer.\n-     * </p>\n-      * @return maximal number of function calls\n+    /** Get the maximal number of iterations of the algorithm.\n+      * @return maximal number of iterations\n      */\n-    int getMaxEvaluations();\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * @return number of iterations\n+    */\n+   int getIterations();\n \n     /** Get the number of evaluations of the objective function.\n      * <p>\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.optimization.ScalarConvergenceChecker;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.ScalarOptimizer;\n import org.apache.commons.math.optimization.ScalarPointValuePair;\n-import org.apache.commons.math.optimization.SimpleValueChecker;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /** \n  * This class implements simplex-based direct search optimization\n  * will occur.</p>\n  *\n  * <p>If {@link #setConvergenceChecker(ScalarConvergenceChecker)} is not called,\n- * a default {@link SimpleValueChecker} is used.</p>\n+ * a default {@link SimpleScalarValueChecker} is used.</p>\n  *\n  * <p>Convergence is checked by providing the <em>worst</em> points of\n  * previous and current simplex to the convergence checker, not the best ones.</p>\n     /** Convergence checker. */\n     private ScalarConvergenceChecker checker;\n \n-    /** Number of evaluations already performed for the current start. */\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Number of evaluations already performed. */\n     private int evaluations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n \n     /** Start simplex configuration. */\n     private double[][] startConfiguration;\n     /** Simple constructor.\n      */\n     protected DirectSearchOptimizer() {\n-        setConvergenceChecker(new SimpleValueChecker());\n-        setMaxEvaluations(Integer.MAX_VALUE);\n+        setConvergenceChecker(new SimpleScalarValueChecker());\n+        setMaxIterations(Integer.MAX_VALUE);\n     }\n \n     /** Set start configuration for simplex.\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public ScalarPointValuePair optimize(final ScalarObjectiveFunction f, final GoalType goalType,\n-                                   final double[] startPoint)\n+                                         final double[] startPoint)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n         if (startConfiguration == null) {\n         };\n \n         // initialize search\n+        iterations  = 0;\n         evaluations = 0;\n         buildSimplex(startPoint);\n         evaluateSimplex(comparator);\n \n         ScalarPointValuePair[] previous = new ScalarPointValuePair[simplex.length];\n-        int iterations = 0;\n-        while (evaluations <= maxEvaluations) {\n-\n-            if (++iterations > 1) {\n+        while (true) {\n+\n+            if (iterations > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.length; ++i) {\n                     converged &= checker.converged(iterations, previous[i], simplex[i]);\n \n         }\n \n-        throw new OptimizationException(\n-                \"maximal number of evaluations exceeded ({0})\",\n-                evaluations);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return evaluations;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n     }\n \n     /** Compute the next simplex of the algorithm.\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n      * @exception ObjectiveException if the function cannot be evaluated at\n      * some point\n-     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception OptimizationException if the algorithm fails to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n     protected abstract void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n     protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n-        final int max = getMaxEvaluations();\n-        while (getEvaluations() < max) {\n+        while (true) {\n+\n+            incrementIterationsCounter();\n \n             // save the original vertex\n             final ScalarPointValuePair[] original = simplex;\n             }\n \n         }\n-\n-        throw new OptimizationException(\n-                \"maximal number of evaluations exceeded ({0})\",\n-                getEvaluations());\n \n     }\n \n--- a/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n import java.util.Comparator;\n \n import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.ScalarPointValuePair;\n \n /** \n \n     /** {@inheritDoc} */\n     protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n-        throws ObjectiveException {\n+        throws ObjectiveException, OptimizationException {\n+\n+        incrementIterationsCounter();\n \n         // the simplex has n+1 point if dimension is n\n         final int n = simplex.length - 1;\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n public abstract class AbstractLeastSquaresOptimizer implements VectorialDifferentiableOptimizer {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -3080152374642370722L;\n-\n-    /** Default maximal number of objective function evaluations allowed. */\n-    public static final int DEFAULT_MAX_EVALUATIONS = 100;\n-\n-    /** Number of evaluations already performed for the current start. */\n+    private static final long serialVersionUID = 5413193243329026789L;\n+\n+    /** Default maximal number of iterations allowed. */\n+    public static final int DEFAULT_MAX_ITERATIONS = 100;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Number of evaluations already performed. */\n     private int objectiveEvaluations;\n \n     /** Number of jacobian evaluations. */\n     private int jacobianEvaluations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n \n     /** Convergence checker. */\n     protected VectorialConvergenceChecker checker;\n      */\n     protected AbstractLeastSquaresOptimizer() {\n         setConvergenceChecker(new SimpleVectorialValueChecker());\n-        setMaxEvaluations(DEFAULT_MAX_EVALUATIONS);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n+        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public VectorialConvergenceChecker getConvergenceChecker() {\n         return checker;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            if (++iterations > maxIterations) {\n+                throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+            }\n+        }\n     }\n \n     /** \n      * cannot be evaluated or its dimension doesn't match problem dimension\n      */\n     protected void updateJacobian() throws ObjectiveException {\n-        incrementJacobianEvaluationsCounter();\n+        ++jacobianEvaluations;\n         jacobian = f.jacobian(variables, objective);\n         if (jacobian.length != rows) {\n             throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n         }\n     }\n \n-    /**\n-     * Increment the jacobian evaluations counter.\n-     */\n-    protected final void incrementJacobianEvaluationsCounter() {\n-        ++jacobianEvaluations;\n-    }\n-\n     /** \n      * Update the residuals array and cost function value.\n      * @exception ObjectiveException if the function cannot be evaluated\n      * or its dimension doesn't match problem dimension\n-     * @exception OptimizationException if the number of cost evaluations\n-     * exceeds the maximum allowed\n      */\n     protected void updateResidualsAndCost()\n-        throws ObjectiveException, OptimizationException {\n-\n-        if (++objectiveEvaluations > maxEvaluations) {\n-            throw new OptimizationException(\n-                    \"maximal number of evaluations exceeded ({0})\",\n-                    objectiveEvaluations);\n-        }\n+        throws ObjectiveException {\n \n         objective = f.objective(variables);\n         if (objective.length != rows) {\n         }\n \n         // reset counters\n+        iterations           = 0;\n         objectiveEvaluations = 0;\n         jacobianEvaluations  = 0;\n \n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n     abstract protected VectorialPointValuePair doOptimize()\n-    throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n \n }\n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n      * and the maximal number of evaluation is set to\n-     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_EVALUATIONS}.\n+     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_ITERATIONS}.\n      * @param useLU if true, the normal equations will be solved using LU\n      * decomposition, otherwise they will be solved using QR decomposition\n      */\n \n         // iterate until convergence is reached\n         VectorialPointValuePair current = null;\n-        boolean converged = false;\n-        for (int iteration = 1; ! converged; ++iteration) {\n+        for (boolean converged = false; !converged;) {\n+\n+            incrementIterationsCounter();\n \n             // evaluate the objective function and its jacobian\n             VectorialPointValuePair previous = current;\n \n             // check convergence\n             if (previous != null) {\n-                converged = checker.converged(++iteration, previous, current);\n+                converged = checker.converged(getIterations(), previous, current);\n             }\n \n         }\n--- a/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n      * <p>The default values for the algorithm settings are:\n      *   <ul>\n      *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n-     *    <li>{@link #setMaxCostEval maximal cost evaluations}: 1000</li>\n+     *    <li>{@link #setMaxIterations maximal iterations}: 1000</li>\n      *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n      *    <li>{@link #setParRelativeTolerance parameters relative tolerance}: 1.0e-10</li>\n      *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n     public LevenbergMarquardtOptimizer() {\n \n         // set up the superclass with a default  max cost evaluations setting\n-        setMaxEvaluations(1000);\n+        setMaxIterations(1000);\n \n         // default values for the tuning parameters\n         setInitialStepBoundFactor(100.0);\n         lmPar = 0;\n         boolean firstIteration = true;\n         while (true) {\n+\n+            incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n             updateJacobian();\n--- a/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n import org.apache.commons.math.optimization.ScalarPointValuePair;\n-import org.apache.commons.math.optimization.SimpleValueChecker;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class MultiDirectionalTest\n   extends TestCase {\n       };\n \n       MultiDirectional optimizer = new MultiDirectional();\n-      optimizer.setConvergenceChecker(new SimpleValueChecker(1.0e-10, 1.0e-30));\n-      optimizer.setMaxEvaluations(200);\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxIterations(200);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n       ScalarPointValuePair optimum;\n \n \n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n-    optimizer.setConvergenceChecker(new SimpleValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxEvaluations(100);\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxIterations(100);\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n \n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n-    optimizer.setConvergenceChecker(new SimpleValueChecker(-1.0, 1.0e-3));\n-    optimizer.setMaxEvaluations(1000);\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxIterations(1000);\n     ScalarPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n import org.apache.commons.math.optimization.ScalarPointValuePair;\n-import org.apache.commons.math.optimization.SimpleValueChecker;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class NelderMeadTest\n   extends TestCase {\n       };\n \n       NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new SimpleValueChecker(1.0e-10, 1.0e-30));\n-      optimizer.setMaxEvaluations(100);\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxIterations(100);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n       ScalarPointValuePair optimum;\n \n \n     count = 0;\n     NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new SimpleValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxEvaluations(100);\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxIterations(100);\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n \n     count = 0;\n     NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new SimpleValueChecker(-1.0, 1.0e-3));\n-    optimizer.setMaxEvaluations(200);\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxIterations(200);\n     ScalarPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n--- a/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n                 { 0, 0, 0, 0, 0, 2 }\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                 {  0, -1, 1 }\n         }, new double[] { 1, 1, 1});\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n                 {  7.0, 5.0,  9.0, 10.0 }\n         }, new double[] { 32, 23, 33, 31 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum1 =\n             optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         assertTrue(optimizer.getRMS() > 0.1);\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n         VectorialPointValuePair optimum =\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-15, 1.0e-15));\n         try {\n             optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxIterations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         try {\n             optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n         try {\n             LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n             optimizer.setInitialStepBoundFactor(initialStepBoundFactor);\n-            optimizer.setMaxEvaluations(maxCostEval);\n+            optimizer.setMaxIterations(maxCostEval);\n             optimizer.setCostRelativeTolerance(costRelativeTolerance);\n             optimizer.setParRelativeTolerance(parRelativeTolerance);\n             optimizer.setOrthoTolerance(orthoTolerance);\n--- a/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n                                              0.188053165007911,\n                                              0.122430604321144,\n                                              0.134575665392506\n-                                           }), true);\n+                                           }), false);\n   }\n     \n   public void testMinpackMeyer()\n \n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n       LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-      optimizer.setMaxEvaluations(100 * (function.getN() + 1));\n+      optimizer.setMaxIterations(100 * (function.getN() + 1));\n       optimizer.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n       optimizer.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n       optimizer.setOrthoTolerance(2.22044604926e-16);", "timestamp": 1237726800, "metainfo": ""}