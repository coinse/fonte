{"sha": "b80bab2dc0ffe93b3fe705b4f695cc3982a66735", "log": "added Loess interpolator, applying Eugene Kirpichov's patch JIRA: MATH-278  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.MathException;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/**\n+ * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n+ * Local Regression Algorithm</a> (also Loess, Lowess) for interpolation of\n+ * real univariate functions.\n+ * <p/>\n+ * For reference, see\n+ * <a href=\"http://www.math.tau.ac.il/~yekutiel/MA seminar/Cleveland 1979.pdf\">\n+ * William S. Cleveland - Robust Locally Weighted Regression and Smoothing\n+ * Scatterplots</a>\n+ * <p/>\n+ * This class implements both the loess method and serves as an interpolation\n+ * adapter to it, allowing to build a spline on the obtained loess fit.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LoessInterpolator\n+        implements UnivariateRealInterpolator, Serializable {\n+\n+    /** serializable version identifier. */\n+    private static final long serialVersionUID = 5204927143605193821L;\n+\n+    /**\n+     * Default value of the bandwidth parameter.\n+     */\n+    public static final double DEFAULT_BANDWIDTH = 0.3;\n+    /**\n+     * Default value of the number of robustness iterations.\n+     */\n+    public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n+\n+    /**\n+     * The bandwidth parameter: when computing the loess fit at\n+     * a particular point, this fraction of source points closest\n+     * to the current point is taken into account for computing\n+     * a least-squares regression.\n+     * <p/>\n+     * A sensible value is usually 0.25 to 0.5.\n+     */\n+    private final double bandwidth;\n+\n+    /**\n+     * The number of robustness iterations parameter: this many\n+     * robustness iterations are done.\n+     * <p/>\n+     * A sensible value is usually 0 (just the initial fit without any\n+     * robustness iterations) to 4.\n+     */\n+    private final int robustnessIters;\n+\n+    /**\n+     * Constructs a new {@link LoessInterpolator}\n+     * with a bandwidth of {@link #DEFAULT_BANDWIDTH} and\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations.\n+     * See {@link #LoessInterpolator(double, int)} for an explanation of\n+     * the parameters.\n+     */\n+    public LoessInterpolator() {\n+        this.bandwidth = DEFAULT_BANDWIDTH;\n+        this.robustnessIters = DEFAULT_ROBUSTNESS_ITERS;\n+    }\n+\n+    /**\n+     * Constructs a new {@link LoessInterpolator}\n+     * with given bandwidth and number of robustness iterations.\n+     *\n+     * @param bandwidth  when computing the loess fit at\n+     * a particular point, this fraction of source points closest\n+     * to the current point is taken into account for computing\n+     * a least-squares regression.</br>\n+     * A sensible value is usually 0.25 to 0.5, the default value is\n+     * {@link #DEFAULT_BANDWIDTH}.\n+     * @param robustnessIters This many robustness iterations are done.</br>\n+     * A sensible value is usually 0 (just the initial fit without any\n+     * robustness iterations) to 4, the default value is\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n+     * @throws MathException if bandwidth does not lie in the interval [0,1]\n+     * or if robustnessIters is negative.\n+     */\n+    public LoessInterpolator(double bandwidth, int robustnessIters) throws MathException {\n+        if (bandwidth < 0 || bandwidth > 1) {\n+            throw new MathException(\"bandwidth must be in the interval [0,1], but got {0}\",\n+                                    bandwidth);\n+        }\n+        this.bandwidth = bandwidth;\n+        if (robustnessIters < 0) {\n+            throw new MathException(\"the number of robustness iterations must \" +\n+                                    \"be non-negative, but got {0}\",\n+                                    robustnessIters);\n+        }\n+        this.robustnessIters = robustnessIters;\n+    }\n+\n+    /**\n+     * Compute an interpolating function by performing a loess fit\n+     * on the data at the original abscissae and then building a cubic spline\n+     * with a\n+     * {@link org.apache.commons.math.analysis.interpolation.SplineInterpolator}\n+     * on the resulting fit.\n+     *\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return A cubic spline built upon a loess fit to the data at the original abscissae\n+     * @throws MathException  if some of the following conditions are false:\n+     * <ul>\n+     * <li> Arguments and values are of the same size that is greater than zero</li>\n+     * <li> The arguments are in a strictly increasing order</li>\n+     * <li> All arguments and values are finite real numbers</li>\n+     * </ul>\n+     */\n+    public final UnivariateRealFunction interpolate(\n+            final double[] xval, final double[] yval) throws MathException {\n+        return new SplineInterpolator().interpolate(xval, smooth(xval, yval));\n+    }\n+\n+    /**\n+     * Compute a loess fit on the data at the original abscissae.\n+     *\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return values of the loess fit at corresponding original abscissae\n+     * @throws MathException if some of the following conditions are false:\n+     * <ul>\n+     * <li> Arguments and values are of the same size that is greater than zero</li>\n+     * <li> The arguments are in a strictly increasing order</li>\n+     * <li> All arguments and values are finite real numbers</li>\n+     * </ul>\n+     */\n+    public final double[] smooth(final double[] xval, final double[] yval)\n+            throws MathException {\n+        if (xval.length != yval.length) {\n+            throw new MathException(\n+                    \"Loess expects the abscissa and ordinate arrays \" +\n+                    \"to be of the same size, \" +\n+                    \"but got {0} abscisssae and {1} ordinatae\",\n+                    xval.length, yval.length);\n+        }\n+\n+        final int n = xval.length;\n+\n+        if (n == 0) {\n+            throw new MathException(\"Loess expects at least 1 point\");\n+        }\n+\n+        checkAllFiniteReal(xval, true);\n+        checkAllFiniteReal(yval, false);\n+\n+        checkStrictlyIncreasing(xval);\n+\n+        if (n == 1) {\n+            return new double[]{yval[0]};\n+        }\n+\n+        if (n == 2) {\n+            return new double[]{yval[0], yval[1]};\n+        }\n+\n+        int bandwidthInPoints = (int) (bandwidth * n);\n+\n+        if (bandwidthInPoints < 2) {\n+            throw new MathException(\n+                    \"the bandwidth must be large enough to \" +\n+                    \"accomodate at least 2 points. There are {0} \" +\n+                    \" data points, and bandwidth must be at least {1} \" +\n+                    \" but it is only {2}\",\n+                    n, 2.0 / n, bandwidth);\n+        }\n+\n+        final double[] res = new double[n];\n+\n+        final double[] residuals = new double[n];\n+        final double[] sortedResiduals = new double[n];\n+\n+        final double[] robustnessWeights = new double[n];\n+\n+        // Do an initial fit and 'robustnessIters' robustness iterations.\n+        // This is equivalent to doing 'robustnessIters+1' robustness iterations\n+        // starting with all robustness weights set to 1.\n+        Arrays.fill(robustnessWeights, 1);\n+\n+        for (int iter = 0; iter <= robustnessIters; ++iter) {\n+            final int[] bandwidthInterval = {0, bandwidthInPoints - 1};\n+            // At each x, compute a local weighted linear regression\n+            for (int i = 0; i < n; ++i) {\n+                final double x = xval[i];\n+\n+                // Find out the interval of source points on which\n+                // a regression is to be made.\n+                if (i > 0) {\n+                    updateBandwidthInterval(xval, i, bandwidthInterval);\n+                }\n+\n+                final int ileft = bandwidthInterval[0];\n+                final int iright = bandwidthInterval[1];\n+\n+                // Compute the point of the bandwidth interval that is\n+                // farthest from x\n+                final int edge;\n+                if (xval[i] - xval[ileft] > xval[iright] - xval[i]) {\n+                    edge = ileft;\n+                } else {\n+                    edge = iright;\n+                }\n+\n+                // Compute a least-squares linear fit weighted by\n+                // the product of robustness weights and the tricube\n+                // weight function.\n+                // See http://en.wikipedia.org/wiki/Linear_regression\n+                // (section \"Univariate linear case\")\n+                // and http://en.wikipedia.org/wiki/Weighted_least_squares\n+                // (section \"Weighted least squares\")\n+                double sumWeights = 0;\n+                double sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0;\n+                double denom = Math.abs(1.0 / (xval[edge] - x));\n+                for (int k = ileft; k <= iright; ++k) {\n+                    final double xk = xval[k];\n+                    final double yk = yval[k];\n+                    double dist;\n+                    if (k < i) {\n+                        dist = (x - xk);\n+                    } else {\n+                        dist = (xk - x);\n+                    }\n+                    final double w = tricube(dist * denom) * robustnessWeights[k];\n+                    final double xkw = xk * w;\n+                    sumWeights += w;\n+                    sumX += xkw;\n+                    sumXSquared += xk * xkw;\n+                    sumY += yk * w;\n+                    sumXY += yk * xkw;\n+                }\n+\n+                final double meanX = sumX / sumWeights;\n+                final double meanY = sumY / sumWeights;\n+                final double meanXY = sumXY / sumWeights;\n+                final double meanXSquared = sumXSquared / sumWeights;\n+\n+                final double beta;\n+                if (meanXSquared == meanX * meanX) {\n+                    beta = 0;\n+                } else {\n+                    beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX);\n+                }\n+\n+                final double alpha = meanY - beta * meanX;\n+\n+                res[i] = beta * x + alpha;\n+                residuals[i] = Math.abs(yval[i] - res[i]);\n+            }\n+\n+            // No need to recompute the robustness weights at the last\n+            // iteration, they won't be needed anymore\n+            if (iter == robustnessIters) {\n+                break;\n+            }\n+\n+            // Recompute the robustness weights.\n+\n+            // Find the median residual.\n+            // An arraycopy and a sort are completely tractable here, \n+            // because the preceding loop is a lot more expensive\n+            System.arraycopy(residuals, 0, sortedResiduals, 0, n);\n+            Arrays.sort(sortedResiduals);\n+            final double medianResidual = sortedResiduals[n / 2];\n+\n+            if (medianResidual == 0) {\n+                break;\n+            }\n+\n+            for (int i = 0; i < n; ++i) {\n+                final double arg = residuals[i] / (6 * medianResidual);\n+                robustnessWeights[i] = (arg >= 1) ? 0 : Math.pow(1 - arg * arg, 2);\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Given an index interval into xval that embraces a certain number of\n+     * points closest to xval[i-1], update the interval so that it embraces\n+     * the same number of points closest to xval[i]\n+     *\n+     * @param xval arguments array\n+     * @param i the index around which the new interval should be computed\n+     * @param bandwidthInterval a two-element array {left, right} such that: <p/>\n+     * <tt>(left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])</tt>\n+     * <p/> and also <p/>\n+     * <tt>(right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])</tt>.\n+     * The array will be updated.\n+     */\n+    private static void updateBandwidthInterval(final double[] xval, final int i,\n+                                                final int[] bandwidthInterval) {\n+        final int left = bandwidthInterval[0];\n+        final int right = bandwidthInterval[1];\n+\n+        // The right edge should be adjusted if the next point to the right\n+        // is closer to xval[i] than the leftmost point of the current interval\n+        if (right < xval.length - 1 &&\n+           xval[right+1] - xval[i] < xval[i] - xval[left]) {\n+            bandwidthInterval[0]++;\n+            bandwidthInterval[1]++;\n+        }\n+    }\n+\n+    /**\n+     * Compute the \n+     * <a href=\"http://en.wikipedia.org/wiki/Local_regression#Weight_function\">tricube</a>\n+     * weight function\n+     *\n+     * @param x the argument\n+     * @return (1-|x|^3)^3\n+     */\n+    private static double tricube(final double x) {\n+        final double tmp = 1 - x * x * x;\n+        return tmp * tmp * tmp;\n+    }\n+\n+    /**\n+     * Check that all elements of an array are finite real numbers.\n+     *\n+     * @param values the values array\n+     * @param isAbscissae if true, elements are abscissae otherwise they are ordinatae\n+     * @throws MathException if one of the values is not\n+     *         a finite real number\n+     */\n+    private static void checkAllFiniteReal(final double[] values, final boolean isAbscissae)\n+        throws MathException {\n+        for (int i = 0; i < values.length; i++) {\n+            final double x = values[i];\n+            if (Double.isInfinite(x) || Double.isNaN(x)) {\n+                final String pattern = isAbscissae ?\n+                        \"all abscissae must be finite real numbers, but {0}-th is {1}\" :\n+                        \"all ordinatae must be finite real numbers, but {0}-th is {1}\";\n+                throw new MathException(pattern, i, x);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check that elements of the abscissae array are in a strictly\n+     * increasing order.\n+     *\n+     * @param xval the abscissae array\n+     * @throws MathException if the abscissae array\n+     * is not in a strictly increasing order\n+     */\n+    private static void checkStrictlyIncreasing(final double[] xval)\n+        throws MathException {\n+        for (int i = 0; i < xval.length; ++i) {\n+            if (i >= 1 && xval[i - 1] >= xval[i]) {\n+                throw new MathException(\n+                        \"the abscissae array must be sorted in a strictly \" +\n+                        \"increasing order, but the {0}-th element is {1} \" +\n+                        \"whereas {2}-th is {3}\",\n+                        i - 1, xval[i - 1], i, xval[i]);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.MathException;\n+import org.junit.Test;\n+\n+/**\n+ * Test of the LoessInterpolator class.\n+ */\n+public class LoessInterpolatorTest {\n+\n+    @Test\n+    public void testOnOnePoint() throws MathException {\n+        double[] xval = {0.5};\n+        double[] yval = {0.7};\n+        double[] res = new LoessInterpolator().smooth(xval, yval);\n+        assertEquals(1, res.length);\n+        assertEquals(0.7, res[0], 0.0);\n+    }\n+\n+    @Test\n+    public void testOnTwoPoints() throws MathException {\n+        double[] xval = {0.5, 0.6};\n+        double[] yval = {0.7, 0.8};\n+        double[] res = new LoessInterpolator().smooth(xval, yval);\n+        assertEquals(2, res.length);\n+        assertEquals(0.7, res[0], 0.0);\n+        assertEquals(0.8, res[1], 0.0);\n+    }\n+\n+    @Test\n+    public void testOnStraightLine() throws MathException {\n+        double[] xval = {1,2,3,4,5};\n+        double[] yval = {2,4,6,8,10};\n+        LoessInterpolator li = new LoessInterpolator(0.6, 2);\n+        double[] res = li.smooth(xval, yval);\n+        assertEquals(5, res.length);\n+        for(int i = 0; i < 5; ++i) {\n+            assertEquals(yval[i], res[i], 1e-8);\n+        }\n+    }\n+\n+    @Test\n+    public void testOnDistortedSine() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.2;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        LoessInterpolator li = new LoessInterpolator(0.3, 4);\n+\n+        double[] res = li.smooth(xval, yval);\n+\n+        // Check that the resulting curve differs from\n+        // the \"real\" sine less than the jittered one\n+\n+        double noisyResidualSum = 0;\n+        double fitResidualSum = 0;\n+\n+        System.out.println();\n+        for(int i = 0; i < numPoints; ++i) {\n+            double expected = Math.sin(xval[i]);\n+            double noisy = yval[i];\n+            double fit = res[i];\n+\n+            noisyResidualSum += Math.pow(noisy - expected, 2);\n+            fitResidualSum += Math.pow(fit - expected, 2);\n+        }\n+\n+        assertTrue(fitResidualSum < noisyResidualSum);\n+    }\n+\n+    @Test\n+    public void testIncreasingBandwidthIncreasesSmoothness() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.1;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        // Check that variance decreases as bandwidth increases\n+\n+        double[] bandwidths = {0.1, 0.5, 1.0};\n+        double[] variances = new double[bandwidths.length];\n+        for (int i = 0; i < bandwidths.length; i++) {\n+            double bw = bandwidths[i];\n+\n+            LoessInterpolator li = new LoessInterpolator(bw, 4);\n+\n+            double[] res = li.smooth(xval, yval);\n+\n+            for (int j = 1; j < res.length; ++j) {\n+                variances[i] += Math.pow(res[j] - res[j-1], 2);\n+            }\n+        }\n+\n+        for(int i = 1; i < variances.length; ++i) {\n+            assertTrue(variances[i] < variances[i-1]);\n+        }\n+    }\n+\n+    @Test\n+    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() throws MathException {\n+        int numPoints = 100;\n+        double[] xval = new double[numPoints];\n+        double[] yval = new double[numPoints];\n+        double xnoise = 0.1;\n+        double ynoise = 0.1;\n+\n+        generateSineData(xval, yval, xnoise, ynoise);\n+\n+        // Introduce a couple of outliers\n+        yval[numPoints/3] *= 100;\n+        yval[2 * numPoints/3] *= -100;\n+\n+        // Check that variance decreases as the number of robustness\n+        // iterations increases\n+\n+        double[] variances = new double[4];\n+        for (int i = 0; i < 4; i++) {\n+            LoessInterpolator li = new LoessInterpolator(0.3, i);\n+\n+            double[] res = li.smooth(xval, yval);\n+\n+            for (int j = 1; j < res.length; ++j) {\n+                variances[i] += Math.abs(res[j] - res[j-1]);\n+            }\n+        }\n+\n+        for(int i = 1; i < variances.length; ++i) {\n+            assertTrue(variances[i] < variances[i-1]);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnequalSizeArguments() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyData() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {}, new double[] {});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNonStrictlyIncreasing() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNotAllFiniteReal() {\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testInsufficientBandwidth() {\n+        try {\n+            LoessInterpolator li = new LoessInterpolator(0.1, 3);\n+            li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCompletelyIncorrectBandwidth() {\n+        try {\n+            new LoessInterpolator(-0.2, 3);\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+        try {\n+            new LoessInterpolator(1.1, 3);\n+            fail();\n+        } catch(MathException e) {\n+            // Expected\n+        }\n+    }\n+\n+    private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {\n+        double dx = 2 * Math.PI / xval.length;\n+        double x = 0;\n+        for(int i = 0; i < xval.length; ++i) {\n+            xval[i] = x;\n+            yval[i] = Math.sin(x) + (2 * Math.random() - 1) * ynoise;\n+            x += dx * (1 + (2 * Math.random() - 1) * xnoise);\n+        }\n+    }\n+\n+}", "timestamp": 1245505376, "metainfo": ""}