{"sha": "681ce013786d7db57b116865394c826e802bd8f4", "log": "Modifications to the hierarchy of distributions, according to MATH-692. Patch contributed by Christian Winter.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n     /**\n      * {@inheritDoc}\n-     */\n-    public abstract double density(double x);\n-\n-    /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws OutOfRangeException if {@code p} is not a valid probability.\n-     */\n-    public double inverseCumulativeProbability(final double p) {\n+     *\n+     * For continuous distributions {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    @Override\n+    public final double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n \n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         // subclasses can override if there is a better method.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n+            @Override\n             public double value(double x) {\n                 return cumulativeProbability(x) - p;\n             }\n      * @param seed New seed.\n      * @since 2.2\n      */\n+    @Override\n     public void reseedRandomGenerator(long seed) {\n         randomData.reSeed(seed);\n     }\n      * @return a random value.\n      * @since 2.2\n      */\n+    @Override\n     public double sample() {\n         return randomData.nextInversionDeviate(this);\n     }\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not positive.\n      * @since 2.2\n      */\n+    @Override\n     public double[] sample(int sampleSize) {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n     }\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     * <p>\n-     * The default implementation uses the identity</p>\n-     * <p>\n-     * P(x0 &le; X &le; x1) = P(X &le; x1) - P(X &le; x0) </p>\n+     * {@inheritDoc}\n      *\n-     * @param x0 the (inclusive) lower bound\n-     * @param x1 the (inclusive) upper bound\n-     * @return the probability that a random variable with this distribution\n-     * will take a value between {@code x0} and {@code x1},\n-     * including the endpoints.\n-     * @throws NumberIsTooLargeException if {@code x0 > x1}\n+     * The default implementation uses the identity\n+     * <p>{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}</p>\n      */\n-    public double cumulativeProbability(double x0, double x1) {\n+    @Override\n+    public double cumulativeProbability(double x0, double x1) throws NumberIsTooLargeException {\n         if (x0 > x1) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x0, x1, true);\n      *\n      * @return the mean or Double.NaN if it's not defined\n      */\n+    @Override\n     public double getNumericalMean() {\n         if (!numericalMeanIsCalculated) {\n             numericalMean = calculateNumericalMean();\n      * for certain cases in {@link TDistributionImpl}) or\n      * Double.NaN if it's not defined\n      */\n+    @Override\n     public double getNumericalVariance() {\n         if (!numericalVarianceIsCalculated) {\n             numericalVariance = calculateNumericalVariance();\n      *\n      * @return whether the lower bound of the support is inclusive or not\n      */\n+    @Override\n     public abstract boolean isSupportLowerBoundInclusive();\n \n     /**\n      *\n      * @return whether the upper bound of the support is inclusive or not\n      */\n+    @Override\n     public abstract boolean isSupportUpperBoundInclusive();\n \n     /**\n      *\n      * @return whether the support limits given by subclassed methods are connected or not\n      */\n+    @Override\n     public boolean isSupportConnected() {\n         return true;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public double cumulativeProbability(double x0, double x1)  {\n-        return cumulativeProbability(x1) - cumulativeProbability(x0);\n-    }\n-\n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return CDF evaluated at {@code x}.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double cumulativeProbability(double x) {\n         return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getMedian() {\n         return median;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getScale() {\n         return scale;\n     }\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n-     * {@code Double.POSITIVE_INFINITY} when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws OutOfRangeException if {@code p} is not a valid probability.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(double p) {\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code Double.NEGATIVE_INFINITY} when {@code p = 0}\n+     * and {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws OutOfRangeException {\n         double ret;\n         if (p < 0 || p > 1) {\n             throw new OutOfRangeException(p, 0, 1);\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getDegreesOfFreedom() {\n         return gamma.getAlpha() * 2.0;\n     }\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n-     *\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double cumulativeProbability(double x)  {\n         return gamma.cumulativeProbability(x);\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point\n-     * {@code x}, such that {@code P(X < x) = p}.\n-     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n-     * when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException if\n-     * {@code p} is not a valid probability.\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code 0} when {@code p = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.OutOfRangeException;\n+\n /**\n  * Base interface for continuous distributions.\n  *\n  */\n public interface ContinuousDistribution extends Distribution {\n     /**\n-     * For a distribution, {@code X}, compute {@code x} such that\n-     * {@code P(X < x) = p}.\n+     * Computes the quantile function of this distribution. For a random\n+     * variable {@code X} distributed according to this distribution, the\n+     * returned value is\n+     * <ul>\n+     * <li><code>inf{x in R | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>\n+     * <li><code>inf{x in R | P(X<=x) > 0}</code> for {@code p = 0}.</li>\n+     * </ul>\n      *\n-     * @param p Cumulative probability.\n-     * @return {@code x} such that {@code P(X < x) = p}.\n+     * @param p the cumulative probability\n+     * @return the smallest {@code p}-quantile of this distribution\n+     * (largest 0-quantile for {@code p = 0})\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}\n      */\n-    double inverseCumulativeProbability(double p);\n+    double inverseCumulativeProbability(double p) throws OutOfRangeException;\n \n     /**\n-     * Probability density for a particular point.\n+     * Returns the probability density function (PDF) of this distribution\n+     * evaluated at the specified point.\n      *\n-     * @param x Point at which the density should be computed.\n-     * @return the pdf at point {@code x}.\n+     * @param x the point at which the PDF should be evaluated\n+     * @return the PDF at point {@code x}\n      */\n     double density(double x);\n \n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+\n /**\n  * Base interface for probability distributions.\n  *\n  */\n public interface Distribution {\n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(X &le; x).  In other words,\n-     * this method represents the  (cumulative) distribution function, or\n-     * CDF, for this distribution.\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X = x)}. In other\n+     * words, this method represents the probability mass function (PMF)\n+     * for the distribution.\n      *\n-     * @param x the value at which the distribution function is evaluated.\n+     * @param x the value at which the PMF is evaluated\n+     * @return the value of the probability mass function at {@code x}\n+     */\n+    double probability(double x);\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(X <= x)}. In other\n+     * words, this method represents the (cumulative) distribution function\n+     * (CDF) for this distribution.\n+     *\n+     * @param x the value at which the CDF is evaluated\n      * @return the probability that a random variable with this\n-     * distribution takes a value less than or equal to <code>x</code>\n+     * distribution takes a value less than or equal to {@code x}\n      */\n     double cumulativeProbability(double x);\n \n     /**\n-     * For a random variable X whose values are distributed according\n-     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * For a random variable {@code X} whose values are distributed according\n+     * to this distribution, this method returns {@code P(x0 < X <= x1)}.\n      *\n-     * @param x0 the (inclusive) lower bound\n-     * @param x1 the (inclusive) upper bound\n+     * @param x0 the exclusive lower bound\n+     * @param x1 the inclusive upper bound\n      * @return the probability that a random variable with this distribution\n-     * will take a value between <code>x0</code> and <code>x1</code>,\n-     * including the endpoints\n-     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     * takes a value between {@code x0} and {@code x1},\n+     * excluding the lower and including the upper endpoint\n+     * @throws NumberIsTooLargeException if {@code x0 > x1}\n      */\n-    double cumulativeProbability(double x0, double x1);\n+    double cumulativeProbability(double x0, double x1) throws NumberIsTooLargeException;\n \n     /**\n      * Use this method to get the numerical value of the mean of this\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getMean() {\n         return mean;\n     }\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &lt; x).\n+     * {@inheritDoc}\n      *\n      * The implementation of this method is based on:\n      * <ul>\n      * <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n      * Exponential Distribution</a>, equation (1).</li>\n      * </ul>\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return the CDF for this distribution.\n-     */\n+     */\n+    @Override\n     public double cumulativeProbability(double x)  {\n         double ret;\n         if (x <= 0.0) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that {@code P(X < x) = p}.\n-     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n-     * when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(double p) {\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code 0} when {@code p = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws OutOfRangeException {\n         double ret;\n \n         if (p < 0.0 || p > 1.0) {\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.FastMath;\n     }\n \n     /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n+     * {@inheritDoc}\n+     *\n      * @since 2.1\n      */\n     @Override\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     * {@inheritDoc}\n      *\n      * The implementation of this method is based on\n      * <ul>\n      *   F-Distribution</a>, equation (4).\n      *  </li>\n      * </ul>\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return CDF for this distribution.\n-     */\n+     */\n+    @Override\n     public double cumulativeProbability(double x)  {\n         double ret;\n         if (x <= 0) {\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws IllegalArgumentException if {@code p} is not a valid\n-     * probability.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(final double p) {\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code 0} when {@code p = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n         if (p == 0) {\n             return 0;\n         }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getNumeratorDegreesOfFreedom() {\n         return numeratorDegreesOfFreedom;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getDenominatorDegreesOfFreedom() {\n         return denominatorDegreesOfFreedom;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     * {@inheritDoc}\n      *\n      * The implementation of this method is based on:\n      * <ul>\n      *    Belmont, CA: Duxbury Press.\n      *  </li>\n      * </ul>\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return CDF for this distribution.\n-     */\n+     */\n+    @Override\n     public double cumulativeProbability(double x) {\n         double ret;\n \n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n-     * when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException if\n-     * {@code p} is not a valid probability.\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code 0} when {@cod p = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getAlpha() {\n         return alpha;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getBeta() {\n         return beta;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getMean() {\n         return mean;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getStandardDeviation() {\n         return standardDeviation;\n     }\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n-     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n+     * {@inheritDoc}\n+     *\n+     * If {@code x} is more than 40 standard deviations from the mean, 0 or 1 is returned,\n      * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return CDF evaluated at {@code x}.\n-     */\n+     */\n+    @Override\n     public double cumulativeProbability(double x)  {\n         final double dev = x - mean;\n         if (FastMath.abs(dev) > 40 * standardDeviation) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public double cumulativeProbability(double x0, double x1)  {\n+    public double cumulativeProbability(double x0, double x1) throws NumberIsTooLargeException {\n         if (x0 > x1) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x0, x1, true);\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point\n-     * {@code x}, such that {@code P(X < x) = p}.\n-     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n-     * {@code Double.POSITIVE_INFINITY} for p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException if\n-     * {@code p} is not a valid probability.\n-     */\n-    @Override\n-    public double inverseCumulativeProbability(final double p)\n-     {\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code Double.NEGATIVE_INFINITY} when {@code p = 0}\n+     * and {@code Double.POSITIVE_INFINITY} for {@code p = 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n         if (p == 0) {\n             return Double.NEGATIVE_INFINITY;\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n      *\n      * @return the degrees of freedom.\n      */\n+    @Override\n     public double getDegreesOfFreedom() {\n         return degreesOfFreedom;\n     }\n     }\n \n     /**\n-     * For this distribution, X, this method returns {@code P(X < x}).\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return CDF evaluated at {@code x}.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double cumulativeProbability(double x) {\n         double ret;\n         if (x == 0) {\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and\n-     * {@code Double.POSITIVE_INFINITY} when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException if\n-     * {@code p} is not a valid probability.\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code Double.NEGATIVE_INFINITY} when {@cod p = 0}\n+     * and {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n-     *\n-     * @param x Value at which the CDF is evaluated.\n-     * @return the CDF evaluated at {@code x}.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double cumulativeProbability(double x) {\n         double ret;\n         if (x <= 0.0) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getShape() {\n         return shape;\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double getScale() {\n         return scale;\n     }\n     }\n \n     /**\n-     * For this distribution, {@code X}, this method returns the critical\n-     * point {@code x}, such that {@code P(X < x) = p}.\n-     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n-     * {@code Double.POSITIVE_INFINITY} when p = 1.\n-     *\n-     * @param p Desired probability.\n-     * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws OutOfRangeException if {@code p} is not a valid probability.\n+     * {@inheritDoc}\n+     *\n+     * It will return {@code 0} when {@code p = 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n      */\n     @Override\n     public double inverseCumulativeProbability(double p) {\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n                distribution.cumulativeProbability\n                  (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);\n \n-            // check that P(a < X < b) = P(X < b) - P(X < a)\n+            // check that P(a < X <= b) = P(X <= b) - P(X <= a)\n             double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n             double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n             double diff = distribution.cumulativeProbability(upper) -\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n      *      Bug report that prompted this unit test.</a>\n      */\n     @Test\n-    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {\n+    public void testCumulativeProbabilityAgainstStackOverflow() throws Exception {\n         TDistributionImpl td = new TDistributionImpl(5.);\n         td.cumulativeProbability(.1);\n         td.cumulativeProbability(.01);", "timestamp": 1320906116, "metainfo": ""}