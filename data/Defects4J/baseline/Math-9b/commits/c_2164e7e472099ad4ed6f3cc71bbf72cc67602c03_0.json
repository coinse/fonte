{"sha": "2164e7e472099ad4ed6f3cc71bbf72cc67602c03", "log": "Merged CauchyDistribution and CauchyDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * Cauchy Distribution.\n+ * Implementation of the Cauchy distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- *  <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n- *   Cauchy Distribution</a>\n- *  </li>\n- * </ul>\n- * </p>\n- *\n- * @since 1.1\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cauchy_distribution\">Cauchy distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">Cauchy Distribution (MathWorld)</a>\n+ * @since 1.1 (changed to concrete class in 3.0)\n  * @version $Id$\n  */\n-public interface CauchyDistribution extends ContinuousDistribution {\n+public class CauchyDistribution extends AbstractContinuousDistribution\n+    implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    /** The median of this distribution. */\n+    private final double median;\n+    /** The scale of this distribution. */\n+    private final double scale;\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Creates a Cauchy distribution with the median equal to zero and scale\n+     * equal to one.\n+     */\n+    public CauchyDistribution() {\n+        this(0, 1);\n+    }\n+\n+    /**\n+     * Creates a Cauchy distribution using the given median and scale.\n+     *\n+     * @param median Median for this distribution.\n+     * @param scale Scale parameter for this distribution.\n+     */\n+    public CauchyDistribution(double median, double scale) {\n+        this(median, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Creates a Cauchy distribution using the given median and scale.\n+     *\n+     * @param median Median for this distribution.\n+     * @param scale Scale parameter for this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code scale <= 0}.\n+     * @since 2.1\n+     */\n+    public CauchyDistribution(double median, double scale,\n+                                  double inverseCumAccuracy) {\n+        if (scale <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);\n+        }\n+        this.scale = scale;\n+        this.median = median;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x) {\n+        return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);\n+    }\n+\n     /**\n      * Access the median.\n      *\n      * @return the median for this distribution.\n      */\n-    double getMedian();\n+    public double getMedian() {\n+        return median;\n+    }\n \n     /**\n      * Access the scale parameter.\n      *\n      * @return the scale parameter for this distribution.\n      */\n-    double getScale();\n+    public double getScale() {\n+        return scale;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        final double dev = x - median;\n+        return (1 / FastMath.PI) * (scale / (dev * dev + scale * scale));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code Double.NEGATIVE_INFINITY} when {@code p == 0}\n+     * and {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws OutOfRangeException {\n+        double ret;\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        } else if (p == 0) {\n+            ret = Double.NEGATIVE_INFINITY;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = median + scale * FastMath.tan(FastMath.PI * (p - .5));\n+        }\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = median;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = median;\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = median - scale;\n+        } else if (p > 0.5) {\n+            ret = median + scale;\n+        } else {\n+            ret = median;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always negative infinity no matter\n+     * the parameters.\n+     *\n+     * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter\n+     * the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The mean is always undefined no matter the parameters.\n+     *\n+     * @return mean (always Double.NaN)\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The variance is always undefined no matter the parameters.\n+     *\n+     * @return variance (always Double.NaN)\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n \n import org.apache.commons.math.distribution.BetaDistribution;\n import org.apache.commons.math.distribution.BinomialDistribution;\n-import org.apache.commons.math.distribution.CauchyDistributionImpl;\n+import org.apache.commons.math.distribution.CauchyDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.distribution.ContinuousDistribution;\n import org.apache.commons.math.distribution.FDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link CauchyDistributionImpl Cauchy Distribution}.\n+     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextCauchy(double median, double scale) {\n-        return nextInversionDeviate(new CauchyDistributionImpl(median, scale));\n+        return nextInversionDeviate(new CauchyDistribution(median, scale));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public CauchyDistribution makeDistribution() {\n-        return new CauchyDistributionImpl(1.2, 2.1);\n+        return new CauchyDistribution(1.2, 2.1);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     @Test\n     public void testPreconditions() {\n         try {\n-            new CauchyDistributionImpl(0, 0);\n+            new CauchyDistribution(0, 0);\n             Assert.fail(\"Cannot have zero scale\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new CauchyDistributionImpl(0, -1);\n+            new CauchyDistribution(0, -1);\n             Assert.fail(\"Cannot have negative scale\");\n         } catch (NotStrictlyPositiveException ex) {\n             // Expected.\n     @Test\n     public void testMoments() {\n         CauchyDistribution dist;\n-        \n-        dist = new CauchyDistributionImpl(10.2, 0.15);        \n+\n+        dist = new CauchyDistribution(10.2, 0.15);\n         Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n         Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n-        \n-        dist = new CauchyDistributionImpl(23.12, 2.12);\n+\n+        dist = new CauchyDistribution(23.12, 2.12);\n         Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n         Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.BetaDistribution;\n import org.apache.commons.math.distribution.BinomialDistribution;\n import org.apache.commons.math.distribution.BinomialDistributionTest;\n-import org.apache.commons.math.distribution.CauchyDistributionImpl;\n+import org.apache.commons.math.distribution.CauchyDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.distribution.ExponentialDistributionImpl;\n import org.apache.commons.math.distribution.FDistributionImpl;\n \n     @Test\n     public void testNextCauchy() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistribution(1.2, 2.1));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {", "timestamp": 1322194145, "metainfo": ""}