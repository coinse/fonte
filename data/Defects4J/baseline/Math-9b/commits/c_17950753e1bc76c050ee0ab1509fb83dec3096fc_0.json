{"sha": "17950753e1bc76c050ee0ab1509fb83dec3096fc", "log": "added the geometry package from Mantissa  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** This class represents exceptions thrown while extractiong Cardan\n+ * or Euler angles from a rotation.\n+\n+ * @version $Id: CardanEulerSingularityException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class CardanEulerSingularityException\n+  extends MathException {\n+\n+  /** Simple constructor.\n+   * build an exception with a default message.\n+   * @param isCardan if true, the rotation is related to Cardan angles,\n+   * if false it is related to EulerAngles\n+   */\n+  public CardanEulerSingularityException(boolean isCardan) {\n+    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\", new Object[0]);\n+  }\n+\n+  private static final long serialVersionUID = -1360952845582206770L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** This class represents exceptions thrown while building rotations\n+ * from matrices.\n+\n+ * @version $Id: NotARotationMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class NotARotationMatrixException\n+  extends MathException {\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public NotARotationMatrixException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  private static final long serialVersionUID = 5647178478658937642L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class implements rotations in a three-dimensional space.\n+\n+ * <p>Rotations can be represented by several different mathematical\n+ * entities (matrices, axe and angle, Cardan or Euler angles,\n+ * quaternions). This class presents an higher level abstraction, more\n+ * user-oriented and hiding this implementation details. Well, for the\n+ * curious, we use quaternions for the internal representation. The\n+ * user can build a rotation from any of these representations, and\n+ * any of these representations can be retrieved from a\n+ * <code>Rotation</code> instance (see the various constructors and\n+ * getters). In addition, a rotation can also be built implicitely\n+ * from a set of vectors and their image.</p>\n+ * <p>This implies that this class can be used to convert from one\n+ * representation to another one. For example, converting a rotation\n+ * matrix into a set of Cardan angles from can be done using the\n+ * followong single line of code:</p>\n+ * <pre>\n+ * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n+ * </pre>\n+ * <p>Focus is oriented on what a rotation <em>do</em> rather than on its\n+ * underlying representation. Once it has been built, and regardless of its\n+ * internal representation, a rotation is an <em>operator</em> which basically\n+ * transforms three dimensional {@link Vector3D vectors} into other three\n+ * dimensional {@link Vector3D vectors}. Depending on the application, the\n+ * meaning of these vectors may vary and the semantics of the rotation also.</p>\n+ * <p>For example in an spacecraft attitude simulation tool, users will often\n+ * consider the vectors are fixed (say the Earth direction for example) and the\n+ * rotation transforms the coordinates coordinates of this vector in inertial\n+ * frame into the coordinates of the same vector in satellite frame. In this\n+ * case, the rotation implicitely defines the relation between the two frames.\n+ * Another example could be a telescope control application, where the rotation\n+ * would transform the sighting direction at rest into the desired observing\n+ * direction when the telescope is pointed towards an object of interest. In this\n+ * case the rotation transforms the directionf at rest in a topocentric frame\n+ * into the sighting direction in the same topocentric frame. In many case, both\n+ * approaches will be combined, in our telescope example, we will probably also\n+ * need to transform the observing direction in the topocentric frame into the\n+ * observing direction in inertial frame taking into account the observatory\n+ * location and the Earth rotation.</p>\n+\n+ * <p>These examples show that a rotation is what the user wants it to be, so this\n+ * class does not push the user towards one specific definition and hence does not\n+ * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n+ * <code>computeTransformedDirection</code>. It provides simpler and more generic\n+ * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n+ * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n+\n+ * <p>Since a rotation is basically a vectorial operator, several rotations can be\n+ * composed together and the composite operation <code>r = r<sub>1</sub> o\n+ * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n+ * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence\n+ * we can consider that in addition to vectors, a rotation can be applied to other\n+ * rotations as well (or to itself). With our previous notations, we would say we\n+ * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result\n+ * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n+ * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n+ * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+\n+ * <p>Rotations are guaranteed to be immutable objects.</p>\n+\n+ * @version $Id: Rotation.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ * @see Vector3D\n+ * @see RotationOrder\n+\n+ */\n+\n+public class Rotation implements Serializable {\n+\n+  /** Build the identity rotation.\n+   */\n+  public Rotation() {\n+    q0 = 1;\n+    q1 = 0;\n+    q2 = 0;\n+    q3 = 0;\n+  }\n+\n+  /** Build a rotation from the quaternion coordinates.\n+   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+   * the constructor can normalize it in a preprocessing step.</p>\n+   * @param q0 scalar part of the quaternion\n+   * @param q1 first coordinate of the vectorial part of the quaternion\n+   * @param q2 second coordinate of the vectorial part of the quaternion\n+   * @param q3 third coordinate of the vectorial part of the quaternion\n+   * @param needsNormalization if true, the coordinates are considered\n+   * not to be normalized, a normalization preprocessing step is performed\n+   * before using them\n+   */\n+  public Rotation(double q0, double q1, double q2, double q3,\n+                  boolean needsNormalization) {\n+\n+    if (needsNormalization) {\n+      // normalization preprocessing\n+      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n+      q0 *= inv;\n+      q1 *= inv;\n+      q2 *= inv;\n+      q3 *= inv;\n+    }\n+\n+    this.q0 = q0;\n+    this.q1 = q1;\n+    this.q2 = q2;\n+    this.q3 = q3;\n+\n+  }\n+\n+  /** Build a rotation from an axis and an angle.\n+   * <p>We use the convention that angles are oriented according to\n+   * the effect of the rotation on vectors around the axis. That means\n+   * that if (i, j, k) is a direct frame and if we first provide +k as\n+   * the axis and PI/2 as the angle to this constructor, and then\n+   * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n+   * +j.</p>\n+   * @param axis axis around which to rotate\n+   * @param angle rotation angle.\n+   * @exception ArithmeticException if the axis norm is null\n+   */\n+  public Rotation(Vector3D axis, double angle) {\n+\n+    double norm = axis.getNorm();\n+    if (norm == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double halfAngle = -0.5 * angle;\n+    double coeff = Math.sin(halfAngle) / norm;\n+\n+    q0 = Math.cos (halfAngle);\n+    q1 = coeff * axis.getX();\n+    q2 = coeff * axis.getY();\n+    q3 = coeff * axis.getZ();\n+\n+  }\n+\n+  /** Build a rotation from a 3X3 matrix.\n+\n+   * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+   * (which are matrices for which m.m<sup>T</sup> = I) with real\n+   * coefficients. The module of the determinant of unit matrices is\n+   * 1, among the orthogonal 3X3 matrices, only the ones having a\n+   * positive determinant (+1) are rotation matrices.</p>\n+\n+   * <p>When a rotation is defined by a matrix with truncated values\n+   * (typically when it is extracted from a technical sheet where only\n+   * four to five significant digits are available), the matrix is not\n+   * orthogonal anymore. This constructor handles this case\n+   * transparently by using a copy of the given matrix and applying a\n+   * correction to the copy in order to perfect its orthogonality. If\n+   * the Frobenius norm of the correction needed is above the given\n+   * threshold, then the matrix is considered to be too far from a\n+   * true rotation matrix and an exception is thrown.<p>\n+\n+   * @param m rotation matrix\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+\n+   * @exception NotARotationMatrixException if the matrix is not a 3X3\n+   * matrix, or if it cannot be transformed into an orthogonal matrix\n+   * with the given threshold, or if the determinant of the resulting\n+   * orthogonal matrix is negative\n+\n+   */\n+  public Rotation(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+\n+    // dimension check\n+    if ((m.length != 3) || (m[0].length != 3)\n+        || (m[1].length != 3) || (m[2].length != 3)) {\n+      throw new NotARotationMatrixException(\"a {0}x{1} matrix\"\n+                                            + \" cannot be a rotation matrix\",\n+                                            new String[] {\n+                                              Integer.toString(m.length),\n+                                              Integer.toString(m[0].length)\n+                                            });\n+    }\n+\n+    // compute a \"close\" orthogonal matrix\n+    double[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+    // check the sign of the determinant\n+    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2])\n+               - ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2])\n+               + ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n+    if (det < 0.0) {\n+      throw new NotARotationMatrixException(\"the closest orthogonal matrix\"\n+                                            + \" has a negative determinant {0}\",\n+                                            new String[] {\n+                                              Double.toString(det)\n+                                            });\n+    }\n+\n+    // There are different ways to compute the quaternions elements\n+    // from the matrix. They all involve computing one element from\n+    // the diagonal of the matrix, and computing the three other ones\n+    // unsing a formula involving a division by the first element,\n+    // which unfortunately can be null. Since the norm of the\n+    // quaternion is 1, we know at least one element has an absolute\n+    // value greater or equal to 0.5, so it is always possible to\n+    // select the right formula and avoid division by zero and even\n+    // numerical inaccuracy. Checking the elements in turn and using\n+    // the first one greater than 0.45 is safe (this leads to a simple\n+    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+    double s = ort[0][0] + ort[1][1] + ort[2][2];\n+    if (s > -0.19) {\n+      // compute q0 and deduce q1, q2 and q3\n+      q0 = 0.5 * Math.sqrt(s + 1.0);\n+      double inv = 0.25 / q0;\n+      q1 = inv * (ort[1][2] - ort[2][1]);\n+      q2 = inv * (ort[2][0] - ort[0][2]);\n+      q3 = inv * (ort[0][1] - ort[1][0]);\n+    } else {\n+      s = ort[0][0] - ort[1][1] - ort[2][2];\n+      if (s > -0.19) {\n+        // compute q1 and deduce q0, q2 and q3\n+        q1 = 0.5 * Math.sqrt(s + 1.0);\n+        double inv = 0.25 / q1;\n+        q0 = inv * (ort[1][2] - ort[2][1]);\n+        q2 = inv * (ort[0][1] + ort[1][0]);\n+        q3 = inv * (ort[0][2] + ort[2][0]);\n+      } else {\n+        s = ort[1][1] - ort[0][0] - ort[2][2];\n+        if (s > -0.19) {\n+          // compute q2 and deduce q0, q1 and q3\n+          q2 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q2;\n+          q0 = inv * (ort[2][0] - ort[0][2]);\n+          q1 = inv * (ort[0][1] + ort[1][0]);\n+          q3 = inv * (ort[2][1] + ort[1][2]);\n+        } else {\n+          // compute q3 and deduce q0, q1 and q2\n+          s = ort[2][2] - ort[0][0] - ort[1][1];\n+          q3 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q3;\n+          q0 = inv * (ort[0][1] - ort[1][0]);\n+          q1 = inv * (ort[0][2] + ort[2][0]);\n+          q2 = inv * (ort[2][1] + ort[1][2]);\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Build the rotation that transforms a pair of vector into another pair.\n+\n+   * <p>Except for possible scale factors, if the instance were applied to\n+   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+   * not the same as the angular separation between v<sub>1</sub> and\n+   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+   * v<sub>2</sub>) plane.</p>\n+\n+   * @param u1 first vector of the origin pair\n+   * @param u2 second vector of the origin pair\n+   * @param v1 desired image of u1 by the rotation\n+   * @param v2 desired image of u2 by the rotation\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n+\n+  // norms computation\n+  double u1u1 = Vector3D.dotProduct(u1, u1);\n+  double u2u2 = Vector3D.dotProduct(u2, u2);\n+  double v1v1 = Vector3D.dotProduct(v1, v1);\n+  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)\n+      || (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))\n+    throw new ArithmeticException(\"null norm\");\n+\n+  double u1x = u1.getX();\n+  double u1y = u1.getY();\n+  double u1z = u1.getZ();\n+\n+  double u2x = u2.getX();\n+  double u2y = u2.getY();\n+  double u2z = u2.getZ();\n+\n+  // renormalize v1 in order to have (v1'|v1') = (u1|u1)\n+  double coeff = Math.sqrt (u1u1 / v1v1);\n+  double v1x   = coeff * v1.getX();\n+  double v1y   = coeff * v1.getY();\n+  double v1z   = coeff * v1.getZ();\n+  v1 = new Vector3D(v1x, v1y, v1z);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n+  double u1u2   = Vector3D.dotProduct(u1, u2);\n+  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  double coeffU = u1u2 / u1u1;\n+  double coeffV = v1v2 / u1u1;\n+  double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n+  double alpha  = coeffU - beta * coeffV;\n+  double v2x    = alpha * v1x + beta * v2.getX();\n+  double v2y    = alpha * v1y + beta * v2.getY();\n+  double v2z    = alpha * v1z + beta * v2.getZ();\n+  v2 = new Vector3D(v2x, v2y, v2z);\n+\n+  // preliminary computation (we use explicit formulation instead\n+  // of relying on the Vector3D class in order to avoid building lots\n+  // of temporary objects)\n+  Vector3D uRef = u1;\n+  Vector3D vRef = v1;\n+  double dx1 = v1x - u1.getX();\n+  double dy1 = v1y - u1.getY();\n+  double dz1 = v1z - u1.getZ();\n+  double dx2 = v2x - u2.getX();\n+  double dy2 = v2y - u2.getY();\n+  double dz2 = v2z - u2.getZ();\n+  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n+                            dz1 * dx2 - dx1 * dz2,\n+                            dx1 * dy2 - dy1 * dx2);\n+  double c = k.getX() * (u1y * u2z - u1z * u2y)\n+           + k.getY() * (u1z * u2x - u1x * u2z)\n+           + k.getZ() * (u1x * u2y - u1y * u2x);\n+\n+  if (c < (1.0e-10 * u1u1 * u2u2)) {\n+    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+    // we try other vectors\n+    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    double u3x  = u3.getX();\n+    double u3y  = u3.getY();\n+    double u3z  = u3.getZ();\n+    double v3x  = v3.getX();\n+    double v3y  = v3.getY();\n+    double v3z  = v3.getZ();\n+    double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;\n+\n+    double dx3 = v3x - u3x;\n+    double dy3 = v3y - u3y;\n+    double dz3 = v3z - u3z;\n+    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n+                     dz1 * dx3 - dx1 * dz3,\n+                     dx1 * dy3 - dy1 * dx3);\n+    c = k.getX() * (u1y * u3z - u1z * u3y)\n+      + k.getY() * (u1z * u3x - u1x * u3z)\n+      + k.getZ() * (u1x * u3y - u1y * u3x);\n+\n+    if (c < (1.0e-10 * u1u1 * u3u3)) {\n+      // the (q1, q2, q3) vector is aligned with u1:\n+      // we try (u2, u3) and (v2, v3)\n+      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n+                       dz2 * dx3 - dx2 * dz3,\n+                       dx2 * dy3 - dy2 * dx3);\n+      c = k.getX() * (u2y * u3z - u2z * u3y)\n+        + k.getY() * (u2z * u3x - u2x * u3z)\n+        + k.getZ() * (u2x * u3y - u2y * u3x);\n+\n+      if (c < (1.0e-10 * u2u2 * u3u3)) {\n+        // the (q1, q2, q3) vector is aligned with everything\n+        // this is really the identity rotation\n+        q0 = 1.0;\n+        q1 = 0.0;\n+        q2 = 0.0;\n+        q3 = 0.0;\n+        return;\n+      }\n+\n+      // we will have to use u2 and v2 to compute the scalar part\n+      uRef = u2;\n+      vRef = v2;\n+\n+    }\n+\n+  }\n+\n+  // compute the vectorial part\n+  c = Math.sqrt(c);\n+  double inv = 1.0 / (c + c);\n+  q1 = inv * k.getX();\n+  q2 = inv * k.getY();\n+  q3 = inv * k.getZ();\n+\n+  // compute the scalar part\n+   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n+                    uRef.getZ() * q1 - uRef.getX() * q3,\n+                    uRef.getX() * q2 - uRef.getY() * q1);\n+   c = Vector3D.dotProduct(k, k);\n+  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+\n+  }\n+\n+  /** Build one of the rotations that transform one vector into another one.\n+\n+   * <p>Except for a possible scale factor, if the instance were\n+   * applied to the vector u it will produce the vector v. There is an\n+   * infinite number of such rotations, this constructor choose the\n+   * one with the smallest associated angle (i.e. the one whose axis\n+   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+   * arbitrary rotation axis is chosen.</p>\n+\n+   * @param u origin vector\n+   * @param v desired image of u by the rotation\n+   * @exception ArithmeticException if the norm of one of the vectors is null\n+   */\n+  public Rotation(Vector3D u, Vector3D v) {\n+\n+    double normProduct = u.getNorm() * v.getNorm();\n+    if (normProduct < 1.0e-15) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double dot = Vector3D.dotProduct(u, v);\n+\n+    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n+      // special case u = -v: we select a PI angle rotation around\n+      // an arbitrary vector orthogonal to u\n+      Vector3D w = u.orthogonal();\n+      q0 = 0.0;\n+      q1 = -w.getX();\n+      q2 = -w.getY();\n+      q3 = -w.getZ();\n+    } else {\n+      // general case: (u, v) defines a plane, we select\n+      // the shortest possible rotation: axis orthogonal to this plane\n+      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));\n+      double coeff = 1.0 / (2.0 * q0 * normProduct);\n+      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n+      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n+      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+    }\n+\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+   * <p>Cardan rotations are three successive rotations around the\n+   * canonical axes X, Y and Z, each axis beeing used once. There are\n+   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+   * rotations are three successive rotations around the canonical\n+   * axes X, Y and Z, the first and last rotations beeing around the\n+   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+   * <p>Beware that many people routinely use the term Euler angles even\n+   * for what really are Cardan angles (this confusion is especially\n+   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+   * are often wrongly tagged as Euler angles).</p>\n+\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public Rotation(RotationOrder order,\n+                  double alpha1, double alpha2, double alpha3) {\n+    Rotation r1 = new Rotation(order.getA1(), alpha1);\n+    Rotation r2 = new Rotation(order.getA2(), alpha2);\n+    Rotation r3 = new Rotation(order.getA3(), alpha3);\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n+  }\n+\n+  /** Revert a rotation.\n+   * Build a rotation which reverse the effect of another\n+   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n+   * instance is not changed.\n+   * @return a new rotation whose effect is the reverse of the effect\n+   * of the instance\n+   */\n+  public Rotation revert() {\n+    return new Rotation(-q0, q1, q2, q3, false);\n+  }\n+\n+  /** Get the scalar coordinate of the quaternion.\n+   * @return scalar coordinate of the quaternion\n+   */\n+  public double getQ0() {\n+    return q0;\n+  }\n+\n+  /** Get the first coordinate of the vectorial part of the quaternion.\n+   * @return first coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ1() {\n+    return q1;\n+  }\n+\n+  /** Get the second coordinate of the vectorial part of the quaternion.\n+   * @return second coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ2() {\n+    return q2;\n+  }\n+\n+  /** Get the third coordinate of the vectorial part of the quaternion.\n+   * @return third coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ3() {\n+    return q3;\n+  }\n+\n+  /** Get the normalized axis of the rotation.\n+   * @return normalized axis of the rotation\n+   */\n+  public Vector3D getAxis() {\n+    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n+    if (squaredSine < 1.0e-12) {\n+      return new Vector3D(1, 0, 0);\n+    } else if (q0 < 0) {\n+      double inverse = 1 / Math.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    } else {\n+      double inverse = -1 / Math.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    }\n+  }\n+\n+  /** Get the angle of the rotation.\n+   * @return angle of the rotation (between 0 and &pi;)\n+   */\n+  public double getAngle() {\n+    if ((q0 < -0.1) || (q0 > 0.1)) {\n+      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n+    } else if (q0 < 0) {\n+      return 2 * Math.acos(-q0);\n+    } else {\n+      return 2 * Math.acos(q0);\n+    }\n+  }\n+\n+  /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+   * <p>The equations show that each rotation can be defined by two\n+   * different values of the Cardan or Euler angles set. For example\n+   * if Cardan angles are used, the rotation defined by the angles\n+   * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+   * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+   * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+   * the following arbitrary choices. For Cardan angles, the chosen\n+   * set is the one for which the second angle is between -&pi;/2 and\n+   * &pi;/2 (i.e its cosine is positive). For Euler angles, the chosen\n+   * set is the one for which the second angle is between 0 and &pi;\n+   * (i.e its sine is positive).</p>\n+\n+   * <p>Cardan and Euler angle have a very disappointing drawback: all\n+   * of them have singularities. This means that if the instance is\n+   * too close to the singularities corresponding to the given\n+   * rotation order, it will be impossible to retrieve the angles. For\n+   * Cardan angles, this is often called gimbal lock. There is\n+   * <em>nothing</em> to do to prevent this, it is an intrisic problem\n+   * with Cardan and Euler representation (but not a problem with the\n+   * rotation itself, which is perfectly well defined). For Cardan\n+   * angles, singularities occur when the second angle is close to\n+   * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+   * second angle is close to 0 or &pi;, this implies that the identity\n+   * rotation is always singular for Euler angles!\n+\n+   * @param order rotation order to use\n+   * @return an array of three angles, in the order specified by the set\n+   * @exception CardanEulerSingularityException if the rotation is\n+   * singular with respect to the angles set specified\n+   */\n+  public double[] getAngles(RotationOrder order)\n+    throws CardanEulerSingularityException {\n+\n+    final double small        = 1.0e-10;\n+    final double maxThreshold = 1.0 - small;\n+    final double minThreshold = -maxThreshold;\n+\n+    double[] angles = new double[3];\n+    Vector3D v1 = null;\n+    Vector3D v2 = null;\n+\n+    if (order == RotationOrder.XYZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if  ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getY()), v1.getZ());\n+      angles[1] = Math.asin(v2.getZ());\n+      angles[2] = Math.atan2(-(v2.getY()), v2.getX());\n+\n+    } else if (order == RotationOrder.XZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n+      angles[1] = -Math.asin(v2.getY());\n+      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+\n+    } else if (order == RotationOrder.YXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n+      angles[1] = -Math.asin(v2.getZ());\n+      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+\n+    } else if (order == RotationOrder.YZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getZ()), v1.getX());\n+      angles[1] = Math.asin(v2.getX());\n+      angles[2] = Math.atan2(-(v2.getZ()), v2.getY());\n+\n+    } else if (order == RotationOrder.ZXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(-(v1.getX()), v1.getY());\n+      angles[1] = Math.asin(v2.getY());\n+      angles[2] = Math.atan2(-(v2.getX()), v2.getZ());\n+\n+    } else if (order == RotationOrder.ZYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), v1.getX());\n+      angles[1] = -Math.asin(v2.getX());\n+      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+\n+    } else if (order == RotationOrder.XYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), -v1.getZ());\n+      angles[1] = Math.acos(v2.getX());\n+      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+\n+    } else if (order == RotationOrder.XZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusI);\n+      v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n+      angles[1] = Math.acos(v2.getX());\n+      angles[2] = Math.atan2(v2.getZ(), -v2.getY());\n+\n+    } else if (order == RotationOrder.YXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n+      angles[1] = Math.acos(v2.getY());\n+      angles[2] = Math.atan2(v2.getX(), -v2.getZ());\n+\n+    } else if (order == RotationOrder.YZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusJ);\n+      v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getZ(), -v1.getX());\n+      angles[1] = Math.acos(v2.getY());\n+      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+\n+    } else if (order == RotationOrder.ZXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getX(), -v1.getY());\n+      angles[1] = Math.acos(v2.getZ());\n+      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+\n+    } else { // last possibility is ZYZ\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      v1 = applyTo(Vector3D.plusK);\n+      v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      angles[0] = Math.atan2(v1.getY(), v1.getX());\n+      angles[1] = Math.acos(v2.getZ());\n+      angles[2] = Math.atan2(v2.getY(), -v2.getX());\n+\n+    }\n+\n+    return angles;\n+\n+  }\n+\n+  /** Get the 3X3 matrix corresponding to the instance\n+   * @return the matrix corresponding to the instance\n+   */\n+  public double[][] getMatrix() {\n+\n+    // products\n+    double q0q0  = q0 * q0;\n+    double q0q1  = q0 * q1;\n+    double q0q2  = q0 * q2;\n+    double q0q3  = q0 * q3;\n+    double q1q1  = q1 * q1;\n+    double q1q2  = q1 * q2;\n+    double q1q3  = q1 * q3;\n+    double q2q2  = q2 * q2;\n+    double q2q3  = q2 * q3;\n+    double q3q3  = q3 * q3;\n+\n+    // create the matrix\n+    double[][] m = new double[3][];\n+    m[0] = new double[3];\n+    m[1] = new double[3];\n+    m[2] = new double[3];\n+\n+    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n+    m [1][0] = 2.0 * (q1q2 - q0q3);\n+    m [2][0] = 2.0 * (q1q3 + q0q2);\n+\n+    m [0][1] = 2.0 * (q1q2 + q0q3);\n+    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n+    m [2][1] = 2.0 * (q2q3 - q0q1);\n+\n+    m [0][2] = 2.0 * (q1q3 - q0q2);\n+    m [1][2] = 2.0 * (q2q3 + q0q1);\n+    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n+\n+    return m;\n+\n+  }\n+\n+  /** Apply the rotation to a vector.\n+   * @param u vector to apply the rotation to\n+   * @return a new vector which is the image of u by the rotation\n+   */\n+  public Vector3D applyTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+\n+    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the inverse of the rotation to a vector.\n+   * @param u vector to apply the inverse of the rotation to\n+   * @return a new vector which such that u is its image by the rotation\n+   */\n+  public Vector3D applyInverseTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+    double m0 = -q0;\n+\n+    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the instance to another rotation.\n+   * Applying the instance to a rotation is computing the composition\n+   * in an order compliant with the following rule : let u be any\n+   * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+   * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+   * where comp = applyTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the instance\n+   */\n+  public Rotation applyTo(Rotation r) {\n+    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Apply the inverse of the instance to another rotation.\n+   * Applying the inverse of the instance to a rotation is computing\n+   * the composition in an order compliant with the following rule :\n+   * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+   * let w be the inverse image of v by the instance\n+   * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+   * comp = applyInverseTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the inverse\n+   * of the instance\n+   */\n+  public Rotation applyInverseTo(Rotation r) {\n+    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Perfect orthogonality on a 3X3 matrix.\n+   * @param m initial matrix (not exactly orthogonal)\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+   * @return an orthogonal matrix close to m\n+   * @exception NotARotationMatrixException if the matrix cannot be\n+   * orthogonalized with the given threshold after 10 iterations\n+   */\n+  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+    double x00 = m[0][0];\n+    double x01 = m[0][1];\n+    double x02 = m[0][2];\n+    double x10 = m[1][0];\n+    double x11 = m[1][1];\n+    double x12 = m[1][2];\n+    double x20 = m[2][0];\n+    double x21 = m[2][1];\n+    double x22 = m[2][2];\n+    double fn = 0;\n+    double fn1;\n+\n+    double[][] o = new double[3][];\n+    o[0] = new double[3];\n+    o[1] = new double[3];\n+    o[2] = new double[3];\n+\n+    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+    int i = 0;\n+    while (++i < 11) {\n+\n+      // Mt.Xn\n+      double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;\n+      double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;\n+      double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;\n+      double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;\n+      double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;\n+      double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;\n+      double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;\n+      double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;\n+      double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;\n+\n+      // Xn+1\n+      o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);\n+      o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);\n+      o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);\n+      o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);\n+      o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);\n+      o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);\n+      o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);\n+      o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);\n+      o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);\n+\n+      // correction on each elements\n+      double corr00 = o[0][0] - m[0][0];\n+      double corr01 = o[0][1] - m[0][1];\n+      double corr02 = o[0][2] - m[0][2];\n+      double corr10 = o[1][0] - m[1][0];\n+      double corr11 = o[1][1] - m[1][1];\n+      double corr12 = o[1][2] - m[1][2];\n+      double corr20 = o[2][0] - m[2][0];\n+      double corr21 = o[2][1] - m[2][1];\n+      double corr22 = o[2][2] - m[2][2];\n+\n+      // Frobenius norm of the correction\n+      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02\n+        + corr10 * corr10 + corr11 * corr11 + corr12 * corr12\n+        + corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+      // convergence test\n+      if (Math.abs(fn1 - fn) <= threshold)\n+        return o;\n+\n+      // prepare next iteration\n+      x00 = o[0][0];\n+      x01 = o[0][1];\n+      x02 = o[0][2];\n+      x10 = o[1][0];\n+      x11 = o[1][1];\n+      x12 = o[1][2];\n+      x20 = o[2][0];\n+      x21 = o[2][1];\n+      x22 = o[2][2];\n+      fn  = fn1;\n+\n+    }\n+\n+    // the algorithm did not converge after 10 iterations\n+    throw new NotARotationMatrixException(\"unable to orthogonalize matrix\"\n+                                          + \" in {0} iterations\",\n+                                          new String[] {\n+                                            Integer.toString(i - 1)\n+                                          });\n+  }\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private final double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private final double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private final double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private final double q3;\n+\n+  private static final long serialVersionUID = 5127795878493115119L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/RotationOrder.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+/**\n+ * This class is a utility representing a rotation order specification\n+ * for Cardan or Euler angles specification.\n+\n+ * This class cannot be instanciated by the user. He can only use one\n+ * of the twelve predefined supported orders as an argument to either\n+ * the {@link Rotation#Rotation(RotationOrder,double,double,double)}\n+ * constructor or the {@link Rotation#getAngles} method.\n+\n+ * @version $Id: RotationOrder.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+public final class RotationOrder {\n+\n+  /** Private constructor.\n+   * This is a utility class that cannot be instantiated by the user,\n+   * so its only constructor is private.\n+   * @param name name of the rotation order\n+   * @param a1 axis of the first rotation\n+   * @param a2 axis of the second rotation\n+   * @param a3 axis of the third rotation\n+   */\n+  private RotationOrder(String name,\n+                        Vector3D a1, Vector3D a2, Vector3D a3) {\n+    this.name = name;\n+    this.a1   = a1;\n+    this.a2   = a2;\n+    this.a3   = a3;\n+  }\n+\n+  /** Get a string representation of the instance.\n+   * @return a string representation of the instance (in fact, its name)\n+   */\n+  public String toString() {\n+    return name;\n+  }\n+\n+  /** Get the axis of the first rotation.\n+   * @return axis of the first rotation\n+   */\n+  public Vector3D getA1() {\n+    return a1;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA2() {\n+    return a2;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA3() {\n+    return a3;\n+  }\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder XYZ =\n+    new RotationOrder(\"XYZ\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder XZY =\n+    new RotationOrder(\"XZY\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder YXZ =\n+    new RotationOrder(\"YXZ\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder YZX =\n+    new RotationOrder(\"YZX\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder ZXY =\n+    new RotationOrder(\"ZXY\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder ZYX =\n+    new RotationOrder(\"ZYX\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder XYX =\n+    new RotationOrder(\"XYX\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder XZX =\n+    new RotationOrder(\"XZX\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder YXY =\n+    new RotationOrder(\"YXY\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder YZY =\n+    new RotationOrder(\"YZY\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZXZ =\n+    new RotationOrder(\"ZXZ\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZYZ =\n+    new RotationOrder(\"ZYZ\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);\n+\n+  /** Name of the rotations order. */\n+  private final String name;\n+\n+  /** Axis of the first rotation. */\n+  private final Vector3D a1;\n+\n+  /** Axis of the second rotation. */\n+  private final Vector3D a2;\n+\n+  /** Axis of the third rotation. */\n+  private final Vector3D a3;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+\n+/** This class implements vectors in a three-dimensional space.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @version $Id: Vector3D.java 1716 2006-12-13 22:56:35Z luc $\n+ * @author L. Maisonobe\n+ */\n+\n+public class Vector3D\n+  implements Serializable {\n+\n+  /** First canonical vector (coordinates : 1, 0, 0). */\n+  public static final Vector3D plusI = new Vector3D(1, 0, 0);\n+\n+  /** Opposite of the first canonical vector (coordinates : -1, 0, 0). */\n+  public static final Vector3D minusI = new Vector3D(-1, 0, 0);\n+\n+  /** Second canonical vector (coordinates : 0, 1, 0). */\n+  public static final Vector3D plusJ = new Vector3D(0, 1, 0);\n+\n+  /** Opposite of the second canonical vector (coordinates : 0, -1, 0). */\n+  public static final Vector3D minusJ = new Vector3D(0, -1, 0);\n+\n+  /** Third canonical vector (coordinates : 0, 0, 1). */\n+  public static final Vector3D plusK = new Vector3D(0, 0, 1);\n+\n+  /** Opposite of the third canonical vector (coordinates : 0, 0, -1).  */\n+  public static final Vector3D minusK = new Vector3D(0, 0, -1);\n+\n+  /** Simple constructor.\n+   * Build a null vector.\n+   */\n+  public Vector3D() {\n+    x = 0;\n+    y = 0;\n+    z = 0;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate\n+   * @param z height\n+   * @see #getX()\n+   * @see #getY()\n+   * @see #getZ()\n+   */\n+  public Vector3D(double x, double y, double z) {\n+    this.x = x;\n+    this.y = y;\n+    this.z = z;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its azimuthal coordinates\n+   * @param alpha azimuth (&alpha;) around Z\n+   *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+   * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+   * @see #getAlpha()\n+   * @see #getDelta()\n+   */\n+  public Vector3D(double alpha, double delta) {\n+    double cosDelta = Math.cos(delta);\n+    this.x = Math.cos(alpha) * cosDelta;\n+    this.y = Math.sin(alpha) * cosDelta;\n+    this.z = Math.sin(delta);\n+  }\n+\n+  /** Multiplicative constructor\n+   * Build a vector from another one and a scale factor. \n+   * The vector built will be a * u\n+   * @param a scale factor\n+   * @param u base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u) {\n+    this.x = a * u.x;\n+    this.y = a * u.y;\n+    this.z = a * u.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from two other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n+    this.x = a1 * u1.x + a2 * u2.x;\n+    this.y = a1 * u1.y + a2 * u2.y;\n+    this.z = a1 * u1.z + a2 * u2.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from three other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from four other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   * @param a4 fourth scale factor\n+   * @param u4 fourth base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3, double a4, Vector3D u4) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n+  }\n+\n+  /** Get the abscissa of the vector.\n+   * @return abscissa of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /** Get the ordinate of the vector.\n+   * @return ordinate of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getY() {\n+    return y;\n+  }\n+\n+  /** Get the height of the vector.\n+   * @return height of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getZ() {\n+    return z;\n+  }\n+\n+  /** Get the norm for the vector.\n+   * @return euclidian norm for the vector\n+   */\n+  public double getNorm() {\n+    return Math.sqrt (x * x + y * y + z * z);\n+  }\n+\n+  /** Get the azimuth of the vector.\n+   * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getAlpha() {\n+    return Math.atan2(y, x);\n+  }\n+\n+  /** Get the elevation of the vector.\n+   * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getDelta() {\n+    return Math.asin(z / getNorm());\n+  }\n+\n+  /** Add a vector to the instance.\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(Vector3D v) {\n+    return new Vector3D(x + v.x, y + v.y, z + v.z);\n+  }\n+\n+  /** Add a scaled vector to the instance.\n+   * @param factor scale factor to apply to v before adding it\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(double factor, Vector3D v) {\n+    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(Vector3D v) {\n+    return new Vector3D(x - v.x, y - v.y, z - v.z);\n+  }\n+\n+  /** Subtract a scaled vector from the instance.\n+   * @param factor scale factor to apply to v before subtracting it\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(double factor, Vector3D v) {\n+    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n+  }\n+\n+  /** Normalize the instance.\n+   * @return a new normalized vector\n+   * @exception ArithmeticException if the norm is null\n+   */\n+  public Vector3D normalize() {\n+    double s = getNorm();\n+    if (s == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+    return multiply(1 / s);\n+  }\n+\n+  /** Get a vector orthogonal to the instance.\n+   * <p>There are an infinite number of normalized vectors orthogonal\n+   * to the instance. This method picks up one of them almost\n+   * arbitrarily. It is useful when one needs to compute a reference\n+   * frame with one of the axes in a predefined direction. The\n+   * following example shows how to build a frame having the k axis\n+   * aligned with the known vector u :\n+   * <pre><code>\n+   *   Vector3D k = u.normalize();\n+   *   Vector3D i = k.orthogonal();\n+   *   Vector3D j = Vector3D.crossProduct(k, i);\n+   * </code></pre></p>\n+   * @return a new normalized vector orthogonal to the instance\n+   * @exception ArithmeticException if the norm of the instance is null\n+   */\n+  public Vector3D orthogonal() {\n+\n+    double threshold = 0.6 * getNorm();\n+    if (threshold == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    if ((x >= -threshold) && (x <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(y * y + z * z);\n+      return new Vector3D(0, inverse * z, -inverse * y);\n+    } else if ((y >= -threshold) && (y <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(x * x + z * z);\n+      return new Vector3D(-inverse * z, 0, inverse * x);\n+    } else {\n+      double inverse  = 1 / Math.sqrt(x * x + y * y);\n+      return new Vector3D(inverse * y, -inverse * x, 0);\n+    }\n+\n+  }\n+\n+  /** Compute the angular separation between two vectors.\n+   * <p>This method computes the angular separation between two\n+   * vectors using the dot product for well separated vectors and the\n+   * cross product for almost aligned vectors. This allow to have a\n+   * good accuracy in all cases, even for vectors very close to each\n+   * other.</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @exception ArithmeticException if either vector has a null norm\n+   */\n+  public static double angle(Vector3D v1, Vector3D v2) {\n+\n+    double normProduct = v1.getNorm() * v2.getNorm();\n+    if (normProduct == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+    }\n+\n+    double dot = dotProduct(v1, v2);\n+    double threshold = normProduct * 0.9999;\n+    if ((dot < -threshold) || (dot > threshold)) {\n+      // the vectors are almost aligned, compute using the sine\n+      Vector3D v3 = crossProduct(v1, v2);\n+      if (dot >= 0) {\n+        return Math.asin(v3.getNorm() / normProduct);\n+      }\n+      return Math.PI - Math.asin(v3.getNorm() / normProduct);\n+    }\n+    \n+    // the vectors are sufficiently separated to use the cosine\n+    return Math.acos(dot / normProduct);\n+\n+  }\n+\n+  /** Get the opposite of the instance.\n+   * @return a new vector which is opposite to the instance\n+   */\n+  public Vector3D negate() {\n+    return new Vector3D(-x, -y, -z);\n+  }\n+\n+  /** Multiply the instance by a scalar\n+   * @param a scalar\n+   * @return a new vector\n+   */\n+  public Vector3D multiply(double a) {\n+    return new Vector3D(a * x, a * y, a * z);\n+  }\n+\n+  /** Compute the dot-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the dot product v1.v2\n+   */\n+  public static double dotProduct(Vector3D v1, Vector3D v2) {\n+    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n+  }\n+\n+  /** Compute the cross-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the cross product v1 ^ v2 as a new Vector\n+   */\n+  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n+    return new Vector3D(v1.y * v2.z - v1.z * v2.y,\n+                        v1.z * v2.x - v1.x * v2.z,\n+                        v1.x * v2.y - v1.y * v2.x);\n+  }\n+\n+  /** Abscissa. */\n+  private final double x;\n+\n+  /** Ordinate. */\n+  private final double y;\n+\n+  /** Height. */\n+  private final double z;\n+\n+  private static final long serialVersionUID = 7318440192750283659L;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/RotationTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.geometry.CardanEulerSingularityException;\n+import org.apache.commons.math.geometry.NotARotationMatrixException;\n+import org.apache.commons.math.geometry.Rotation;\n+import org.apache.commons.math.geometry.RotationOrder;\n+import org.apache.commons.math.geometry.Vector3D;\n+\n+import junit.framework.*;\n+\n+public class RotationTest\n+  extends TestCase {\n+\n+  public RotationTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testIdentity() {\n+\n+    Rotation r = new Rotation();\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(-1, 0, 0, 0, false);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(42, 0, 0, 0, true);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkAngle(r.getAngle(), 0);\n+\n+  }\n+\n+  public void testAxisAngle() {\n+\n+    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);\n+    double s = 1 / Math.sqrt(3);\n+    checkVector(r.getAxis(), new Vector3D(s, s, s));\n+    checkAngle(r.getAngle(), 2 * Math.PI / 3);\n+\n+    try {\n+      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    } catch (Exception e) {\n+      fail(\"unexpected exception\");\n+    }\n+\n+    r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);\n+    checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n+    checkAngle(r.getAngle(), 0.5 * Math.PI);\n+\n+    r = new Rotation(Vector3D.plusJ, Math.PI);\n+    checkVector(r.getAxis(), Vector3D.plusJ);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testVectorOnePair() {\n+\n+    Vector3D u = new Vector3D(3, 2, 1);\n+    Vector3D v = new Vector3D(-4, 2, 2);\n+    Rotation r = new Rotation(u, v);\n+    checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));\n+\n+    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testVectorTwoPairs() {\n+\n+    Vector3D u1 = new Vector3D(3, 0, 0);\n+    Vector3D u2 = new Vector3D(0, 5, 0);\n+    Vector3D v1 = new Vector3D(0, 0, 2);\n+    Vector3D v2 = new Vector3D(-2, 0, 2);\n+    Rotation r = new Rotation(u1, u2, v1, v2);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);\n+\n+    r = new Rotation(u1, u2, u1.negate(), u2.negate());\n+    Vector3D axis = r.getAxis();\n+    if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {\n+      checkVector(axis, Vector3D.plusK);\n+    } else {\n+      checkVector(axis, Vector3D.minusK);\n+    }\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+  }\n+\n+  public void testMatrix()\n+    throws NotARotationMatrixException {\n+\n+    double[][] m1 = { { 0.0, 1.0, 0.0 },\n+                      { 0.0, 0.0, 1.0 },\n+                      { 1.0, 0.0, 0.0 } };\n+    Rotation r = new Rotation(m1, 1.0e-7);\n+    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);\n+\n+    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+                      { 0.48293,  0.78164, -0.39474 },\n+                      { 0.27296,  0.29396,  0.91602 } };\n+    r = new Rotation(m2, 1.0e-12);\n+\n+    double[][] m3 = r.getMatrix();\n+    double d00 = m2[0][0] - m3[0][0];\n+    double d01 = m2[0][1] - m3[0][1];\n+    double d02 = m2[0][2] - m3[0][2];\n+    double d10 = m2[1][0] - m3[1][0];\n+    double d11 = m2[1][1] - m3[1][1];\n+    double d12 = m2[1][2] - m3[1][2];\n+    double d20 = m2[2][0] - m3[2][0];\n+    double d21 = m2[2][1] - m3[2][1];\n+    double d22 = m2[2][2] - m3[2][2];\n+\n+    assertTrue(Math.abs(d00) < 6.0e-6);\n+    assertTrue(Math.abs(d01) < 6.0e-6);\n+    assertTrue(Math.abs(d02) < 6.0e-6);\n+    assertTrue(Math.abs(d10) < 6.0e-6);\n+    assertTrue(Math.abs(d11) < 6.0e-6);\n+    assertTrue(Math.abs(d12) < 6.0e-6);\n+    assertTrue(Math.abs(d20) < 6.0e-6);\n+    assertTrue(Math.abs(d21) < 6.0e-6);\n+    assertTrue(Math.abs(d22) < 6.0e-6);\n+\n+    assertTrue(Math.abs(d00) > 4.0e-7);\n+    assertTrue(Math.abs(d01) > 4.0e-7);\n+    assertTrue(Math.abs(d02) > 4.0e-7);\n+    assertTrue(Math.abs(d10) > 4.0e-7);\n+    assertTrue(Math.abs(d11) > 4.0e-7);\n+    assertTrue(Math.abs(d12) > 4.0e-7);\n+    assertTrue(Math.abs(d20) > 4.0e-7);\n+    assertTrue(Math.abs(d21) > 4.0e-7);\n+    assertTrue(Math.abs(d22) > 4.0e-7);\n+\n+    for (int i = 0; i < 3; ++i) {\n+      for (int j = 0; j < 3; ++j) {\n+        double m3tm3 = m3[i][0] * m3[j][0]\n+                     + m3[i][1] * m3[j][1]\n+                     + m3[i][2] * m3[j][2];\n+        if (i == j) {\n+          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);\n+        } else {\n+          assertTrue(Math.abs(m3tm3) < 1.0e-10);\n+        }\n+      }\n+    }\n+\n+    checkVector(r.applyTo(Vector3D.plusI),\n+                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n+    checkVector(r.applyTo(Vector3D.plusJ),\n+                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n+    checkVector(r.applyTo(Vector3D.plusK),\n+                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n+\n+    double[][] m4 = { { 1.0,  0.0,  0.0 },\n+                      { 0.0, -1.0,  0.0 },\n+                      { 0.0,  0.0, -1.0 } };\n+    r = new Rotation(m4, 1.0e-7);\n+    checkAngle(r.getAngle(), Math.PI);\n+\n+    try {\n+      double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                        { 0.0, 1.0, 0.0 },\n+                        { 1.0, 0.0, 0.0 } };\n+      r = new Rotation(m5, 1.0e-7);\n+      fail(\"got \" + r + \", should have caught an exception\");\n+    } catch (NotARotationMatrixException e) {\n+      // expected\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  public void testAngles()\n+    throws CardanEulerSingularityException {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    RotationOrder[] EulerOrders = {\n+      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+    };\n+\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(CardanOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(CardanOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(EulerOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(EulerOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testQuaternion() {\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    double n = 23.5;\n+    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),\n+                               n * r1.getQ2(), n * r1.getQ3(),\n+                               true);\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(u), r1.applyTo(u));\n+        }\n+      }\n+    }\n+  }\n+\n+  public void testCompose() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testComposeInverse() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyInverseTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  public void testApplyInverseTo() {\n+\n+    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          r.applyInverseTo(r.applyTo(u));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation();\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation(Vector3D.plusK, Math.PI);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n+                                    Math.sin(lambda) * Math.cos(phi),\n+                                    Math.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n+  }\n+\n+  private void checkAngle(double a1, double a2) {\n+    a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));\n+    assertTrue(Math.abs(a1 - a2) < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RotationTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.geometry.Vector3D;\n+\n+import junit.framework.*;\n+\n+public class Vector3DTest\n+  extends TestCase {\n+\n+  public Vector3DTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testCoordinates() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);\n+    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);\n+    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);\n+  }\n+  \n+  public void testNorm() {\n+    assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);\n+    assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))\n+               < 1.0e-12);\n+  }\n+\n+  public void testSubtract() {\n+\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1 = v1.subtract(v2);\n+    checkVector(v1, new Vector3D(4, 4, 4));\n+\n+    checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));\n+\n+  }\n+\n+  public void testAdd() {\n+    Vector3D v1 = new Vector3D(1, 2, 3);\n+    Vector3D v2 = new Vector3D(-3, -2, -1);\n+    v1 = v1.add(v2);\n+    checkVector(v1, new Vector3D(-2, 0, 2));\n+\n+    checkVector(v2.add(v1), new Vector3D(-5, -2, 1));\n+\n+  }\n+\n+  public void testScalarProduct() {\n+    Vector3D v = new Vector3D(1, 2, 3);\n+    v = v.multiply(3);\n+    checkVector(v, new Vector3D(3, 6, 9));\n+\n+    checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));\n+\n+  }\n+\n+  public void testVectorialProducts() {\n+    Vector3D v1 = new Vector3D(2, 1, -4);\n+    Vector3D v2 = new Vector3D(3, 1, -1);\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n+\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    checkVector(v3, new Vector3D(3, -10, -1));\n+\n+    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n+    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n+\n+  }\n+\n+  public void testAngular() {\n+\n+    assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);\n+\n+    Vector3D u = new Vector3D(-1, 1, -1);\n+    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n+    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);\n+\n+  }\n+\n+  public void testAngularSeparation() {\n+    Vector3D v1 = new Vector3D(2, -1, 4);\n+\n+    Vector3D  k = v1.normalize();\n+    Vector3D  i = k.orthogonal();\n+    Vector3D v2 = k.multiply(Math.cos(1.2)).add(i.multiply(Math.sin(1.2)));\n+\n+    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(Vector3DTest.class);\n+  }\n+\n+}", "timestamp": 1172607752, "metainfo": ""}