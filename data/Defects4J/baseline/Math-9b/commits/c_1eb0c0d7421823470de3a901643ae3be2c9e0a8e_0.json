{"sha": "1eb0c0d7421823470de3a901643ae3be2c9e0a8e", "log": "added the dfp library The Dfp class represent the high precision numbers, it implements our existing Field interface and hence each instance is associated with a DfpField that provides the constants at the required precision as well as factory methods. This allowed to remove the compile-time constraint in the library. Users can even use at the same time a field for 20 decimals digits precision and another field for 100 digits precision. Dfp instances with different precision CANNOT be mixed in the same computation (doing so creates a NaN). A few utility methods have been added, like constructors from integral types, isInfinite and isNaN methods, equal has been renames to equals and its signature changed to match the general Object method (a hashcode method has been added too). JIRA: MATH-412  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ *  Decimal floating point library for Java\n+ *\n+ *  <p>Another floating point class.  This one is built using radix 10000\n+ *  which is 10<sup>4</sup>, so its almost decimal.</p>\n+ *\n+ *  <p>The design goals here are:\n+ *  <ol>\n+ *    <li>Decimal math, or close to it</li>\n+ *    <li>Settable precision (but no mix between numbers using different settings)</li>\n+ *    <li>Portability.  Code should be keep as portable as possible.</li>\n+ *    <li>Performance</li>\n+ *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n+ *         algebraic operation</li>\n+ *    <li>Comply with IEEE 854-1987 as much as possible.\n+ *         (See IEEE 854-1987 notes below)</li>\n+ *  </ol></p>\n+ *\n+ *  <p>Trade offs:\n+ *  <ol>\n+ *    <li>Memory foot print.  I'm using more memory than necessary to\n+ *         represent numbers to get better performance.</li>\n+ *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n+ *         really need 12 decimal digits, better use 4 base 10000 digits\n+ *         there can be one partially filled.</li>\n+ *  </ol></p>\n+ *\n+ *  <p>Numbers are represented  in the following form:\n+ *  <pre>\n+ *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n+ *  </pre>\n+ *  where sign is &plusmn;1, mantissa represents a fractional number between\n+ *  zero and one.  mant[0] is the least significant digit.\n+ *  exp is in the range of -32767 to 32768</p>\n+ *\n+ *  <p>IEEE 854-1987  Notes and differences</p>\n+ *\n+ *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n+ *  10000, so that requirement is not met, but  it is possible that a\n+ *  subclassed can be made to make it behave as a radix 10\n+ *  number.  It is my opinion that if it looks and behaves as a radix\n+ *  10 number then it is one and that requirement would be met.</p>\n+ *\n+ *  <p>The radix of 10000 was chosen because it should be faster to operate\n+ *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n+ *  can be realized by add an additional rounding step to ensure that\n+ *  the number of decimal digits represented is constant.</p>\n+ *\n+ *  <p>The IEEE standard specifically leaves out internal data encoding,\n+ *  so it is reasonable to conclude that such a subclass of this radix\n+ *  10000 system is merely an encoding of a radix 10 system.</p>\n+ *\n+ *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n+ *  class does not contain any such entities.  The most significant radix\n+ *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n+ *  by raising the underflow flag for numbers less with exponent less than\n+ *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n+ *  Thus the smallest number we can represent would be:\n+ *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n+ *  be 1e-131092.</p>\n+ *\n+ *  <p>IEEE 854 defines that the implied radix point lies just to the right\n+ *  of the most significant digit and to the left of the remaining digits.\n+ *  This implementation puts the implied radix point to the left of all\n+ *  digits including the most significant one.  The most significant digit\n+ *  here is the one just to the right of the radix point.  This is a fine\n+ *  detail and is really only a matter of definition.  Any side effects of\n+ *  this can be rendered invisible by a subclass.</p>\n+ * @see DfpField\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class Dfp implements FieldElement<Dfp> {\n+\n+    /** The radix, or base of this system.  Set to 10000 */\n+    public static final int RADIX = 10000;\n+\n+    /** The minimum exponent before underflow is signaled.  Flush to zero\n+     *  occurs at minExp-DIGITS */\n+    public static final int MIN_EXP = -32767;\n+\n+    /** The maximum exponent before overflow is signaled and results flushed\n+     *  to infinity */\n+    public static final int MAX_EXP =  32768;\n+\n+    /** The amount under/overflows are scaled by before going to trap handler */\n+    public static final int ERR_SCALE = 32760;\n+\n+    /** Indicator value for normal finite numbers. */\n+    public static final byte FINITE = 0;\n+\n+    /** Indicator value for Infinity. */\n+    public static final byte INFINITE = 1;\n+\n+    /** Indicator value for signaling NaN. */\n+    public static final byte SNAN = 2;\n+\n+    /** Indicator value for quiet NaN. */\n+    public static final byte QNAN = 3;\n+\n+    /** String for NaN representation. */\n+    private static final String NAN_STRING = \"NaN\";\n+\n+    /** String for positive infinity representation. */\n+    private static final String POS_INFINITY_STRING = \"Infinity\";\n+\n+    /** String for negative infinity representation. */\n+    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n+\n+    /** Name for traps triggered by addition. */\n+    private static final String ADD_TRAP = \"add\";\n+\n+    /** Name for traps triggered by multiplication. */\n+    private static final String MULTIPLY_TRAP = \"multiply\";\n+\n+    /** Name for traps triggered by division. */\n+    private static final String DIVIDE_TRAP = \"divide\";\n+\n+    /** Name for traps triggered by square root. */\n+    private static final String SQRT_TRAP = \"sqrt\";\n+\n+    /** Name for traps triggered by alignment. */\n+    private static final String ALIGN_TRAP = \"align\";\n+\n+    /** Name for traps triggered by truncation. */\n+    private static final String TRUNC_TRAP = \"trunc\";\n+\n+    /** Name for traps triggered by nextAfter. */\n+    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n+\n+    /** Name for traps triggered by lessThan. */\n+    private static final String LESS_THAN_TRAP = \"lessThan\";\n+\n+    /** Name for traps triggered by greaterThan. */\n+    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n+\n+    /** Name for traps triggered by newInstance. */\n+    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n+\n+    /** Mantissa. */\n+    protected int[] mant;\n+\n+    /** Sign bit: & for positive, -1 for negative. */\n+    protected byte sign;\n+\n+    /** Exponent. */\n+    protected int exp;\n+\n+    /** Indicator for non-finite / non-number values. */\n+    protected byte nans;\n+\n+    /** Factory building similar Dfp's. */\n+    private final DfpField field;\n+\n+    /** Makes an instance with a value of zero.\n+     * @param field field to which this instance belongs\n+     */\n+    protected Dfp(final DfpField field) {\n+        mant = new int[field.getRadixDigits()];\n+        sign = 1;\n+        exp = 0;\n+        nans = FINITE;\n+        this.field = field;\n+    }\n+\n+    /** Create an instance from a byte value.\n+     * @param field field to which this instance belongs\n+     * @param x value to convert to an instance\n+     */\n+    protected Dfp(final DfpField field, byte x) {\n+        this(field, (long) x);\n+    }\n+\n+    /** Create an instance from an int value.\n+     * @param field field to which this instance belongs\n+     * @param x value to convert to an instance\n+     */\n+    protected Dfp(final DfpField field, int x) {\n+        this(field, (long) x);\n+    }\n+\n+    /** Create an instance from a long value.\n+     * @param field field to which this instance belongs\n+     * @param x value to convert to an instance\n+     */\n+    protected Dfp(final DfpField field, long x) {\n+\n+        // initialize as if 0\n+        mant = new int[field.getRadixDigits()];\n+        nans = FINITE;\n+        this.field = field;\n+\n+        boolean isLongMin = false;\n+        if (x == Long.MIN_VALUE) {\n+            // special case for Long.MIN_VALUE (-9223372036854775808)\n+            // we must shift it before taking its absolute value\n+            isLongMin = true;\n+            ++x;\n+        }\n+\n+        // set the sign\n+        if (x < 0) {\n+            sign = -1;\n+            x = -x;\n+        } else {\n+            sign = 1;\n+        }\n+\n+        exp = 0;\n+        while (x != 0) {\n+            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n+            mant[mant.length - 1] = (int) (x % RADIX);\n+            x /= RADIX;\n+            exp++;\n+        }\n+\n+        if (isLongMin) {\n+            // remove the shift added for Long.MIN_VALUE\n+            // we know in this case that fixing the last digit is sufficient\n+            for (int i = 0; i < mant.length - 1; i++) {\n+                if (mant[i] != 0) {\n+                    mant[i]++;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /** Create an instance from a double value.\n+     * @param field field to which this instance belongs\n+     * @param x value to convert to an instance\n+     */\n+    protected Dfp(final DfpField field, double x) {\n+\n+        // initialize as if 0\n+        mant = new int[field.getRadixDigits()];\n+        sign = 1;\n+        exp = 0;\n+        nans = FINITE;\n+        this.field = field;\n+\n+        long bits = Double.doubleToLongBits(x);\n+        long mantissa = bits & 0x000fffffffffffffL;\n+        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n+\n+        if (exponent == -1023) {\n+            // Zero or sub-normal\n+            if (x == 0) {\n+                return;\n+            }\n+\n+            exponent++;\n+\n+            // Normalize the subnormal number\n+            while ( (mantissa & 0x0010000000000000L) == 0) {\n+                exponent--;\n+                mantissa <<= 1;\n+            }\n+            mantissa &= 0x000fffffffffffffL;\n+        }\n+\n+        if (exponent == 1024) {\n+            // infinity or NAN\n+            if (x != x) {\n+                sign = (byte) 1;\n+                nans = QNAN;\n+            } else if (x < 0) {\n+                sign = (byte) -1;\n+                nans = INFINITE;\n+            } else {\n+                sign = (byte) 1;\n+                nans = INFINITE;\n+            }\n+            return;\n+        }\n+\n+        Dfp xdfp = new Dfp(field, mantissa);\n+        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n+        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n+\n+        if ((bits & 0x8000000000000000L) != 0) {\n+            xdfp = xdfp.negate();\n+        }\n+\n+        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n+        sign = xdfp.sign;\n+        exp  = xdfp.exp;\n+        nans = xdfp.nans;\n+\n+    }\n+\n+    /** Copy constructor.\n+     * @param d instance to copy\n+     */\n+    public Dfp(final Dfp d) {\n+        mant  = d.mant.clone();\n+        sign  = d.sign;\n+        exp   = d.exp;\n+        nans  = d.nans;\n+        field = d.field;\n+    }\n+\n+    /** Create an instance from a String representation.\n+     * @param field field to which this instance belongs\n+     * @param s string representation of the instance\n+     */\n+    protected Dfp(final DfpField field, final String s) {\n+\n+        // initialize as if 0\n+        mant = new int[field.getRadixDigits()];\n+        sign = 1;\n+        exp = 0;\n+        nans = FINITE;\n+        this.field = field;\n+\n+        boolean decimalFound = false;\n+        final int rsize = 4;   // size of radix in decimal digits\n+        final int offset = 4;  // Starting offset into Striped\n+        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n+\n+        // Check some special cases\n+        if (s.equals(POS_INFINITY_STRING)) {\n+            sign = (byte) 1;\n+            nans = (byte) INFINITE;\n+            return;\n+        }\n+\n+        if (s.equals(NEG_INFINITY_STRING)) {\n+            sign = (byte) -1;\n+            nans = (byte) INFINITE;\n+            return;\n+        }\n+\n+        if (s.equals(NAN_STRING)) {\n+            sign = (byte) 1;\n+            nans = (byte) QNAN;\n+            return;\n+        }\n+\n+        // Check for scientific notation\n+        int p = s.indexOf(\"e\");\n+        if (p == -1) { // try upper case?\n+            p = s.indexOf(\"E\");\n+        }\n+\n+        final String fpdecimal;\n+        int sciexp = 0;\n+        if (p != -1) {\n+            // scientific notation\n+            fpdecimal = s.substring(0, p);\n+            String fpexp = s.substring(p+1);\n+            boolean negative = false;\n+\n+            for (int i=0; i<fpexp.length(); i++)\n+            {\n+                if (fpexp.charAt(i) == '-')\n+                {\n+                    negative = true;\n+                    continue;\n+                }\n+                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n+                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n+            }\n+\n+            if (negative) {\n+                sciexp = -sciexp;\n+            }\n+        } else {\n+            // normal case\n+            fpdecimal = s;\n+        }\n+\n+        // If there is a minus sign in the number then it is negative\n+        if (fpdecimal.indexOf(\"-\") !=  -1) {\n+            sign = -1;\n+        }\n+\n+        // First off, find all of the leading zeros, trailing zeros, and significant digits\n+        p = 0;\n+\n+        // Move p to first significant digit\n+        int decimalPos = 0;\n+        for (;;) {\n+            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n+                break;\n+            }\n+\n+            if (decimalFound && fpdecimal.charAt(p) == '0') {\n+                decimalPos--;\n+            }\n+\n+            if (fpdecimal.charAt(p) == '.') {\n+                decimalFound = true;\n+            }\n+\n+            p++;\n+\n+            if (p == fpdecimal.length()) {\n+                break;\n+            }\n+        }\n+\n+        // Copy the string onto Stripped\n+        int q = offset;\n+        striped[0] = '0';\n+        striped[1] = '0';\n+        striped[2] = '0';\n+        striped[3] = '0';\n+        int significantDigits=0;\n+        for(;;) {\n+            if (p == (fpdecimal.length())) {\n+                break;\n+            }\n+\n+            // Don't want to run pass the end of the array\n+            if (q == mant.length*rsize+offset+1) {\n+                break;\n+            }\n+\n+            if (fpdecimal.charAt(p) == '.') {\n+                decimalFound = true;\n+                decimalPos = significantDigits;\n+                p++;\n+                continue;\n+            }\n+\n+            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n+                p++;\n+                continue;\n+            }\n+\n+            striped[q] = fpdecimal.charAt(p);\n+            q++;\n+            p++;\n+            significantDigits++;\n+        }\n+\n+\n+        // If the decimal point has been found then get rid of trailing zeros.\n+        if (decimalFound && q != offset) {\n+            for (;;) {\n+                q--;\n+                if (q == offset) {\n+                    break;\n+                }\n+                if (striped[q] == '0') {\n+                    significantDigits--;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // special case of numbers like \"0.00000\"\n+        if (decimalFound && significantDigits == 0) {\n+            decimalPos = 0;\n+        }\n+\n+        // Implicit decimal point at end of number if not present\n+        if (!decimalFound) {\n+            decimalPos = q-offset;\n+        }\n+\n+        // Find the number of significant trailing zeros\n+        q = offset;  // set q to point to first sig digit\n+        p = significantDigits-1+offset;\n+\n+        int trailingZeros = 0;\n+        while (p > q) {\n+            if (striped[p] != '0') {\n+                break;\n+            }\n+            trailingZeros++;\n+            p--;\n+        }\n+\n+        // Make sure the decimal is on a mod 10000 boundary\n+        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n+        q -= i;\n+        decimalPos += i;\n+\n+        // Make the mantissa length right by adding zeros at the end if necessary\n+        while ((p - q) < (mant.length * rsize)) {\n+            for (i = 0; i < rsize; i++) {\n+                striped[++p] = '0';\n+            }\n+        }\n+\n+        // Ok, now we know how many trailing zeros there are,\n+        // and where the least significant digit is\n+        for (i = mant.length - 1; i >= 0; i--) {\n+            mant[i] = (striped[q]   - '0') * 1000 +\n+                      (striped[q+1] - '0') * 100  +\n+                      (striped[q+2] - '0') * 10   +\n+                      (striped[q+3] - '0');\n+            q += 4;\n+        }\n+\n+\n+        exp = (decimalPos+sciexp) / rsize;\n+\n+        if (q < striped.length) {\n+            // Is there possible another digit?\n+            round((striped[q] - '0')*1000);\n+        }\n+\n+    }\n+\n+    /** Creates an instance with a non-finite value.\n+     * @param field field to which this instance belongs\n+     * @param sign sign of the Dfp to create\n+     * @param nans code of the value, must be one of {@link #INFINITE},\n+     * {@link #SNAN},  {@link #QNAN}\n+     */\n+    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n+        this.field = field;\n+        this.mant    = new int[field.getRadixDigits()];\n+        this.sign    = sign;\n+        this.exp     = 0;\n+        this.nans    = nans;\n+    }\n+\n+    /** Create an instance with a value of 0.\n+     * Use this internally in preference to constructors to facilitate subclasses\n+     * @return a new instance with a value of 0\n+     */\n+    public Dfp newInstance() {\n+        return new Dfp(getField());\n+    }\n+\n+    /** Create an instance from a byte value.\n+     * @param x value to convert to an instance\n+     * @return a new instance with value x\n+     */\n+    public Dfp newInstance(final byte x) {\n+        return new Dfp(getField(), x);\n+    }\n+\n+    /** Create an instance from an int value.\n+     * @param x value to convert to an instance\n+     * @return a new instance with value x\n+     */\n+    public Dfp newInstance(final int x) {\n+        return new Dfp(getField(), x);\n+    }\n+\n+    /** Create an instance from a long value.\n+     * @param x value to convert to an instance\n+     * @return a new instance with value x\n+     */\n+    public Dfp newInstance(final long x) {\n+        return new Dfp(getField(), x);\n+    }\n+\n+    /** Create an instance from a double value.\n+     * @param x value to convert to an instance\n+     * @return a new instance with value x\n+     */\n+    public Dfp newInstance(final double x) {\n+        return new Dfp(getField(), x);\n+    }\n+\n+    /** Create an instance by copying an existing one.\n+     * Use this internally in preference to constructors to facilitate subclasses.\n+     * @param d instance to copy\n+     * @return a new instance with the same value as d\n+     */\n+    public Dfp newInstance(final Dfp d) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n+        }\n+\n+        return new Dfp(d);\n+\n+    }\n+\n+    /** Create an instance from a String representation.\n+     * Use this internally in preference to constructors to facilitate subclasses.\n+     * @param s string representation of the instance\n+     * @return a new instance parsed from specified string\n+     */\n+    public Dfp newInstance(final String s) {\n+        return new Dfp(field, s);\n+    }\n+\n+    /** Creates an instance with a non-finite value.\n+     * @param sig sign of the Dfp to create\n+     * @param code code of the value, must be one of {@link #INFINITE},\n+     * {@link #SNAN},  {@link #QNAN}\n+     * @return a new instance with a non-finite value\n+     */\n+    public Dfp newInstance(final byte sig, final byte code) {\n+        return field.newDfp(sig, code);\n+    }\n+\n+    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n+     * <p>\n+     * The field is linked to the number of digits and acts as a factory\n+     * for {@link Dfp} instances.\n+     * </p>\n+     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n+     */\n+    public DfpField getField() {\n+        return field;\n+    }\n+\n+    /** Get the number of radix digits of the instance.\n+     * @return number of radix digits\n+     */\n+    public int getRadixDigits() {\n+        return field.getRadixDigits();\n+    }\n+\n+    /** Get the constant 0.\n+     * @return a Dfp with value zero\n+     */\n+    public Dfp getZero() {\n+        return field.getZero();\n+    }\n+\n+    /** Get the constant 1.\n+     * @return a Dfp with value one\n+     */\n+    public Dfp getOne() {\n+        return field.getOne();\n+    }\n+\n+    /** Get the constant 2.\n+     * @return a Dfp with value two\n+     */\n+    public Dfp getTwo() {\n+        return field.getTwo();\n+    }\n+\n+    /** Shift the mantissa left, and adjust the exponent to compensate.\n+     */\n+    protected void shiftLeft() {\n+        for (int i = mant.length - 1; i > 0; i--) {\n+            mant[i] = mant[i-1];\n+        }\n+        mant[0] = 0;\n+        exp--;\n+    }\n+\n+    /* Note that shiftRight() does not call round() as that round() itself\n+     uses shiftRight() */\n+    /** Shift the mantissa right, and adjust the exponent to compensate.\n+     */\n+    protected void shiftRight() {\n+        for (int i = 0; i < mant.length - 1; i++) {\n+            mant[i] = mant[i+1];\n+        }\n+        mant[mant.length - 1] = 0;\n+        exp++;\n+    }\n+\n+    /** Make our exp equal to the supplied one, this may cause rounding.\n+     *  Also causes de-normalized numbers.  These numbers are generally\n+     *  dangerous because most routines assume normalized numbers.\n+     *  Align doesn't round, so it will return the last digit destroyed\n+     *  by shifting right.\n+     *  @param e desired exponent\n+     *  @return last digit destroyed by shifting right\n+     */\n+    protected int align(int e) {\n+        int lostdigit = 0;\n+        boolean inexact = false;\n+\n+        int diff = exp - e;\n+\n+        int adiff = diff;\n+        if (adiff < 0) {\n+            adiff = -adiff;\n+        }\n+\n+        if (diff == 0) {\n+            return 0;\n+        }\n+\n+        if (adiff > (mant.length + 1)) {\n+            // Special case\n+            Arrays.fill(mant, 0);\n+            exp = e;\n+\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n+\n+            return 0;\n+        }\n+\n+        for (int i = 0; i < adiff; i++) {\n+            if (diff < 0) {\n+                /* Keep track of loss -- only signal inexact after losing 2 digits.\n+                 * the first lost digit is returned to add() and may be incorporated\n+                 * into the result.\n+                 */\n+                if (lostdigit != 0) {\n+                    inexact = true;\n+                }\n+\n+                lostdigit = mant[0];\n+\n+                shiftRight();\n+            } else {\n+                shiftLeft();\n+            }\n+        }\n+\n+        if (inexact) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n+        }\n+\n+        return lostdigit;\n+\n+    }\n+\n+    /** Check if instance is less than x.\n+     * @param x number to check instance against\n+     * @return true if instance is less than x and neither are NaN, false otherwise\n+     */\n+    public boolean lessThan(final Dfp x) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n+            return false;\n+        }\n+\n+        /* if a nan is involved, signal invalid and return false */\n+        if (isNaN() || x.isNaN()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n+            return false;\n+        }\n+\n+        return compare(this, x) < 0;\n+    }\n+\n+    /** Check if instance is greater than x.\n+     * @param x number to check instance against\n+     * @return true if instance is greater than x and neither are NaN, false otherwise\n+     */\n+    public boolean greaterThan(final Dfp x) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n+            return false;\n+        }\n+\n+        /* if a nan is involved, signal invalid and return false */\n+        if (isNaN() || x.isNaN()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n+            return false;\n+        }\n+\n+        return compare(this, x) > 0;\n+    }\n+\n+    /** Check if instance is infinite.\n+     * @return true if instance is infinite\n+     */\n+    public boolean isInfinite() {\n+        return nans == INFINITE;\n+    }\n+\n+    /** Check if instance is not a number.\n+     * @return true if instance is not a number\n+     */\n+    public boolean isNaN() {\n+        return (nans == QNAN) || (nans == SNAN);\n+    }\n+\n+    /** Check if instance is equal to x.\n+     * @param other object to check instance against\n+     * @return true if instance is equal to x and neither are NaN, false otherwise\n+     */\n+    @Override\n+    public boolean equals(final Object other) {\n+\n+        if (other instanceof Dfp) {\n+            final Dfp x = (Dfp) other;\n+            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n+                return false;\n+            }\n+\n+            return compare(this, x) == 0;\n+        }\n+\n+        return false;\n+\n+    }\n+\n+    /**\n+     * Gets a hashCode for the instance.\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 17 + (sign << 8) + (nans << 16) + exp + mant.hashCode();\n+    }\n+\n+    /** Check if instance is not equal to x.\n+     * @param x number to check instance against\n+     * @return true if instance is not equal to x and neither are NaN, false otherwise\n+     */\n+    public boolean unequal(final Dfp x) {\n+        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n+            return false;\n+        }\n+\n+        return greaterThan(x) || lessThan(x);\n+    }\n+\n+    /** Compare two instances.\n+     * @param a first instance in comparison\n+     * @param b second instance in comparison\n+     * @return -1 if a<b, 1 if a>b and 0 if a==b\n+     *  Note this method does not properly handle NaNs or numbers with different precision.\n+     */\n+    private static int compare(final Dfp a, final Dfp b) {\n+        // Ignore the sign of zero\n+        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n+            a.nans == FINITE && b.nans == FINITE) {\n+            return 0;\n+        }\n+\n+        if (a.sign != b.sign) {\n+            if (a.sign == -1) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        }\n+\n+        // deal with the infinities\n+        if (a.nans == INFINITE && b.nans == FINITE) {\n+            return a.sign;\n+        }\n+\n+        if (a.nans == FINITE && b.nans == INFINITE) {\n+            return -b.sign;\n+        }\n+\n+        if (a.nans == INFINITE && b.nans == INFINITE) {\n+            return 0;\n+        }\n+\n+        // Handle special case when a or b is zero, by ignoring the exponents\n+        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n+            if (a.exp < b.exp) {\n+                return -a.sign;\n+            }\n+\n+            if (a.exp > b.exp) {\n+                return a.sign;\n+            }\n+        }\n+\n+        // compare the mantissas\n+        for (int i = a.mant.length - 1; i >= 0; i--) {\n+            if (a.mant[i] > b.mant[i]) {\n+                return a.sign;\n+            }\n+\n+            if (a.mant[i] < b.mant[i]) {\n+                return -a.sign;\n+            }\n+        }\n+\n+        return 0;\n+\n+    }\n+\n+    /** Round to nearest integer using the round-half-even method.\n+     *  That is round to nearest integer unless both are equidistant.\n+     *  In which case round to the even one.\n+     *  @return rounded value\n+     */\n+    public Dfp rint() {\n+        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n+    }\n+\n+    /** Round to an integer using the round floor mode.\n+     * That is, round toward -Infinity\n+     *  @return rounded value\n+     */\n+    public Dfp floor() {\n+        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n+    }\n+\n+    /** Round to an integer using the round ceil mode.\n+     * That is, round toward +Infinity\n+     *  @return rounded value\n+     */\n+    public Dfp ceil() {\n+        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n+    }\n+\n+    /** Returns the IEEE remainder.\n+     * @param d divisor\n+     * @return this less n &times; d, where n is the integer closest to this/d\n+     */\n+    public Dfp remainder(final Dfp d) {\n+\n+        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n+\n+        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n+        if (result.mant[mant.length-1] == 0) {\n+            result.sign = sign;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /** Does the integer conversions with the specified rounding.\n+     * @param rmode rounding mode to use\n+     * @return truncated value\n+     */\n+    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n+        boolean changed = false;\n+\n+        if (isNaN()) {\n+            return newInstance(this);\n+        }\n+\n+        if (nans == INFINITE) {\n+            return newInstance(this);\n+        }\n+\n+        if (mant[mant.length-1] == 0) {\n+            // a is zero\n+            return newInstance(this);\n+        }\n+\n+        /* If the exponent is less than zero then we can certainly\n+         * return zero */\n+        if (exp < 0) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            Dfp result = newInstance(getZero());\n+            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n+            return result;\n+        }\n+\n+        /* If the exponent is greater than or equal to digits, then it\n+         * must already be an integer since there is no precision left\n+         * for any fractional part */\n+\n+        if (exp >= mant.length) {\n+            return newInstance(this);\n+        }\n+\n+        /* General case:  create another dfp, result, that contains the\n+         * a with the fractional part lopped off.  */\n+\n+        Dfp result = newInstance(this);\n+        for (int i = 0; i < mant.length-result.exp; i++) {\n+            changed |= result.mant[i] != 0;\n+            result.mant[i] = 0;\n+        }\n+\n+        if (changed) {\n+            switch (rmode) {\n+                case ROUND_FLOOR:\n+                    if (result.sign == -1) {\n+                        // then we must increment the mantissa by one\n+                        result = result.add(newInstance(-1));\n+                    }\n+                    break;\n+\n+                case ROUND_CEIL:\n+                    if (result.sign == 1) {\n+                        // then we must increment the mantissa by one\n+                        result = result.add(getOne());\n+                    }\n+                    break;\n+\n+                case ROUND_HALF_EVEN:\n+                default:\n+                    final Dfp half = newInstance(\"0.5\");\n+                    Dfp a = subtract(result);  // difference between this and result\n+                    a.sign = 1;            // force positive (take abs)\n+                    if (a.greaterThan(half)) {\n+                        a = newInstance(getOne());\n+                        a.sign = sign;\n+                        result = result.add(a);\n+                    }\n+\n+                    /** If exactly equal to 1/2 and odd then increment */\n+                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n+                        a = newInstance(getOne());\n+                        a.sign = sign;\n+                        result = result.add(a);\n+                    }\n+                    break;\n+            }\n+\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n+            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n+            return result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Convert this to an integer.\n+     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n+     * @return converted number\n+     */\n+    public int intValue() {\n+        Dfp rounded;\n+        int result = 0;\n+\n+        rounded = rint();\n+\n+        if (rounded.greaterThan(newInstance(2147483647))) {\n+            return 2147483647;\n+        }\n+\n+        if (rounded.lessThan(newInstance(-2147483648))) {\n+            return -2147483648;\n+        }\n+\n+        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n+            result = result * RADIX + rounded.mant[i];\n+        }\n+\n+        if (rounded.sign == -1) {\n+            result = -result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Get the exponent of the greatest power of 10000 that is\n+     *  less than or equal to the absolute value of this.  I.E.  if\n+     *  this is 10<sup>6</sup> then log10K would return 1.\n+     *  @return integer base 10000 logarithm\n+     */\n+    public int log10K() {\n+        return exp - 1;\n+    }\n+\n+    /** Get the specified  power of 10000.\n+     * @param e desired power\n+     * @return 10000<sup>e</sup>\n+     */\n+    public Dfp power10K(final int e) {\n+        Dfp d = newInstance(getOne());\n+        d.exp = e + 1;\n+        return d;\n+    }\n+\n+    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n+     *  @return integer base 10 logarithm\n+     */\n+    public int log10()  {\n+        if (mant[mant.length-1] > 1000) {\n+            return exp * 4 - 1;\n+        }\n+        if (mant[mant.length-1] > 100) {\n+            return exp * 4 - 2;\n+        }\n+        if (mant[mant.length-1] > 10) {\n+            return exp * 4 - 3;\n+        }\n+        return exp * 4 - 4;\n+    }\n+\n+    /** Return the specified  power of 10.\n+     * @param e desired power\n+     * @return 10<sup>e</sup>\n+     */\n+    public Dfp power10(final int e) {\n+        Dfp d = newInstance(getOne());\n+\n+        if (e >= 0) {\n+            d.exp = e / 4 + 1;\n+        } else {\n+            d.exp = (e + 1) / 4;\n+        }\n+\n+        switch ((e % 4 + 4) % 4) {\n+            case 0:\n+                break;\n+            case 1:\n+                d = d.multiply(10);\n+                break;\n+            case 2:\n+                d = d.multiply(100);\n+                break;\n+            default:\n+                d = d.multiply(1000);\n+        }\n+\n+        return d;\n+    }\n+\n+    /** Negate the mantissa of this by computing the complement.\n+     *  Leaves the sign bit unchanged, used internally by add.\n+     *  Denormalized numbers are handled properly here.\n+     *  @param extra ???\n+     *  @return ???\n+     */\n+    protected int complement(int extra) {\n+\n+        extra = RADIX-extra;\n+        for (int i = 0; i < mant.length; i++) {\n+            mant[i] = RADIX-mant[i]-1;\n+        }\n+\n+        int rh = extra / RADIX;\n+        extra = extra - rh * RADIX;\n+        for (int i = 0; i < mant.length; i++) {\n+            final int r = mant[i] + rh;\n+            rh = r / RADIX;\n+            mant[i] = r - rh * RADIX;\n+        }\n+\n+        return extra;\n+    }\n+\n+    /** Add x to this.\n+     * @param x number to add\n+     * @return sum of this and x\n+     */\n+    public Dfp add(final Dfp x) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n+        }\n+\n+        /* handle special cases */\n+        if (nans != FINITE || x.nans != FINITE) {\n+            if (isNaN()) {\n+                return this;\n+            }\n+\n+            if (x.isNaN()) {\n+                return x;\n+            }\n+\n+            if (nans == INFINITE && x.nans == FINITE) {\n+                return this;\n+            }\n+\n+            if (x.nans == INFINITE && nans == FINITE) {\n+                return x;\n+            }\n+\n+            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n+                return x;\n+            }\n+\n+            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n+                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                Dfp result = newInstance(getZero());\n+                result.nans = QNAN;\n+                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n+                return result;\n+            }\n+        }\n+\n+        /* copy this and the arg */\n+        Dfp a = newInstance(this);\n+        Dfp b = newInstance(x);\n+\n+        /* initialize the result object */\n+        Dfp result = newInstance(getZero());\n+\n+        /* Make all numbers positive, but remember their sign */\n+        final byte asign = a.sign;\n+        final byte bsign = b.sign;\n+\n+        a.sign = 1;\n+        b.sign = 1;\n+\n+        /* The result will be signed like the arg with greatest magnitude */\n+        byte rsign = bsign;\n+        if (compare(a, b) > 0) {\n+            rsign = asign;\n+        }\n+\n+        /* Handle special case when a or b is zero, by setting the exponent\n+       of the zero number equal to the other one.  This avoids an alignment\n+       which would cause catastropic loss of precision */\n+        if (b.mant[mant.length-1] == 0) {\n+            b.exp = a.exp;\n+        }\n+\n+        if (a.mant[mant.length-1] == 0) {\n+            a.exp = b.exp;\n+        }\n+\n+        /* align number with the smaller exponent */\n+        int aextradigit = 0;\n+        int bextradigit = 0;\n+        if (a.exp < b.exp) {\n+            aextradigit = a.align(b.exp);\n+        } else {\n+            bextradigit = b.align(a.exp);\n+        }\n+\n+        /* complement the smaller of the two if the signs are different */\n+        if (asign != bsign) {\n+            if (asign == rsign) {\n+                bextradigit = b.complement(bextradigit);\n+            } else {\n+                aextradigit = a.complement(aextradigit);\n+            }\n+        }\n+\n+        /* add the mantissas */\n+        int rh = 0; /* acts as a carry */\n+        for (int i = 0; i < mant.length; i++) {\n+            final int r = a.mant[i]+b.mant[i]+rh;\n+            rh = r / RADIX;\n+            result.mant[i] = r - rh * RADIX;\n+        }\n+        result.exp = a.exp;\n+        result.sign = rsign;\n+\n+        /* handle overflow -- note, when asign!=bsign an overflow is\n+         * normal and should be ignored.  */\n+\n+        if (rh != 0 && (asign == bsign)) {\n+            final int lostdigit = result.mant[0];\n+            result.shiftRight();\n+            result.mant[mant.length-1] = rh;\n+            final int excp = result.round(lostdigit);\n+            if (excp != 0) {\n+                result = dotrap(excp, ADD_TRAP, x, result);\n+            }\n+        }\n+\n+        /* normalize the result */\n+        for (int i = 0; i < mant.length; i++) {\n+            if (result.mant[mant.length-1] != 0) {\n+                break;\n+            }\n+            result.shiftLeft();\n+            if (i == 0) {\n+                result.mant[0] = aextradigit+bextradigit;\n+                aextradigit = 0;\n+                bextradigit = 0;\n+            }\n+        }\n+\n+        /* result is zero if after normalization the most sig. digit is zero */\n+        if (result.mant[mant.length-1] == 0) {\n+            result.exp = 0;\n+\n+            if (asign != bsign) {\n+                // Unless adding 2 negative zeros, sign is positive\n+                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n+            }\n+        }\n+\n+        /* Call round to test for over/under flows */\n+        final int excp = result.round(aextradigit + bextradigit);\n+        if (excp != 0) {\n+            result = dotrap(excp, ADD_TRAP, x, result);\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Returns a number that is this number with the sign bit reversed.\n+     * @return the opposite of this\n+     */\n+    public Dfp negate() {\n+        Dfp result = newInstance(this);\n+        result.sign = (byte) - result.sign;\n+        return result;\n+    }\n+\n+    /** Subtract x from this.\n+     * @param x number to subtract\n+     * @return difference of this and a\n+     */\n+    public Dfp subtract(final Dfp x) {\n+        return add(x.negate());\n+    }\n+\n+    /** Round this given the next digit n using the current rounding mode.\n+     * @param n ???\n+     * @return the IEEE flag if an exception occurred\n+     */\n+    protected int round(int n) {\n+        boolean inc = false;\n+        switch (field.getRoundingMode()) {\n+            case ROUND_DOWN:\n+                inc = false;\n+                break;\n+\n+            case ROUND_UP:\n+                inc = n != 0;       // round up if n!=0\n+                break;\n+\n+            case ROUND_HALF_UP:\n+                inc = n >= 5000;  // round half up\n+                break;\n+\n+            case ROUND_HALF_DOWN:\n+                inc = n > 5000;  // round half down\n+                break;\n+\n+            case ROUND_HALF_EVEN:\n+                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n+                break;\n+\n+            case ROUND_HALF_ODD:\n+                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n+                break;\n+\n+            case ROUND_CEIL:\n+                inc = sign == 1 && n != 0;  // round ceil\n+                break;\n+\n+            case ROUND_FLOOR:\n+            default:\n+                inc = sign == -1 && n != 0;  // round floor\n+                break;\n+        }\n+\n+        if (inc) {\n+            // increment if necessary\n+            int rh = 1;\n+            for (int i = 0; i < mant.length; i++) {\n+                final int r = mant[i] + rh;\n+                rh = r / RADIX;\n+                mant[i] = r - rh * RADIX;\n+            }\n+\n+            if (rh != 0) {\n+                shiftRight();\n+                mant[mant.length-1] = rh;\n+            }\n+        }\n+\n+        // check for exceptional cases and raise signals if necessary\n+        if (exp < MIN_EXP) {\n+            // Gradual Underflow\n+            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n+            return DfpField.FLAG_UNDERFLOW;\n+        }\n+\n+        if (exp > MAX_EXP) {\n+            // Overflow\n+            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n+            return DfpField.FLAG_OVERFLOW;\n+        }\n+\n+        if (n != 0) {\n+            // Inexact\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            return DfpField.FLAG_INEXACT;\n+        }\n+\n+        return 0;\n+\n+    }\n+\n+    /** Multiply this by x.\n+     * @param x multiplicand\n+     * @return product of this and x\n+     */\n+    public Dfp multiply(final Dfp x) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n+        }\n+\n+        Dfp result = newInstance(getZero());\n+\n+        /* handle special cases */\n+        if (nans != FINITE || x.nans != FINITE) {\n+            if (isNaN()) {\n+                return this;\n+            }\n+\n+            if (x.isNaN()) {\n+                return x;\n+            }\n+\n+            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n+                result = newInstance(this);\n+                result.sign = (byte) (sign * x.sign);\n+                return result;\n+            }\n+\n+            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n+                result = newInstance(x);\n+                result.sign = (byte) (sign * x.sign);\n+                return result;\n+            }\n+\n+            if (x.nans == INFINITE && nans == INFINITE) {\n+                result = newInstance(this);\n+                result.sign = (byte) (sign * x.sign);\n+                return result;\n+            }\n+\n+            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n+                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n+                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                result = newInstance(getZero());\n+                result.nans = QNAN;\n+                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n+                return result;\n+            }\n+        }\n+\n+        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n+\n+        for (int i = 0; i < mant.length; i++) {\n+            int rh = 0;  // acts as a carry\n+            for (int j=0; j<mant.length; j++) {\n+                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n+                r = r + product[i+j] + rh;  // add to the product digit with carry in\n+\n+                rh = r / RADIX;\n+                product[i+j] = r - rh * RADIX;\n+            }\n+            product[i+mant.length] = rh;\n+        }\n+\n+        // Find the most sig digit\n+        int md = mant.length * 2 - 1;  // default, in case result is zero\n+        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n+            if (product[i] != 0) {\n+                md = i;\n+                break;\n+            }\n+        }\n+\n+        // Copy the digits into the result\n+        for (int i = 0; i < mant.length; i++) {\n+            result.mant[mant.length - i - 1] = product[md - i];\n+        }\n+\n+        // Fixup the exponent.\n+        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n+        result.sign = (byte)((sign == x.sign)?1:-1);\n+\n+        if (result.mant[mant.length-1] == 0) {\n+            // if result is zero, set exp to zero\n+            result.exp = 0;\n+        }\n+\n+        final int excp;\n+        if (md > (mant.length-1)) {\n+            excp = result.round(product[md-mant.length]);\n+        } else {\n+            excp = result.round(0); // has no effect except to check status\n+        }\n+\n+        if (excp != 0) {\n+            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n+     * There are speed advantages in this special case\n+     * @param x multiplicand\n+     * @return product of this and x\n+     */\n+    public Dfp multiply(final int x) {\n+        Dfp result = newInstance(this);\n+\n+        /* handle special cases */\n+        if (nans != FINITE) {\n+            if (isNaN()) {\n+                return this;\n+            }\n+\n+            if (nans == INFINITE && x != 0) {\n+                result = newInstance(this);\n+                return result;\n+            }\n+\n+            if (nans == INFINITE && x == 0) {\n+                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                result = newInstance(getZero());\n+                result.nans = QNAN;\n+                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n+                return result;\n+            }\n+        }\n+\n+        /* range check x */\n+        if (x < 0 || x >= RADIX) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            result = newInstance(getZero());\n+            result.nans = QNAN;\n+            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n+            return result;\n+        }\n+\n+        int rh = 0;\n+        for (int i = 0; i < mant.length; i++) {\n+            final int r = mant[i] * x + rh;\n+            rh = r / RADIX;\n+            result.mant[i] = r - rh * RADIX;\n+        }\n+\n+        int lostdigit = 0;\n+        if (rh != 0) {\n+            lostdigit = result.mant[0];\n+            result.shiftRight();\n+            result.mant[mant.length-1] = rh;\n+        }\n+\n+        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n+            result.exp = 0;\n+        }\n+\n+        final int excp = result.round(lostdigit);\n+        if (excp != 0) {\n+            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Divide this by divisor.\n+     * @param divisor divisor\n+     * @return quotient of this by divisor\n+     */\n+    public Dfp divide(Dfp divisor) {\n+        int dividend[]; // current status of the dividend\n+        int quotient[]; // quotient\n+        int remainder[];// remainder\n+        int qd;         // current quotient digit we're working with\n+        int nsqd;       // number of significant quotient digits we have\n+        int trial=0;    // trial quotient digit\n+        int minadj;     // minimum adjustment\n+        boolean trialgood; // Flag to indicate a good trail digit\n+        int md=0;       // most sig digit in result\n+        int excp;       // exceptions\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n+        }\n+\n+        Dfp result = newInstance(getZero());\n+\n+        /* handle special cases */\n+        if (nans != FINITE || divisor.nans != FINITE) {\n+            if (isNaN()) {\n+                return this;\n+            }\n+\n+            if (divisor.isNaN()) {\n+                return divisor;\n+            }\n+\n+            if (nans == INFINITE && divisor.nans == FINITE) {\n+                result = newInstance(this);\n+                result.sign = (byte) (sign * divisor.sign);\n+                return result;\n+            }\n+\n+            if (divisor.nans == INFINITE && nans == FINITE) {\n+                result = newInstance(getZero());\n+                result.sign = (byte) (sign * divisor.sign);\n+                return result;\n+            }\n+\n+            if (divisor.nans == INFINITE && nans == INFINITE) {\n+                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                result = newInstance(getZero());\n+                result.nans = QNAN;\n+                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n+                return result;\n+            }\n+        }\n+\n+        /* Test for divide by zero */\n+        if (divisor.mant[mant.length-1] == 0) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n+            result = newInstance(getZero());\n+            result.sign = (byte) (sign * divisor.sign);\n+            result.nans = INFINITE;\n+            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n+            return result;\n+        }\n+\n+        dividend = new int[mant.length+1];  // one extra digit needed\n+        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n+        remainder = new int[mant.length+1]; // one extra digit needed\n+\n+        /* Initialize our most significant digits to zero */\n+\n+        dividend[mant.length] = 0;\n+        quotient[mant.length] = 0;\n+        quotient[mant.length+1] = 0;\n+        remainder[mant.length] = 0;\n+\n+        /* copy our mantissa into the dividend, initialize the\n+       quotient while we are at it */\n+\n+        for (int i = 0; i < mant.length; i++) {\n+            dividend[i] = mant[i];\n+            quotient[i] = 0;\n+            remainder[i] = 0;\n+        }\n+\n+        /* outer loop.  Once per quotient digit */\n+        nsqd = 0;\n+        for (qd = mant.length+1; qd >= 0; qd--) {\n+            /* Determine outer limits of our quotient digit */\n+\n+            // r =  most sig 2 digits of dividend\n+            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n+            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n+            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n+\n+            trialgood = false;\n+            while (!trialgood) {\n+                // try the mean\n+                trial = (min+max)/2;\n+\n+                /* Multiply by divisor and store as remainder */\n+                int rh = 0;\n+                for (int i = 0; i < mant.length + 1; i++) {\n+                    int dm = (i<mant.length)?divisor.mant[i]:0;\n+                    final int r = (dm * trial) + rh;\n+                    rh = r / RADIX;\n+                    remainder[i] = r - rh * RADIX;\n+                }\n+\n+                /* subtract the remainder from the dividend */\n+                rh = 1;  // carry in to aid the subtraction\n+                for (int i = 0; i < mant.length + 1; i++) {\n+                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n+                    rh = r / RADIX;\n+                    remainder[i] = r - rh * RADIX;\n+                }\n+\n+                /* Lets analyze what we have here */\n+                if (rh == 0) {\n+                    // trial is too big -- negative remainder\n+                    max = trial-1;\n+                    continue;\n+                }\n+\n+                /* find out how far off the remainder is telling us we are */\n+                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n+                minadj = minadj / (divisor.mant[mant.length-1]+1);\n+\n+                if (minadj >= 2) {\n+                    min = trial+minadj;  // update the minimum\n+                    continue;\n+                }\n+\n+                /* May have a good one here, check more thoroughly.  Basically\n+           its a good one if it is less than the divisor */\n+                trialgood = false;  // assume false\n+                for (int i = mant.length - 1; i >= 0; i--) {\n+                    if (divisor.mant[i] > remainder[i]) {\n+                        trialgood = true;\n+                    }\n+                    if (divisor.mant[i] < remainder[i]) {\n+                        break;\n+                    }\n+                }\n+\n+                if (remainder[mant.length] != 0) {\n+                    trialgood = false;\n+                }\n+\n+                if (trialgood == false) {\n+                    min = trial+1;\n+                }\n+            }\n+\n+            /* Great we have a digit! */\n+            quotient[qd] = trial;\n+            if (trial != 0 || nsqd != 0) {\n+                nsqd++;\n+            }\n+\n+            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n+                // We have enough for this mode\n+                break;\n+            }\n+\n+            if (nsqd > mant.length) {\n+                // We have enough digits\n+                break;\n+            }\n+\n+            /* move the remainder into the dividend while left shifting */\n+            dividend[0] = 0;\n+            for (int i = 0; i < mant.length; i++) {\n+                dividend[i + 1] = remainder[i];\n+            }\n+        }\n+\n+        /* Find the most sig digit */\n+        md = mant.length;  // default\n+        for (int i = mant.length + 1; i >= 0; i--) {\n+            if (quotient[i] != 0) {\n+                md = i;\n+                break;\n+            }\n+        }\n+\n+        /* Copy the digits into the result */\n+        for (int i=0; i<mant.length; i++) {\n+            result.mant[mant.length-i-1] = quotient[md-i];\n+        }\n+\n+        /* Fixup the exponent. */\n+        result.exp = exp - divisor.exp + md - mant.length;\n+        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n+\n+        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n+            result.exp = 0;\n+        }\n+\n+        if (md > (mant.length-1)) {\n+            excp = result.round(quotient[md-mant.length]);\n+        } else {\n+            excp = result.round(0);\n+        }\n+\n+        if (excp != 0) {\n+            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Divide by a single digit less than radix.\n+     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n+     * @param divisor divisor\n+     * @return quotient of this by divisor\n+     */\n+    public Dfp divide(int divisor) {\n+\n+        // Handle special cases\n+        if (nans != FINITE) {\n+            if (isNaN()) {\n+                return this;\n+            }\n+\n+            if (nans == INFINITE) {\n+                return newInstance(this);\n+            }\n+        }\n+\n+        // Test for divide by zero\n+        if (divisor == 0) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n+            Dfp result = newInstance(getZero());\n+            result.sign = sign;\n+            result.nans = INFINITE;\n+            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n+            return result;\n+        }\n+\n+        // range check divisor\n+        if (divisor < 0 || divisor >= RADIX) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n+            return result;\n+        }\n+\n+        Dfp result = newInstance(this);\n+\n+        int rl = 0;\n+        for (int i = mant.length-1; i >= 0; i--) {\n+            final int r = rl*RADIX + result.mant[i];\n+            final int rh = r / divisor;\n+            rl = r - rh * divisor;\n+            result.mant[i] = rh;\n+        }\n+\n+        if (result.mant[mant.length-1] == 0) {\n+            // normalize\n+            result.shiftLeft();\n+            final int r = rl * RADIX;        // compute the next digit and put it in\n+            final int rh = r / divisor;\n+            rl = r - rh * divisor;\n+            result.mant[0] = rh;\n+        }\n+\n+        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n+        if (excp != 0) {\n+            result = dotrap(excp, DIVIDE_TRAP, result, result);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /** Compute the square root.\n+     * @return square root of the instance\n+     */\n+    public Dfp sqrt() {\n+\n+        // check for unusual cases\n+        if (nans == FINITE && mant[mant.length-1] == 0) {\n+            // if zero\n+            return newInstance(this);\n+        }\n+\n+        if (nans != FINITE) {\n+            if (nans == INFINITE && sign == 1) {\n+                // if positive infinity\n+                return newInstance(this);\n+            }\n+\n+            if (nans == QNAN) {\n+                return newInstance(this);\n+            }\n+\n+            if (nans == SNAN) {\n+                Dfp result;\n+\n+                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                result = newInstance(this);\n+                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n+                return result;\n+            }\n+        }\n+\n+        if (sign == -1) {\n+            // if negative\n+            Dfp result;\n+\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            result = newInstance(this);\n+            result.nans = QNAN;\n+            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n+            return result;\n+        }\n+\n+        Dfp x = newInstance(this);\n+\n+        /* Lets make a reasonable guess as to the size of the square root */\n+        if (x.exp < -1 || x.exp > 1) {\n+            x.exp = this.exp / 2;\n+        }\n+\n+        /* Coarsely estimate the mantissa */\n+        switch (x.mant[mant.length-1] / 2000) {\n+            case 0:\n+                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n+                break;\n+            case 2:\n+                x.mant[mant.length-1] = 1500;\n+                break;\n+            case 3:\n+                x.mant[mant.length-1] = 2200;\n+                break;\n+            default:\n+                x.mant[mant.length-1] = 3000;\n+        }\n+\n+        Dfp dx = newInstance(x);\n+\n+        /* Now that we have the first pass estimate, compute the rest\n+       by the formula dx = (y - x*x) / (2x); */\n+\n+        Dfp px  = getZero();\n+        Dfp ppx = getZero();\n+        while (x.unequal(px)) {\n+            dx = newInstance(x);\n+            dx.sign = -1;\n+            dx = dx.add(this.divide(x));\n+            dx = dx.divide(2);\n+            ppx = px;\n+            px = x;\n+            x = x.add(dx);\n+\n+            if (x.equals(ppx)) {\n+                // alternating between two values\n+                break;\n+            }\n+\n+            // if dx is zero, break.  Note testing the most sig digit\n+            // is a sufficient test since dx is normalized\n+            if (dx.mant[mant.length-1] == 0) {\n+                break;\n+            }\n+        }\n+\n+        return x;\n+\n+    }\n+\n+    /** Get a string representation of the instance.\n+     * @return string representation of the instance\n+     */\n+    public String toString() {\n+        if (nans != FINITE) {\n+            // if non-finite exceptional cases\n+            if (nans == INFINITE) {\n+                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n+            } else {\n+                return NAN_STRING;\n+            }\n+        }\n+\n+        if (exp > mant.length || exp < -1) {\n+            return dfp2sci();\n+        }\n+\n+        return dfp2string();\n+\n+    }\n+\n+    /** Convert an instance to a string using scientific notation.\n+     * @param a instance to convert\n+     * @return string representation of the instance in scientific notation\n+     */\n+    protected String dfp2sci() {\n+        char rawdigits[]    = new char[mant.length * 4];\n+        char outputbuffer[] = new char[mant.length * 4 + 20];\n+        int p;\n+        int q;\n+        int e;\n+        int ae;\n+        int shf;\n+\n+        // Get all the digits\n+        p = 0;\n+        for (int i = mant.length - 1; i >= 0; i--) {\n+            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n+            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n+            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n+            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n+        }\n+\n+        // Find the first non-zero one\n+        for (p = 0; p < rawdigits.length; p++) {\n+            if (rawdigits[p] != '0') {\n+                break;\n+            }\n+        }\n+        shf = p;\n+\n+        // Now do the conversion\n+        q = 0;\n+        if (sign == -1) {\n+            outputbuffer[q++] = '-';\n+        }\n+\n+        if (p != rawdigits.length) {\n+            // there are non zero digits...\n+            outputbuffer[q++] = rawdigits[p++];\n+            outputbuffer[q++] = '.';\n+\n+            while (p<rawdigits.length) {\n+                outputbuffer[q++] = rawdigits[p++];\n+            }\n+        } else {\n+            outputbuffer[q++] = '0';\n+            outputbuffer[q++] = '.';\n+            outputbuffer[q++] = '0';\n+            outputbuffer[q++] = 'e';\n+            outputbuffer[q++] = '0';\n+            return new String(outputbuffer, 0, 5);\n+        }\n+\n+        outputbuffer[q++] = 'e';\n+\n+        // Find the msd of the exponent\n+\n+        e = exp * 4 - shf - 1;\n+        ae = e;\n+        if (e < 0) {\n+            ae = -e;\n+        }\n+\n+        // Find the largest p such that p < e\n+        for (p = 1000000000; p > ae; p /= 10) {\n+            // nothing to do\n+        }\n+\n+        if (e < 0) {\n+            outputbuffer[q++] = '-';\n+        }\n+\n+        while (p > 0) {\n+            outputbuffer[q++] = (char)(ae / p + '0');\n+            ae = ae % p;\n+            p = p / 10;\n+        }\n+\n+        return new String(outputbuffer, 0, q);\n+\n+    }\n+\n+    /** Convert an instance to a string using normal notation.\n+     * @param a instance to convert\n+     * @return string representation of the instance in normal notation\n+     */\n+    protected String dfp2string() {\n+        char buffer[] = new char[mant.length*4 + 20];\n+        int p = 1;\n+        int q;\n+        int e = exp;\n+        boolean pointInserted = false;\n+\n+        buffer[0] = ' ';\n+\n+        if (e <= 0) {\n+            buffer[p++] = '0';\n+            buffer[p++] = '.';\n+            pointInserted = true;\n+        }\n+\n+        while (e < 0) {\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            e++;\n+        }\n+\n+        for (int i = mant.length - 1; i >= 0; i--) {\n+            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n+            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n+            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n+            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n+            if (--e == 0) {\n+                buffer[p++] = '.';\n+                pointInserted = true;\n+            }\n+        }\n+\n+        while (e > 0) {\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            buffer[p++] = '0';\n+            e--;\n+        }\n+\n+        if (!pointInserted) {\n+            // Ensure we have a radix point!\n+            buffer[p++] = '.';\n+        }\n+\n+        // Suppress leading zeros\n+        q = 1;\n+        while (buffer[q] == '0') {\n+            q++;\n+        }\n+        if (buffer[q] == '.') {\n+            q--;\n+        }\n+\n+        // Suppress trailing zeros\n+        while (buffer[p-1] == '0') {\n+            p--;\n+        }\n+\n+        // Insert sign\n+        if (sign < 0) {\n+            buffer[--q] = '-';\n+        }\n+\n+        return new String(buffer, q, p - q);\n+\n+    }\n+\n+    /** Raises a trap.  This does not set the corresponding flag however.\n+     *  @param type the trap type\n+     *  @param what - name of routine trap occurred in\n+     *  @param oper - input operator to function\n+     *  @param result - the result computed prior to the trap\n+     *  @return The suggested return value from the trap handler\n+     */\n+    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n+        Dfp def = result;\n+\n+        switch (type) {\n+            case DfpField.FLAG_INVALID:\n+                def = newInstance(getZero());\n+                def.sign = result.sign;\n+                def.nans = QNAN;\n+                break;\n+\n+            case DfpField.FLAG_DIV_ZERO:\n+                if (nans == FINITE && mant[mant.length-1] != 0) {\n+                    // normal case, we are finite, non-zero\n+                    def = newInstance(getZero());\n+                    def.sign = (byte)(sign*oper.sign);\n+                    def.nans = INFINITE;\n+                }\n+\n+                if (nans == FINITE && mant[mant.length-1] == 0) {\n+                    //  0/0\n+                    def = newInstance(getZero());\n+                    def.nans = QNAN;\n+                }\n+\n+                if (nans == INFINITE || nans == QNAN) {\n+                    def = newInstance(getZero());\n+                    def.nans = QNAN;\n+                }\n+\n+                if (nans == INFINITE || nans == SNAN) {\n+                    def = newInstance(getZero());\n+                    def.nans = QNAN;\n+                }\n+                break;\n+\n+            case DfpField.FLAG_UNDERFLOW:\n+                if ( (result.exp+mant.length) < MIN_EXP) {\n+                    def = newInstance(getZero());\n+                    def.sign = result.sign;\n+                } else {\n+                    def = newInstance(result);  // gradual underflow\n+                }\n+                result.exp = result.exp + ERR_SCALE;\n+                break;\n+\n+            case DfpField.FLAG_OVERFLOW:\n+                result.exp = result.exp - ERR_SCALE;\n+                def = newInstance(getZero());\n+                def.sign = result.sign;\n+                def.nans = INFINITE;\n+                break;\n+\n+            default: def = result; break;\n+        }\n+\n+        return trap(type, what, oper, def, result);\n+\n+    }\n+\n+    /** Trap handler.  Subclasses may override this to provide trap\n+     *  functionality per IEEE 854-1987.\n+     *\n+     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n+     *  @param what  The name of the routine we were in e.g. divide()\n+     *  @param oper  An operand to this function if any\n+     *  @param def   The default return value if trap not enabled\n+     *  @param result    The result that is specified to be delivered per\n+     *                   IEEE 854, if any\n+     *  @return the value that should be return by the operation triggering the trap\n+     */\n+    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n+        return def;\n+    }\n+\n+    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n+     * @return type of the number\n+     */\n+    public int classify() {\n+        return nans;\n+    }\n+\n+    /** Creates an instance that is the same as x except that it has the sign of y.\n+     * abs(x) = dfp.copysign(x, dfp.one)\n+     * @param x number to get the value from\n+     * @param y number to get the sign from\n+     * @return a number with the value of x and the sign of y\n+     */\n+    public static Dfp copysign(final Dfp x, final Dfp y) {\n+        Dfp result = x.newInstance(x);\n+        result.sign = y.sign;\n+        return result;\n+    }\n+\n+    /** Returns the next number greater than this one in the direction of x.\n+     * If this==x then simply returns this.\n+     * @param x direction where to look at\n+     * @return closest number next to instance in the direction of x\n+     */\n+    public Dfp nextAfter(final Dfp x) {\n+\n+        // make sure we don't mix number with different precision\n+        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n+        }\n+\n+        // if this is greater than x\n+        boolean up = false;\n+        if (this.lessThan(x)) {\n+            up = true;\n+        }\n+\n+        if (compare(this, x) == 0) {\n+            return newInstance(x);\n+        }\n+\n+        if (lessThan(getZero())) {\n+            up = !up;\n+        }\n+\n+        final Dfp inc;\n+        Dfp result;\n+        if (up) {\n+            inc = newInstance(getOne());\n+            inc.exp = this.exp-mant.length+1;\n+            inc.sign = this.sign;\n+\n+            if (this.equals(getZero())) {\n+                inc.exp = MIN_EXP-mant.length;\n+            }\n+\n+            result = add(inc);\n+        } else {\n+            inc = newInstance(getOne());\n+            inc.exp = this.exp;\n+            inc.sign = this.sign;\n+\n+            if (this.equals(inc)) {\n+                inc.exp = this.exp-mant.length;\n+            } else {\n+                inc.exp = this.exp-mant.length+1;\n+            }\n+\n+            if (this.equals(getZero())) {\n+                inc.exp = MIN_EXP-mant.length;\n+            }\n+\n+            result = this.subtract(inc);\n+        }\n+\n+        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n+        }\n+\n+        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /** Convert the instance into a double.\n+     * @return a double approximating the instance\n+     * @see #toSplitDouble()\n+     */\n+    public double toDouble() {\n+\n+        if (isInfinite()) {\n+            if (lessThan(getZero())) {\n+                return Double.NEGATIVE_INFINITY;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (isNaN()) {\n+            return Double.NaN;\n+        }\n+\n+        Dfp y = this;\n+        boolean negate = false;\n+        if (lessThan(getZero())) {\n+            y = negate();\n+            negate = true;\n+        }\n+\n+        /* Find the exponent, first estimate by integer log10, then adjust.\n+         Should be faster than doing a natural logarithm.  */\n+        int exponent = (int)(y.log10() * 3.32);\n+        if (exponent < 0) {\n+            exponent--;\n+        }\n+\n+        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n+        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n+            tempDfp = tempDfp.multiply(2);\n+            exponent++;\n+        }\n+        exponent--;\n+\n+        /* We have the exponent, now work on the mantissa */\n+\n+        y = y.divide(DfpMath.pow(getTwo(), exponent));\n+        if (exponent > -1023) {\n+            y = y.subtract(getOne());\n+        }\n+\n+        if (exponent < -1074) {\n+            return 0;\n+        }\n+\n+        if (exponent > 1023) {\n+            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+        }\n+\n+\n+        y = y.multiply(newInstance(4503599627370496l)).rint();\n+        String str = y.toString();\n+        str = str.substring(0, str.length()-1);\n+        long mantissa = Long.parseLong(str);\n+\n+        if (mantissa == 4503599627370496L) {\n+            // Handle special case where we round up to next power of two\n+            mantissa = 0;\n+            exponent++;\n+        }\n+\n+        /* Its going to be subnormal, so make adjustments */\n+        if (exponent <= -1023) {\n+            exponent--;\n+        }\n+\n+        while (exponent < -1023) {\n+            exponent++;\n+            mantissa >>>= 1;\n+        }\n+\n+        long bits = mantissa | ((exponent + 1023L) << 52);\n+        double x = Double.longBitsToDouble(bits);\n+\n+        if (negate) {\n+            x = -x;\n+        }\n+\n+        return x;\n+\n+    }\n+\n+    /** Convert the instance into a split double.\n+     * @return an array of two doubles which sum represent the instance\n+     * @see #toDouble()\n+     */\n+    public double[] toSplitDouble() {\n+        double split[] = new double[2];\n+        long mask = 0xffffffffc0000000L;\n+\n+        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n+        split[1] = subtract(newInstance(split[0])).toDouble();\n+\n+        return split;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpDec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+/** Subclass of {@link Dfp} which hides the radix-10000 artifacts of the superclass.\n+ * This should give outward appearances of being a decimal number with DIGITS*4-3\n+ * decimal digits. This class can be subclassed to appear to be an arbitrary number\n+ * of decimal digits less than DIGITS*4-3.\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class DfpDec extends Dfp {\n+\n+    /** Makes an instance with a value of zero.\n+     * @param factory factory linked to this instance\n+     */\n+    protected DfpDec(final DfpField factory) {\n+        super(factory);\n+    }\n+\n+    /** Create an instance from a byte value.\n+     * @param factory factory linked to this instance\n+     * @param x value to convert to an instance\n+     */\n+    protected DfpDec(final DfpField factory, byte x) {\n+        super(factory, x);\n+    }\n+\n+    /** Create an instance from an int value.\n+     * @param factory factory linked to this instance\n+     * @param x value to convert to an instance\n+     */\n+    protected DfpDec(final DfpField factory, int x) {\n+        super(factory, x);\n+    }\n+\n+    /** Create an instance from a long value.\n+     * @param factory factory linked to this instance\n+     * @param x value to convert to an instance\n+     */\n+    protected DfpDec(final DfpField factory, long x) {\n+        super(factory, x);\n+    }\n+\n+    /** Create an instance from a double value.\n+     * @param factory factory linked to this instance\n+     * @param x value to convert to an instance\n+     */\n+    protected DfpDec(final DfpField factory, double x) {\n+        super(factory, x);\n+        round(0);\n+    }\n+\n+    /** Copy constructor.\n+     * @param d instance to copy\n+     */\n+    public DfpDec(final Dfp d) {\n+        super(d);\n+        round(0);\n+    }\n+\n+    /** Create an instance from a String representation.\n+     * @param factory factory linked to this instance\n+     * @param s string representation of the instance\n+     */\n+    protected DfpDec(final DfpField factory, final String s) {\n+        super(factory, s);\n+        round(0);\n+    }\n+\n+    /** Creates an instance with a non-finite value.\n+     * @param factory factory linked to this instance\n+     * @param sign sign of the Dfp to create\n+     * @param nans code of the value, must be one of {@link #INFINITE},\n+     * {@link #SNAN},  {@link #QNAN}\n+     */\n+    protected DfpDec(final DfpField factory, final byte sign, final byte nans) {\n+        super(factory, sign, nans);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance() {\n+        return new DfpDec(getField());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final byte x) {\n+        return new DfpDec(getField(), x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final int x) {\n+        return new DfpDec(getField(), x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final long x) {\n+        return new DfpDec(getField(), x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final double x) {\n+        return new DfpDec(getField(), x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final Dfp d) {\n+\n+        // make sure we don't mix number with different precision\n+        if (getField().getRadixDigits() != d.getField().getRadixDigits()) {\n+            getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, \"newInstance\", d, result);\n+        }\n+\n+        return new DfpDec(d);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final String s) {\n+        return new DfpDec(getField(), s);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp newInstance(final byte sign, final byte nans) {\n+        return new DfpDec(getField(), sign, nans);\n+    }\n+\n+    /** Get the number of decimal digits this class is going to represent.\n+     * Default implementation returns {@link #getRadixDigits()}*4-3. Subclasses can\n+     * override this to return something less.\n+     * @return number of decimal digits this class is going to represent\n+     */\n+    protected int getDecimalDigits() {\n+        return getRadixDigits() * 4 - 3;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected int round(int in) {\n+\n+        int msb = mant[mant.length-1];\n+        if (msb == 0) {\n+            // special case -- this == zero\n+            return 0;\n+        }\n+\n+        int cmaxdigits = mant.length * 4;\n+        int lsbthreshold = 1000;\n+        while (lsbthreshold > msb) {\n+            lsbthreshold /= 10;\n+            cmaxdigits --;\n+        }\n+\n+\n+        final int digits = getDecimalDigits();\n+        final int lsbshift = cmaxdigits - digits;\n+        final int lsd = lsbshift / 4;\n+\n+        lsbthreshold = 1;\n+        for (int i = 0; i < lsbshift % 4; i++) {\n+            lsbthreshold *= 10;\n+        }\n+\n+        final int lsb = mant[lsd];\n+\n+        if (lsbthreshold <= 1 && digits == 4 * mant.length - 3) {\n+            return super.round(in);\n+        }\n+\n+        int discarded = in;  // not looking at this after this point\n+        final int n;\n+        if (lsbthreshold == 1) {\n+            // look to the next digit for rounding\n+            n = (mant[lsd-1] / 1000) % 10;\n+            mant[lsd-1] %= 1000;\n+            discarded |= mant[lsd-1];\n+        } else {\n+            n = (lsb * 10 / lsbthreshold) % 10;\n+            discarded |= lsb % (lsbthreshold/10);\n+        }\n+\n+        for (int i = 0; i < lsd; i++) {\n+            discarded |= mant[i];    // need to know if there are any discarded bits\n+            mant[i] = 0;\n+        }\n+\n+        mant[lsd] = lsb / lsbthreshold * lsbthreshold;\n+\n+        final boolean inc;\n+        switch (getField().getRoundingMode()) {\n+            case ROUND_DOWN:\n+                inc = false;\n+                break;\n+\n+            case ROUND_UP:\n+                inc = (n != 0) || (discarded != 0); // round up if n!=0\n+                break;\n+\n+            case ROUND_HALF_UP:\n+                inc = n >= 5;  // round half up\n+                break;\n+\n+            case ROUND_HALF_DOWN:\n+                inc = n > 5;  // round half down\n+                break;\n+\n+            case ROUND_HALF_EVEN:\n+                inc = (n > 5) ||\n+                      (n == 5 && discarded != 0) ||\n+                      (n == 5 && discarded == 0 && ((lsb / lsbthreshold) & 1) == 1);  // round half-even\n+                break;\n+\n+            case ROUND_HALF_ODD:\n+                inc = (n > 5) ||\n+                      (n == 5 && discarded != 0) ||\n+                      (n == 5 && discarded == 0 && ((lsb / lsbthreshold) & 1) == 0);  // round half-odd\n+                break;\n+\n+            case ROUND_CEIL:\n+                inc = (sign == 1) && (n != 0 || discarded != 0);  // round ceil\n+                break;\n+\n+            case ROUND_FLOOR:\n+            default:\n+                inc = (sign == -1) && (n != 0 || discarded != 0);  // round floor\n+                break;\n+        }\n+\n+        if (inc) {\n+            // increment if necessary\n+            int rh = lsbthreshold;\n+            for (int i = lsd; i < mant.length; i++) {\n+                final int r = mant[i] + rh;\n+                rh = r / RADIX;\n+                mant[i] = r % RADIX;\n+            }\n+\n+            if (rh != 0) {\n+                shiftRight();\n+                mant[mant.length-1]=rh;\n+            }\n+        }\n+\n+        // Check for exceptional cases and raise signals if necessary\n+        if (exp < MIN_EXP) {\n+            // Gradual Underflow\n+            getField().setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n+            return DfpField.FLAG_UNDERFLOW;\n+        }\n+\n+        if (exp > MAX_EXP) {\n+            // Overflow\n+            getField().setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n+            return DfpField.FLAG_OVERFLOW;\n+        }\n+\n+        if (n != 0 || discarded != 0) {\n+            // Inexact\n+            getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            return DfpField.FLAG_INEXACT;\n+        }\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Dfp nextAfter(Dfp x) {\n+\n+        final String trapName = \"nextAfter\";\n+\n+        // make sure we don't mix number with different precision\n+        if (getField().getRadixDigits() != x.getField().getRadixDigits()) {\n+            getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = newInstance(getZero());\n+            result.nans = QNAN;\n+            return dotrap(DfpField.FLAG_INVALID, trapName, x, result);\n+        }\n+\n+        boolean up = false;\n+        Dfp result;\n+        Dfp inc;\n+\n+        // if this is greater than x\n+        if (this.lessThan(x)) {\n+            up = true;\n+        }\n+\n+        if (equals(x)) {\n+            return newInstance(x);\n+        }\n+\n+        if (lessThan(getZero())) {\n+            up = !up;\n+        }\n+\n+        if (up) {\n+            inc = power10(log10() - getDecimalDigits() + 1);\n+            inc = copysign(inc, this);\n+\n+            if (this.equals(getZero())) {\n+                inc = power10K(MIN_EXP-mant.length-1);\n+            }\n+\n+            if (inc.equals(getZero())) {\n+                result = copysign(newInstance(getZero()), this);\n+            } else {\n+                result = add(inc);\n+            }\n+        } else {\n+            inc = power10(log10());\n+            inc = copysign(inc, this);\n+\n+            if (this.equals(inc)) {\n+                inc = inc.divide(power10(getDecimalDigits()));\n+            } else {\n+                inc = inc.divide(power10(getDecimalDigits() - 1));\n+            }\n+\n+            if (this.equals(getZero())) {\n+                inc = power10K(MIN_EXP-mant.length-1);\n+            }\n+\n+            if (inc.equals(getZero())) {\n+                result = copysign(newInstance(getZero()), this);\n+            } else {\n+                result = subtract(inc);\n+            }\n+        }\n+\n+        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n+            getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            result = dotrap(DfpField.FLAG_INEXACT, trapName, x, result);\n+        }\n+\n+        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n+            getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            result = dotrap(DfpField.FLAG_INEXACT, trapName, x, result);\n+        }\n+\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import org.apache.commons.math.Field;\n+\n+/** Field for Decimal floating point instances.\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class DfpField implements Field<Dfp> {\n+\n+    /** Enumerate for rounding modes. */\n+    public enum RoundingMode {\n+\n+        /** Rounds toward zero (truncation). */\n+        ROUND_DOWN,\n+\n+        /** Rounds away from zero if discarded digit is non-zero. */\n+        ROUND_UP,\n+\n+        /** Rounds towards nearest unless both are equidistant in which case it rounds away from zero. */\n+        ROUND_HALF_UP,\n+\n+        /** Rounds towards nearest unless both are equidistant in which case it rounds toward zero. */\n+        ROUND_HALF_DOWN,\n+\n+        /** Rounds towards nearest unless both are equidistant in which case it rounds toward the even neighbor.\n+         * This is the default as  specified by IEEE 854-1987\n+         */\n+        ROUND_HALF_EVEN,\n+\n+        /** Rounds towards nearest unless both are equidistant in which case it rounds toward the odd neighbor.  */\n+        ROUND_HALF_ODD,\n+\n+        /** Rounds towards positive infinity. */\n+        ROUND_CEIL,\n+\n+        /** Rounds towards negative infinity. */\n+        ROUND_FLOOR;\n+\n+    }\n+\n+    /** IEEE 854-1987 flag for invalid operation. */\n+    public static final int FLAG_INVALID   =  1;\n+\n+    /** IEEE 854-1987 flag for division by zero. */\n+    public static final int FLAG_DIV_ZERO  =  2;\n+\n+    /** IEEE 854-1987 flag for overflow. */\n+    public static final int FLAG_OVERFLOW  =  4;\n+\n+    /** IEEE 854-1987 flag for underflow. */\n+    public static final int FLAG_UNDERFLOW =  8;\n+\n+    /** IEEE 854-1987 flag for inexact result. */\n+    public static final int FLAG_INEXACT   = 16;\n+\n+    /** High precision string representation of &radic;2. */\n+    private static String sqr2String;\n+\n+    /** High precision string representation of &radic;2 / 2. */\n+    private static String sqr2ReciprocalString;\n+\n+    /** High precision string representation of &radic;3. */\n+    private static String sqr3String;\n+\n+    /** High precision string representation of &radic;3 / 3. */\n+    private static String sqr3ReciprocalString;\n+\n+    /** High precision string representation of &pi;. */\n+    private static String piString;\n+\n+    /** High precision string representation of e. */\n+    private static String eString;\n+\n+    /** High precision string representation of ln(2). */\n+    private static String ln2String;\n+\n+    /** High precision string representation of ln(5). */\n+    private static String ln5String;\n+\n+    /** High precision string representation of ln(10). */\n+    private static String ln10String;\n+\n+    /** The number of radix digits.\n+     * Note these depend on the radix which is 10000 digits,\n+     * so each one is equivalent to 4 decimal digits.\n+     */\n+    private final int radixDigits;\n+\n+    /** A {@link Dfp} with value 0. */\n+    private final Dfp zero;\n+\n+    /** A {@link Dfp} with value 1. */\n+    private final Dfp one;\n+\n+    /** A {@link Dfp} with value 2. */\n+    private final Dfp two;\n+\n+    /** A {@link Dfp} with value &radic;2. */\n+    private final Dfp sqr2;\n+\n+    /** A two elements {@link Dfp} array with value &radic;2 split in two pieces. */\n+    private final Dfp[] sqr2Split;\n+\n+    /** A {@link Dfp} with value &radic;2 / 2. */\n+    private final Dfp sqr2Reciprocal;\n+\n+    /** A {@link Dfp} with value &radic;3. */\n+    private final Dfp sqr3;\n+\n+    /** A {@link Dfp} with value &radic;3 / 3. */\n+    private final Dfp sqr3Reciprocal;\n+\n+    /** A {@link Dfp} with value &pi;. */\n+    private final Dfp pi;\n+\n+    /** A two elements {@link Dfp} array with value &pi; split in two pieces. */\n+    private final Dfp[] piSplit;\n+\n+    /** A {@link Dfp} with value e. */\n+    private final Dfp e;\n+\n+    /** A two elements {@link Dfp} array with value e split in two pieces. */\n+    private final Dfp[] eSplit;\n+\n+    /** A {@link Dfp} with value ln(2). */\n+    private final Dfp ln2;\n+\n+    /** A two elements {@link Dfp} array with value ln(2) split in two pieces. */\n+    private final Dfp[] ln2Split;\n+\n+    /** A {@link Dfp} with value ln(5). */\n+    private final Dfp ln5;\n+\n+    /** A two elements {@link Dfp} array with value ln(5) split in two pieces. */\n+    private final Dfp[] ln5Split;\n+\n+    /** A {@link Dfp} with value ln(10). */\n+    private final Dfp ln10;\n+\n+    /** Current rounding mode. */\n+    private RoundingMode rMode;\n+\n+    /** IEEE 854-1987 signals. */\n+    private int ieeeFlags;\n+\n+    /** Create a factory for the specified number of radix digits.\n+     * <p>\n+     * Note that since the {@link Dfp} class uses 10000 as its radix, each radix\n+     * digit is equivalent to 4 decimal digits. This implies that asking for\n+     * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in\n+     * all cases.\n+     * </p>\n+     * @param decimalDigits minimal number of decimal digits.\n+     */\n+    public DfpField(final int decimalDigits) {\n+        this(decimalDigits, true);\n+    }\n+\n+    /** Create a factory for the specified number of radix digits.\n+     * <p>\n+     * Note that since the {@link Dfp} class uses 10000 as its radix, each radix\n+     * digit is equivalent to 4 decimal digits. This implies that asking for\n+     * 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in\n+     * all cases.\n+     * </p>\n+     * @param decimalDigits minimal number of decimal digits\n+     * @param computeConstants if true, the transcendental constants for the given precision\n+     * must be computed (setting this flag to false is RESERVED for the internal recursive call)\n+     */\n+    public DfpField(final int decimalDigits, final boolean computeConstants) {\n+\n+        this.radixDigits = (decimalDigits + 3) / 4;\n+        this.rMode       = RoundingMode.ROUND_HALF_EVEN;\n+        this.ieeeFlags   = 0;\n+        this.zero        = new Dfp(this, 0);\n+        this.one         = new Dfp(this, 1);\n+        this.two         = new Dfp(this, 2);\n+\n+        if (computeConstants) {\n+            // set up transcendental constants\n+            synchronized (DfpField.class) {\n+\n+                // as a heuristic to circumvent Table-Maker's Dilemma, we set the string\n+                // representation of the constants to be at least 3 times larger than the\n+                // number of decimal digits, also as an attempt to really compute these\n+                // constants only once, we set a minimum number of digits\n+                computeStringConstants((decimalDigits < 67) ? 200 : (3 * decimalDigits));\n+\n+                // set up the constants at current field accuracy\n+                sqr2           = new Dfp(this, sqr2String);\n+                sqr2Split      = split(sqr2String);\n+                sqr2Reciprocal = new Dfp(this, sqr2ReciprocalString);\n+                sqr3           = new Dfp(this, sqr3String);\n+                sqr3Reciprocal = new Dfp(this, sqr3ReciprocalString);\n+                pi             = new Dfp(this, piString);\n+                piSplit        = split(piString);\n+                e              = new Dfp(this, eString);\n+                eSplit         = split(eString);\n+                ln2            = new Dfp(this, ln2String);\n+                ln2Split       = split(ln2String);\n+                ln5            = new Dfp(this, ln5String);\n+                ln5Split       = split(ln5String);\n+                ln10           = new Dfp(this, ln10String);\n+\n+            }\n+        } else {\n+            // dummy settings for unused constants\n+            sqr2           = null;\n+            sqr2Split      = null;\n+            sqr2Reciprocal = null;\n+            sqr3           = null;\n+            sqr3Reciprocal = null;\n+            pi             = null;\n+            piSplit        = null;\n+            e              = null;\n+            eSplit         = null;\n+            ln2            = null;\n+            ln2Split       = null;\n+            ln5            = null;\n+            ln5Split       = null;\n+            ln10           = null;\n+        }\n+\n+    }\n+\n+    /** Get the number of radix digits of the {@link Dfp} instances built by this factory.\n+     * @return number of radix digits\n+     */\n+    public int getRadixDigits() {\n+        return radixDigits;\n+    }\n+\n+    /** Set the rounding mode.\n+     *  If not set, the default value is {@link RoundingMode#ROUND_HALF_EVEN}.\n+     * @param mode desired rounding mode\n+     * Note that the rounding mode is common to all {@link Dfp} instances\n+     * belonging to the current {@link DfpField} in the system and will\n+     * affect all future calculations.\n+     */\n+    public void setRoundingMode(final RoundingMode mode) {\n+        rMode = mode;\n+    }\n+\n+    /** Get the current rounding mode.\n+     * @return current rounding mode\n+     */\n+    public RoundingMode getRoundingMode() {\n+        return rMode;\n+    }\n+\n+    /** Get the IEEE 854 status flags.\n+     * @return IEEE 854 status flags\n+     * @see #clearIEEEFlags()\n+     * @see #setIEEEFlags(int)\n+     * @see #setIEEEFlagsBits(int)\n+     * @see #FLAG_INVALID\n+     * @see #FLAG_DIV_ZERO\n+     * @see #FLAG_OVERFLOW\n+     * @see #FLAG_UNDERFLOW\n+     * @see #FLAG_INEXACT\n+     */\n+    public int getIEEEFlags() {\n+        return ieeeFlags;\n+    }\n+\n+    /** Clears the IEEE 854 status flags.\n+     * @see #getIEEEFlags()\n+     * @see #setIEEEFlags(int)\n+     * @see #setIEEEFlagsBits(int)\n+     * @see #FLAG_INVALID\n+     * @see #FLAG_DIV_ZERO\n+     * @see #FLAG_OVERFLOW\n+     * @see #FLAG_UNDERFLOW\n+     * @see #FLAG_INEXACT\n+     */\n+    public void clearIEEEFlags() {\n+        ieeeFlags = 0;\n+    }\n+\n+    /** Sets the IEEE 854 status flags.\n+     * @param flags desired value for the flags\n+     * @see #getIEEEFlags()\n+     * @see #clearIEEEFlags()\n+     * @see #setIEEEFlagsBits(int)\n+     * @see #FLAG_INVALID\n+     * @see #FLAG_DIV_ZERO\n+     * @see #FLAG_OVERFLOW\n+     * @see #FLAG_UNDERFLOW\n+     * @see #FLAG_INEXACT\n+     */\n+    public void setIEEEFlags(final int flags) {\n+        ieeeFlags = flags & (FLAG_INVALID | FLAG_DIV_ZERO | FLAG_OVERFLOW | FLAG_UNDERFLOW | FLAG_INEXACT);\n+    }\n+\n+    /** Sets some bits in the IEEE 854 status flags, without changing the already set bits.\n+     * <p>\n+     * Calling this method is equivalent to call {@code setIEEEFlags(getIEEEFlags() | bits)}\n+     * </p>\n+     * @param bits bits to set\n+     * @see #getIEEEFlags()\n+     * @see #clearIEEEFlags()\n+     * @see #setIEEEFlags(int)\n+     * @see #FLAG_INVALID\n+     * @see #FLAG_DIV_ZERO\n+     * @see #FLAG_OVERFLOW\n+     * @see #FLAG_UNDERFLOW\n+     * @see #FLAG_INEXACT\n+     */\n+    public void setIEEEFlagsBits(final int bits) {\n+        ieeeFlags |= bits & (FLAG_INVALID | FLAG_DIV_ZERO | FLAG_OVERFLOW | FLAG_UNDERFLOW | FLAG_INEXACT);\n+    }\n+\n+    /** Makes a {@link Dfp} with a value of 0.\n+     * @return a new {@link Dfp} with a value of 0\n+     */\n+    public Dfp newDfp() {\n+        return new Dfp(this);\n+    }\n+\n+    /** Create an instance from a byte value.\n+     * @param x value to convert to an instance\n+     * @return a new {@link Dfp} with the same value as x\n+     */\n+    public Dfp newDfp(final byte x) {\n+        return new Dfp(this, x);\n+    }\n+\n+    /** Create an instance from an int value.\n+     * @param x value to convert to an instance\n+     * @return a new {@link Dfp} with the same value as x\n+     */\n+    public Dfp newDfp(final int x) {\n+        return new Dfp(this, x);\n+    }\n+\n+    /** Create an instance from a long value.\n+     * @param x value to convert to an instance\n+     * @return a new {@link Dfp} with the same value as x\n+     */\n+    public Dfp newDfp(final long x) {\n+        return new Dfp(this, x);\n+    }\n+\n+    /** Create an instance from a double value.\n+     * @param x value to convert to an instance\n+     * @return a new {@link Dfp} with the same value as x\n+     */\n+    public Dfp newDfp(final double x) {\n+        return new Dfp(this, x);\n+    }\n+\n+    /** Copy constructor.\n+     * @param d instance to copy\n+     * @return a new {@link Dfp} with the same value as d\n+     */\n+    public Dfp newDfp(Dfp d) {\n+        return new Dfp(d);\n+    }\n+\n+    /** Create a {@link Dfp} given a String representation.\n+     * @param s string representation of the instance\n+     * @return a new {@link Dfp} parsed from specified string\n+     */\n+    public Dfp newDfp(final String s) {\n+        return new Dfp(this, s);\n+    }\n+\n+    /** Creates a {@link Dfp} with a non-finite value.\n+     * @param sign sign of the Dfp to create\n+     * @param nans code of the value, must be one of {@link Dfp#INFINITE},\n+     * {@link Dfp#SNAN},  {@link Dfp#QNAN}\n+     * @return a new {@link Dfp} with a non-finite value\n+     */\n+    public Dfp newDfp(final byte sign, final byte nans) {\n+        return new Dfp(this, sign, nans);\n+    }\n+\n+    /** Get the constant 0.\n+     * @return a {@link Dfp} with value 0\n+     */\n+    public Dfp getZero() {\n+        return zero;\n+    }\n+\n+    /** Get the constant 1.\n+     * @return a {@link Dfp} with value 1\n+     */\n+    public Dfp getOne() {\n+        return one;\n+    }\n+\n+    /** Get the constant 2.\n+     * @return a {@link Dfp} with value 2\n+     */\n+    public Dfp getTwo() {\n+        return two;\n+    }\n+\n+    /** Get the constant &radic;2.\n+     * @return a {@link Dfp} with value &radic;2\n+     */\n+    public Dfp getSqr2() {\n+        return sqr2;\n+    }\n+\n+    /** Get the constant &radic;2 split in two pieces.\n+     * @return a {@link Dfp} with value &radic;2 split in two pieces\n+     */\n+    public Dfp[] getSqr2Split() {\n+        return sqr2Split.clone();\n+    }\n+\n+    /** Get the constant &radic;2 / 2.\n+     * @return a {@link Dfp} with value &radic;2 / 2\n+     */\n+    public Dfp getSqr2Reciprocal() {\n+        return sqr2Reciprocal;\n+    }\n+\n+    /** Get the constant &radic;3.\n+     * @return a {@link Dfp} with value &radic;3\n+     */\n+    public Dfp getSqr3() {\n+        return sqr3;\n+    }\n+\n+    /** Get the constant &radic;3 / 3.\n+     * @return a {@link Dfp} with value &radic;3 / 3\n+     */\n+    public Dfp getSqr3Reciprocal() {\n+        return sqr3Reciprocal;\n+    }\n+\n+    /** Get the constant &pi;.\n+     * @return a {@link Dfp} with value &pi;\n+     */\n+    public Dfp getPi() {\n+        return pi;\n+    }\n+\n+    /** Get the constant &pi; split in two pieces.\n+     * @return a {@link Dfp} with value &pi; split in two pieces\n+     */\n+    public Dfp[] getPiSplit() {\n+        return piSplit.clone();\n+    }\n+\n+    /** Get the constant e.\n+     * @return a {@link Dfp} with value e\n+     */\n+    public Dfp getE() {\n+        return e;\n+    }\n+\n+    /** Get the constant e split in two pieces.\n+     * @return a {@link Dfp} with value e split in two pieces\n+     */\n+    public Dfp[] getESplit() {\n+        return eSplit.clone();\n+    }\n+\n+    /** Get the constant ln(2).\n+     * @return a {@link Dfp} with value ln(2)\n+     */\n+    public Dfp getLn2() {\n+        return ln2;\n+    }\n+\n+    /** Get the constant ln(2) split in two pieces.\n+     * @return a {@link Dfp} with value ln(2) split in two pieces\n+     */\n+    public Dfp[] getLn2Split() {\n+        return ln2Split.clone();\n+    }\n+\n+    /** Get the constant ln(5).\n+     * @return a {@link Dfp} with value ln(5)\n+     */\n+    public Dfp getLn5() {\n+        return ln5;\n+    }\n+\n+    /** Get the constant ln(5) split in two pieces.\n+     * @return a {@link Dfp} with value ln(5) split in two pieces\n+     */\n+    public Dfp[] getLn5Split() {\n+        return ln5Split.clone();\n+    }\n+\n+    /** Get the constant ln(10).\n+     * @return a {@link Dfp} with value ln(10)\n+     */\n+    public Dfp getLn10() {\n+        return ln10;\n+    }\n+\n+    /** Breaks a string representation up into two {@link Dfp}'s.\n+     * The split is such that the sum of them is equivalent to the input string,\n+     * but has higher precision than using a single Dfp.\n+     * @param a string representation of the number to split\n+     * @return an array of two {@link Dfp Dfp} instances which sum equals a\n+     */\n+    private Dfp[] split(final String a) {\n+      Dfp result[] = new Dfp[2];\n+      boolean leading = true;\n+      int sp = 0;\n+      int sig = 0;\n+\n+      char[] buf = new char[a.length()];\n+\n+      for (int i = 0; i < buf.length; i++) {\n+        buf[i] = a.charAt(i);\n+\n+        if (buf[i] >= '1' && buf[i] <= '9') {\n+            leading = false;\n+        }\n+\n+        if (buf[i] == '.') {\n+          sig += (400 - sig) % 4;\n+          leading = false;\n+        }\n+\n+        if (sig == (radixDigits / 2) * 4) {\n+          sp = i;\n+          break;\n+        }\n+\n+        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n+            sig ++;\n+        }\n+      }\n+\n+      result[0] = new Dfp(this, new String(buf, 0, sp));\n+\n+      for (int i = 0; i < buf.length; i++) {\n+        buf[i] = a.charAt(i);\n+        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n+            buf[i] = '0';\n+        }\n+      }\n+\n+      result[1] = new Dfp(this, new String(buf));\n+\n+      return result;\n+\n+    }\n+\n+    /** Recompute the high precision string constants.\n+     * @param highPrecisionDecimalDigits precision at which the string constants mus be computed\n+     */\n+    private static void computeStringConstants(final int highPrecisionDecimalDigits) {\n+        if (sqr2String == null || sqr2String.length() < highPrecisionDecimalDigits - 3) {\n+\n+            // recompute the string representation of the transcendental constants\n+            final DfpField highPrecisionField = new DfpField(highPrecisionDecimalDigits, false);\n+            final Dfp highPrecisionOne        = new Dfp(highPrecisionField, 1);\n+            final Dfp highPrecisionTwo        = new Dfp(highPrecisionField, 2);\n+            final Dfp highPrecisionThree      = new Dfp(highPrecisionField, 3);\n+\n+            final Dfp highPrecisionSqr2 = highPrecisionTwo.sqrt();\n+            sqr2String           = highPrecisionSqr2.toString();\n+            sqr2ReciprocalString = highPrecisionOne.divide(highPrecisionSqr2).toString();\n+\n+            final Dfp highPrecisionSqr3 = highPrecisionThree.sqrt();\n+            sqr3String           = highPrecisionSqr3.toString();\n+            sqr3ReciprocalString = highPrecisionOne.divide(highPrecisionSqr3).toString();\n+\n+            piString   = computePi(highPrecisionOne, highPrecisionTwo, highPrecisionThree).toString();\n+            eString    = computeExp(highPrecisionOne, highPrecisionOne).toString();\n+            ln2String  = computeLn(highPrecisionTwo, highPrecisionOne, highPrecisionTwo).toString();\n+            ln5String  = computeLn(new Dfp(highPrecisionField, 5),  highPrecisionOne, highPrecisionTwo).toString();\n+            ln10String = computeLn(new Dfp(highPrecisionField, 10), highPrecisionOne, highPrecisionTwo).toString();\n+\n+        }\n+    }\n+\n+    /** Compute &pi; by atan(1/&radic;(3)) = &pi;/6.\n+     * @param one constant with value 1 at desired precision\n+     * @param two constant with value 2 at desired precision\n+     * @param three constant with value 3 at desired precision\n+     * @return &pi;\n+     */\n+    private static Dfp computePi(final Dfp one, final Dfp two, final Dfp three) {\n+\n+        Dfp x = three;\n+        x = x.sqrt();\n+        x = one.divide(x);\n+\n+        Dfp denom = one;\n+\n+        Dfp py = new Dfp(x);\n+        Dfp y  = new Dfp(x);\n+\n+        for (int i = 1; i < 10000; i++) {\n+            x = x.divide(three);\n+            denom = denom.add(two);\n+            if ((i&1) != 0) {\n+                y = y.subtract(x.divide(denom));\n+            } else {\n+                y = y.add(x.divide(denom));\n+            }\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y.multiply(new Dfp(one.getField(), 6));\n+\n+    }\n+\n+    /** Compute exp(a).\n+     * @param a number for which we want the exponential\n+     * @param one constant with value 1 at desired precision\n+     * @return exp(a)\n+     */\n+    public static Dfp computeExp(final Dfp a, final Dfp one) {\n+\n+        Dfp y  = new Dfp(one);\n+        Dfp py = new Dfp(one);\n+        Dfp f  = new Dfp(one);\n+        Dfp fi = new Dfp(one);\n+        Dfp x  = new Dfp(one);\n+\n+        for (int i = 0; i < 10000; i++) {\n+            x = x.multiply(a);\n+            y = y.add(x.divide(f));\n+            fi = fi.add(one);\n+            f = f.multiply(fi);\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y;\n+\n+    }\n+\n+\n+    /** Compute ln(a).\n+     *\n+     *  Let f(x) = ln(x),\n+     *\n+     *  We know that f'(x) = 1/x, thus from Taylor's theorem we have:\n+     *\n+     *           -----          n+1         n\n+     *  f(x) =   \\           (-1)    (x - 1)\n+     *           /          ----------------    for 1 <= n <= infinity\n+     *           -----             n\n+     *\n+     *  or\n+     *                       2        3       4\n+     *                   (x-1)   (x-1)    (x-1)\n+     *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n+     *                     2       3        4\n+     *\n+     *  alternatively,\n+     *\n+     *                  2    3   4\n+     *                 x    x   x\n+     *  ln(x+1) =  x - -  + - - - + ...\n+     *                 2    3   4\n+     *\n+     *  This series can be used to compute ln(x), but it converges too slowly.\n+     *\n+     *  If we substitute -x for x above, we get\n+     *\n+     *                   2    3    4\n+     *                  x    x    x\n+     *  ln(1-x) =  -x - -  - -  - - + ...\n+     *                  2    3    4\n+     *\n+     *  Note that all terms are now negative.  Because the even powered ones\n+     *  absorbed the sign.  Now, subtract the series above from the previous\n+     *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n+     *  only the odd ones\n+     *\n+     *                             3     5      7\n+     *                           2x    2x     2x\n+     *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n+     *                            3     5      7\n+     *\n+     *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n+     *\n+     *                                3        5        7\n+     *      x+1           /          x        x        x          \\\n+     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n+     *      x-1           \\          3        5        7          /\n+     *\n+     *  But now we want to find ln(a), so we need to find the value of x\n+     *  such that a = (x+1)/(x-1).   This is easily solved to find that\n+     *  x = (a-1)/(a+1).\n+     * @param a number for which we want the exponential\n+     * @param one constant with value 1 at desired precision\n+     * @param two constant with value 2 at desired precision\n+     * @return ln(a)\n+     */\n+\n+    public static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two) {\n+\n+        int den = 1;\n+        Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(one));\n+\n+        Dfp y = new Dfp(x);\n+        Dfp num = new Dfp(x);\n+        Dfp py = new Dfp(y);\n+        for (int i = 0; i < 10000; i++) {\n+            num = num.multiply(x);\n+            num = num.multiply(x);\n+            den = den + 2;\n+            Dfp t = num.divide(den);\n+            y = y.add(t);\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y.multiply(two);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpMath.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+/** Mathematical routines for use with {@link Dfp}.\n+ * The constants are defined in {@link DfpField}\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class DfpMath {\n+\n+    /** Name for traps triggered by pow. */\n+    private static final String POW_TRAP = \"pow\";\n+\n+    /**\n+     * Private Constructor.\n+     */\n+    private DfpMath() {\n+    }\n+\n+    /** Breaks a string representation up into two dfp's.\n+     * <p>The two dfp are such that the sum of them is equivalent\n+     * to the input string, but has higher precision than using a\n+     * single dfp. This is useful for improving accuracy of\n+     * exponentiation and critical multiplies.\n+     * @param field field to which the Dfp must belong\n+     * @param a string representation to split\n+     * @return an array of two {@link Dfp} which sum is a\n+     */\n+    protected static Dfp[] split(final DfpField field, final String a) {\n+        Dfp result[] = new Dfp[2];\n+        char[] buf;\n+        boolean leading = true;\n+        int sp = 0;\n+        int sig = 0;\n+\n+        buf = new char[a.length()];\n+\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = a.charAt(i);\n+\n+            if (buf[i] >= '1' && buf[i] <= '9') {\n+                leading = false;\n+            }\n+\n+            if (buf[i] == '.') {\n+                sig += (400 - sig) % 4;\n+                leading = false;\n+            }\n+\n+            if (sig == (field.getRadixDigits() / 2) * 4) {\n+                sp = i;\n+                break;\n+            }\n+\n+            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n+                sig ++;\n+            }\n+        }\n+\n+        result[0] = field.newDfp(new String(buf, 0, sp));\n+\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = a.charAt(i);\n+            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n+                buf[i] = '0';\n+            }\n+        }\n+\n+        result[1] = field.newDfp(new String(buf));\n+\n+        return result;\n+    }\n+\n+    /** Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n+     * @param a number to split\n+     * @return two elements array containing the split number\n+     */\n+    protected static Dfp[] split(final Dfp a) {\n+        final Dfp[] result = new Dfp[2];\n+        final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n+        result[0] = a.add(shift).subtract(shift);\n+        result[1] = a.subtract(result[0]);\n+        return result;\n+    }\n+\n+    /** Multiply two numbers that are split in to two pieces that are\n+     *  meant to be added together.\n+     *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n+     *  Store the first term in result0, the rest in result1\n+     *  @param a first factor of the multiplication, in split form\n+     *  @param b second factor of the multiplication, in split form\n+     *  @return a &times; b, in split form\n+     */\n+    protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n+        final Dfp[] result = new Dfp[2];\n+\n+        result[1] = a[0].getZero();\n+        result[0] = a[0].multiply(b[0]);\n+\n+        /* If result[0] is infinite or zero, don't compute result[1].\n+         * Attempting to do so may produce NaNs.\n+         */\n+\n+        if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n+            return result;\n+        }\n+\n+        result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n+\n+        return result;\n+    }\n+\n+    /** Divide two numbers that are split in to two pieces that are meant to be added together.\n+     * Inverse of split multiply above:\n+     *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n+     *  @param a dividend, in split form\n+     *  @param b divisor, in split form\n+     *  @return a / b, in split form\n+     */\n+    protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n+        final Dfp[] result;\n+\n+        result = new Dfp[2];\n+\n+        result[0] = a[0].divide(b[0]);\n+        result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n+        result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n+\n+        return result;\n+    }\n+\n+    /** Raise a split base to the a power.\n+     * @param base number to raise\n+     * @param a power\n+     * @return base<sup>a</sup>\n+     */\n+    protected static Dfp splitPow(final Dfp[] base, int a) {\n+        boolean invert = false;\n+\n+        Dfp[] r = new Dfp[2];\n+\n+        Dfp[] result = new Dfp[2];\n+        result[0] = base[0].getOne();\n+        result[1] = base[0].getZero();\n+\n+        if (a == 0) {\n+            // Special case a = 0\n+            return result[0].add(result[1]);\n+        }\n+\n+        if (a < 0) {\n+            // If a is less than zero\n+            invert = true;\n+            a = -a;\n+        }\n+\n+        // Exponentiate by successive squaring\n+        do {\n+            r[0] = new Dfp(base[0]);\n+            r[1] = new Dfp(base[1]);\n+            int trial = 1;\n+\n+            int prevtrial;\n+            while (true) {\n+                prevtrial = trial;\n+                trial = trial * 2;\n+                if (trial > a) {\n+                    break;\n+                }\n+                r = splitMult(r, r);\n+            }\n+\n+            trial = prevtrial;\n+\n+            a -= trial;\n+            result = splitMult(result, r);\n+\n+        } while (a >= 1);\n+\n+        result[0] = result[0].add(result[1]);\n+\n+        if (invert) {\n+            result[0] = base[0].getOne().divide(result[0]);\n+        }\n+\n+        return result[0];\n+\n+    }\n+\n+    /** Raises base to the power a by successive squaring.\n+     * @param base number to raise\n+     * @param a power\n+     * @return base<sup>a</sup>\n+     */\n+    public static Dfp pow(Dfp base, int a)\n+    {\n+        boolean invert = false;\n+\n+        Dfp result = base.getOne();\n+\n+        if (a == 0) {\n+            // Special case\n+            return result;\n+        }\n+\n+        if (a < 0) {\n+            invert = true;\n+            a = -a;\n+        }\n+\n+        // Exponentiate by successive squaring\n+        do {\n+            Dfp r = new Dfp(base);\n+            Dfp prevr;\n+            int trial = 1;\n+            int prevtrial;\n+\n+            do {\n+                prevr = new Dfp(r);\n+                prevtrial = trial;\n+                r = r.multiply(r);\n+                trial = trial * 2;\n+            } while (a>trial);\n+\n+            r = prevr;\n+            trial = prevtrial;\n+\n+            a = a - trial;\n+            result = result.multiply(r);\n+\n+        } while (a >= 1);\n+\n+        if (invert) {\n+            result = base.getOne().divide(result);\n+        }\n+\n+        return base.newInstance(result);\n+\n+    }\n+\n+    /** Computes e to the given power.\n+     * a is broken into two parts, such that a = n+m  where n is an integer.\n+     * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n+     * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n+     * @param a power at which e should be raised\n+     * @return e<sup>a</sup>\n+     */\n+    public static Dfp exp(final Dfp a) {\n+\n+        final Dfp inta = a.rint();\n+        final Dfp fraca = a.subtract(inta);\n+\n+        final int ia = inta.intValue();\n+        if (ia > 2147483646) {\n+            // return +Infinity\n+            return a.newInstance((byte)1, (byte) Dfp.INFINITE);\n+        }\n+\n+        if (ia < -2147483646) {\n+            // return 0;\n+            return a.newInstance();\n+        }\n+\n+        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n+        final Dfp efraca = expInternal(fraca);\n+\n+        return einta.multiply(efraca);\n+    }\n+\n+    /** Computes e to the given power.\n+     * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n+     * @param a power at which e should be raised\n+     * @return e<sup>a</sup>\n+     */\n+    protected static Dfp expInternal(final Dfp a) {\n+        Dfp y = a.getOne();\n+        Dfp x = a.getOne();\n+        Dfp fact = a.getOne();\n+        Dfp py = new Dfp(y);\n+\n+        for (int i = 1; i < 90; i++) {\n+            x = x.multiply(a);\n+            fact = fact.divide(i);\n+            y = y.add(x.multiply(fact));\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y;\n+    }\n+\n+    /** Returns the natural logarithm of a.\n+     * a is first split into three parts such that  a = (10000^h)(2^j)k.\n+     * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n+     * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n+     * @param a number from which logarithm is requested\n+     * @return log(a)\n+     */\n+    public static Dfp log(Dfp a) {\n+        int lr;\n+        Dfp x;\n+        int ix;\n+        int p2 = 0;\n+\n+        // Check the arguments somewhat here\n+        if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || (a.equals(a) == false)) {\n+            // negative, zero or NaN\n+            a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte)1, (byte) Dfp.QNAN));\n+        }\n+\n+        if (a.classify() == Dfp.INFINITE) {\n+            return a;\n+        }\n+\n+        x = new Dfp(a);\n+        lr = x.log10K();\n+\n+        x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n+        ix = x.floor().intValue();\n+\n+        while (ix > 2) {\n+            ix >>= 1;\n+            p2++;\n+        }\n+\n+\n+        Dfp[] spx = split(x);\n+        Dfp[] spy = new Dfp[2];\n+        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n+        spx[0] = spx[0].divide(spy[0]);\n+        spx[1] = spx[1].divide(spy[0]);\n+\n+        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n+        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n+            spx[0] = spx[0].divide(2);\n+            spx[1] = spx[1].divide(2);\n+            p2++;\n+        }\n+\n+        // X is now in the range of 2/3 < x < 4/3\n+        Dfp[] spz = logInternal(spx);\n+\n+        spx[0] = a.newInstance(new StringBuffer().append(p2+4*lr).toString());\n+        spx[1] = a.getZero();\n+        spy = splitMult(a.getField().getLn2Split(), spx);\n+\n+        spz[0] = spz[0].add(spy[0]);\n+        spz[1] = spz[1].add(spy[1]);\n+\n+        spx[0] = a.newInstance(new StringBuffer().append(4*lr).toString());\n+        spx[1] = a.getZero();\n+        spy = splitMult(a.getField().getLn5Split(), spx);\n+\n+        spz[0] = spz[0].add(spy[0]);\n+        spz[1] = spz[1].add(spy[1]);\n+\n+        return a.newInstance(spz[0].add(spz[1]));\n+\n+    }\n+\n+    /** Computes the natural log of a number between 0 and 2.\n+     *  Let f(x) = ln(x),\n+     *\n+     *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n+     *\n+     *           -----          n+1         n\n+     *  f(x) =   \\           (-1)    (x - 1)\n+     *           /          ----------------    for 1 <= n <= infinity\n+     *           -----             n\n+     *\n+     *  or\n+     *                       2        3       4\n+     *                   (x-1)   (x-1)    (x-1)\n+     *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n+     *                     2       3        4\n+     *\n+     *  alternatively,\n+     *\n+     *                  2    3   4\n+     *                 x    x   x\n+     *  ln(x+1) =  x - -  + - - - + ...\n+     *                 2    3   4\n+     *\n+     *  This series can be used to compute ln(x), but it converges too slowly.\n+     *\n+     *  If we substitute -x for x above, we get\n+     *\n+     *                   2    3    4\n+     *                  x    x    x\n+     *  ln(1-x) =  -x - -  - -  - - + ...\n+     *                  2    3    4\n+     *\n+     *  Note that all terms are now negative.  Because the even powered ones\n+     *  absorbed the sign.  Now, subtract the series above from the previous\n+     *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n+     *  only the odd ones\n+     *\n+     *                             3     5      7\n+     *                           2x    2x     2x\n+     *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n+     *                            3     5      7\n+     *\n+     *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n+     *\n+     *                                3        5        7\n+     *      x+1           /          x        x        x          \\\n+     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n+     *      x-1           \\          3        5        7          /\n+     *\n+     *  But now we want to find ln(a), so we need to find the value of x\n+     *  such that a = (x+1)/(x-1).   This is easily solved to find that\n+     *  x = (a-1)/(a+1).\n+     * @param a number from which logarithm is requested, in split form\n+     * @return log(a)\n+     */\n+    protected static Dfp[] logInternal(final Dfp a[]) {\n+\n+        /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n+         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n+         */\n+        Dfp t = a[0].divide(4).add(a[1].divide(4));\n+        Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n+\n+        Dfp y = new Dfp(x);\n+        Dfp num = new Dfp(x);\n+        Dfp py = new Dfp(y);\n+        int den = 1;\n+        for (int i = 0; i < 10000; i++) {\n+            num = num.multiply(x);\n+            num = num.multiply(x);\n+            den = den + 2;\n+            t = num.divide(den);\n+            y = y.add(t);\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        y = y.multiply(a[0].getTwo());\n+\n+        return split(y);\n+\n+    }\n+\n+    /** Computes x to the y power.<p>\n+     *\n+     *  Uses the following method:<p>\n+     *\n+     *  <ol>\n+     *  <li> Set u = rint(y), v = y-u\n+     *  <li> Compute a = v * ln(x)\n+     *  <li> Compute b = rint( a/ln(2) )\n+     *  <li> Compute c = a - b*ln(2)\n+     *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n+     *  </ol>\n+     *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n+     *\n+     *  <b>Special Cases</b><p>\n+     *  <ul>\n+     *  <li>  if y is 0.0 or -0.0 then result is 1.0\n+     *  <li>  if y is 1.0 then result is x\n+     *  <li>  if y is NaN then result is NaN\n+     *  <li>  if x is NaN and y is not zero then result is NaN\n+     *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n+     *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n+     *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n+     *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n+     *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n+     *  <li>  if x = +0 and y > 0 then result is +0\n+     *  <li>  if x = +Inf and y < 0 then result is +0\n+     *  <li>  if x = +0 and y < 0 then result is +Inf\n+     *  <li>  if x = +Inf and y > 0 then result is +Inf\n+     *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n+     *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n+     *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n+     *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n+     *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n+     *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n+     *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n+     *  </ul>\n+     *  @param x base to be raised\n+     *  @param y power to which base should be raised\n+     *  @return x<sup>y</sup>\n+     */\n+    public static Dfp pow(Dfp x, final Dfp y) {\n+\n+        // make sure we don't mix number with different precision\n+        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n+            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            final Dfp result = x.newInstance(x.getZero());\n+            result.nans = Dfp.QNAN;\n+            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n+        }\n+\n+        final Dfp zero = x.getZero();\n+        final Dfp one  = x.getOne();\n+        final Dfp two  = x.getTwo();\n+        boolean invert = false;\n+        int ui;\n+\n+        /* Check for special cases */\n+        if (y.equals(zero)) {\n+            return x.newInstance(one);\n+        }\n+\n+        if (y.equals(one)) {\n+            if (!x.equals(x)) {\n+                // Test for NaNs\n+                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n+            }\n+            return x;\n+        }\n+\n+        if (!x.equals(x) || !y.equals(y)) {\n+            // Test for NaNs\n+            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, (byte) Dfp.QNAN));\n+        }\n+\n+        // X == 0\n+        if (x.equals(zero)) {\n+            if (Dfp.copysign(one, x).greaterThan(zero)) {\n+                // X == +0\n+                if (y.greaterThan(zero)) {\n+                    return x.newInstance(zero);\n+                } else {\n+                    return x.newInstance(x.newInstance((byte)1, (byte)Dfp.INFINITE));\n+                }\n+            } else {\n+                // X == -0\n+                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n+                    // If y is odd integer\n+                    if (y.greaterThan(zero)) {\n+                        return x.newInstance(zero.negate());\n+                    } else {\n+                        return x.newInstance(x.newInstance((byte)-1, (byte)Dfp.INFINITE));\n+                    }\n+                } else {\n+                    // Y is not odd integer\n+                    if (y.greaterThan(zero)) {\n+                        return x.newInstance(zero);\n+                    } else {\n+                        return x.newInstance(x.newInstance((byte)1, (byte)Dfp.INFINITE));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (x.lessThan(zero)) {\n+            // Make x positive, but keep track of it\n+            x = x.negate();\n+            invert = true;\n+        }\n+\n+        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n+            if (y.greaterThan(zero)) {\n+                return y;\n+            } else {\n+                return x.newInstance(zero);\n+            }\n+        }\n+\n+        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n+            if (y.greaterThan(zero)) {\n+                return x.newInstance(zero);\n+            } else {\n+                return x.newInstance(Dfp.copysign(y, one));\n+            }\n+        }\n+\n+        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n+            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, (byte) Dfp.QNAN));\n+        }\n+\n+        if (x.classify() == Dfp.INFINITE) {\n+            // x = +/- inf\n+            if (invert) {\n+                // negative infinity\n+                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n+                    // If y is odd integer\n+                    if (y.greaterThan(zero)) {\n+                        return x.newInstance(x.newInstance((byte)-1, (byte)Dfp.INFINITE));\n+                    } else {\n+                        return x.newInstance(zero.negate());\n+                    }\n+                } else {\n+                    // Y is not odd integer\n+                    if (y.greaterThan(zero)) {\n+                        return x.newInstance(x.newInstance((byte)1, (byte)Dfp.INFINITE));\n+                    } else {\n+                        return x.newInstance(zero);\n+                    }\n+                }\n+            } else {\n+                // positive infinity\n+                if (y.greaterThan(zero)) {\n+                    return x;\n+                } else {\n+                    return x.newInstance(zero);\n+                }\n+            }\n+        }\n+\n+        if (invert && !y.rint().equals(y)) {\n+            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, (byte) Dfp.QNAN));\n+        }\n+\n+        // End special cases\n+\n+        Dfp r;\n+        if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n+            final Dfp u = y.rint();\n+            ui = u.intValue();\n+\n+            final Dfp v = y.subtract(u);\n+\n+            if (v.unequal(zero)) {\n+                final Dfp a = v.multiply(log(x));\n+                final Dfp b = a.divide(x.getField().getLn2()).rint();\n+\n+                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n+                r = splitPow(split(x), ui);\n+                r = r.multiply(pow(two, b.intValue()));\n+                r = r.multiply(exp(c));\n+            } else {\n+                r = splitPow(split(x), ui);\n+            }\n+        } else {\n+            // very large exponent.  |y| > 1e8\n+            r = exp(log(x).multiply(y));\n+        }\n+\n+        if (invert) {\n+            // if y is odd integer\n+            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n+                r = r.negate();\n+            }\n+        }\n+\n+        return x.newInstance(r);\n+\n+    }\n+\n+    /** Computes sin(a)  Used when 0 < a < pi/4.\n+     * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...\n+     * @param a number from which sine is desired, in split form\n+     * @return sin(a)\n+     */\n+    protected static Dfp sinInternal(Dfp a[]) {\n+\n+        Dfp c = a[0].add(a[1]);\n+        Dfp y = c;\n+        c = c.multiply(c);\n+        Dfp x = y;\n+        Dfp fact = a[0].getOne();\n+        Dfp py = new Dfp(y);\n+\n+        for (int i = 3; i < 90; i += 2) {\n+            x = x.multiply(c);\n+            x = x.negate();\n+\n+            fact = fact.divide((i-1)*i);  // 1 over fact\n+            y = y.add(x.multiply(fact));\n+            if (y.equals(py))\n+                break;\n+            py = new Dfp(y);\n+        }\n+\n+        return y;\n+\n+    }\n+\n+    /** Computes cos(a)  Used when 0 < a < pi/4.\n+     * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...\n+     * @param a number from which cosine is desired, in split form\n+     * @return cos(a)\n+     */\n+    protected static Dfp cosInternal(Dfp a[]) {\n+        final Dfp one = a[0].getOne();\n+\n+\n+        Dfp x = one;\n+        Dfp y = one;\n+        Dfp c = a[0].add(a[1]);\n+        c = c.multiply(c);\n+\n+        Dfp fact = one;\n+        Dfp py = new Dfp(y);\n+\n+        for (int i = 2; i < 90; i += 2) {\n+            x = x.multiply(c);\n+            x = x.negate();\n+\n+            fact = fact.divide((i - 1) * i);  // 1 over fact\n+\n+            y = y.add(x.multiply(fact));\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y;\n+\n+    }\n+\n+    /** computes the sine of the argument.\n+     * @param a number from which sine is desired\n+     * @return sin(a)\n+     */\n+    public static Dfp sin(final Dfp a) {\n+        final Dfp pi = a.getField().getPi();\n+        final Dfp zero = a.getField().getZero();\n+        boolean neg = false;\n+\n+        /* First reduce the argument to the range of +/- PI */\n+        Dfp x = a.remainder(pi.multiply(2));\n+\n+        /* if x < 0 then apply identity sin(-x) = -sin(x) */\n+        /* This puts x in the range 0 < x < PI            */\n+        if (x.lessThan(zero)) {\n+            x = x.negate();\n+            neg = true;\n+        }\n+\n+        /* Since sine(x) = sine(pi - x) we can reduce the range to\n+         * 0 < x < pi/2\n+         */\n+\n+        if (x.greaterThan(pi.divide(2))) {\n+            x = pi.subtract(x);\n+        }\n+\n+        Dfp y;\n+        if (x.lessThan(pi.divide(4))) {\n+            Dfp c[] = new Dfp[2];\n+            c[0] = x;\n+            c[1] = zero;\n+\n+            //y = sinInternal(c);\n+            y = sinInternal(split(x));\n+        } else {\n+            final Dfp c[] = new Dfp[2];\n+            final Dfp[] piSplit = a.getField().getPiSplit();\n+            c[0] = piSplit[0].divide(2).subtract(x);\n+            c[1] = piSplit[1].divide(2);\n+            y = cosInternal(c);\n+        }\n+\n+        if (neg) {\n+            y = y.negate();\n+        }\n+\n+        return a.newInstance(y);\n+\n+    }\n+\n+    /** computes the cosine of the argument.\n+     * @param a number from which cosine is desired\n+     * @return cos(a)\n+     */\n+    public static Dfp cos(Dfp a) {\n+        final Dfp pi = a.getField().getPi();\n+        final Dfp zero = a.getField().getZero();\n+        boolean neg = false;\n+\n+        /* First reduce the argument to the range of +/- PI */\n+        Dfp x = a.remainder(pi.multiply(2));\n+\n+        /* if x < 0 then apply identity cos(-x) = cos(x) */\n+        /* This puts x in the range 0 < x < PI           */\n+        if (x.lessThan(zero)) {\n+            x = x.negate();\n+        }\n+\n+        /* Since cos(x) = -cos(pi - x) we can reduce the range to\n+         * 0 < x < pi/2\n+         */\n+\n+        if (x.greaterThan(pi.divide(2))) {\n+            x = pi.subtract(x);\n+            neg = true;\n+        }\n+\n+        Dfp y;\n+        if (x.lessThan(pi.divide(4))) {\n+            Dfp c[] = new Dfp[2];\n+            c[0] = x;\n+            c[1] = zero;\n+\n+            y = cosInternal(c);\n+        } else {\n+            final Dfp c[] = new Dfp[2];\n+            final Dfp[] piSplit = a.getField().getPiSplit();\n+            c[0] = piSplit[0].divide(2).subtract(x);\n+            c[1] = piSplit[1].divide(2);\n+            y = sinInternal(c);\n+        }\n+\n+        if (neg) {\n+            y = y.negate();\n+        }\n+\n+        return a.newInstance(y);\n+\n+    }\n+\n+    /** computes the tangent of the argument.\n+     * @param a number from which tangent is desired\n+     * @return tan(a)\n+     */\n+    public static Dfp tan(final Dfp a) {\n+        return sin(a).divide(cos(a));\n+    }\n+\n+    /** computes the arc-tangent of the argument.\n+     * @param a number from which arc-tangent is desired\n+     * @return atan(a)\n+     */\n+    protected static Dfp atanInternal(final Dfp a) {\n+\n+        Dfp y = new Dfp(a);\n+        Dfp x = new Dfp(y);\n+        Dfp py = new Dfp(y);\n+\n+        for (int i = 3; i < 90; i += 2) {\n+            x = x.multiply(a);\n+            x = x.multiply(a);\n+            x = x.negate();\n+            y = y.add(x.divide(i));\n+            if (y.equals(py)) {\n+                break;\n+            }\n+            py = new Dfp(y);\n+        }\n+\n+        return y;\n+\n+    }\n+\n+    /** computes the arc tangent of the argument\n+     *\n+     *  Uses the typical taylor series\n+     *\n+     *  but may reduce arguments using the following identity\n+     * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))\n+     *\n+     * since tan(PI/8) = sqrt(2)-1,\n+     *\n+     * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0\n+     * @param a number from which arc-tangent is desired\n+     * @return atan(a)\n+     */\n+    public static Dfp atan(final Dfp a) {\n+        final Dfp   zero      = a.getField().getZero();\n+        final Dfp   one       = a.getField().getOne();\n+        final Dfp[] sqr2Split = a.getField().getSqr2Split();\n+        final Dfp[] piSplit   = a.getField().getPiSplit();\n+        boolean recp = false;\n+        boolean neg = false;\n+        boolean sub = false;\n+\n+        final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]);\n+\n+        Dfp x = new Dfp(a);\n+        if (x.lessThan(zero)) {\n+            neg = true;\n+            x = x.negate();\n+        }\n+\n+        if (x.greaterThan(one)) {\n+            recp = true;\n+            x = one.divide(x);\n+        }\n+\n+        if (x.greaterThan(ty)) {\n+            Dfp sty[] = new Dfp[2];\n+            sub = true;\n+\n+            sty[0] = sqr2Split[0].subtract(one);\n+            sty[1] = sqr2Split[1];\n+\n+            Dfp[] xs = split(x);\n+\n+            Dfp[] ds = splitMult(xs, sty);\n+            ds[0] = ds[0].add(one);\n+\n+            xs[0] = xs[0].subtract(sty[0]);\n+            xs[1] = xs[1].subtract(sty[1]);\n+\n+            xs = splitDiv(xs, ds);\n+            x = xs[0].add(xs[1]);\n+\n+            //x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));\n+        }\n+\n+        Dfp y = atanInternal(x);\n+\n+        if (sub) {\n+            y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8));\n+        }\n+\n+        if (recp) {\n+            y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2));\n+        }\n+\n+        if (neg) {\n+            y = y.negate();\n+        }\n+\n+        return a.newInstance(y);\n+\n+    }\n+\n+    /** computes the arc-sine of the argument.\n+     * @param a number from which arc-sine is desired\n+     * @return asin(a)\n+     */\n+    public static Dfp asin(final Dfp a) {\n+        return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt()));\n+    }\n+\n+    /** computes the arc-cosine of the argument.\n+     * @param a number from which arc-cosine is desired\n+     * @return acos(a)\n+     */\n+    public static Dfp acos(Dfp a) {\n+        Dfp result;\n+        boolean negative = false;\n+\n+        if (a.lessThan(a.getZero())) {\n+            negative = true;\n+        }\n+\n+        a = Dfp.copysign(a, a.getOne());  // absolute value\n+\n+        result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a));\n+\n+        if (negative) {\n+            result = a.getField().getPi().subtract(result);\n+        }\n+\n+        return a.newInstance(result);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/dfp/Decimal10.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+public class Decimal10 extends DfpDec {\n+\n+    Decimal10(final DfpField factory) {\n+        super(factory);\n+    }\n+\n+    Decimal10(final DfpField factory, final byte x) {\n+        super(factory, x);\n+    }\n+\n+    Decimal10(final DfpField factory, final int x) {\n+        super(factory, x);\n+    }\n+\n+    Decimal10(final DfpField factory, final long x) {\n+        super(factory, x);\n+    }\n+\n+    Decimal10(final DfpField factory, final double x) {\n+        super(factory, x);\n+    }\n+\n+    public Decimal10(final Dfp d) {\n+        super(d);\n+    }\n+\n+    public Decimal10(final DfpField factory, final String s) {\n+        super(factory, s);\n+    }\n+\n+    protected Decimal10(final DfpField factory, final byte sign, final byte nans) {\n+        super(factory, sign, nans);\n+    }\n+\n+    public Dfp newInstance() {\n+        return new Decimal10(getField());\n+    }\n+\n+    public Dfp newInstance(final byte x) {\n+        return new Decimal10(getField(), x);\n+    }\n+\n+    public Dfp newInstance(final int x) {\n+        return new Decimal10(getField(), x);\n+    }\n+\n+    public Dfp newInstance(final long x) {\n+        return new Decimal10(getField(), x);\n+    }\n+\n+    public Dfp newInstance(final double x) {\n+        return new Decimal10(getField(), x);\n+    }\n+\n+    public Dfp newInstance(final Dfp d) {\n+        return new Decimal10(d);\n+    }\n+\n+    public Dfp newInstance(final String s) {\n+        return new Decimal10(getField(), s);\n+    }\n+\n+    public Dfp newInstance(final byte sign, final byte nans) {\n+        return new Decimal10(getField(), sign, nans);\n+    }\n+\n+    protected int getDecimalDigits() {\n+        return 10;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/dfp/DfpDecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class DfpDecTest {\n+\n+    private DfpField field;\n+    private Dfp pinf;\n+    private Dfp ninf;\n+    private Dfp nan;\n+    private Dfp snan;\n+    private Dfp qnan;\n+\n+    @Before\n+    public void setUp() {\n+        // Some basic setup.  Define some constants and clear the status flags\n+        field = new DfpField(20);\n+        pinf = new DfpDec(field, 1).divide(new DfpDec(field, 0));\n+        ninf = new DfpDec(field, -1).divide(new DfpDec(field, 0));\n+        nan = new DfpDec(field, 0).divide(new DfpDec(field, 0));\n+        snan = field.newDfp((byte)1, Dfp.SNAN);\n+        qnan = field.newDfp((byte)1, Dfp.QNAN);\n+        ninf.getField().clearIEEEFlags();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        field = null;\n+        pinf    = null;\n+        ninf    = null;\n+        nan     = null;\n+        snan    = null;\n+        qnan    = null;\n+    }\n+\n+    // Generic test function.  Takes params x and y and tests them for \n+    // equality.  Then checks the status flags against the flags argument.\n+    // If the test fail, it prints the desc string\n+    private void test(Dfp x, Dfp y, int flags, String desc) {\n+        boolean b = x.equals(y);\n+\n+        if (!x.equals(y) && !x.unequal(y))  // NaNs involved \n+            b = (x.toString().equals(y.toString()));\n+\n+        if (x.equals(new DfpDec(field, 0)))  // distinguish +/- zero\n+            b = (b && (x.toString().equals(y.toString())));\n+\n+        b = (b && x.getField().getIEEEFlags() == flags);\n+\n+        if (!b)\n+            Assert.assertTrue(\"assersion failed \"+desc+\" x = \"+x.toString()+\" flags = \"+x.getField().getIEEEFlags(), b);\n+\n+        x.getField().clearIEEEFlags();\n+    }\n+\n+    @Test\n+    public void testRound()\n+    {\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);\n+\n+        test(new DfpDec(field, \"12345678901234567890\"),\n+             new DfpDec(field, \"12345678901234568000\"),\n+             DfpField.FLAG_INEXACT, \"Round #1\");\n+\n+        test(new DfpDec(field, \"0.12345678901234567890\"),\n+             new DfpDec(field, \"0.12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #2\");\n+\n+        test(new DfpDec(field, \"0.12345678901234567500\"),\n+             new DfpDec(field, \"0.12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #3\");\n+\n+        test(new DfpDec(field, \"0.12345678901234568500\"),\n+             new DfpDec(field, \"0.12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #4\");\n+\n+        test(new DfpDec(field, \"0.12345678901234568501\"),\n+             new DfpDec(field, \"0.12345678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #5\");\n+\n+        test(new DfpDec(field, \"0.12345678901234568499\"),\n+             new DfpDec(field, \"0.12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #6\");\n+\n+        test(new DfpDec(field, \"1.2345678901234567890\"),\n+             new DfpDec(field, \"1.2345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #7\");\n+\n+        test(new DfpDec(field, \"1.2345678901234567500\"),\n+             new DfpDec(field, \"1.2345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #8\");\n+\n+        test(new DfpDec(field, \"1.2345678901234568500\"),\n+             new DfpDec(field, \"1.2345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #9\");\n+\n+        test(new DfpDec(field, \"1.2345678901234568000\").add(new DfpDec(field, \".0000000000000000501\")),\n+             new DfpDec(field, \"1.2345678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #10\");\n+\n+        test(new DfpDec(field, \"1.2345678901234568499\"),\n+             new DfpDec(field, \"1.2345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #11\");\n+\n+        test(new DfpDec(field, \"12.345678901234567890\"),\n+             new DfpDec(field, \"12.345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #12\");\n+\n+        test(new DfpDec(field, \"12.345678901234567500\"),\n+             new DfpDec(field, \"12.345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #13\");\n+\n+        test(new DfpDec(field, \"12.345678901234568500\"),\n+             new DfpDec(field, \"12.345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #14\");\n+\n+        test(new DfpDec(field, \"12.345678901234568\").add(new DfpDec(field, \".000000000000000501\")),\n+             new DfpDec(field, \"12.345678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #15\");\n+\n+        test(new DfpDec(field, \"12.345678901234568499\"),\n+             new DfpDec(field, \"12.345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #16\");\n+\n+        test(new DfpDec(field, \"123.45678901234567890\"),\n+             new DfpDec(field, \"123.45678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #17\");\n+\n+        test(new DfpDec(field, \"123.45678901234567500\"),\n+             new DfpDec(field, \"123.45678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #18\");\n+\n+        test(new DfpDec(field, \"123.45678901234568500\"),\n+             new DfpDec(field, \"123.45678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #19\");\n+\n+        test(new DfpDec(field, \"123.456789012345685\").add(new DfpDec(field, \".00000000000000501\")),\n+             new DfpDec(field, \"123.45678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #20\");\n+\n+        test(new DfpDec(field, \"123.45678901234568499\"),\n+             new DfpDec(field, \"123.45678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #21\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);\n+\n+        // Round down\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.9\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #22\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.99999999\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #23\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.99999999\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #24\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);\n+\n+        // Round up\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.1\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #25\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.0001\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #26\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.1\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #27\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.0001\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #28\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"0\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             0, \"Round #28.5\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);\n+\n+        // Round half up\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.499999999999\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #29\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.50000001\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #30\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.5\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #30.5\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.499999999999\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #31\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.50000001\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #32\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);\n+\n+        // Round half down\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.5001\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #33\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.5000\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #34\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.5001\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #35\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.6\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #35.5\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.5000\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #36\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);\n+\n+        // Round half odd\n+        test(new DfpDec(field, \"12345678901234568\").add(new DfpDec(field, \"0.5000\")),\n+             new DfpDec(field, \"12345678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #37\");\n+\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.5000\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #38\");\n+\n+        test(new DfpDec(field, \"-12345678901234568\").add(new DfpDec(field, \"-0.5000\")),\n+             new DfpDec(field, \"-12345678901234569\"),\n+             DfpField.FLAG_INEXACT, \"Round #39\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.5000\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #40\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);\n+\n+        // Round ceil\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.0001\")),\n+             new DfpDec(field, \"12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #41\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.9999\")),\n+             new DfpDec(field, \"-12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #42\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);\n+\n+        // Round floor\n+        test(new DfpDec(field, \"12345678901234567\").add(new DfpDec(field, \"0.9999\")),\n+             new DfpDec(field, \"12345678901234567\"),\n+             DfpField.FLAG_INEXACT, \"Round #43\");\n+\n+        test(new DfpDec(field, \"-12345678901234567\").add(new DfpDec(field, \"-0.0001\")),\n+             new DfpDec(field, \"-12345678901234568\"),\n+             DfpField.FLAG_INEXACT, \"Round #44\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset\n+    }\n+\n+    @Test\n+    public void testRoundDecimal10()\n+    {\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);\n+\n+        test(new Decimal10(field, \"1234567891234567890\"),\n+             new Decimal10(field, \"1234567891000000000\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #1\");\n+\n+        test(new Decimal10(field, \"0.1234567891634567890\"),\n+             new Decimal10(field, \"0.1234567892\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #2\");\n+\n+        test(new Decimal10(field, \"0.1234567891500000000\"),\n+             new Decimal10(field, \"0.1234567892\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #3\");\n+\n+        test(new Decimal10(field, \"0.1234567890500\"),\n+             new Decimal10(field, \"0.1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #4\");\n+\n+        test(new Decimal10(field, \"0.1234567890501\"),\n+             new Decimal10(field, \"0.1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #5\");\n+\n+        test(new Decimal10(field, \"0.1234567890499\"),\n+             new Decimal10(field, \"0.1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #6\");\n+\n+        test(new Decimal10(field, \"1.234567890890\"),\n+             new Decimal10(field, \"1.234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #7\");\n+\n+        test(new Decimal10(field, \"1.234567891500\"),\n+             new Decimal10(field, \"1.234567892\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #8\");\n+\n+        test(new Decimal10(field, \"1.234567890500\"),\n+             new Decimal10(field, \"1.234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #9\");\n+\n+        test(new Decimal10(field, \"1.234567890000\").add(new Decimal10(field, \".000000000501\")),\n+             new Decimal10(field, \"1.234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #10\");\n+\n+        test(new Decimal10(field, \"1.234567890499\"),\n+             new Decimal10(field, \"1.234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #11\");\n+\n+        test(new Decimal10(field, \"12.34567890890\"),\n+             new Decimal10(field, \"12.34567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #12\");\n+\n+        test(new Decimal10(field, \"12.34567891500\"),\n+             new Decimal10(field, \"12.34567892\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #13\");\n+\n+        test(new Decimal10(field, \"12.34567890500\"),\n+             new Decimal10(field, \"12.34567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #14\");\n+\n+        test(new Decimal10(field, \"12.34567890\").add(new Decimal10(field, \".00000000501\")),\n+             new Decimal10(field, \"12.34567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #15\");\n+\n+        test(new Decimal10(field, \"12.34567890499\"),\n+             new Decimal10(field, \"12.34567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #16\");\n+\n+        test(new Decimal10(field, \"123.4567890890\"),\n+             new Decimal10(field, \"123.4567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #17\");\n+\n+        test(new Decimal10(field, \"123.4567891500\"),\n+             new Decimal10(field, \"123.4567892\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #18\");\n+\n+        test(new Decimal10(field, \"123.4567890500\"),\n+             new Decimal10(field, \"123.4567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #19\");\n+\n+        test(new Decimal10(field, \"123.4567890\").add(new Decimal10(field, \".0000000501\")),\n+             new Decimal10(field, \"123.4567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #20\");\n+\n+        test(new Decimal10(field, \"123.4567890499\"),\n+             new Decimal10(field, \"123.4567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #21\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);\n+\n+        // RoundDecimal10 down\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.9\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #22\");\n+\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.99999999\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #23\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.99999999\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #24\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);\n+\n+        // RoundDecimal10 up\n+        test(new Decimal10(field, 1234567890).add(new Decimal10(field, \"0.1\")),\n+             new Decimal10(field, 1234567891l),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #25\");\n+\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.0001\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #26\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.1\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #27\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.0001\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #28\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"0\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             0, \"RoundDecimal10 #28.5\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);\n+\n+        // RoundDecimal10 half up\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.4999999999\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #29\");\n+\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.50000001\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #30\");\n+\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.5\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #30.5\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.4999999999\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #31\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.50000001\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #32\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);\n+\n+        // RoundDecimal10 half down\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.5001\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #33\");\n+\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.5000\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #34\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.5001\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #35\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.6\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #35.5\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.5000\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #36\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);\n+\n+        // RoundDecimal10 half odd\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.5000\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #37\");\n+\n+        test(new Decimal10(field, \"1234567891\").add(new Decimal10(field, \"0.5000\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #38\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.5000\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #39\");\n+\n+        test(new Decimal10(field, \"-1234567891\").add(new Decimal10(field, \"-0.5000\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #40\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);\n+\n+        // RoundDecimal10 ceil\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.0001\")),\n+             new Decimal10(field, \"1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #41\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.9999\")),\n+             new Decimal10(field, \"-1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #42\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);\n+\n+        // RoundDecimal10 floor\n+        test(new Decimal10(field, \"1234567890\").add(new Decimal10(field, \"0.9999\")),\n+             new Decimal10(field, \"1234567890\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #43\");\n+\n+        test(new Decimal10(field, \"-1234567890\").add(new Decimal10(field, \"-0.0001\")),\n+             new Decimal10(field, \"-1234567891\"),\n+             DfpField.FLAG_INEXACT, \"RoundDecimal10 #44\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset\n+    }\n+\n+    @Test\n+    public void testNextAfter()\n+    {\n+        test(new DfpDec(field, 1).nextAfter(pinf),\n+             new DfpDec(field, \"1.0000000000000001\"),\n+             0, \"NextAfter #1\");\n+\n+        test(new DfpDec(field, \"1.0000000000000001\").nextAfter(ninf),\n+             new DfpDec(field, 1),\n+             0, \"NextAfter #1.5\");\n+\n+        test(new DfpDec(field, 1).nextAfter(ninf),\n+             new DfpDec(field, \"0.99999999999999999\"),\n+             0, \"NextAfter #2\");\n+\n+        test(new DfpDec(field, \"0.99999999999999999\").nextAfter(new DfpDec(field, 2)),\n+             new DfpDec(field, 1),\n+             0, \"NextAfter #3\");\n+\n+        test(new DfpDec(field, -1).nextAfter(ninf),\n+             new DfpDec(field, \"-1.0000000000000001\"),\n+             0, \"NextAfter #4\");\n+\n+        test(new DfpDec(field, -1).nextAfter(pinf),\n+             new DfpDec(field, \"-0.99999999999999999\"),\n+             0, \"NextAfter #5\");\n+\n+        test(new DfpDec(field, \"-0.99999999999999999\").nextAfter(new DfpDec(field, -2)),\n+             new DfpDec(field, (byte) -1),\n+             0, \"NextAfter #6\");\n+\n+        test(new DfpDec(field, (byte) 2).nextAfter(new DfpDec(field, 2)),\n+             new DfpDec(field, 2l),\n+             0, \"NextAfter #7\");\n+\n+        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 0)),\n+             new DfpDec(field, 0),\n+             0, \"NextAfter #8\");\n+\n+        test(new DfpDec(field, -2).nextAfter(new DfpDec(field, -2)),\n+             new DfpDec(field, -2),\n+             0, \"NextAfter #9\");\n+\n+        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 1)),\n+             new DfpDec(field, \"1e-131092\"),\n+             DfpField.FLAG_UNDERFLOW, \"NextAfter #10\");\n+\n+        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, -1)),\n+             new DfpDec(field, \"-1e-131092\"),\n+             DfpField.FLAG_UNDERFLOW, \"NextAfter #11\");\n+\n+        test(new DfpDec(field, \"-1e-131092\").nextAfter(pinf),\n+             new DfpDec(field, \"-0\"),\n+             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, \"Next After #12\");\n+\n+        test(new DfpDec(field, \"1e-131092\").nextAfter(ninf), \n+             new DfpDec(field, \"0\"),\n+             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, \"Next After #13\");\n+\n+        test(new DfpDec(field, \"9.9999999999999999e131078\").nextAfter(pinf),\n+             pinf,\n+             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, \"Next After #14\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/dfp/DfpMathTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+\n+public class DfpMathTest {\n+\n+    private DfpField factory;\n+    private Dfp pinf;\n+    private Dfp ninf;\n+    private Dfp nan;\n+    private Dfp snan;\n+    private Dfp qnan;\n+\n+    @Before\n+    public void setUp() {\n+        // Some basic setup.  Define some constants and clear the status flags\n+        factory = new DfpField(20);\n+        pinf = factory.newDfp(\"1\").divide(factory.newDfp(\"0\"));\n+        ninf = factory.newDfp(\"-1\").divide(factory.newDfp(\"0\"));\n+        nan = factory.newDfp(\"0\").divide(factory.newDfp(\"0\"));\n+        snan = factory.newDfp((byte)1, Dfp.SNAN);\n+        qnan = factory.newDfp((byte)1, Dfp.QNAN);\n+        ninf.getField().clearIEEEFlags();\n+\n+        // force loading of dfpmath\n+        Dfp pi = factory.getPi();\n+        pi.getField().clearIEEEFlags();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        pinf = null;\n+        ninf = null;\n+        nan  = null;\n+        snan = null;\n+        qnan = null;\n+    }\n+\n+    // Generic test function.  Takes params x and y and tests them for \n+    // equality.  Then checks the status flags against the flags argument.\n+    // If the test fail, it prints the desc string\n+    private void test(Dfp x, Dfp y, int flags, String desc)\n+    {\n+        boolean b = x.equals(y);\n+\n+        if (!x.equals(y) && !x.unequal(y))  // NaNs involved \n+            b = (x.toString().equals(y.toString()));\n+\n+        if (x.equals(factory.newDfp(\"0\")))  // distinguish +/- zero\n+            b = (b && (x.toString().equals(y.toString())));\n+\n+        b = (b && x.getField().getIEEEFlags() == flags);\n+\n+        if (!b)\n+            Assert.assertTrue(\"assersion failed \"+desc+\" x = \"+x.toString()+\" flags = \"+x.getField().getIEEEFlags(), b);\n+\n+        x.getField().clearIEEEFlags();\n+    }\n+\n+    public void testPow()  \n+    {\n+        // Test special cases  exponent of zero\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #1\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"-0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #2\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"2\"), factory.newDfp(\"0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #3\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"-0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #4\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"-0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #5\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"0\")),\n+             factory.newDfp(\"1\"), \n+             0, \"pow #6\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-0\")),      \n+             factory.newDfp(\"1\"), \n+             0, \"pow #7\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"0\")),\n+             factory.newDfp(\"1\"), \n+             0, \"pow #8\");\n+\n+        test(DfpMath.pow(qnan, factory.newDfp(\"0\")),\n+             factory.newDfp(\"1\"), \n+             0, \"pow #8\");\n+\n+        // exponent of one\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"1\")),\n+             factory.newDfp(\"0\"), \n+             0, \"pow #9\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"1\")),      \n+             factory.newDfp(\"-0\"), \n+             0, \"pow #10\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"2\"), factory.newDfp(\"1\")),\n+             factory.newDfp(\"2\"), \n+             0, \"pow #11\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"1\")),\n+             factory.newDfp(\"-2\"), \n+             0, \"pow #12\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"1\")),      \n+             pinf, \n+             0, \"pow #13\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"1\")),\n+             ninf, \n+             0, \"pow #14\");\n+\n+        test(DfpMath.pow(qnan, factory.newDfp(\"1\")),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #14.1\");\n+\n+        // exponent of NaN\n+        test(DfpMath.pow(factory.newDfp(\"0\"), qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #15\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), qnan),      \n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #16\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"2\"), qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #17\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #18\");\n+\n+        test(DfpMath.pow(pinf, qnan),      \n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #19\");\n+\n+        test(DfpMath.pow(ninf, qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #20\");\n+\n+        test(DfpMath.pow(qnan, qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #21\");\n+\n+        // radix of NaN\n+        test(DfpMath.pow(qnan, factory.newDfp(\"1\")),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #22\");\n+\n+        test(DfpMath.pow(qnan, factory.newDfp(\"-1\")),      \n+             qnan,\n+             DfpField.FLAG_INVALID, \"pow #23\");\n+\n+        test(DfpMath.pow(qnan, pinf),\n+             qnan,\n+             DfpField.FLAG_INVALID, \"pow #24\");\n+\n+        test(DfpMath.pow(qnan, ninf),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #25\");\n+\n+        test(DfpMath.pow(qnan, qnan),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #26\");\n+\n+        // (x > 1) ^ pinf = pinf,    (x < -1) ^ pinf = pinf\n+        test(DfpMath.pow(factory.newDfp(\"2\"), pinf),\n+             pinf, \n+             0, \"pow #27\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), pinf),      \n+             pinf,\n+             0, \"pow #28\");\n+\n+        test(DfpMath.pow(pinf, pinf),\n+             pinf,\n+             0, \"pow #29\");\n+\n+        test(DfpMath.pow(ninf, pinf),\n+             pinf, \n+             0, \"pow #30\");\n+\n+        // (x > 1) ^ ninf = +0,    (x < -1) ^ ninf = +0\n+        test(DfpMath.pow(factory.newDfp(\"2\"), ninf),\n+             factory.getZero(), \n+             0, \"pow #31\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), ninf),      \n+             factory.getZero(),\n+             0, \"pow #32\");\n+\n+        test(DfpMath.pow(pinf, ninf),\n+             factory.getZero(),\n+             0, \"pow #33\");\n+\n+        test(DfpMath.pow(ninf, ninf),\n+             factory.getZero(), \n+             0, \"pow #34\");\n+\n+        // (-1 < x < 1) ^ pinf = 0\n+        test(DfpMath.pow(factory.newDfp(\"0.5\"), pinf),\n+             factory.getZero(), \n+             0, \"pow #35\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0.5\"), pinf),      \n+             factory.getZero(),\n+             0, \"pow #36\");\n+\n+        // (-1 < x < 1) ^ ninf = pinf \n+        test(DfpMath.pow(factory.newDfp(\"0.5\"), ninf),\n+             pinf, \n+             0, \"pow #37\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0.5\"), ninf),      \n+             pinf,\n+             0, \"pow #38\");\n+\n+        // +/- 1  ^ +/-inf  = NaN\n+        test(DfpMath.pow(factory.getOne(), pinf),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #39\");\n+\n+        test(DfpMath.pow(factory.getOne(), ninf),      \n+             qnan,\n+             DfpField.FLAG_INVALID, \"pow #40\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-1\"), pinf),\n+             qnan, \n+             DfpField.FLAG_INVALID, \"pow #41\");\n+\n+        test(DfpMath.pow(factory.getOne().negate(), ninf),      \n+             qnan,\n+             DfpField.FLAG_INVALID, \"pow #42\");\n+\n+        // +0  ^ +anything except 0, NAN  = +0\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"1\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #43\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"1e30\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #44\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"1e-30\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #45\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), pinf),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #46\");\n+\n+        // -0  ^ +anything except 0, NAN, odd integer  = +0\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"2\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #47\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"1e30\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #48\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"1e-30\")),\n+             factory.newDfp(\"0\"),\n+             DfpField.FLAG_INEXACT, \"pow #49\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), pinf),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #50\");\n+\n+        // +0  ^ -anything except 0, NAN  = +INF\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"-1\")),\n+             pinf,\n+             0, \"pow #51\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"-1e30\")),\n+             pinf,\n+             0, \"pow #52\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), factory.newDfp(\"-1e-30\")),\n+             pinf,\n+             0, \"pow #53\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"0\"), ninf),\n+             pinf,\n+             0, \"pow #54\");\n+\n+        // -0  ^ -anything except 0, NAN, odd integer  = +INF\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"-2\")),\n+             pinf,\n+             0, \"pow #55\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"-1e30\")),\n+             pinf,\n+             0, \"pow #56\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"-1e-30\")),\n+             pinf,\n+             DfpField.FLAG_INEXACT, \"pow #57\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), ninf),\n+             pinf,\n+             0, \"pow #58\");\n+\n+        // -0  ^ -odd integer   =  -INF\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"-1\")),\n+             ninf,\n+             DfpField.FLAG_INEXACT, \"pow #59\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"-12345\")),\n+             ninf,\n+             DfpField.FLAG_INEXACT, \"pow #60\");\n+\n+        // -0  ^ +odd integer   =  -0\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"3\")),\n+             factory.newDfp(\"-0\"),\n+             DfpField.FLAG_INEXACT, \"pow #61\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-0\"), factory.newDfp(\"12345\")),\n+             factory.newDfp(\"-0\"),\n+             DfpField.FLAG_INEXACT, \"pow #62\");\n+\n+        // pinf  ^ +anything   = pinf \n+        test(DfpMath.pow(pinf, factory.newDfp(\"3\")),\n+             pinf,\n+             0, \"pow #63\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"1e30\")),\n+             pinf,\n+             0, \"pow #64\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"1e-30\")),\n+             pinf,\n+             0, \"pow #65\");\n+\n+        test(DfpMath.pow(pinf, pinf),\n+             pinf,\n+             0, \"pow #66\");\n+\n+        // pinf  ^ -anything   = +0 \n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"-3\")),\n+             factory.getZero(),\n+             0, \"pow #67\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"-1e30\")),\n+             factory.getZero(),\n+             0, \"pow #68\");\n+\n+        test(DfpMath.pow(pinf, factory.newDfp(\"-1e-30\")),\n+             factory.getZero(),\n+             0, \"pow #69\");\n+\n+        test(DfpMath.pow(pinf, ninf),\n+             factory.getZero(),\n+             0, \"pow #70\");\n+\n+        // ninf  ^ anything   = -0 ^ -anything\n+        // ninf  ^ -anything except 0, NAN, odd integer  = +0\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-2\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #71\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-1e30\")),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #72\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-1e-30\")),\n+             factory.newDfp(\"0\"),\n+             DfpField.FLAG_INEXACT, \"pow #73\");\n+\n+        test(DfpMath.pow(ninf, ninf),\n+             factory.newDfp(\"0\"),\n+             0, \"pow #74\");\n+\n+        // ninf  ^ +anything except 0, NAN, odd integer  = +INF\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"2\")),\n+             pinf,\n+             0, \"pow #75\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"1e30\")),\n+             pinf,\n+             0, \"pow #76\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"1e-30\")),\n+             pinf,\n+             DfpField.FLAG_INEXACT, \"pow #77\");\n+\n+        test(DfpMath.pow(ninf, pinf),\n+             pinf,\n+             0, \"pow #78\");\n+\n+        // ninf  ^ +odd integer   =  -INF\n+        test(DfpMath.pow(ninf, factory.newDfp(\"3\")),\n+             ninf,\n+             DfpField.FLAG_INEXACT, \"pow #79\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"12345\")),\n+             ninf,\n+             DfpField.FLAG_INEXACT, \"pow #80\");\n+\n+        // ninf  ^ -odd integer   =  -0\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-3\")),\n+             factory.newDfp(\"-0\"),\n+             DfpField.FLAG_INEXACT, \"pow #81\");\n+\n+        test(DfpMath.pow(ninf, factory.newDfp(\"-12345\")),\n+             factory.newDfp(\"-0\"),\n+             DfpField.FLAG_INEXACT, \"pow #82\");\n+\n+        // -anything ^ integer \n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"3\")),\n+             factory.newDfp(\"-8\"),\n+             DfpField.FLAG_INEXACT, \"pow #83\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"16\")),\n+             factory.newDfp(\"65536\"),\n+             0, \"pow #84\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"-3\")),\n+             factory.newDfp(\"-0.125\"),\n+             DfpField.FLAG_INEXACT, \"pow #85\");\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"-4\")),\n+             factory.newDfp(\"0.0625\"),\n+             0, \"pow #86\");\n+\n+        // -anything ^ noninteger = NaN\n+\n+        test(DfpMath.pow(factory.newDfp(\"-2\"), factory.newDfp(\"-4.1\")),\n+             qnan,\n+             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, \"pow #87\");\n+\n+        // Some fractional cases.\n+        test(DfpMath.pow(factory.newDfp(\"2\"),factory.newDfp(\"1.5\")),\n+             factory.newDfp(\"2.8284271247461901\"), \n+             DfpField.FLAG_INEXACT, \"pow #88\");\n+    }\n+\n+    public void testSin()\n+    {\n+        test(DfpMath.sin(pinf),\n+             nan,\n+             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, \"sin #1\");\n+\n+        test(DfpMath.sin(nan),\n+             nan,\n+             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, \"sin #2\");\n+\n+        test(DfpMath.sin(factory.getZero()),\n+             factory.getZero(),\n+             DfpField.FLAG_INEXACT, \"sin #3\");\n+\n+        test(DfpMath.sin(factory.getPi()),\n+             factory.getZero(),\n+             DfpField.FLAG_INEXACT, \"sin #4\");\n+\n+        test(DfpMath.sin(factory.getPi().negate()),\n+             factory.newDfp(\"-0\"),\n+             DfpField.FLAG_INEXACT, \"sin #5\");\n+\n+        test(DfpMath.sin(factory.getPi().multiply(2)),\n+             factory.getZero(),\n+             DfpField.FLAG_INEXACT, \"sin #6\");\n+\n+        test(DfpMath.sin(factory.getPi().divide(2)),\n+             factory.getOne(),\n+             DfpField.FLAG_INEXACT, \"sin #7\");\n+\n+        test(DfpMath.sin(factory.getPi().divide(2).negate()),\n+             factory.getOne().negate(),\n+             DfpField.FLAG_INEXACT, \"sin #8\");\n+\n+        test(DfpMath.sin(DfpMath.atan(factory.getOne())),  // pi/4\n+             factory.newDfp(\"0.5\").sqrt(),\n+             DfpField.FLAG_INEXACT, \"sin #9\");\n+\n+        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4\n+             factory.newDfp(\"0.5\").sqrt().negate(),\n+             DfpField.FLAG_INEXACT, \"sin #10\");\n+\n+        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4\n+             factory.newDfp(\"0.5\").sqrt().negate(),\n+             DfpField.FLAG_INEXACT, \"sin #11\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.1\")),\n+             factory.newDfp(\"0.0998334166468281523\"),\n+             DfpField.FLAG_INEXACT, \"sin #12\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.2\")),\n+             factory.newDfp(\"0.19866933079506121546\"),\n+             DfpField.FLAG_INEXACT, \"sin #13\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.3\")),\n+             factory.newDfp(\"0.2955202066613395751\"),\n+             DfpField.FLAG_INEXACT, \"sin #14\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.4\")),\n+             factory.newDfp(\"0.38941834230865049166\"),\n+             DfpField.FLAG_INEXACT, \"sin #15\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.5\")),\n+             factory.newDfp(\"0.47942553860420300026\"),  // off by one ULP\n+             DfpField.FLAG_INEXACT, \"sin #16\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.6\")),\n+             factory.newDfp(\"0.56464247339503535721\"),  // off by one ULP\n+             DfpField.FLAG_INEXACT, \"sin #17\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.7\")),\n+             factory.newDfp(\"0.64421768723769105367\"),  \n+             DfpField.FLAG_INEXACT, \"sin #18\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.8\")),        \n+             factory.newDfp(\"0.71735609089952276163\"),\n+             DfpField.FLAG_INEXACT, \"sin #19\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"0.9\")),        // off by one ULP\n+             factory.newDfp(\"0.78332690962748338847\"),\n+             DfpField.FLAG_INEXACT, \"sin #20\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.0\")),\n+             factory.newDfp(\"0.84147098480789650666\"),\n+             DfpField.FLAG_INEXACT, \"sin #21\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.1\")),\n+             factory.newDfp(\"0.89120736006143533995\"),\n+             DfpField.FLAG_INEXACT, \"sin #22\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.2\")),\n+             factory.newDfp(\"0.93203908596722634968\"),\n+             DfpField.FLAG_INEXACT, \"sin #23\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.3\")),\n+             factory.newDfp(\"0.9635581854171929647\"),\n+             DfpField.FLAG_INEXACT, \"sin #24\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.4\")),\n+             factory.newDfp(\"0.98544972998846018066\"),\n+             DfpField.FLAG_INEXACT, \"sin #25\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.5\")),\n+             factory.newDfp(\"0.99749498660405443096\"),\n+             DfpField.FLAG_INEXACT, \"sin #26\");\n+\n+        test(DfpMath.sin(factory.newDfp(\"1.6\")),\n+             factory.newDfp(\"0.99957360304150516323\"),\n+             DfpField.FLAG_INEXACT, \"sin #27\");\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/dfp/DfpTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class DfpTest {\n+\n+    private DfpField field;\n+    private Dfp pinf;\n+    private Dfp ninf;\n+    private Dfp nan;\n+    private Dfp snan;\n+    private Dfp qnan;\n+\n+    @Before\n+    public void setUp() {\n+        // Some basic setup.  Define some constants and clear the status flags\n+        field = new DfpField(20);\n+        pinf = field.newDfp(\"1\").divide(field.newDfp(\"0\"));\n+        ninf = field.newDfp(\"-1\").divide(field.newDfp(\"0\"));\n+        nan = field.newDfp(\"0\").divide(field.newDfp(\"0\"));\n+        snan = field.newDfp((byte)1, Dfp.SNAN);\n+        qnan = field.newDfp((byte)1, Dfp.QNAN);\n+        ninf.getField().clearIEEEFlags();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        field = null;\n+        pinf    = null;\n+        ninf    = null;\n+        nan     = null;\n+        snan    = null;\n+        qnan    = null;\n+    }\n+\n+    // Generic test function.  Takes params x and y and tests them for \n+    // equality.  Then checks the status flags against the flags argument.\n+    // If the test fail, it prints the desc string\n+    private void test(Dfp x, Dfp y, int flags, String desc)\n+    {\n+        boolean b = x.equals(y);\n+\n+        if (!x.equals(y) && !x.unequal(y))  // NaNs involved \n+            b = (x.toString().equals(y.toString()));\n+\n+        if (x.equals(field.newDfp(\"0\")))  // distinguish +/- zero\n+            b = (b && (x.toString().equals(y.toString())));\n+\n+        b = (b && x.getField().getIEEEFlags() == flags);\n+\n+        if (!b)\n+            Assert.assertTrue(\"assersion failed \"+desc+\" x = \"+x.toString()+\" flags = \"+x.getField().getIEEEFlags(), b);\n+\n+        x.getField().clearIEEEFlags();\n+    }\n+\n+    @Test\n+    public void testByteConstructor() {\n+        Assert.assertEquals(\"0.\", new Dfp(field, (byte) 0).toString());\n+        Assert.assertEquals(\"1.\", new Dfp(field, (byte) 1).toString());\n+        Assert.assertEquals(\"-1.\", new Dfp(field, (byte) -1).toString());\n+        Assert.assertEquals(\"-128.\", new Dfp(field, Byte.MIN_VALUE).toString());\n+        Assert.assertEquals(\"127.\", new Dfp(field, Byte.MAX_VALUE).toString());\n+    }\n+\n+    @Test\n+    public void testIntConstructor() {\n+        Assert.assertEquals(\"0.\", new Dfp(field, 0).toString());\n+        Assert.assertEquals(\"1.\", new Dfp(field, 1).toString());\n+        Assert.assertEquals(\"-1.\", new Dfp(field, -1).toString());\n+        Assert.assertEquals(\"1234567890.\", new Dfp(field, 1234567890).toString());\n+        Assert.assertEquals(\"-1234567890.\", new Dfp(field, -1234567890).toString());\n+        Assert.assertEquals(\"-2147483648.\", new Dfp(field, Integer.MIN_VALUE).toString());\n+        Assert.assertEquals(\"2147483647.\", new Dfp(field, Integer.MAX_VALUE).toString());\n+    }\n+\n+    @Test\n+    public void testLongConstructor() {\n+        Assert.assertEquals(\"0.\", new Dfp(field, 0l).toString());\n+        Assert.assertEquals(\"1.\", new Dfp(field, 1l).toString());\n+        Assert.assertEquals(\"-1.\", new Dfp(field, -1l).toString());\n+        Assert.assertEquals(\"1234567890.\", new Dfp(field, 1234567890l).toString());\n+        Assert.assertEquals(\"-1234567890.\", new Dfp(field, -1234567890l).toString());\n+        Assert.assertEquals(\"-9223372036854775808.\", new Dfp(field, Long.MIN_VALUE).toString());\n+        Assert.assertEquals(\"9223372036854775807.\", new Dfp(field, Long.MAX_VALUE).toString());\n+    }\n+\n+    /*\n+     *  Test addition\n+     */\n+    @Test\n+    public void testAdd()\n+    {\n+        test(field.newDfp(\"1\").add(field.newDfp(\"1\")),      // Basic tests   1+1 = 2\n+             field.newDfp(\"2\"), \n+             0, \"Add #1\");\n+\n+        test(field.newDfp(\"1\").add(field.newDfp(\"-1\")),     // 1 + (-1) = 0\n+             field.newDfp(\"0\"), \n+             0, \"Add #2\");\n+\n+        test(field.newDfp(\"-1\").add(field.newDfp(\"1\")),     // (-1) + 1 = 0\n+             field.newDfp(\"0\"), \n+             0, \"Add #3\");\n+\n+        test(field.newDfp(\"-1\").add(field.newDfp(\"-1\")),     // (-1) + (-1) = -2\n+             field.newDfp(\"-2\"), \n+             0, \"Add #4\");\n+\n+        // rounding mode is round half even\n+\n+        test(field.newDfp(\"1\").add(field.newDfp(\"1e-16\")),     // rounding on add\n+             field.newDfp(\"1.0000000000000001\"), \n+             0, \"Add #5\");\n+\n+        test(field.newDfp(\"1\").add(field.newDfp(\"1e-17\")),     // rounding on add\n+             field.newDfp(\"1\"), \n+             DfpField.FLAG_INEXACT, \"Add #6\");\n+\n+        test(field.newDfp(\"0.90999999999999999999\").add(field.newDfp(\"0.1\")),     // rounding on add\n+             field.newDfp(\"1.01\"), \n+             DfpField.FLAG_INEXACT, \"Add #7\");\n+\n+        test(field.newDfp(\".10000000000000005000\").add(field.newDfp(\".9\")),     // rounding on add\n+             field.newDfp(\"1.\"), \n+             DfpField.FLAG_INEXACT, \"Add #8\");\n+\n+        test(field.newDfp(\".10000000000000015000\").add(field.newDfp(\".9\")),     // rounding on add\n+             field.newDfp(\"1.0000000000000002\"), \n+             DfpField.FLAG_INEXACT, \"Add #9\");\n+\n+        test(field.newDfp(\".10000000000000014999\").add(field.newDfp(\".9\")),     // rounding on add\n+             field.newDfp(\"1.0000000000000001\"), \n+             DfpField.FLAG_INEXACT, \"Add #10\");\n+\n+        test(field.newDfp(\".10000000000000015001\").add(field.newDfp(\".9\")),     // rounding on add\n+             field.newDfp(\"1.0000000000000002\"), \n+             DfpField.FLAG_INEXACT, \"Add #11\");\n+\n+        test(field.newDfp(\".11111111111111111111\").add(field.newDfp(\"11.1111111111111111\")), // rounding on add\n+             field.newDfp(\"11.22222222222222222222\"), \n+             DfpField.FLAG_INEXACT, \"Add #12\");\n+\n+        test(field.newDfp(\".11111111111111111111\").add(field.newDfp(\"1111111111111111.1111\")), // rounding on add\n+             field.newDfp(\"1111111111111111.2222\"), \n+             DfpField.FLAG_INEXACT, \"Add #13\");\n+\n+        test(field.newDfp(\".11111111111111111111\").add(field.newDfp(\"11111111111111111111\")), // rounding on add\n+             field.newDfp(\"11111111111111111111\"), \n+             DfpField.FLAG_INEXACT, \"Add #14\");\n+\n+        test(field.newDfp(\"9.9999999999999999999e131071\").add(field.newDfp(\"-1e131052\")), // overflow on add\n+             field.newDfp(\"9.9999999999999999998e131071\"), \n+             0, \"Add #15\");\n+\n+        test(field.newDfp(\"9.9999999999999999999e131071\").add(field.newDfp(\"1e131052\")), // overflow on add\n+             pinf, \n+             DfpField.FLAG_OVERFLOW, \"Add #16\");\n+\n+        test(field.newDfp(\"-9.9999999999999999999e131071\").add(field.newDfp(\"-1e131052\")), // overflow on add\n+             ninf, \n+             DfpField.FLAG_OVERFLOW, \"Add #17\");\n+\n+        test(field.newDfp(\"-9.9999999999999999999e131071\").add(field.newDfp(\"1e131052\")), // overflow on add\n+             field.newDfp(\"-9.9999999999999999998e131071\"), \n+             0, \"Add #18\");\n+\n+        test(field.newDfp(\"1e-131072\").add(field.newDfp(\"1e-131072\")), // underflow on add\n+             field.newDfp(\"2e-131072\"), \n+             0, \"Add #19\");\n+\n+        test(field.newDfp(\"1.0000000000000001e-131057\").add(field.newDfp(\"-1e-131057\")), // underflow on add\n+             field.newDfp(\"1e-131073\"), \n+             DfpField.FLAG_UNDERFLOW, \"Add #20\");\n+\n+        test(field.newDfp(\"1.1e-131072\").add(field.newDfp(\"-1e-131072\")), // underflow on add\n+             field.newDfp(\"1e-131073\"), \n+             DfpField.FLAG_UNDERFLOW, \"Add #21\");\n+\n+        test(field.newDfp(\"1.0000000000000001e-131072\").add(field.newDfp(\"-1e-131072\")), // underflow on add\n+             field.newDfp(\"1e-131088\"), \n+             DfpField.FLAG_UNDERFLOW, \"Add #22\");\n+\n+        test(field.newDfp(\"1.0000000000000001e-131078\").add(field.newDfp(\"-1e-131078\")), // underflow on add\n+             field.newDfp(\"0\"), \n+             DfpField.FLAG_UNDERFLOW, \"Add #23\");\n+\n+        test(field.newDfp(\"1.0\").add(field.newDfp(\"-1e-20\")), // loss of precision on alignment?\n+             field.newDfp(\"0.99999999999999999999\"), \n+             0, \"Add #23.1\");\n+\n+        test(field.newDfp(\"-0.99999999999999999999\").add(field.newDfp(\"1\")), // proper normalization?\n+             field.newDfp(\"0.00000000000000000001\"), \n+             0, \"Add #23.2\");\n+\n+        test(field.newDfp(\"1\").add(field.newDfp(\"0\")), // adding zeros\n+             field.newDfp(\"1\"), \n+             0, \"Add #24\");\n+\n+        test(field.newDfp(\"0\").add(field.newDfp(\"0\")), // adding zeros\n+             field.newDfp(\"0\"), \n+             0, \"Add #25\");\n+\n+        test(field.newDfp(\"-0\").add(field.newDfp(\"0\")), // adding zeros\n+             field.newDfp(\"0\"), \n+             0, \"Add #26\");\n+\n+        test(field.newDfp(\"0\").add(field.newDfp(\"-0\")), // adding zeros\n+             field.newDfp(\"0\"), \n+             0, \"Add #27\");\n+\n+        test(field.newDfp(\"-0\").add(field.newDfp(\"-0\")), // adding zeros\n+             field.newDfp(\"-0\"), \n+             0, \"Add #28\");\n+\n+        test(field.newDfp(\"1e-20\").add(field.newDfp(\"0\")), // adding zeros\n+             field.newDfp(\"1e-20\"), \n+             0, \"Add #29\");\n+\n+        test(field.newDfp(\"1e-40\").add(field.newDfp(\"0\")), // adding zeros\n+             field.newDfp(\"1e-40\"), \n+             0, \"Add #30\");\n+\n+        test(pinf.add(ninf), // adding infinities\n+             nan, \n+             DfpField.FLAG_INVALID, \"Add #31\");\n+\n+        test(ninf.add(pinf), // adding infinities\n+             nan, \n+             DfpField.FLAG_INVALID, \"Add #32\");\n+\n+        test(ninf.add(ninf), // adding infinities\n+             ninf, \n+             0, \"Add #33\");\n+\n+        test(pinf.add(pinf), // adding infinities\n+             pinf, \n+             0, \"Add #34\");\n+\n+        test(pinf.add(field.newDfp(\"0\")), // adding infinities\n+             pinf, \n+             0, \"Add #35\");\n+\n+        test(pinf.add(field.newDfp(\"-1e131071\")), // adding infinities\n+             pinf, \n+             0, \"Add #36\");\n+\n+        test(pinf.add(field.newDfp(\"1e131071\")), // adding infinities\n+             pinf, \n+             0, \"Add #37\");\n+\n+        test(field.newDfp(\"0\").add(pinf), // adding infinities\n+             pinf, \n+             0, \"Add #38\");\n+\n+        test(field.newDfp(\"-1e131071\").add(pinf), // adding infinities\n+             pinf, \n+             0, \"Add #39\");\n+\n+        test(field.newDfp(\"1e131071\").add(pinf), // adding infinities\n+             pinf, \n+             0, \"Add #40\");\n+\n+        test(ninf.add(field.newDfp(\"0\")), // adding infinities\n+             ninf, \n+             0, \"Add #41\");\n+\n+        test(ninf.add(field.newDfp(\"-1e131071\")), // adding infinities\n+             ninf, \n+             0, \"Add #42\");\n+\n+        test(ninf.add(field.newDfp(\"1e131071\")), // adding infinities\n+             ninf, \n+             0, \"Add #43\");\n+\n+        test(field.newDfp(\"0\").add(ninf), // adding infinities\n+             ninf, \n+             0, \"Add #44\");\n+\n+        test(field.newDfp(\"-1e131071\").add(ninf), // adding infinities\n+             ninf, \n+             0, \"Add #45\");\n+\n+        test(field.newDfp(\"1e131071\").add(ninf), // adding infinities\n+             ninf, \n+             0, \"Add #46\");\n+\n+        test(field.newDfp(\"9.9999999999999999999e131071\").add(field.newDfp(\"5e131051\")),  // overflow\n+             pinf,\n+             DfpField.FLAG_OVERFLOW, \"Add #47\");\n+\n+        test(field.newDfp(\"9.9999999999999999999e131071\").add(field.newDfp(\"4.9999999999999999999e131051\")),  // overflow\n+             field.newDfp(\"9.9999999999999999999e131071\"),\n+             DfpField.FLAG_INEXACT, \"Add #48\");\n+\n+        test(nan.add(field.newDfp(\"1\")),\n+             nan,\n+             0, \"Add #49\");\n+\n+        test(field.newDfp(\"1\").add(nan),\n+             nan,\n+             0, \"Add #50\");\n+\n+        test(field.newDfp(\"12345678123456781234\").add(field.newDfp(\"0.12345678123456781234\")),\n+             field.newDfp(\"12345678123456781234\"),\n+             DfpField.FLAG_INEXACT, \"Add #51\");\n+\n+        test(field.newDfp(\"12345678123456781234\").add(field.newDfp(\"123.45678123456781234\")),\n+             field.newDfp(\"12345678123456781357\"),\n+             DfpField.FLAG_INEXACT, \"Add #52\");\n+\n+        test(field.newDfp(\"123.45678123456781234\").add(field.newDfp(\"12345678123456781234\")),\n+             field.newDfp(\"12345678123456781357\"),\n+             DfpField.FLAG_INEXACT, \"Add #53\");\n+\n+        test(field.newDfp(\"12345678123456781234\").add(field.newDfp(\".00001234567812345678\")),\n+             field.newDfp(\"12345678123456781234\"),\n+             DfpField.FLAG_INEXACT, \"Add #54\");\n+\n+        test(field.newDfp(\"12345678123456781234\").add(field.newDfp(\".00000000123456781234\")),\n+             field.newDfp(\"12345678123456781234\"),\n+             DfpField.FLAG_INEXACT, \"Add #55\");\n+\n+        test(field.newDfp(\"-0\").add(field.newDfp(\"-0\")),\n+             field.newDfp(\"-0\"),\n+             0, \"Add #56\"); \n+\n+        test(field.newDfp(\"0\").add(field.newDfp(\"-0\")),\n+             field.newDfp(\"0\"),\n+             0, \"Add #57\"); \n+\n+        test(field.newDfp(\"-0\").add(field.newDfp(\"0\")),\n+             field.newDfp(\"0\"),\n+             0, \"Add #58\"); \n+\n+        test(field.newDfp(\"0\").add(field.newDfp(\"0\")),\n+             field.newDfp(\"0\"),\n+             0, \"Add #59\"); \n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // Test comparisons\n+\n+    // utility function to help test comparisons\n+    private void cmptst(Dfp a, Dfp b, String op, boolean result, double num)\n+    {\n+        if (op == \"equal\")\n+            if (a.equals(b) != result)\n+                Assert.fail(\"assersion failed.  \"+op+\" compare #\"+num);\n+\n+        if (op == \"unequal\")\n+            if (a.unequal(b) != result)\n+                Assert.fail(\"assersion failed.  \"+op+\" compare #\"+num);\n+\n+        if (op == \"lessThan\")\n+            if (a.lessThan(b) != result)\n+                Assert.fail(\"assersion failed.  \"+op+\" compare #\"+num);\n+\n+        if (op == \"greaterThan\")\n+            if (a.greaterThan(b) != result)\n+                Assert.fail(\"assersion failed.  \"+op+\" compare #\"+num);\n+    }\n+\n+    @Test\n+    public void  testCompare()\n+    {\n+        // test equal() comparison\n+        // check zero vs. zero\n+        field.clearIEEEFlags();\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"0\"), \"equal\", true, 1);         // 0 == 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-0\"), \"equal\", true, 2);        // 0 == -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"-0\"), \"equal\", true, 3);       // -0 == -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"0\"), \"equal\", true, 4);        // -0 == 0\n+\n+        // check zero vs normal numbers\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1\"), \"equal\", false, 5);         // 0 == 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"0\"), \"equal\", false, 6);         // 1 == 0\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"0\"), \"equal\", false, 7);        // -1 == 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-1\"), \"equal\", false, 8);        // 0 == -1\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131072\"), \"equal\", false, 9); // 0 == 1e-131072\n+        // check flags \n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131078\"), \"equal\", false, 10); // 0 == 1e-131078\n+\n+        // check flags  -- underflow should be set\n+        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        field.clearIEEEFlags();\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e+131071\"), \"equal\", false, 11); // 0 == 1e+131071\n+\n+        // check zero vs infinities\n+\n+        cmptst(field.newDfp(\"0\"), pinf, \"equal\", false, 12);    // 0 == pinf\n+        cmptst(field.newDfp(\"0\"), ninf, \"equal\", false, 13);    // 0 == ninf\n+        cmptst(field.newDfp(\"-0\"), pinf, \"equal\", false, 14);   // -0 == pinf\n+        cmptst(field.newDfp(\"-0\"), ninf, \"equal\", false, 15);   // -0 == ninf\n+        cmptst(pinf, field.newDfp(\"0\"), \"equal\", false, 16);    // pinf == 0\n+        cmptst(ninf, field.newDfp(\"0\"), \"equal\", false, 17);    // ninf == 0\n+        cmptst(pinf, field.newDfp(\"-0\"), \"equal\", false, 18);   // pinf == -0\n+        cmptst(ninf, field.newDfp(\"-0\"), \"equal\", false, 19);   // ninf == -0\n+        cmptst(ninf, pinf, \"equal\", false, 19.10);     // ninf == pinf\n+        cmptst(pinf, ninf, \"equal\", false, 19.11);     // pinf == ninf\n+        cmptst(pinf, pinf, \"equal\", true, 19.12);     // pinf == pinf\n+        cmptst(ninf, ninf, \"equal\", true, 19.13);     // ninf == ninf\n+\n+        // check some normal numbers\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1\"), \"equal\", true, 20);   // 1 == 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"-1\"), \"equal\", false, 21);   // 1 == -1\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"-1\"), \"equal\", true, 22);   // -1 == -1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1.0000000000000001\"), \"equal\", false, 23);   // 1 == 1.0000000000000001\n+\n+        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT\n+        // 100000 == 1.0000000000000001\n+        cmptst(field.newDfp(\"1e20\"), field.newDfp(\"1.0000000000000001\"), \"equal\", false, 24);\n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0.000001\"), field.newDfp(\"1e-6\"), \"equal\", true, 25);\n+\n+        // check some nans -- nans shouldnt equal anything\n+\n+        cmptst(snan, snan, \"equal\", false, 27);\n+        cmptst(qnan, qnan, \"equal\", false, 28);\n+        cmptst(snan, qnan, \"equal\", false, 29);\n+        cmptst(qnan, snan, \"equal\", false, 30);\n+        cmptst(qnan, field.newDfp(\"0\"), \"equal\", false, 31);\n+        cmptst(snan, field.newDfp(\"0\"), \"equal\", false, 32);\n+        cmptst(field.newDfp(\"0\"), snan, \"equal\", false, 33);\n+        cmptst(field.newDfp(\"0\"), qnan, \"equal\", false, 34);\n+        cmptst(qnan, pinf, \"equal\", false, 35);\n+        cmptst(snan, pinf, \"equal\", false, 36);\n+        cmptst(pinf, snan, \"equal\", false, 37);\n+        cmptst(pinf, qnan, \"equal\", false, 38);\n+        cmptst(qnan, ninf, \"equal\", false, 39);\n+        cmptst(snan, ninf, \"equal\", false, 40);\n+        cmptst(ninf, snan, \"equal\", false, 41);\n+        cmptst(ninf, qnan, \"equal\", false, 42);\n+        cmptst(qnan, field.newDfp(\"-1\"), \"equal\", false, 43);\n+        cmptst(snan, field.newDfp(\"-1\"), \"equal\", false, 44);\n+        cmptst(field.newDfp(\"-1\"), snan, \"equal\", false, 45);\n+        cmptst(field.newDfp(\"-1\"), qnan, \"equal\", false, 46);\n+        cmptst(qnan, field.newDfp(\"1\"), \"equal\", false, 47);\n+        cmptst(snan, field.newDfp(\"1\"), \"equal\", false, 48);\n+        cmptst(field.newDfp(\"1\"), snan, \"equal\", false, 49);\n+        cmptst(field.newDfp(\"1\"), qnan, \"equal\", false, 50);\n+        cmptst(snan.negate(), snan, \"equal\", false, 51);\n+        cmptst(qnan.negate(), qnan, \"equal\", false, 52);\n+\n+        //\n+        // Tests for un equal  -- do it all over again\n+        //\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"0\"), \"unequal\", false, 1);         // 0 == 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-0\"), \"unequal\", false, 2);        // 0 == -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"-0\"), \"unequal\", false, 3);       // -0 == -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"0\"), \"unequal\", false, 4);        // -0 == 0\n+\n+        // check zero vs normal numbers\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1\"), \"unequal\", true, 5);         // 0 == 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"0\"), \"unequal\", true, 6);         // 1 == 0\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"0\"), \"unequal\", true, 7);        // -1 == 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-1\"), \"unequal\", true, 8);        // 0 == -1\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131072\"), \"unequal\", true, 9); // 0 == 1e-131072\n+        // check flags \n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131078\"), \"unequal\", true, 10); // 0 == 1e-131078\n+\n+        // check flags  -- underflow should be set\n+        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        field.clearIEEEFlags();\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e+131071\"), \"unequal\", true, 11); // 0 == 1e+131071\n+\n+        // check zero vs infinities\n+\n+        cmptst(field.newDfp(\"0\"), pinf, \"unequal\", true, 12);    // 0 == pinf\n+        cmptst(field.newDfp(\"0\"), ninf, \"unequal\", true, 13);    // 0 == ninf\n+        cmptst(field.newDfp(\"-0\"), pinf, \"unequal\", true, 14);   // -0 == pinf\n+        cmptst(field.newDfp(\"-0\"), ninf, \"unequal\", true, 15);   // -0 == ninf\n+        cmptst(pinf, field.newDfp(\"0\"), \"unequal\", true, 16);    // pinf == 0\n+        cmptst(ninf, field.newDfp(\"0\"), \"unequal\", true, 17);    // ninf == 0\n+        cmptst(pinf, field.newDfp(\"-0\"), \"unequal\", true, 18);   // pinf == -0\n+        cmptst(ninf, field.newDfp(\"-0\"), \"unequal\", true, 19);   // ninf == -0\n+        cmptst(ninf, pinf, \"unequal\", true, 19.10);     // ninf == pinf\n+        cmptst(pinf, ninf, \"unequal\", true, 19.11);     // pinf == ninf\n+        cmptst(pinf, pinf, \"unequal\", false, 19.12);     // pinf == pinf\n+        cmptst(ninf, ninf, \"unequal\", false, 19.13);     // ninf == ninf\n+\n+        // check some normal numbers\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1\"), \"unequal\", false, 20);   // 1 == 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"-1\"), \"unequal\", true, 21);   // 1 == -1\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"-1\"), \"unequal\", false, 22);   // -1 == -1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1.0000000000000001\"), \"unequal\", true, 23);   // 1 == 1.0000000000000001\n+\n+        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT\n+        // 100000 == 1.0000000000000001\n+        cmptst(field.newDfp(\"1e20\"), field.newDfp(\"1.0000000000000001\"), \"unequal\", true, 24);\n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0.000001\"), field.newDfp(\"1e-6\"), \"unequal\", false, 25);\n+\n+        // check some nans -- nans shouldnt be unequal to anything\n+\n+        cmptst(snan, snan, \"unequal\", false, 27);\n+        cmptst(qnan, qnan, \"unequal\", false, 28);\n+        cmptst(snan, qnan, \"unequal\", false, 29);\n+        cmptst(qnan, snan, \"unequal\", false, 30);\n+        cmptst(qnan, field.newDfp(\"0\"), \"unequal\", false, 31);\n+        cmptst(snan, field.newDfp(\"0\"), \"unequal\", false, 32);\n+        cmptst(field.newDfp(\"0\"), snan, \"unequal\", false, 33);\n+        cmptst(field.newDfp(\"0\"), qnan, \"unequal\", false, 34);\n+        cmptst(qnan, pinf, \"unequal\", false, 35);\n+        cmptst(snan, pinf, \"unequal\", false, 36);\n+        cmptst(pinf, snan, \"unequal\", false, 37);\n+        cmptst(pinf, qnan, \"unequal\", false, 38);\n+        cmptst(qnan, ninf, \"unequal\", false, 39);\n+        cmptst(snan, ninf, \"unequal\", false, 40);\n+        cmptst(ninf, snan, \"unequal\", false, 41);\n+        cmptst(ninf, qnan, \"unequal\", false, 42);\n+        cmptst(qnan, field.newDfp(\"-1\"), \"unequal\", false, 43);\n+        cmptst(snan, field.newDfp(\"-1\"), \"unequal\", false, 44);\n+        cmptst(field.newDfp(\"-1\"), snan, \"unequal\", false, 45);\n+        cmptst(field.newDfp(\"-1\"), qnan, \"unequal\", false, 46);\n+        cmptst(qnan, field.newDfp(\"1\"), \"unequal\", false, 47);\n+        cmptst(snan, field.newDfp(\"1\"), \"unequal\", false, 48);\n+        cmptst(field.newDfp(\"1\"), snan, \"unequal\", false, 49);\n+        cmptst(field.newDfp(\"1\"), qnan, \"unequal\", false, 50);\n+        cmptst(snan.negate(), snan, \"unequal\", false, 51);\n+        cmptst(qnan.negate(), qnan, \"unequal\", false, 52);\n+\n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare unequal flags = \"+field.getIEEEFlags());\n+\n+        //\n+        // Tests for lessThan  -- do it all over again\n+        //\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"0\"), \"lessThan\", false, 1);         // 0 < 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-0\"), \"lessThan\", false, 2);        // 0 < -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"-0\"), \"lessThan\", false, 3);       // -0 < -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"0\"), \"lessThan\", false, 4);        // -0 < 0\n+\n+        // check zero vs normal numbers\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1\"), \"lessThan\", true, 5);         // 0 < 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"0\"), \"lessThan\", false, 6);         // 1 < 0\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"0\"), \"lessThan\", true, 7);        // -1 < 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-1\"), \"lessThan\", false, 8);        // 0 < -1\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131072\"), \"lessThan\", true, 9); // 0 < 1e-131072\n+        // check flags \n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131078\"), \"lessThan\", true, 10); // 0 < 1e-131078\n+\n+        // check flags  -- underflow should be set\n+        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+        field.clearIEEEFlags();\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e+131071\"), \"lessThan\", true, 11); // 0 < 1e+131071\n+\n+        // check zero vs infinities\n+\n+        cmptst(field.newDfp(\"0\"), pinf, \"lessThan\", true, 12);    // 0 < pinf\n+        cmptst(field.newDfp(\"0\"), ninf, \"lessThan\", false, 13);    // 0 < ninf\n+        cmptst(field.newDfp(\"-0\"), pinf, \"lessThan\", true, 14);   // -0 < pinf\n+        cmptst(field.newDfp(\"-0\"), ninf, \"lessThan\", false, 15);   // -0 < ninf\n+        cmptst(pinf, field.newDfp(\"0\"), \"lessThan\", false, 16);    // pinf < 0\n+        cmptst(ninf, field.newDfp(\"0\"), \"lessThan\", true, 17);    // ninf < 0\n+        cmptst(pinf, field.newDfp(\"-0\"), \"lessThan\", false, 18);   // pinf < -0\n+        cmptst(ninf, field.newDfp(\"-0\"), \"lessThan\", true, 19);   // ninf < -0\n+        cmptst(ninf, pinf, \"lessThan\", true, 19.10);     // ninf < pinf\n+        cmptst(pinf, ninf, \"lessThan\", false, 19.11);     // pinf < ninf\n+        cmptst(pinf, pinf, \"lessThan\", false, 19.12);     // pinf < pinf\n+        cmptst(ninf, ninf, \"lessThan\", false, 19.13);     // ninf < ninf\n+\n+        // check some normal numbers\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1\"), \"lessThan\", false, 20);   // 1 < 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"-1\"), \"lessThan\", false, 21);   // 1 < -1\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"-1\"), \"lessThan\", false, 22);   // -1 < -1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1.0000000000000001\"), \"lessThan\", true, 23);   // 1 < 1.0000000000000001\n+\n+        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT\n+        // 100000 < 1.0000000000000001\n+        cmptst(field.newDfp(\"1e20\"), field.newDfp(\"1.0000000000000001\"), \"lessThan\", false, 24);\n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0.000001\"), field.newDfp(\"1e-6\"), \"lessThan\", false, 25);\n+\n+        // check some nans -- nans shouldnt be lessThan to anything\n+        cmptst(snan, snan, \"lessThan\", false, 27);\n+        cmptst(qnan, qnan, \"lessThan\", false, 28);\n+        cmptst(snan, qnan, \"lessThan\", false, 29);\n+        cmptst(qnan, snan, \"lessThan\", false, 30);\n+        cmptst(qnan, field.newDfp(\"0\"), \"lessThan\", false, 31);\n+        cmptst(snan, field.newDfp(\"0\"), \"lessThan\", false, 32);\n+        cmptst(field.newDfp(\"0\"), snan, \"lessThan\", false, 33);\n+        cmptst(field.newDfp(\"0\"), qnan, \"lessThan\", false, 34);\n+        cmptst(qnan, pinf, \"lessThan\", false, 35);\n+        cmptst(snan, pinf, \"lessThan\", false, 36);\n+        cmptst(pinf, snan, \"lessThan\", false, 37);\n+        cmptst(pinf, qnan, \"lessThan\", false, 38);\n+        cmptst(qnan, ninf, \"lessThan\", false, 39);\n+        cmptst(snan, ninf, \"lessThan\", false, 40);\n+        cmptst(ninf, snan, \"lessThan\", false, 41);\n+        cmptst(ninf, qnan, \"lessThan\", false, 42);\n+        cmptst(qnan, field.newDfp(\"-1\"), \"lessThan\", false, 43);\n+        cmptst(snan, field.newDfp(\"-1\"), \"lessThan\", false, 44);\n+        cmptst(field.newDfp(\"-1\"), snan, \"lessThan\", false, 45);\n+        cmptst(field.newDfp(\"-1\"), qnan, \"lessThan\", false, 46);\n+        cmptst(qnan, field.newDfp(\"1\"), \"lessThan\", false, 47);\n+        cmptst(snan, field.newDfp(\"1\"), \"lessThan\", false, 48);\n+        cmptst(field.newDfp(\"1\"), snan, \"lessThan\", false, 49);\n+        cmptst(field.newDfp(\"1\"), qnan, \"lessThan\", false, 50);\n+        cmptst(snan.negate(), snan, \"lessThan\", false, 51);\n+        cmptst(qnan.negate(), qnan, \"lessThan\", false, 52);\n+\n+        //lessThan compares with nans should raise FLAG_INVALID\n+        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)\n+            Assert.fail(\"assersion failed.  compare lessThan flags = \"+field.getIEEEFlags());\n+        field.clearIEEEFlags();\n+\n+        //\n+        // Tests for greaterThan  -- do it all over again\n+        //\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"0\"), \"greaterThan\", false, 1);         // 0 > 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-0\"), \"greaterThan\", false, 2);        // 0 > -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"-0\"), \"greaterThan\", false, 3);       // -0 > -0\n+        cmptst(field.newDfp(\"-0\"), field.newDfp(\"0\"), \"greaterThan\", false, 4);        // -0 > 0\n+\n+        // check zero vs normal numbers\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1\"), \"greaterThan\", false, 5);         // 0 > 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"0\"), \"greaterThan\", true, 6);         // 1 > 0\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"0\"), \"greaterThan\", false, 7);        // -1 > 0\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"-1\"), \"greaterThan\", true, 8);        // 0 > -1\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131072\"), \"greaterThan\", false, 9); // 0 > 1e-131072\n+        // check flags \n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e-131078\"), \"greaterThan\", false, 10); // 0 > 1e-131078\n+\n+        // check flags  -- underflow should be set\n+        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+        field.clearIEEEFlags();\n+\n+        cmptst(field.newDfp(\"0\"), field.newDfp(\"1e+131071\"), \"greaterThan\", false, 11); // 0 > 1e+131071\n+\n+        // check zero vs infinities\n+\n+        cmptst(field.newDfp(\"0\"), pinf, \"greaterThan\", false, 12);    // 0 > pinf\n+        cmptst(field.newDfp(\"0\"), ninf, \"greaterThan\", true, 13);    // 0 > ninf\n+        cmptst(field.newDfp(\"-0\"), pinf, \"greaterThan\", false, 14);   // -0 > pinf\n+        cmptst(field.newDfp(\"-0\"), ninf, \"greaterThan\", true, 15);   // -0 > ninf\n+        cmptst(pinf, field.newDfp(\"0\"), \"greaterThan\", true, 16);    // pinf > 0\n+        cmptst(ninf, field.newDfp(\"0\"), \"greaterThan\", false, 17);    // ninf > 0\n+        cmptst(pinf, field.newDfp(\"-0\"), \"greaterThan\", true, 18);   // pinf > -0\n+        cmptst(ninf, field.newDfp(\"-0\"), \"greaterThan\", false, 19);   // ninf > -0\n+        cmptst(ninf, pinf, \"greaterThan\", false, 19.10);     // ninf > pinf\n+        cmptst(pinf, ninf, \"greaterThan\", true, 19.11);     // pinf > ninf\n+        cmptst(pinf, pinf, \"greaterThan\", false, 19.12);     // pinf > pinf\n+        cmptst(ninf, ninf, \"greaterThan\", false, 19.13);     // ninf > ninf\n+\n+        // check some normal numbers\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1\"), \"greaterThan\", false, 20);   // 1 > 1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"-1\"), \"greaterThan\", true, 21);   // 1 > -1\n+        cmptst(field.newDfp(\"-1\"), field.newDfp(\"-1\"), \"greaterThan\", false, 22);   // -1 > -1\n+        cmptst(field.newDfp(\"1\"), field.newDfp(\"1.0000000000000001\"), \"greaterThan\", false, 23);   // 1 > 1.0000000000000001\n+\n+        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT\n+        // 100000 > 1.0000000000000001\n+        cmptst(field.newDfp(\"1e20\"), field.newDfp(\"1.0000000000000001\"), \"greaterThan\", true, 24);\n+        if (field.getIEEEFlags() != 0)\n+            Assert.fail(\"assersion failed.  compare flags = \"+field.getIEEEFlags());\n+\n+        cmptst(field.newDfp(\"0.000001\"), field.newDfp(\"1e-6\"), \"greaterThan\", false, 25);\n+\n+        // check some nans -- nans shouldnt be greaterThan to anything\n+        cmptst(snan, snan, \"greaterThan\", false, 27);\n+        cmptst(qnan, qnan, \"greaterThan\", false, 28);\n+        cmptst(snan, qnan, \"greaterThan\", false, 29);\n+        cmptst(qnan, snan, \"greaterThan\", false, 30);\n+        cmptst(qnan, field.newDfp(\"0\"), \"greaterThan\", false, 31);\n+        cmptst(snan, field.newDfp(\"0\"), \"greaterThan\", false, 32);\n+        cmptst(field.newDfp(\"0\"), snan, \"greaterThan\", false, 33);\n+        cmptst(field.newDfp(\"0\"), qnan, \"greaterThan\", false, 34);\n+        cmptst(qnan, pinf, \"greaterThan\", false, 35);\n+        cmptst(snan, pinf, \"greaterThan\", false, 36);\n+        cmptst(pinf, snan, \"greaterThan\", false, 37);\n+        cmptst(pinf, qnan, \"greaterThan\", false, 38);\n+        cmptst(qnan, ninf, \"greaterThan\", false, 39);\n+        cmptst(snan, ninf, \"greaterThan\", false, 40);\n+        cmptst(ninf, snan, \"greaterThan\", false, 41);\n+        cmptst(ninf, qnan, \"greaterThan\", false, 42);\n+        cmptst(qnan, field.newDfp(\"-1\"), \"greaterThan\", false, 43);\n+        cmptst(snan, field.newDfp(\"-1\"), \"greaterThan\", false, 44);\n+        cmptst(field.newDfp(\"-1\"), snan, \"greaterThan\", false, 45);\n+        cmptst(field.newDfp(\"-1\"), qnan, \"greaterThan\", false, 46);\n+        cmptst(qnan, field.newDfp(\"1\"), \"greaterThan\", false, 47);\n+        cmptst(snan, field.newDfp(\"1\"), \"greaterThan\", false, 48);\n+        cmptst(field.newDfp(\"1\"), snan, \"greaterThan\", false, 49);\n+        cmptst(field.newDfp(\"1\"), qnan, \"greaterThan\", false, 50);\n+        cmptst(snan.negate(), snan, \"greaterThan\", false, 51);\n+        cmptst(qnan.negate(), qnan, \"greaterThan\", false, 52);\n+\n+        //greaterThan compares with nans should raise FLAG_INVALID\n+        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)\n+            Assert.fail(\"assersion failed.  compare greaterThan flags = \"+field.getIEEEFlags());\n+        field.clearIEEEFlags();\n+    }\n+\n+    //\n+    // Test multiplication\n+    //\n+    @Test\n+    public void testMultiply()\n+    {\n+        test(field.newDfp(\"1\").multiply(field.newDfp(\"1\")),      // Basic tests   1*1 = 1\n+             field.newDfp(\"1\"), \n+             0, \"Multiply #1\");\n+\n+        test(field.newDfp(\"1\").multiply(1),             // Basic tests   1*1 = 1\n+             field.newDfp(\"1\"), \n+             0, \"Multiply #2\");\n+\n+        test(field.newDfp(\"-1\").multiply(field.newDfp(\"1\")),     // Basic tests   -1*1 = -1\n+             field.newDfp(\"-1\"), \n+             0, \"Multiply #3\");\n+\n+        test(field.newDfp(\"-1\").multiply(1),            // Basic tests   -1*1 = -1\n+             field.newDfp(\"-1\"), \n+             0, \"Multiply #4\");\n+\n+        // basic tests with integers\n+        test(field.newDfp(\"2\").multiply(field.newDfp(\"3\")),\n+             field.newDfp(\"6\"), \n+             0, \"Multiply #5\");\n+\n+        test(field.newDfp(\"2\").multiply(3),\n+             field.newDfp(\"6\"), \n+             0, \"Multiply #6\");\n+\n+        test(field.newDfp(\"-2\").multiply(field.newDfp(\"3\")),\n+             field.newDfp(\"-6\"), \n+             0, \"Multiply #7\");\n+\n+        test(field.newDfp(\"-2\").multiply(3),\n+             field.newDfp(\"-6\"), \n+             0, \"Multiply #8\");\n+\n+        test(field.newDfp(\"2\").multiply(field.newDfp(\"-3\")),\n+             field.newDfp(\"-6\"), \n+             0, \"Multiply #9\");\n+\n+        test(field.newDfp(\"-2\").multiply(field.newDfp(\"-3\")),\n+             field.newDfp(\"6\"), \n+             0, \"Multiply #10\");\n+\n+        //multiply by zero\n+\n+        test(field.newDfp(\"-2\").multiply(field.newDfp(\"0\")),\n+             field.newDfp(\"-0\"), \n+             0, \"Multiply #11\");\n+\n+        test(field.newDfp(\"-2\").multiply(0),\n+             field.newDfp(\"-0\"), \n+             0, \"Multiply #12\");\n+\n+        test(field.newDfp(\"2\").multiply(field.newDfp(\"0\")),\n+             field.newDfp(\"0\"), \n+             0, \"Multiply #13\");\n+\n+        test(field.newDfp(\"2\").multiply(0),\n+             field.newDfp(\"0\"), \n+             0, \"Multiply #14\");\n+\n+        test(field.newDfp(\"2\").multiply(pinf),\n+             pinf,\n+             0, \"Multiply #15\");\n+\n+        test(field.newDfp(\"2\").multiply(ninf),\n+             ninf,\n+             0, \"Multiply #16\");\n+\n+        test(field.newDfp(\"-2\").multiply(pinf),\n+             ninf,\n+             0, \"Multiply #17\");\n+\n+        test(field.newDfp(\"-2\").multiply(ninf),\n+             pinf,\n+             0, \"Multiply #18\");\n+\n+        test(ninf.multiply(field.newDfp(\"-2\")),\n+             pinf,\n+             0, \"Multiply #18.1\");\n+\n+        test(field.newDfp(\"5e131071\").multiply(2),\n+             pinf,\n+             DfpField.FLAG_OVERFLOW, \"Multiply #19\");        \n+\n+        test(field.newDfp(\"5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n+             field.newDfp(\"9.9999999999999950000e131071\"),\n+             0, \"Multiply #20\");        \n+\n+        test(field.newDfp(\"-5e131071\").multiply(2),\n+             ninf,\n+             DfpField.FLAG_OVERFLOW, \"Multiply #22\");        \n+\n+        test(field.newDfp(\"-5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n+             field.newDfp(\"-9.9999999999999950000e131071\"),\n+             0, \"Multiply #23\");        \n+\n+        test(field.newDfp(\"1e-65539\").multiply(field.newDfp(\"1e-65539\")),\n+             field.newDfp(\"1e-131078\"),\n+             DfpField.FLAG_UNDERFLOW, \"Multiply #24\");\n+\n+        test(field.newDfp(\"1\").multiply(nan),\n+             nan,\n+             0, \"Multiply #25\");\n+\n+        test(nan.multiply(field.newDfp(\"1\")),\n+             nan,\n+             0, \"Multiply #26\");\n+\n+        test(nan.multiply(pinf),\n+             nan,\n+             0, \"Multiply #27\");\n+\n+        test(pinf.multiply(nan),\n+             nan,\n+             0, \"Multiply #27\");\n+\n+        test(pinf.multiply(field.newDfp(\"0\")),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Multiply #28\");\n+\n+        test(field.newDfp(\"0\").multiply(pinf),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Multiply #29\");\n+\n+        test(pinf.multiply(pinf),\n+             pinf,\n+             0, \"Multiply #30\");\n+\n+        test(ninf.multiply(pinf),\n+             ninf,\n+             0, \"Multiply #31\");\n+\n+        test(pinf.multiply(ninf),\n+             ninf,\n+             0, \"Multiply #32\");\n+\n+        test(ninf.multiply(ninf),\n+             pinf,\n+             0, \"Multiply #33\");\n+\n+        test(pinf.multiply(1),\n+             pinf,\n+             0, \"Multiply #34\");\n+\n+        test(pinf.multiply(0),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Multiply #35\");\n+\n+        test(nan.multiply(1),\n+             nan,\n+             0, \"Multiply #36\");\n+\n+        test(field.newDfp(\"1\").multiply(10000),  // out of range\n+             nan,\n+             DfpField.FLAG_INVALID, \"Multiply #37\");\n+\n+        test(field.newDfp(\"1\").multiply(-1),  // out of range\n+             nan,\n+             DfpField.FLAG_INVALID, \"Multiply #38\");\n+    }\n+\n+    @Test\n+    public void testDivide()\n+    {\n+        test(field.newDfp(\"1\").divide(nan),      // divide by NaN = NaN\n+             nan, \n+             0, \"Divide #1\");\n+\n+        test(nan.divide(field.newDfp(\"1\")),      // NaN / number = NaN\n+             nan, \n+             0, \"Divide #2\");\n+\n+        test(pinf.divide(field.newDfp(\"1\")),\n+             pinf,\n+             0, \"Divide #3\");\n+\n+        test(pinf.divide(field.newDfp(\"-1\")),\n+             ninf,\n+             0, \"Divide #4\");\n+\n+        test(pinf.divide(pinf),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Divide #5\");\n+\n+        test(ninf.divide(pinf),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Divide #6\");\n+\n+        test(pinf.divide(ninf),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Divide #7\");\n+\n+        test(ninf.divide(ninf),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Divide #8\");\n+\n+        test(field.newDfp(\"0\").divide(field.newDfp(\"0\")),\n+             nan,\n+             DfpField.FLAG_DIV_ZERO, \"Divide #9\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"0\")),\n+             pinf,\n+             DfpField.FLAG_DIV_ZERO, \"Divide #10\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"-0\")),\n+             ninf,\n+             DfpField.FLAG_DIV_ZERO, \"Divide #11\");\n+\n+        test(field.newDfp(\"-1\").divide(field.newDfp(\"0\")),\n+             ninf,\n+             DfpField.FLAG_DIV_ZERO, \"Divide #12\");\n+\n+        test(field.newDfp(\"-1\").divide(field.newDfp(\"-0\")),\n+             pinf,\n+             DfpField.FLAG_DIV_ZERO, \"Divide #13\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"3\")),\n+             field.newDfp(\"0.33333333333333333333\"),\n+             DfpField.FLAG_INEXACT, \"Divide #14\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"6\")),\n+             field.newDfp(\"0.16666666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"Divide #15\");\n+\n+        test(field.newDfp(\"10\").divide(field.newDfp(\"6\")),\n+             field.newDfp(\"1.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"Divide #16\");\n+\n+        test(field.newDfp(\"100\").divide(field.newDfp(\"6\")),\n+             field.newDfp(\"16.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"Divide #17\");\n+\n+        test(field.newDfp(\"1000\").divide(field.newDfp(\"6\")),\n+             field.newDfp(\"166.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"Divide #18\");\n+\n+        test(field.newDfp(\"10000\").divide(field.newDfp(\"6\")),\n+             field.newDfp(\"1666.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"Divide #19\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"1\")),\n+             field.newDfp(\"1\"),\n+             0, \"Divide #20\");\n+\n+        test(field.newDfp(\"1\").divide(field.newDfp(\"-1\")),\n+             field.newDfp(\"-1\"),\n+             0, \"Divide #21\");\n+\n+        test(field.newDfp(\"-1\").divide(field.newDfp(\"1\")),\n+             field.newDfp(\"-1\"),\n+             0, \"Divide #22\");\n+\n+        test(field.newDfp(\"-1\").divide(field.newDfp(\"-1\")),\n+             field.newDfp(\"1\"),\n+             0, \"Divide #23\");\n+\n+        test(field.newDfp(\"1e-65539\").divide(field.newDfp(\"1e65539\")),\n+             field.newDfp(\"1e-131078\"),\n+             DfpField.FLAG_UNDERFLOW, \"Divide #24\");\n+\n+        test(field.newDfp(\"1e65539\").divide(field.newDfp(\"1e-65539\")),\n+             pinf,\n+             DfpField.FLAG_OVERFLOW, \"Divide #24\");\n+\n+        test(field.newDfp(\"2\").divide(field.newDfp(\"1.5\")),     // test trial-divisor too high\n+             field.newDfp(\"1.3333333333333333\"),\n+             DfpField.FLAG_INEXACT, \"Divide #25\");\n+\n+        test(field.newDfp(\"2\").divide(pinf),\n+             field.newDfp(\"0\"),\n+             0, \"Divide #26\");\n+\n+        test(field.newDfp(\"2\").divide(ninf),\n+             field.newDfp(\"-0\"),\n+             0, \"Divide #27\");\n+\n+        test(field.newDfp(\"0\").divide(field.newDfp(\"1\")),\n+             field.newDfp(\"0\"),\n+             0, \"Divide #28\");\n+    }\n+\n+    @Test\n+    public void testDivideInt()\n+    {\n+        test(nan.divide(1),      // NaN / number = NaN\n+             nan, \n+             0, \"DivideInt #1\");\n+\n+        test(pinf.divide(1),\n+             pinf,\n+             0, \"DivideInt #2\");\n+\n+        test(field.newDfp(\"0\").divide(0),\n+             nan,\n+             DfpField.FLAG_DIV_ZERO, \"DivideInt #3\");\n+\n+        test(field.newDfp(\"1\").divide(0),\n+             pinf,\n+             DfpField.FLAG_DIV_ZERO, \"DivideInt #4\");\n+\n+        test(field.newDfp(\"-1\").divide(0),\n+             ninf,\n+             DfpField.FLAG_DIV_ZERO, \"DivideInt #5\");\n+\n+        test(field.newDfp(\"1\").divide(3),\n+             field.newDfp(\"0.33333333333333333333\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #6\");\n+\n+        test(field.newDfp(\"1\").divide(6),\n+             field.newDfp(\"0.16666666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #7\");\n+\n+        test(field.newDfp(\"10\").divide(6),\n+             field.newDfp(\"1.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #8\");\n+\n+        test(field.newDfp(\"100\").divide(6),\n+             field.newDfp(\"16.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #9\");\n+\n+        test(field.newDfp(\"1000\").divide(6),\n+             field.newDfp(\"166.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #10\");\n+\n+        test(field.newDfp(\"10000\").divide(6),\n+             field.newDfp(\"1666.6666666666666667\"),\n+             DfpField.FLAG_INEXACT, \"DivideInt #20\");\n+\n+        test(field.newDfp(\"1\").divide(1),\n+             field.newDfp(\"1\"),\n+             0, \"DivideInt #21\");\n+\n+        test(field.newDfp(\"1e-131077\").divide(10),\n+             field.newDfp(\"1e-131078\"),\n+             DfpField.FLAG_UNDERFLOW, \"DivideInt #22\");\n+\n+        test(field.newDfp(\"0\").divide(1),\n+             field.newDfp(\"0\"),\n+             0, \"DivideInt #23\");\n+\n+        test(field.newDfp(\"1\").divide(10000),\n+             nan,\n+             DfpField.FLAG_INVALID, \"DivideInt #24\");\n+\n+        test(field.newDfp(\"1\").divide(-1),\n+             nan,\n+             DfpField.FLAG_INVALID, \"DivideInt #25\");\n+    }\n+\n+    @Test\n+    public void testNextAfter()\n+    {\n+        test(field.newDfp(\"1\").nextAfter(pinf),\n+             field.newDfp(\"1.0000000000000001\"),\n+             0, \"NextAfter #1\");\n+\n+        test(field.newDfp(\"1.0000000000000001\").nextAfter(ninf),\n+             field.newDfp(\"1\"),\n+             0, \"NextAfter #1.5\");\n+\n+        test(field.newDfp(\"1\").nextAfter(ninf),\n+             field.newDfp(\"0.99999999999999999999\"),\n+             0, \"NextAfter #2\");\n+\n+        test(field.newDfp(\"0.99999999999999999999\").nextAfter(field.newDfp(\"2\")),\n+             field.newDfp(\"1\"),\n+             0, \"NextAfter #3\");\n+\n+        test(field.newDfp(\"-1\").nextAfter(ninf),\n+             field.newDfp(\"-1.0000000000000001\"),\n+             0, \"NextAfter #4\");\n+\n+        test(field.newDfp(\"-1\").nextAfter(pinf),\n+             field.newDfp(\"-0.99999999999999999999\"),\n+             0, \"NextAfter #5\");\n+\n+        test(field.newDfp(\"-0.99999999999999999999\").nextAfter(field.newDfp(\"-2\")),\n+             field.newDfp(\"-1\"),\n+             0, \"NextAfter #6\");\n+\n+        test(field.newDfp(\"2\").nextAfter(field.newDfp(\"2\")),\n+             field.newDfp(\"2\"),\n+             0, \"NextAfter #7\");\n+\n+        test(field.newDfp(\"0\").nextAfter(field.newDfp(\"0\")),\n+             field.newDfp(\"0\"),\n+             0, \"NextAfter #8\");\n+\n+        test(field.newDfp(\"-2\").nextAfter(field.newDfp(\"-2\")),\n+             field.newDfp(\"-2\"),\n+             0, \"NextAfter #9\");\n+\n+        test(field.newDfp(\"0\").nextAfter(field.newDfp(\"1\")),\n+             field.newDfp(\"1e-131092\"),\n+             DfpField.FLAG_UNDERFLOW, \"NextAfter #10\");\n+\n+        test(field.newDfp(\"0\").nextAfter(field.newDfp(\"-1\")),\n+             field.newDfp(\"-1e-131092\"),\n+             DfpField.FLAG_UNDERFLOW, \"NextAfter #11\");\n+\n+        test(field.newDfp(\"-1e-131092\").nextAfter(pinf),\n+             field.newDfp(\"-0\"),\n+             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, \"Next After #12\");\n+\n+        test(field.newDfp(\"1e-131092\").nextAfter(ninf), \n+             field.newDfp(\"0\"),\n+             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, \"Next After #13\");\n+\n+        test(field.newDfp(\"9.9999999999999999999e131078\").nextAfter(pinf),\n+             pinf,\n+             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, \"Next After #14\");\n+    }\n+\n+    @Test\n+    public void testToString()\n+    {\n+        Assert.assertEquals(\"toString #1\", \"Infinity\", pinf.toString());\n+        Assert.assertEquals(\"toString #2\", \"-Infinity\", ninf.toString());\n+        Assert.assertEquals(\"toString #3\", \"NaN\", nan.toString());\n+        Assert.assertEquals(\"toString #4\", \"NaN\", field.newDfp((byte) 1, (byte) Dfp.QNAN).toString());\n+        Assert.assertEquals(\"toString #5\", \"NaN\", field.newDfp((byte) 1, (byte) Dfp.SNAN).toString());\n+        Assert.assertEquals(\"toString #6\", \"1.2300000000000000e100\", field.newDfp(\"1.23e100\").toString());\n+        Assert.assertEquals(\"toString #7\", \"-1.2300000000000000e100\", field.newDfp(\"-1.23e100\").toString());\n+        Assert.assertEquals(\"toString #8\", \"12345678.1234\", field.newDfp(\"12345678.1234\").toString());\n+        Assert.assertEquals(\"toString #9\", \"0.00001234\", field.newDfp(\"0.00001234\").toString());\n+    }\n+\n+    @Test\n+    public void testRound()\n+    {\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);\n+\n+        // Round down\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.9\")),\n+             field.newDfp(\"12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #1\");\n+\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.99999999\")),\n+             field.newDfp(\"12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #2\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.99999999\")),\n+             field.newDfp(\"-12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #3\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);\n+\n+        // Round up\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.1\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #4\");\n+\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.0001\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #5\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.1\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #6\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.0001\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #7\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);\n+\n+        // Round half up\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.4999\")),\n+             field.newDfp(\"12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #8\");\n+\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.5000\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #9\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.4999\")),\n+             field.newDfp(\"-12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #10\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.5000\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #11\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);\n+\n+        // Round half down\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.5001\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #12\");\n+\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.5000\")),\n+             field.newDfp(\"12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #13\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.5001\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #14\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.5000\")),\n+             field.newDfp(\"-12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #15\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);\n+\n+        // Round half odd\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.5000\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #16\");\n+\n+        test(field.newDfp(\"12345678901234567891\").add(field.newDfp(\"0.5000\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #17\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.5000\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #18\");\n+\n+        test(field.newDfp(\"-12345678901234567891\").add(field.newDfp(\"-0.5000\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #19\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);\n+\n+        // Round ceil\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.0001\")),\n+             field.newDfp(\"12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #20\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.9999\")),\n+             field.newDfp(\"-12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #21\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);\n+\n+        // Round floor\n+        test(field.newDfp(\"12345678901234567890\").add(field.newDfp(\"0.9999\")),\n+             field.newDfp(\"12345678901234567890\"),\n+             DfpField.FLAG_INEXACT, \"Round #22\");\n+\n+        test(field.newDfp(\"-12345678901234567890\").add(field.newDfp(\"-0.0001\")),\n+             field.newDfp(\"-12345678901234567891\"),\n+             DfpField.FLAG_INEXACT, \"Round #23\");\n+\n+        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset\n+    }\n+\n+    @Test\n+    public void testCeil()\n+    {\n+        test(field.newDfp(\"1234.0000000000000001\").ceil(),\n+             field.newDfp(\"1235\"),\n+             DfpField.FLAG_INEXACT, \"Ceil #1\");\n+    }\n+\n+    @Test\n+    public void testFloor()\n+    {\n+        test(field.newDfp(\"1234.9999999999999999\").floor(),\n+             field.newDfp(\"1234\"),\n+             DfpField.FLAG_INEXACT, \"Floor #1\");\n+    }\n+\n+    @Test\n+    public void testRint()\n+    {\n+        test(field.newDfp(\"1234.50000000001\").rint(),\n+             field.newDfp(\"1235\"),\n+             DfpField.FLAG_INEXACT, \"Rint #1\");\n+\n+        test(field.newDfp(\"1234.5000\").rint(),\n+             field.newDfp(\"1234\"),\n+             DfpField.FLAG_INEXACT, \"Rint #2\");\n+\n+        test(field.newDfp(\"1235.5000\").rint(),\n+             field.newDfp(\"1236\"),\n+             DfpField.FLAG_INEXACT, \"Rint #3\");\n+    }\n+\n+    @Test\n+    public void testCopySign()\n+    {\n+        test(Dfp.copysign(field.newDfp(\"1234.\"), field.newDfp(\"-1\")),\n+             field.newDfp(\"-1234\"),\n+             0, \"CopySign #1\");\n+\n+        test(Dfp.copysign(field.newDfp(\"-1234.\"), field.newDfp(\"-1\")),\n+             field.newDfp(\"-1234\"),\n+             0, \"CopySign #2\");\n+\n+        test(Dfp.copysign(field.newDfp(\"-1234.\"), field.newDfp(\"1\")),\n+             field.newDfp(\"1234\"),\n+             0, \"CopySign #3\");\n+\n+        test(Dfp.copysign(field.newDfp(\"1234.\"), field.newDfp(\"1\")),\n+             field.newDfp(\"1234\"),\n+             0, \"CopySign #4\");\n+    }\n+\n+    @Test\n+    public void testIntValue()\n+    {\n+        Assert.assertEquals(\"intValue #1\", 1234, field.newDfp(\"1234\").intValue());\n+        Assert.assertEquals(\"intValue #2\", -1234, field.newDfp(\"-1234\").intValue());\n+        Assert.assertEquals(\"intValue #3\", 1234, field.newDfp(\"1234.5\").intValue());\n+        Assert.assertEquals(\"intValue #4\", 1235, field.newDfp(\"1234.500001\").intValue());\n+        Assert.assertEquals(\"intValue #5\", 2147483647, field.newDfp(\"1e1000\").intValue());\n+        Assert.assertEquals(\"intValue #6\", -2147483648, field.newDfp(\"-1e1000\").intValue());\n+    }\n+\n+    @Test\n+    public void testLog10K()\n+    {\n+        Assert.assertEquals(\"log10K #1\", 1, field.newDfp(\"123456\").log10K());\n+        Assert.assertEquals(\"log10K #2\", 2, field.newDfp(\"123456789\").log10K());\n+        Assert.assertEquals(\"log10K #3\", 0, field.newDfp(\"2\").log10K());\n+        Assert.assertEquals(\"log10K #3\", 0, field.newDfp(\"1\").log10K());\n+        Assert.assertEquals(\"log10K #4\", -1, field.newDfp(\"0.1\").log10K());\n+    }\n+\n+    @Test\n+    public void testPower10K()\n+    {\n+        Dfp d = field.newDfp();\n+\n+        test(d.power10K(0), field.newDfp(\"1\"), 0, \"Power10 #1\");\n+        test(d.power10K(1), field.newDfp(\"10000\"), 0, \"Power10 #2\");\n+        test(d.power10K(2), field.newDfp(\"100000000\"), 0, \"Power10 #3\");\n+\n+        test(d.power10K(-1), field.newDfp(\"0.0001\"), 0, \"Power10 #4\");\n+        test(d.power10K(-2), field.newDfp(\"0.00000001\"), 0, \"Power10 #5\");\n+        test(d.power10K(-3), field.newDfp(\"0.000000000001\"), 0, \"Power10 #6\");\n+    }\n+\n+    @Test\n+    public void testLog10()\n+    {\n+\n+        Assert.assertEquals(\"log10 #1\", 1, field.newDfp(\"12\").log10());\n+        Assert.assertEquals(\"log10 #2\", 2, field.newDfp(\"123\").log10());\n+        Assert.assertEquals(\"log10 #3\", 3, field.newDfp(\"1234\").log10());\n+        Assert.assertEquals(\"log10 #4\", 4, field.newDfp(\"12345\").log10());\n+        Assert.assertEquals(\"log10 #5\", 5, field.newDfp(\"123456\").log10());\n+        Assert.assertEquals(\"log10 #6\", 6, field.newDfp(\"1234567\").log10());\n+        Assert.assertEquals(\"log10 #6\", 7, field.newDfp(\"12345678\").log10());\n+        Assert.assertEquals(\"log10 #7\", 8, field.newDfp(\"123456789\").log10());\n+        Assert.assertEquals(\"log10 #8\", 9, field.newDfp(\"1234567890\").log10());\n+        Assert.assertEquals(\"log10 #9\", 10, field.newDfp(\"12345678901\").log10());\n+        Assert.assertEquals(\"log10 #10\", 11, field.newDfp(\"123456789012\").log10());\n+        Assert.assertEquals(\"log10 #11\", 12, field.newDfp(\"1234567890123\").log10());\n+\n+        Assert.assertEquals(\"log10 #12\", 0, field.newDfp(\"2\").log10());\n+        Assert.assertEquals(\"log10 #13\", 0, field.newDfp(\"1\").log10());\n+        Assert.assertEquals(\"log10 #14\", -1, field.newDfp(\"0.12\").log10());\n+        Assert.assertEquals(\"log10 #15\", -2, field.newDfp(\"0.012\").log10());\n+    }\n+\n+    @Test\n+    public void testPower10()\n+    {\n+        Dfp d = field.newDfp();\n+\n+        test(d.power10(0), field.newDfp(\"1\"), 0, \"Power10 #1\");\n+        test(d.power10(1), field.newDfp(\"10\"), 0, \"Power10 #2\");\n+        test(d.power10(2), field.newDfp(\"100\"), 0, \"Power10 #3\");\n+        test(d.power10(3), field.newDfp(\"1000\"), 0, \"Power10 #4\");\n+        test(d.power10(4), field.newDfp(\"10000\"), 0, \"Power10 #5\");\n+        test(d.power10(5), field.newDfp(\"100000\"), 0, \"Power10 #6\");\n+        test(d.power10(6), field.newDfp(\"1000000\"), 0, \"Power10 #7\");\n+        test(d.power10(7), field.newDfp(\"10000000\"), 0, \"Power10 #8\");\n+        test(d.power10(8), field.newDfp(\"100000000\"), 0, \"Power10 #9\");\n+        test(d.power10(9), field.newDfp(\"1000000000\"), 0, \"Power10 #10\");\n+\n+        test(d.power10(-1), field.newDfp(\".1\"), 0, \"Power10 #11\");\n+        test(d.power10(-2), field.newDfp(\".01\"), 0, \"Power10 #12\");\n+        test(d.power10(-3), field.newDfp(\".001\"), 0, \"Power10 #13\");\n+        test(d.power10(-4), field.newDfp(\".0001\"), 0, \"Power10 #14\");\n+        test(d.power10(-5), field.newDfp(\".00001\"), 0, \"Power10 #15\");\n+        test(d.power10(-6), field.newDfp(\".000001\"), 0, \"Power10 #16\");\n+        test(d.power10(-7), field.newDfp(\".0000001\"), 0, \"Power10 #17\");\n+        test(d.power10(-8), field.newDfp(\".00000001\"), 0, \"Power10 #18\");\n+        test(d.power10(-9), field.newDfp(\".000000001\"), 0, \"Power10 #19\");\n+        test(d.power10(-10), field.newDfp(\".0000000001\"), 0, \"Power10 #20\");\n+    }\n+\n+    @Test\n+    public void testRemainder()\n+    {\n+        test(field.newDfp(\"10\").remainder(field.newDfp(\"3\")),\n+             field.newDfp(\"1\"),\n+             DfpField.FLAG_INEXACT, \"Remainder #1\");\n+\n+        test(field.newDfp(\"9\").remainder(field.newDfp(\"3\")),\n+             field.newDfp(\"0\"),\n+             0, \"Remainder #2\");\n+\n+        test(field.newDfp(\"-9\").remainder(field.newDfp(\"3\")),\n+             field.newDfp(\"-0\"),\n+             0, \"Remainder #3\");\n+    }\n+\n+    @Test\n+    public void testSqrt()\n+    {\n+        test(field.newDfp(\"0\").sqrt(),\n+             field.newDfp(\"0\"),\n+             0, \"Sqrt #1\");\n+\n+        test(field.newDfp(\"-0\").sqrt(),\n+             field.newDfp(\"-0\"),\n+             0, \"Sqrt #2\");\n+\n+        test(field.newDfp(\"1\").sqrt(),\n+             field.newDfp(\"1\"),\n+             0, \"Sqrt #3\");\n+\n+        test(field.newDfp(\"2\").sqrt(),\n+             field.newDfp(\"1.4142135623730950\"),\n+             DfpField.FLAG_INEXACT, \"Sqrt #4\");\n+\n+        test(field.newDfp(\"3\").sqrt(),\n+             field.newDfp(\"1.7320508075688773\"),\n+             DfpField.FLAG_INEXACT, \"Sqrt #5\");\n+\n+        test(field.newDfp(\"5\").sqrt(),\n+             field.newDfp(\"2.2360679774997897\"),\n+             DfpField.FLAG_INEXACT, \"Sqrt #6\");\n+\n+        test(field.newDfp(\"500\").sqrt(),\n+             field.newDfp(\"22.3606797749978970\"),\n+             DfpField.FLAG_INEXACT, \"Sqrt #6.2\");\n+\n+        test(field.newDfp(\"50000\").sqrt(),\n+             field.newDfp(\"223.6067977499789696\"),\n+             DfpField.FLAG_INEXACT, \"Sqrt #6.3\");\n+\n+        test(field.newDfp(\"-1\").sqrt(),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Sqrt #7\");\n+\n+        test(pinf.sqrt(),\n+             pinf,\n+             0, \"Sqrt #8\");\n+\n+        test(field.newDfp((byte) 1, (byte) Dfp.QNAN).sqrt(),\n+             nan,\n+             0, \"Sqrt #9\");\n+\n+        test(field.newDfp((byte) 1, (byte) Dfp.SNAN).sqrt(),\n+             nan,\n+             DfpField.FLAG_INVALID, \"Sqrt #9\");\n+    }\n+\n+}", "timestamp": 1283641161, "metainfo": ""}