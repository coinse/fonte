{"sha": "1e25d303fef1851347459b7f3cd8aa67104a4bb1", "log": "Initial commit.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+/*\n+ * \n+ * Copyright (c) 2004 The Apache Software Foundation. All rights reserved.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy\n+ * of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *  \n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Represents a polynomial spline function.\n+ * <p>\n+ * A <strong>polynomial spline function</strong> consists of a set of <i>interpolating polynomials</i> \n+ * and an ascending array of  domain <i>knot points</i>, determining the intervals over which the \n+ * spline function is defined by the constituent polynomials.  The polynomials are assumed to have \n+ * been computed to match the values of another function at the knot points and the first two \n+ * derivatives of \"adjacent\" polynomials are constrained to agree at the knot points.  The value \n+ * consistency constraints are not currently enforced by <code>PolynomialSplineFunction</code> itself,\n+ * but are assumed to hold  among the polynomials and knot points passed to the constructor.\n+ * <p>\n+ * N.B.:  The polynomials in the <code>polynomials</code> property must be centered on the knot points\n+ * to compute the spline function values.  See below.\n+ * <p>\n+ * The value of the polynomial spline function for an argument <code>x</code> is computed as follows:\n+ * <ol>\n+ * <li>The knot array is searched to find the segment to which <code>x</code> belongs.  \n+ *  If <code>x</code> is less than the smallest knot point or greater than or equal to the largest one, an \n+ *  <code>IllegalArgumentException</code> is thrown.</li>\n+ * <li> Let <code>j</code> be the index of the largest knot point that is less than or equal to <code>x</code>. \n+ *  The value returned is <br> <code>polynomials[j](x - knot[j])</code></li></ol>\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/04/02 20:58:11 $\n+ */\n+public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {\n+   \n+    /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n+    private double knots[];\n+\n+    /**\n+     * The polynomial functions that make up the spline.  The first element determines the value of the spline\n+     * over the first subinterval, the second over the second, etc.   Spline function values are determined by\n+     * evaluating these functions at <code>(x - knot[i])</code> where i is the knot segment to which x belongs.\n+     */\n+    private PolynomialFunction polynomials[] = null;\n+    \n+    /** Number of spline segments = number of polynomials = number of partition points - 1 */\n+    private int n = 0;\n+    \n+\n+    /**\n+     * Construct a polynomial spline function with the given segment delimiters and interpolating\n+     * polynomials.\n+     * <p>\n+     * The constructor copies both arrays and assigns the copies to the knots and polynomials properties,\n+     * respectively.\n+     * \n+     * @param knots spline segment interval delimiters\n+     * @param polynomials polynomial functions that make up the spline\n+     * @throws NullPointerException if either of the input arrays is null\n+     * @throws IllegalArgumentException if knots has length less than 2,  \n+     *     <code>polynomials.length != knots.length - 1 </code>, or the knots array\n+     *     is not strictly increasing.\n+     * \n+     */\n+    public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n+        super();\n+        if (knots.length < 2) {\n+            throw new IllegalArgumentException\n+            \t(\"Not enough knot values -- spline partition must have at least 2 points.\");\n+        }\n+        if (knots.length - 1 != polynomials.length) {\n+            throw new IllegalArgumentException \n+            (\"Number of polynomial interpolants must match the number of segments.\");\n+        }\n+        \n+        // TODO: check that knots is increasing\n+        \n+        this.n = knots.length -1;\n+        this.knots = new double[n + 1];\n+        System.arraycopy(knots, 0, this.knots, 0, n + 1);\n+        this.polynomials = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, this.polynomials, 0, n);\n+    }\n+\n+    /**\n+     * Compute the value for the function.\n+     * \n+     * @param v the point for which the function value should be computed\n+     * @return the value\n+     * @throws MathException if the function couldn't be computed due to\n+     *  missing additional data or other environmental problems.\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double v) throws MathException {\n+        if (v < knots[0] || v >= knots[n]) {\n+            throw new IllegalArgumentException(\"Argument outside domain\");\n+        }\n+        int i = Arrays.binarySearch(knots, v);\n+        if (i < 0) {\n+            i = -i - 2;\n+        }\n+        return polynomials[i].value(v - knots[i]);\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a UnivariateRealFunction\n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return polynomialSplineDerivative();\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a PolynomialSplineFunction\n+     * \n+     * @return  the derivative function\n+     */\n+    public PolynomialSplineFunction polynomialSplineDerivative() {\n+        PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];\n+        for (int i = 0; i < n; i++) {\n+            derivativePolynomials[i] = polynomials[i].polynomialDerivative();\n+        }\n+        return new PolynomialSplineFunction(knots, derivativePolynomials);\n+    }\n+\n+    /**\n+     * Returns the number of spline segments = the number of polynomials = the number of knot points - 1.\n+     * \n+     * @return the number of spline segments\n+     */\n+    public int getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating polynomials array.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy will\n+     * not affect the polynomials property.\n+     * \n+     * @return the interpolating polynomials\n+     */\n+    public PolynomialFunction[] getPolynomials() {\n+        PolynomialFunction p[] = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, p, 0, n);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns an array copy of the knot points.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy\n+     * will not affect the knots property.\n+     * \n+     * @return the knot points\n+     */\n+    public double[] getKnots() {\n+        double out[] = new double[n + 1];\n+        System.arraycopy(knots, 0, out, 0, n + 1);\n+        return out;  \n+    }\n+\n+}", "timestamp": 1080939491, "metainfo": ""}