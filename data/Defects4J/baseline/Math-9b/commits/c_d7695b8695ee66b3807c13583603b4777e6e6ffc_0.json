{"sha": "d7695b8695ee66b3807c13583603b4777e6e6ffc", "log": "New ODE integrators have been added: the explicit Adams-Bashforth and implicit Adams-Moulton multistep methods. These methods support customizable starter integrators and support discrete events even during the start phase. All these methods provide the same rich features has the existing ones: continuous output, step handlers, discrete events, G-stop ...   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements explicit Adams-Bashforth integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Bashforth (in fact due to Adams alone) methods are explicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h f<sub>n</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3f<sub>n</sub>-f<sub>n-1</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23f<sub>n</sub>-16f<sub>n-1</sub>+5f<sub>n-2</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55f<sub>n</sub>-59f<sub>n-1</sub>+37f<sub>n-2</sub>-9f<sub>n-3)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Bashforth method is of order k. There is no limit to the\n+ * value of k.</p>\n+ *\n+ * <p>These methods are explicit: f<sub>n+1</sub> is not used to compute\n+ * y<sub>n+1</sub>. More accurate implicit Adams methods exist: the\n+ * Adams-Moulton methods (which are also due to Adams alone). They are\n+ * provided by the {@link AdamsMoultonIntegrator AdamsMoultonIntegrator} class.</p>\n+ *\n+ * @see AdamsMoultonIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsBashforthIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1676381657635800870L;\n+\n+    /** Integrator method name. */\n+    private static final String METHOD_NAME = \"Adams-Bashforth\";\n+\n+   /** Coefficients for the current method. */\n+    private final double[] coeffs;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Bashforth integrator with the given order and step size.\n+     * @param order order of the method (must be strictly positive)\n+     * @param step integration step size\n+     */\n+    public AdamsBashforthIntegrator(final int order, final double step) {\n+\n+        super(METHOD_NAME, order, new AdamsBashforthStepInterpolator());\n+\n+        // compute the integration coefficients\n+        int[][] bdArray = computeBackwardDifferencesArray(order);\n+        Fraction[] gamma = computeGammaArray(order);\n+        coeffs = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            Fraction f = Fraction.ZERO;\n+            for (int j = i; j < order; ++j) {\n+                f = f.add(gamma[j].multiply(new Fraction(bdArray[j][i], 1)));\n+            }\n+            coeffs[i] = f.doubleValue();\n+        }\n+\n+        this.step = step;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(FirstOrderDifferentialEquations equations,\n+                            double t0, double[] y0, double t, double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, y0.length);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final AdamsBashforthStepInterpolator interpolator =\n+                (AdamsBashforthStepInterpolator) prototype.copy();\n+        interpolator.reinitialize(yTmp, previousT, previousF, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            // estimate the state at the end of the step\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < coeffs.length; ++l) {\n+                    sum += coeffs[l] * previousF[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepStart + stepSize);\n+            final boolean truncated;\n+            if (manager.evaluateStep(interpolator)) {\n+                truncated = true;\n+                interpolator.truncateStep(manager.getEventTime());\n+            } else {\n+                truncated = false;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = interpolator.getCurrentTime();\n+            interpolator.setInterpolatedTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep) {\n+                // prepare next step\n+\n+                if (manager.reset(stepStart, y)) {\n+\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    stopTime =\n+                        start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                    if (Double.isNaN(previousT[0])) {\n+                        return stopTime;\n+                    }\n+                    stepStart = previousT[0];\n+\n+                } else {\n+\n+                    if (truncated) {\n+                        // the step has been truncated, we need to adjust the previous steps\n+                        for (int i = 1; i < previousF.length; ++i) {\n+                            previousT[i] = stepStart - i * stepSize;\n+                            interpolator.setInterpolatedTime(previousT[i]);\n+                            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                                             previousF[i], 0, y0.length);\n+                        }\n+                    } else {\n+                        rotatePreviousSteps();\n+                    }\n+\n+                    // evaluate differential equations for next step\n+                    previousT[0] = stepStart;\n+                    equations.computeDerivatives(stepStart, y, previousF[0]);\n+\n+                }\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Get the coefficients of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k-1</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getCoeffs() {\n+        return coeffs.clone();\n+    }\n+\n+    /** Compute the backward differences coefficients array.\n+     * <p>This is quite similar to the Pascal triangle, except for a\n+     * (-1)<sup>i</sup> sign. We use a straightforward approach here,\n+     * since we don't expect this to be run too many times with too\n+     * high k. It is based on the recurrence relations:</p>\n+     * <pre>\n+     *   &nabla;<sup>0</sup> f<sub>n</sub> = f<sub>n</sub>\n+     *   &nabla;<sup>i+1</sup> f<sub>n</sub> = &nabla;<sup>i</sup>f<sub>n</sub> - &nabla;<sup>i</sup>f<sub>n-1</sub>\n+     * </pre>\n+     * @param order order of the integration method\n+     */\n+    static int[][] computeBackwardDifferencesArray(final int order) {\n+\n+        // create the array\n+        int[][] bdArray = new int[order][];\n+\n+        // recurrence initialization\n+        bdArray[0] = new int[] { 1 };\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i < order; ++i) {\n+            bdArray[i] = new int[i + 1];\n+            bdArray[i][0] = 1;\n+            for (int j = 0; j < i - 1; ++j) {\n+                bdArray[i][j + 1] = bdArray[i - 1][j + 1] - bdArray[i - 1][j];\n+            }\n+            bdArray[i][i] = -bdArray[i - 1][i - 1];\n+        }\n+\n+        return bdArray;\n+\n+    }\n+\n+    /** Compute the gamma coefficients.\n+     * @param order order of the integration method\n+     * @return gamma coefficients array\n+     */\n+    static Fraction[] computeGammaArray(final int order) {\n+\n+        // create the array\n+        Fraction[] gammaArray = new Fraction[order];\n+\n+        // recurrence initialization\n+        gammaArray[0] = Fraction.ONE;\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i < order; ++i) {\n+            Fraction gamma = Fraction.ONE;\n+            for (int j = 1; j <= i; ++j) {\n+                gamma = gamma.subtract(gammaArray[i - j].multiply(new Fraction(1, j + 1)));\n+            }\n+            gammaArray[i] = gamma;\n+        }\n+\n+        return gammaArray;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for Adams-Bashforth multiple steps.\n+ *\n+ * <p>This interpolator computes dense output inside the last few\n+ * steps computed. The interpolation equation is consistent with the\n+ * integration scheme, it is based on a kind of <em>rollback</em> of the\n+ * integration from step end to interpolation date:\n+ * <pre>\n+ *   y(t<sub>n</sub> + theta h) = y (t<sub>n</sub> + h) - &int;<sub>t<sub>n</sub> + theta h</sub><sup>t<sub>n</sub> + h</sup>p(t)dt\n+ * </pre>\n+ * where theta belongs to [0 ; 1] and p(t) is the interpolation polynomial based on\n+ * the derivatives at previous steps f<sub>n-k+1</sub>, f<sub>n-k+2</sub> ...\n+ * f<sub>n</sub> and f<sub>n</sub>.</p>\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+class AdamsBashforthStepInterpolator extends MultistepStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7179861704951334960L;\n+\n+    /** Neville's interpolation array. */\n+    private double[] neville;\n+\n+    /** Integration rollback array. */\n+    private double[] rollback;\n+\n+    /** &gamma; array. */\n+    private double[] gamma;\n+\n+    /** Backward differences array. */\n+    private int[][] bdArray;\n+\n+    /** Original non-truncated step end time. */\n+    private double nonTruncatedEnd;\n+\n+    /** Original non-truncated step size. */\n+    private double nonTruncatedH;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public AdamsBashforthStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public AdamsBashforthStepInterpolator(final AdamsBashforthStepInterpolator interpolator) {\n+        super(interpolator);\n+        nonTruncatedEnd = interpolator.nonTruncatedEnd;\n+        nonTruncatedH   = interpolator.nonTruncatedH;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new AdamsBashforthStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void initializeCoefficients() {\n+\n+        neville  = new double[previousF.length];\n+        rollback = new double[previousF.length];\n+\n+        bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);\n+\n+        Fraction[] fGamma = AdamsBashforthIntegrator.computeGammaArray(previousF.length);\n+        gamma = new double[fGamma.length];\n+        for (int i = 0; i < fGamma.length; ++i) {\n+            gamma[i] = fGamma[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void storeTime(final double t) {\n+        nonTruncatedEnd = t;\n+        nonTruncatedH   = nonTruncatedEnd - previousTime;\n+        super.storeTime(t);\n+    }\n+\n+    /** Truncate a step.\n+     * <p>Truncating a step is necessary when an event is triggered\n+     * before the nominal end of the step.</p>\n+     */\n+    void truncateStep(final double truncatedEndTime) {\n+        currentTime = truncatedEndTime;\n+        h = currentTime - previousTime;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setInterpolatedTime(final double time)\n+        throws DerivativeException {\n+        interpolatedTime = time;\n+        final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;\n+        final double theta = (nonTruncatedH == 0) ?\n+                             0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;\n+        computeInterpolatedState(theta, oneMinusThetaH);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n+        interpolateDerivatives();\n+        interpolateState(theta);\n+    }\n+\n+    /** Interpolate the derivatives.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. So the interpolation of\n+     * the derivatives here is strictly equivalent: it is a simple polynomial\n+     * interpolation.</p>\n+     */\n+    private void interpolateDerivatives() {\n+\n+        for (int i = 0; i < interpolatedDerivatives.length; ++i) {\n+\n+            // initialize the Neville's interpolation algorithm\n+            for (int k = 0; k < previousF.length; ++k) {\n+                neville[k] = previousF[k][i];\n+            }\n+\n+            // combine the contributions of each points\n+            for (int l = 1; l < neville.length; ++l) {\n+                for (int m = neville.length - 1; m >= l; --m) {\n+                    final double xm   = previousT[m];\n+                    final double xmMl = previousT[m - l];\n+                    neville[m] = ((interpolatedTime - xm) * neville[m-1] +\n+                                  (xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);\n+                }\n+            }\n+\n+            // the interpolation polynomial value is in the array last element\n+            interpolatedDerivatives[i] = neville[neville.length - 1];\n+\n+        }\n+\n+    }\n+\n+    /** Interpolate the state.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. The polynomial model is\n+     * integrated analytically throughout the last step. Using the notations\n+     * found in the second edition of the first volume (Nonstiff Problems)\n+     * of the reference book by Hairer, Norsett and Wanner: <i>Solving Ordinary\n+     * Differential Equations</i> (Springer-Verlag, ISBN 3-540-56670-8), this\n+     * process leads to the following expression:</p>\n+     * <pre>\n+     * y<sub>n+1</sub> = y<sub>n</sub> +\n+     * h &times; &sum;<sub>j=0</sub><sup>j=k-1</sup> &gamma;<sub>j</sub>&nabla;<sup>j</sup>f<sub>n</sub>\n+     * </pre>\n+     * <p>In the previous expression, the &gamma;<sub>j</sub> terms are the\n+     * ones that result from the analytical integration, and can be computed form\n+     * the binomial coefficients C<sub>j</sub><sup>-s</sup>:</p>\n+     * <p>\n+     * &gamma;<sub>j</sub> = (-1)<sup>j</sup>&int;<sub>0</sub><sup>1</sup>C<sub>j</sub><sup>-s</sup>ds\n+     * </p>\n+     * <p>In order to interpolate the state in a manner that is consistent with the\n+     * integration scheme, we simply subtract from the current state (at the end of the step)\n+     * the integral computed from interpolation time to step end time.</p>\n+     * <p>\n+     * &eta;<sub>j</sub>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>&theta;</sub><sup>1</sup>C<sub>j</sub><sup>-s</sup>ds\n+     * </p>\n+     * The method described in the Hairer, Norsett and Wanner book to compute &gamma;<sub>j</sub>\n+     * is easily extended to compute &gamma;<sub>j</sub>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>0</sub><sup>&theta;</sup>C<sub>j</sub><sup>-s</sup>ds. From this,\n+     * we can compute &eta;<sub>j</sub>(&theta;) = &gamma;<sub>j</sub>-&gamma;<sub>j</sub>(&theta;).\n+     * The first few values are:</p>\n+     * <table>\n+     * <tr><td>j</td><td>&gamma;<sub>j</sub></td><td>&gamma;<sub>j</sub>(&theta;)</td><td>&eta;<sub>j</sub>(&theta;)</td></tr>\n+     * <tr><td>0</td><td>1</td><td></td>&theta;<td>1-&theta;</td></tr>\n+     * <tr><td>1</td><td>1/2</td><td></td>&theta;<sup>2</sup>/2<td>(1-&theta;<sup>2</sup>)/2</td></tr>\n+     * <tr><td>2</td><td>5/12</td><td></td>(3&theta;<sup>2</sup>+2&theta;<sup>3</sup>)/12<td>(5-3&theta;<sup>2</sup>-2&theta;<sup>3</sup>)/12</td></tr>\n+     * </table>\n+     * <p>\n+     * The &eta;<sub>j</sub>(&theta;) functions appear to be polynomial ones. As expected,\n+     * we see that &eta;<sub>j</sub>(1)= 0. The recurrence relation derived for\n+     * &gamma;<sub>j</sub>(&theta;) is:\n+     * </p>\n+     * <p>\n+     * &sum<sub>j=0</sub><sup>j=m</sup>&gamma;<sub>j</sub>(&theta;)/(m+1-j) =\n+     * 1/(m+1)! &prod;<sub>k=0</sub><sup>k=m</sup>(&theta;+k)\n+     * </p>\n+     * @param theta location of the interpolation point within the last step\n+     */\n+    private void interpolateState(final double theta) {\n+\n+        // compute the integrals to remove from the final state\n+        computeRollback(previousT.length - 1, theta);\n+\n+        // remove these integrals from the final state\n+        for (int j = 0; j < interpolatedState.length; ++j) {\n+            double sum = 0;\n+            for (int l = 0; l < previousT.length; ++l) {\n+                sum += rollback[l] * previousF[l][j];\n+            }\n+            interpolatedState[j] = currentState[j] - h * sum;\n+        }\n+\n+    }\n+\n+    /** Compute the rollback coefficients.\n+     * @param order order of the integration method\n+     * @param theta current value for theta\n+     */\n+    private void computeRollback(final int order, final double theta) {\n+\n+        // compute the gamma(theta) values from the recurrence relation\n+        double product = theta;\n+        rollback[0]  = theta;\n+        for (int i = 1; i < order; ++i) {\n+            product *= (i + theta) / (i + 1);\n+            double g = product;\n+            for (int j = 1; j <= i; ++j) {\n+                g -= rollback[i - j] / (j + 1);\n+            }\n+            rollback[i] = g;\n+        }\n+\n+        // subtract it from gamma to get eta(theta)\n+        for (int i = 0; i < order; ++i) {\n+            rollback[i] -= gamma[i];\n+        }\n+\n+        // combine the eta integrals with the backward differences array\n+        // to get the rollback coefficients\n+        for (int i = 0; i < order; ++i) {\n+            double f = 0;\n+            for (int j = i; j <= order; ++j) {\n+                f -= rollback[j] * bdArray[j][i];\n+            }\n+            rollback[i] = f;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+        super.writeExternal(out);\n+        out.writeDouble(nonTruncatedEnd);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+        throws IOException {\n+        nonTruncatedEnd = in.readDouble();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements implicit Adams-Moulton integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Moulton (in fact due to Adams alone) methods are implicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n+1, n, n-1 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 0: y<sub>n+1</sub> = y<sub>n</sub> + h f<sub>n+1</sub></li>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h (f<sub>n+1</sub>+f<sub>n</sub>)/2</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (5f<sub>n+1</sub>+8f<sub>n</sub>-f<sub>n-1</sub>)/12</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (9f<sub>n+1</sub>+19f<sub>n</sub>-5f<sub>n-1</sub>+f<sub>n-2)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>The coefficients are computed (and cached) as needed, so their are no\n+ * theoretical limitations to the number of steps</p>\n+ *\n+ * <p>A k-steps Adams-Moulton method is of order k+1. There is no limit to the\n+ * value of k.</p>\n+ *\n+ * <p>These methods are implicit: f<sub>n+1</sub> is used to compute\n+ * y<sub>n+1</sub>. Simpler explicit Adams methods exist: the\n+ * Adams-Bashforth methods (which are also due to Adams alone). They are\n+ * provided by the {@link AdamsBashforthIntegrator AdamsBashforthIntegrator} class.</p>\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsMoultonIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4990335331377040417L;\n+\n+    /** Integrator method name. */\n+    private static final String METHOD_NAME = \"Adams-Moulton\";\n+\n+    /** Coefficients for the predictor phase of the method. */\n+    private final double[] predictorCoeffs;\n+\n+    /** Coefficients for the corrector phase of the method. */\n+    private final double[] correctorCoeffs;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and step size.\n+     * @param order order of the method (must be strictly positive)\n+     * @param step integration step size\n+     */\n+    public AdamsMoultonIntegrator(final int order, final double step) {\n+\n+        super(METHOD_NAME, order + 1, new AdamsMoultonStepInterpolator());\n+\n+        // compute the integration coefficients\n+        int[][] bdArray      = AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);\n+\n+        Fraction[] gamma     = AdamsBashforthIntegrator.computeGammaArray(order);\n+        predictorCoeffs = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            Fraction fPredictor = Fraction.ZERO;\n+            for (int j = i; j < order; ++j) {\n+                Fraction f = new Fraction(bdArray[j][i], 1);\n+                fPredictor = fPredictor.add(gamma[j].multiply(f));\n+            }\n+            predictorCoeffs[i] = fPredictor.doubleValue();\n+        }\n+\n+        Fraction[] gammaStar = computeGammaStarArray(order);\n+        correctorCoeffs = new double[order + 1];\n+        for (int i = 0; i <= order; ++i) {\n+            Fraction fCorrector = Fraction.ZERO;\n+            for (int j = i; j <= order; ++j) {\n+                Fraction f = new Fraction(bdArray[j][i], 1);\n+                fCorrector = fCorrector.add(gammaStar[j].multiply(f));\n+            }\n+            correctorCoeffs[i] = fCorrector.doubleValue();\n+        }\n+\n+        this.step = step;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(FirstOrderDifferentialEquations equations,\n+                            double t0, double[] y0, double t, double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, y0.length);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final AdamsMoultonStepInterpolator interpolator =\n+                (AdamsMoultonStepInterpolator) prototype.copy();\n+        interpolator.reinitialize(yTmp, previousT, previousF, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length - 1, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        rotatePreviousSteps();\n+        previousF[0] = new double[y0.length];\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            // predict state at end of step\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < predictorCoeffs.length; ++l) {\n+                    sum += predictorCoeffs[l] * previousF[l+1][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // evaluate the derivatives\n+            final double stepEnd = stepStart + stepSize;\n+            equations.computeDerivatives(stepEnd, yTmp, previousF[0]);\n+\n+            // apply corrector\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < correctorCoeffs.length; ++l) {\n+                    sum += correctorCoeffs[l] * previousF[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepEnd);\n+            final boolean truncated;\n+            if (manager.evaluateStep(interpolator)) {\n+                truncated = true;\n+                interpolator.truncateStep(manager.getEventTime());\n+            } else {\n+                truncated = false;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = interpolator.getCurrentTime();\n+            interpolator.setInterpolatedTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep) {\n+                // prepare next step\n+\n+                if (manager.reset(stepStart, y)) {\n+\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    stopTime =\n+                        start(previousF.length - 1, stepSize, manager, equations, stepStart, y);\n+                    if (Double.isNaN(previousT[0])) {\n+                        return stopTime;\n+                    }\n+                    stepStart = previousT[0];\n+                    rotatePreviousSteps();\n+                    previousF[0] = new double[y0.length];\n+\n+                } else {\n+\n+                    if (truncated) {\n+                        // the step has been truncated, we need to adjust the previous steps\n+                        for (int i = 1; i < previousF.length; ++i) {\n+                            previousT[i] = stepStart - i * stepSize;\n+                            interpolator.setInterpolatedTime(previousT[i]);\n+                            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                                             previousF[i], 0, y0.length);\n+                        }\n+                    } else {\n+                        rotatePreviousSteps();\n+                    }\n+\n+                    // evaluate differential equations for next step\n+                    previousT[0] = stepStart;\n+                    equations.computeDerivatives(stepStart, y, previousF[0]);\n+\n+                }\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Get the coefficients of the prdictor phase of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k-1</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getPredictorCoeffs() {\n+        return predictorCoeffs.clone();\n+    }\n+\n+    /** Get the coefficients of the corrector phase of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getCorrectorCoeffs() {\n+        return correctorCoeffs.clone();\n+    }\n+\n+    /** Compute the gamma star coefficients.\n+     * @param order order of the integration method\n+     * @return gamma star coefficients array\n+     */\n+    static Fraction[] computeGammaStarArray(final int order) {\n+\n+        // create the array\n+        Fraction[] gammaStarArray = new Fraction[order + 1];\n+\n+        // recurrence initialization\n+        gammaStarArray[0] = Fraction.ONE;\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i <= order; ++i) {\n+            Fraction gammaStar = Fraction.ZERO;\n+            for (int j = 1; j <= i; ++j) {\n+                gammaStar = gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1, j + 1)));\n+            }\n+            gammaStarArray[i] = gammaStar;\n+        }\n+\n+        return gammaStarArray;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for Adams-Moulton multiple steps.\n+ *\n+ * <p>This interpolator computes dense output inside the last few\n+ * steps computed. The interpolation equation is consistent with the\n+ * integration scheme, it is based on a kind of <em>rollback</em> of the\n+ * integration from step end to interpolation date:\n+ * <pre>\n+ *   y(t<sub>n</sub> + theta h) = y (t<sub>n</sub> + h) - &int;<sub>t<sub>n</sub> + theta h</sub><sup>t<sub>n</sub> + h</sup>p(t)dt\n+ * </pre>\n+ * where theta belongs to [0 ; 1] and p(t) is the interpolation polynomial based on\n+ * the derivatives at previous steps f<sub>n-k+1</sub>, f<sub>n-k+2</sub> ...\n+ * f<sub>n</sub>, f<sub>n</sub> and f<sub>n+1</sub>.</p>\n+ *\n+ * @see AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+class AdamsMoultonStepInterpolator extends MultistepStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 735568489801241899L;\n+\n+    /** Neville's interpolation array. */\n+    private double[] neville;\n+\n+    /** Integration rollback array. */\n+    private double[] rollback;\n+\n+    /** &gamma; star array. */\n+    private double[] gammaStar;\n+\n+    /** Backward differences array. */\n+    private int[][] bdArray;\n+\n+    /** Original non-truncated step end time. */\n+    private double nonTruncatedEnd;\n+\n+    /** Original non-truncated step size. */\n+    private double nonTruncatedH;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public AdamsMoultonStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public AdamsMoultonStepInterpolator(final AdamsMoultonStepInterpolator interpolator) {\n+        super(interpolator);\n+        nonTruncatedEnd = interpolator.nonTruncatedEnd;\n+        nonTruncatedH   = interpolator.nonTruncatedH;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new AdamsMoultonStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void initializeCoefficients() {\n+\n+        neville  = new double[previousF.length];\n+        rollback = new double[previousF.length];\n+\n+        bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);\n+\n+        Fraction[] fGammaStar = AdamsMoultonIntegrator.computeGammaStarArray(previousF.length);\n+        gammaStar = new double[fGammaStar.length];\n+        for (int i = 0; i < fGammaStar.length; ++i) {\n+            gammaStar[i] = fGammaStar[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void storeTime(final double t) {\n+        nonTruncatedEnd = t;\n+        nonTruncatedH   = nonTruncatedEnd - previousTime;\n+        super.storeTime(t);\n+    }\n+\n+    /** Truncate a step.\n+     * <p>Truncating a step is necessary when an event is triggered\n+     * before the nominal end of the step.</p>\n+     */\n+    void truncateStep(final double truncatedEndTime) {\n+        currentTime = truncatedEndTime;\n+        h = currentTime - previousTime;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setInterpolatedTime(final double time)\n+        throws DerivativeException {\n+        interpolatedTime = time;\n+        final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;\n+        final double theta = (nonTruncatedH == 0) ?\n+                             0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;\n+        computeInterpolatedState(theta, oneMinusThetaH);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n+        interpolateDerivatives();\n+        interpolateState(theta);\n+    }\n+\n+    /** Interpolate the derivatives.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. So the interpolation of\n+     * the derivatives here is strictly equivalent: it is a simple polynomial\n+     * interpolation.</p>\n+     */\n+    private void interpolateDerivatives() {\n+\n+        for (int i = 0; i < interpolatedDerivatives.length; ++i) {\n+\n+            // initialize the Neville's interpolation algorithm\n+            for (int k = 0; k < previousF.length; ++k) {\n+                neville[k] = previousF[k][i];\n+            }\n+\n+            // combine the contributions of each points\n+            for (int l = 1; l < neville.length; ++l) {\n+                for (int m = neville.length - 1; m >= l; --m) {\n+                    final double xm   = previousT[m];\n+                    final double xmMl = previousT[m - l];\n+                    neville[m] = ((interpolatedTime - xm) * neville[m-1] +\n+                                  (xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);\n+                }\n+            }\n+\n+            // the interpolation polynomial value is in the array last element\n+            interpolatedDerivatives[i] = neville[neville.length - 1];\n+\n+        }\n+\n+    }\n+\n+    /** Interpolate the state.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. The polynomial model is\n+     * integrated analytically throughout the last step. Using the notations\n+     * found in the second edition of the first volume (Nonstiff Problems)\n+     * of the reference book by Hairer, Norsett and Wanner: <i>Solving Ordinary\n+     * Differential Equations</i> (Springer-Verlag, ISBN 3-540-56670-8), this\n+     * process leads to the following expression:</p>\n+     * <pre>\n+     * y<sub>n+1</sub> = y<sub>n</sub> +\n+     * h &times; &sum;<sub>j=0</sub><sup>j=k</sup> &gamma;<sub>j</sub><sup>*</sup>&nabla;<sup>j</sup>f<sub>n+1</sub>\n+     * </pre>\n+     * <p>In the previous expression, the &gamma;<sub>j</sub><sup>*</sup> terms are the\n+     * ones that result from the analytical integration, and can be computed form\n+     * the binomial coefficients C<sub>j</sub><sup>-s</sup>:</p>\n+     * <p>\n+     * &gamma;<sub>j</sub><sup>*</sup> = (-1)<sup>j</sup>&int;<sub>0</sub><sup>1</sup>C<sub>j</sub><sup>1-s</sup>ds\n+     * </p>\n+     * <p>In order to interpolate the state in a manner that is consistent with the\n+     * integration scheme, we simply subtract from the current state (at the end of the step)\n+     * the integral computed from interpolation time to step end time.</p>\n+     * <p>\n+     * &eta;<sub>j</sub><sup>*</sup>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>&theta;</sub><sup>1</sup>C<sub>j</sub><sup>1-s</sup>ds\n+     * </p>\n+     * The method described in the Hairer, Norsett and Wanner book to compute &gamma;<sub>j</sub><sup>*</sup>\n+     * is easily extended to compute &gamma;<sub>j</sub><sup>*</sup>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>0</sub><sup>&theta;</sup>C<sub>j</sub><sup>1-s</sup>ds. From this,\n+     * we can compute &eta;<sub>j</sub><sup>*</sup>(&theta;) =\n+     * &gamma;<sub>j</sub><sup>*</sup>-&gamma;<sub>j</sub><sup>*</sup>(&theta;).\n+     * The first few values are:</p>\n+     * <table>\n+     * <tr><td>j</td><td>&gamma;<sub>j</sub><sup>*</sup></td><td>&gamma;<sub>j</sub><sup>*</sup>(&theta;)</td><td>&eta;<sub>j</sub><sup>*</sup>(&theta;)</td></tr>\n+     * <tr><td>0</td><td>1</td><td>&theta;</td><td>1-&theta;</td></tr>\n+     * <tr><td>1</td><td>-1/2</td><td>(&theta;<sup>2</sup>-2&theta;)/2</td><td>(-1+2&theta;-&theta;<sup>2</sup>)/2</td></tr>\n+     * <tr><td>2</td><td>-1/12</td><td>(2&theta;<sup>3</sup>-3&theta;<sup>2</sup>)/12</td><td>(-1+3&theta;<sup>2</sup>-2&theta;<sup>3</sup>)/12</td></tr>\n+     * </table>\n+     * <p>\n+     * The &eta;<sub>j</sub>(&theta;) functions appear to be polynomial ones. As expected,\n+     * we see that &eta;<sub>j</sub>(1)= 0. The recurrence relation derived for\n+     * &gamma;<sub>j</sub>(&theta;) is:\n+     * </p>\n+     * <p>\n+     * &sum<sub>j=0</sub><sup>j=m</sup>&gamma;<sub>j</sub><sup>*</sup>(&theta;)/(m+1-j) =\n+     * 1/(m+1)! &prod;<sub>k=0</sub><sup>k=m</sup>(&theta;+k-1)\n+     * </p>\n+     * @param theta location of the interpolation point within the last step\n+     */\n+    private void interpolateState(final double theta) {\n+\n+        // compute the integrals to remove from the final state\n+        computeRollback(previousT.length - 1, theta);\n+\n+        // remove these integrals from the final state\n+        for (int j = 0; j < interpolatedState.length; ++j) {\n+            double sum = 0;\n+            for (int l = 0; l < previousT.length; ++l) {\n+                sum += rollback[l] * previousF[l][j];\n+            }\n+            interpolatedState[j] = currentState[j] - h * sum;\n+        }\n+\n+    }\n+\n+    /** Compute the rollback coefficients.\n+     * @param order order of the integration method\n+     * @param theta current value for theta\n+     */\n+    private void computeRollback(final int order, final double theta) {\n+\n+        // compute the gamma star(theta) values from the recurrence relation\n+        double product = theta - 1;\n+        rollback[0]  = theta;\n+        for (int i = 1; i <= order; ++i) {\n+            product *= (i - 1 + theta) / (i + 1);\n+            double gStar = product;\n+            for (int j = 1; j <= i; ++j) {\n+                gStar -= rollback[i - j] / (j + 1);\n+            }\n+            rollback[i] = gStar;\n+        }\n+\n+        // subtract it from gamma star to get eta star(theta)\n+        for (int i = 0; i <= order; ++i) {\n+            rollback[i] -= gammaStar[i];\n+        }\n+\n+        // combine the eta star integrals with the backward differences array\n+        // to get the rollback coefficients\n+        for (int i = 0; i <= order; ++i) {\n+            double f = 0;\n+            for (int j = i; j <= order; ++j) {\n+                f -= rollback[j] * bdArray[j][i];\n+            }\n+            rollback[i] = f;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+        super.writeExternal(out);\n+        out.writeDouble(nonTruncatedEnd);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+        throws IOException {\n+        nonTruncatedEnd = in.readDouble();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MultistepIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.ODEIntegrator;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+/**\n+ * This class is the base class for multistep integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @see AdamsMoultonIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class MultistepIntegrator extends AbstractIntegrator {\n+\n+    /** Starter integrator. */\n+    private FirstOrderIntegrator starter;\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Time of last detected reset. */\n+    private double resetTime;\n+\n+    /** Prototype of the step interpolator. */\n+    protected MultistepStepInterpolator prototype;\n+                                           \n+    /**\n+     * Build a multistep integrator with the given number of steps.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * @param name name of the method\n+     * @param k number of steps of the multistep method\n+     * (including the one being computed)\n+     * @param prototype prototype of the step interpolator to use\n+     */\n+    protected MultistepIntegrator(final String name, final int k,\n+                                  final MultistepStepInterpolator prototype) {\n+        super(name);\n+        starter = new DormandPrince853Integrator(1.0e-6, 1.0e6, 1.0e-5, 1.0e-6);\n+        previousT = new double[k];\n+        previousF = new double[k][];\n+        this.prototype = prototype;\n+    }\n+\n+    /**\n+     * Get the starter integrator.\n+     * @return starter integrator\n+     */\n+    public ODEIntegrator getStarterIntegrator() {\n+        return starter;\n+    }\n+\n+    /**\n+     * Set the starter integrator.\n+     * <p>The various step and event handlers for this starter integrator\n+     * will be managed automatically by the multi-step integrator. Any\n+     * user configuration for these elements will be cleared before use.</p>\n+     * @param starter starter integrator\n+     */\n+    public void setStarterIntegrator(FirstOrderIntegrator starter) {\n+        this.starter = starter;\n+    }\n+\n+    /** Start the integration.\n+     * <p>This method computes the first few steps of the multistep method,\n+     * using the underlying starter integrator, ensuring the returned steps\n+     * all belong to the same smooth range.</p>\n+     * <p>In order to ensure smoothness, the start phase is automatically\n+     * restarted when a state or derivative reset is triggered by the\n+     * registered events handlers before this start phase is completed. As\n+     * an example, consider integrating a differential equation from t=0\n+     * to t=100 with a 4 steps method and step size equal to 0.2. If an event\n+     * resets the state at t=0.5, the start phase will not end at t=0.7 with\n+     * steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps\n+     * at [0.5, 0.7, 0.9, 1.1].</p>\n+     * <p>A side effect of the need for smoothness is that an ODE triggering\n+     * short period regular resets will remain in the start phase throughout\n+     * the integration range if the step size or the number of steps to store\n+     * are too large.</p>\n+     * <p>If the start phase ends prematurely (because of some triggered event\n+     * for example), then the time of latest previous steps will be set to\n+     * <code>Double.NaN</code>.</p>\n+     * @param n number of steps to store\n+     * @param h signed step size to use for the first steps\n+     * @param manager discrete events manager to use\n+     * @param equations differential equations to integrate\n+     * @param t0 initial time\n+     * @param y state vector: contains the initial value of the state vector at t0,\n+     * will be used to put the state vector at each successful step and hence\n+     * contains the final value at the end of the start phase\n+     * @return time of the end of the start phase\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    protected double start(final int n, final double h,\n+                           final CombinedEventsManager manager,\n+                           final FirstOrderDifferentialEquations equations,\n+                           final double t0, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        // clear the first steps\n+        Arrays.fill(previousT, Double.NaN);\n+        Arrays.fill(previousF, null);\n+\n+        // configure the event handlers\n+        starter.clearEventHandlers();\n+        for (EventState state : manager.getEventsStates()) {\n+            starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),\n+                                    state.getMaxCheckInterval(),\n+                                    state.getConvergence(), state.getMaxIterationCount());\n+        }\n+\n+        // configure the step handlers\n+        starter.clearStepHandlers();\n+        for (final StepHandler handler : stepHandlers) {\n+            // add the user defined step handlers, filtering out the isLast indicator\n+            starter.addStepHandler(new FilteringWrapper(handler));\n+        }\n+\n+        // add one specific step handler to store the first steps\n+        final StoringStepHandler store = new StoringStepHandler(n);\n+        starter.addStepHandler(new StepNormalizer(h, store));\n+\n+        // integrate over the first few steps, ensuring no intermediate reset occurs\n+        double t = t0;\n+        double stopTime = Double.NaN;\n+        do {\n+            resetTime = Double.NaN;\n+            store.restart();\n+            // we overshoot by 1/10000 step the end to make sure we get don't miss the last point\n+            stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);\n+            if (!Double.isNaN(resetTime)) {\n+                // there was an intermediate reset, we restart\n+                t = resetTime;\n+            }\n+        } while (!Double.isNaN(resetTime));\n+\n+        // clear configuration\n+        starter.clearEventHandlers();\n+        starter.clearStepHandlers();\n+\n+        if (store.getFinalState() != null) {\n+            System.arraycopy(store.getFinalState(), 0, y, 0, y.length);\n+        }\n+        return stopTime;\n+\n+    }\n+\n+    /** Rotate the previous steps arrays.\n+     */\n+    protected void rotatePreviousSteps() {\n+        final double[] rolled = previousF[previousT.length - 1];\n+        for (int k = previousF.length - 1; k > 0; --k) {\n+            previousT[k] = previousT[k - 1];\n+            previousF[k] = previousF[k - 1];\n+        }\n+        previousF[0] = rolled;\n+    }\n+\n+    /** Event handler wrapper to check if state or derivatives have been reset. */\n+    private class ResetCheckingWrapper implements EventHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4922660285376467937L;\n+\n+        /** Wrapped event handler. */\n+        private final EventHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler event handler to wrap\n+         */\n+        public ResetCheckingWrapper(final EventHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y) throws EventException {\n+            final int action = handler.eventOccurred(t, y);\n+            if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {\n+                // a singularity has been encountered\n+                // we need to restart the start phase\n+                resetTime = t;\n+                return STOP;\n+            }\n+            return action;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) throws EventException {\n+            return handler.g(t, y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) throws EventException {\n+            handler.resetState(t, y);\n+        }\n+        \n+    }\n+\n+    /** Step handler wrapper filtering out the isLast indicator. */\n+    private class FilteringWrapper implements StepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4607975253344802232L;\n+\n+        /** Wrapped step handler. */\n+        private final StepHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler step handler to wrap\n+         */\n+        public FilteringWrapper(final StepHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws DerivativeException {\n+            // we force the isLast indicator to false EXCEPT if some event handler triggered a stop\n+            handler.handleStep(interpolator, eventsHandlersManager.stop());\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return handler.requiresDenseOutput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            handler.reset();\n+        }\n+        \n+    }\n+\n+    /** Specialized step handler storing the first few steps. */\n+    private class StoringStepHandler implements FixedStepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4592974435520688797L;\n+\n+        /** Number of steps to store. */\n+        private final int n;\n+\n+        /** Counter for already stored steps. */\n+        private int count;\n+\n+        /** Final state. */\n+        private double[] finalState;\n+\n+        /** Build a new instance.\n+         * @param number of steps to store\n+         */\n+        public StoringStepHandler(final int n) {\n+            this.n = n;\n+            restart();\n+        }\n+\n+        /** Restart storage.\n+         */\n+        public void restart() {\n+            count = 0;\n+            finalState = null;\n+        }\n+\n+        /** Get the final state.\n+         * @return final state\n+         */\n+        public double[] getFinalState() {\n+            return finalState;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(final double t, final double[] y, final double[] yDot,\n+                               final boolean isLast) {\n+            if (count++ < n) {\n+                previousT[n - count] = t;\n+                previousF[n - count] = yDot.clone();\n+                if (count == n) {\n+                    finalState = y.clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MultistepStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for multistep integrators.\n+ *\n+ * @see MultistepIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+abstract class MultistepStepInterpolator\n+    extends AbstractStepInterpolator {\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link #reinitialize} method should be called before using the\n+     * instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases. The {@link MultistepIntegrator} classe uses the\n+     * prototyping design pattern to create the step interpolators by\n+     * cloning an uninitialized model and latter initializing the copy.\n+     */\n+    protected MultistepStepInterpolator() {\n+        previousT = null;\n+        previousF = null;\n+    }\n+\n+    /** Copy constructor.\n+\n+     * <p>The copied interpolator should have been finalized before the\n+     * copy, otherwise the copy will not be able to perform correctly any\n+     * interpolation and will throw a {@link NullPointerException}\n+     * later. Since we don't want this constructor to throw the\n+     * exceptions finalization may involve and since we don't want this\n+     * method to modify the state of the copied interpolator,\n+     * finalization is <strong>not</strong> done automatically, it\n+     * remains under user control.</p>\n+\n+     * <p>The copy is a deep copy: its arrays are separated from the\n+     * original arrays of the instance.</p>\n+\n+     * @param interpolator interpolator to copy from.\n+\n+     */\n+    public MultistepStepInterpolator(final MultistepStepInterpolator interpolator) {\n+\n+        super(interpolator);\n+\n+        if (interpolator.currentState != null) {\n+            previousT = interpolator.previousT.clone();\n+            previousF = new double[interpolator.previousF.length][];\n+            for (int k = 0; k < interpolator.previousF.length; ++k) {\n+                previousF[k] = interpolator.previousF[k].clone();\n+            }\n+            initializeCoefficients();\n+        } else {\n+            previousT = null;\n+            previousF = null;\n+        }\n+\n+    }\n+\n+    /** Reinitialize the instance\n+     * @param y reference to the integrator array holding the state at\n+     * the end of the step\n+     * @param previousT reference to the integrator array holding the times\n+     * of the previous steps\n+     * @param previousF reference to the integrator array holding the\n+     * previous slopes\n+     * @param forward integration direction indicator\n+     */\n+    public void reinitialize(final double[] y,\n+                             final double[] previousT, final double[][] previousF,\n+                             final boolean forward) {\n+        reinitialize(y, forward);\n+        this.previousT = previousT;\n+        this.previousF = previousF;\n+        initializeCoefficients();\n+    }\n+\n+    /** Initialize the coefficients arrays.\n+     */\n+    protected abstract void initializeCoefficients();\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+        // save the state of the base class\n+        writeBaseExternal(out);\n+\n+        // save the local attributes\n+        out.writeInt(previousT.length);\n+        for (int k = 0; k < previousF.length; ++k) {\n+            out.writeDouble(previousT[k]);\n+            for (int i = 0; i < currentState.length; ++i) {\n+                out.writeDouble(previousF[k][i]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+        // read the base class \n+        final double t = readBaseExternal(in);\n+\n+        // read the local attributes\n+        final int kMax = in.readInt();\n+        previousT = new double[kMax];\n+        previousF = new double[kMax][];\n+        for (int k = 0; k < kMax; ++k) {\n+            previousT[k] = in.readDouble();\n+            previousF[k] = new double[currentState.length];\n+            for (int i = 0; i < currentState.length; ++i) {\n+                previousF[k][i] = in.readDouble();\n+            }\n+        }\n+\n+        // initialize the coefficients\n+        initializeCoefficients();\n+\n+        try {\n+            // we can now set the interpolated time and state\n+            setInterpolatedTime(t);\n+        } catch (DerivativeException e) {\n+            throw new IOException(e.getMessage());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+public class AdamsBashforthIntegratorTest\n+  extends TestCase {\n+\n+  public AdamsBashforthIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testCoefficients() {\n+\n+      double[] coeffs1 = new AdamsBashforthIntegrator(1, 0.01).getCoeffs();\n+      assertEquals(1, coeffs1.length);\n+      assertEquals(1.0, coeffs1[0], 1.0e-16);\n+\n+      double[] coeffs2 = new AdamsBashforthIntegrator(2, 0.01).getCoeffs();\n+      assertEquals(2, coeffs2.length);\n+      assertEquals( 3.0 / 2.0, coeffs2[0], 1.0e-16);\n+      assertEquals(-1.0 / 2.0, coeffs2[1], 1.0e-16);\n+\n+      double[] coeffs3 = new AdamsBashforthIntegrator(3, 0.01).getCoeffs();\n+      assertEquals(3, coeffs3.length);\n+      assertEquals( 23.0 / 12.0, coeffs3[0], 1.0e-16);\n+      assertEquals(-16.0 / 12.0, coeffs3[1], 1.0e-16);\n+      assertEquals(  5.0 / 12.0, coeffs3[2], 1.0e-16);\n+\n+      double[] coeffs4 = new AdamsBashforthIntegrator(4, 0.01).getCoeffs();\n+      assertEquals(4, coeffs4.length);\n+      assertEquals( 55.0 / 24.0, coeffs4[0], 1.0e-16);\n+      assertEquals(-59.0 / 24.0, coeffs4[1], 1.0e-16);\n+      assertEquals( 37.0 / 24.0, coeffs4[2], 1.0e-16);\n+      assertEquals( -9.0 / 24.0, coeffs4[3], 1.0e-16);\n+\n+      double[] coeffs5 = new AdamsBashforthIntegrator(5, 0.01).getCoeffs();\n+      assertEquals(5, coeffs5.length);\n+      assertEquals( 1901.0 / 720.0, coeffs5[0], 1.0e-16);\n+      assertEquals(-2774.0 / 720.0, coeffs5[1], 1.0e-16);\n+      assertEquals( 2616.0 / 720.0, coeffs5[2], 1.0e-16);\n+      assertEquals(-1274.0 / 720.0, coeffs5[3], 1.0e-16);\n+      assertEquals(  251.0 / 720.0, coeffs5[4], 1.0e-16);\n+\n+      double[] coeffs6 = new AdamsBashforthIntegrator(6, 0.01).getCoeffs();\n+      assertEquals(6, coeffs6.length);\n+      assertEquals( 4277.0 / 1440.0, coeffs6[0], 1.0e-16);\n+      assertEquals(-7923.0 / 1440.0, coeffs6[1], 1.0e-16);\n+      assertEquals( 9982.0 / 1440.0, coeffs6[2], 1.0e-16);\n+      assertEquals(-7298.0 / 1440.0, coeffs6[3], 1.0e-16);\n+      assertEquals( 2877.0 / 1440.0, coeffs6[4], 1.0e-16);\n+      assertEquals( -475.0 / 1440.0, coeffs6[5], 1.0e-16);\n+\n+      double[] coeffs7 = new AdamsBashforthIntegrator(7, 0.01).getCoeffs();\n+      assertEquals(7, coeffs7.length);\n+      assertEquals( 198721.0 / 60480.0, coeffs7[0], 1.0e-16);\n+      assertEquals(-447288.0 / 60480.0, coeffs7[1], 1.0e-16);\n+      assertEquals( 705549.0 / 60480.0, coeffs7[2], 1.0e-16);\n+      assertEquals(-688256.0 / 60480.0, coeffs7[3], 1.0e-16);\n+      assertEquals( 407139.0 / 60480.0, coeffs7[4], 1.0e-16);\n+      assertEquals(-134472.0 / 60480.0, coeffs7[5], 1.0e-16);\n+      assertEquals(  19087.0 / 60480.0, coeffs7[6], 1.0e-16);\n+\n+      double[] coeffs8 = new AdamsBashforthIntegrator(8, 0.01).getCoeffs();\n+      assertEquals(8, coeffs8.length);\n+      assertEquals(  434241.0 / 120960.0, coeffs8[0], 1.0e-16);\n+      assertEquals(-1152169.0 / 120960.0, coeffs8[1], 1.0e-16);\n+      assertEquals( 2183877.0 / 120960.0, coeffs8[2], 1.0e-16);\n+      assertEquals(-2664477.0 / 120960.0, coeffs8[3], 1.0e-16);\n+      assertEquals( 2102243.0 / 120960.0, coeffs8[4], 1.0e-16);\n+      assertEquals(-1041723.0 / 120960.0, coeffs8[5], 1.0e-16);\n+      assertEquals(  295767.0 / 120960.0, coeffs8[6], 1.0e-16);\n+      assertEquals(  -36799.0 / 120960.0, coeffs8[7], 1.0e-16);\n+\n+      double[] coeffs9 = new AdamsBashforthIntegrator(9, 0.01).getCoeffs();\n+      assertEquals(9, coeffs9.length);\n+      assertEquals(  14097247.0 / 3628800.0, coeffs9[0], 1.0e-16);\n+      assertEquals( -43125206.0 / 3628800.0, coeffs9[1], 1.0e-16);\n+      assertEquals(  95476786.0 / 3628800.0, coeffs9[2], 1.0e-16);\n+      assertEquals(-139855262.0 / 3628800.0, coeffs9[3], 1.0e-16);\n+      assertEquals( 137968480.0 / 3628800.0, coeffs9[4], 1.0e-16);\n+      assertEquals( -91172642.0 / 3628800.0, coeffs9[5], 1.0e-16);\n+      assertEquals(  38833486.0 / 3628800.0, coeffs9[6], 1.0e-16);\n+      assertEquals(  -9664106.0 / 3628800.0, coeffs9[7], 1.0e-16);\n+      assertEquals(   1070017.0 / 3628800.0, coeffs9[8], 1.0e-16);\n+\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new AdamsBashforthIntegrator(3, 0.01).integrate(pb,\n+                                                      0.0, new double[pb.getDimension()+10],\n+                                                      1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 6; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+          assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 6) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-9);\n+   assertTrue(handler.getMaximalValueError() < 3.0e-8);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+   assertEquals(\"Adams-Bashforth\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.05);\n+    assertTrue(handler.getMaximalValueError() > 0.1);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(AdamsBashforthIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class AdamsMoultonIntegratorTest\n+  extends TestCase {\n+\n+    public AdamsMoultonIntegratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testPredictorCoefficients() {\n+        for (int order = 1; order < 10; ++order) {\n+            double[] moulton = new AdamsMoultonIntegrator(order, 0.01).getPredictorCoeffs();\n+            double[] bashforth  = new AdamsBashforthIntegrator(order, 0.01).getCoeffs();\n+            assertEquals(bashforth.length, moulton.length);\n+            for (int i = 0; i < moulton.length; ++i) {\n+                assertEquals(bashforth[i], moulton[i], 1.0e-16);\n+            }\n+        }\n+    }\n+\n+    public void testCorrectorCoefficients() {\n+\n+        double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs();\n+        assertEquals(2, coeffs1.length);\n+        assertEquals(1.0 / 2.0, coeffs1[0], 1.0e-16);\n+        assertEquals(1.0 / 2.0, coeffs1[1], 1.0e-16);\n+\n+        double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs();\n+        assertEquals(3, coeffs2.length);\n+        assertEquals( 5.0 / 12.0, coeffs2[0], 1.0e-16);\n+        assertEquals( 8.0 / 12.0, coeffs2[1], 1.0e-16);\n+        assertEquals(-1.0 / 12.0, coeffs2[2], 1.0e-16);\n+\n+        double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs();\n+        assertEquals(4, coeffs3.length);\n+        assertEquals( 9.0 / 24.0, coeffs3[0], 1.0e-16);\n+        assertEquals(19.0 / 24.0, coeffs3[1], 1.0e-16);\n+        assertEquals(-5.0 / 24.0, coeffs3[2], 1.0e-16);\n+        assertEquals( 1.0 / 24.0, coeffs3[3], 1.0e-16);\n+\n+        double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs();\n+        assertEquals(5, coeffs4.length);\n+        assertEquals( 251.0 / 720.0, coeffs4[0], 1.0e-16);\n+        assertEquals( 646.0 / 720.0, coeffs4[1], 1.0e-16);\n+        assertEquals(-264.0 / 720.0, coeffs4[2], 1.0e-16);\n+        assertEquals( 106.0 / 720.0, coeffs4[3], 1.0e-16);\n+        assertEquals( -19.0 / 720.0, coeffs4[4], 1.0e-16);\n+\n+        double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs();\n+        assertEquals(6, coeffs5.length);\n+        assertEquals( 475.0 / 1440.0, coeffs5[0], 1.0e-16);\n+        assertEquals(1427.0 / 1440.0, coeffs5[1], 1.0e-16);\n+        assertEquals(-798.0 / 1440.0, coeffs5[2], 1.0e-16);\n+        assertEquals( 482.0 / 1440.0, coeffs5[3], 1.0e-16);\n+        assertEquals(-173.0 / 1440.0, coeffs5[4], 1.0e-16);\n+        assertEquals(  27.0 / 1440.0, coeffs5[5], 1.0e-16);\n+\n+        double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs();\n+        assertEquals(7, coeffs6.length);\n+        assertEquals( 19087.0 / 60480.0, coeffs6[0], 1.0e-16);\n+        assertEquals( 65112.0 / 60480.0, coeffs6[1], 1.0e-16);\n+        assertEquals(-46461.0 / 60480.0, coeffs6[2], 1.0e-16);\n+        assertEquals( 37504.0 / 60480.0, coeffs6[3], 1.0e-16);\n+        assertEquals(-20211.0 / 60480.0, coeffs6[4], 1.0e-16);\n+        assertEquals(  6312.0 / 60480.0, coeffs6[5], 1.0e-16);\n+        assertEquals(  -863.0 / 60480.0, coeffs6[6], 1.0e-16);\n+\n+        double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs();\n+        assertEquals(8, coeffs7.length);\n+        assertEquals(  36799.0 / 120960.0, coeffs7[0], 1.0e-16);\n+        assertEquals( 139849.0 / 120960.0, coeffs7[1], 1.0e-16);\n+        assertEquals(-121797.0 / 120960.0, coeffs7[2], 1.0e-16);\n+        assertEquals( 123133.0 / 120960.0, coeffs7[3], 1.0e-16);\n+        assertEquals( -88547.0 / 120960.0, coeffs7[4], 1.0e-16);\n+        assertEquals(  41499.0 / 120960.0, coeffs7[5], 1.0e-16);\n+        assertEquals( -11351.0 / 120960.0, coeffs7[6], 1.0e-16);\n+        assertEquals(   1375.0 / 120960.0, coeffs7[7], 1.0e-16);\n+\n+        double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs();\n+        assertEquals(9, coeffs8.length);\n+        assertEquals( 1070017.0 / 3628800.0, coeffs8[0], 1.0e-16);\n+        assertEquals( 4467094.0 / 3628800.0, coeffs8[1], 1.0e-16);\n+        assertEquals(-4604594.0 / 3628800.0, coeffs8[2], 1.0e-16);\n+        assertEquals( 5595358.0 / 3628800.0, coeffs8[3], 1.0e-16);\n+        assertEquals(-5033120.0 / 3628800.0, coeffs8[4], 1.0e-16);\n+        assertEquals( 3146338.0 / 3628800.0, coeffs8[5], 1.0e-16);\n+        assertEquals(-1291214.0 / 3628800.0, coeffs8[6], 1.0e-16);\n+        assertEquals(  312874.0 / 3628800.0, coeffs8[7], 1.0e-16);\n+        assertEquals(  -33953.0 / 3628800.0, coeffs8[8], 1.0e-16);\n+\n+    }\n+\n+    public void testDimensionCheck() {\n+        try  {\n+            TestProblem1 pb = new TestProblem1();\n+            new AdamsMoultonIntegrator(3, 0.01).integrate(pb,\n+                    0.0, new double[pb.getDimension()+10],\n+                    1.0, new double[pb.getDimension()+10]);\n+            fail(\"an exception should have been thrown\");\n+        } catch(DerivativeException de) {\n+            fail(\"wrong exception caught\");\n+        } catch(IntegratorException ie) {\n+        }\n+    }\n+\n+    public void testDecreasingSteps()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+                if (pb instanceof TestProblem3) {\n+                    step /= 8;\n+                }\n+\n+                FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                            Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if (i > 6) {\n+                    assertTrue(error < Math.abs(previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    public void testSmallStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 7.0e-12);\n+        assertTrue(handler.getMaximalValueError() < 4.0e-11);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+\n+    }\n+\n+    public void testBigStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() > 0.01);\n+        assertTrue(handler.getMaximalValueError() > 0.03);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(AdamsMoultonIntegratorTest.class);\n+    }\n+\n+}", "timestamp": 1216070003, "metainfo": ""}