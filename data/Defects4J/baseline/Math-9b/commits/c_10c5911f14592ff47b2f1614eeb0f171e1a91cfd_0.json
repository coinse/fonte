{"sha": "10c5911f14592ff47b2f1614eeb0f171e1a91cfd", "log": "added FastMath.hypot JIRA: MATH-478  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n      * @param y a value\n      * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n      */\n-    public static double hypot(double x, double y) {\n-        return StrictMath.hypot(x, y); // TODO provide our own implementation\n+    public static double hypot(final double x, final double y) {\n+        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n+            return Double.POSITIVE_INFINITY;\n+        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n+            return Double.NaN;\n+        } else {\n+\n+            final int expX = getExponent(x);\n+            final int expY = getExponent(y);\n+            if (expX > expY + 27) {\n+                // y is neglectible with respect to x\n+                return abs(x);\n+            } else if (expY > expX + 27) {\n+                // x is neglectible with respect to y\n+                return abs(y);\n+            } else {\n+\n+                // find an intermediate scale to avoid both overflow and underflow\n+                final int middleExp = (expX + expY) / 2;\n+\n+                // scale parameters without losing precision\n+                final double scaledX = scalb(x, -middleExp);\n+                final double scaledY = scalb(y, -middleExp);\n+\n+                // compute scaled hypotenuse\n+                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n+\n+                // remove scaling\n+                return scalb(scaledH, middleExp);\n+\n+            }\n+\n+        }\n     }\n \n     /**", "timestamp": 1295822270, "metainfo": ""}