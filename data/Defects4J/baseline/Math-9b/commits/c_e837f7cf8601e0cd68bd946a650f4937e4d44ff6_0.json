{"sha": "e837f7cf8601e0cd68bd946a650f4937e4d44ff6", "log": "tighten rules for public/private/abstract/final/... modifiers  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n      *\n      * @param count maximum number of iterations\n      */\n-    public abstract void setMaximalIterationCount(int count);\n+    void setMaximalIterationCount(int count);\n \n     /**\n      * Get the upper limit for the number of iterations.\n      *\n      * @return the actual upper limit\n      */\n-    public abstract int getMaximalIterationCount();\n+    int getMaximalIterationCount();\n \n     /**\n      * Reset the upper limit for the number of iterations to the default.\n      *\n      * @see #setMaximalIterationCount(int)\n      */\n-    public abstract void resetMaximalIterationCount();\n+    void resetMaximalIterationCount();\n \n     /**\n      * Set the absolute accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n      * the solver or is otherwise deemed unreasonable.\n      */\n-    public abstract void setAbsoluteAccuracy(double accuracy);\n+    void setAbsoluteAccuracy(double accuracy);\n \n     /**\n      * Get the actual absolute accuracy.\n      *\n      * @return the accuracy\n      */\n-    public abstract double getAbsoluteAccuracy();\n+    double getAbsoluteAccuracy();\n \n     /**\n      * Reset the absolute accuracy to the default.\n      * <p>\n      * The default value is provided by the algorithm implementation.</p>\n      */\n-    public abstract void resetAbsoluteAccuracy();\n+    void resetAbsoluteAccuracy();\n \n     /**\n      * Set the relative accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n      *  the algorithm or is otherwise deemed unreasonable.\n      */\n-    public abstract void setRelativeAccuracy(double accuracy);\n+    void setRelativeAccuracy(double accuracy);\n \n     /**\n      * Get the actual relative accuracy.\n      * @return the accuracy\n      */\n-    public abstract double getRelativeAccuracy();\n+    double getRelativeAccuracy();\n \n     /**\n      * Reset the relative accuracy to the default.\n      * The default value is provided by the algorithm implementation.\n      */\n-    public abstract void resetRelativeAccuracy();\n+    void resetRelativeAccuracy();\n \n     /**\n      * Get the number of iterations in the last run of the algorithm.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n-    public abstract int getIterationCount();\n+    int getIterationCount();\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateMatrixFunction.java\n      *\n      * @return  the derivative function\n      */\n-    public UnivariateMatrixFunction derivative();\n+    UnivariateMatrixFunction derivative();\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateRealFunction.java\n      *\n      * @return  the derivative function\n      */\n-    public UnivariateRealFunction derivative();\n+    UnivariateRealFunction derivative();\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateVectorialFunction.java\n      *\n      * @return  the derivative function\n      */\n-    public UnivariateVectorialFunction derivative();\n+    UnivariateVectorialFunction derivative();\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n  * @since 2.0\n  */\n public interface UnivariateMatrixFunction {\n+\n     /**\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n      * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double[][] value(double x) throws FunctionEvaluationException;\n+    double[][] value(double x) throws FunctionEvaluationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealFunction {\n+\n     /**\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n      * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double value(double x) throws FunctionEvaluationException;\n+    double value(double x) throws FunctionEvaluationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n  * @since 2.0\n  */\n public interface UnivariateVectorialFunction {\n+\n     /**\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n      * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double[] value(double x) throws FunctionEvaluationException;\n+    double[] value(double x) throws FunctionEvaluationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n      * @throws MathException if arguments violate assumptions made by the\n      *         interpolationg algorithm\n      */\n-    public UnivariateRealFunction interpolate(double xval[], double yval[])\n+    UnivariateRealFunction interpolate(double xval[], double yval[])\n         throws MathException;\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n-    abstract public double cumulativeProbability(int x) throws MathException;\n+    public abstract double cumulativeProbability(int x) throws MathException;\n \n     /**\n      * For a random variable X whose values are distributed according\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface HypergeometricDistribution extends IntegerDistribution {\n+\n     /**\n      * Access the number of successes.\n      * @return the number of successes.\n      */\n-    public abstract int getNumberOfSuccesses();\n+    int getNumberOfSuccesses();\n \n     /**\n      * Access the population size.\n      * @return the population size.\n      */\n-    public abstract int getPopulationSize();\n+    int getPopulationSize();\n \n     /**\n      * Access the sample size.\n      * @return the sample size.\n      */\n-    public abstract int getSampleSize();\n+    int getSampleSize();\n \n     /**\n      * Modify the number of successes.\n      * @param num the new number of successes.\n      */\n-    public abstract void setNumberOfSuccesses(int num);\n+    void setNumberOfSuccesses(int num);\n \n     /**\n      * Modify the population size.\n      * @param size the new population size.\n      */\n-    public abstract void setPopulationSize(int size);\n+    void setPopulationSize(int size);\n \n     /**\n      * Modify the sample size.\n      * @param size the new sample size.\n      */\n-    public abstract void setSampleSize(int size);\n+    void setSampleSize(int size);\n+\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n      *\n      * @return the mean for the distribution.\n      */\n-    public double getMean();\n+    double getMean();\n \n     /**\n      * Set the mean for the distribution.\n      * @param p the mean\n      * @throws IllegalArgumentException if p &le; 0\n      */\n-    public void setMean(double p);\n+    void setMean(double p);\n \n     /**\n      * Calculates the Poisson distribution function using a normal approximation.\n      * @return the distribution function value calculated using a normal approximation\n      * @throws MathException if an error occurs computing the normal approximation\n      */\n-    public double normalApproximateProbability(int x) throws MathException;\n+    double normalApproximateProbability(int x) throws MathException;\n+\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface ZipfDistribution extends IntegerDistribution {\n+\n     /**\n      * Get the number of elements (e.g. corpus size) for the distribution.\n      *\n      * @return the number of elements\n      */\n-    public int getNumberOfElements();\n+    int getNumberOfElements();\n \n     /**\n      * Set the number of elements (e.g. corpus size) for the distribution.\n      * @param n the number of elements\n      * @throws IllegalArgumentException if n &le; 0\n      */\n-    public void setNumberOfElements(int n);\n+    void setNumberOfElements(int n);\n \n     /**\n      * Get the exponent characterising the distribution.\n      *\n      * @return the exponent\n      */\n-    public double getExponent();\n+    double getExponent();\n \n     /**\n      * Set the exponent characterising the distribution.\n      * @param s the exponent\n      * @throws IllegalArgumentException if s &le; 0.0\n      */\n-    public void setExponent(double s);\n+    void setExponent(double s);\n+\n }\n--- a/src/main/java/org/apache/commons/math/estimation/EstimationProblem.java\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationProblem.java\n  */\n @Deprecated\n public interface EstimationProblem {\n-  /**\n-   * Get the measurements of an estimation problem.\n-   * @return measurements\n-   */\n-  public WeightedMeasurement[] getMeasurements();\n \n-  /**\n-   * Get the unbound parameters of the problem.\n-   * @return unbound parameters\n-   */\n-  public EstimatedParameter[] getUnboundParameters();\n+    /**\n+     * Get the measurements of an estimation problem.\n+     * @return measurements\n+     */\n+    WeightedMeasurement[] getMeasurements();\n \n-  /**\n-   * Get all the parameters of the problem.\n-   * @return parameters\n-   */\n-  public EstimatedParameter[] getAllParameters();\n+    /**\n+     * Get the unbound parameters of the problem.\n+     * @return unbound parameters\n+     */\n+    EstimatedParameter[] getUnboundParameters();\n+\n+    /**\n+     * Get all the parameters of the problem.\n+     * @return parameters\n+     */\n+    EstimatedParameter[] getAllParameters();\n \n }\n--- a/src/main/java/org/apache/commons/math/estimation/Estimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/Estimator.java\n    * @exception EstimationException if the problem cannot be solved\n    *\n    */\n-  public void estimate(EstimationProblem problem)\n-    throws EstimationException;\n+  void estimate(EstimationProblem problem) throws EstimationException;\n \n   /**\n    * Get the Root Mean Square value.\n    * @param problem estimation problem\n    * @return RMS value\n    */\n-  public double getRMS(EstimationProblem problem);\n+  double getRMS(EstimationProblem problem);\n \n   /**\n    * Get the covariance matrix of estimated parameters.\n    * @exception EstimationException if the covariance matrix\n    * cannot be computed (singular problem)\n    */\n-  public double[][] getCovariances(EstimationProblem problem)\n-    throws EstimationException;\n+  double[][] getCovariances(EstimationProblem problem) throws EstimationException;\n \n   /**\n    * Guess the errors in estimated parameters.\n    * @return errors in estimated parameters\n      * @exception EstimationException if the error cannot be guessed\n    */\n-  public double[] guessParametersErrors(EstimationProblem problem)\n-    throws EstimationException;\n+  double[] guessParametersErrors(EstimationProblem problem) throws EstimationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/genetics/Fitness.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Fitness.java\n  * @since 2.0\n  */\n public interface Fitness {\n+\n     /**\n      * Compute the fitness. This is usually very time-consuming, so the value\n      * should be cached.\n      *\n      * @return fitness\n      */\n-    public double fitness();\n+    double fitness();\n+\n }\n--- a/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n      *\n      * @param random random generator\n      */\n-    public synchronized static void setRandomGenerator(RandomGenerator random) {\n+    public static synchronized void setRandomGenerator(RandomGenerator random) {\n         randomGenerator = random;\n     }\n \n      *\n      * @return the static random generator shared by GA implementation classes\n      */\n-    public synchronized static RandomGenerator getRandomGenerator() {\n+    public static synchronized RandomGenerator getRandomGenerator() {\n         return randomGenerator;\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n      * @return permutation of <code>sequence</code> represented by this\n      *         permutation\n      */\n-    public List<T> decode(List<T> sequence);\n+    List<T> decode(List<T> sequence);\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrix.java\n      * @throws     IllegalArgumentException\n      *             if rowDimension(this) != columnDimension(m)\n      */\n-    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;\n+    BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n      * @throws     IllegalArgumentException\n      *             if rowDimension(this) != columnDimension(m)\n      */\n-    public FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+    FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws IllegalArgumentException;\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n--- a/src/main/java/org/apache/commons/math/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java\n      * @return a vector containing this[i] * v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n-        throws IllegalArgumentException;\n+    FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element multiplication.\n      * @return a vector containing this[i] * v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public FieldVector<T> ebeMultiply(T[] v)\n-        throws IllegalArgumentException;\n+    FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element division.\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public FieldVector<T> ebeDivide(FieldVector<T> v)\n-        throws IllegalArgumentException;\n+    FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element division.\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public FieldVector<T> ebeDivide(T[] v)\n-        throws IllegalArgumentException;\n+    FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException;\n \n     /**\n      * Returns vector entries as a T array.\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n      * @throws     IllegalArgumentException\n      *             if rowDimension(this) != columnDimension(m)\n      */\n-    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;\n+    RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n      * @return a vector containing this[i] * v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public RealVector ebeMultiply(RealVector v)\n-        throws IllegalArgumentException;\n+    RealVector ebeMultiply(RealVector v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element multiplication.\n      * @return a vector containing this[i] * v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public RealVector ebeMultiply(double[] v)\n-        throws IllegalArgumentException;\n+    RealVector ebeMultiply(double[] v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element division.\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public RealVector ebeDivide(RealVector v)\n-        throws IllegalArgumentException;\n+    RealVector ebeDivide(RealVector v) throws IllegalArgumentException;\n \n     /**\n      * Element-by-element division.\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public RealVector ebeDivide(double[] v)\n-        throws IllegalArgumentException;\n+    RealVector ebeDivide(double[] v) throws IllegalArgumentException;\n \n     /**\n      * Returns vector entries as a double array.\n      * Returns true if any coordinate of this vector is NaN; false otherwise\n      * @return  true if any coordinate of this vector is NaN; false otherwise\n      */\n-    public boolean isNaN();\n+    boolean isNaN();\n \n     /**\n      * Returns true if any coordinate of this vector is infinite and none are NaN;\n      * @return  true if any coordinate of this vector is infinite and none are NaN;\n      * false otherwise\n      */\n-    public boolean isInfinite();\n+    boolean isInfinite();\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n     /** Get the dimension of the problem.\n      * @return dimension of the problem\n      */\n-    public int getDimension();\n+    int getDimension();\n \n     /** Get the current time derivative of the state vector.\n      * @param t current value of the independent <I>time</I> variable\n      * @throws DerivativeException this exception is propagated to the caller if the\n      * underlying user function triggers one\n      */\n-    public void computeDerivatives(double t, double[] y, double[] yDot)\n-    throws DerivativeException;\n+    void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n    * @throws DerivativeException this exception is propagated to the caller if\n    * the underlying user function triggers one\n    */\n-  public double integrate (FirstOrderDifferentialEquations equations,\n-                           double t0, double[] y0,\n-                           double t, double[] y)\n-    throws DerivativeException, IntegratorException;\n+  double integrate (FirstOrderDifferentialEquations equations,\n+                    double t0, double[] y0,\n+                    double t, double[] y) throws DerivativeException, IntegratorException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n \n public interface SecondOrderDifferentialEquations {\n \n-  /** Get the dimension of the problem.\n-   * @return dimension of the problem\n-   */\n-  public int getDimension();\n+    /** Get the dimension of the problem.\n+     * @return dimension of the problem\n+     */\n+    int getDimension();\n \n-  /** Get the current time derivative of the state vector.\n-   * @param t current value of the independent <I>time</I> variable\n-   * @param y array containing the current value of the state vector\n-   * @param yDot array containing the current value of the first derivative\n-   * of the state vector\n-   * @param yDDot placeholder array where to put the second time derivative\n-   * of the state vector\n-   * @throws DerivativeException this exception is propagated to the caller if the\n-   * underlying user function triggers one\n-   */\n-  public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n-                                       double[] yDDot)\n-  throws DerivativeException;\n+    /** Get the current time derivative of the state vector.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot array containing the current value of the first derivative\n+     * of the state vector\n+     * @param yDDot placeholder array where to put the second time derivative\n+     * of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                  double[] yDDot) throws DerivativeException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n-  public void integrate(SecondOrderDifferentialEquations equations,\n-                        double t0, double[] y0, double[] yDot0,\n-                        double t, double[] y, double[] yDot)\n-  throws DerivativeException, IntegratorException;\n+  void integrate(SecondOrderDifferentialEquations equations,\n+                 double t0, double[] y0, double[] yDot0,\n+                 double t, double[] y, double[] yDot)\n+      throws DerivativeException, IntegratorException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/events/EventHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventHandler.java\n    * #eventOccurred eventOccurred} method when the integration should be\n    * stopped after the event ending the current step.</p>\n    */\n-  public static final int STOP = 0;\n+  int STOP = 0;\n \n   /** Reset state indicator.\n    * <p>This value should be used as the return value of the {@link\n    * vector (which will be retrieved thanks to the {@link #resetState\n    * resetState} method).</p>\n    */\n-  public static final int RESET_STATE = 1;\n+  int RESET_STATE = 1;\n \n   /** Reset derivatives indicator.\n    * <p>This value should be used as the return value of the {@link\n    * org.apache.commons.math.ode.FirstOrderDifferentialEquations#computeDerivatives}\n    * method).</p>\n    */\n-  public static final int RESET_DERIVATIVES = 2;\n+  int RESET_DERIVATIVES = 2;\n \n   /** Continue indicator.\n    * <p>This value should be used as the return value of the {@link\n    * #eventOccurred eventOccurred} method when the integration should go\n    * on after the event ending the current step.</p>\n    */\n-  public static final int CONTINUE = 3;\n+  int CONTINUE = 3;\n \n   /** Compute the value of the switching function.\n \n    * @return value of the g switching function\n    * @exception EventException if the switching function cannot be evaluated\n    */\n-  public double g(double t, double[] y) throws EventException;\n+  double g(double t, double[] y) throws EventException;\n \n   /** Handle an event and choose what to do next.\n \n    * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n    * @exception EventException if the event occurrence triggers an error\n    */\n-  public int eventOccurred(double t, double[] y, boolean increasing) throws EventException;\n+  int eventOccurred(double t, double[] y, boolean increasing) throws EventException;\n \n   /** Reset the state prior to continue the integration.\n \n    * the new state should be put in the same array\n    * @exception EventException if the state cannot be reseted\n    */\n-  public void resetState(double t, double[] y) throws EventException;\n+  void resetState(double t, double[] y) throws EventException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n    * @param isLast true if the step is the last one\n    * @throws DerivativeException if some error condition is encountered\n    */\n-  public void handleStep(double t, double[] y, double[] yDot, boolean isLast)\n-      throws DerivativeException;\n+  void handleStep(double t, double[] y, double[] yDot, boolean isLast) throws DerivativeException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n    * than a custom interpolator.</p>\n    * @return true if the handler needs dense output\n    */\n-  public boolean requiresDenseOutput();\n+  boolean requiresDenseOutput();\n \n   /** Reset the step handler.\n    * Initialize the internal data as required before the first step is\n    * handled.\n    */\n-  public void reset();\n+  void reset();\n \n   /**\n    * Handle the last accepted step\n    * @throws DerivativeException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n-  public void handleStep(StepInterpolator interpolator, boolean isLast)\n-    throws DerivativeException;\n+  void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException;\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n  * @since 1.2\n  */\n \n-public interface StepInterpolator\n-  extends Externalizable {\n+public interface StepInterpolator extends Externalizable {\n \n   /**\n    * Get the previous grid point time.\n    * @return previous grid point time\n    */\n-  public double getPreviousTime();\n+  double getPreviousTime();\n \n   /**\n    * Get the current grid point time.\n    * @return current grid point time\n    */\n-  public double getCurrentTime();\n+  double getCurrentTime();\n \n   /**\n    * Get the time of the interpolated point.\n    * the current grid point time.\n    * @return interpolation point time\n    */\n-  public double getInterpolatedTime();\n+  double getInterpolatedTime();\n \n   /**\n    * Set the time of the interpolated point.\n    * created using {@link #copy()}.</p>\n    * @param time time of the interpolated point\n    */\n-  public void setInterpolatedTime(double time);\n+  void setInterpolatedTime(double time);\n \n   /**\n    * Get the state vector of the interpolated point.\n    * @throws DerivativeException if this call induces an automatic\n    * step finalization that throws one\n    */\n-  public double[] getInterpolatedState()\n-      throws DerivativeException;\n+  double[] getInterpolatedState() throws DerivativeException;\n \n   /**\n    * Get the derivatives of the state vector of the interpolated point.\n    * step finalization that throws one\n    * @since 2.0\n    */\n-  public double[] getInterpolatedDerivatives()\n-      throws DerivativeException;\n+  double[] getInterpolatedDerivatives() throws DerivativeException;\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n    * @return true if the integration variable (time) increases during\n    * integration\n    */\n-  public boolean isForward();\n+  boolean isForward();\n \n   /** Copy the instance.\n    * <p>The copied instance is guaranteed to be independent from the\n    * step finalization that throws one\n    * @see #setInterpolatedTime(double)\n    */\n-   public StepInterpolator copy() throws DerivativeException;\n+   StepInterpolator copy() throws DerivativeException;\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n      * @return the value\n      * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double value(double x, double[] parameters)\n+    double value(double x, double[] parameters)\n         throws FunctionEvaluationException;\n \n     /**\n      * @return the value\n      * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double[] gradient(double x, double[] parameters)\n+    double[] gradient(double x, double[] parameters)\n         throws FunctionEvaluationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n      * @exception OptimizationException if the algorithm failed to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n-    abstract protected VectorialPointValuePair doOptimize()\n+    protected abstract VectorialPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n      * @exception OptimizationException if the algorithm failed to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n-    abstract protected RealPointValuePair doOptimize()\n+    protected abstract RealPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n      * @exception OptimizationException if no solution fulfilling the constraints\n      * can be found in the allowed number of iterations\n      */\n-    abstract protected RealPointValuePair doOptimize()\n+    protected abstract RealPointValuePair doOptimize()\n         throws OptimizationException;\n \n }\n--- a/src/main/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n    * standard deviation.</p>\n    * @return a random scalar with null mean and unit standard deviation\n    */\n-  public double nextNormalizedDouble();\n+  double nextNormalizedDouble();\n \n }\n--- a/src/main/java/org/apache/commons/math/random/RandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomVectorGenerator.java\n \n public interface RandomVectorGenerator {\n \n-  /** Generate a random vector.\n-   * @return a random vector as an array of double.\n-   */\n-  public double[] nextVector();\n+    /** Generate a random vector.\n+     * @return a random vector as an array of double.\n+     */\n+    double[] nextVector();\n \n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n  * @version $Revision$ $Date$\n  */\n public interface StatisticalMultivariateSummary {\n+\n     /**\n      * Returns the dimension of the data\n      * @return The dimension of the data\n      */\n-    public int getDimension();\n+    int getDimension();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * mean of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component means\n      */\n-    public abstract double[] getMean();\n+    double[] getMean();\n+\n     /**\n      * Returns the covariance of the available values.\n      * @return The covariance, null if no multivariate sample\n      * have been added or a zeroed matrix for a single value set.\n      */\n-    public abstract RealMatrix getCovariance();\n+    RealMatrix getCovariance();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * standard deviation of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component standard deviations\n      */\n-    public abstract double[] getStandardDeviation();\n+    double[] getStandardDeviation();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * maximum of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component maxima\n      */\n-    public abstract double[] getMax();\n+    double[] getMax();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * minimum of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component minima\n      */\n-    public abstract double[] getMin();\n+    double[] getMin();\n+\n     /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n-    public abstract long getN();\n+    long getN();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * geometric mean of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component geometric means\n      */\n-    public double[] getGeometricMean();\n+    double[] getGeometricMean();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component sums\n      */\n-    public abstract double[] getSum();\n+    double[] getSum();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of squares of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component sums of squares\n      */\n-    public abstract double[] getSumSq();\n+    double[] getSumSq();\n+\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of logs of the i<sup>th</sup> entries of the arrays\n      *\n      * @return the array of component log sums\n      */\n-    public abstract double[] getSumLog();\n+    double[] getSumLog();\n+\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n   * @version $Revision$ $Date$\n  */\n public interface StatisticalSummary {\n+\n     /**\n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n      * arithmetic mean </a> of the available values\n      * @return The mean or Double.NaN if no values have been added.\n      */\n-    public abstract double getMean();\n+    double getMean();\n     /**\n      * Returns the variance of the available values.\n      * @return The variance, Double.NaN if no values have been added\n      * or 0.0 for a single value set.\n      */\n-    public abstract double getVariance();\n+    double getVariance();\n     /**\n      * Returns the standard deviation of the available values.\n      * @return The standard deviation, Double.NaN if no values have been added\n      * or 0.0 for a single value set.\n      */\n-    public abstract double getStandardDeviation();\n+    double getStandardDeviation();\n     /**\n      * Returns the maximum of the available values\n      * @return The max or Double.NaN if no values have been added.\n      */\n-    public abstract double getMax();\n+    double getMax();\n     /**\n     * Returns the minimum of the available values\n     * @return The min or Double.NaN if no values have been added.\n     */\n-    public abstract double getMin();\n+    double getMin();\n     /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n-    public abstract long getN();\n+    long getN();\n     /**\n      * Returns the sum of the values that have been added to Univariate.\n      * @return The sum or Double.NaN if no values have been added\n      */\n-    public abstract double getSum();\n+    double getSum();\n+\n }\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n  * @version $Revision$ $Date$\n  */\n public interface OneWayAnova {\n+\n     /**\n      * Computes the ANOVA F-value for a collection of <code>double[]</code>\n      * arrays.\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaFValue(Collection<double[]> categoryData)\n+    double anovaFValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaPValue(Collection<double[]> categoryData)\n+    double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n-    */\n-    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n+     */\n+    boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException;\n \n }\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTest.java\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public abstract double pairedT(double[] sample1, double[] sample2)\n+    double pairedT(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Returns the <i>observed significance level</i>, or\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double pairedTTest(double[] sample1, double[] sample2)\n+    double pairedTTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Performs a paired t-test evaluating the null hypothesis that the\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    public abstract boolean pairedTTest(\n+    boolean pairedTTest(\n         double[] sample1,\n         double[] sample2,\n         double alpha)\n      * @return t statistic\n      * @throws IllegalArgumentException if input array length is less than 2\n      */\n-    public abstract double t(double mu, double[] observed)\n+    double t(double mu, double[] observed)\n         throws IllegalArgumentException;\n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public abstract double t(double mu, StatisticalSummary sampleStats)\n+    double t(double mu, StatisticalSummary sampleStats)\n         throws IllegalArgumentException;\n     /**\n      * Computes a 2-sample t statistic,  under the hypothesis of equal\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public abstract double homoscedasticT(double[] sample1, double[] sample2)\n+    double homoscedasticT(double[] sample1, double[] sample2)\n         throws IllegalArgumentException;\n     /**\n      * Computes a 2-sample t statistic, without the hypothesis of equal\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public abstract double t(double[] sample1, double[] sample2)\n+    double t(double[] sample1, double[] sample2)\n         throws IllegalArgumentException;\n     /**\n      * Computes a 2-sample t statistic </a>, comparing the means of the datasets\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public abstract double t(\n+    double t(\n         StatisticalSummary sampleStats1,\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException;\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public abstract double homoscedasticT(\n+    double homoscedasticT(\n         StatisticalSummary sampleStats1,\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException;\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double tTest(double mu, double[] sample)\n+    double tTest(double mu, double[] sample)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error computing the p-value\n      */\n-    public abstract boolean tTest(double mu, double[] sample, double alpha)\n+    boolean tTest(double mu, double[] sample, double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Returns the <i>observed significance level</i>, or\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double tTest(double mu, StatisticalSummary sampleStats)\n+    double tTest(double mu, StatisticalSummary sampleStats)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract boolean tTest(\n+    boolean tTest(\n         double mu,\n         StatisticalSummary sampleStats,\n         double alpha)\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double tTest(double[] sample1, double[] sample2)\n+    double tTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n      * Returns the <i>observed significance level</i>, or\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double homoscedasticTTest(\n+    double homoscedasticTTest(\n         double[] sample1,\n         double[] sample2)\n         throws IllegalArgumentException, MathException;\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    public abstract boolean tTest(\n+    boolean tTest(\n         double[] sample1,\n         double[] sample2,\n         double alpha)\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    public abstract boolean homoscedasticTTest(\n+    boolean homoscedasticTTest(\n         double[] sample1,\n         double[] sample2,\n         double alpha)\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double tTest(\n+    double tTest(\n         StatisticalSummary sampleStats1,\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException, MathException;\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public abstract double homoscedasticTTest(\n+    double homoscedasticTTest(\n         StatisticalSummary sampleStats1,\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException, MathException;\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    public abstract boolean tTest(\n+    boolean tTest(\n         StatisticalSummary sampleStats1,\n         StatisticalSummary sampleStats2,\n         double alpha)\n--- a/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n     private static class IntDoublePair implements Comparable<IntDoublePair>  {\n \n         /** Value of the pair */\n-        final private double value;\n+        private final double value;\n \n         /** Original position of the pair */\n-        final private int position;\n+        private final int position;\n \n         /**\n          * Construct an IntDoublePair with the given value and position.\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n      * @return the real inversely transformed array (signal)\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public abstract double[] inversetransform(double f[])\n+    double[] inversetransform(double f[])\n         throws IllegalArgumentException;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * @param p2 the second point\n      * @return the L<sub>1</sub> distance between the two points\n      */\n-    public static final double distance1(double[] p1, double[] p2) {\n+    public static double distance1(double[] p1, double[] p2) {\n         double sum = 0;\n         for (int i = 0; i < p1.length; i++) {\n             sum += Math.abs(p1[i] - p2[i]);\n      * @param p2 the second point\n      * @return the L<sub>1</sub> distance between the two points\n      */\n-    public static final int distance1(int[] p1, int[] p2) {\n+    public static int distance1(int[] p1, int[] p2) {\n       int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n           sum += Math.abs(p1[i] - p2[i]);\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n-    public static final double distance(double[] p1, double[] p2) {\n+    public static double distance(double[] p1, double[] p2) {\n         double sum = 0;\n         for (int i = 0; i < p1.length; i++) {\n             final double dp = p1[i] - p2[i];\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n-    public static final double distance(int[] p1, int[] p2) {\n+    public static double distance(int[] p1, int[] p2) {\n       int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n           final int dp = p1[i] - p2[i];\n      * @param p2 the second point\n      * @return the L<sub>&infin;</sub> distance between the two points\n      */\n-    public static final double distanceInf(double[] p1, double[] p2) {\n+    public static double distanceInf(double[] p1, double[] p2) {\n         double max = 0;\n         for (int i = 0; i < p1.length; i++) {\n             max = Math.max(max, Math.abs(p1[i] - p2[i]));\n      * @param p2 the second point\n      * @return the L<sub>&infin;</sub> distance between the two points\n      */\n-    public static final int distanceInf(int[] p1, int[] p2) {\n+    public static int distanceInf(int[] p1, int[] p2) {\n         int max = 0;\n         for (int i = 0; i < p1.length; i++) {\n             max = Math.max(max, Math.abs(p1[i] - p2[i]));", "timestamp": 1252229768, "metainfo": ""}