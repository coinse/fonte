{"sha": "b25bec37c059442830ee749c6653ff83e8510259", "log": "added event handling to ODE integrators with jacobians  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/EventHandlerWithJacobians.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import org.apache.commons.math.ode.events.EventException;\n+\n+/** This interface represents a handler for discrete events triggered\n+ * during ODE integration.\n+ *\n+ * <p>Some events can be triggered at discrete times as an ODE problem\n+ * is solved. This occurs for example when the integration process\n+ * should be stopped as some state is reached (G-stop facility) when the\n+ * precise date is unknown a priori, or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings.\n+ * </p>\n+ *\n+ * <p>These events are defined as occurring when a <code>g</code>\n+ * switching function sign changes.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independent <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this event handling feature is available for all integrators,\n+ * including fixed step ones).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface EventHandlerWithJacobians  {\n+\n+    /** Stop indicator.\n+     * <p>This value should be used as the return value of the {@link\n+     * #eventOccurred eventOccurred} method when the integration should be\n+     * stopped after the event ending the current step.</p>\n+     */\n+    int STOP = 0;\n+\n+    /** Reset state indicator.\n+     * <p>This value should be used as the return value of the {@link\n+     * #eventOccurred eventOccurred} method when the integration should\n+     * go on after the event ending the current step, with a new state\n+     * vector (which will be retrieved thanks to the {@link #resetState\n+     * resetState} method).</p>\n+     */\n+    int RESET_STATE = 1;\n+\n+    /** Reset derivatives indicator.\n+     * <p>This value should be used as the return value of the {@link\n+     * #eventOccurred eventOccurred} method when the integration should\n+     * go on after the event ending the current step, with a new derivatives\n+     * vector (which will be retrieved thanks to the {@link\n+     * org.apache.commons.math.ode.FirstOrderDifferentialEquations#computeDerivatives}\n+     * method).</p>\n+     */\n+    int RESET_DERIVATIVES = 2;\n+\n+    /** Continue indicator.\n+     * <p>This value should be used as the return value of the {@link\n+     * #eventOccurred eventOccurred} method when the integration should go\n+     * on after the event ending the current step.</p>\n+     */\n+    int CONTINUE = 3;\n+\n+    /** Compute the value of the switching function.\n+\n+     * <p>The discrete events are generated when the sign of this\n+     * switching function changes. The integrator will take care to change\n+     * the stepsize in such a way these events occur exactly at step boundaries.\n+     * The switching function must be continuous in its roots neighborhood\n+     * (but not necessarily smooth), as the integrator will need to find its\n+     * roots to locate precisely the events.</p>\n+\n+     * @param t current value of the independent <i>time</i> variable\n+     * @param y array containing the current value of the state vector\n+     * @param dydy0 array containing the current value of the jacobian of\n+     * the state vector with respect to initial state\n+     * @param dydp array containing the current value of the jacobian of\n+     * the state vector with respect to parameters\n+     * @return value of the g switching function\n+     * @exception EventException if the switching function cannot be evaluated\n+     */\n+    double g(double t, double[] y, double[][] dydy0, double[][] dydp)\n+        throws EventException;\n+\n+    /** Handle an event and choose what to do next.\n+\n+     * <p>This method is called when the integrator has accepted a step\n+     * ending exactly on a sign change of the function, just <em>before</em>\n+     * the step handler itself is called (see below for scheduling). It\n+     * allows the user to update his internal data to acknowledge the fact\n+     * the event has been handled (for example setting a flag in the {@link\n+     * org.apache.commons.math.ode.jacobians.ParameterizedODEWithJacobians\n+     * differential equations} to switch the derivatives computation in\n+     * case of discontinuity), or to direct the integrator to either stop\n+     * or continue integration, possibly with a reset state or derivatives.</p>\n+\n+     * <ul>\n+     *   <li>if {@link #STOP} is returned, the step handler will be called\n+     *   with the <code>isLast</code> flag of the {@link\n+     *   org.apache.commons.math.ode.jacobians.StepHandlerWithJacobians#handleStep(\n+     *   StepInterpolatorWithJacobians, boolean) handleStep} method set to true and\n+     *   the integration will be stopped,</li>\n+     *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+     *   resetState} method will be called once the step handler has\n+     *   finished its task, and the integrator will also recompute the\n+     *   derivatives,</li>\n+     *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+     *   will recompute the derivatives,\n+     *   <li>if {@link #CONTINUE} is returned, no specific action will\n+     *   be taken (apart from having called this method) and integration\n+     *   will continue.</li>\n+     * </ul>\n+\n+     * <p>The scheduling between this method and the {@link\n+     * org.apache.commons.math.ode.jacobians.StepHandlerWithJacobians\n+     * StepHandlerWithJacobians} method {@link\n+     * org.apache.commons.math.ode.jacobians.StepHandlerWithJacobians#handleStep(\n+     * StepInterpolatorWithJacobians, boolean) handleStep(interpolator, isLast)}\n+     * is to call this method first and <code>handleStep</code> afterwards. This\n+     * scheduling allows the integrator to pass <code>true</code> as the\n+     * <code>isLast</code> parameter to the step handler to make it aware the step\n+     * will be the last one if this method returns {@link #STOP}. As the\n+     * interpolator may be used to navigate back throughout the last step (as {@link\n+     * org.apache.commons.math.ode.sampling.StepNormalizer StepNormalizer}\n+     * does for example), user code called by this method and user\n+     * code called by step handlers may experience apparently out of order values\n+     * of the independent time variable. As an example, if the same user object\n+     * implements both this {@link EventHandlerWithJacobians EventHandler} interface and the\n+     * {@link org.apache.commons.math.ode.sampling.FixedStepHandler FixedStepHandler}\n+     * interface, a <em>forward</em> integration may call its\n+     * <code>eventOccurred</code> method with t = 10 first and call its\n+     * <code>handleStep</code> method with t = 9 afterwards. Such out of order\n+     * calls are limited to the size of the integration step for {@link\n+     * org.apache.commons.math.ode.sampling.StepHandler variable step handlers} and\n+     * to the size of the fixed step for {@link\n+     * org.apache.commons.math.ode.sampling.FixedStepHandler fixed step handlers}.</p>\n+\n+     * @param t current value of the independent <i>time</i> variable\n+     * @param y array containing the current value of the state vector\n+     * @param dydy0 array containing the current value of the jacobian of\n+     * the state vector with respect to initial state\n+     * @param dydp array containing the current value of the jacobian of\n+     * the state vector with respect to parameters\n+     * @param increasing if true, the value of the switching function increases\n+     * when times increases around event (note that increase is measured with respect\n+     * to physical time, not with respect to integration which may go backward in time)\n+     * @return indication of what the integrator should do next, this\n+     * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+     * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+     * @exception EventException if the event occurrence triggers an error\n+     */\n+    int eventOccurred(double t, double[] y, double[][] dydy0, double[][] dydp,\n+                      boolean increasing) throws EventException;\n+\n+    /** Reset the state prior to continue the integration.\n+\n+     * <p>This method is called after the step handler has returned and\n+     * before the next step is started, but only when {@link\n+     * #eventOccurred} has itself returned the {@link #RESET_STATE}\n+     * indicator. It allows the user to reset the state vector for the\n+     * next step, without perturbing the step handler of the finishing\n+     * step. If the {@link #eventOccurred} never returns the {@link\n+     * #RESET_STATE} indicator, this function will never be called, and it is\n+     * safe to leave its body empty.</p>\n+\n+     * @param t current value of the independent <i>time</i> variable\n+     * @param y array containing the current value of the state vector\n+     * the new state should be put in the same array\n+     * @param dydy0 array containing the current value of the jacobian of\n+     * the state vector with respect to initial state, the new jacobian\n+     * should be put in the same array\n+     * @param dydp array containing the current value of the jacobian of\n+     * the state vector with respect to parameters, the new jacobian\n+     * should be put in the same array\n+     * @exception EventException if the state cannot be reseted\n+     */\n+    void resetState(double t, double[] y, double[][] dydy0, double[][] dydp)\n+    throws EventException;\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n      * @see #getStepHandlers()\n      */\n     public void clearStepHandlers() {\n-\n-        // preserve the handlers we did not add ourselves\n-        final Collection<StepHandler> otherHandlers = new ArrayList<StepHandler>();\n-        for (final StepHandler handler : integrator.getStepHandlers()) {\n-            if (!(handler instanceof StepHandlerWrapper)) {\n-                otherHandlers.add(handler);\n-            }\n-        }\n-\n-        // clear all handlers\n         integrator.clearStepHandlers();\n-\n-        // put back the preserved handlers\n-        for (final StepHandler handler : otherHandlers) {\n-            integrator.addStepHandler(handler);\n-        }\n-\n+    }\n+\n+    /** Add an event handler to the integrator.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventHandlers()\n+     * @see #clearEventHandlers()\n+     */\n+    public void addEventHandler(EventHandlerWithJacobians handler,\n+                                double maxCheckInterval,\n+                                double convergence,\n+                                int maxIterationCount) {\n+        integrator.addEventHandler(new EventHandlerWrapper(handler),\n+                                   maxCheckInterval, convergence, maxIterationCount);\n+    }\n+\n+    /** Get all the event handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addEventHandler(EventHandlerWithJacobians, double, double, int)\n+     * @see #clearEventHandlers()\n+     */\n+    public Collection<EventHandlerWithJacobians> getEventHandlers() {\n+        final Collection<EventHandlerWithJacobians> handlers =\n+            new ArrayList<EventHandlerWithJacobians>();\n+        for (final EventHandler handler : integrator.getEventHandlers()) {\n+            if (handler instanceof EventHandlerWrapper) {\n+                handlers.add(((EventHandlerWrapper) handler).getHandler());\n+            }\n+        }\n+        return handlers;\n+    }\n+\n+    /** Remove all the event handlers that have been added to the integrator.\n+     * @see #addEventHandler(EventHandlerWithJacobians, double, double, int)\n+     * @see #getEventHandlers()\n+     */\n+    public void clearEventHandlers() {\n+        integrator.clearEventHandlers();\n     }\n \n     /** Integrate the differential equations and the variational equations up to the given time.\n         final double stopTime = integrator.integrate(new MappingWrapper(), t0, z, t, z);\n \n         // dispatch the final compound state into the state and partial derivatives arrays\n+        dispatchCompoundState(z, y, dYdY0, dYdP);\n+\n+        return stopTime;\n+\n+    }\n+\n+    /** Dispatch a compound state array into state and jacobians arrays.\n+     * @param z compound state\n+     * @param y raw state array to fill\n+     * @param dydy0 jacobian array to fill\n+     * @param dydp jacobian array to fill\n+     */\n+    private static void dispatchCompoundState(final double[] z, final double[] y,\n+                                              final double[][] dydy0, final double[][] dydp) {\n+\n+        final int n = y.length;\n+        final int k = dydp[0].length;\n+\n+        // state\n         System.arraycopy(z, 0, y, 0, n);\n+\n+        // jacobian with respect to initial state\n         for (int i = 0; i < n; ++i) {\n-            System.arraycopy(z, n * (i + 1), dYdY0[i], 0, n);\n-        }\n+            System.arraycopy(z, n * (i + 1), dydy0[i], 0, n);\n+        }\n+\n+        // jacobian with respect to parameters\n         for (int i = 0; i < n; ++i) {\n-            System.arraycopy(z, n * (n + 1) + i * k, dYdP[i], 0, k);\n-        }\n-\n-        return stopTime;\n+            System.arraycopy(z, n * (n + 1) + i * k, dydp[i], 0, k);\n+        }\n \n     }\n \n         }\n \n     }\n+\n+    /** Wrapper for event handlers. */\n+    private class EventHandlerWrapper implements EventHandler {\n+\n+        /** Underlying event handler with jacobians. */\n+        private final EventHandlerWithJacobians handler;\n+\n+        /** State array. */\n+        private double[] y;\n+\n+        /** Jacobian with respect to initial state dy/dy0. */\n+        private double[][] dydy0;\n+\n+        /** Jacobian with respect to parameters dy/dp. */\n+        private double[][] dydp;\n+\n+        /** Simple constructor.\n+         * @param handler underlying event handler with jacobians\n+         */\n+        public EventHandlerWrapper(final EventHandlerWithJacobians handler) {\n+            this.handler = handler;\n+            final int n = ode.getDimension();\n+            final int k = ode.getParametersDimension();\n+            y        = new double[n];\n+            dydy0    = new double[n][n];\n+            dydp     = new double[n][k];\n+        }\n+\n+        /** Get the underlying event handler with jacobians.\n+         * @return underlying event handler with jacobians\n+         */\n+        public EventHandlerWithJacobians getHandler() {\n+            return handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] z, boolean increasing)\n+            throws EventException {\n+            dispatchCompoundState(z, y, dydy0, dydp);\n+            return handler.eventOccurred(t, y, dydy0, dydp, increasing);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] z)\n+            throws EventException {\n+            dispatchCompoundState(z, y, dydy0, dydp);\n+            return handler.g(t, y, dydy0, dydp);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] z)\n+            throws EventException {\n+            dispatchCompoundState(z, y, dydy0, dydp);\n+            handler.resetState(t, y, dydy0, dydp);\n+        }\n+\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n         extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n     }\n \n+    @Test\n+    public void testEventHandler() throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+        double[] y = new double[] { 0.0, 1.0 };\n+        final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n+        double[][] dydy0 = new double[2][2];\n+        double[][] dydp  = new double[2][3];\n+        double t = 18 * Math.PI;\n+        final FirstOrderIntegratorWithJacobians extInt =\n+            new FirstOrderIntegratorWithJacobians(integ, circle);\n+        extInt.addEventHandler(new EventHandlerWithJacobians() {\n+\n+            public int eventOccurred(double t, double[] y, double[][] dydy0,\n+                                     double[][] dydp, boolean increasing) {\n+                Assert.assertEquals(0.1, y[1], 1.0e-11);\n+                Assert.assertTrue(!increasing);\n+                return STOP;\n+            }\n+\n+            public double g(double t, double[] y, double[][] dydy0,\n+                            double[][] dydp) {\n+                return y[1] - 0.1;\n+            }\n+\n+            public void resetState(double t, double[] y, double[][] dydy0,\n+                                   double[][] dydp) {\n+            }\n+        }, 10.0, 1.0e-10, 1000);\n+        double stopTime = extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n+        Assert.assertTrue(stopTime < 5.0 * Math.PI);\n+    }\n+\n     private static class Brusselator implements ParameterizedODEWithJacobians {\n \n         private double b;", "timestamp": 1267907935, "metainfo": ""}