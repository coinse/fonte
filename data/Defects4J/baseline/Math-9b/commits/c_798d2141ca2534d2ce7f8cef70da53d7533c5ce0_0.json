{"sha": "798d2141ca2534d2ce7f8cef70da53d7533c5ce0", "log": "Added Hermite interpolator.  This class implements the Hermite polynomial interpolation method, which can match function derivatives in addition to function value at sampling points. The implementation is done for vector-valued functions.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.interpolation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.analysis.DifferentiableUnivariateVectorFunction;\n+import org.apache.commons.math3.analysis.UnivariateVectorFunction;\n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.ArithmeticUtils;\n+\n+/** Polynomial interpolator using both sample values and sample derivatives.\n+ * <p>\n+ * The interpolation polynomials match all sample points, including both values\n+ * and provided derivatives. There is one polynomial for each component of\n+ * the values vector. All polynomial have the same degree. The degree of the\n+ * polynomials depends on the number of points and number of derivatives at each\n+ * point. For example the interpolation polynomials for n sample points without\n+ * any derivatives all have degree n-1. The interpolation polynomials for n\n+ * sample points with the two extreme points having value and first derivative\n+ * and the remaining points having value only all have degree n+1. The\n+ * interpolation polynomial for n sample points with value, first and second\n+ * derivative for all points all have degree 3n-1.\n+ * </p>\n+ * <p>\n+ * This class has been imported from the Orekit space flight dynamics library\n+ * also distributed under the terms of the Apache License V2. Original copyright\n+ * is: Copyright 2002-2012 CS Syst\u00e8mes d'Information.\n+ * </p>\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class HermiteInterpolator implements DifferentiableUnivariateVectorFunction {\n+\n+    /** Sample abscissae. */\n+    private final List<Double> abscissae;\n+\n+    /** Top diagonal of the divided differences array. */\n+    private final List<double[]> topDiagonal;\n+\n+    /** Bottom diagonal of the divided differences array. */\n+    private final List<double[]> bottomDiagonal;\n+\n+    /** Create an empty interpolator.\n+     */\n+    public HermiteInterpolator() {\n+        this.abscissae      = new ArrayList<Double>();\n+        this.topDiagonal    = new ArrayList<double[]>();\n+        this.bottomDiagonal = new ArrayList<double[]>();\n+    }\n+\n+    /** Add a sample point.\n+     * <p>\n+     * This method must be called once for each sample point. It is allowed to\n+     * mix some calls with values only with calls with values and first\n+     * derivatives.\n+     * </p>\n+     * <p>\n+     * The point abscissae for all calls <em>must</em> be different.\n+     * </p>\n+     * @param x abscissa of the sample point\n+     * @param value value and derivatives of the sample point\n+     * (if only one row is passed, it is the value, if two rows are\n+     * passed the first one is the value and the second the derivative\n+     * and so on)\n+     * @exception MathIllegalArgumentException if the abscissa is equals to a previously\n+     * added sample point\n+     */\n+    public void addSamplePoint(final double x, final double[] ... value)\n+        throws MathIllegalArgumentException {\n+\n+        for (int i = 0; i < value.length; ++i) {\n+\n+            final double[] y = value[i].clone();\n+            if (i > 1) {\n+                double inv = 1.0 / ArithmeticUtils.factorial(i);\n+                for (int j = 0; j < y.length; ++j) {\n+                    y[j] *= inv;\n+                }\n+            }\n+\n+            // update the bottom diagonal of the divided differences array\n+            final int n = abscissae.size();\n+            bottomDiagonal.add(n - i, y);\n+            double[] bottom0 = y;\n+            for (int j = i; j < n; ++j) {\n+                final double[] bottom1 = bottomDiagonal.get(n - (j + 1));\n+                final double inv = 1.0 / (x - abscissae.get(n - (j + 1)));\n+                if (Double.isInfinite(inv)) {\n+                    throw new MathIllegalArgumentException(LocalizedFormats.DUPLICATED_ABSCISSA_DIVISION_BY_ZERO,\n+                                                           x);\n+                }\n+                for (int k = 0; k < y.length; ++k) {\n+                    bottom1[k] = inv * (bottom0[k] - bottom1[k]);\n+                }\n+                bottom0 = bottom1;\n+            }\n+\n+            // update the top diagonal of the divided differences array\n+            topDiagonal.add(bottom0.clone());\n+\n+            // update the abscissae array\n+            abscissae.add(x);\n+\n+        }\n+\n+    }\n+\n+    /** Compute the interpolation polynomials.\n+     * @return interpolation polynomials array\n+     * @exception MathIllegalStateException if sample is empty\n+     */\n+    public PolynomialFunction[] getPolynomials()\n+        throws MathIllegalStateException {\n+\n+        // safety check\n+        checkInterpolation();\n+\n+        // iteration initialization\n+        final PolynomialFunction zero = polynomial(0);\n+        PolynomialFunction[] polynomials = new PolynomialFunction[topDiagonal.get(0).length];\n+        for (int i = 0; i < polynomials.length; ++i) {\n+            polynomials[i] = zero;\n+        }\n+        PolynomialFunction coeff = polynomial(1);\n+\n+        // build the polynomials by iterating on the top diagonal of the divided differences array\n+        for (int i = 0; i < topDiagonal.size(); ++i) {\n+            double[] tdi = topDiagonal.get(i);\n+            for (int k = 0; k < polynomials.length; ++k) {\n+                polynomials[k] = polynomials[k].add(coeff.multiply(polynomial(tdi[k])));\n+            }\n+            coeff = coeff.multiply(polynomial(-abscissae.get(i), 1.0));\n+        }\n+\n+        return polynomials;\n+\n+    }\n+\n+    /** Interpolate value at a specified abscissa.\n+     * <p>\n+     * Calling this method is equivalent to call the {@link PolynomialFunction#value(double)\n+     * value} methods of all polynomials returned by {@link #getPolynomials() getPolynomials},\n+     * except it does not build the intermediate polynomials, so this method is faster and\n+     * numerically more stable.\n+     * </p>\n+     * @param x interpolation abscissa\n+     * @return interpolated value\n+     * @exception MathIllegalStateException if sample is empty\n+     */\n+    public double[] value(double x)\n+        throws MathIllegalStateException {\n+\n+        // safety check\n+        checkInterpolation();\n+\n+        final double[] value = new double[topDiagonal.get(0).length];\n+        double valueCoeff = 1;\n+        for (int i = 0; i < topDiagonal.size(); ++i) {\n+            double[] dividedDifference = topDiagonal.get(i);\n+            for (int k = 0; k < value.length; ++k) {\n+                value[k] += dividedDifference[k] * valueCoeff;\n+            }\n+            final double deltaX = x - abscissae.get(i);\n+            valueCoeff *= deltaX;\n+        }\n+\n+        return value;\n+\n+    }\n+\n+    /** Interpolate first derivative at a specified abscissa.\n+     * <p>\n+     * Calling this method is equivalent to call the {@link PolynomialFunction#value(double)\n+     * value} methods of the derivatives of all polynomials returned by {@link\n+     * #getPolynomials() getPolynomials}, except it builds neither the intermediate\n+     * polynomials nor their derivatives, so this method is faster and numerically more stable.\n+     * </p>\n+     * @param x interpolation abscissa\n+     * @return interpolated derivative\n+     * @exception MathIllegalStateException if sample is empty\n+     */\n+    public double[] derivative(double x)\n+        throws MathIllegalStateException {\n+\n+        // safety check\n+        checkInterpolation();\n+\n+        final double[] derivative = new double[topDiagonal.get(0).length];\n+        double valueCoeff      = 1;\n+        double derivativeCoeff = 0;\n+        for (int i = 0; i < topDiagonal.size(); ++i) {\n+            double[] dividedDifference = topDiagonal.get(i);\n+            for (int k = 0; k < derivative.length; ++k) {\n+                derivative[k] += dividedDifference[k] * derivativeCoeff;\n+            }\n+            final double deltaX = x - abscissae.get(i);\n+            derivativeCoeff = valueCoeff + derivativeCoeff * deltaX;\n+            valueCoeff *= deltaX;\n+        }\n+\n+        return derivative;\n+\n+    }\n+\n+    /** {@inheritDoc}} */\n+    public UnivariateVectorFunction derivative() {\n+        return new UnivariateVectorFunction() {\n+\n+            /** {@inheritDoc}} */\n+            public double[] value(double x) {\n+                return derivative(x);\n+            }\n+            \n+        };\n+    }\n+\n+    /** Check interpolation can be performed.\n+     * @exception MathIllegalStateException if interpolation cannot be performed\n+     * because sample is empty\n+     */\n+    private void checkInterpolation() throws MathIllegalStateException {        \n+        if (abscissae.isEmpty()) {\n+            throw new MathIllegalStateException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n+        }\n+    }\n+\n+    /** Create a polynomial from its coefficients.\n+     * @param c polynomials coefficients\n+     * @return polynomial\n+     */\n+    private PolynomialFunction polynomial(double ... c) {\n+        return new PolynomialFunction(c);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n     DIMENSIONS_MISMATCH(\"dimensions mismatch\"), /* keep */\n     DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n     DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n-    DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n+    DUPLICATED_ABSCISSA_DIVISION_BY_ZERO(\"duplicated abscissa {0} causes division by zero\"),\n     ELITISM_RATE(\"elitism rate ({0})\"),\n     EMPTY_CLUSTER_IN_K_MEANS(\"empty cluster in k-means\"),\n+    EMPTY_INTERPOLATION_SAMPLE(\"sample for interpolation is empty\"),\n     EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"), /* keep */\n     EMPTY_SELECTED_COLUMN_INDEX_ARRAY(\"empty selected column index array\"),\n     EMPTY_SELECTED_ROW_INDEX_ARRAY(\"empty selected row index array\"),\n     GCD_OVERFLOW_32_BITS(\"overflow: gcd({0}, {1}) is 2^31\"),\n     GCD_OVERFLOW_64_BITS(\"overflow: gcd({0}, {1}) is 2^63\"),\n     HOLE_BETWEEN_MODELS_TIME_RANGES(\"{0} wide hole between models time ranges\"),\n-    IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\"),\n     ILL_CONDITIONED_OPERATOR(\"condition number {1} is too high \"),\n     INDEX_LARGER_THAN_MAX(\"the index specified: {0} is larger than the current maximal index {1}\"),\n     INDEX_NOT_POSITIVE(\"index ({0}) is not positive\"),\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.interpolation;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class HermiteInterpolatorTest {\n+\n+    @Test\n+    public void testZero() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(0.0, new double[] { 0.0 });\n+        for (double x = -10; x < 10; x += 1.0) {\n+            Assert.assertEquals(0.0, interpolator.value(x)[0], 1.0e-15);\n+            Assert.assertEquals(0.0, interpolator.derivative(x)[0], 1.0e-15);\n+        }\n+        checkPolynomial(new PolynomialFunction(new double[] { 0.0 }),\n+                        interpolator.getPolynomials()[0]);\n+    }\n+\n+    @Test\n+    public void testQuadratic() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(0.0, new double[] { 2.0 });\n+        interpolator.addSamplePoint(1.0, new double[] { 0.0 });\n+        interpolator.addSamplePoint(2.0, new double[] { 0.0 });\n+        for (double x = -10; x < 10; x += 1.0) {\n+            Assert.assertEquals((x - 1.0) * (x - 2.0), interpolator.value(x)[0], 1.0e-15);\n+            Assert.assertEquals(2 * x - 3.0, interpolator.derivative(x)[0], 1.0e-15);\n+        }\n+        checkPolynomial(new PolynomialFunction(new double[] { 2.0, -3.0, 1.0 }),\n+                        interpolator.getPolynomials()[0]);\n+    }\n+\n+    @Test\n+    public void testMixedDerivatives() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });\n+        interpolator.addSamplePoint(1.0, new double[] { 4.0 });\n+        interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });\n+        Assert.assertEquals(4, interpolator.getPolynomials()[0].degree());\n+        Assert.assertEquals(1.0, interpolator.value(0.0)[0], 1.0e-15);\n+        Assert.assertEquals(2.0, interpolator.derivative(0.0)[0], 1.0e-15);\n+        Assert.assertEquals(4.0, interpolator.value(1.0)[0], 1.0e-15);\n+        Assert.assertEquals(5.0, interpolator.value(2.0)[0], 1.0e-15);\n+        Assert.assertEquals(2.0, interpolator.derivative(2.0)[0], 1.0e-15);\n+        checkPolynomial(new PolynomialFunction(new double[] { 1.0, 2.0, 4.0, -4.0, 1.0 }),\n+                        interpolator.getPolynomials()[0]);\n+    }\n+\n+    @Test\n+    public void testRandomPolynomialsValuesOnly() {\n+\n+        Random random = new Random(0x42b1e7dbd361a932l);\n+\n+        for (int i = 0; i < 100; ++i) {\n+\n+            int maxDegree = 0;\n+            PolynomialFunction[] p = new PolynomialFunction[5];\n+            for (int k = 0; k < p.length; ++k) {\n+                int degree = random.nextInt(7);\n+                p[k] = randomPolynomial(degree, random);\n+                maxDegree = FastMath.max(maxDegree, degree);\n+            }\n+\n+            HermiteInterpolator interpolator = new HermiteInterpolator();\n+            for (int j = 0; j < 1 + maxDegree; ++j) {\n+                double x = 0.1 * j;\n+                double[] values = new double[p.length];\n+                for (int k = 0; k < p.length; ++k) {\n+                    values[k] = p[k].value(x);\n+                }\n+                interpolator.addSamplePoint(x, values);\n+            }\n+\n+            for (double x = 0; x < 2; x += 0.1) {\n+                double[] values = interpolator.value(x);\n+                Assert.assertEquals(p.length, values.length);\n+                for (int k = 0; k < p.length; ++k) {\n+                    Assert.assertEquals(p[k].value(x), values[k], 1.0e-8 * FastMath.abs(p[k].value(x)));\n+                }\n+            }\n+\n+            PolynomialFunction[] result = interpolator.getPolynomials();\n+            for (int k = 0; k < p.length; ++k) {\n+                checkPolynomial(p[k], result[k]);\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testRandomPolynomialsFirstDerivative() {\n+\n+        Random random = new Random(0x570803c982ca5d3bl);\n+\n+        for (int i = 0; i < 100; ++i) {\n+\n+            int maxDegree = 0;\n+            PolynomialFunction[] p      = new PolynomialFunction[5];\n+            PolynomialFunction[] pPrime = new PolynomialFunction[5];\n+            for (int k = 0; k < p.length; ++k) {\n+                int degree = random.nextInt(7);\n+                p[k]      = randomPolynomial(degree, random);\n+                pPrime[k] = p[k].polynomialDerivative();\n+                maxDegree = FastMath.max(maxDegree, degree);\n+            }\n+\n+            HermiteInterpolator interpolator = new HermiteInterpolator();\n+            for (int j = 0; j < 1 + maxDegree / 2; ++j) {\n+                double x = 0.1 * j;\n+                double[] values      = new double[p.length];\n+                double[] derivatives = new double[p.length];\n+                for (int k = 0; k < p.length; ++k) {\n+                    values[k]      = p[k].value(x);\n+                    derivatives[k] = pPrime[k].value(x);\n+                }\n+                interpolator.addSamplePoint(x, values, derivatives);\n+            }\n+\n+            for (double x = 0; x < 2; x += 0.1) {\n+                double[] values      = interpolator.value(x);\n+                double[] derivatives = interpolator.derivative(x);\n+                Assert.assertEquals(p.length, values.length);\n+                for (int k = 0; k < p.length; ++k) {\n+                    Assert.assertEquals(p[k].value(x), values[k], 1.0e-8 * FastMath.abs(p[k].value(x)));\n+                    Assert.assertEquals(pPrime[k].value(x), derivatives[k], 4.0e-8 * FastMath.abs(p[k].value(x)));\n+                }\n+            }\n+\n+            PolynomialFunction[] result = interpolator.getPolynomials();\n+            for (int k = 0; k < p.length; ++k) {\n+                checkPolynomial(p[k], result[k]);\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testSine() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        for (double x = 0; x < FastMath.PI; x += 0.5) {\n+            interpolator.addSamplePoint(x, new double[] { FastMath.sin(x) });\n+        }\n+        for (double x = 0.1; x <= 2.9; x += 0.01) {\n+            Assert.assertEquals(FastMath.sin(x), interpolator.value(x)[0], 3.5e-5);\n+            Assert.assertEquals(FastMath.cos(x), interpolator.derivative(x)[0], 1.3e-4);\n+        }\n+    }\n+\n+    @Test\n+    public void testSquareRoot() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        for (double x = 1.0; x < 3.6; x += 0.5) {\n+            interpolator.addSamplePoint(x, new double[] { FastMath.sqrt(x) });\n+        }\n+        for (double x = 1.1; x < 3.5; x += 0.01) {\n+            Assert.assertEquals(FastMath.sqrt(x), interpolator.value(x)[0], 1.5e-4);\n+            Assert.assertEquals(0.5 / FastMath.sqrt(x), interpolator.derivative(x)[0], 8.5e-4);\n+        }\n+    }\n+\n+    @Test\n+    public void testWikipedia() {\n+        // this test corresponds to the example from Wikipedia page:\n+        // http://en.wikipedia.org/wiki/Hermite_interpolation\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(-1, new double[] { 2 }, new double[] { -8 }, new double[] { 56 });\n+        interpolator.addSamplePoint( 0, new double[] { 1 }, new double[] {  0 }, new double[] {  0 });\n+        interpolator.addSamplePoint( 1, new double[] { 2 }, new double[] {  8 }, new double[] { 56 });\n+        for (double x = -1.0; x <= 1.0; x += 0.125) {\n+            double x2 = x * x;\n+            double x4 = x2 * x2;\n+            double x8 = x4 * x4;\n+            Assert.assertEquals(x8 + 1, interpolator.value(x)[0], 1.0e-15);\n+            Assert.assertEquals(8 * x4 * x2 * x, interpolator.derivative(x)[0], 1.0e-15);\n+        }\n+        checkPolynomial(new PolynomialFunction(new double[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 }),\n+                        interpolator.getPolynomials()[0]);\n+    }\n+\n+    @Test\n+    public void testOnePointParabola() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(0, new double[] { 1 }, new double[] { 1 }, new double[] { 2 });\n+        for (double x = -1.0; x <= 1.0; x += 0.125) {\n+            Assert.assertEquals(1 + x * (1 + x), interpolator.value(x)[0], 1.0e-15);\n+            Assert.assertEquals(1 + 2 * x, interpolator.derivative(x)[0], 1.0e-15);\n+        }\n+        checkPolynomial(new PolynomialFunction(new double[] { 1, 1, 1 }),\n+                        interpolator.getPolynomials()[0]);\n+    }\n+\n+    private PolynomialFunction randomPolynomial(int degree, Random random) {\n+        double[] coeff = new double[ 1 + degree];\n+        for (int j = 0; j < degree; ++j) {\n+            coeff[j] = random.nextDouble();\n+        }\n+        return new PolynomialFunction(coeff);\n+    }\n+\n+    @Test(expected=IllegalStateException.class)\n+    public void testEmptySample() {\n+        new HermiteInterpolator().value(0.0);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testDuplicatedAbscissa() {\n+        HermiteInterpolator interpolator = new HermiteInterpolator();\n+        interpolator.addSamplePoint(1.0, new double[] { 0.0 });\n+        interpolator.addSamplePoint(1.0, new double[] { 1.0 });\n+    }\n+\n+    private void checkPolynomial(PolynomialFunction expected, PolynomialFunction result) {\n+        Assert.assertTrue(result.degree() >= expected.degree());\n+        double[] cE = expected.getCoefficients();\n+        double[] cR = result.getCoefficients();\n+        for (int i = 0; i < cE.length; ++i) {\n+            Assert.assertEquals(cE[i], cR[i], 1.0e-8 * FastMath.abs(cE[i]));\n+        }\n+        for (int i = cE.length; i < cR.length; ++i) {\n+            Assert.assertEquals(0.0, cR[i], 1.0e-9);\n+        }\n+    }\n+\n+}\n+", "timestamp": 1340013672, "metainfo": ""}