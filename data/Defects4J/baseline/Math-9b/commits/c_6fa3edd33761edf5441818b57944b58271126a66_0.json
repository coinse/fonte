{"sha": "6fa3edd33761edf5441818b57944b58271126a66", "log": "Addition of optimal array based evaluations available in StatUtils. These are not delegates to StatUtils, they are implementations.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractStorelessUnivariateStatistic.java\n     extends AbstractUnivariateStatistic\n     implements StorelessUnivariateStatistic {\n \n-    protected boolean clearOnEval = true;\n-\n-    protected boolean init = true;\n-    \n     /**\n      * This implements the AbstractUnivariateStatistic impl to funnel \n      * calculation off to the instantanious increment method.\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] d, int start, int length) {\n-\n-        if (clearOnEval)\n+    public double evaluate(double[] values, int begin, int length) {\n+        if (this.test(values, begin, length)) {\n             this.clear();\n-\n-        for (int i = start; i < start + length; i++) {\n-            increment(d[i]);\n+            for (int i = begin; i < begin + length; i++) {\n+                increment(values[i]);\n+            }\n         }\n-\n         return getValue();\n     }\n-\n-    /**\n-     * Implement this delegated internalClear()\n-     * to cleanup the state of your implementation on clear().\n-     */\n-    protected abstract void internalClear();\n-    \n-    /**\n-     * This implementation is finalized so the implementor does not have to manage\n-     * clearing its state. They just need to implement their delegated internalClear()\n-     * to cleanup the state of their implementation on clear().\n-     * \n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n-     */\n-    public final void clear(){\n-        init = true;\n-        internalClear();\n-    }\n-    \n-    /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#isClearOnEval()\n-     */\n-    public boolean isClearOnEval() {\n-        return clearOnEval;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#setClearOnEval(boolean)\n-     */\n-    public void setClearOnEval(boolean b) {\n-        clearOnEval = b;\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/AbstractUnivariateStatistic.java\n      * \n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[])\n      */\n-    public double evaluate(double[] d) {\n-        return evaluate(d, 0, d.length);\n+    public double evaluate(double[] values) {\n+        return evaluate(values, 0, values.length);\n     }\n \n     /**\n-     * Subclasses of AbstractUnivariateStatistc need to implementation this method.\n+     * Subclasses of AbstractUnivariateStatistc need to implement this method.\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public abstract double evaluate(double[] d, int start, int length);\n+    public abstract double evaluate(double[] values, int begin, int length);\n \n     /**\n      * this protected test method used by all methods to verify the content \n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n      */\n-    protected void test(double[] values, int begin, int length) {\n+    protected boolean test(double[] values, int begin, int length) {\n \n         if (length > values.length)\n             throw new IllegalArgumentException(\"length > values.length\");\n         if (values == null)\n             throw new IllegalArgumentException(\"input value array is null\");\n \n+        if (values.length == 0 || length == 0)\n+            return false;\n+\n+        return true;\n+\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n      */\n     public double getValue();\n \n+\n     /**\n      * Clears all the internal state of the Statistic\n      */\n      * <code>evaluate(double[])</code> methods.\n      * @return the state\n      */\n-    public boolean isClearOnEval();\n+    //public boolean isClearOnEval();\n \n     /**\n      * Sets the behavior of this statistic when evaluating\n      * incrimented.\n      * @param b true | false\n      */\n-    public void setClearOnEval(boolean b);\n+    //public void setClearOnEval(boolean b);\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/UnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/UnivariateStatistic.java\n      * @return the result of the evaluation or Double.NaN \n      * if the array is empty\n      */\n-    public double evaluate(double[] d, int begin, int length); \n+    public double evaluate(double[] values, int begin, int length); \n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org\n-    .apache\n-    .commons\n-    .math\n-    .stat\n-    .univariate\n-    .AbstractStorelessUnivariateStatistic;\n-\n /**\n  * @author Mark Diggory\n  *\n  */\n-public class FourthMoment extends AbstractStorelessUnivariateStatistic {\n-\n-    /** count of values that have been added */\n-    protected int n = 0;\n-\n-    /** first moment of values that have been added */\n-    protected double m1 = Double.NaN;\n-\n-    /** second moment of values that have been added */\n-    protected double m2 = Double.NaN;\n-\n-    /** third moment of values that have been added */\n-    protected double m3 = Double.NaN;\n+public class FourthMoment extends ThirdMoment {\n \n     /** fourth moment of values that have been added */\n     protected double m4 = Double.NaN;\n     }\n \n     /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        n = 0;\n-        m1 = m2 = m3 = m4 = Double.NaN;\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        m4 = Double.NaN;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n+import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n \n /**\n  * @author Mark Diggory\n  *\n  */\n-public class GeometricMean extends SumOfLogs {\n+public class GeometricMean extends AbstractStorelessUnivariateStatistic {\n  \n-    protected double geomean = Double.NaN;\n+    private SumOfLogs sumLog = new SumOfLogs();\n     \n-    protected int n = 0;\n+    private double value = Double.NaN;\n+    \n+    private int n = 0;\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n         n++;\n-        super.increment(d);\n-        geomean = Math.exp( sumLog / (double)n );\n-        return geomean;\n+        sumLog.increment(d);\n+        value = Math.exp( sumLog.increment(d) / (double)n );\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return geomean;\n+        return value;\n     }\n \n     /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        geomean = Double.NaN;\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+        sumLog.clear();\n         n = 0;\n     }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        return Math.exp(sumLog.evaluate(values, begin, length) / (double) length );\n+    }\n+\n+\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n  */\n public class Kurtosis extends FourthMoment {\n \n-    protected double kurtosis = Double.NaN;\n+    private double kurtosis = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n     public double getValue() {\n         return kurtosis;\n     }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        kurtosis = Double.NaN;\n+    }\n \n     /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        super.internalClear();\n-        kurtosis = Double.NaN;\n-    }\n-    \n+        * Returns the kurtosis for this collection of values. Kurtosis is a \n+        * measure of the \"peakedness\" of a distribution.\n+        * @param values Is a double[] containing the values\n+        * @param begin processing at this point in the array\n+        * @param length processing at this point in the array\n+        * @return the kurtosis of the values or Double.NaN if the array is empty\n+        */\n+       public double evaluate(double[] values, int begin, int length) {\n+           test(values, begin, length);\n+\n+           // Initialize the kurtosis\n+           double kurt = Double.NaN;\n+\n+           // Get the mean and the standard deviation\n+           double mean = super.evaluate(values, begin, length);\n+\n+           // Calc the std, this is implemented here instead of using the \n+           // standardDeviation method eliminate a duplicate pass to get the mean\n+           double accum = 0.0;\n+           double accum2 = 0.0;\n+           for (int i = begin; i < begin + length; i++) {\n+               accum += Math.pow((values[i] - mean), 2.0);\n+               accum2 += (values[i] - mean);\n+           }\n+        \n+           double stdDev =\n+               Math.sqrt(\n+                   (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                       / (double) (length - 1));\n+\n+           // Sum the ^4 of the distance from the mean divided by the \n+           // standard deviation\n+           double accum3 = 0.0;\n+           for (int i = begin; i < begin + length; i++) {\n+               accum3 += Math.pow((values[i] - mean) / stdDev, 4.0);\n+           }\n+\n+           // Get N\n+           double n = length;\n+\n+           double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+           double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n+        \n+           // Calculate kurtosis\n+           kurt = (coefficientOne * accum3) - termTwo;\n+\n+           return kurt;\n+       }\n+       \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n package org.apache.commons.math.stat.univariate.moment;\n \n import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.univariate.summary.Sum;\n \n /**\n  * @author Mark Diggory\n  */\n public class Mean extends AbstractStorelessUnivariateStatistic {\n \n+\n     /** count of values that have been added */\n-    private int n = 0;\n+    protected int n = 0;\n \n     /** first moment of values that have been added */\n-    private double m1 = Double.NaN;\n+    protected double m1 = Double.NaN;\n+    \n+    private Sum sum = new Sum();\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n         if (n < 1) {\n-            m1 = 0.0;\n+             m1 = 0.0;\n         }\n+         \n         n++;\n-\n         m1 += (d - m1) / ((double) n);\n-\n         return m1;\n     }\n-\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        m1 = Double.NaN;\n+        n = 0;\n+    }\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     }\n \n     /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        m1 = Double.NaN;\n-        n = 0;\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        if(test(values,begin,length))\n+            return sum.evaluate(values, begin, length) / ((double) length);\n+        return Double.NaN;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n \n /**\n  * @author Mark Diggory\n  *\n  */\n-public class SecondMoment extends AbstractStorelessUnivariateStatistic {\n-\n-    /** count of values that have been added */\n-    protected int n = 0;\n-\n-    /** first moment of values that have been added */\n-    protected double m1 = Double.NaN;\n+public class SecondMoment extends Mean {\n \n     /** second moment of values that have been added */\n     protected double m2 = Double.NaN;\n      */\n     public double increment(double d) {\n         if (n < 1) {\n-            m2 = m1 = 0.0;\n+            m1 = m2 = 0.0;\n         }\n \n         n++;\n-        \n+\n         double dev = d - m1;\n         double v = dev / ((double) n);\n+\n+        m2 += ((double)(n - 1)) * dev * v;\n         m1 += v;\n-        m2 += (n - 1) * dev * v;\n+        \n+        return m2;\n+    }\n \n-        return m2;\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        m2 = Double.NaN;\n     }\n \n     /**\n         return m2;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-     */\n-    protected void internalClear() {\n-        m2 = Double.NaN;\n-        n = 0;\n-    }\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n  */\n public class Skewness extends ThirdMoment {\n \n-    protected double skewness = Double.NaN;\n+    private double skewness = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n     }\n \n     /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        super.internalClear();\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n         skewness = Double.NaN;\n     }\n \n+    /**\n+      * Returns the skewness of a collection of values.  Skewness is a \n+      * measure of the assymetry of a given distribution. \n+      * @param values Is a double[] containing the values\n+      * @param begin processing at this point in the array\n+      * @param length processing at this point in the array\n+      * @return the skewness of the values or Double.NaN if the array is empty\n+      */\n+     public double evaluate(double[] values, int begin, int length) {\n+\n+         test(values, begin, length);\n+\n+         // Initialize the skewness\n+         double skew = Double.NaN;\n+\n+         // Get the mean and the standard deviation\n+         double mean = super.evaluate(values, begin, length);\n+\n+         // Calc the std, this is implemented here instead of using the \n+         // standardDeviation method eliminate a duplicate pass to get the mean\n+         double accum = 0.0;\n+         double accum2 = 0.0;\n+         for (int i = begin; i < begin + length; i++) {\n+             accum += Math.pow((values[i] - mean), 2.0);\n+             accum2 += (values[i] - mean);\n+         }\n+         double stdDev =\n+             Math.sqrt(\n+                 (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                     / (double) (length - 1));\n+\n+         // Calculate the skew as the sum the cubes of the distance \n+         // from the mean divided by the standard deviation.\n+         double accum3 = 0.0;\n+         for (int i = begin; i < begin + length; i++) {\n+             accum3 += Math.pow((values[i] - mean) / stdDev, 3.0);\n+         }\n+\n+         // Get N\n+         double n = length;\n+\n+         // Calculate skewness\n+         skew = (n / ((n - 1) * (n - 2))) * accum3;\n+\n+         return skew;\n+     }\n+     \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n+import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+\n /**\n  * @author Mark Diggory\n  *\n  */\n-public class StandardDeviation extends Variance {\n+public class StandardDeviation extends AbstractStorelessUnivariateStatistic {\n \n-    protected double std = Double.NaN;\n+    private double value = Double.NaN;\n+    \n+    private Variance var = new Variance();\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        std = Math.sqrt(super.increment(d));\n-        return std;\n+        var.increment(d);\n+        value = Math.sqrt(var.getValue());\n+        return value;\n     }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return std;\n+        return value;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        var.clear();\n+        value = Double.NaN;\n     }\n \n-    /**\n-    * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-    */\n-    protected void internalClear() {\n-        super.internalClear();\n-        std = Double.NaN;\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double tmp = var.evaluate(values, begin, length);\n+        return tmp != 0.0 ? Math.sqrt(tmp) : 0.0;\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n-\n /**\n  * @author Mark Diggory\n  *\n  */\n-public class ThirdMoment extends AbstractStorelessUnivariateStatistic{\n-\n-    /** count of values that have been added */\n-    protected int n = 0;\n-\n-    /** first moment of values that have been added */\n-    protected double m1 = Double.NaN;\n-\n-    /** second moment of values that have been added */\n-    protected double m2 = Double.NaN;\n+public class ThirdMoment extends SecondMoment{\n \n     /** third moment of values that have been added */\n     protected double m3 = Double.NaN;\n         }\n         \n         n++;\n+        \n         double dev = d - m1;\n         double v = dev / ((double) n);\n         double v2 = v * v;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n-    protected void internalClear() {\n-        n = 0;\n-        m1 = m2 = m3 = Double.NaN;\n+    public void clear() {\n+        super.clear();\n+        m3 = Double.NaN;\n     }\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n+\n /**\n  * @author Mark Diggory\n  *\n  */\n public class Variance extends SecondMoment {\n \n-    protected double variance = Double.NaN;\n+    private double variance = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n         super.increment(d);\n-        variance = (n <= 1) ? 0.0 : m2 / (double) (n - 1);\n+\n+        variance = (n < 1) ? 0.0 : m2 / (double)(n - 1);\n+        \n         return variance;\n     }\n-\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n-    protected void internalClear() {\n-        super.internalClear();\n+    public void clear() {\n+        super.clear();\n         variance = Double.NaN;\n     }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double var = Double.NaN;\n+        if (values.length == 1) {\n+            var = 0;\n+        } else if (values.length > 1) {\n+            double m = super.evaluate(values, begin, length);\n+            double accum = 0.0;\n+            double accum2 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum += Math.pow((values[i] - m), 2.0);\n+                accum2 += (values[i] - m);\n+            }\n+            var =\n+                (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                    / (double) (length - 1);\n+        }\n+        return var;\n+    }\n+\n+\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n  */\n package org.apache.commons.math.stat.univariate.rank;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n \n /**\n  * @author Mark Diggory\n  */\n public class Max extends AbstractStorelessUnivariateStatistic {\n \n-    double value = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n     }\n \n     /**\n+         * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+         */\n+    public void clear() {\n+        value = Double.NaN;\n+    }\n+\n+    /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n         return value;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    protected void internalClear() {\n-        value = Double.NaN;\n+    public double evaluate(double[] values, int begin, int length) {\n+        double max = Double.NaN;\n+        if (test(values, begin, length)) {\n+            max = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                max = (max > values[i]) ? max : values[i];\n+            }\n+        }\n+        return max;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n  */\n package org.apache.commons.math.stat.univariate.rank;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n \n /**\n  * @author Mark Diggory\n  */\n public class Min extends AbstractStorelessUnivariateStatistic {\n \n-    double value = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        return value = Double.isNaN(value) ? d : Math.min(value, d);\n+        value = Double.isNaN(value) ? d : Math.min(value, d);\n+        return value;\n     }\n \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+    }\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    protected void internalClear() {\n-        value = Double.NaN;\n+    public double evaluate(double[] values, int begin, int length) {\n+        double min = Double.NaN;\n+        if (test(values, begin, length)) {\n+            min = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                min = (min < values[i]) ? min : values[i];\n+            }\n+        }\n+        return min;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n      * Evaluates the double[] top the specified percentile. \n      * This does not alter the interal percentile state of the \n      * statistic.\n-     * @param d Is a double[] containing the values\n+     * @param values Is a double[] containing the values\n      * @param p Is the percentile to evaluate to.\n      * @return the result of the evaluation or Double.NaN \n      * if the array is empty\n      */\n-    public double evaluate(double[] d, double p) {\n-        return evaluate(d, 0,d.length, p);\n+    public double evaluate(double[] values, double p) {\n+        return evaluate(values, 0,values.length, p);\n     }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n-    public double evaluate(double[] d, int start, int length) {\n-        return evaluate(d, start, length, percentile);\n+    public double evaluate(double[] values, int start, int length) {\n+        return evaluate(values, start, length, percentile);\n     }\n \n     /**\n      * Evaluates the double[] top the specified percentile. \n      * This does not alter the interal percentile state of the \n      * statistic.\n-     * @param d Is a double[] containing the values\n+     * @param values Is a double[] containing the values\n      * @param begin processing at this point in the array\n      * @param length processing at this point in the array\n      * @param p Is the percentile to evaluate to.* \n      * @return the result of the evaluation or Double.NaN \n      * if the array is empty\n      */\n-    public double evaluate(double[] d, int start, int length, double p) {\n+    public double evaluate(double[] values, int begin, int length, double p) {\n \n-        test(d,start,length);\n+        test(values,begin,length);\n         \n         if ((p > 100) || (p <= 0)) {\n             throw new IllegalArgumentException(\"invalid percentile value\");\n             return Double.NaN;\n         }\n         if (n == 1) {\n-            return d[start]; // always return single value for n = 1\n+            return values[begin]; // always return single value for n = 1\n         }\n         double pos = p * (n + 1) / 100;\n         double fpos = Math.floor(pos);\n         int intPos = (int) fpos;\n         double dif = pos - fpos;\n         double[] sorted = new double[length];\n-        System.arraycopy(d, start,sorted, 0, length);\n+        System.arraycopy(values, begin,sorted, 0, length);\n         Arrays.sort(sorted);\n         \n         if (pos < 1) {\n     /**\n      * The default internal state of this percentile can be set.\n      * This will setthat value.\n-     * @param d a value between 0 <= p <= 100\n+     * @param p a value between 0 <= p <= 100\n      */\n     public void setPercentile(double p) {\n         percentile = p;\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n     /**\n      * The current Running Product.\n      */\n-    double product = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        if (init) {\n-            init = false;\n-            product = d;\n+        if (Double.isNaN(value)) {\n+            value = d;\n         } else {\n-            product *= d;\n+            value *= d;\n         }\n \n-        return product;\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double product = Double.NaN;\n+        if (test(values, begin, length)) {\n+            product = 1.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                product *= values[i];\n+            }\n+        }\n         return product;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-     */\n-    protected void internalClear() {\n-        product = Double.NaN;\n-    }\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n     /**\n      * The currently running sum.\n      */\n-    protected double sum = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        if (init) {\n-            init = false;\n-            sum = d;\n+        if (Double.isNaN(value )) {\n+            value  = d;\n         } else {\n-            sum += d;\n+            value  += d;\n         }\n-        return sum;\n+        return value ;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n+        return value;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double sum = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sum = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sum += values[i];\n+            }\n+        }\n         return sum;\n     }\n \n-    /**\n-     * @see org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic#internalClear()\n-     */\n-    protected void internalClear() {\n-        sum = Double.NaN;\n-    }\n+\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic {\n \n     /**\n-     * The currently running sumLog\n+     * The currently running value\n      */\n-    protected double sumLog = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        if (init) {\n-            sumLog = Math.log(d);\n-            init = false;\n+        if (Double.isNaN(value )) {\n+            value = Math.log(d);\n         } else {\n-            sumLog += Math.log(d);\n+            value += Math.log(d);\n         }\n \n-        return sumLog;\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return sumLog;\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n-    protected void internalClear() {\n-        sumLog = Double.NaN;\n+    public void clear() {\n+        value = Double.NaN;\n     }\n-}\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double sumLog = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumLog = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumLog += Math.log(values[i]);\n+            }\n+        }\n+        return sumLog;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n     /**\n      * The currently running sumSq\n      */\n-    protected double sumSq = Double.NaN;\n+    private double value = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        if (init) {\n-            init = false;\n-            sumSq = d * d;\n+        if (Double.isNaN(value )) {\n+            value = d * d;\n         } else {\n-            sumSq += d * d;\n+            value += d * d;\n         }\n-        return sumSq;\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return sumSq;\n+        return value;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n-    protected void internalClear() {\n-        sumSq = Double.NaN;\n+    public void clear() {\n+        value = Double.NaN;\n     }\n \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n+        double sumSq = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumSq = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumSq += Math.pow(values[i], 2.0);\n+            }\n+        }\n+        return sumSq;\n+    }\n+   \n+\n }", "timestamp": 1057544119, "metainfo": ""}