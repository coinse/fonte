{"sha": "8b62ed457040b6a1b4562aa0d0df88e1e77bddce", "log": "Updated class javadoc for ContractableDoubleArray   ", "commit": "\n--- a/src/java/org/apache/commons/math/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ContractableDoubleArray.java\n import java.io.Serializable;\n \n /**\n- * An array of double primitives which can expand as needed.\n+ * <p>\n+ * A variable length double array implementation and extension of \n+ * ExpandableDoubleArray which automatically handles expanding and\n+ * contracting double arrays.\n+ * </p>\n+ *\n+ * <p>\n+ * This class extends the functionality of ExpandableDoubleArray and\n+ * inherits the expansion parameters from that class.  If a developer\n+ * instantiates a ContractableDoubleArray and only adds values to\n+ * that instance, the behavior of this class is no different from\n+ * the behavior of the super-class ExpandableDoubleArray.  If, on the\n+ * other hand, elements are removed from the array, this implementation\n+ * tests an additional parameter <code>contractionCriteria</code>.  The\n+ * <code>contractionCriteria</code> dictates when this implementation\n+ * will contract the size of the internal storage array to\n+ * the number of elements + 1.  This check is performed after every\n+ * operation that alters the number of elements in the array.\n+ * </p>\n+ *\n+ * <p>\n+ * Note that the contractionCriteria must always be greater than the\n+ * expansionFactor.  If this were not the case (assume a \n+ * contractionCriteria of 1.5f and a expansionFactor of 2.0f) an\n+ * endless series of expansions and contractions would occur.  If the \n+ * length of this array is highly varied over time it is a good idea\n+ * to trade efficient memory usage for performance.  Each time an array\n+ * is expanded or contracted the meaningful portions of the internal\n+ * storage array are copied to a new array and the reference to the \n+ * internal storage array is swapped.\n+ * </p>\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n     }\n \n     /**\n-     * Adds an element to the end of this expandable array\n+     * <p>\n+     * Adds an element to the end of this expandable array and \n+     * discards a value from the front of the array.  This method\n+     * has the effect of adding a value to the end of the list\n+     * and discarded an element from the front of the list.\n+     * </p>\n+     *\n+     * <p>\n+     * When an array rolls it actually \"scrolls\" the element array in \n+     * the internal storage array.  An element is added to the end of the\n+     * array, and the first element of the array is discard by incrementing\n+     * the starting index of the element array within the internal\n+     * storage array.  Over time this will create an orphaned prefix\n+     * to the element array within the internal storage array.  If this\n+     * function is called frequently, this orphaned prefix list will\n+     * gradually push the internal storage vs. element storage to\n+     * the contractionCriteria.\n+     * </p>\n      * \n      * @return value to be added to end of array\n      */\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Method invokes the super class' setExpansionFactor but first it\n+     * must validate the combination of expansionFactor and \n+     * contractionCriteria.\n+     *\n      * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n      */\n     public void setExpansionFactor(float expansionFactor) {", "timestamp": 1053499586, "metainfo": ""}