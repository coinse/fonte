{"sha": "6a23f66ae368949d1a0764cdcd8aad9668bda0c3", "log": "MATH-599 Inserted \"BaseBracketedSecantSolver\" into the secant-based solvers hierarchy. Renamed \"SecantBase\" to \"BaseSecantSolver\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseBracketedSecantSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Base class for <em>Secant</em> methods that guarantee convergence\n+ * by maintaining a {@link BracketedSolution bracketed solution}.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class BaseBracketedSecantSolver extends BaseSecantSolver\n+    implements BracketedSolution {\n+    /**\n+     * Construct a solver with default accuracy (1e-6).\n+     *\n+     * @param method Method.\n+     */\n+    protected BaseBracketedSecantSolver(Method method) {\n+        super(DEFAULT_ABSOLUTE_ACCURACY, method);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method Method.\n+     */\n+    protected BaseBracketedSecantSolver(final double absoluteAccuracy,\n+                                        Method method) {\n+        super(absoluteAccuracy, method);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method Method.\n+     */\n+    protected BaseBracketedSecantSolver(final double relativeAccuracy,\n+                                        final double absoluteAccuracy,\n+                                        Method method) {\n+        super(relativeAccuracy, absoluteAccuracy, method);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public AllowedSolutions getAllowedSolutions() {\n+        return allowedSolutions;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n+        this.allowedSolutions = allowedSolutions;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathInternalError;\n+\n+/**\n+ * Base class for all <em>Secant</em>-based methods for root-finding\n+ * (approximating a zero of a univariate real function).\n+ *\n+ * <p>Implementation of the {@link SecantSolver <em>Secant</em>},\n+ * {@link RegulaFalsiSolver <em>Regula Falsi</em>}, and\n+ * {@link IllinoisSolver <em>Illinois</em>} methods is based on the\n+ * following article: M. Dowell and P. Jarratt,\n+ * <em>A modified regula falsi method for computing the root of an\n+ * equation</em>, BIT Numerical Mathematics, volume 11, number 2,\n+ * pages 168-174, Springer, 1971.</p>\n+ *\n+ * <p>Implementation of the {@link PegasusSolver <em>Pegasus</em>} method is\n+ * based on the following article: M. Dowell and P. Jarratt,\n+ * <em>The \"Pegasus\" method for computing the root of an equation</em>,\n+ * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,\n+ * 1972.</p>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class BaseSecantSolver extends AbstractUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+    /** The kinds of solutions that the algorithm may accept. */\n+    protected AllowedSolutions allowedSolutions = AllowedSolutions.EITHER_SIDE;\n+    /** The <em>Secant</em>-based root-finding method to use. */\n+    private final Method method;\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method <em>Secant</em>-based root-finding method to use\n+     */\n+    protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n+        super(absoluteAccuracy);\n+        this.method = method;\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method <em>Secant</em>-based root-finding method to use\n+     */\n+    protected BaseSecantSolver(final double relativeAccuracy,\n+                               final double absoluteAccuracy,\n+                               final Method method) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+        this.method = method;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected final double doSolve() {\n+        // Get initial solution\n+        double x0 = getMin();\n+        double x1 = getMax();\n+        double f0 = computeObjectiveValue(x0);\n+        double f1 = computeObjectiveValue(x1);\n+\n+        // If one of the bounds is the exact root, return it. Since these are\n+        // not under-approximations or over-approximations, we can return them\n+        // regardless of the allowed solutions.\n+        if (f0 == 0.0) return x0;\n+        if (f1 == 0.0) return x1;\n+\n+        // Verify bracketing of initial solution.\n+        verifyBracketing(x0, x1);\n+\n+        // Get accuracies.\n+        final double ftol = getFunctionValueAccuracy();\n+        final double atol = getAbsoluteAccuracy();\n+        final double rtol = getRelativeAccuracy();\n+\n+        // Variables to hold new bounds.\n+        double x;\n+        double fx;\n+\n+        // Keep track of inverted intervals, meaning that the left bound is\n+        // larger than the right bound. Not used for the original Secant\n+        // method.\n+        boolean inverted = false;\n+\n+        // Keep finding better approximations.\n+        while (true) {\n+            // Calculate the next approximation.\n+            x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+            fx = computeObjectiveValue(x);\n+\n+            // If the new approximation is the exact root, return it. Since\n+            // this is not an under-approximation or an over-approximation,\n+            // we can return it regardless of the allowed solutions.\n+            if (fx == 0.0) return x;\n+\n+            // Update the bounds with the new approximation.\n+            if (method == Method.SECANT) {\n+                x0 = x1;\n+                f0 = f1;\n+                x1 = x;\n+                f1 = fx;\n+            } else if (f1 * fx < 0) {\n+                // We had [x0..x1]. We update it to [x1, x]. Note that the\n+                // value of x1 has switched to the other bound, thus inverting\n+                // the interval.\n+                x0 = x1;\n+                f0 = f1;\n+                x1 = x;\n+                f1 = fx;\n+                inverted = !inverted;\n+            } else {\n+                // We had [x0..x1]. We update it to [x0, x].\n+                if (method == Method.ILLINOIS) f0 *= 0.5;\n+                if (method == Method.PEGASUS) f0 *= f1 / (f1 + fx);\n+                x1 = x;\n+                f1 = fx;\n+            }\n+\n+            // If the function value of the last approximation is too small,\n+            // given the function value accuracy, then we can't get close to\n+            // the root than we already are.\n+            if (FastMath.abs(f1) <= ftol) {\n+                switch (allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    if (inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case RIGHT_SIDE:\n+                    if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n+                }\n+            }\n+\n+            // If the current interval is within the given accuracies, we\n+            // are satisfied with the current approximation.\n+            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n+                                                     atol)) {\n+                switch (allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    return inverted ? x1 : x0;\n+                case RIGHT_SIDE:\n+                    return inverted ? x0 : x1;\n+                default:\n+                    throw new MathInternalError();\n+                }\n+            }\n+        }\n+    }\n+\n+    /** <em>Secant</em>-based root-finding methods. */\n+    protected enum Method {\n+        /** The original {@link SecantSolver <em>Secant</em>} method. */\n+        SECANT,\n+\n+        /**\n+         * The {@link RegulaFalsiSolver <em>Regula Falsi</em>} or\n+         * <em>False Position</em> method.\n+         */\n+        REGULA_FALSI,\n+\n+        /** The {@link IllinoisSolver <em>Illinois</em>} method. */\n+        ILLINOIS,\n+\n+        /** The {@link PegasusSolver <em>Pegasus</em>} method. */\n+        PEGASUS,\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class IllinoisSolver extends SecantBase implements BracketedSolution {\n+public class IllinoisSolver extends BaseBracketedSecantSolver {\n     /** Construct a solver with default accuracy (1e-6). */\n     public IllinoisSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.ILLINOIS);\n                           final double absoluteAccuracy) {\n         super(relativeAccuracy, absoluteAccuracy, Method.ILLINOIS);\n     }\n-\n-    /** {@inheritDoc} */\n-    public AllowedSolutions getAllowedSolutions() {\n-        return allowedSolutions;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n-        this.allowedSolutions = allowedSolutions;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class PegasusSolver extends SecantBase implements BracketedSolution {\n+public class PegasusSolver extends BaseBracketedSecantSolver {\n     /** Construct a solver with default accuracy (1e-6). */\n     public PegasusSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.PEGASUS);\n                          final double absoluteAccuracy) {\n         super(relativeAccuracy, absoluteAccuracy, Method.PEGASUS);\n     }\n-\n-    /** {@inheritDoc} */\n-    public AllowedSolutions getAllowedSolutions() {\n-        return allowedSolutions;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n-        this.allowedSolutions = allowedSolutions;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class RegulaFalsiSolver extends SecantBase implements BracketedSolution {\n+public class RegulaFalsiSolver extends BaseBracketedSecantSolver {\n     /** Construct a solver with default accuracy (1e-6). */\n     public RegulaFalsiSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n                              final double absoluteAccuracy) {\n         super(relativeAccuracy, absoluteAccuracy, Method.REGULA_FALSI);\n     }\n-\n-    /** {@inheritDoc} */\n-    public AllowedSolutions getAllowedSolutions() {\n-        return allowedSolutions;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n-        this.allowedSolutions = allowedSolutions;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n  *\n  * @version $Id$\n  */\n-public class SecantSolver extends SecantBase {\n+public class SecantSolver extends BaseSecantSolver {\n     /** Construct a solver with default accuracy (1e-6). */\n     public SecantSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.SECANT);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.XMinus5Function;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Base class for root-finding algorithms tests derived from\n+ * {@link BaseSecantSolver}.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class BaseSecantSolverTest {\n+    /** Returns the solver to use to perform the tests.\n+     * @return the solver to use to perform the tests\n+     */\n+    protected abstract UnivariateRealSolver getSolver();\n+\n+    /** Returns the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that\n+     * the test should be skipped for that solver.\n+     * @return the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test\n+     */\n+    protected abstract int[] getQuinticEvalCounts();\n+\n+    @Test\n+    public void testSinZero() {\n+        // The sinus function is behaved well around the root at pi. The second\n+        // order derivative is zero, which means linear approximating methods\n+        // still converge quadratically.\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+\n+        result = solver.solve(100, f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 6);\n+        result = solver.solve(100, f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n+    }\n+\n+    @Test\n+    public void testQuinticZero() {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second\n+        // derivative of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1,\n+        // because the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613\n+        // and 0.82221643, intervals containing these values are harder for\n+        // the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+        double atol = solver.getAbsoluteAccuracy();\n+        int[] counts = getQuinticEvalCounts();\n+\n+        // Tests data: initial bounds, and expected solution, per test case.\n+        double[][] testsData = {{-0.2,  0.2,  0.0},\n+                                {-0.1,  0.3,  0.0},\n+                                {-0.3,  0.45, 0.0},\n+                                { 0.3,  0.7,  0.5},\n+                                { 0.2,  0.6,  0.5},\n+                                { 0.05, 0.95, 0.5},\n+                                { 0.85, 1.25, 1.0},\n+                                { 0.8,  1.2,  1.0},\n+                                { 0.85, 1.75, 1.0},\n+                                { 0.55, 1.45, 1.0},\n+                                { 0.85, 5.0,  1.0},\n+                               };\n+        int maxIter = 500;\n+\n+        for(int i = 0; i < testsData.length; i++) {\n+            // Skip test, if needed.\n+            if (counts[i] == -1) continue;\n+\n+            // Compute solution.\n+            double[] testData = testsData[i];\n+            result = solver.solve(maxIter, f, testData[0], testData[1]);\n+            //System.out.println(\n+            //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+\n+            // Check solution.\n+            Assert.assertEquals(result, testData[2], atol);\n+            Assert.assertTrue(solver.getEvaluations() <= counts[i] + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testRootEndpoints() {\n+        UnivariateRealFunction f = new XMinus5Function();\n+        UnivariateRealSolver solver = getSolver();\n+\n+        // End-point is root. This should be a special case in the solver, and\n+        // the initial end-point should be returned exactly.\n+        double result = solver.solve(100, f, 5.0, 6.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 5.0, 6.0, 5.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0, 4.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+    }\n+\n+    @Test\n+    public void testBadEndpoints() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        try {  // bad interval\n+            solver.solve(100, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5, 1.2);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionLeftSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(\n+                                                AllowedSolutions.LEFT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution <= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionRightSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(\n+                                                AllowedSolutions.RIGHT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution >= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class IllinoisSolverTest extends SecantBaseTest {\n+public final class IllinoisSolverTest extends BaseSecantSolverTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new IllinoisSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class PegasusSolverTest extends SecantBaseTest {\n+public final class PegasusSolverTest extends BaseSecantSolverTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new PegasusSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class RegulaFalsiSolverTest extends SecantBaseTest {\n+public final class RegulaFalsiSolverTest extends BaseSecantSolverTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new RegulaFalsiSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class SecantSolverTest extends SecantBaseTest {\n+public final class SecantSolverTest extends BaseSecantSolverTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new SecantSolver();", "timestamp": 1308955003, "metainfo": ""}