{"sha": "6f04c3eec5c5c63d981c5e46e276c3946874f6b5", "log": "Rename private variables to avoid name shadowing  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n     private class FitnessFunction {\n \n         /** Optional bounds for the objective variables */\n-        private final double[][] boundaries;\n+        private final double[][] _boundaries;\n         /** Determines the penalty for boundary violations */\n         private double valueRange = 1.0;\n         /**\n          */\n         private boolean isRepairMode = true;\n         /** Flag indicating the optimization goal. */\n-        private final boolean isMinimize;\n+        private final boolean _isMinimize;\n \n         /**\n          * @param boundaries\n          */\n         private FitnessFunction(final double[][] boundaries,\n                 final boolean isMinimize) {\n-            this.boundaries = boundaries;\n-            this.isMinimize = isMinimize;\n+            this._boundaries = boundaries;\n+            this._isMinimize = isMinimize;\n         }\n \n         /**\n          * @return Normalized objective variables.\n          */\n         private double[] encode(final double[] x) {\n-            if (boundaries == null)\n+            if (_boundaries == null)\n                 return x;\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = (x[i] - boundaries[0][i]) / diff;\n+                double diff = _boundaries[1][i] - _boundaries[0][i];\n+                res[i] = (x[i] - _boundaries[0][i]) / diff;\n             }\n             return res;\n         }\n          * @return Original objective variables.\n          */\n         private double[] decode(final double[] x) {\n-            if (boundaries == null)\n+            if (_boundaries == null)\n                 return x;\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i] + boundaries[0][i];\n+                double diff = _boundaries[1][i] - _boundaries[0][i];\n+                res[i] = diff * x[i] + _boundaries[0][i];\n             }\n             return res;\n         }\n          */\n         private double value(final double[] point) {\n             double value;\n-            if (boundaries != null && isRepairMode) {\n+            if (_boundaries != null && isRepairMode) {\n                 double[] repaired = repair(point);\n                 value = CMAESOptimizer.this\n                         .computeObjectiveValue(decode(repaired)) +\n             } else\n                 value = CMAESOptimizer.this\n                         .computeObjectiveValue(decode(point));\n-            return isMinimize ? value : -value;\n+            return _isMinimize ? value : -value;\n         }\n \n         /**\n          * @return True if in bounds\n          */\n         private boolean isFeasible(final double[] x) {\n-            if (boundaries == null)\n+            if (_boundaries == null)\n                 return true;\n             for (int i = 0; i < x.length; i++) {\n                 if (x[i] < 0)\n                 double diff = Math.abs(x[i] - repaired[i]);\n                 penalty += diff * valueRange;\n             }\n-            return isMinimize ? penalty : -penalty;\n+            return _isMinimize ? penalty : -penalty;\n         }\n     }\n ", "timestamp": 1299409103, "metainfo": ""}