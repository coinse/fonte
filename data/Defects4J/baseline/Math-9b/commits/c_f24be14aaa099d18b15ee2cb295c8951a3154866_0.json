{"sha": "f24be14aaa099d18b15ee2cb295c8951a3154866", "log": "Mostly completing the methods that don't make sense if using a sparse vector in the first place.  Initial implementations for equals on the backing store, but it seems it will need more work (since still have to comment out junit tests).   Making  checkVectorDimensions protected instead of public on all RealVector classes.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n      * @exception IllegalArgumentException if the vectors do not\n      * have the same dimension\n      */\n-    public void checkVectorDimensions(RealVector v)\n+    protected void checkVectorDimensions(RealVector v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n     }\n      * @exception IllegalArgumentException if the dimension is\n      * inconsistent with vector size\n      */\n-    public void checkVectorDimensions(int n)\n+    protected void checkVectorDimensions(int n)\n         throws IllegalArgumentException {\n         if (data.length != n) {\n             throw new IllegalArgumentException(\"vector dimension is \" + data.length +\n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n      * @return The sum of <code>this</code> with <code>v</code>\n      */\n     public SparseRealVector add(SparseRealVector v) {\n+        checkVectorDimensions(v.getDimension());\n         SparseRealVector res = (SparseRealVector) copy();\n         Iterator iter = res.getEntries().iterator();\n         while (iter.hasNext()) {\n \n     /** {@inheritDoc} */\n     public RealVector mapCosToSelf() {\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            entries.put(iter.key(), Math.cos(iter.value()));\n+        for(int i=0; i < virtualSize; i++){\n+            setEntry(i, Math.cos(getEntry(i)));\n         }\n         return this;\n     }\n \n     /** {@inheritDoc} */\n     public RealVector mapCoshToSelf() {\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            entries.put(iter.key(), Math.cosh(iter.value()));\n+        for(int i = 0; i < virtualSize; i++){\n+            setEntry(i, Math.cosh(getEntry(i)));\n         }\n         return this;\n     }\n      * @exception IllegalArgumentException\n      *                if the dimension is inconsistent with vector size\n      */\n-    public void checkVectorDimensions(int n) throws IllegalArgumentException {\n+    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n         if (getDimension() != n) {\n             throw new IllegalArgumentException(\"vector dimension is \"\n                     + getDimension() + \", not \" + n + \" as expected\");\n     public double[] toArray() {\n         return getData();\n     }\n+\n+    /* (non-Javadoc)\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((entries == null) ? 0 : entries.hashCode());\n+        long temp;\n+        temp = Double.doubleToLongBits(epsilon);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        result = prime * result + virtualSize;\n+        return result;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        System.out.println(\"Checking equality of \"+obj);\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof SparseRealVector))\n+            return false;\n+        System.out.println(\"is a sparse vector\");\n+        SparseRealVector other = (SparseRealVector) obj;\n+        if (entries == null) {\n+            if (other.entries != null)\n+                return false;\n+        } else if (!entries.equals(other.entries)){\n+            System.out.println(\"no entries match\");\n+            return false;\n+        }if (Double.doubleToLongBits(epsilon) != Double\n+                .doubleToLongBits(other.epsilon))\n+            return false;\n+        if (virtualSize != other.virtualSize)\n+            return false;\n+        return true;\n+    }\n }\n--- a/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.Serializable;\n+import java.util.Arrays;\n import java.util.ConcurrentModificationException;\n import java.util.NoSuchElementException;\n \n         count = 0;\n     }\n \n+    /* (non-Javadoc)\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + Arrays.hashCode(keys);\n+        result = prime * result + mask;\n+        long temp;\n+        temp = Double.doubleToLongBits(missingEntries);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        result = prime * result + size;\n+        result = prime * result + Arrays.hashCode(states);\n+        result = prime * result + Arrays.hashCode(values);\n+        return result;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        OpenIntToDoubleHashMap other = (OpenIntToDoubleHashMap) obj;\n+        if (!Arrays.equals(keys, other.keys))\n+            return false;\n+        if (mask != other.mask)\n+            return false;\n+        if (Double.doubleToLongBits(missingEntries) != Double\n+                .doubleToLongBits(other.missingEntries))\n+            return false;\n+        if (size != other.size)\n+            return false;\n+        if (!Arrays.equals(states, other.states)){\n+            System.out.println(\"states not match:\" );\n+            for(byte e : states){\n+                System.out.print(e+\" \");\n+            }\n+            System.out.println();\n+            for(byte e : other.states){\n+                System.out.print(e+\" \");\n+            }\n+            return false;\n+        }\n+        if (!Arrays.equals(values, other.values)){\n+            System.out.println(\"values don't match\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n         assertEquals(\"testData len\", 7, v1.getDimension());\n         assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n \n-        /* TODO: make this supported */\n-        //SparseRealVector v2 = new SparseRealVector(5, 1.23);\n-        //assertEquals(\"testData len\", 5, v2.getDimension());\n-        //assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n-\n         SparseRealVector v3 = new SparseRealVector(vec1);\n         assertEquals(\"testData len\", 3, v3.getDimension());\n         assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n         assertEquals(\"testData len\", 6, v_append_3.getDimension());\n         assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n \n-\t/* TODO: fixme */\n-        //RealVector v_append_4 = v1.append(v2_t);\n-        //assertEquals(\"testData len\", 6, v_append_4.getDimension());\n-        //assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n-\n-        /* TODO: fixme */\n-        //RealVector v_copy = v1.copy();\n-        //assertEquals(\"testData len\", 3, v_copy.getDimension());\n-        //assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n-        /* TODO: fixme */\n-        //double[] a_double = v1.toArray();\n-        //assertEquals(\"testData len\", 3, a_double.length);\n-        //assertNotSame(\"testData not same object \", v1.data, a_double);\n-\n-\n-//      SparseRealVector vout4 = (SparseRealVector) v1.clone();\n-//      assertEquals(\"testData len\", 3, vout4.getDimension());\n-//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n-\n-\n+\t    RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+        \n         RealVector vout5 = v4.getSubVector(3, 3);\n         assertEquals(\"testData len\", 3, vout5.getDimension());\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        } \n-\n-\t/* TODO: fixme */\n-\t//try {\n-        //    v1.checkVectorDimensions(v4); \n-        //    fail(\"IllegalArgumentException expected\");\n-        //} catch (IllegalArgumentException ex) {\n-            // expected behavior\n-        //} catch (Exception e) {\n-        //    fail(\"wrong exception caught\");\n-        //}        \n-\n-\t/* TODO: fixme */\n-        //try {\n-        //    v1.checkVectorDimensions(v4_2); \n-        //    fail(\"IllegalArgumentException expected\");\n-        //} catch (IllegalArgumentException ex) {\n-            // expected behavior\n-\t// } catch (Exception e) {\n-        //    fail(\"wrong exception caught\");\n-        //}        \n+        }     \n+\n \n     }\n \n \n         assertFalse(v.isInfinite());\n         v.setEntry(0, Double.POSITIVE_INFINITY);\n-        // TODO: fixme\n+        // TODO: why is this test here\n         //assertFalse(v.isInfinite());\n         v.setEntry(1, 1);\n         assertTrue(v.isInfinite());\n \n-        v.setEntry(0, 0);\n-        // TODO: backing store doesn't yet implement equals\n+        //TODO: differeciate from resetting to zero\n+        //v.setEntry(0, 0);\n         //assertEquals(v, new SparseRealVector(new double[] { 0, 1, 2 }));\n-        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n-        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n+        assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n \n         //assertEquals(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n         //              new SparseRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());", "timestamp": 1234155027, "metainfo": ""}