{"sha": "2bbad8ecca1a9b52c20dadcff06f30682a77a738", "log": "Added a FixedDoubleArray.  FixedDoubleArray supports a rolling mechanism that reuses an array of fixed length.  This classes was added to an efficient rolling mechanism.  FixedDoubleArray was influenced by discussions on the commons-dev list and patches submitted by Mark Diggory.   ", "commit": "\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n \t\tstartIndex += 1;\n \t\t\n \t\t// Add the new value\n-\t\tinternalArray[startIndex + (numElements -1)] = value;\n+\t\tinternalArray[startIndex + (numElements - 1)] = value;\n \t\t\n \t\treturn discarded;\n \t}\n \tpublic double getMax() {\n \t\tdouble max = internalArray[startIndex];\n \t\t\n-\t\tfor( int i = startIndex + 1; i < numElements; i++) {\n+\t\tfor( int i = startIndex + 1; i < (numElements + startIndex); i++) {\n \t\t\tif( internalArray[i] > max ) {\n \t\t\t\tmax = internalArray[i];\n \t\t\t}\n \tpublic double getMin() {\n \t\tdouble min = internalArray[startIndex];\n \t\t\n-\t\tfor( int i = startIndex + 1; i < numElements; i++) {\n+\t\tfor( int i = startIndex + 1; i < (numElements + startIndex); i++) {\n \t\t\tif( internalArray[i] < min ) {\n \t\t\t\tmin = internalArray[i];\n \t\t\t}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/FixedDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Provides a fixed size implementation of the DoubleArray with\n+ * support to true \"rolling\" functionality.  If a program attempts to add\n+ * a value to a fixed array which has reach a maximum number of \n+ * elements a ArrayIndexOutOfBoundsException will be thrown.   \n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class FixedDoubleArray implements DoubleArray {\n+\n+\tdouble[] internalArray;\n+\t\n+\tint size = 0;\n+\tint nextAdd = 0;\n+\tint maxElements = 0;\n+\n+\tpublic FixedDoubleArray(int maxElements) {\n+\t\tthis.maxElements = maxElements;\n+\t\tinternalArray = new double[maxElements];\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getNumElements()\n+\t */\n+\tpublic int getNumElements() {\n+\t\treturn size;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getElement(int)\n+\t */\n+\tpublic double getElement(int index) throws NoSuchElementException {\n+\t\tif( index > (size-1) ) {\n+\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to retrieve an element outside of\" +\n+\t\t\t\t\"the element array\");\n+\t\t} else {\n+\t\t\treturn internalArray[index];\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n+\t */\n+\tpublic void setElement(int index, double value) {\n+\t\tif( index > (size-1) ) {\n+\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to set an element outside of\" +\n+\t\t\t\t\"the element array\");\n+\t\t} else {\n+\t\t\tinternalArray[index] = value;\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#addElement(double)\n+\t */\n+\tpublic void addElement(double value) {\n+\t\tif( size < internalArray.length ) {\n+\t\t\tsize++;\n+\t\t\t\n+\t\t\tinternalArray[nextAdd] = value;\n+\t\t\t\n+\t\t\tnextAdd++;\n+\t\t\tnextAdd = nextAdd % (maxElements);\n+\n+\t\t} else {\n+\t\t\tthrow new ArrayIndexOutOfBoundsException(\"Attempted to add a value to an array of fixed size, please \" +\n+\t\t\t\t\"use addElementRolling to avoid this exception\");\n+\t\t}\n+\t\t\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#addElementRolling(double)\n+\t */\n+\tpublic double addElementRolling(double value) {\n+\t\tif( size < internalArray.length ) {\n+\t\t\tsize++;\n+\t\t} \n+\t\t\n+\t\tdouble discarded = internalArray[nextAdd];\n+\n+\t\tinternalArray[nextAdd] = value;\n+\n+\t\tnextAdd++;\n+\t\tnextAdd = nextAdd % maxElements;\t\n+\t\t\n+\t\t// but we return the value which was \"replaced\"\n+\t\treturn( discarded );\t\t\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getElements()\n+\t */\n+\tpublic double[] getElements() {\n+\t\tdouble[] copy = new double[internalArray.length];\n+\t\tSystem.arraycopy(internalArray, 0, copy, 0, internalArray.length);\n+\t\treturn copy;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#clear()\n+\t */\n+\tpublic void clear() {\n+\t\tsize = 0;\n+\t\tnextAdd = 0;\n+\t\tinternalArray = new double[maxElements];\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#discardFrontElements(int)\n+\t */\n+\tpublic void discardFrontElements(int i) {\n+\t\t// TODO: AH! implemented there is not concept of \"front\"\n+\t\t// in an array that discards values when rolling.....  anyone?\n+\t\tthrow new RuntimeException(\"Discarding front element not supported in FixedDoubleArray\");\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getMin()\n+\t */\n+\tpublic double getMin() {\n+\t\tdouble min = internalArray[0];\n+\t\tfor( int i = 1; i < size; i++) {\n+\t\t\tif( internalArray[i] < min ) {\n+\t\t\t\tmin = internalArray[i];\n+\t\t\t}\n+\t\t}\n+\t\treturn min;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getMax()\n+\t */\n+\tpublic double getMax() {\n+\t\tdouble max = internalArray[0];\n+\t\tfor( int i = 1; i < size; i++) {\n+\t\t\tif( internalArray[i] > max ) {\n+\t\t\t\tmax = internalArray[i];\n+\t\t\t}\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n+}\n--- a/src/java/org/apache/commons/math/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/UnivariateImpl.java\n  * to doubles by addValue().  \n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.3 $ $Date: 2003/05/16 05:23:29 $\n+ * @version $Revision: 1.4 $ $Date: 2003/05/17 23:24:21 $\n  * \n */\n public class UnivariateImpl implements Univariate, Serializable {\n \t/** Just in case, the windowSize is not inifinite, we need to\n \t *   keep an array to remember values 0 to N\n \t */\n-\tprivate DoubleArray doubleArray =\n-\t\tnew ContractableDoubleArray(); \n-\n+\tprivate DoubleArray doubleArray;\n+\t\n     /** running sum of values that have been added */\n     private double sum = 0.0;\n \n     public UnivariateImpl() {\n         clear();\n     }\n+    \n+    /** Create a new univariate with a fixed window **/\n+    public UnivariateImpl(int window) {\n+    \twindowSize = window;\n+   \t\tdoubleArray = new FixedDoubleArray( window );\n+     }\n \n     /**\n      * Adds the value, updating running sums.\n     \t\tif( windowSize == n ) {\n \t\t\t\tdouble discarded = doubleArray.addElementRolling( v );        \t\n \t\t\t\n-\t\t\t\t// Remove the influence of the discarded\n-\t\t\t\tsum -= discarded;\n-\t\t\t\tsumsq -= discarded * discarded;\n+\t\t\t\t// Remove the influence of discarded value ONLY\n+\t\t\t\t// if the discard value has any meaning.  In other words\n+\t\t\t\t// don't discount until we \"roll\".\n+\t\t\t\tif( windowSize > doubleArray.getNumElements() ) {\n+\t\t\t\t\t// Remove the influence of the discarded\n+\t\t\t\t\tsum -= discarded;\n+\t\t\t\t\tsumsq -= discarded * discarded;\n+\t\t\t\t}\n \t\t\t\n \t\t\t\t// Include the influence of the new\n \t\t\t\t// TODO: The next two lines seems rather expensive, but\n \t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n \t */\n \tpublic void setWindowSize(int windowSize) {\n-\t\tthis.windowSize = windowSize;\n+\t\tthrow new RuntimeException( \"A fixed window size must be set via the UnivariateImpl constructor\");\n \t}\n \n }\n--- a/src/test/org/apache/commons/math/ContractableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ContractableDoubleArrayTest.java\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n-public class ContractableDoubleArrayTest extends DoubleArrayAbstractTest {\n+public class ContractableDoubleArrayTest extends ExpandableDoubleArrayTest {\n \n \tpublic ContractableDoubleArrayTest(String name) {\n \t\tsuper( name );\n \t */\n \tprotected void setUp() throws Exception {\n \t\tda = new ContractableDoubleArray();\n+\t\tra = new ContractableDoubleArray();\n \t}\n \n-\t/** Test normal operations and then test internal storage */\n-\tpublic void testAdd1000() {\n-\t\tsuper.testAdd1000();\n-\t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n-\t\t\t\"16 and an expansion factor of 2.0\",\n-\t\t\t\t\t\t\t1024, ((ExpandableDoubleArray) da).getInternalLength());\n-\t}\n-\t\n-\tpublic void testSetElementArbitraryExpansion() {\n-\t\tsuper.testSetElementArbitraryExpansion();\n-\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", ((ExpandableDoubleArray) da).getInternalLength(), 1001);\n-\t}\n-\n-\tpublic void testAddElementRolling() {\n-\t\tsuper.testAddElementRolling();\n-\t\tassertTrue( \"Even though there are only 6 element, internal storage should be less than 2.5 times the number of elements\", \n-\t\t\t((ExpandableDoubleArray) da).getInternalLength() < ((int) 6 * 2.5) );\n-\t}\n-\n-\n-\t/** Test ERROR conditions */\n-\t/** TEST ERROR CONDITIONS **/\n-\n-\tpublic void testIllegalInitialCapacity() {\n-\t\ttry {\n-\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(-3, 2.0f);\n-\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n-\t\t\t\t\"the initialCapacity was negative, if it didn't then\" +\n-\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\t\ttry {\n-\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(0, 2.0f);\n-\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n-\t\t\t\t\"the initialCapacity was ZERO if it didn't then\" +\n-\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\t}\n-\t\n-\tpublic void testIllegalExpansionFactor() {\n-\t\ttry {\n-\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, 0.66f);\n-\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n-\t\t\t\t\"the expansionFactor for 0.66 which would shrink the array instead of expand the array\");\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\t\ttry {\n-\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, 0.0f);\n-\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n-\t\t\t\t\"the expansionFactor for 0.0\");\n-\t\t} catch( IllegalArgumentException iae) {\n-\t\t}\n-\t\t\n-\t\ttry {\n-\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, -4.35f);\n-\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n-\t\t\t\t\"the expansionFactor for -4.35\");\n-\t\t} catch( IllegalArgumentException iae) {\n-\t\t}\n-\t}\n-\t\n-\n }\n--- a/src/test/org/apache/commons/math/DoubleArrayAbstractTest.java\n+++ b/src/test/org/apache/commons/math/DoubleArrayAbstractTest.java\n \n \tprotected DoubleArray da = null;\n \n+\t// Array used to test rolling\n+\tprotected DoubleArray ra = null;\n+\n \tpublic DoubleArrayAbstractTest(String name) {\n-\t\tsuper( name );\n+\t\tsuper(name);\n \t}\n-\t\n-\t\n-\t\n-\t/** TEST NORMAL OPERATIONS **/\n-\t\n+\n \tpublic void testAdd1000() {\n \n-\t\tfor( int i = 0; i < 1000; i++) {\n-\t\t\tda.addElement( i );\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tda.addElement(i);\n \t\t}\n-\t\t\n-\t\tassertEquals(\"Number of elements should be equal to 1000 after adding 1000 values\",\n-\t\t\t\t\t\t\t1000, da.getNumElements() );\n-\t\t\t\t\t\t\t\n-\t\t\t\t\t\t    \n-\t\tassertEquals(\"The element at the 56th index should be 56\", \n-\t\t\t\t\t\t\t56.0, da.getElement(56), Double.MIN_VALUE );\n-\t\t\t\t\t\t    \n+\n+\t\tassertEquals(\n+\t\t\t\"Number of elements should be equal to 1000 after adding 1000 values\",\n+\t\t\t1000,\n+\t\t\tda.getNumElements());\n+\n+\t\tassertEquals(\n+\t\t\t\"The element at the 56th index should be 56\",\n+\t\t\t56.0,\n+\t\t\tda.getElement(56),\n+\t\t\tDouble.MIN_VALUE);\n+\n \t}\n-\t\n-\t\n+\n \tpublic void testGetValues() {\n-\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n-\t\t\n+\t\tdouble[] controlArray = { 2.0, 4.0, 6.0 };\n+\n \t\tda.addElement(2.0);\n \t\tda.addElement(4.0);\n \t\tda.addElement(6.0);\n \t\tdouble[] testArray = da.getElements();\n-\t\t\n-\t\tfor( int i = 0; i < da.getNumElements(); i++) {\n-\t\t\tassertEquals( \"The testArray values should equal the controlArray values, index i: \" + i +\n-\t\t\t\t\" does not match\", testArray[i], controlArray[i], Double.MIN_VALUE);\n-\t\t}\n-\t\t\n-\t}\n-\t\n-\tpublic void testSetElementArbitraryExpansion() {\n-\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n-\t\t\n-\t\tda.addElement(2.0);\n-\t\tda.addElement(4.0);\n-\t\tda.addElement(6.0);\n-\t\tda.setElement(1, 3.0);\n-\t\t\n-\t\t// Expand the array arbitrarily to 1000 items\n-\t\tda.setElement(1000, 3.4);\n \n-\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", da.getNumElements(), 1001);\n-\t\t\n-\t\tassertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n-\t\t\t\t\t\t\tda.getElement( 760 ), Double.MIN_VALUE );\n-\t\t\n-\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), Double.MIN_VALUE );\n-\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), Double.MIN_VALUE);\t\t\n-\t\t\n-\t}\n-\t\n-\tpublic void testSetNumberOfElements() {\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tassertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n-\t\t\n-\t\t((ExpandableDoubleArray) da).setNumElements( 3 );\n-\t\tassertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n-\t\t\n-\t\ttry {\n-\t\t\t((ExpandableDoubleArray) da).setNumElements( -3 );\n-\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n-\t\t} catch( IllegalArgumentException iae ) {\n+\t\tfor (int i = 0; i < da.getNumElements(); i++) {\n+\t\t\tassertEquals(\n+\t\t\t\t\"The testArray values should equal the controlArray values, index i: \"\n+\t\t\t\t\t+ i\n+\t\t\t\t\t+ \" does not match\",\n+\t\t\t\ttestArray[i],\n+\t\t\t\tcontrolArray[i],\n+\t\t\t\tDouble.MIN_VALUE);\n \t\t}\n \n-\t\t((ExpandableDoubleArray) da).setNumElements(1024);\n-\t\tassertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n-\t\tassertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n-\t\t\t\t\n \t}\n-\t\n+\n \tpublic void testAddElementRolling() {\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElement( 1.0 );\n-\t\tda.addElementRolling( 2.0 );\n-\t\t\n-\t\tassertEquals( \"There should be 6 elements in the eda\", da.getNumElements(), 6);\n-\t\tassertEquals( \"The last element should be 2.0\", da.getElement( da.getNumElements() -1 ), 2.0, Double.MIN_VALUE);\n-\t\t\n-\t\tfor( int i = 0; i  < 1024; i++ ) {\n-\t\t\tda.addElementRolling( i );\n+\t\tra.addElement(0.5);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElementRolling(2.0);\n+\n+\t\tassertEquals(\n+\t\t\t\"There should be 6 elements in the eda\",\n+\t\t\t6,\n+\t\t\tra.getNumElements());\n+\t\tassertEquals(\n+\t\t\t\"The max element should be 2.0\",\n+\t\t\t2.0,\n+\t\t\tra.getMax(),\n+\t\t\tDouble.MIN_VALUE);\n+\t\tassertEquals(\n+\t\t\t\"The min element should be 1.0\",\n+\t\t\t1.0,\n+\t\t\tra.getMin(),\n+\t\t\tDouble.MIN_VALUE);\n+\n+\t\tfor (int i = 0; i < 1024; i++) {\n+\t\t\tra.addElementRolling(i);\n \t\t}\n-\t\t\n-\t\tassertEquals( \"We just inserted 1024 rolling elements, num elements should still be 6\", da.getNumElements(), 6);\n-\t\t\t\t\n+\n+\t\tassertEquals(\n+\t\t\t\"We just inserted 1024 rolling elements, num elements should still be 6\",\n+\t\t\t6,\n+\t\t\tra.getNumElements());\n+\t}\n+\n+\tpublic void testMinMax() {\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(-2.0);\n+\t\tda.addElement(21.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(42.0);\n+\t\tda.addElement(62.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(122.0);\n+\t\tda.addElement(1212.0);\n+\n+\t\tassertEquals(\"Min should be -2.0\", -2.0, da.getMin(), Double.MIN_VALUE);\n+\t\tassertEquals(\n+\t\t\t\"Max should be 1212.0\",\n+\t\t\t1212.0,\n+\t\t\tda.getMax(),\n+\t\t\tDouble.MIN_VALUE);\n \t}\n \n }\n--- a/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n \t */\n \tprotected void setUp() throws Exception {\n \t\tda = new ExpandableDoubleArray();\n+\t\tra = new ExpandableDoubleArray();\n \t}\n \n \t/* (non-Javadoc)\n \t */\n \tprotected void tearDown() throws Exception {\n \t\tda = null;\n+\t\tra = null;\n \t}\n \t\n \t\n \t/** TEST NORMAL OPERATIONS - calling super class test and then checking internal\n \t *   storage **/\n \t\n+\t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(4.0);\n+\t\tda.addElement(6.0);\n+\t\tda.setElement(1, 3.0);\n+\t\t\n+\t\t// Expand the array arbitrarily to 1000 items\n+\t\tda.setElement(1000, 3.4);\n+\n+\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", da.getNumElements(), 1001);\n+\t\t\n+\t\tassertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+\t\t\t\t\t\t\tda.getElement( 760 ), Double.MIN_VALUE );\n+\t\t\n+\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), Double.MIN_VALUE );\n+\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), Double.MIN_VALUE);\t\t\n+\t\t\n+\t}\n+\t\t\n \tpublic void testAdd1000() {\n \t\tsuper.testAdd1000();\n \t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n \t\t\t\t\t\t\t1024, ((ExpandableDoubleArray) da).getInternalLength());\n \t}\n \t\n-\tpublic void testSetElementArbitraryExpansion() {\n-\t\tsuper.testSetElementArbitraryExpansion();\n-\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", ((ExpandableDoubleArray) da).getInternalLength(), 1001);\n-\t}\n-\n \tpublic void testAddElementRolling() {\n \t\tsuper.testAddElementRolling();\n-\t\tassertEquals( \"Even though there are only 6 element, internal storage should be 2048\", ((ExpandableDoubleArray) da).getInternalLength(), 2048);\n+\t}\n+\n+\tpublic void testSetNumberOfElements() {\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tassertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n+\t\t\n+\t\t((ExpandableDoubleArray) da).setNumElements( 3 );\n+\t\tassertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n+\t\t\n+\t\ttry {\n+\t\t\t((ExpandableDoubleArray) da).setNumElements( -3 );\n+\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\n+\t\t((ExpandableDoubleArray) da).setNumElements(1024);\n+\t\tassertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+\t\tassertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+\t\t\t\t\n \t}\n \n \t/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */\n \tpublic void testWithInitialCapacity() {\n \n \t\tExpandableDoubleArray eDA2 = new ExpandableDoubleArray(2);\n-\t\tassertEquals(\"Initial internal length should be 2\", 2, eDA2.getInternalLength());\n \t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n \n \t\tint iterations = (int) Math.pow(2.0, 15.0);\n \t\t}\n \t\t\n \t\tassertEquals(\"Number of elements should be equal to 2^15\", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());\n-\t\tassertEquals(\"Internal length should be 2^15\", (int) Math.pow(2.0, 15.0), eDA2.getInternalLength());\n \t\t\n \t\teDA2.addElement( 2.0 );\n \t\t\n \t\tassertEquals(\"Number of elements should be equals to 2^15 + 1\",\n \t\t        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );\n-\t\tassertEquals(\"Internal length should be 2^16\", (int) Math.pow(2.0, 16.0), eDA2.getInternalLength());\n \t}\n \n \tpublic void testWithInitialCapacityAndExpansionFactor() {\n \n \t\tExpandableDoubleArray eDA3 = new ExpandableDoubleArray(3, 3.0f);\n-\t\tassertEquals(\"Initial internal length should be 3\", 3, eDA3.getInternalLength() );\n \t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n \n \t\tint iterations = (int) Math.pow(3.0, 7.0);\n \t\t}\n \t\t\n \t\tassertEquals(\"Number of elements should be equal to 3^7\", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());\n-\t\tassertEquals(\"Internal length should be 3^7\", (int) Math.pow(3.0, 7.0), eDA3.getInternalLength());\n \t\t\n \t\teDA3.addElement( 2.0 );\n \t\t\n \t\tassertEquals(\"Number of elements should be equals to 3^7 + 1\",\n \t\t\t( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );\n-\t\tassertEquals(\"Internal length should be 3^8\", (int) Math.pow(3.0, 8.0), eDA3.getInternalLength());\n \t\t\t\t\t\t   \n \t\tassertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n \t}\n \t\n-\t\n+\tpublic void testDiscard() {\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tassertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+\t\t\n+\t\tda.discardFrontElements(5);\n+\t\tassertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+\t\t\n+\t\ttry {\n+\t\t\tda.discardFrontElements(-1);\n+\t\t\tfail( \"Trying to discard a negative number of element is not allowed\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tda.discardFrontElements( 10000 );\n+\t\t\tfail( \"You can't discard more elements than the array contains\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t\t\n+\t}\n+\t\t\n \t/** TEST ERROR CONDITIONS **/\n \n \tpublic void testIllegalInitialCapacity() {\n \t\t}\n \t}\n \t\n+\tpublic void testSetOutOfBounds() {\n+\t\t\ttry {\n+\t\t\t\tda.setElement( -1, 2.0);\n+\t\t\t\tfail( \"Cannot set a negative index\");\t\n+\t\t\t} catch( Exception e ){\n+\t\t\t}\n+\t}\n+\t\n+\tpublic void testGetOutOfBounds() {\n+\t\ttry {\n+\t\t\tda.getElement(10000);\n+\t\t\tfail( \"Cannot get an element that is larger than the number of elements\");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tda.getElement(-3);\n+\t\t\tfail(\"Cannot get a negative index\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t}\n+\t\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/FixedDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class FixedDoubleArrayTest extends DoubleArrayAbstractTest {\n+\n+\tpublic FixedDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\tda = new FixedDoubleArray(4000);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#tearDown()\n+\t */\n+\tprotected void tearDown() throws Exception {\n+\t\tda = null;\n+\t}\n+\t\n+\t\n+\t/** TEST NORMAL OPERATIONS - calling super class test and then checking internal\n+\t *   storage **/\n+\t\n+\tpublic void testAddElementRolling() {\n+\t\tra = new FixedDoubleArray(6);\n+\n+\t\tsuper.testAddElementRolling();\n+\t\t\n+\t\tassertEquals( \"FixedDoubleArray should have 6 size internal storage\", \n+\t\t\t\t\t\t\t\t6, ((FixedDoubleArray) ra).internalArray.length);\t\t\n+\t}\n+\t\n+\tpublic void testExceedingElements() {\n+\t\t\n+\t\tfor( int i = 0; i < 3999; i++) {\n+\t\t\tda.addElement( 1.0 );\n+\t\t}\n+\n+\t\tda.addElement( 1.0 );\n+\t\t\n+\t\ttry {\n+\t\t\tda.addElement( 2.0 );\n+\t\t\tfail( \" Adding more than 4000 elements should cause an exception \");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t\t\n+\t\tda.addElementRolling(2.0);\n+\t\tassertEquals( \"This is the first rolling add, the first element should be 2.0\",\n+\t\t\t\t\t\t\t\t2.0, da.getElement(0), Double.MIN_VALUE);\n+\t}\n+\t\n+\tpublic void testGetExceeding() {\n+\t\ttry {\n+\t\t\tda.getElement(100);\n+\t\t\tfail( \"I haven't added 100 elements to the list yet, trying to getElement(100) should \" +\n+\t\t\t\t\"thrown an error\");\n+\t\t} catch (Exception e ){ \n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic void testSetElement() {\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\t\n+\t\tda.setElement( 2, 4.0 );\n+\t\tassertEquals( \"Index 2 should be 4.0\", 4.0, da.getElement(2), Double.MIN_VALUE);\n+\t\t\n+\t\ttry {\n+\t\t\tda.setElement(2000, 45.0);\n+\t\t\tfail( \"The array does not contain 2000 elements yet, setting this element should\" +\n+\t\t\t\t\" cause an excpetion\");\n+\t\t} catch(Exception e) {\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic void testOnlyRolling() {\n+\t\tfor( int i = 0; i < 8000; i++) {\n+\t\t\tda.addElementRolling( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"The 2000th element should equal 6000\",\n+\t\t\t6000.0, da.getElement(2000), Double.MIN_VALUE);\n+\t}\n+\t\n+\tpublic void testClear() {\n+\t\tfor( int i = 0; i < 10; i++) {\n+\t\t\tda.addElementRolling(1.0);\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"There should be ten elements in the array\",\n+\t\t\t\t\t\t\t\t10, da.getNumElements() );\n+\t\t\n+\t\tda.clear();\n+\n+\t\tassertEquals( \"There should be zero elements in the array\",\n+\t\t\t\t\t\t\t\t0, da.getNumElements() );\n+\n+\t\tfor( int i = 0; i < 10; i++) {\n+\t\t\tda.addElementRolling(1.0);\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"There should be ten elements in the array\",\n+\t\t\t\t\t\t\t\t10, da.getNumElements() );\n+\t\t\t\t\n+\t}\n+\t\n+\tpublic void testDiscardFront() {\n+\t\ttry {\n+\t\t\tda.discardFrontElements( 2 );\n+\t\t\tfail( \"Discard front elements should throw an exception\");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t}\n+\t\t\n+}", "timestamp": 1053213861, "metainfo": ""}