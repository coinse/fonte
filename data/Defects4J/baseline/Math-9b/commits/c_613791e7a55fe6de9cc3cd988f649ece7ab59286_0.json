{"sha": "613791e7a55fe6de9cc3cd988f649ece7ab59286", "log": "Greatly improved QR-decomposition speed using transposed matrices internally JIRA: MATH-223  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n /**\n- * Calculates the QR-decomposition of a matrix. In the QR-decomposition of\n- * a matrix A consists of two matrices Q and R that satisfy: A = QR, Q is\n- * orthogonal (Q<sup>T</sup>Q = I), and R is upper triangular. If A is\n- * m&times;n, Q is m&times;m and R m&times;n. \n- * <p>\n- * Implemented using Householder reflectors.</p>\n+ * Calculates the QR-decomposition of a matrix.\n+ * <p>The QR-decomposition of a matrix A consists of two matrices Q and R\n+ * that satisfy: A = QR, Q is orthogonal (Q<sup>T</sup>Q = I), and R is\n+ * upper triangular. If A is m&times;n, Q is m&times;m and R m&times;n.</p>\n+ * <p>This class compute the decomposition using Householder reflectors.</p>\n+ * <p>For efficiency purposes, the decomposition in packed form is transposed.\n+ * This allows inner loop to iterate inside rows, which is much more cache-efficient\n+ * in Java.</p>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n public class QRDecompositionImpl implements QRDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 7125583145349720380L;\n+    private static final long serialVersionUID = 7560093145655650408L;\n \n     /**\n-     * A packed representation of the QR decomposition. The elements above the \n-     * diagonal are the elements of R, and the columns of the lower triangle \n-     * are the Householder reflector vectors of which an explicit form of Q can\n-     * be calculated. \n+     * A packed TRANSPOSED representation of the QR decomposition.\n+     * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+     * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+     * from which an explicit form of Q can be recomputed if desired.</p>\n      */\n-    private double[][] qr;\n+    private double[][] qrt;\n \n     /** The diagonal elements of R. */\n     private double[] rDiag;\n \n     /** {@inheritDoc} */\n     public void decompose(RealMatrix matrix) {\n+\n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n-        qr = matrix.getData();\n+        qrt = matrix.transpose().getData();\n         rDiag = new double[n];\n         cachedQ = null;\n         cachedR = null;\n          * A(minor,minor) of A:\n          */\n         for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+            final double[] qrtMinor = qrt[minor];\n+\n             /*\n              * Let x be the first column of the minor, and a^2 = |x|^2.\n              * x will be in the positions qr[minor][minor] through qr[m][minor].\n              */\n             double xNormSqr = 0;\n             for (int row = minor; row < m; row++) {\n-                final double c = qr[row][minor];\n+                final double c = qrtMinor[row];\n                 xNormSqr += c * c;\n             }\n-            final double a = (qr[minor][minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            final double a = (qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n             rDiag[minor] = a;\n \n             if (a != 0.0) {\n                  * Here <x, e> is now qr[minor][minor].\n                  * v = x-ae is stored in the column at qr:\n                  */\n-                qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n \n                 /*\n                  * Transform the rest of the columns of the minor:\n                  * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n                  * Therefore the transformation is easily calculated by\n                  * subtracting the column vector (2<x,v>/|v|^2)v from x.\n-                 * \n+                 *\n                  * Let 2<x,v>/|v|^2 = alpha. From above we have\n                  * |v|^2 = -2a*(qr[minor][minor]), so\n                  * alpha = -<x,v>/(a*qr[minor][minor])\n                  */\n-                for (int col = minor + 1; col < n; col++) {\n+                for (int col = minor+1; col < n; col++) {\n+                    final double[] qrtCol = qrt[col];\n                     double alpha = 0;\n                     for (int row = minor; row < m; row++) {\n-                        final double[] qrRow = qr[row];\n-                        alpha -= qrRow[col] * qrRow[minor];\n+                        alpha -= qrtCol[row] * qrtMinor[row];\n                     }\n-                    alpha /= a * qr[minor][minor];\n+                    alpha /= a * qrtMinor[minor];\n \n                     // Subtract the column vector alpha*v from x.\n                     for (int row = minor; row < m; row++) {\n-                        final double[] qrRow = qr[row];\n-                        qrRow[col] -= alpha * qrRow[minor];\n+                        qrtCol[row] -= alpha * qrtMinor[row];\n                     }\n                 }\n             }\n             checkDecomposed();\n \n             // R is supposed to be m x n\n-            final int m = qr.length;\n-            final int n = qr[0].length;\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n             double[][] r = new double[m][n];\n \n             // copy the diagonal from rDiag and the upper triangle of qr\n-            for (int row = Math.min(m,n)-1; row >= 0; row--) {\n-                final double[] rRow = r[row];\n+            for (int row = Math.min(m, n) - 1; row >= 0; row--) {\n+                double[] rRow = r[row];\n                 rRow[row] = rDiag[row];\n-                System.arraycopy(qr[row], row + 1, rRow, row + 1, n - row - 1);\n+                for (int col = row + 1; col < n; col++) {\n+                    rRow[col] = qrt[col][row];\n+                }\n             }\n \n             // cache the matrix for subsequent calls\n             checkDecomposed();\n \n             // Q is supposed to be m x m\n-            final int m = qr.length;\n-            final int n = qr[0].length;\n-            double[][] Q = new double[m][m];\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            double[][] q = new double[m][m];\n \n             /* \n              * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n              * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n              * succession to the result \n              */ \n-            for (int minor = m-1; minor >= Math.min(m,n); minor--) {\n-                Q[minor][minor]=1;\n+            for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n+                q[minor][minor]=1;\n             }\n \n             for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n-                Q[minor][minor] = 1;\n-                if (qr[minor][minor] != 0.0) {\n+                final double[] qrtMinor = qrt[minor];\n+                q[minor][minor] = 1;\n+                if (qrtMinor[minor] != 0.0) {\n                     for (int col = minor; col < m; col++) {\n                         double alpha = 0;\n                         for (int row = minor; row < m; row++) {\n-                            alpha -= Q[row][col] * qr[row][minor];\n+                            alpha -= q[row][col] * qrtMinor[row];\n                         }\n-                        alpha /= rDiag[minor]*qr[minor][minor];\n+                        alpha /= rDiag[minor] * qrtMinor[minor];\n \n                         for (int row = minor; row < m; row++) {\n-                            Q[row][col] -= alpha*qr[row][minor];\n+                            q[row][col] -= alpha * qrtMinor[row];\n                         }\n                     }\n                 }\n             }\n \n             // cache the matrix for subsequent calls\n-            cachedQ = new RealMatrixImpl(Q, false);\n+            cachedQ = new RealMatrixImpl(q, false);\n \n         }\n \n \n             checkDecomposed();\n \n-            final int m = qr.length;\n-            final int n = qr[0].length;\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n             double[][] hData = new double[m][n];\n             for (int i = 0; i < m; ++i) {\n+                final double[] hDataI = hData[i];\n                 for (int j = 0; j < Math.min(i + 1, n); ++j) {\n-                    hData[i][j] = qr[i][j] / -rDiag[j];\n+                    hDataI[j] = qrt[j][i] / -rDiag[j];\n                 }\n             }\n \n  \n         checkDecomposed();\n \n-        final int m = qr.length;\n-        final int n = qr[0].length;\n+        final int n = qrt.length;\n+        final int m = qrt[0].length;\n         if (b.length != m) {\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         // apply Householder transforms to solve Q.y = b\n         for (int minor = 0; minor < Math.min(m, n); minor++) {\n \n+            final double[] qrtMinor = qrt[minor];\n             double dotProduct = 0;\n             for (int row = minor; row < m; row++) {\n-                dotProduct += y[row] * qr[row][minor];\n-            }\n-            dotProduct /= rDiag[minor] * qr[minor][minor];\n+                dotProduct += y[row] * qrtMinor[row];\n+            }\n+            dotProduct /= rDiag[minor] * qrtMinor[minor];\n \n             for (int row = minor; row < m; row++) {\n-                y[row] += dotProduct * qr[row][minor];\n+                y[row] += dotProduct * qrtMinor[row];\n             }\n \n         }\n         // solve triangular system R.x = y\n         for (int row = n - 1; row >= 0; --row) {\n             y[row] /= rDiag[row];\n-            final double yRow = y[row];\n+            final double yRow   = y[row];\n+            final double[] qrtRow = qrt[row];\n             x[row] = yRow;\n             for (int i = 0; i < row; i++) {\n-                y[i] -= yRow * qr[i][row];\n+                y[i] -= yRow * qrtRow[i];\n             }\n         }\n \n \n         checkDecomposed();\n \n-        final int m = qr.length;\n-        final int n = qr[0].length;\n+        final int n = qrt.length;\n+        final int m = qrt[0].length;\n         if (b.getRowDimension() != m) {\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n             // apply Householder transforms to solve Q.y = b\n             for (int minor = 0; minor < Math.min(m, n); minor++) {\n \n+                final double[] qrtMinor = qrt[minor];\n                 double dotProduct = 0;\n                 for (int row = minor; row < m; row++) {\n-                    dotProduct += y[row] * qr[row][minor];\n-                }\n-                dotProduct /= rDiag[minor] * qr[minor][minor];\n+                    dotProduct += y[row] * qrtMinor[row];\n+                }\n+                dotProduct /= rDiag[minor] * qrtMinor[minor];\n \n                 for (int row = minor; row < m; row++) {\n-                    y[row] += dotProduct * qr[row][minor];\n+                    y[row] += dotProduct * qrtMinor[row];\n                 }\n \n             }\n             for (int row = n - 1; row >= 0; --row) {\n                 y[row] /= rDiag[row];\n                 final double yRow = y[row];\n+                final double[] qrtRow = qrt[row];\n                 xData[row][k] = yRow;\n                 for (int i = 0; i < row; i++) {\n-                   y[i] -= yRow * qr[i][row];\n+                   y[i] -= yRow * qrtRow[i];\n                 }\n              }\n \n      */\n     private void checkDecomposed()\n         throws IllegalStateException {\n-        if (qr == null) {\n+        if (qrt == null) {\n             throw new IllegalStateException(\"no matrix have been decomposed yet\");\n         }\n     }", "timestamp": 1221410291, "metainfo": ""}