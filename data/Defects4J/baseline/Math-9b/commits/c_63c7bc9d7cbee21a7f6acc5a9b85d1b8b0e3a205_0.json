{"sha": "63c7bc9d7cbee21a7f6acc5a9b85d1b8b0e3a205", "log": "added a Legendre-Gauss integrator  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    { \"invalid iteration limits: min={0}, max={1}\",\n      \"limites d''it\\u00e9rations invalides : min = {0}, max = {1}\" },\n \n+   // org.apache.commons.math.analysis.integration.LegendreGaussIntegrator\n+   { \"{0} points Legendre-Gauss integrator not supported,\" +\n+     \" number of points must be in the {1}-{2} range\",\n+     \"int\\u00e9grateur de Legendre-Gauss non support\\u00e9 en {0} points, \" +\n+     \"le nombre de points doit \\u00eatre entre {1} et {2}\" },\n+\n    // org.apache.commons.math.fraction.Fraction\n    { \"zero denominator in fraction {0}/{1}\",\n      \"d\\u00e9nominateur null dans le nombre rationnel {0}/{1}\" },\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/Legendre-GaussQuadrature.html\">\n+ * Legendre-Gauss</a> quadrature formula.\n+ * <p>\n+ * Legendre-Gauss integrators are efficient integrators that can\n+ * accurately integrate functions with few functions evaluations. A\n+ * Legendre-Gauss integrator using an n-points quadrature formula can\n+ * integrate exactly 2n-1 degree polynomialss.\n+ * </p>\n+ * <p>\n+ * These integrators evaluate the function on n carefully chosen\n+ * abscissas in each step interval (mapped to the canonical [-1  1] interval).\n+ * The evaluation abscissas are not evenly spaced and none of them are\n+ * at the interval endpoints. This implies the function integrated can be\n+ * undefined at integration interval endpoints.\n+ * </p>\n+ * <p>\n+ * The evaluation abscissas x<sub>i</sub> are the roots of the degree n\n+ * Legendre polynomial. The weights a<sub>i</sub> of the quadrature formula\n+ * integrals from -1 to +1 &int; Li<sup>2</sup> where Li (x) =\n+ * &prod; (x-x<sub>k</sub>)/(x<sub>i</sub>-x<sub>k</sub>) for k != i.\n+ * </p>\n+ * <p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class LegendreGaussIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -331962723352824098L;\n+\n+    /** Abscissas for the 2 points method. */\n+    private static final double[] ABSCISSAS_2 = {\n+        -1.0 / Math.sqrt(3.0),\n+         1.0 / Math.sqrt(3.0)\n+    };\n+\n+    /** Weights for the 2 points method. */\n+    private static final double[] WEIGHTS_2 = {\n+        1.0,\n+        1.0\n+    };\n+\n+    /** Abscissas for the 3 points method. */\n+    private static final double[] ABSCISSAS_3 = {\n+        -Math.sqrt(0.6),\n+         0.0,\n+         Math.sqrt(0.6)\n+    };\n+\n+    /** Weights for the 3 points method. */\n+    private static final double[] WEIGHTS_3 = {\n+        5.0 / 9.0,\n+        8.0 / 9.0,\n+        5.0 / 9.0\n+    };\n+\n+    /** Abscissas for the 4 points method. */\n+    private static final double[] ABSCISSAS_4 = {\n+        -Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0),\n+        -Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n+         Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n+         Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0)\n+    };\n+\n+    /** Weights for the 4 points method. */\n+    private static final double[] WEIGHTS_4 = {\n+        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0\n+    };\n+\n+    /** Abscissas for the 5 points method. */\n+    private static final double[] ABSCISSAS_5 = {\n+        -Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0),\n+        -Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n+         0.0,\n+         Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n+         Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0)\n+    };\n+\n+    /** Weights for the 5 points method. */\n+    private static final double[] WEIGHTS_5 = {\n+        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0,\n+        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+        128.0 / 225.0,\n+        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0\n+    };\n+\n+    /** Abscissas for the current method. */\n+    private final double[] abscissas;\n+\n+    /** Weights for the current method. */\n+    private final double[] weights;\n+\n+    /** Build a Legendre-Gauss integrator.\n+     * @param n number of points desired (must be between 2 and 5 inclusive)\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @exception IllegalArgumentException if the number of points is not\n+     * in the supported range\n+     */\n+    public LegendreGaussIntegrator(final int n, final int defaultMaximalIterationCount)\n+        throws IllegalArgumentException {\n+        super(defaultMaximalIterationCount);\n+        switch(n) {\n+        case 2 :\n+            abscissas = ABSCISSAS_2;\n+            weights   = WEIGHTS_2;\n+            break;\n+        case 3 :\n+            abscissas = ABSCISSAS_3;\n+            weights   = WEIGHTS_3;\n+            break;\n+        case 4 :\n+            abscissas = ABSCISSAS_4;\n+            weights   = WEIGHTS_4;\n+            break;\n+        case 5 :\n+            abscissas = ABSCISSAS_5;\n+            weights   = WEIGHTS_5;\n+            break;\n+        default :\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} points Legendre-Gauss integrator not supported, \" +\n+                    \"number of points must be in the {1}-{2} range\",\n+                    new Object[] { n, 2, 5 });\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double integrate(final double min, final double max)\n+        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+        return integrate(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final UnivariateRealFunction f,\n+            final double min, final double max)\n+        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        // compute first estimate with a single step\n+        double oldt = stage(f, min, max, 1);\n+\n+        int n = 2;\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+\n+            // improve integral with a larger number of steps\n+            final double t = stage(f, min, max, n);\n+\n+            // estimate error\n+            final double delta = Math.abs(t - oldt);\n+            final double limit =\n+                Math.max(absoluteAccuracy,\n+                         relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5);\n+\n+            // check convergence\n+            if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {\n+                setResult(t, i);\n+                return result;\n+            }\n+\n+            // prepare next iteration\n+            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / abscissas.length));\n+            n = Math.max((int) (ratio * n), n + 1);\n+            oldt = t;\n+\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral.\n+     * @param f the integrand function\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n number of steps\n+     * @return the value of n-th stage integral\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     */\n+    private double stage(final UnivariateRealFunction f,\n+                         final double min, final double max, final int n)\n+        throws FunctionEvaluationException {\n+\n+        // set up the step for the current stage\n+        final double step     = (max - min) / n;\n+        final double halfStep = step / 2.0;\n+\n+        // integrate over all elementary steps\n+        double midPoint = min + halfStep;\n+        double sum = 0.0;\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < abscissas.length; ++j) {\n+                sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);\n+            }\n+            midPoint += step;\n+        }\n+\n+        return halfStep * sum;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+\n+import junit.framework.*;\n+\n+public class LegendreGaussIntegratorTest\n+extends TestCase {\n+\n+    public LegendreGaussIntegratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(5, 64);\n+        integrator.setAbsoluteAccuracy(1.0e-10);\n+        integrator.setRelativeAccuracy(1.0e-14);\n+        integrator.setMinimalIterationCount(2);\n+        integrator.setMaximalIterationCount(15);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n+                             Math.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n+                Math.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);\n+        double min, max, expected, result;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        result = integrator.integrate(f, min, max);\n+        assertEquals(expected, result, 1.0e-16);\n+    }\n+\n+    public void testExactIntegration()\n+        throws ConvergenceException, FunctionEvaluationException {\n+        Random random = new Random(86343623467878363l);\n+        for (int n = 2; n < 6; ++n) {\n+            LegendreGaussIntegrator integrator =\n+                new LegendreGaussIntegrator(n, 64);\n+\n+            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly\n+            for (int degree = 0; degree <= 2 * n - 1; ++degree) {\n+                for (int i = 0; i < 10; ++i) {\n+                    double[] coeff = new double[degree + 1];\n+                    for (int k = 0; k < coeff.length; ++k) {\n+                        coeff[k] = 2 * random.nextDouble() - 1;\n+                    }\n+                    PolynomialFunction p = new PolynomialFunction(coeff);\n+                    double result    = integrator.integrate(p, -5.0, 15.0);\n+                    double reference = exactIntegration(p, -5.0, 15.0);\n+                    assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + Math.abs(reference)));\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private double exactIntegration(PolynomialFunction p, double a, double b) {\n+        final double[] coeffs = p.getCoefficients();\n+        double yb = coeffs[coeffs.length - 1] / coeffs.length;\n+        double ya = yb;\n+        for (int i = coeffs.length - 2; i >= 0; --i) {\n+            yb = yb * b + coeffs[i] / (i + 1);\n+            ya = ya * a + coeffs[i] / (i + 1);\n+        }\n+        return yb * b - ya * a;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(LegendreGaussIntegratorTest.class);\n+    }\n+\n+}", "timestamp": 1232408414, "metainfo": ""}