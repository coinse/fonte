{"sha": "a303f3b8c90d39d1f84b19af9131b5c69c60eafc", "log": "MATH-562 Interpolator adapter for periodic data.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+\n+/**\n+ * Adapter for class implementing the {@link UnivariateRealInterpolator}\n+ * interface.\n+ * The data to be interpolated is assumed to be periodic. Thus values that are\n+ * outside of the range can be passed to the interpolation function: They will\n+ * be wrapped into the initial range before being passed to the class that\n+ * actually computes the interpolation.\n+ *\n+ * @version $Id$\n+ */\n+public class UnivariateRealPeriodicInterpolator\n+    implements UnivariateRealInterpolator {\n+    /** Default number of extension points of the samples array. */\n+    public static final int DEFAULT_EXTEND = 5;\n+    /** Interpolator. */\n+    private final UnivariateRealInterpolator interpolator;\n+    /** Period. */\n+    private final double period;\n+    /** Number of extension points. */\n+    private final int extend;\n+\n+    /**\n+     * Builds an interpolator.\n+     *\n+     * @param interpolator Interpolator.\n+     * @param period Period.\n+     * @param extend Number of points to be appended at the beginning and\n+     * end of the sample arrays in order to avoid interpolation failure at\n+     * the (periodic) boundaries of the orginal interval. The value is the\n+     * number of sample points which the original {@code interpolator} needs\n+     * on each side of the interpolated point.\n+     */\n+    public UnivariateRealPeriodicInterpolator(UnivariateRealInterpolator interpolator,\n+                                              double period,\n+                                              int extend) {\n+        this.interpolator = interpolator;\n+        this.period = period;\n+        this.extend = extend;\n+    }\n+\n+    /**\n+     * Builds an interpolator.\n+     * Uses {@link #DEFAULT_EXTEND} as the number of extension points on each side\n+     * of the original abscissae range.\n+     *\n+     * @param interpolator Interpolator.\n+     * @param period Period.\n+     */\n+    public UnivariateRealPeriodicInterpolator(UnivariateRealInterpolator interpolator,\n+                                              double period) {\n+        this(interpolator, period, DEFAULT_EXTEND);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NumberIsTooSmallException if the number of extension points\n+     * iss larger then the size of {@code xval}.\n+     */\n+    public UnivariateRealFunction interpolate(double[] xval,\n+                                              double[] yval) {\n+        if (xval.length < extend) {\n+            throw new NumberIsTooSmallException(xval.length, extend, true);\n+        }\n+\n+        MathUtils.checkOrder(xval);\n+        final double offset = xval[0];\n+\n+        final int len = xval.length + extend * 2;\n+        final double[] x = new double[len];\n+        final double[] y = new double[len];\n+        for (int i = 0; i < xval.length; i++) {\n+            final int index = i + extend;\n+            x[index] = MathUtils.reduce(xval[i], period, offset);\n+            y[index] = yval[i];\n+        }\n+\n+        // Wrap to enable interpolation at the boundaries.\n+        for (int i = 0; i < extend; i++) {\n+            int index = xval.length - extend + i;\n+            x[i] = MathUtils.reduce(xval[index], period, offset) - period;\n+            y[i] = yval[index];\n+\n+            index = len - extend + i;\n+            x[index] = MathUtils.reduce(xval[i], period, offset) + period;\n+            y[index] = yval[i];\n+        }\n+\n+        MathUtils.sortInPlace(x, y);\n+\n+        final UnivariateRealFunction f = interpolator.interpolate(x, y);\n+        return new UnivariateRealFunction() {\n+            public double value(final double x) {\n+                return f.value(MathUtils.reduce(x, period, offset));\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.util.Random;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test for {@link UnivariateRealPeriodicInterpolator}.\n+ */\n+public class UnivariateRealPeriodicInterpolatorTest {\n+    private final Random rng = new Random(1224465L);\n+\n+    @Test\n+    public void testSine() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = 0;\n+        for (int i = 0; i < n; i++) {\n+            delta += rng.nextDouble() * period / n;\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateRealInterpolator inter = new LinearInterpolator();\n+        final UnivariateRealFunction f = inter.interpolate(xval, yval);\n+\n+        final UnivariateRealInterpolator interP\n+            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+\n+        // Comparing with original interpolation algorithm.\n+        final double xMin = xval[0];\n+        final double xMax = xval[n - 1];\n+        for (int i = 0; i < n; i++) {\n+            final double x = xMin + (xMax - xMin) * rng.nextDouble();\n+            final double y = f.value(x);\n+            final double yP = fP.value(x);\n+\n+            Assert.assertEquals(\"x=\" + x, y, yP, Math.ulp(1d));\n+        }\n+\n+        // Test interpolation outside the primary interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-7);\n+        }\n+    }\n+\n+    @Test\n+    public void testLessThanOnePeriodCoverage() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = period / 2;\n+        for (int i = 0; i < n; i++) {\n+            delta += period / (2 * n) * rng.nextDouble();\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateRealInterpolator interP\n+            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+\n+        // Test interpolation outside the sample data interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-7);\n+        }\n+    }\n+\n+    @Test\n+    public void testMoreThanOnePeriodCoverage() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = period / 2;\n+        for (int i = 0; i < n; i++) {\n+            delta += 10 * period / n * rng.nextDouble();\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateRealInterpolator interP\n+            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateRealFunction fP = interP.interpolate(xval, yval);\n+\n+        // Test interpolation outside the sample data interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-6);\n+        }\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testTooFewSamples() {\n+        final double[] xval = { 2, 3, 7 };\n+        final double[] yval = { 1, 6, 5 };\n+        final double period = 10;\n+\n+        final UnivariateRealInterpolator interpolator\n+            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(), period);\n+        final UnivariateRealFunction f = interpolator.interpolate(xval, yval);\n+    }\n+\n+    @Test(expected=NonMonotonousSequenceException.class)\n+    public void testUnsortedSamples() {\n+        final double[] xval = { 2, 3, 7, 4, 6 };\n+        final double[] yval = { 1, 6, 5, -1, -2 };\n+        final double period = 10;\n+\n+        final UnivariateRealInterpolator interpolator\n+            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(), period);\n+        final UnivariateRealFunction f = interpolator.interpolate(xval, yval);\n+    }\n+}", "timestamp": 1303991831, "metainfo": ""}