{"sha": "9e2581a44ec1d38923824afcd7c7022df4536443", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=24962 Obtained from: sergei skarupo  Refactored all sign methods to indicator. Created new Sign methods per wolfram specs.   ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/ComplexMath.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexMath.java\n  * Reference:\n  *   http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\n  * \n- * @version $Revision: 1.4 $ $Date: 2003/11/15 18:52:31 $\n+ * @version $Revision: 1.5 $ $Date: 2004/01/26 19:41:16 $\n  */\n public class ComplexMath {\n     \n             return new Complex(t, b / (2.0 * t));\n         } else {\n             return new Complex(Math.abs(z.getImaginary()) / (2.0 * t),\n-                MathUtils.sign(b) * t);\n+                MathUtils.indicator(b) * t);\n         }\n     }\n     \n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n  *\n- * @version $Revision: 1.9 $ $Date: 2003/11/14 22:22:17 $\n+ * @version $Revision: 1.10 $ $Date: 2004/01/26 19:41:16 $\n  */\n public final class MathUtils {\n \n+\tprivate static final byte ZB = (byte) 0;\n+\t\n+\tprivate static final byte NB = (byte) -1;\n+\t\n+\tprivate static final byte PB = (byte) 1;\n+\t\n+\tprivate static final short ZS = (short) 0;\n+\t\n+\tprivate static final short NS = (short) -1;\n+\t\n+\tprivate static final short PS = (short) 1;\n+\t\n     /**\n      * Private Constructor\n      */\n     private MathUtils() {\n     }\n \n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * +1.0 : x < 0.0\n+     *  0.0 : x = 0.0\n+     * -1.0 : x > 0.0\n+     * \n+     * @param x the value, a double\n+     * @return +1.0, 0.0 or -1.0, depending on the the value of x\n+     */\n+    public static double sign(final double x) {\n+    \tif (Double.isNaN(x)) {\n+    \t\treturn Double.NaN;\n+    \t}\n+    \treturn (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n+    }\n+\n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * +1.0F : x < 0.0F\n+     *  0.0F : x = 0.0F\n+     * -1.0F : x > 0.0F\n+     * \n+     * For a float value x, this method returns +1.0F if x >= 0\n+     * and -1.0F if x < 0.\n+     * @param x the value, a float\n+     * @return +1.0F or -1.0F, depending on the the sign of x\n+     */\n+    public static float sign(final float x) {\n+    \tif (Float.isNaN(x)) {\n+    \t\treturn Float.NaN;\n+    \t}\n+    \treturn (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n+    }\n+\n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * (byte)+1.0 : x < (byte)0.0\n+     * (byte) 0.0 : x = (byte)0.0\n+     * (byte)-1.0 : x > (byte)0.0\n+     * \n+     * For a byte value x, this method returns (byte)(+1) if x >= 0\n+     * and (byte)(-1) if x < 0.\n+     * @param x the value, a byte\n+     * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n+     */\n+    public static byte sign(final byte x) {\n+    \treturn (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n+    }\n+\n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * (short)+1.0 : x < (short)0.0\n+     * (short) 0.0 : x = (short)0.0\n+     * (short)-1.0 : x > (short)0.0\n+     * \n+     * For a short value x, this method returns (short)(+1) if x >= 0\n+     * and (short)(-1) if x < 0.\n+     *\n+     * @param x the value, a short\n+     * @return (short)(+1) or (short)(-1), depending on the the sign of x\n+     */\n+    public static short sign(final short x) {\n+    \treturn (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n+    }\n+\n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * +1.0 : x < 0.0\n+     *  0.0 : x = 0.0\n+     * -1.0 : x > 0.0\n+     * \n+     * For an int value x, this method returns +1 if x >= 0\n+     * and -1 if x < 0.\n+     *\n+     * @param x the value, an int\n+     * @return +1 or -1, depending on the the sign of x\n+     */\n+    public static int sign(final int x) {\n+    \treturn (x == 0) ? 0 : (x > 0) ? 1 : -1;\n+    }\n+\n+    /**\n+     * Based on rules for sign function as defined in\n+     * http://mathworld.wolfram.com/Sign.html\n+     * \n+     * +1L : x < 0L\n+     *  0L : x = 0L\n+     * -1L : x > 0L\n+     * \n+     * For a long value x, this method returns +1L if x >= 0\n+     * and -1L if x < 0.\n+     *\n+     * @param x the value, a long\n+     * @return +1L or -1L, depending on the the sign of x\n+     */\n+    public static long sign(final long x) {\n+    \treturn (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n+    }\n+    \n     /**\n      * For a double precision value x, this method returns +1.0 if x >= 0\n      * and -1.0 if x < 0.\n      * @param x the value, a double\n      * @return +1.0 or -1.0, depending on the the sign of x\n      */\n-    public static double sign(final double x) {\n-        if (x >= 0.0) {\n-            return 1.0;\n-        } else {\n-            return -1.0;\n-        }\n+    public static double indicator(final double x) {\n+    \tif (Double.isNaN(x)) {\n+    \t\treturn Double.NaN;\n+    \t}\n+    \treturn (x >= 0.0) ? 1.0 : -1.0;\n     }\n \n     /**\n      * @param x the value, a float\n      * @return +1.0F or -1.0F, depending on the the sign of x\n      */\n-    public static float sign(final float x) {\n-        if (x >= 0.0F) {\n-            return 1.0F;\n-        } else {\n-            return -1.0F;\n-        }\n+    public static float indicator(final float x) {\n+    \tif (Float.isNaN(x)) {\n+    \t\treturn Float.NaN;\n+    \t}\n+    \treturn (x >= 0.0F) ? 1.0F : -1.0F;\n     }\n \n     /**\n      * @param x the value, a byte\n      * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n      */\n-    public static byte sign(final byte x) {\n-        if (x >= (byte) 0) {\n-            return (byte) 1;\n-        } else {\n-            return (byte) (-1);\n-        }\n+    public static byte indicator(final byte x) {\n+    \treturn (x >= ZB) ? PB : NB;\n     }\n \n     /**\n      * @param x the value, a short\n      * @return (short)(+1) or (short)(-1), depending on the the sign of x\n      */\n-    public static short sign(final short x) {\n-        if (x >= (short) 0) {\n-            return (short) 1;\n-        } else {\n-            return (short) (-1);\n-        }\n+    public static short indicator(final short x) {\n+        return (x > ZS) ? PS : NS;\n     }\n \n     /**\n      * @param x the value, an int\n      * @return +1 or -1, depending on the the sign of x\n      */\n-    public static int sign(final int x) {\n-        if (x >= 0) {\n-            return 1;\n-        } else {\n-            return -1;\n-        }\n+    public static int indicator(final int x) {\n+    \treturn (x >= 0) ? 1 : -1;\n     }\n \n     /**\n      * @param x the value, a long\n      * @return +1L or -1L, depending on the the sign of x\n      */\n-    public static long sign(final long x) {\n-        if (x >= 0L) {\n-            return 1L;\n-        } else {\n-            return -1L;\n-        }\n-    }\n+    public static long indicator(final long x) {\n+        return (x >= 0L) ? 1L : -1L;\n+    }\n+    \n     /**\n      * Returns an exact representation of the\n      * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n /**\n  * Test cases for the MathUtils class.\n  *\n- * @version $Revision: 1.7 $ $Date: 2003/11/15 18:52:31 $\n+ * @version $Revision: 1.8 $ $Date: 2004/01/26 19:41:16 $\n  */\n \n public final class MathUtilsTest extends TestCase {\n \n     public void testSignDouble() {\n         double delta = 0.0 ;\n-        assertEquals( 1.0, MathUtils.sign( 2.0 ), delta ) ;\n-        assertEquals( -1.0, MathUtils.sign( -2.0 ), delta ) ;\n+        assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;\n+        assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;\n     }\n \n \n     public void testSignFloat() {\n         float delta = 0.0F ;\n-        assertEquals( 1.0F, MathUtils.sign( 2.0F ), delta ) ;\n-        assertEquals( -1.0F, MathUtils.sign( -2.0F ), delta ) ;\n+        assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;\n+        assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;\n     }\n \n \n     public void testSignByte() {\n-        assertEquals( (byte)1, MathUtils.sign( (byte)2 ) ) ;\n-        assertEquals( (byte)(-1), MathUtils.sign( (byte)(-2) ) ) ;\n+        assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;\n+        assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;\n     }\n \n \n     public void testSignShort() {\n-        assertEquals( (short)1, MathUtils.sign( (short)2 ) ) ;\n-        assertEquals( (short)(-1), MathUtils.sign( (short)(-2) ) ) ;\n+        assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;\n+        assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;\n     }\n \n \n     public void testSignInt() {\n-        assertEquals( (int)1, MathUtils.sign( (int)(2) ) ) ;\n-        assertEquals( (int)(-1), MathUtils.sign( (int)(-2) ) ) ;\n+        assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;\n+        assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;\n     }\n \n \n     public void testSignLong() {\n-        assertEquals( 1L, MathUtils.sign( 2L ) ) ;\n-        assertEquals( -1L, MathUtils.sign( -2L ) ) ;\n+        assertEquals( 1L, MathUtils.indicator( 2L ) ) ;\n+        assertEquals( -1L, MathUtils.indicator( -2L ) ) ;\n     }\n     \n     public void testCosh() {", "timestamp": 1075146076, "metainfo": ""}