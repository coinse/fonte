{"sha": "19a21f531697627f3cf49482796884763a6c74ba", "log": "MATH-512 Refactoring of the \"GaussianFitter\" class by Ole Ersoy.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.analysis.function.Gaussian;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n import org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n \n /**\n- * Fits points to a Gaussian function (that is, a {@link GaussianFunction}).\n+ * Fits points to a {@link\n+ * org.apache.commons.math.analysis.function.Gaussian.Parametric Gaussian} function.\n  * <p>\n  * Usage example:\n  * <pre>\n  *   fitter.addObservedPoint(4.07525716, 1447024.0);\n  *   fitter.addObservedPoint(4.08237071, 717104.0);\n  *   fitter.addObservedPoint(4.08366408, 620014.0);\n- *   GaussianFunction fitFunction = fitter.fit();\n+ *   double[] parameters = fitter.fit();\n  * </pre>\n  *\n- * @see ParametricGaussianFunction\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class GaussianFitter {\n-    /** Fitter used for fitting. */\n-    private final CurveFitter fitter;\n+public class GaussianFitter extends CurveFitter {\n \n     /**\n      * Constructs an instance using the specified optimizer.\n      * @param optimizer optimizer to use for the fitting\n      */\n     public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        fitter = new CurveFitter(optimizer);\n+        super(optimizer);;\n     }\n \n-    /**\n-     * Adds point ({@code x}, {@code y}) to list of observed points\n-     * with a weight of 1.\n-     *\n-     * @param x Abscissa value.\n-     * @param y Ordinate value.\n-     */\n-    public void addObservedPoint(double x, double y) {\n-        addObservedPoint(1, x, y);\n-    }\n-\n-    /**\n-     * Adds point ({@code x}, {@code y}) to list of observed points\n-     * with a weight of {@code weight}.\n-     *\n-     * @param weight Weight assigned to the given point.\n-     * @param x Abscissa value.\n-     * @param y Ordinate value.\n-     */\n-    public void addObservedPoint(double weight, double x, double y) {\n-        fitter.addObservedPoint(weight, x, y);\n-    }\n \n     /**\n      * Fits Gaussian function to the observed points.\n      * It will call the base class\n-     * {@link CurveFitter#fit(ParametricUnivariateRealFunction,double[]) fit} method.\n+     * {@link CurveFitter#fit(\n+     * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\n+     * double[]) fit} method.\n      *\n      * @return the Gaussian function that best fits the observed points.\n-     * @see CurveFitter\n      */\n-    public GaussianFunction fit() {\n-        return new GaussianFunction(fitter.fit(new ParametricGaussianFunction(),\n-                                               createParametersGuesser(fitter.getObservations()).guess()));\n+    public double[] fit() {\n+        return fit(new Gaussian.Parametric(),\n+                   (new ParameterGuesser(getObservations())).guess());\n     }\n \n     /**\n-     * Factory method to create a {@code GaussianParametersGuesser}\n-     * instance initialized with the specified observations.\n-     *\n-     * @param observations points used to initialize the created\n-     * {@code GaussianParametersGuesser} instance.\n-     * @return a new {@code GaussianParametersGuesser} instance.\n+     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n+     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n+     * based on the specified observed points.\n      */\n-    protected GaussianParametersGuesser createParametersGuesser(WeightedObservedPoint[] observations) {\n-        return new GaussianParametersGuesser(observations);\n+    public static class ParameterGuesser {\n+        /** Observed points. */\n+        private final WeightedObservedPoint[] observations;\n+\n+        /** Resulting guessed parameters. */\n+        private double[] parameters;\n+\n+        /**\n+         * Constructs instance with the specified observed points.\n+         *\n+         * @param observations observed points upon which should base guess\n+         */\n+        public ParameterGuesser(WeightedObservedPoint[] observations) {\n+            if (observations == null) {\n+                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+            }\n+            if (observations.length < 3) {\n+                throw new NumberIsTooSmallException(observations.length, 3, true);\n+            }\n+            this.observations = observations.clone();\n+        }\n+\n+        /**\n+         * Guesses the parameters based on the observed points.\n+         *\n+         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         */\n+        public double[] guess() {\n+            if (parameters == null) {\n+                parameters = basicGuess(observations);\n+            }\n+            return parameters.clone();\n+        }\n+\n+        /**\n+         * Guesses the parameters based on the specified observed points.\n+         *\n+         * @param points observed points upon which should base guess\n+         *\n+         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         */\n+        private double[] basicGuess(WeightedObservedPoint[] points) {\n+            Arrays.sort(points, createWeightedObservedPointComparator());\n+            double[] params = new double[3];\n+\n+\n+            int maxYIdx = findMaxY(points);\n+            params[0] = points[maxYIdx].getY();\n+            params[1] = points[maxYIdx].getX();\n+\n+            double fwhmApprox;\n+            try {\n+                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n+                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n+                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n+                fwhmApprox = fwhmX2 - fwhmX1;\n+            } catch (OutOfRangeException e) {\n+                fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n+            }\n+            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n+\n+            return params;\n+        }\n+\n+        /**\n+         * Finds index of point in specified points with the largest Y.\n+         *\n+         * @param points points to search\n+         *\n+         * @return index in specified points array\n+         */\n+        private int findMaxY(WeightedObservedPoint[] points) {\n+            int maxYIdx = 0;\n+            for (int i = 1; i < points.length; i++) {\n+                if (points[i].getY() > points[maxYIdx].getY()) {\n+                    maxYIdx = i;\n+                }\n+            }\n+            return maxYIdx;\n+        }\n+\n+        /**\n+         * Interpolates using the specified points to determine X at the specified\n+         * Y.\n+         *\n+         * @param points points to use for interpolation\n+         * @param startIdx index within points from which to start search for\n+         *        interpolation bounds points\n+         * @param idxStep index step for search for interpolation bounds points\n+         * @param y Y value for which X should be determined\n+         *\n+         * @return value of X at the specified Y\n+         *\n+         * @throws IllegalArgumentException if idxStep is 0\n+         * @throws OutOfRangeException if specified <code>y</code> is not within the\n+         *         range of the specified <code>points</code>\n+         */\n+        private double interpolateXAtY(WeightedObservedPoint[] points,\n+                                       int startIdx, int idxStep, double y)\n+            throws OutOfRangeException {\n+            if (idxStep == 0) {\n+                throw new ZeroException();\n+            }\n+            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n+            WeightedObservedPoint pointA = twoPoints[0];\n+            WeightedObservedPoint pointB = twoPoints[1];\n+            if (pointA.getY() == y) {\n+                return pointA.getX();\n+            }\n+            if (pointB.getY() == y) {\n+                return pointB.getX();\n+            }\n+            return pointA.getX() +\n+                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n+                    (pointB.getY() - pointA.getY()));\n+        }\n+\n+        /**\n+         * Gets the two bounding interpolation points from the specified points\n+         * suitable for determining X at the specified Y.\n+         *\n+         * @param points points to use for interpolation\n+         * @param startIdx index within points from which to start search for\n+         *        interpolation bounds points\n+         * @param idxStep index step for search for interpolation bounds points\n+         * @param y Y value for which X should be determined\n+         *\n+         * @return array containing two points suitable for determining X at the\n+         *         specified Y\n+         *\n+         * @throws IllegalArgumentException if idxStep is 0\n+         * @throws OutOfRangeException if specified <code>y</code> is not within the\n+         *         range of the specified <code>points</code>\n+         */\n+        private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n+                                                                   int startIdx, int idxStep, double y)\n+            throws OutOfRangeException {\n+            if (idxStep == 0) {\n+                throw new ZeroException();\n+            }\n+            for (int i = startIdx;\n+                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n+                 i += idxStep) {\n+                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n+                    return (idxStep < 0) ?\n+                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n+                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n+                }\n+            }\n+\n+            double minY = Double.POSITIVE_INFINITY;\n+            double maxY = Double.NEGATIVE_INFINITY;\n+            for (final WeightedObservedPoint point : points) {\n+                minY = Math.min(minY, point.getY());\n+                maxY = Math.max(maxY, point.getY());\n+            }\n+            throw new OutOfRangeException(y, minY, maxY);\n+\n+        }\n+\n+        /**\n+         * Determines whether a value is between two other values.\n+         *\n+         * @param value value to determine whether is between <code>boundary1</code>\n+         *        and <code>boundary2</code>\n+         * @param boundary1 one end of the range\n+         * @param boundary2 other end of the range\n+         *\n+         * @return true if <code>value</code> is between <code>boundary1</code> and\n+         *         <code>boundary2</code> (inclusive); false otherwise\n+         */\n+        private boolean isBetween(double value, double boundary1, double boundary2) {\n+            return (value >= boundary1 && value <= boundary2) ||\n+                   (value >= boundary2 && value <= boundary1);\n+        }\n+\n+        /**\n+         * Factory method creating <code>Comparator</code> for comparing\n+         * <code>WeightedObservedPoint</code> instances.\n+         *\n+         * @return new <code>Comparator</code> instance\n+         */\n+        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n+            return new Comparator<WeightedObservedPoint>() {\n+                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n+                    if (p1 == null && p2 == null) {\n+                        return 0;\n+                    }\n+                    if (p1 == null) {\n+                        return -1;\n+                    }\n+                    if (p2 == null) {\n+                        return 1;\n+                    }\n+                    if (p1.getX() < p2.getX()) {\n+                        return -1;\n+                    }\n+                    if (p1.getX() > p2.getX()) {\n+                        return 1;\n+                    }\n+                    if (p1.getY() < p2.getY()) {\n+                        return -1;\n+                    }\n+                    if (p1.getY() > p2.getY()) {\n+                        return 1;\n+                    }\n+                    if (p1.getWeight() < p2.getWeight()) {\n+                        return -1;\n+                    }\n+                    if (p1.getWeight() > p2.getWeight()) {\n+                        return 1;\n+                    }\n+                    return 0;\n+                }\n+            };\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n     throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET1, fitter);\n-        GaussianFunction fitFunction = fitter.fit();\n-        assertEquals(99200.86969833552, fitFunction.getA(), 1e-4);\n-        assertEquals(3410515.285208688, fitFunction.getB(), 1e-4);\n-        assertEquals(4.054928275302832, fitFunction.getC(), 1e-4);\n-        assertEquals(0.014609868872574, fitFunction.getD(), 1e-4);\n+        double[] parameters = fitter.fit();\n+\n+        assertEquals(3496978.1837704973, parameters[0], 1e-4);\n+        assertEquals(4.054933085999146, parameters[1], 1e-4);\n+        assertEquals(0.015039355620304326, parameters[2], 1e-4);\n     }\n \n     /**\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         fitter.fit();\n     }\n-\n+    \n     /**\n      * Two points is not enough observed points.\n      *\n             fitter);\n         fitter.fit();\n     }\n-\n+    \n     /**\n      * Poor data: right of peak not symmetric with left of peak.\n      *\n      */\n     @Test\n     public void testFit04()\n-    throws OptimizationException {\n+    throws OptimizationException \n+    {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET2, fitter);\n-        GaussianFunction fitFunction = fitter.fit();\n-        assertEquals(-256534.689445631, fitFunction.getA(), 1e-4);\n-        assertEquals(481328.2181530679, fitFunction.getB(), 1e-4);\n-        assertEquals(-10.5217226891099, fitFunction.getC(), 1e-4);\n-        assertEquals(-7.64248239366800, fitFunction.getD(), 1e-4);\n-    }\n-\n+        double[] parameters = fitter.fit();\n+\n+        assertEquals(233003.2967252038, parameters[0], 1e-4);\n+        assertEquals(-10.654887521095983, parameters[1], 1e-4);\n+        assertEquals(4.335937353196641, parameters[2], 1e-4);\n+    }  \n+    \n     /**\n      * Poor data: long tails.\n      *\n     throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET3, fitter);\n-        GaussianFunction fitFunction = fitter.fit();\n-        assertEquals(491.6310079258938, fitFunction.getA(), 1e-4);\n-        assertEquals(283508.6800413632, fitFunction.getB(), 1e-4);\n-        assertEquals(-13.2966857238057, fitFunction.getC(), 1e-4);\n-        assertEquals(1.725590356962981, fitFunction.getD(), 1e-4);\n-    }\n-\n+        double[] parameters = fitter.fit();\n+\n+        assertEquals(283863.81929180305, parameters[0], 1e-4);\n+        assertEquals(-13.29641995105174, parameters[1], 1e-4);\n+        assertEquals(1.7297330293549908, parameters[2], 1e-4);\n+    }\n+    \n     /**\n      * Poor data: right of peak is missing.\n      *\n     throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET4, fitter);\n-        GaussianFunction fitFunction = fitter.fit();\n-        assertEquals(530.3649792355617, fitFunction.getA(), 1e-4);\n-        assertEquals(284517.0835567514, fitFunction.getB(), 1e-4);\n-        assertEquals(-13.5355534565105, fitFunction.getC(), 1e-4);\n-        assertEquals(1.512353018625465, fitFunction.getD(), 1e-4);\n-    }\n+        double[] parameters = fitter.fit();\n+\n+        assertEquals(285250.66754309234, parameters[0], 1e-4);\n+        assertEquals(-13.528375695228455, parameters[1], 1e-4);\n+        assertEquals(1.5204344894331614, parameters[2], 1e-4);\n+    }    \n \n     /**\n      * Basic with smaller dataset.\n      */\n     @Test\n     public void testFit07()\n-    throws OptimizationException {\n+    throws OptimizationException \n+    {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET5, fitter);\n-        GaussianFunction fitFunction = fitter.fit();\n-        assertEquals(176748.1400947575, fitFunction.getA(), 1e-4);\n-        assertEquals(3361537.018813906, fitFunction.getB(), 1e-4);\n-        assertEquals(4.054949992747176, fitFunction.getC(), 1e-4);\n-        assertEquals(0.014192380137002, fitFunction.getD(), 1e-4);\n-    }\n-\n+        double[] parameters = fitter.fit();\n+\n+        assertEquals(3514384.729342235, parameters[0], 1e-4);\n+        assertEquals(4.054970307455625, parameters[1], 1e-4);\n+        assertEquals(0.015029412832160017, parameters[2], 1e-4);\n+    }\n+    \n     /**\n      * Adds the specified points to specified <code>GaussianFitter</code>\n      * instance.", "timestamp": 1298047557, "metainfo": ""}