{"sha": "de2670a5a653cb978b68abfe3787b9a44269aa7c", "log": "MATH-461 \"RealVectorFormat\", \"ComplexFormat\", \"Vector3DFormat\" do not inherit anymore  from the Java standard \"Format\". Removed methods that were mandated by this base class (because they were not compatible with the new policy that CM should only throw unchecked exceptions). \"CompositeFormat\" now contains only static methods: Made it a utility class        (i.e. with a \"private\" constructor).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n \n import java.text.FieldPosition;\n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.MathParseException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NoDataException;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class ComplexFormat extends CompositeFormat {\n-\n+public class ComplexFormat {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3343698360149467646L;\n-\n      /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n-\n     /** The notation used to signify the imaginary part of the complex number. */\n     private String imaginaryCharacter;\n-\n     /** The format used for the imaginary part. */\n     private NumberFormat imaginaryFormat;\n-\n     /** The format used for the real part. */\n     private NumberFormat realFormat;\n \n      * default number format for both real and imaginary parts.\n      */\n     public ComplexFormat() {\n-        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n+        this(DEFAULT_IMAGINARY_CHARACTER, CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      * @param imaginaryCharacter The custom imaginary character.\n      */\n     public ComplexFormat(String imaginaryCharacter) {\n-        this(imaginaryCharacter, getDefaultNumberFormat());\n+        this(imaginaryCharacter, CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n     }\n \n     /**\n-     * This static method calls {@link #format(Object)} on a default instance of\n-     * ComplexFormat.\n-     *\n-     * @param c Complex object to format\n-     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n-     */\n-    public static String formatComplex(Complex c) {\n-        return getInstance().format(c);\n+     * This method calls {@link #format(Object,StringBuffer,FieldPosition)}.\n+     *\n+     * @param c Complex object to format.\n+     * @return A formatted number in the form \"Re(c) + Im(c)i\".\n+     */\n+    public String format(Complex c) {\n+        return format(c, new StringBuffer(), new FieldPosition(0)).toString();\n+    }\n+\n+    /**\n+     * This method calls {@link #format(Object,StringBuffer,FieldPosition)}.\n+     *\n+     * @param c Double object to format.\n+     * @return A formatted number.\n+     */\n+    public String format(Double c) {\n+        return format(new Complex(c, 0), new StringBuffer(), new FieldPosition(0)).toString();\n     }\n \n     /**\n      * @return the value passed in as toAppendTo.\n      */\n     public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n-\n+                               FieldPosition pos) {\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         // format real\n         double re = complex.getReal();\n-        formatDouble(re, getRealFormat(), toAppendTo, pos);\n+        CompositeFormat.formatDouble(re, getRealFormat(), toAppendTo, pos);\n \n         // format sign and imaginary\n         double im = complex.getImaginary();\n         if (im < 0.0) {\n             toAppendTo.append(\" - \");\n-            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n+            CompositeFormat.formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n             toAppendTo.append(getImaginaryCharacter());\n         } else if (im > 0.0 || Double.isNaN(im)) {\n             toAppendTo.append(\" + \");\n-            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n+            CompositeFormat.formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n             toAppendTo.append(getImaginaryCharacter());\n         }\n \n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n      * @throws IllegalArgumentException is {@code obj} is not a valid type.\n      */\n-    @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n+                               FieldPosition pos) {\n \n         StringBuffer ret = null;\n \n         if (obj instanceof Complex) {\n             ret = format( (Complex)obj, toAppendTo, pos);\n         } else if (obj instanceof Number) {\n-            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n-                toAppendTo, pos);\n+            ret = format(new Complex(((Number)obj).doubleValue(), 0.0),\n+                         toAppendTo, pos);\n         } else {\n             throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX,\n                                                    obj.getClass().getName());\n      * @return the complex format specific to the given locale.\n      */\n     public static ComplexFormat getInstance(Locale locale) {\n-        NumberFormat f = getDefaultNumberFormat(locale);\n+        NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n         return new ComplexFormat(f);\n     }\n \n     /**\n      * Parses a string to produce a {@link Complex} object.\n      *\n-     * @param source the string to parse\n+     * @param source the string to parse.\n      * @return the parsed {@link Complex} object.\n-     * @exception ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     */\n-    public Complex parse(String source) throws ParseException {\n+     * @throws MathParseException if the beginning of the specified string\n+     * cannot be parsed.\n+     */\n+    public Complex parse(String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\n-                    parsePosition.getErrorIndex(),\n-                    LocalizedFormats.UNPARSEABLE_COMPLEX_NUMBER, source);\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Complex.class);\n         }\n         return result;\n     }\n         int initialIndex = pos.getIndex();\n \n         // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n \n         // parse real\n-        Number re = parseNumber(source, getRealFormat(), pos);\n+        Number re = CompositeFormat.parseNumber(source, getRealFormat(), pos);\n         if (re == null) {\n             // invalid real number\n             // set index back to initial, error index should already be set\n \n         // parse sign\n         int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n+        char c = CompositeFormat.parseNextCharacter(source, pos);\n         int sign = 0;\n         switch (c) {\n         case 0 :\n         }\n \n         // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n \n         // parse imaginary\n-        Number im = parseNumber(source, getRealFormat(), pos);\n+        Number im = CompositeFormat.parseNumber(source, getRealFormat(), pos);\n         if (im == null) {\n             // invalid imaginary number\n             // set index back to initial, error index should already be set\n         }\n \n         // parse imaginary character\n-        if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {\n+        if (!CompositeFormat.parseFixedstring(source, getImaginaryCharacter(), pos)) {\n             return null;\n         }\n \n         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n \n-    }\n-\n-    /**\n-     * Parses a string to produce a object.\n-     *\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed object.\n-     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n-     */\n-    @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n-        return parse(source, pos);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3DFormat.java\n \n import java.text.FieldPosition;\n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.exception.MathParseException;\n \n /**\n  * Formats a 3D vector in components list format \"{x; y; z}\".\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Vector3DFormat extends CompositeFormat {\n-\n+public class Vector3DFormat {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -5447606608652576301L;\n-\n     /** The default prefix: \"{\". */\n     private static final String DEFAULT_PREFIX = \"{\";\n-\n     /** The default suffix: \"}\". */\n     private static final String DEFAULT_SUFFIX = \"}\";\n-\n     /** The default separator: \", \". */\n     private static final String DEFAULT_SEPARATOR = \"; \";\n-\n     /** Prefix. */\n     private final String prefix;\n-\n     /** Suffix. */\n     private final String suffix;\n-\n     /** Separator. */\n     private final String separator;\n-\n     /** Trimmed prefix. */\n     private final String trimmedPrefix;\n-\n     /** Trimmed suffix. */\n     private final String trimmedSuffix;\n-\n     /** Trimmed separator. */\n     private final String trimmedSeparator;\n-\n     /** The format used for components. */\n     private final NumberFormat format;\n \n      * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n      */\n     public Vector3DFormat() {\n-        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+             CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      */\n     public Vector3DFormat(final String prefix, final String suffix,\n                           final String separator) {\n-        this(prefix, suffix, separator, getDefaultNumberFormat());\n+        this(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      * @return the 3D vector format specific to the given locale.\n      */\n     public static Vector3DFormat getInstance(final Locale locale) {\n-        return new Vector3DFormat(getDefaultNumberFormat(locale));\n-    }\n-\n-    /**\n-     * This static method calls {@link #format(Object)} on a default instance of\n-     * Vector3DFormat.\n+        return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This method calls {@link #format(Vector3D,StringBuffer,FieldPosition)}.\n      *\n-     * @param v Vector3D object to format\n-     * @return A formatted vector\n-     */\n-    public static String formatVector3D(Vector3D v) {\n-        return getInstance().format(v);\n+     * @param v Vector3D object to format.\n+     * @return a formatted vector.\n+     */\n+    public String format(Vector3D v) {\n+        return format(v, new StringBuffer(), new FieldPosition(0)).toString();\n     }\n \n     /**\n         toAppendTo.append(prefix);\n \n         // format components\n-        formatDouble(vector.getX(), format, toAppendTo, pos);\n+        CompositeFormat.formatDouble(vector.getX(), format, toAppendTo, pos);\n         toAppendTo.append(separator);\n-        formatDouble(vector.getY(), format, toAppendTo, pos);\n+        CompositeFormat.formatDouble(vector.getY(), format, toAppendTo, pos);\n         toAppendTo.append(separator);\n-        formatDouble(vector.getZ(), format, toAppendTo, pos);\n+        CompositeFormat.formatDouble(vector.getZ(), format, toAppendTo, pos);\n \n         // format suffix\n         toAppendTo.append(suffix);\n \n         return toAppendTo;\n-\n-    }\n-\n-    /**\n-     * Formats a object to produce a string.\n-     * <p><code>obj</code> must be a  {@link Vector3D} object. Any other type of\n-     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n-     * @param obj the object to format.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n-     */\n-    @Override\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-                               FieldPosition pos) {\n-\n-        if (obj instanceof Vector3D) {\n-            return format( (Vector3D)obj, toAppendTo, pos);\n-        }\n-\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR,\n-                                                                  obj.getClass().getName());\n-\n     }\n \n     /**\n      * Parses a string to produce a {@link Vector3D} object.\n      * @param source the string to parse\n      * @return the parsed {@link Vector3D} object.\n-     * @exception ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     */\n-    public Vector3D parse(String source) throws ParseException {\n+     * @throws MathParseException if the beginning of the specified string\n+     * cannot be parsed.\n+     */\n+    public Vector3D parse(String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\n-                    parsePosition.getErrorIndex(),\n-                    LocalizedFormats.UNPARSEABLE_3D_VECTOR, source);\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Vector3D.class);\n         }\n         return result;\n     }\n         int initialIndex = pos.getIndex();\n \n         // parse prefix\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n             return null;\n         }\n \n         // parse X component\n-        parseAndIgnoreWhitespace(source, pos);\n-        Number x = parseNumber(source, format, pos);\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number x = CompositeFormat.parseNumber(source, format, pos);\n         if (x == null) {\n             // invalid abscissa\n             // set index back to initial, error index should already be set\n         }\n \n         // parse Y component\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n-            return null;\n-        }\n-        parseAndIgnoreWhitespace(source, pos);\n-        Number y = parseNumber(source, format, pos);\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number y = CompositeFormat.parseNumber(source, format, pos);\n         if (y == null) {\n             // invalid ordinate\n             // set index back to initial, error index should already be set\n         }\n \n         // parse Z component\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n-            return null;\n-        }\n-        parseAndIgnoreWhitespace(source, pos);\n-        Number z = parseNumber(source, format, pos);\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number z = CompositeFormat.parseNumber(source, format, pos);\n         if (z == null) {\n             // invalid height\n             // set index back to initial, error index should already be set\n         }\n \n         // parse suffix\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n             return null;\n         }\n \n         return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n-\n-    }\n-\n-    /**\n-     * Parses a string to produce a object.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed object.\n-     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n-     */\n-    @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n-        return parse(source, pos);\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1097961340710804027L;\n     /** Default format. */\n-    private static final RealVectorFormat DEFAULT_FORMAT =\n-        RealVectorFormat.getInstance();\n+    private static final RealVectorFormat DEFAULT_FORMAT = RealVectorFormat.getInstance();\n     /** Entries of the vector. */\n     protected double data[];\n \n--- a/src/main/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVectorFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.exception.MathParseException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.CompositeFormat;\n \n /**\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class RealVectorFormat extends CompositeFormat {\n-\n+public class RealVectorFormat {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -708767813036157690L;\n-\n     /** The default prefix: \"{\". */\n     private static final String DEFAULT_PREFIX = \"{\";\n-\n     /** The default suffix: \"}\". */\n     private static final String DEFAULT_SUFFIX = \"}\";\n-\n     /** The default separator: \", \". */\n     private static final String DEFAULT_SEPARATOR = \"; \";\n-\n     /** Prefix. */\n     private final String prefix;\n-\n     /** Suffix. */\n     private final String suffix;\n-\n     /** Separator. */\n     private final String separator;\n-\n     /** Trimmed prefix. */\n     private final String trimmedPrefix;\n-\n     /** Trimmed suffix. */\n     private final String trimmedSuffix;\n-\n     /** Trimmed separator. */\n     private final String trimmedSeparator;\n-\n     /** The format used for components. */\n     private final NumberFormat format;\n \n      * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n      */\n     public RealVectorFormat() {\n-        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+             CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      */\n     public RealVectorFormat(final String prefix, final String suffix,\n                             final String separator) {\n-        this(prefix, suffix, separator, getDefaultNumberFormat());\n+        this(prefix, suffix, separator,\n+             CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      * @return the real vector format specific to the given locale.\n      */\n     public static RealVectorFormat getInstance(final Locale locale) {\n-        return new RealVectorFormat(getDefaultNumberFormat(locale));\n-    }\n-\n-    /**\n-     * This static method calls {@link #format(Object)} on a default instance of\n-     * RealVectorFormat.\n+        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This method calls {@link #format(RealVector,StringBuffer,FieldPosition)}.\n      *\n-     * @param v RealVector object to format\n-     * @return A formatted vector\n-     */\n-    public static String formatRealVector(RealVector v) {\n-        return getInstance().format(v);\n+     * @param v RealVector object to format.\n+     * @return a formatted vector.\n+     */\n+    public String format(RealVector v) {\n+        return format(v, new StringBuffer(), new FieldPosition(0)).toString();\n     }\n \n     /**\n             if (i > 0) {\n                 toAppendTo.append(separator);\n             }\n-            formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n+            CompositeFormat.formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n         }\n \n         // format suffix\n         toAppendTo.append(suffix);\n \n         return toAppendTo;\n-\n-    }\n-\n-    /**\n-     * Formats a object to produce a string.\n-     * <p><code>obj</code> must be a  {@link RealVector} object. Any other type of\n-     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n-     * @param obj the object to format.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws MathIllegalArgumentException is {@code obj} is not a valid type.\n-     */\n-    @Override\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-                               FieldPosition pos) {\n-\n-        if (obj instanceof RealVector) {\n-            return format((RealVector) obj, toAppendTo, pos);\n-        }\n-\n-        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR,\n-                                               obj.getClass().getName());\n-\n     }\n \n     /**\n         int initialIndex = pos.getIndex();\n \n         // parse prefix\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n             return null;\n         }\n \n         for (boolean loop = true; loop;){\n \n             if (!components.isEmpty()) {\n-                parseAndIgnoreWhitespace(source, pos);\n-                if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+                CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+                if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n                     loop = false;\n                 }\n             }\n \n             if (loop) {\n-                parseAndIgnoreWhitespace(source, pos);\n-                Number component = parseNumber(source, format, pos);\n+                CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+                Number component = CompositeFormat.parseNumber(source, format, pos);\n                 if (component != null) {\n                     components.add(component);\n                 } else {\n         }\n \n         // parse suffix\n-        parseAndIgnoreWhitespace(source, pos);\n-        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n             return null;\n         }\n \n         }\n         return new ArrayRealVector(data, false);\n     }\n-\n-    /**\n-     * Parses a string to produce a object.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed object.\n-     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n-     */\n-    @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n-        return parse(source, pos);\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/util/CompositeFormat.java\n+++ b/src/main/java/org/apache/commons/math/util/CompositeFormat.java\n package org.apache.commons.math.util;\n \n import java.text.FieldPosition;\n-import java.text.Format;\n import java.text.NumberFormat;\n import java.text.ParsePosition;\n import java.util.Locale;\n  *\n  * @version $Revision$ $Date$\n  */\n-public abstract class CompositeFormat extends Format {\n-\n+public class CompositeFormat {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 5358685519349262494L;\n+\n+    /**\n+     * Class contains only static methods.\n+     */\n+    private CompositeFormat() {}\n \n     /**\n      * Create a default number format.  The default number format is based on\n      * maximum number of fraction digits is set to 2.\n      * @return the default number format.\n      */\n-    protected static NumberFormat getDefaultNumberFormat() {\n+    public static NumberFormat getDefaultNumberFormat() {\n         return getDefaultNumberFormat(Locale.getDefault());\n     }\n \n      * @param locale the specific locale used by the format.\n      * @return the default number format specific to the given locale.\n      */\n-    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n         final NumberFormat nf = NumberFormat.getInstance(locale);\n         nf.setMaximumFractionDigits(2);\n         return nf;\n      * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n      *        holds the index of the next non-whitespace character.\n      */\n-    protected void parseAndIgnoreWhitespace(final String source,\n-                                            final ParsePosition pos) {\n+    public static void parseAndIgnoreWhitespace(final String source,\n+                                                final ParsePosition pos) {\n         parseNextCharacter(source, pos);\n         pos.setIndex(pos.getIndex() - 1);\n     }\n      * @param pos input/ouput parsing parameter.\n      * @return the first non-whitespace character.\n      */\n-    protected char parseNextCharacter(final String source,\n-                                      final ParsePosition pos) {\n+    public static char parseNextCharacter(final String source,\n+                                          final ParsePosition pos) {\n          int index = pos.getIndex();\n          final int n = source.length();\n          char ret = 0;\n      * @param pos input/ouput parsing parameter.\n      * @return the special number.\n      */\n-    private Number parseNumber(final String source, final double value,\n-                               final ParsePosition pos) {\n+    private static Number parseNumber(final String source, final double value,\n+                                      final ParsePosition pos) {\n         Number ret = null;\n \n         StringBuilder sb = new StringBuilder();\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed number.\n      */\n-    protected Number parseNumber(final String source, final NumberFormat format,\n-                                 final ParsePosition pos) {\n+    public static Number parseNumber(final String source, final NumberFormat format,\n+                                     final ParsePosition pos) {\n         final int startIndex = pos.getIndex();\n         Number number = format.parse(source, pos);\n         final int endIndex = pos.getIndex();\n      * @param pos input/ouput parsing parameter.\n      * @return true if the expected string was there\n      */\n-    protected boolean parseFixedstring(final String source, final String expected,\n-                                       final ParsePosition pos) {\n+    public static boolean parseFixedstring(final String source,\n+                                           final String expected,\n+                                           final ParsePosition pos) {\n \n         final int startIndex = pos.getIndex();\n         final int endIndex = startIndex + expected.length();\n         // the string was here\n         pos.setIndex(endIndex);\n         return true;\n-\n     }\n \n     /**\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n-    protected StringBuffer formatDouble(final double value, final NumberFormat format,\n-                                        final StringBuffer toAppendTo,\n-                                        final FieldPosition pos) {\n+    public static StringBuffer formatDouble(final double value, final NumberFormat format,\n+                                            final StringBuffer toAppendTo,\n+                                            final FieldPosition pos) {\n         if( Double.isNaN(value) || Double.isInfinite(value) ) {\n             toAppendTo.append('(');\n             toAppendTo.append(value);\n         }\n         return toAppendTo;\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n      * @param epsilon  tolerance\n      */\n     public static void assertContains(String msg, Complex[] values,\n-            Complex z, double epsilon) {\n+                                      Complex z, double epsilon) {\n         int i = 0;\n         boolean found = false;\n         while (!found && i < values.length) {\n         }\n         if (!found) {\n             Assert.fail(msg +\n-                \" Unable to find \" + ComplexFormat.formatComplex(z));\n+                        \" Unable to find \" + (new ComplexFormat()).format(z));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n package org.apache.commons.math.complex;\n \n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.util.CompositeFormat;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NullArgumentException;\n-\n-import junit.framework.TestCase;\n-\n-public abstract class ComplexFormatAbstractTest extends TestCase {\n-\n-    CompositeFormat complexFormat = null;\n+import org.apache.commons.math.exception.MathParseException;\n+\n+public abstract class ComplexFormatAbstractTest {\n+\n+    ComplexFormat complexFormat = null;\n     ComplexFormat complexFormatJ = null;\n \n     protected abstract Locale getLocale();\n \n     protected abstract char getDecimalCharacter();\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    protected ComplexFormatAbstractTest() {\n         complexFormat = ComplexFormat.getInstance(getLocale());\n         complexFormatJ = ComplexFormat.getInstance(getLocale());\n         complexFormatJ.setImaginaryCharacter(\"j\");\n     }\n \n+    @Test\n     public void testSimpleNoDecimals() {\n         Complex c = new Complex(1, 1);\n         String expected = \"1 + 1i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testSimpleWithDecimals() {\n         Complex c = new Complex(1.23, 1.43);\n         String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testSimpleWithDecimalsTrunc() {\n         Complex c = new Complex(1.2323, 1.4343);\n         String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeReal() {\n         Complex c = new Complex(-1.2323, 1.4343);\n         String expected = \"-1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeImaginary() {\n         Complex c = new Complex(1.2323, -1.4343);\n         String expected = \"1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeBoth() {\n         Complex c = new Complex(-1.2323, -1.4343);\n         String expected = \"-1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testZeroReal() {\n         Complex c = new Complex(0.0, -1.4343);\n         String expected = \"0 - 1\" + getDecimalCharacter() + \"43i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testZeroImaginary() {\n         Complex c = new Complex(30.233, 0);\n         String expected = \"30\" + getDecimalCharacter() + \"23\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testDifferentImaginaryChar() {\n         Complex c = new Complex(1, 1);\n         String expected = \"1 + 1j\";\n         String actual = complexFormatJ.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n-    public void testStaticFormatComplex() {\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testDefaultFormatComplex() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n \n         Complex c = new Complex(232.222, -342.33);\n         String expected = \"232\" + getDecimalCharacter() + \"22 - 342\" + getDecimalCharacter() + \"33i\";\n-        String actual = ComplexFormat.formatComplex(c);\n-        assertEquals(expected, actual);\n+        String actual = (new ComplexFormat()).format(c);\n+        Assert.assertEquals(expected, actual);\n \n         Locale.setDefault(defaultLocal);\n     }\n \n+    @Test\n     public void testNan() {\n         Complex c = new Complex(Double.NaN, Double.NaN);\n         String expected = \"(NaN) + (NaN)i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testPositiveInfinity() {\n         Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n         String expected = \"(Infinity) + (Infinity)i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeInfinity() {\n         Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n         String expected = \"(-Infinity) - (Infinity)i\";\n         String actual = complexFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testParseSimpleNoDecimals() {\n         String source = \"1 + 1i\";\n         Complex expected = new Complex(1, 1);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseSimpleWithDecimals() {\n         String source = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n         Complex expected = new Complex(1.23, 1.43);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseSimpleWithDecimalsTrunc() {\n         String source = \"1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(1.2323, 1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeReal() {\n         String source = \"-1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(-1.2323, 1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeImaginary() {\n         String source = \"1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeBoth() {\n         String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(-1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseZeroReal() {\n         String source = \"0\" + getDecimalCharacter() + \"0 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(0.0, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseZeroImaginary() {\n         String source = \"-1\" + getDecimalCharacter() + \"2323\";\n         Complex expected = new Complex(-1.2323, 0);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseDifferentImaginaryChar() {\n         String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343j\";\n         Complex expected = new Complex(-1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormatJ.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormatJ.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNan() {\n         String source = \"(NaN) + (NaN)i\";\n         Complex expected = new Complex(Double.NaN, Double.NaN);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParsePositiveInfinity() {\n         String source = \"(Infinity) + (Infinity)i\";\n         Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testPaseNegativeInfinity() {\n         String source = \"(-Infinity) - (Infinity)i\";\n         Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Complex actual = (Complex)complexFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testConstructorSingleFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat(nf);\n-        assertNotNull(cf);\n-        assertEquals(nf, cf.getRealFormat());\n-    }\n-\n+        Assert.assertNotNull(cf);\n+        Assert.assertEquals(nf, cf.getRealFormat());\n+    }\n+\n+    @Test\n     public void testGetImaginaryFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat();\n \n-        assertNotSame(nf, cf.getImaginaryFormat());\n+        Assert.assertNotSame(nf, cf.getImaginaryFormat());\n         cf.setImaginaryFormat(nf);\n-        assertSame(nf, cf.getImaginaryFormat());\n-    }\n-\n+        Assert.assertSame(nf, cf.getImaginaryFormat());\n+    }\n+\n+    @Test\n     public void testSetImaginaryFormatNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryFormat(null);\n-            fail();\n+            Assert.fail();\n         } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testSetRealFormatNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             cf.setRealFormat(null);\n-            fail();\n+            Assert.fail();\n         } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testGetRealFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat();\n \n-        assertNotSame(nf, cf.getRealFormat());\n+        Assert.assertNotSame(nf, cf.getRealFormat());\n         cf.setRealFormat(nf);\n-        assertSame(nf, cf.getRealFormat());\n-    }\n-\n+        Assert.assertSame(nf, cf.getRealFormat());\n+    }\n+\n+    @Test\n     public void testSetImaginaryCharacterNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryCharacter(null);\n-            fail();\n+            Assert.fail();\n         } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testSetImaginaryCharacterEmpty() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryCharacter(\"\");\n-            fail();\n+            Assert.fail();\n         } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n \n+    @Test\n     public void testFormatNumber() {\n-        CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n+        ComplexFormat cf = ComplexFormat.getInstance(getLocale());\n         Double pi = Double.valueOf(FastMath.PI);\n         String text = cf.format(pi);\n-        assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n-    }\n-\n-    public void testFormatObject() {\n-        try {\n-            CompositeFormat cf = new ComplexFormat();\n-            Object object = new Object();\n-            cf.format(object);\n-            fail();\n-        } catch (MathIllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n+        Assert.assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n+    }\n+\n+    @Test\n     public void testForgottenImaginaryCharacter() {\n         ParsePosition pos = new ParsePosition(0);\n-        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n-        assertEquals(5, pos.getErrorIndex());\n+        Assert.assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n+        Assert.assertEquals(5, pos.getErrorIndex());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n package org.apache.commons.math.geometry;\n \n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n import org.apache.commons.math.util.CompositeFormat;\n-\n-public abstract class Vector3DFormatAbstractTest extends TestCase {\n+import org.apache.commons.math.exception.MathParseException;\n+\n+public abstract class Vector3DFormatAbstractTest {\n \n     Vector3DFormat vector3DFormat = null;\n     Vector3DFormat vector3DFormatSquare = null;\n \n     protected abstract char getDecimalCharacter();\n \n-    @Override\n-    protected void setUp() throws Exception {\n+    protected Vector3DFormatAbstractTest() {\n         vector3DFormat = Vector3DFormat.getInstance(getLocale());\n         final NumberFormat nf = NumberFormat.getInstance(getLocale());\n         nf.setMaximumFractionDigits(2);\n         vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n     }\n \n+    @Test\n     public void testSimpleNoDecimals() {\n         Vector3D c = new Vector3D(1, 1, 1);\n         String expected = \"{1; 1; 1}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testSimpleWithDecimals() {\n         Vector3D c = new Vector3D(1.23, 1.43, 1.63);\n         String expected =\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testSimpleWithDecimalsTrunc() {\n         Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);\n         String expected =\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeX() {\n         Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);\n         String expected =\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeY() {\n         Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);\n         String expected =\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNegativeZ() {\n         Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);\n         String expected =\n             \"43; -1\" + getDecimalCharacter() +\n             \"63}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testNonDefaultSetting() {\n         Vector3D c = new Vector3D(1, 1, 1);\n         String expected = \"[1 : 1 : 1]\";\n         String actual = vector3DFormatSquare.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n-    public void testStaticFormatVector3D() {\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testDefaultFormatVector3D() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n \n             \"22; -342\" + getDecimalCharacter() +\n             \"33; 432\" + getDecimalCharacter() +\n             \"44}\";\n-        String actual = Vector3DFormat.formatVector3D(c);\n-        assertEquals(expected, actual);\n+        String actual = (new Vector3DFormat()).format(c);\n+        Assert.assertEquals(expected, actual);\n \n         Locale.setDefault(defaultLocal);\n     }\n \n+    @Test\n     public void testNan() {\n         Vector3D c = Vector3D.NaN;\n         String expected = \"{(NaN); (NaN); (NaN)}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testPositiveInfinity() {\n         Vector3D c = Vector3D.POSITIVE_INFINITY;\n         String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void tesNegativeInfinity() {\n         Vector3D c = Vector3D.NEGATIVE_INFINITY;\n         String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         String actual = vector3DFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n     public void testParseSimpleNoDecimals() {\n         String source = \"{1; 1; 1}\";\n         Vector3D expected = new Vector3D(1, 1, 1);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseIgnoredWhitespace() {\n         Vector3D expected = new Vector3D(1, 1, 1);\n         ParsePosition pos1 = new ParsePosition(0);\n         String source1 = \"{1;1;1}\";\n-        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));\n-        assertEquals(source1.length(), pos1.getIndex());\n+        Assert.assertEquals(expected, vector3DFormat.parse(source1, pos1));\n+        Assert.assertEquals(source1.length(), pos1.getIndex());\n         ParsePosition pos2 = new ParsePosition(0);\n         String source2 = \" { 1 ; 1 ; 1 } \";\n-        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));\n-        assertEquals(source2.length() - 1, pos2.getIndex());\n-    }\n-\n+        Assert.assertEquals(expected, vector3DFormat.parse(source2, pos2));\n+        Assert.assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    @Test\n     public void testParseSimpleWithDecimals() {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"63}\";\n         Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseSimpleWithDecimalsTrunc() {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeX() {\n         String source =\n             \"{-1\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeY() {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeZ() {\n         String source =\n             \"{1\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeAll() {\n         String source =\n             \"{-1\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseZeroX() {\n         String source =\n             \"{0\" + getDecimalCharacter() +\n             \"6333}\";\n         Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNonDefaultSetting() {\n         String source =\n             \"[1\" + getDecimalCharacter() +\n             \"6333]\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source);\n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormatSquare.parse(source);\n+            Assert.assertEquals(expected, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNan() {\n         String source = \"{(NaN); (NaN); (NaN)}\";\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n-            assertEquals(Vector3D.NaN, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D) vector3DFormat.parse(source);\n+            Assert.assertEquals(Vector3D.NaN, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParsePositiveInfinity() {\n         String source = \"{(Infinity); (Infinity); (Infinity)}\";\n         try {\n-            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);\n-            assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D)vector3DFormat.parse(source);\n+            Assert.assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testParseNegativeInfinity() {\n         String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         try {\n-            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);\n-            assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-\n+            Vector3D actual = (Vector3D)vector3DFormat.parse(source);\n+            Assert.assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n+        } catch (MathParseException ex) {\n+            Assert.fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n     public void testConstructorSingleFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         Vector3DFormat cf = new Vector3DFormat(nf);\n-        assertNotNull(cf);\n-        assertEquals(nf, cf.getFormat());\n-    }\n-\n-    public void testFormatObject() {\n-        try {\n-            CompositeFormat cf = new Vector3DFormat();\n-            Object object = new Object();\n-            cf.format(object);\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n+        Assert.assertNotNull(cf);\n+        Assert.assertEquals(nf, cf.getFormat());\n+    }\n+\n+    @Test\n     public void testForgottenPrefix() {\n         ParsePosition pos = new ParsePosition(0);\n-        assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n-        assertEquals(0, pos.getErrorIndex());\n-    }\n-\n+        Assert.assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n+        Assert.assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    @Test\n     public void testForgottenSeparator() {\n         ParsePosition pos = new ParsePosition(0);\n-        assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n-        assertEquals(6, pos.getErrorIndex());\n-    }\n-\n+        Assert.assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n+        Assert.assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    @Test\n     public void testForgottenSuffix() {\n         ParsePosition pos = new ParsePosition(0);\n-        assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n-        assertEquals(8, pos.getErrorIndex());\n+        Assert.assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n+        Assert.assertEquals(8, pos.getErrorIndex());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n     }\n \n     @Test\n-    public void testStaticFormatRealVectorImpl() {\n+    public void testDefaultFormatRealVectorImpl() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n \n             \"22; -342\" + getDecimalCharacter() +\n             \"33; 432\" + getDecimalCharacter() +\n             \"44}\";\n-        String actual = RealVectorFormat.formatRealVector(c);\n+        String actual = (new RealVectorFormat()).format(c);\n         Assert.assertEquals(expected, actual);\n \n         Locale.setDefault(defaultLocal);\n     }\n \n     @Test\n-    public void testFormatObject() {\n-        try {\n-            CompositeFormat cf = new RealVectorFormat();\n-            Object object = new Object();\n-            cf.format(object);\n-            Assert.fail();\n-        } catch (MathIllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n-    @Test\n     public void testForgottenPrefix() {\n         ParsePosition pos = new ParsePosition(0);\n         final String source = \"1; 1; 1}\";", "timestamp": 1294313527, "metainfo": ""}