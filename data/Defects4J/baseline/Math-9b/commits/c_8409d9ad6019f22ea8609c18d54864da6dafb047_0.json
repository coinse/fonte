{"sha": "8409d9ad6019f22ea8609c18d54864da6dafb047", "log": "Fixed Javadoc warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/PoissonDistribution.java\n      *\n      * The upper bound of the support is positive infinity,\n      * regardless of the parameter values. There is no integer infinity,\n-     * so this method returns {@code Integer.MAX_VALUE} and\n-     * {@link #isSupportUpperBoundInclusive()} returns {@code true}.\n+     * so this method returns {@code Integer.MAX_VALUE}.\n      *\n      * @return upper bound of the support (always {@code Integer.MAX_VALUE} for\n      * positive infinity)\n--- a/src/main/java/org/apache/commons/math3/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastFourierTransformer.java\n \n     /**\n      * Performs a multi-dimensional Fourier transform on a given array. Use\n-     * {@link #transform(Complex[])} and {@link #inverseTransform(Complex[])} in\n-     * a row-column implementation in any number of dimensions with\n+     * {@link #transform(Complex[], TransformType)} in a row-column\n+     * implementation in any number of dimensions with\n      * O(N&times;log(N)) complexity with\n      * N = n<sub>1</sub> &times; n<sub>2</sub> &times;n<sub>3</sub> &times; ...\n      * &times; n<sub>d</sub>, where n<sub>k</sub> is the number of elements in\n--- a/src/main/java/org/apache/commons/math3/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/transform/FastSineTransformer.java\n  * transform requires the length of the data to be a power of two. Besides,\n  * it implicitly assumes that the sampled function is odd. In particular, the\n  * first element of the data set must be 0, which is enforced in\n- * {@link #transform(UnivariateFunction, double, double, int)} and\n- * {@link #inverseTransform(UnivariateFunction, double, double, int)}, after\n- * sampling.\n+ * {@link #transform(UnivariateFunction, double, double, int, TransformType)},\n+ * after sampling.\n  * </p>\n  *\n  * @version $Id$\n--- a/src/test/java/org/apache/commons/math3/transform/RealTransformerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/transform/RealTransformerAbstractTest.java\n  * This abstract test handles the automatic generation of random data of various\n  * sizes. For each generated data array, actual values (returned by the\n  * transformer to be tested) are compared to expected values, returned by the\n- * {@link #transform(double[], boolean)} (to be implemented by the user: a naive\n- * method may be used). Methods are also provided to test that invalid parameters\n- * throw the expected exceptions.\n+ * {@link #transform(double[], TransformType)} (to be implemented by the user:\n+ * a naive method may be used). Methods are also provided to test that invalid\n+ * parameters throw the expected exceptions.\n  *\n  * @since 3.0\n  * @version $Id$\n      */\n \n     /**\n-     * {@link RealTransformer#transform(double[], TransformType))} should throw a\n+     * {@link RealTransformer#transform(double[], TransformType)} should throw a\n      * {@link MathIllegalArgumentException} if data size is invalid.\n      */\n     @Test\n      */\n \n     /**\n-     * Accuracy check of {@link RealTransformer#transform(double[])}. For each\n-     * valid data size returned by\n+     * Accuracy check of {@link RealTransformer#transform(double[], TransformType)}.\n+     * For each valid data size returned by\n      * {@link #getValidDataSize(int) getValidDataSize(i)},\n      * a random data array is generated with\n      * {@link #createRealData(int) createRealData(i)}. The actual\n      * transform is computed and compared to the expected transform, return by\n-     * {@link #transform(double[], boolean)}. Actual and expected values should\n-     * be equal to within the relative error returned by\n+     * {@link #transform(double[], TransformType)}. Actual and expected values\n+     * should be equal to within the relative error returned by\n      * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n      */\n     @Test\n \n     /**\n      * Accuracy check of\n-     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}.\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}.\n      * For each valid data size returned by\n      * {@link #getValidDataSize(int) getValidDataSize(i)},\n      * the {@link UnivariateFunction} returned by {@link #getValidFunction()} is\n      * sampled. The actual transform is computed and compared to the expected\n-     * transform, return by {@link #transform(double[], boolean)}. Actual and\n-     * expected values should be equal to within the relative error returned by\n-     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n+     * transform, return by {@link #transform(double[], TransformType)}. Actual\n+     * and expected values should be equal to within the relative error returned\n+     * by {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n      */\n     @Test\n     public void testTransformFunction() {", "timestamp": 1329287405, "metainfo": ""}