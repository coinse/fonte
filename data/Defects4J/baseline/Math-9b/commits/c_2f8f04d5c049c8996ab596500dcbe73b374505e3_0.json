{"sha": "2f8f04d5c049c8996ab596500dcbe73b374505e3", "log": "added a no-args constructor for GaussNewtonEstimator  ", "commit": "\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n  */\n public abstract class AbstractEstimator implements Estimator {\n \n+    /** Default maximal number of cost evaluations allowed. */\n+    public static final int DEFAULT_MAX_COST_EVALUATIONS = 100;\n+\n     /**\n      * Build an abstract estimator for least squares problems.\n+     * <p>The maximal number of cost evaluations allowed is set\n+     * to its default value {@link #DEFAULT_MAX_COST_EVALUATIONS}.</p>\n      */\n     protected AbstractEstimator() {\n+        setMaxCostEval(DEFAULT_MAX_COST_EVALUATIONS);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n \n public class GaussNewtonEstimator extends AbstractEstimator implements Serializable {\n \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5485001826076289109L;\n+\n+    /** Default threshold for cost steady state detection. */\n+    private static final double DEFAULT_STEADY_STATE_THRESHOLD = 1.0e-6;\n+\n+    /** Default threshold for cost convergence. */\n+    private static final double DEFAULT_CONVERGENCE = 1.0e-6;\n+\n+    /** Threshold for cost steady state detection. */\n+    private double steadyStateThreshold;\n+\n+    /** Threshold for cost convergence. */\n+    private double convergence;\n+\n+    /** Simple constructor with default settings.\n+     * <p>\n+     * The estimator is built with default values for all settings.\n+     * </p>\n+     * @see #DEFAULT_STEADY_STATE_THRESHOLD\n+     * @see #DEFAULT_CONVERGENCE\n+     * @see AbstractEstimator#DEFAULT_MAX_COST_EVALUATIONS\n+     */\n+    public GaussNewtonEstimator() {\n+        this.steadyStateThreshold = DEFAULT_STEADY_STATE_THRESHOLD;\n+        this.convergence          = DEFAULT_CONVERGENCE;        \n+    }\n+\n     /** \n      * Simple constructor.\n      *\n      * to improve the criterion anymore\n      * @param steadyStateThreshold steady state detection threshold, the\n      * problem has converged has reached a steady state if\n-     * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-     * <code>Jn</code> and <code>Jn-1</code> are the current and\n-     * preceding criterion value (square sum of the weighted residuals\n-     * of considered measurements).\n-     */\n-    public GaussNewtonEstimator(int maxCostEval,\n-            double convergence,\n-            double steadyStateThreshold) {\n+     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n+     * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n+     * values (square sum of the weighted residuals of considered measurements).\n+     */\n+    public GaussNewtonEstimator(final int maxCostEval, final double convergence,\n+                                final double steadyStateThreshold) {\n         setMaxCostEval(maxCostEval);\n         this.steadyStateThreshold = steadyStateThreshold;\n         this.convergence          = convergence;\n+    }\n+\n+    /**\n+     * Set the convergence criterion threshold.\n+     * @param convergence criterion threshold below which we do not need\n+     * to improve the criterion anymore\n+     */\n+    public void setConvergence(final double convergence) {\n+        this.convergence = convergence;\n+    }\n+\n+    /**\n+     * Set the steady state detection threshold.\n+     * <p>\n+     * The problem has converged has reached a steady state if\n+     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n+     * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n+     * values (square sum of the weighted residuals of considered measurements).\n+     * </p>\n+     * @param steadyStateThreshold steady state detection threshold\n+     */\n+    public void setSteadyStateThreshold(final double steadyStateThreshold) {\n+        this.steadyStateThreshold = steadyStateThreshold;\n     }\n \n     /** \n      * below a physical threshold under which improvement are considered\n      * useless or when the algorithm is unable to improve it (even if it\n      * is still high). The first condition that is met stops the\n-     * iterations. If the convergence it nos reached before the maximum\n+     * iterations. If the convergence it not reached before the maximum\n      * number of iterations, an {@link EstimationException} is\n      * thrown.</p>\n      *\n \n     }\n \n-    /** Threshold for cost steady state detection. */\n-    private double steadyStateThreshold;\n-\n-    /** Threshold for cost convergence. */\n-    private double convergence;\n-\n-    /** Serializable version identifier */\n-     private static final long serialVersionUID = 5485001826076289109L;\n-\n }", "timestamp": 1234895912, "metainfo": ""}