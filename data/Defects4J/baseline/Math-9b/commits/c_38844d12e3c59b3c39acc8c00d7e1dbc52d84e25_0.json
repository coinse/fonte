{"sha": "38844d12e3c59b3c39acc8c00d7e1dbc52d84e25", "log": "Removed deprecated code.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface NormalDistribution extends ContinuousDistribution, HasDensity<Double> {\n+public interface NormalDistribution extends ContinuousDistribution {\n     /**\n      * Access the mean.\n-     * @return mean for this distribution\n+     *\n+     * @return the mean for this distribution.\n      */\n     double getMean();\n-    /**\n-     * Modify the mean.\n-     * @param mean for this distribution\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setMean(double mean);\n+\n     /**\n      * Access the standard deviation.\n-     * @return standard deviation for this distribution\n+     *\n+     * @return the standard deviation for this distribution.\n      */\n     double getStandardDeviation();\n-    /**\n-     * Modify the standard deviation.\n-     * @param sd standard deviation for this distribution\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setStandardDeviation(double sd);\n \n     /**\n      * Return the probability density for a particular point.\n-     * @param x  The point at which the density should be computed.\n-     * @return  The pdf at point x.\n+     *\n+     * @param x Point at which the density should be computed.\n+     * @return the pdf at point {@code x}.\n      */\n-    double density(Double x);\n+    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Erf;\n  */\n public class NormalDistributionImpl extends AbstractContinuousDistribution\n         implements NormalDistribution, Serializable {\n-\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = 8589540077390120676L;\n-\n     /** &sqrt;(2 &pi;) */\n     private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n-\n-    /** The mean of this distribution. */\n+    /** Mean of this distribution. */\n     private double mean = 0;\n-\n-    /** The standard deviation of this distribution. */\n+    /** Standard deviation of this distribution. */\n     private double standardDeviation = 1;\n-\n-    /** Inverse cumulative probability accuracy */\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a normal distribution using the given mean, standard deviation and\n      * inverse cumulative distribution accuracy.\n      *\n-     * @param mean mean for this distribution\n-     * @param sd standard deviation for this distribution\n-     * @param inverseCumAccuracy inverse cumulative probability accuracy\n+     * @param mean Mean for this distribution.\n+     * @param sd Standard deviation for this distribution.\n+     * @param inverseCumAccuracy inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n      * @since 2.1\n      */\n     public NormalDistributionImpl(double mean, double sd, double inverseCumAccuracy) {\n-        super();\n-        setMeanInternal(mean);\n-        setStandardDeviationInternal(sd);\n+        if (sd <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n+        }\n+        \n+        this.mean = mean;\n+        standardDeviation = sd;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n-     * Creates normal distribution with the mean equal to zero and standard\n+     * Create a normal distribution with mean equal to zero and standard\n      * deviation equal to one.\n      */\n     public NormalDistributionImpl(){\n-        this(0.0, 1.0);\n-    }\n-\n-    /**\n-     * Access the mean.\n-     * @return mean for this distribution\n+        this(0, 1);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     public double getMean() {\n         return mean;\n     }\n \n     /**\n-     * Modify the mean.\n-     * @param mean for this distribution\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setMean(double mean) {\n-        setMeanInternal(mean);\n-    }\n-    /**\n-     * Modify the mean.\n-     * @param newMean for this distribution\n-     */\n-    private void setMeanInternal(double newMean) {\n-        this.mean = newMean;\n-    }\n-\n-    /**\n-     * Access the standard deviation.\n-     * @return standard deviation for this distribution\n+     * {@inheritDoc}\n      */\n     public double getStandardDeviation() {\n         return standardDeviation;\n     }\n \n     /**\n-     * Modify the standard deviation.\n-     * @param sd standard deviation for this distribution\n-     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setStandardDeviation(double sd) {\n-        setStandardDeviationInternal(sd);\n-    }\n-    /**\n-     * Modify the standard deviation.\n-     * @param sd standard deviation for this distribution\n-     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-     */\n-    private void setStandardDeviationInternal(double sd) {\n-        if (sd <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION,\n-                  sd);\n-        }\n-        standardDeviation = sd;\n-    }\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @deprecated\n-     */\n-    public double density(Double x) {\n-        return density(x.doubleValue());\n-    }\n-\n-    /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     public double density(double x) {\n-        double x0 = x - mean;\n-        return FastMath.exp(-x0 * x0 / (2 * standardDeviation * standardDeviation)) / (standardDeviation * SQRT2PI);\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>.\n+        final double x0 = x - mean;\n+        final double x1 = x0 / standardDeviation;\n+        return FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return CDF evaluted at {@code x}.\n      * @throws MathException if the algorithm fails to converge; unless\n-     * x is more than 20 standard deviations from the mean, in which case the\n-     * convergence exception is caught and 0 or 1 is returned.\n+     * {@code x} is more than 20 standard deviations from the mean, in which\n+     * case the convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         try {\n                     (standardDeviation * FastMath.sqrt(2.0))));\n         } catch (MaxIterationsExceededException ex) {\n             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0.0d;\n+                return 0;\n             } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1.0d;\n+                return 1;\n             } else {\n                 throw ex;\n             }\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     * For this distribution, X, this method returns the critical point \n+     * {@code x}, such that {@code P(X < x) = p}.\n+     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and\n+     * {@code Double.POSITIVE_INFINITY} for p = 1.\n      *\n      * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n      *         computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n      * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = -Double.MAX_VALUE;\n         } else {\n             ret = mean;\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n      * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = mean;\n         } else {\n             ret = Double.MAX_VALUE;\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n     protected double getInitialDomain(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = mean - standardDeviation;\n-        } else if (p > .5) {\n+        } else if (p > 0.5) {\n             ret = mean + standardDeviation;\n         } else {\n             ret = mean;\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         assertEquals(2.1, distribution.getMean(), 0);\n     }\n \n-    public void testSetMean() throws Exception {\n-        double mu = FastMath.random();\n-        NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        distribution.setMean(mu);\n-        verifyQuantiles();\n-    }\n-\n     public void testGetStandardDeviation() {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         assertEquals(1.4, distribution.getStandardDeviation(), 0);\n     }\n \n-    public void testSetStandardDeviation() throws Exception {\n-        double sigma = 0.1d + FastMath.random();\n-        NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        distribution.setStandardDeviation(sigma);\n-        assertEquals(sigma, distribution.getStandardDeviation(), 0);\n-        verifyQuantiles();\n+    public void testPreconditions() {\n         try {\n-            distribution.setStandardDeviation(0);\n-            fail(\"Expecting IllegalArgumentException for sd = 0\");\n-        } catch (IllegalArgumentException ex) {\n-            // Expected\n+            NormalDistribution distribution = new NormalDistributionImpl(1, 0);\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n         }\n     }\n \n      * Verifies fix for JIRA MATH-167\n      */\n     public void testExtremeValues() throws Exception {\n-        NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        distribution.setMean(0);\n-        distribution.setStandardDeviation(1);\n+        NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n         for (int i = 0; i < 100; i+=5) { // make sure no convergence exception\n             double lowerTail = distribution.cumulativeProbability(-i);\n             double upperTail = distribution.cumulativeProbability(i);", "timestamp": 1285677489, "metainfo": ""}