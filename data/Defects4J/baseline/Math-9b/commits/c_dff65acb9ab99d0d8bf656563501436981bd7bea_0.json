{"sha": "dff65acb9ab99d0d8bf656563501436981bd7bea", "log": "Javadoc fixes, advertise correct exception in inverse().   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n \n /**\n  * Interface defining a real-valued matrix with basic algebraic operations\n- * @version $Revision: 1.12 $ $Date: 2004/02/18 03:24:19 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/03 22:18:04 $\n  */\n public interface RealMatrix {\n \n      * Returns the inverse of this matrix.\n      *\n      * @return inverse matrix\n-     * @throws IllegalArgumentException if *this is not invertible\n-     */\n-    RealMatrix inverse() throws IllegalArgumentException;\n+     * @throws InvalidMatrixException if  this is not invertible\n+     */\n+    RealMatrix inverse() throws InvalidMatrixException;\n     \n     /**\n      * Returns the determinant of this matrix.\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.\n  *\n- * @version $Revision: 1.14 $ $Date: 2004/02/18 03:24:19 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/03 22:18:04 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n \t}\n \n \t/**\n-\t *\n+\t * Returns the transpose matrix.\n+     *\n \t * @return transpose matrix\n \t */\n \tpublic RealMatrix transpose() {\n \t}\n \n \t/**\n+     * Returns the inverse matrix if this matrix is invertible.\n+     * \n \t * @return inverse matrix\n-\t * @throws IllegalArgumentException if this is not invertible\n-\t */\n-\tpublic RealMatrix inverse() throws IllegalArgumentException {\n+\t * @throws InvalidMatrixException if this is not invertible\n+\t */\n+\tpublic RealMatrix inverse() throws InvalidMatrixException {\n \t\treturn solve(getIdentity(this.getRowDimension()));\n \t}\n \n \t\tif (!isSquare()) {\n \t\t\tthrow new InvalidMatrixException(\"matrix is not square\");\n \t\t}\n-\t\tif (isSingular()) { // note: this has side effect of attempting LU\n-\t\t\treturn 0d; //       decomp if lu == null\n+\t\tif (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n+\t\t\treturn 0d;  \n \t\t} else {\n \t\t\tdouble det = (double) parity;\n \t\t\tfor (int i = 0; i < this.getRowDimension(); i++) {\n \t * @return true if the matrix is singular\n \t */\n \tpublic boolean isSingular() {\n-\t\t// @TODO A bad way to check for a singular matrix, is this the only way - kick off an LU decompose?\n \t\tif (lu == null) {\n \t\t\ttry {\n \t\t\t\tLUDecompose();", "timestamp": 1081030684, "metainfo": ""}