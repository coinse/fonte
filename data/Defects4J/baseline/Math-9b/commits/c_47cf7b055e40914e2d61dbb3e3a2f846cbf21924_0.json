{"sha": "47cf7b055e40914e2d61dbb3e3a2f846cbf21924", "log": "Added a way to limit the number of functions evaluations in optimizers (the number of iterations could already be limited)   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/MaxEvaluationsExceededException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Error thrown when a numerical computation exceeds its allowed\n+ * number of functions evaluations.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MaxEvaluationsExceededException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5921271447220129118L;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private final int maxEvaluations;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxEvaluations maximal number of evaluations allowed\n+     */\n+    public MaxEvaluationsExceededException(final int maxEvaluations) {\n+        super(\"Maximal number of evaluations ({0}) exceeded\", maxEvaluations);\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxEvaluations the exceeded maximal number of evaluations\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MaxEvaluationsExceededException(final int maxEvaluations,\n+                                          final String pattern, final Object ... arguments) {\n+        super(pattern, arguments);\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** Get the maximal number of evaluations allowed.\n+     * @return maximal number of evaluations allowed\n+     */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.MaxIterationsExceededException\n     { \"Maximal number of iterations ({0}) exceeded\",\n       \"Nombre maximal d''it\\u00e9rations ({0}) d\\u00e9pass\\u00e9\" },\n+\n+    // org.apache.commons.math.MaxEvaluationsExceededException\n+    { \"Maximal number of evaluations ({0}) exceeded\",\n+      \"Nombre maximal d''\\u00e9valuations ({0}) d\\u00e9pass\\u00e9\" },\n \n     // org.apache.commons.math.analysis.interpolation.SplineInterpolator\n     // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n--- a/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n \n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n \n     /** Number of iterations already performed for all starts. */\n     private int totalIterations;\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getIterations() {\n         return totalIterations;\n     }\n \n             try {\n                 optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                 optima[i] = optimizer.optimize(f, goalType,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (FunctionEvaluationException fee) {\n--- a/src/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n public interface MultivariateRealOptimizer {\n \n     /** Set the maximal number of iterations of the algorithm.\n-     * @param maxIterations maximal number of function calls\n+     * @param maxIterations maximal number of algorithm iterations\n      */\n     void setMaxIterations(int maxIterations);\n+\n+    /** Set the maximal number of evaluations of the algorithm.\n+     * @param maxEvaluations maximal number of function calls\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n \n     /** Get the maximal number of iterations of the algorithm.\n      * @return maximal number of iterations\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n     /** Number of iterations already performed. */\n     private int iterations;\n \n     protected DirectSearchOptimizer() {\n         setConvergenceChecker(new SimpleScalarValueChecker());\n         setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Set start configuration for simplex.\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getMaxIterations() {\n         return maxIterations;\n     }\n      * @return objective function value at the given point\n      * @exception FunctionEvaluationException if no value can be computed for the parameters\n      * @exception IllegalArgumentException if the start point dimension is wrong\n+     * @exception OptimizationException if the maximal number of evaluations is exceeded\n      */\n     protected double evaluate(final double[] x)\n-        throws FunctionEvaluationException, IllegalArgumentException {\n-        evaluations++;\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new OptimizationException(new MaxEvaluationsExceededException(maxEvaluations));\n+        }\n         return f.value(x);\n     }\n \n     /** Evaluate all the non-evaluated points of the simplex.\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n      * @exception FunctionEvaluationException if no value can be computed for the parameters\n+     * @exception OptimizationException if the maximal number of evaluations is exceeded\n      */\n     protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n+        throws FunctionEvaluationException, OptimizationException {\n \n         // evaluate the objective function at all non-evaluated simplex points\n         for (int i = 0; i < simplex.length; ++i) {\n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n      * @return best point in the transformed simplex\n      * @exception FunctionEvaluationException if the function cannot be evaluated at\n      * some point\n+     * @exception OptimizationException if the maximal number of evaluations is exceeded\n      */\n     private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n                                               final double coeff,\n                                               final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n+        throws FunctionEvaluationException, OptimizationException {\n \n         final double[] xSmallest = original[0].getPointRef();\n         final int n = xSmallest.length;\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n-\n-public class NelderMeadTest\n-  extends TestCase {\n-\n-  public NelderMeadTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Test;\n+\n+public class NelderMeadTest {\n+\n+  @Test\n   public void testFunctionEvaluationExceptions() {\n       MultivariateRealFunction wrong =\n           new MultivariateRealFunction() {\n       } \n   }\n \n+  @Test\n   public void testMinimizeMaximize()\n       throws FunctionEvaluationException, ConvergenceException {\n \n \n   }\n \n+  @Test\n   public void testRosenbrock()\n     throws FunctionEvaluationException, ConvergenceException {\n \n-    MultivariateRealFunction rosenbrock =\n-      new MultivariateRealFunction() {\n-        private static final long serialVersionUID = -9044950469615237490L;\n-        public double value(double[] x) throws FunctionEvaluationException {\n-          ++count;\n-          double a = x[1] - x[0] * x[0];\n-          double b = 1.0 - x[0];\n-          return 100 * a * a + b * b;\n-        }\n-      };\n-\n-    count = 0;\n+    Rosenbrock rosenbrock = new Rosenbrock();\n     NelderMead optimizer = new NelderMead();\n     optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n     optimizer.setMaxIterations(100);\n     RealPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n-    assertEquals(count, optimizer.getEvaluations());\n+    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n     assertTrue(optimizer.getEvaluations() > 40);\n     assertTrue(optimizer.getEvaluations() < 50);\n     assertTrue(optimum.getValue() < 8.0e-4);\n \n   }\n \n+  @Test\n   public void testPowell()\n     throws FunctionEvaluationException, ConvergenceException {\n \n-    MultivariateRealFunction powell =\n-      new MultivariateRealFunction() {\n-        private static final long serialVersionUID = -832162886102041840L;\n-        public double value(double[] x) throws FunctionEvaluationException {\n+    Powell powell = new Powell();\n+    NelderMead optimizer = new NelderMead();\n+    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxIterations(200);\n+    RealPointValuePair optimum =\n+      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    assertEquals(powell.getCount(), optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 110);\n+    assertTrue(optimizer.getEvaluations() < 130);\n+    assertTrue(optimum.getValue() < 2.0e-3);\n+\n+  }\n+\n+  @Test(expected = MaxIterationsExceededException.class)\n+  public void testMaxIterations() throws MathException {\n+      try {\n+          Powell powell = new Powell();\n+          NelderMead optimizer = new NelderMead();\n+          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+          optimizer.setMaxIterations(20);\n+          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+      } catch (OptimizationException oe) {\n+          if (oe.getCause() instanceof ConvergenceException) {\n+              throw (ConvergenceException) oe.getCause();\n+          }\n+          throw oe;\n+      }\n+  }\n+\n+  @Test(expected = MaxEvaluationsExceededException.class)\n+  public void testMaxEvaluations() throws MathException {\n+      try {\n+          Powell powell = new Powell();\n+          NelderMead optimizer = new NelderMead();\n+          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n+          optimizer.setMaxEvaluations(20);\n+          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+      } catch (OptimizationException oe) {\n+          if (oe.getCause() instanceof ConvergenceException) {\n+              throw (ConvergenceException) oe.getCause();\n+          }\n+          throw oe;\n+      }\n+  }\n+\n+  private class Rosenbrock implements MultivariateRealFunction {\n+\n+      private int count;\n+\n+      public Rosenbrock() {\n+          count = 0;\n+      }\n+\n+      public double value(double[] x) throws FunctionEvaluationException {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+      }\n+\n+      public int getCount() {\n+          return count;\n+      }\n+\n+  }\n+\n+  private class Powell implements MultivariateRealFunction {\n+\n+      private int count;\n+\n+      public Powell() {\n+          count = 0;\n+      }\n+\n+      public double value(double[] x) throws FunctionEvaluationException {\n           ++count;\n           double a = x[0] + 10 * x[1];\n           double b = x[2] - x[3];\n           double c = x[1] - 2 * x[2];\n           double d = x[0] - x[3];\n           return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n-        }\n-      };\n-\n-    count = 0;\n-    NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n-    optimizer.setMaxIterations(200);\n-    RealPointValuePair optimum =\n-      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-    assertEquals(count, optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 110);\n-    assertTrue(optimizer.getEvaluations() < 130);\n-    assertTrue(optimum.getValue() < 2.0e-3);\n-\n-  }\n-\n-  public static Test suite() {\n-    return new TestSuite(NelderMeadTest.class);\n-  }\n-\n-  private int count;\n+      }\n+\n+      public int getCount() {\n+          return count;\n+      }\n+\n+  }\n \n }", "timestamp": 1243450488, "metainfo": ""}