{"sha": "26ca02d94e85f6e6b8c9db96c0411b901d6c89fc", "log": "Added mapping and iteration methods to vectors. Provided a default implementation for the numerous simple methods in the RealVectorInterface.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunctions;\n+\n+/**\n+ * This class provides default basic implementations for many methods in the\n+ * {@link RealVector} interface with.\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+public abstract class AbstractRealVector implements RealVector {\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(RealVector v) {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        double d = getDimension();\n+        if (d != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"vector length mismatch: got {0} but expected {1}\",\n+                  d, n);\n+        }\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    protected void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                  \"index {0} out of allowed range [{1}, {2}]\",\n+                  index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            setEntry(i + index, v[i]);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v) throws IllegalArgumentException {\n+        double[] result = v.clone();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            result[e.getIndex()] += e.getValue();\n+        }\n+        return new ArrayRealVector(result, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v) throws IllegalArgumentException {\n+        if (v instanceof ArrayRealVector) {\n+            double[] values = ((ArrayRealVector)v).getDataRef();\n+            return add(values);\n+        }\n+        RealVector result = v.copy();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            result.setEntry(index, e.getValue() + result.getEntry(index));\n+        }\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v) throws IllegalArgumentException {\n+        double[] result = v.clone();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            result[index] = e.getValue() - result[index];\n+        }\n+        return new ArrayRealVector(result, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+        if (v instanceof ArrayRealVector) {\n+            double[] values = ((ArrayRealVector)v).getDataRef();\n+            return add(values);\n+        }\n+        RealVector result = v.copy();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            v.setEntry(index, e.getValue() - result.getEntry(index));\n+        }\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        return copy().mapAddToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        if (d != 0) {\n+            Iterator<Entry> it = iterator();\n+            Entry e;\n+            while (it.hasNext() && (e = it.next()) != null) {\n+                e.setValue(e.getValue() + d);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract AbstractRealVector copy();\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v) throws IllegalArgumentException {\n+        return dotProduct(new ArrayRealVector(v, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += e.getValue() * v.getEntry(e.getIndex());\n+        }\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+        return ebeDivide(new ArrayRealVector(v, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+        return ebeMultiply(new ArrayRealVector(v, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double diff = e.getValue() - v.getEntry(e.getIndex());\n+            d += diff * diff;\n+        }\n+        return Math.sqrt(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double diff = e.getValue() - v[e.getIndex()];\n+            d += diff * diff;\n+        }\n+        return Math.sqrt(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += Math.abs(e.getValue() - v.getEntry(e.getIndex()));\n+        }\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += Math.abs(e.getValue() - v[e.getIndex()]);\n+        }\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d = Math.max(Math.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n+        }\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d = Math.max(Math.abs(e.getValue() - v[e.getIndex()]), d);\n+        }\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        return copy().mapAbsToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ABS);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        return copy().mapAcosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ACOS);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        return copy().mapAsinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ASIN);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        return copy().mapAtanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ATAN);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        return copy().mapCbrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.CBRT);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        return copy().mapCeilToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.CEIL);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        return copy().mapCosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.COS);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        return copy().mapCoshToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.COSH);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        return copy().mapExpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.EXP);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        return copy().mapExpm1ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.EXP1M);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        return copy().mapFloorToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.FLOOR);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        return copy().mapInvToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        return copy().mapLogToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.LOG);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        return copy().mapLog10ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.LOG10);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        return copy().mapLog1pToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ASIN);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        return copy().mapPowToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        return copy().mapRintToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.RINT);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        return copy().mapSignumToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.SIGNUM);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        return copy().mapSinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.SIN);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        return copy().mapSinhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.SINH);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        return copy().mapSqrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.SQRT);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        return copy().mapTanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.TAN);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        return copy().mapTanhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.TANH);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        return copy().mapUlpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        try {\n+            return mapToSelf(UnivariateRealFunctions.ULP);\n+        } catch (FunctionEvaluationException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+        RealMatrix product;\n+        if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n+            product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());\n+        } else {\n+            product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());\n+        }\n+        Iterator<Entry> thisIt = sparseIterator();\n+        Entry thisE = null;\n+        while (thisIt.hasNext() && (thisE = thisIt.next()) != null) {\n+            Iterator<Entry> otherIt = v.sparseIterator();\n+            Entry otherE = null;\n+            while (otherIt.hasNext() && (otherE = otherIt.next()) != null) {\n+                product.setEntry(thisE.getIndex(), otherE.getIndex(),\n+                                 thisE.getValue() * otherE.getValue());\n+            }\n+        }\n+\n+        return product;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+        return outerProduct(new ArrayRealVector(v, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) throws IllegalArgumentException {\n+        return projection(new ArrayRealVector(v, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        Iterator<Entry> it = iterator();\n+        Entry e = null;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            e.setValue(value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray() {\n+        int dim = getDimension();\n+        double[] values = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            values[i] = getEntry(i);\n+        }\n+        return values;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        return toArray();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() {\n+        RealVector copy = copy();\n+        copy.unitize();\n+        return copy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() {\n+        mapDivideToSelf(getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Iterator<Entry> sparseIterator() {\n+        return new SparseEntryIterator();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Iterator<Entry> iterator() {\n+        final int dim = getDimension();\n+        return new Iterator<Entry>() {\n+\n+            /** Current index. */\n+            private int i = 0;\n+\n+            /** Current entry. */\n+            private EntryImpl e = new EntryImpl();\n+\n+            /** {@inheritDoc} */\n+            public boolean hasNext() {\n+                return i < dim;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public Entry next() {\n+                e.setIndex(i++);\n+                return e;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void remove() {\n+                throw new UnsupportedOperationException(\"Not supported\");\n+            }\n+        };\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {\n+        return copy().mapToSelf(function);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {\n+        Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            e.setValue(function.value(e.getValue()));\n+        }\n+        return this;\n+    }\n+\n+    /** An entry in the vector. */\n+    protected class EntryImpl extends Entry {\n+\n+        /** Simple constructor. */\n+        public EntryImpl() {\n+            setIndex(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getValue() {\n+            return getEntry(getIndex());\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setValue(double newValue) {\n+            setEntry(getIndex(), newValue);\n+        }\n+    }\n+\n+    /**\n+     * This class should rare be used, but is here to provide\n+     * a default implementation of sparseIterator(), which is implemented\n+     * by walking over the entries, skipping those whose values are the default one.\n+     *\n+     * Concrete subclasses which are SparseVector implementations should\n+     * make their own sparse iterator, not use this one.\n+     *\n+     * This implementation might be useful for ArrayRealVector, when expensive\n+     * operations which preserve the default value are to be done on the entries,\n+     * and the fraction of non-default values is small (i.e. someone took a\n+     * SparseVector, and passed it into the copy-constructor of ArrayRealVector)\n+     */\n+    protected class SparseEntryIterator implements Iterator<Entry> {\n+\n+        /** Dimension of the vector. */\n+        private final int dim;\n+\n+        /** Temporary entry (reused on each call to {@link #next()}. */\n+        private EntryImpl tmp = new EntryImpl();\n+\n+        /** Current entry. */\n+        private EntryImpl current;\n+\n+        /** Next entry. */\n+        private EntryImpl next;\n+\n+        /** Simple constructor. */\n+        protected SparseEntryIterator() {\n+            dim = getDimension();\n+            current = new EntryImpl();\n+            if (current.getValue() == 0) {\n+                advance(current);\n+            }\n+            next = new EntryImpl();\n+            next.setIndex(current.getIndex());\n+            advance(next);\n+        }\n+\n+        /** Advance an entry up to the next non null one.\n+         * @param e entry to advance\n+         */\n+        protected void advance(EntryImpl e) {\n+            if (e == null) {\n+                return;\n+            }\n+            do {\n+                e.setIndex(e.getIndex() + 1);\n+            } while (e.getIndex() < dim && e.getValue() == 0);\n+            if (e.getIndex() >= dim) {\n+                e.setIndex(-1);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean hasNext() {\n+            return current != null;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Entry next() {\n+            tmp.setIndex(current.getIndex());\n+            if (next != null) {\n+                current.setIndex(next.getIndex());\n+                advance(next);\n+                if (next.getIndex() < 0) {\n+                    next = null;\n+                }\n+            } else {\n+                current = null;\n+            }\n+            return tmp;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void remove() {\n+            throw new UnsupportedOperationException(\"Not supported\");\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n \n import java.io.Serializable;\n import java.util.Arrays;\n+import java.util.Iterator;\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class ArrayRealVector implements RealVector, Serializable {\n+public class ArrayRealVector extends AbstractRealVector implements Serializable {\n \n     /** Message for non fitting position and size. */\n     private static final String NON_FITTING_POSITION_AND_SIZE_MESSAGE =\n      * @param v vector to copy\n      */\n     public ArrayRealVector(ArrayRealVector v) {\n-        data = v.data.clone();\n+        this(v, true);\n     }\n \n     /**\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector copy() {\n+    public AbstractRealVector copy() {\n         return new ArrayRealVector(this, true);\n     }\n \n     /** {@inheritDoc} */\n     public RealVector add(RealVector v)\n     throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return add((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n-            double[] out = new double[data.length];\n-            for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] + v.getEntry(i);\n+            double[] out = data.clone();\n+            Iterator<Entry> it = v.sparseIterator();\n+            Entry e;\n+            while(it.hasNext() && (e = it.next()) != null) {\n+                out[e.getIndex()] += e.getValue();\n             }\n             return new ArrayRealVector(out);\n         }\n     public RealVector add(double[] v)\n     throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] + v[i];\n+        double[] out = data.clone();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] += v[i];\n         }\n         return new ArrayRealVector(out);\n     }\n     /** {@inheritDoc} */\n     public RealVector subtract(RealVector v)\n     throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return subtract((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n-            double[] out = new double[data.length];\n-            for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] - v.getEntry(i);\n+            double[] out = data.clone();\n+            Iterator<Entry> it = v.sparseIterator();\n+            Entry e;\n+            while(it.hasNext() && (e = it.next()) != null) {\n+                out[e.getIndex()] -= e.getValue();\n             }\n             return new ArrayRealVector(out);\n         }\n     public RealVector subtract(double[] v)\n     throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] - v[i];\n+        double[] out = data.clone();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] -= v[i];\n         }\n         return new ArrayRealVector(out);\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAdd(double d) {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] + d;\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapAddToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] + d;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSubtract(double d) {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] - d;\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapSubtractToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] - d;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapMultiply(double d) {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] * d;\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapMultiplyToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] * d;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapDivide(double d) {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] / d;\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapDivideToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] / d;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapPow(double d) {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.pow(data[i], d);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapPowToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.pow(data[i], d);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExp() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.exp(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapExpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.exp(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExpm1() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.expm1(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapExpm1ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.expm1(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.log(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapLogToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog10() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.log10(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapLog10ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log10(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapLog1p() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.log1p(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapLog1pToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log1p(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCosh() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.cosh(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapCoshToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cosh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSinh() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.sinh(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapSinhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sinh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTanh() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.tanh(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapTanhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.tanh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCos() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.cos(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapCosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cos(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSin() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.sin(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapSinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sin(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapTan() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.tan(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapTanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.tan(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAcos() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.acos(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapAcosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.acos(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAsin() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.asin(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapAsinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.asin(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAtan() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.atan(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapAtanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.atan(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapInv() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = 1.0 / data[i];\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapInvToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = 1.0 / data[i];\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapAbs() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.abs(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapAbsToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.abs(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSqrt() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.sqrt(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapSqrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sqrt(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCbrt() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.cbrt(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapCbrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cbrt(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapCeil() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.ceil(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapCeilToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.ceil(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapFloor() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.floor(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapFloorToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.floor(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapRint() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.rint(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapRintToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.rint(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapSignum() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.signum(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapSignumToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.signum(data[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapUlp() {\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = Math.ulp(data[i]);\n-        }\n-        return new ArrayRealVector(out);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapUlpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.ulp(data[i]);\n     /** {@inheritDoc} */\n     public RealVector ebeMultiply(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return ebeMultiply((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n-            double[] out = new double[data.length];\n+            double[] out = data.clone();\n             for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] * v.getEntry(i);\n-            }\n-            return new ArrayRealVector(out);\n+                out[i] *= v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out, false);\n         }\n     }\n \n     public RealVector ebeMultiply(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i] * v[i];\n-        }\n-        return new ArrayRealVector(out);\n+        double[] out = data.clone();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] *= v[i];\n+        }\n+        return new ArrayRealVector(out, false);\n     }\n \n     /**\n     /** {@inheritDoc} */\n     public RealVector ebeDivide(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return ebeDivide((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n-            double[] out = new double[data.length];\n+            double[] out = data.clone();\n             for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] / v.getEntry(i);\n-            }\n-            return new ArrayRealVector(out);\n+                out[i] /= v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out, false);\n         }\n     }\n \n     public RealVector ebeDivide(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n-        double[] out = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i] / v[i];\n-        }\n-        return new ArrayRealVector(out);\n+        double[] out = data.clone();\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] /= v[i];\n+        }\n+        return new ArrayRealVector(out, false);\n     }\n \n     /**\n     /** {@inheritDoc} */\n     public double dotProduct(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return dotProduct((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n             double dot = 0;\n-            for (int i = 0; i < data.length; i++) {\n-                dot += data[i] * v.getEntry(i);\n+            Iterator<Entry> it = v.sparseIterator();\n+            Entry e;\n+            while(it.hasNext() && (e = it.next()) != null) {\n+                dot += data[e.getIndex()] * e.getValue();\n             }\n             return dot;\n         }\n     /** {@inheritDoc} */\n     public double getDistance(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return getDistance((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n             double sum = 0;\n             for (int i = 0; i < data.length; ++i) {\n     /** {@inheritDoc} */\n     public double getL1Distance(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return getL1Distance((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n             double sum = 0;\n             for (int i = 0; i < data.length; ++i) {\n     /** {@inheritDoc} */\n     public double getLInfDistance(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return getLInfDistance((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n             double max = 0;\n             for (int i = 0; i < data.length; ++i) {\n         if (norm == 0) {\n             throw MathRuntimeException.createArithmeticException(\"zero norm\");\n         }\n-        return mapDivide(getNorm());\n+        return mapDivide(norm);\n     }\n \n     /** {@inheritDoc} */\n         if (norm == 0) {\n             throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n         }\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] /= norm;\n-        }\n+        mapDivideToSelf(norm);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public RealMatrix outerProduct(RealVector v)\n         throws IllegalArgumentException {\n-        try {\n+        if(v instanceof ArrayRealVector) {\n             return outerProduct((ArrayRealVector) v);\n-        } catch (ClassCastException cce) {\n+        } else {\n             checkVectorDimensions(v);\n             final int m = data.length;\n             final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n         return true;\n       }\n \n-      if (other == null) {\n+      if (other == null || !(other instanceof RealVector)) {\n         return false;\n       }\n \n-      try {\n-\n-          RealVector rhs = (RealVector) other;\n-          if (data.length != rhs.getDimension()) {\n-              return false;\n-          }\n-\n-          if (rhs.isNaN()) {\n-              return this.isNaN();\n-          }\n-\n-          for (int i = 0; i < data.length; ++i) {\n-              if (data[i] != rhs.getEntry(i)) {\n-                  return false;\n-              }\n-          }\n-          return true;\n-\n-      } catch (ClassCastException ex) {\n-          // ignore exception\n+\n+      RealVector rhs = (RealVector) other;\n+      if (data.length != rhs.getDimension()) {\n+        return false;\n+      }\n+\n+      if (rhs.isNaN()) {\n+        return this.isNaN();\n+      }\n+\n+      for (int i = 0; i < data.length; ++i) {\n+        if (data[i] != rhs.getEntry(i)) {\n           return false;\n+        }\n       }\n-\n+      return true;\n     }\n \n     /**\n         return MathUtils.hash(data);\n     }\n \n-    /**\n-     * Check if an index is valid.\n-     * @param index index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkIndex(final int index)\n-        throws MatrixIndexException {\n-        if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(\n-                    \"index {0} out of allowed range [{1}, {2}]\",\n-                    index, 0, getDimension() - 1);\n-        }\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n */\n-public class OpenMapRealVector implements SparseRealVector, Serializable {\n+public class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable {\n \n     /** Default Tolerance for having a value considered zero. */\n     public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n     /** Dimension of the vector. */\n     private final int virtualSize;\n \n-    /** Tolerance for having a value considered zero. */\n-    private double epsilon;\n+    /** Negative tolerance for having a value considered zero. */\n+    private double minusEpsilon;\n+\n+    /** Positive tolerance for having a value considered zero. */\n+    private double plusEpsilon;\n \n     /**\n      * Build a 0-length vector.\n      * into this vector.</p>\n      */\n     public OpenMapRealVector() {\n-        this(0, DEFAULT_ZERO_TOLERANCE);\n+        this(0, DEFAULT_ZERO_TOLERANCE, 0);\n     }\n \n     /**\n      * @param dimension size of the vector\n      */\n     public OpenMapRealVector(int dimension) {\n-        this(dimension, DEFAULT_ZERO_TOLERANCE);\n+        this(dimension, DEFAULT_ZERO_TOLERANCE, 0);\n     }\n \n     /**\n      * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n      * @param dimension Size of the vector\n      * @param epsilon The tolerance for having a value considered zero\n-     */\n-    public OpenMapRealVector(int dimension, double epsilon) {\n+     * @param defaultValue value for non-specified entries\n+     */\n+    public OpenMapRealVector(int dimension, double epsilon, double defaultValue) {\n         virtualSize = dimension;\n-        entries = new OpenIntToDoubleHashMap(0.0);\n-        this.epsilon = epsilon;\n+        entries = new OpenIntToDoubleHashMap(defaultValue);\n+        setDefault(defaultValue, epsilon);\n     }\n \n     /**\n     protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n         virtualSize = v.getDimension() + resize;\n         entries = new OpenIntToDoubleHashMap(v.entries);\n-        epsilon = v.getEpsilon();\n+        minusEpsilon = v.minusEpsilon;\n+        plusEpsilon = v.plusEpsilon;\n     }\n \n     /**\n      * @param dimension The size of the vector\n      * @param expectedSize The expected number of non-zero entries\n      * @param epsilon The tolerance for having a value considered zero\n-     */\n-    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n+     * @param defaultValue value for non-specified entries\n+     */\n+    public OpenMapRealVector(int dimension, int expectedSize, double epsilon, double defaultValue) {\n         virtualSize = dimension;\n-        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n-        this.epsilon = epsilon;\n+        entries = new OpenIntToDoubleHashMap(expectedSize, defaultValue);\n+        setDefault(defaultValue, epsilon);\n     }\n \n     /**\n     public OpenMapRealVector(double[] values, double epsilon) {\n         virtualSize = values.length;\n         entries = new OpenIntToDoubleHashMap(0.0);\n-        this.epsilon = epsilon;\n+        setDefault(0, epsilon);\n         for (int key = 0; key < values.length; key++) {\n             double value = values[key];\n-            if (!isZero(value)) {\n+            if (!isDefaultValue(value)) {\n                 entries.put(key, value);\n             }\n         }\n      * @param values The set of values to create from\n      */\n     public OpenMapRealVector(Double[] values) {\n-        this(values, DEFAULT_ZERO_TOLERANCE);\n+        this(values, DEFAULT_ZERO_TOLERANCE, 0);\n     }\n \n     /**\n      * Only non-zero entries will be stored\n      * @param values The set of values to create from\n      * @param epsilon The tolerance for having a value considered zero\n-     */\n-    public OpenMapRealVector(Double[] values, double epsilon) {\n+     * @param defaultValue value for non-specified entries\n+     */\n+    public OpenMapRealVector(Double[] values, double epsilon, double defaultValue) {\n         virtualSize = values.length;\n-        entries = new OpenIntToDoubleHashMap(0.0);\n-        this.epsilon = epsilon;\n+        entries = new OpenIntToDoubleHashMap(defaultValue);\n+        setDefault(defaultValue, epsilon);\n         for (int key = 0; key < values.length; key++) {\n             double value = values[key].doubleValue();\n-            if (!isZero(value)) {\n+            if (!isDefaultValue(value)) {\n                 entries.put(key, value);\n             }\n         }\n     public OpenMapRealVector(OpenMapRealVector v) {\n         virtualSize = v.getDimension();\n         entries = new OpenIntToDoubleHashMap(v.getEntries());\n-        epsilon = v.getEpsilon();\n+        plusEpsilon = v.plusEpsilon;\n+        minusEpsilon = v.minusEpsilon;\n     }\n \n     /**\n     public OpenMapRealVector(RealVector v) {\n         virtualSize = v.getDimension();\n         entries = new OpenIntToDoubleHashMap(0.0);\n-        epsilon = DEFAULT_ZERO_TOLERANCE;\n+        setDefault(0, DEFAULT_ZERO_TOLERANCE);\n         for (int key = 0; key < virtualSize; key++) {\n             double value = v.getEntry(key);\n-            if (!isZero(value)) {\n+            if (!isDefaultValue(value)) {\n                 entries.put(key, value);\n             }\n         }\n+    }\n+\n+    /** Set defaults.\n+     * @param defaultValue value for non-specified entries\n+     * @param epsilon tolerance to check for equality with default value\n+     */\n+    private void setDefault(double defaultValue, double epsilon) {\n+      if (epsilon < 0) {\n+        throw new IllegalArgumentException(\"default tolerance must be > 0 :\" + epsilon);\n+      }\n+      plusEpsilon  = defaultValue + epsilon;\n+      minusEpsilon = defaultValue - epsilon;\n     }\n \n     /**\n     }\n \n     /**\n-     * Determine if this value is zero.\n+     * Determine if this value is within epsilon of the defaultValue (currently always zero).\n      * @param value The value to test\n-     * @return <code>true</code> if this value is zero, <code>false</code> otherwise\n-     */\n-    protected boolean isZero(double value) {\n-        return value > -epsilon && value < epsilon;\n-    }\n-\n-    /**\n-     * Get the tolerance for having a value considered zero.\n-     * @return The test range for testing if a value is zero\n-     */\n-    public double getEpsilon() {\n-        return epsilon;\n-    }\n-\n-    /**\n-     * Set the tolerance for having a value considered zero.\n-     * @param epsilon The test range for testing if a value is zero\n-     */\n-    public void setEpsilon(double epsilon) {\n-        this.epsilon = epsilon;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public OpenMapRealVector add(RealVector v) throws IllegalArgumentException {\n+     * @return <code>true</code> if this value is within epsilon to the defaultValue, <code>false</code> otherwise\n+     */\n+    protected boolean isDefaultValue(double value) {\n+        return value < plusEpsilon && value > minusEpsilon;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return add((OpenMapRealVector) v);\n-        }\n-        return add(v.getData());\n-    }\n-\n-    /**\n-     * Optimized method to add two OpenMapRealVectors.\n+        } else {\n+            return super.add(v);\n+        }\n+    }\n+\n+    /**\n+     * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.\n      * @param v Vector to add with\n      * @return The sum of <code>this</code> with <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n      */\n     public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n         checkVectorDimensions(v.getDimension());\n-        OpenMapRealVector res = copy();\n-        Iterator iter = v.getEntries().iterator();\n+        boolean copyThis = entries.size() > v.entries.size();\n+        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n+        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n+        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n         while (iter.hasNext()) {\n             iter.advance();\n             int key = iter.key();\n-            if (entries.containsKey(key)) {\n-                res.setEntry(key, entries.get(key) + iter.value());\n+            if (randomAccess.containsKey(key)) {\n+                res.setEntry(key, randomAccess.get(key) + iter.value());\n             } else {\n                 res.setEntry(key, iter.value());\n             }\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public OpenMapRealVector add(double[] v) throws IllegalArgumentException {\n-        checkVectorDimensions(v.length);\n-        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n-        for (int i = 0; i < v.length; i++) {\n-            res.setEntry(i, v[i] + getEntry(i));\n         }\n         return res;\n     }\n         return new OpenMapRealVector(this);\n     }\n \n-    /** {@inheritDoc} */\n-    public double dotProduct(RealVector v) throws IllegalArgumentException {\n-        checkVectorDimensions(v.getDimension());\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res += v.getEntry(iter.key()) * iter.value();\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double dotProduct(double[] v) throws IllegalArgumentException {\n-        checkVectorDimensions(v.length);\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            int idx = iter.key();\n-            double value = 0;\n-            if (idx < v.length) {\n-                value = v[idx];\n-            }\n-            res += value * iter.value();\n-        }\n-        return res;\n-    }\n \n     /** {@inheritDoc} */\n     public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n     /** {@inheritDoc} */\n     public void setEntry(int index, double value) throws MatrixIndexException {\n         checkIndex(index);\n-        if (!isZero(value)) {\n+        if (!isDefaultValue(value)) {\n             entries.put(index, value);\n         } else if (entries.containsKey(index)) {\n             entries.remove(index);\n     /** {@inheritDoc} */\n     public void unitize() {\n         double norm = getNorm();\n-        if (isZero(norm)) {\n+        if (isDefaultValue(norm)) {\n             throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n         }\n         Iterator iter = entries.iterator();\n \n     }\n \n-    /**\n-     * Check if an index is valid.\n-     *\n-     * @param index\n-     *            index to check\n-     * @exception MatrixIndexException\n-     *                if index is not valid\n-     */\n-    private void checkIndex(final int index) throws MatrixIndexException {\n-        if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(\n-                    \"index {0} out of allowed range [{1}, {2}]\",\n-                    index, 0, getDimension() - 1);\n-        }\n-    }\n-\n-    /**\n-     * Check if instance dimension is equal to some expected value.\n-     *\n-     * @param n\n-     *            expected dimension.\n-     * @exception IllegalArgumentException\n-     *                if the dimension is inconsistent with vector size\n-     */\n-    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n-        if (getDimension() != n) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n-                    getDimension(), n);\n-        }\n-    }\n \n     /** {@inheritDoc} */\n     public double[] toArray() {\n         final int prime = 31;\n         int result = 1;\n         long temp;\n-        temp = Double.doubleToLongBits(epsilon);\n+        temp = Double.doubleToLongBits(plusEpsilon) + Double.doubleToLongBits(minusEpsilon);\n         result = prime * result + (int) (temp ^ (temp >>> 32));\n         result = prime * result + virtualSize;\n         Iterator iter = entries.iterator();\n         if (virtualSize != other.virtualSize) {\n             return false;\n         }\n-        if (Double.doubleToLongBits(epsilon) !=\n-            Double.doubleToLongBits(other.epsilon)) {\n+        if (Double.doubleToLongBits(minusEpsilon) !=\n+            Double.doubleToLongBits(other.minusEpsilon)) {\n+            return false;\n+        }\n+        if (Double.doubleToLongBits(plusEpsilon) !=\n+            Double.doubleToLongBits(other.plusEpsilon)) {\n             return false;\n         }\n         Iterator iter = entries.iterator();\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.linear;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n \n /**\n  * Interface defining a real-valued vector with basic algebraic operations.\n public interface RealVector {\n \n     /**\n+     * Acts as if it is implemented as:\n+     * Entry e = null;\n+     * for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {\n+     *   e.setValue(function.value(e.getValue()));\n+     * }\n+     * @param function to apply to each successive entry\n+     * @return this vector\n+     * @throws FunctionEvaluationException if function throws it on application to any entry\n+     */\n+    RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException;\n+\n+    /**\n+     * Acts as if implemented as:\n+     * return copy().map(function);\n+     * @param function to apply to each successive entry\n+     * @return a new vector\n+     * @throws FunctionEvaluationException if function throws it on application to any entry\n+     */\n+    RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException;\n+\n+    /** Class representing a modifiable entry in the vector. */\n+    public abstract class Entry {\n+\n+        /** Index of the entry. */\n+        private int index;\n+\n+        /** Get the value of the entry.\n+         * @return value of the entry\n+         */\n+        public abstract double getValue();\n+\n+        /** Set the value of the entry.\n+         * @param value new value for the entry\n+         */\n+        public abstract void setValue(double value);\n+\n+        /** Get the index of the entry.\n+         * @return index of the entry\n+         */\n+        public int getIndex() {\n+            return index;\n+        }\n+\n+        /** Set the index of the entry.\n+         * @param index new index for the entry\n+         */\n+        public void setIndex(int index) {\n+            this.index = index;\n+        }\n+\n+    }\n+\n+    /**\n+     * Generic dense iterator - starts with index == zero, and hasNext() == true until index == getDimension();\n+     * @return a dense iterator\n+     */\n+    Iterator<Entry> iterator();\n+\n+    /**\n+     * Specialized implementations may choose to not iterate over all dimensions, either because those values are\n+     * unset, or are equal to defaultValue(), or are small enough to be ignored for the purposes of iteration.\n+     * No guarantees are made about order of iteration.\n+     * In dense implementations, this method will often delegate to {@see #iterator() }\n+     * @return a sparse iterator\n+     */\n+    Iterator<Entry> sparseIterator();\n+\n+    /**\n      * Returns a (deep) copy of this.\n      * @return vector copy\n      */\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.linear.RealVector.Entry;\n+\n+import java.util.Iterator;\n+import java.util.Random;\n+\n+/**\n+ * \n+ */\n+public class AbstractRealVectorTest extends TestCase {\n+    private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n+    private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };\n+\n+    private static class TestVectorImpl extends AbstractRealVector {\n+        private double[] values;\n+\n+        TestVectorImpl(double[] values) {\n+            this.values = values;\n+        }\n+\n+        @Override\n+        public double[] getData() { return values; }\n+        \n+        @Override\n+        public AbstractRealVector copy() {\n+            return new TestVectorImpl(values.clone());\n+        }\n+\n+\n+        UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Test implementation only supports methods necessary for testing\");\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            RealVector result = new ArrayRealVector(v);\n+            return result.add(this);\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            RealVector result = new ArrayRealVector(v);\n+            return result.subtract(this).mapMultiplyToSelf(-1);\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] += d;\n+            }\n+            return this;\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] -= d;\n+            }\n+            return this;\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] *= d;\n+            }\n+            return this;\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] /= d;\n+            }\n+            return this;\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] = Math.pow(values[i], d);\n+            }\n+            return this;\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] = 1/values[i];\n+            }\n+            return this;\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return values[index];\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            values[index] = value;\n+        }\n+\n+        public int getDimension() {\n+            return values.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+    }\n+\n+    private static void assertEquals(double[] d1, double[] d2) {\n+        assertEquals(d1.length, d2.length);\n+        for(int i=0; i<d1.length; i++) assertEquals(d1[i], d2[i]);\n+    }\n+\n+    public void testMap() throws Exception {\n+        double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n+        RealVector v = new TestVectorImpl(vec1.clone());\n+        RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });\n+        assertEquals(vec1Squared, w.getData());\n+    }\n+\n+    public void testIterator() throws Exception {\n+        RealVector v = new TestVectorImpl(vec2.clone());\n+        Entry e;\n+        int i = 0;\n+        for(Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) {\n+            assertEquals(vec2[i], e.getValue());\n+        }\n+    }\n+\n+    public void testSparseIterator() throws Exception {\n+        RealVector v = new TestVectorImpl(vec2.clone());\n+        Entry e;\n+        int i = 0;\n+        double[] nonDefaultV2 = { -3d, 2d, 1d };\n+        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; i++) {\n+            assertEquals(nonDefaultV2[i], e.getValue());\n+        }\n+    }\n+\n+    public void testClone() throws Exception {\n+        double[] d = new double[1000000];\n+        Random r = new Random(1234);\n+        for(int i=0;i<d.length; i++) d[i] = r.nextDouble();\n+        assertTrue(new ArrayRealVector(d).getNorm() > 0);\n+        double[] c = d.clone();\n+        c[0] = 1;\n+        assertNotSame(c[0], d[0]);\n+        d[0] = 1;\n+        assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm());\n+        long cloneTime = 0;\n+        long setAndAddTime = 0;\n+        for(int i=0; i<10; i++) {\n+          long start = System.nanoTime();\n+          double[] v = d.clone();\n+          for(int j=0; j<v.length; j++) v[j] += 1234.5678;\n+          if(i > 4) cloneTime += System.nanoTime() - start;\n+          start = System.nanoTime();\n+          v = new double[d.length];\n+          for(int j=0; j<v.length; j++) v[j] = d[j] + 1234.5678;\n+          if(i > 4) setAndAddTime += System.nanoTime() - start;\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n package org.apache.commons.math.linear;\n \n import java.io.Serializable;\n+import java.util.Iterator;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n  * Test cases for the {@link ArrayRealVector} class.\n \n         private UnsupportedOperationException unsupported() {\n             return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {\n+            throw unsupported();\n+        }\n+\n+        public Iterator<Entry> iterator() {\n+            return new Iterator<Entry>() {\n+                int i = 0;\n+                public boolean hasNext() {\n+                    return i<data.length;\n+                }\n+                public Entry next() {\n+                    final int j = i++;\n+                    Entry e = new Entry() {\n+                        public double getValue() {\n+                            return data[j];\n+                        }\n+                        public void setValue(double newValue) {\n+                            data[j] = newValue;\n+                        }\n+                    };\n+                    e.setIndex(j);\n+                    return e;\n+                }\n+                public void remove() { }\n+            };\n+        }\n+\n+        public Iterator<Entry> sparseIterator() {\n+            return iterator();\n         }\n \n         public RealVector copy() {\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n package org.apache.commons.math.linear;\n \n import java.io.Serializable;\n+import java.util.Iterator;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n  * Test cases for the {@link OpenMapRealVector} class.\n             return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n         }\n \n+        public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {\n+            throw unsupported();\n+        }\n+\n+        public Iterator<Entry> iterator() {\n+            throw unsupported();\n+        }\n+\n+        public Iterator<Entry> sparseIterator() {\n+            throw unsupported();\n+        }\n+\n         public RealVector copy() {\n-            throw unsupported();\n+            return new SparseRealVectorTestImpl(data);\n         }\n \n         public RealVector add(RealVector v) throws IllegalArgumentException {\n         }\n \n         public void setEntry(int index, double value) throws MatrixIndexException {\n-            throw unsupported();\n+            data[index] = value;\n         }\n \n         public void setSubVector(int index, RealVector v) throws MatrixIndexException {", "timestamp": 1260399371, "metainfo": ""}