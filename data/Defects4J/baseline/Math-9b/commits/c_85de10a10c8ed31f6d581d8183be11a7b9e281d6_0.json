{"sha": "85de10a10c8ed31f6d581d8183be11a7b9e281d6", "log": "Completed support fo asin, acos and atan in DSCompiler.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n         final double x = operand[operandOffset];\n         function[0] = FastMath.acos(x);\n         if (order > 0) {\n-            function[1] = -1.0 / FastMath.sqrt(1 - x * x);\n-            for (int i = 2; i <= order; ++i) {\n-                // TODO compute higher order derivatives\n-                function[i] = Double.NaN;\n+            // the nth order derivative of acos has the form:\n+            // dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)\n+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order];\n+            p[0] = -1;\n+            final double x2    = x * x;\n+            final double f     = 1.0 / (1 - x2);\n+            double coeff = FastMath.sqrt(f);\n+            function[1] = coeff * p[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(x)\n+                double v = 0;\n+                p[n - 1] = (n - 1) * p[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = p[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n             }\n         }\n \n         final double x = operand[operandOffset];\n         function[0] = FastMath.asin(x);\n         if (order > 0) {\n-            function[1] = 1.0 / FastMath.sqrt(1 - x * x);\n-            for (int i = 2; i <= order; ++i) {\n-                // TODO compute higher order derivatives\n-                function[i] = Double.NaN;\n+            // the nth order derivative of asin has the form:\n+            // dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)\n+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order];\n+            p[0] = 1;\n+            final double x2    = x * x;\n+            final double f     = 1.0 / (1 - x2);\n+            double coeff = FastMath.sqrt(f);\n+            function[1] = coeff * p[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(x)\n+                double v = 0;\n+                p[n - 1] = (n - 1) * p[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = p[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n             }\n         }\n \n         final double x = operand[operandOffset];\n         function[0] = FastMath.atan(x);\n         if (order > 0) {\n-            function[1] = 1.0 / (1 + x * x);\n-            for (int i = 2; i <= order; ++i) {\n-                // TODO compute higher order derivatives\n-                function[i] = Double.NaN;\n+            // the nth order derivative of atan has the form:\n+            // dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n\n+            // where Q_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ...\n+            // the general recurrence relation for Q_n is:\n+            // Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array\n+            final double[] q = new double[order];\n+            q[0] = 1;\n+            final double x2    = x * x;\n+            final double f     = 1.0 / (1 + x2);\n+            double coeff = f;\n+            function[1] = coeff * q[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial Q_n(x)\n+                double v = 0;\n+                q[n - 1] = -n * q[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + q[k];\n+                    if (k > 2) {\n+                        q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];\n+                    } else if (k == 2) {\n+                        q[0] = q[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testSinAsin() {\n+        double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 3.0e-15, 2.0e-14, 4.0e-13 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.sin().asin();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCosAcos() {\n+        double[] epsilon = new double[] { 6.0e-16, 6.0e-15, 2.0e-13, 4.0e-12, 2.0e-10 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.cos().acos();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTanAtan() {\n+        double[] epsilon = new double[] { 6.0e-17, 2.0e-16, 2.0e-15, 4.0e-14, 2.0e-12 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.tan().atan();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testTangentDefinition() {\n         double[] epsilon = new double[] { 5.0e-16, 2.0e-15, 3.0e-14, 5.0e-13, 2.0e-11 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {", "timestamp": 1344623586, "metainfo": ""}