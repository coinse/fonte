{"sha": "5fb92f9e73597386b6366e7850bf20da1794570b", "log": "added a forceSide method to UnivariateRealsolversUtils to allow selecting a bracketing side even for non-bracketing solvers like Bren or Newton  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.NoBracketingException;\n-import org.apache.commons.math.exception.NumberIsTooLargeException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n     }\n \n+    /** Force a root found by a non-bracketing solver to lie on a specified side,\n+     * as if the solver was a bracketing one.\n+     * @param maxEval maximal number of new evaluations of the function\n+     * (evaluations already done for finding the root should have already been subtracted\n+     * from this number)\n+     * @param f function to solve\n+     * @param bracketing bracketing solver to use for shifting the root\n+     * @param baseRoot original root found by a previous non-bracketing solver\n+     * @param min minimal bound of the search interval\n+     * @param max maximal bound of the search interval\n+     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     */\n+    public static double forceSide(final int maxEval, final UnivariateRealFunction f,\n+                                   final BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing,\n+                                   final double baseRoot, final double min, final double max,\n+                                   final AllowedSolutions allowedSolutions) {\n+\n+        if (allowedSolutions == AllowedSolutions.ANY_SIDE) {\n+            // no further bracketing required\n+            return baseRoot;\n+        }\n+\n+        // find a very small interval bracketing the root\n+        final double step = FastMath.max(bracketing.getAbsoluteAccuracy(),\n+                                         FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n+        double xLo        = baseRoot - step;\n+        double fLo        = f.value(xLo);\n+        double xHi        = baseRoot + step;\n+        double fHi        = f.value(xHi);\n+        int remainingEval = maxEval - 2;\n+        while ((remainingEval > 0) && (xLo >= min) && (xHi <= max)) {\n+\n+            if ((fLo > 0 && fHi < 0) || (fLo < 0 && fHi > 0)) {\n+                // compute the root on the selected side\n+                return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolutions);\n+            }\n+\n+            // try increasing the interval\n+            boolean changeLo = false;\n+            boolean changeHi = false;\n+            if (fLo < fHi) {\n+                // increasing function\n+                if (fLo >= 0) {\n+                    changeLo = true;\n+                } else {\n+                    changeHi = true;\n+                }\n+            } else if (fLo > fHi) {\n+                // decreasing function\n+                if (fLo <= 0) {\n+                    changeLo = true;\n+                } else {\n+                    changeHi = true;\n+                }\n+            } else {\n+                // unknown variation\n+                changeLo = true;\n+                changeHi = true;\n+            }\n+\n+            // update the lower bound\n+            if (changeLo) {\n+                xLo -= step;\n+                fLo  = f.value(xLo);\n+                remainingEval--;\n+            }\n+\n+            // update the higher bound\n+            if (changeHi) {\n+                xHi += step;\n+                fHi  = f.value(xHi);\n+                remainingEval--;\n+            }\n+\n+        }\n+\n+        throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING,\n+                                        xLo, xHi, fLo, fHi,\n+                                        maxEval - remainingEval, maxEval, baseRoot,\n+                                        min, max);\n+\n+    }\n+\n     /**\n      * This method attempts to find two values a and b satisfying <ul>\n-    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n      * <li> <code> f(a) * f(b) < 0 </code></li>\n      * </ul>\n      * If f is continuous on <code>[a,b],</code> this means that <code>a</code>", "timestamp": 1310296318, "metainfo": ""}