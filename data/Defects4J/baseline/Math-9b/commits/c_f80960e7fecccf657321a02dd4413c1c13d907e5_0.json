{"sha": "f80960e7fecccf657321a02dd4413c1c13d907e5", "log": "MATH-621 Function \"prelim\": Local variables defined at initialization.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n             if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                 fracsq = xoptsq * ONE_OVER_FOUR;\n                 sumpq = ZERO;\n+                // final RealVector sumVector\n+                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(xpt.operate(xopt));\n                 for (int k = 0; k < npt; k++) {\n                     sumpq += pq.getEntry(k);\n                     sum = -HALF * xoptsq;\n                     for (int i = 0; i < n; i++) {\n                         sum += xpt.getEntry(k, i) * xopt.getEntry(i);\n                     }\n+                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                     work2.setEntry(k, sum);\n                     temp = fracsq - HALF * sum;\n                     for (int i = 0; i < n; i++) {\n         final int ndim = bmat.getRowDimension();\n \n         final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n-        final double recip = ONE / rhosq;\n+        final double recip = 1d / rhosq;\n         final int np = n + 1;\n-\n-        // System generated locals\n-        double d__1, d__2, d__3, d__4;\n-\n-        // Local variables\n-        double f;\n-        int ih, nfm;\n-        int nfx = 0, ipt = 0, jpt = 0;\n-        double fbeg = 0, diff = 0, temp = 0, stepa = 0, stepb = 0;\n-        int itemp;\n-\n-        // Set some constants.\n-\n-        // Function Body\n \n         // Set XBASE to the initial vector of variables, and set the initial\n         // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n         // of function values so far. The coordinates of the displacement of the\n         // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n \n+        int ipt = 0;\n+        int jpt = 0;\n+        double fbeg = Double.NaN;\n         do {\n-            nfm = getEvaluations();\n-            nfx = getEvaluations() - n;\n+            final int nfm = getEvaluations();\n+            final int nfx = nfm - n;\n             final int nfmm = nfm - 1;\n             final int nfxm = nfx - 1;\n-            if (nfm <= n << 1) {\n-                if (nfm >= 1 && nfm <= n) {\n+            double stepa = 0;\n+            double stepb = 0;\n+            if (nfm <= 2 * n) {\n+                if (nfm >= 1 &&\n+                    nfm <= n) {\n                     stepa = initialTrustRegionRadius;\n                     if (su.getEntry(nfmm) == ZERO) {\n                         stepa = -stepa;\n+                        throw new PathIsExploredException(); // XXX\n                     }\n                     xpt.setEntry(nfm, nfmm, stepa);\n                 } else if (nfm > n) {\n                     stepa = xpt.getEntry(nfx, nfxm);\n                     stepb = -initialTrustRegionRadius;\n                     if (sl.getEntry(nfxm) == ZERO) {\n-                        // Computing MIN\n-                        final double d1 = TWO * initialTrustRegionRadius;\n-                        stepb = Math.min(d1, su.getEntry(nfxm));\n+                        stepb = Math.min(TWO * initialTrustRegionRadius, su.getEntry(nfxm));\n+                        throw new PathIsExploredException(); // XXX\n                     }\n                     if (su.getEntry(nfxm) == ZERO) {\n-                        // Computing MAX\n-                        final double d1 = -TWO * initialTrustRegionRadius;\n-                        stepb = Math.max(d1, sl.getEntry(nfxm));\n+                        stepb = Math.max(-TWO * initialTrustRegionRadius, sl.getEntry(nfxm));\n+                        throw new PathIsExploredException(); // XXX\n                     }\n                     xpt.setEntry(nfm, nfxm, stepb);\n                 }\n             } else {\n-                itemp = (nfm - np) / n;\n-                jpt = nfm - itemp * n - n;\n-                ipt = jpt + itemp;\n+                final int tmp1 = (nfm - np) / n;\n+                jpt = nfm - tmp1 * n - n;\n+                ipt = jpt + tmp1;\n                 if (ipt > n) {\n-                    itemp = jpt;\n+                    final int tmp2 = jpt;\n                     jpt = ipt - n;\n-                    ipt = itemp;\n+                    ipt = tmp2;\n+                    throw new PathIsExploredException(); // XXX\n                 }\n                 xpt.setEntry(nfm, ipt, xpt.getEntry(ipt, ipt));\n                 xpt.setEntry(nfm, jpt, xpt.getEntry(jpt, jpt));\n             // its index are required.\n \n             for (int j = 0; j < n; j++) {\n-                // Computing MIN\n-                // Computing MAX\n-                d__3 = lowerBound[j];\n-                d__4 = xbase.getEntry(j) + xpt.getEntry(nfm, j);\n-                d__1 = Math.max(d__3, d__4);\n-                d__2 = upperBound[j];\n-                currentBest.setEntry(j, Math.min(d__1, d__2));\n+                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n+                                                          xbase.getEntry(j) + xpt.getEntry(nfm, j)),\n+                                                 upperBound[j]));\n                 if (xpt.getEntry(nfm, j) == sl.getEntry(j)) {\n                     currentBest.setEntry(j, lowerBound[j]);\n                 }\n                     currentBest.setEntry(j, upperBound[j]);\n                 }\n             }\n-\n-            f = computeObjectiveValue(currentBest.getData());\n-\n-            if (!isMinimize)\n-                f = -f;\n+            \n+            final double objectiveValue = computeObjectiveValue(currentBest.getData());\n+            final double f = isMinimize ? objectiveValue : -objectiveValue;\n+            final int numEval = getEvaluations(); // nfm + 1\n             fval.setEntry(nfm, f);\n-            if (getEvaluations() == 1) {\n+\n+            if (numEval == 1) {\n                 fbeg = f;\n                 trustRegionCenterInterpolationPointIndex = 0;\n             } else if (f < fval.getEntry(trustRegionCenterInterpolationPointIndex)) {\n             // order that the function value at the first of them contributes to the\n             // off-diagonal second derivative terms of the initial quadratic model.\n \n-            if (getEvaluations() <= (n << 1) + 1) {\n-                if (getEvaluations() >= 2 && getEvaluations() <= n + 1) {\n+            if (numEval <= 2 * n + 1) {\n+                if (numEval >= 2 &&\n+                    numEval <= n + 1) {\n                     gopt.setEntry(nfmm, (f - fbeg) / stepa);\n-                    if (npt < getEvaluations() + n) {\n-                        bmat.setEntry(0, nfmm, -ONE / stepa);\n-                        bmat.setEntry(nfm, nfmm, ONE / stepa);\n+                    if (npt < numEval + n) {\n+                        final double oneOverStepA = ONE / stepa;\n+                        bmat.setEntry(0, nfmm, -oneOverStepA);\n+                        bmat.setEntry(nfm, nfmm, oneOverStepA);\n                         bmat.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n-                    }\n-                } else if (getEvaluations() >= n + 2) {\n-                    ih = nfx * (nfx + 1) / 2 - 1;\n-                    temp = (f - fbeg) / stepb;\n-                    diff = stepb - stepa;\n-                    hq.setEntry(ih, TWO * (temp - gopt.getEntry(nfxm)) / diff);\n-                    gopt.setEntry(nfxm, (gopt.getEntry(nfxm) * stepb - temp * stepa) / diff);\n+                        throw new PathIsExploredException(); // XXX\n+                    }\n+                } else if (numEval >= n + 2) {\n+                    final int ih = nfx * (nfx + 1) / 2 - 1;\n+                    final double tmp = (f - fbeg) / stepb;\n+                    final double diff = stepb - stepa;\n+                    hq.setEntry(ih, TWO * (tmp - gopt.getEntry(nfxm)) / diff);\n+                    gopt.setEntry(nfxm, (gopt.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                     if (stepa * stepb < ZERO) {\n                         if (f < fval.getEntry(nfm - n)) {\n                             fval.setEntry(nfm, fval.getEntry(nfm - n));\n                         }\n                     }\n                     bmat.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                    bmat.setEntry(nfm, nfxm, -HALF /\n-                                   xpt.getEntry(nfm - n, nfxm));\n-                    bmat.setEntry(nfm - n, nfxm, -bmat.getEntry(0, nfxm) -\n-                                   bmat.getEntry(nfm, nfxm));\n+                    bmat.setEntry(nfm, nfxm, -HALF / xpt.getEntry(nfm - n, nfxm));\n+                    bmat.setEntry(nfm - n, nfxm,\n+                                  -bmat.getEntry(0, nfxm) - bmat.getEntry(nfm, nfxm));\n                     zmat.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                     zmat.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                    zmat.setEntry(nfm - n, nfxm, -zmat.getEntry(0, nfxm) -\n-                                   zmat.getEntry(nfm, nfxm));\n+                    // zmat.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n+                    zmat.setEntry(nfm - n, nfxm,\n+                                  -zmat.getEntry(0, nfxm) - zmat.getEntry(nfm, nfxm));\n                 }\n \n                 // Set the off-diagonal second derivatives of the Lagrange functions and\n                 // the initial quadratic model.\n \n             } else {\n-                ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 zmat.setEntry(0, nfxm, recip);\n                 zmat.setEntry(nfm, nfxm, recip);\n                 zmat.setEntry(ipt, nfxm, -recip);\n                 zmat.setEntry(jpt, nfxm, -recip);\n-                temp = xpt.getEntry(nfm, ipt - 1) * xpt.getEntry(nfm, jpt - 1);\n-                hq.setEntry(ih, (fbeg - fval.getEntry(ipt) - fval.getEntry(jpt) + f) / temp);\n+\n+                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n+                final double tmp = xpt.getEntry(nfm, ipt - 1) * xpt.getEntry(nfm, jpt - 1);\n+                hq.setEntry(ih, (fbeg - fval.getEntry(ipt) - fval.getEntry(jpt) + f) / tmp);\n+                throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n     } // prelim", "timestamp": 1313789719, "metainfo": ""}