{"sha": "f5bd08d2b9bda97c6d6bf83308cfeb41c0557afe", "log": "improved error messages  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"empty selected row index array\",\n       \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n     { \"empty selected column index array\",\n-      \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" }\n+      \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" },\n+\n+   // org.apache.commons.math.random.EmpiricalDistributionImpl\n+   // org.apache.commons.math.random.ValueServer\n+   { \"URL {0} contains no data\",\n+     \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n+\n+   // org.apache.commons.math.complex.ComplexFormat\n+   { \"unparseable complex number: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.fraction.FractionFormat\n+   { \"unparseable fraction number: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du nombre rationnel \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.geometry.Vector3DFormat\n+   { \"unparseable 3D vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur de dimension 3 \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.linear.RealVectorFormat\n+   { \"unparseable real vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur r\\u00e9el \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.util.ResizableDoubleArray\n+   { \"the index specified: {0} is larger than the current maximal index {1}\",\n+     \"l''index sp\\u00e9cifi\\u00e9 ({0}) d\\u00e9passe l''index maximal courant ({1})\" },\n+   { \"elements cannot be retrieved from a negative array index {0}\",\n+     \"impossible d''extraire un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+   { \"cannot set an element at a negative index {0}\",\n+     \"impossible de mettre un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+\n+   // org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm\n+   { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+     \"division par z\\u00e9ro caus\\u00e9e par les abscisses identiques x[{0}] == x[{1}] == {2}\" },\n+\n+   // org.apache.commons.math.fraction.Fraction\n+   { \"zero denominator in fraction {0}/{1}\",\n+     \"d\\u00e9nominateur null dans le nombre rationnel {0}/{1}\" },\n+   { \"overflow in fraction {0}/{1}, cannot negate\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour la fraction {0}/{1}, son signe ne peut \\u00eatre chang\\u00e9\" },\n+   { \"overflow, numerator too large after multiply: {0}\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour le num\\u00e9rateur apr\\u00e8s multiplication : {0}\" },\n+   { \"the fraction to divide by must not be zero: {0}/{1}\",\n+     \"division par un nombre rationnel nul : {0}/{1}\" },\n+\n+   // org.apache.commons.math.geometry.Rotation\n+   { \"zero norm for rotation axis\",\n+     \"norme nulle pour un axe de rotation\" },\n+\n+   // org.apache.commons.math.geometry.Vector3D\n+    // org.apache.commons.math.linear.RealVectorImpl\n+   { \"cannot normalize a zero norm vector\",\n+     \"impossible de normer un vecteur de norme nulle\" },\n+   { \"zero norm\",\n+     \"norme nulle\" }\n \n   };\n \n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n \n import org.apache.commons.math.DuplicateSampleAbscissaException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Implements the representation of a real polynomial function in\n             }\n             if (d == 0.0) {\n                 // This happens only when two abscissas are identical.\n-                throw new ArithmeticException\n-                    (\"Identical abscissas cause division by zero.\");\n+                for (int k = 0; k < n; ++k) {\n+                    if ((i != k) && (x[i] == x[k])) {\n+                        throw MathRuntimeException.createArithmeticException(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+                                                                             new Object[] {\n+                                                                                 i, k, x[i]\n+                                                                             });\n+                    }\n+                }\n             }\n             t = y[i] / d;\n             // Lagrange polynomial is the sum of n terms, each of which is a\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n \n /**\n         ParsePosition parsePosition = new ParsePosition(0);\n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n-                                     \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable complex number: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n             return ((RealMatrixImpl) new RealMatrixImpl(jTj, false).inverse()).getDataRef();\n         } catch (InvalidMatrixException ime) {\n             throw new EstimationException(\"unable to compute covariances: singular problem\",\n-                                          new Object[0]);\n+                                          null);\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n                 }\n \n             } catch(InvalidMatrixException e) {\n-                throw new EstimationException(\"unable to solve: singular problem\", new Object[0]);\n+                throw new EstimationException(\"unable to solve: singular problem\", null);\n             }\n \n \n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n package org.apache.commons.math.fraction;\n \n import java.math.BigInteger;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     public Fraction(int num, int den) {\n         super();\n         if (den == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n+                                                                 new Object[] { num, den});\n         }\n         if (den < 0) {\n-            if (num == Integer.MIN_VALUE ||\n-                    den == Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n+            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n+                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                     new Object[] { num, den});\n             }\n             num = -num;\n             den = -den;\n      */\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n-            throw new ArithmeticException(\"overflow: too large to negate\");\n+            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                 new Object[] { numerator, denominator});\n         }\n         return new Fraction(-numerator, denominator);\n     }\n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n-            throw new ArithmeticException\n-            (\"overflow: numerator too large after multiply\");\n+            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n+                                                                 new Object[] { w });\n         }\n         return new Fraction (w.intValue(), \n                 MathUtils.mulAndCheck(denominator/d1, \n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n         if (fraction.numerator == 0) {\n-            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"the fraction to divide by must not be zero: {0}/{1}\",\n+                                                                 new Object[] { fraction.numerator, fraction.denominator });\n         }\n         return multiply(fraction.reciprocal());\n     }\n      */\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n+                                                                 new Object[] { numerator, denominator});\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n         if (denominator < 0) {\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n+                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                     new Object[] { numerator, denominator});\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Formats a Fraction number in proper format or improper format.  The number\n         ParsePosition parsePosition = new ParsePosition(0);\n         Fraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable fraction number: \\\"\" +\n-                source + \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable fraction number: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n package org.apache.commons.math.geometry;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n \n     double norm = axis.getNorm();\n     if (norm == 0) {\n-      throw new ArithmeticException(\"zero norm for rotation axis\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\",\n+                                                           null);\n     }\n \n     double halfAngle = -0.5 * angle;\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /** \n   public Vector3D normalize() {\n     double s = getNorm();\n     if (s == 0) {\n-      throw new ArithmeticException(\"cannot normalize a zero norm vector\");\n+      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n+                                                           null);\n     }\n     return scalarMultiply(1 / s);\n   }\n \n     double threshold = 0.6 * getNorm();\n     if (threshold == 0) {\n-      throw new ArithmeticException(\"null norm\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n     }\n \n     if ((x >= -threshold) && (x <= threshold)) {\n \n     double normProduct = v1.getNorm() * v2.getNorm();\n     if (normProduct == 0) {\n-      throw new ArithmeticException(\"null norm\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n     }\n \n     double dot = dotProduct(v1, v2);\n--- a/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n \n /**\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable 3D vector: \\\"\" + source +\n-                                     \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable 3D vector: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n \n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", new Object[0]);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", new Object[0]);\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n         }\n \n         final BigDecimal[][] subMatrixData =\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n \n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", new Object[0]);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", new Object[0]);\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n         }\n \n         final double[][] subMatrixData =\n--- a/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n import java.util.List;\n import java.util.Locale;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n \n /**\n         ParsePosition parsePosition = new ParsePosition(0);\n         RealVectorImpl result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable real vector: \\\"\" + source +\n-                                     \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable real vector: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     public RealVector unitVector() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw new ArithmeticException(\"null norm\");\n+            throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n         }\n         return mapDivide(getNorm());\n     }\n     public void unitize() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw new ArithmeticException(\"null norm\");\n+            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n+                                                                 null);\n         }\n         for (int i = 0; i < data.length; i++) {\n             data[i] /= norm;\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n       steps.get(index).setInterpolatedTime(time);\n \n     } catch (DerivativeException de) {\n-      throw new MathRuntimeException(\"unexpected exception caught\", new Object[0], de);\n+      throw new MathRuntimeException(\"unexpected exception caught\", null, de);\n     }\n \n   }\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n \n         } catch (DimensionMismatchException dme) {\n             // this should not happen\n-            throw new MathRuntimeException(\"unexpected exception caught\", new Object[0], dme);\n+            throw new MathRuntimeException(\"unexpected exception caught\", null, dme);\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n package org.apache.commons.math.random;\n \n import java.io.BufferedReader;\n-import java.io.EOFException;\n import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n             DataAdapter da = new StreamDataAdapter(in);\n             try {\n                 da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n             } catch (Exception e) {\n                 throw new IOException(e.getMessage());\n             }\n             if (sampleStats.getN() == 0) {\n-                throw new EOFException(\"URL \" + url + \" contains no data\");\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              new Object[] { url });\n             }\n             in = new BufferedReader(new InputStreamReader(url.openStream()));\n             fillBinStats(in);\n             DataAdapter da = new StreamDataAdapter(in);\n             try {\n                 da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n             } catch (Exception e) {\n                 throw new IOException(e.getMessage());\n             }\n         DataAdapter da = aFactory.getAdapter(in);\n         try {\n             da.computeBinStats(min, delta);\n+        } catch (IOException ioe) {\n+            // don't wrap exceptions which are already IOException\n+            throw ioe;\n+        } catch (RuntimeException rte) {\n+            // don't wrap RuntimeExceptions\n+            throw rte;\n         } catch (Exception e) {\n-            if(e instanceof RuntimeException){\n-                throw new RuntimeException(e.getMessage());\n-            }else{\n-                throw new IOException(e.getMessage());\n-            }\n+            throw new IOException(e.getMessage());\n         }\n \n         // Assign upperBounds based on bin counts\n                }\n            }\n         }\n-        throw new MathRuntimeException(\"no bin selected\", new Object[0]);\n+        throw new MathRuntimeException(\"no bin selected\", null);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n \n package org.apache.commons.math.random;\n import java.io.BufferedReader;\n-import java.io.EOFException;\n+import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.IOException;\n+import java.net.MalformedURLException;\n import java.net.URL;\n-import java.net.MalformedURLException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Generates values for use in simulation applications.\n             closeReplayFile();\n             resetReplayFile();\n             if ((str = filePointer.readLine()) == null) {\n-                throw new EOFException(\"URL \" + valuesFileURL + \" contains no data\");\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              new Object[] { valuesFileURL });\n             }\n         }\n         return Double.valueOf(str).doubleValue();\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n     public double transform(Object o) throws MathException{\n \n         if (o == null) {\n-            throw new MathException(\"Conversion Exception in Transformation, Object is null\", new Object[0]);\n+            throw new MathException(\"Conversion Exception in Transformation, Object is null\", null);\n         }\n \n         if (o instanceof Number) {\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n package org.apache.commons.math.util;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * <p>\n      */\n     public synchronized double getElement(int index) {\n         if (index >= numElements) {\n-            String msg =\n-                \"The index specified: \" + index +\n-                \" is larger than the current number of elements\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"the index specified: {0} is larger than the current maximal index {1}\",\n+                                                                            new Object[] { index, numElements - 1 });\n         } else if (index >= 0) {\n             return internalArray[startIndex + index];\n         } else {\n-            String msg =\n-                \"Elements cannot be retrieved from a negative array index\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"elements cannot be retrieved from a negative array index {0}\",\n+                                                                            new Object[] { index });\n         }\n     }\n     \n      */\n     public synchronized void setElement(int index, double value) {\n         if (index < 0) {\n-            String msg = \"Cannot set an element at a negative index\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"cannot set an element at a negative index {0}\",\n+                                                                            new Object[] { index });\n         }\n         if (index + 1 > numElements) {\n             numElements = index + 1;\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\", new Object[0]);\n+            throw new InvalidMatrixException(\"incorrect dimensions\", null);\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n--- a/src/test/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/org/apache/commons/math/util/TestBean.java\n      * \n      */\n     public Double getZ() {\n-        throw new MathRuntimeException();\n+        throw new MathRuntimeException(\"?\", null);\n     }\n \n     /**", "timestamp": 1226069723, "metainfo": ""}