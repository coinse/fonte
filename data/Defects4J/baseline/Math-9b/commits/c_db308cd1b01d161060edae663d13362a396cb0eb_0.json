{"sha": "db308cd1b01d161060edae663d13362a396cb0eb", "log": "Adding PascalDistributionImpl inadvertently omitted in r381115.  Thanks, Gump!  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * The default implementation of {@link PascalDistribution}.\n+ *\n+ * @version $Revision:$\n+ */\n+public class PascalDistributionImpl\n+    extends AbstractIntegerDistribution\n+    implements PascalDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 6751309484392813623L;\n+\n+    /** The number of trials */\n+    private int numberOfSuccesses;\n+\n+    /** The probability of success */\n+    private double probabilityOfSuccess;\n+\n+    /**\n+     * Create a binomial distribution with the given number of trials and\n+     * probability of success.\n+     * \n+     * @param r the number of successes\n+     * @param p the probability of success\n+     */\n+    public PascalDistributionImpl(int r, double p) {\n+        super();\n+        setNumberOfSuccesses(r);\n+        setProbabilityOfSuccess(p);\n+    }\n+\n+    /**\n+     * Access the number of trials for this distribution.\n+     * \n+     * @return the number of trials\n+     */\n+    public int getNumberOfSuccesses() {\n+        return numberOfSuccesses;\n+    }\n+\n+    /**\n+     * Access the probability of success for this distribution.\n+     * \n+     * @return the probability of success\n+     */\n+    public double getProbabilityOfSuccess() {\n+        return probabilityOfSuccess;\n+    }\n+\n+    /**\n+     * Change the number of trials for this distribution.\n+     * \n+     * @param successes the new number of trials\n+     * @throws IllegalArgumentException if <code>trials</code> is not positive.\n+     */\n+    public void setNumberOfSuccesses(int successes) {\n+        if (successes < 0) {\n+            throw new IllegalArgumentException(\"number of trials must be non-negative.\");\n+        }\n+        numberOfSuccesses = successes;\n+    }\n+\n+    /**\n+     * Change the probability of success for this distribution.\n+     * \n+     * @param p the new probability of success\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public void setProbabilityOfSuccess(double p) {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException(\"probability of success must be between 0.0 and 1.0, inclusive.\");\n+        }\n+        probabilityOfSuccess = p;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected int getDomainUpperBound(double p) {\n+      // use MAX - 1 because MAX causes loop\n+      return Integer.MAX_VALUE - 1;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &le; x).\n+     * \n+     * @param x the value at which the PDF is evaluated\n+     * @return PDF for this distribution\n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors\n+     */\n+    public double cumulativeProbability(int x) throws MathException {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = Beta.regularizedBeta(\n+                        getProbabilityOfSuccess(),\n+                        getNumberOfSuccesses(),\n+                        x + 1);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X = x).\n+     * \n+     * @param x the value at which the PMF is evaluated\n+     * @return PMF for this distribution \n+     */\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = MathUtils.binomialCoefficientDouble(x + getNumberOfSuccesses() - 1,\n+                    getNumberOfSuccesses() - 1) *\n+                  Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses()) *\n+                  Math.pow(1.0 - getProbabilityOfSuccess(),\n+                        x);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the largest x, such\n+     * that P(X &le; x) &le; <code>p</code>.\n+     * <p>\n+     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code> for\n+     * p=1.\n+     *\n+     * @param p the desired probability\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1\n+     */\n+    public int inverseCumulativeProbability(final double p) throws MathException {\n+        // handle extreme values explicitly\n+        if (p == 0) {\n+            return -1;\n+        } \n+        if (p == 1) {\n+            return Integer.MAX_VALUE; \n+        }\n+        \n+        // use default bisection impl\n+        return super.inverseCumulativeProbability(p);\n+    }\n+}", "timestamp": 1141309656, "metainfo": ""}