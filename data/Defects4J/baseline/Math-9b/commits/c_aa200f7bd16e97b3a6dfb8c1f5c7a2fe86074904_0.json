{"sha": "aa200f7bd16e97b3a6dfb8c1f5c7a2fe86074904", "log": "Adding unit test for SparseFieldVector  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link SparseFieldVector} class.\n+ *\n+ * @version $Revision: 728186 $ $Date: 2009-04-20 11:42:11 -0700 (Mon, 20 Apr 2009) $\n+ */\n+public class SparseFieldVectorTest extends TestCase {\n+\n+    // \n+    protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};\n+    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n+    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n+    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};\n+    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};\n+    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    protected FractionField field = FractionField.getInstance();\n+\n+    public void testMapFunctions() throws FractionConversionException { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n+        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        assertEquals(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n+        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        assertEquals(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n+        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        assertEquals(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n+        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        assertEquals(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n+        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        assertEquals(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n+        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        assertEquals(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n+        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n+        assertEquals(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n+        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};\n+        assertEquals(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInv = v1.mapInv();\n+        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n+        assertEquals(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};\n+        assertEquals(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+\n+    }\n+\n+    public void testBasicFunctions() throws FractionConversionException { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+        SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);\n+\n+        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2); \n+\n+        //octave =  v1 + v2\n+        FieldVector<Fraction> v_add = v1.add(v2);\n+        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        assertEquals(\"compare vect\" ,v_add.getData(),result_add);\n+\n+        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);\n+        FieldVector<Fraction> v_add_i = v1.add(vt2);\n+        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        assertEquals(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+\n+        //octave =  v1 - v2\n+        SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);\n+        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);\n+        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);\n+        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);\n+        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        Fraction dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(32), dot);\n+\n+        // octave  dot(v1,v2_t)\n+        Fraction dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+\n+        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+\n+        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+    }\n+\n+\n+    public void testMisc() { \n+        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }     \n+\n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });\n+\n+        v.setEntry(0, field.getZero());\n+        assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));\n+        assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));\n+\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+        }\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i].doubleValue(),n[i].doubleValue(), tolerance);\n+        }\n+    }\n+\n+}", "timestamp": 1241405970, "metainfo": ""}