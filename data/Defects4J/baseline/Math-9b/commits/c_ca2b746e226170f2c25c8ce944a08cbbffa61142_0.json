{"sha": "ca2b746e226170f2c25c8ce944a08cbbffa61142", "log": "completely changed integration start phase: now the starter integrator for multistep methods do not advance time anymore, it is interrupted at first step end and the interpolator is used to reconstruct Nordsieck vector information at integration start. Then the normal multistep integrators does start also exactly at integration start and is responsible for all time advancing stuff, including step handlers and events handlers management.  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n \n package org.apache.commons.math.ode;\n \n-import java.io.Serializable;\n-import java.util.Arrays;\n-\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n-import org.apache.commons.math.ode.events.EventException;\n-import org.apache.commons.math.ode.events.EventHandler;\n-import org.apache.commons.math.ode.events.EventState;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n-import org.apache.commons.math.ode.sampling.FixedStepHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n-import org.apache.commons.math.ode.sampling.StepNormalizer;\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * This class is the base class for multistep integrators for Ordinary\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public abstract class MultistepIntegrator extends AbstractIntegrator implements Serializable {\n-    \n-    /**\n-     * Serialization UID\n-     */\n+public abstract class MultistepIntegrator extends AdaptiveStepsizeIntegrator {\n+\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = 1L;\n+\n+    /** Transformer. */\n+    protected final transient NordsieckTransformer transformer;\n \n     /** Starter integrator. */\n     private FirstOrderIntegrator starter;\n \n-    /** Previous steps times. */\n-    protected double[] previousT;\n-\n-    /** Previous steps derivatives. */\n-    protected double[][] previousF;\n-\n-    /** Time of last detected reset. */\n-    private double resetTime;\n+    /** Number of steps of the multistep method (including the one being computed). */\n+    private final int nSteps;\n+\n+    /** First scaled derivative (h y'). */\n+    protected double[] scaled;\n+\n+    /** Nordsieck matrix of the higher scaled derivatives.\n+     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n+     */\n+    protected RealMatrix nordsieck;\n+\n+    /** Stepsize control exponent. */\n+    private double exp;\n+\n+    /** Safety factor for stepsize control. */\n+    private double safety;\n+\n+    /** Minimal reduction factor for stepsize control. */\n+    private double minReduction;\n+\n+    /** Maximal growth factor for stepsize control. */\n+    private double maxGrowth;\n \n     /**\n-     * Build a multistep integrator with the given number of steps.\n+     * Build a multistep integrator with the given stepsize bounds.\n      * <p>The default starter integrator is set to the {@link\n      * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n      * some defaults settings.</p>\n      * @param name name of the method\n-     * @param k number of steps of the multistep method\n+     * @param nSteps number of steps of the multistep method\n      * (including the one being computed)\n-     */\n-    protected MultistepIntegrator(final String name, final int k) {\n-        super(name);\n-        starter = new DormandPrince853Integrator(MathUtils.SAFE_MIN, Double.MAX_VALUE,\n-                                                 1.0e-8, 1.0e-8);\n-        previousT = new double[k];\n-        previousF = new double[k][];\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     */\n+    protected MultistepIntegrator(final String name, final int nSteps,\n+                                  final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double scalAbsoluteTolerance,\n+                                  final double scalRelativeTolerance) {\n+\n+        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+        if (nSteps <= 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} is supported only for 2 points or more\",\n+                  name);\n+        }\n+\n+        starter = new DormandPrince853Integrator(minStep, maxStep,\n+                                                 scalAbsoluteTolerance,\n+                                                 scalRelativeTolerance);\n+        this.nSteps = nSteps;\n+        transformer = NordsieckTransformer.getInstance(nSteps);\n+\n+        exp = -1.0 / order;\n+\n+        // set the default values of the algorithm control parameters\n+        setSafety(0.9);\n+        setMinReduction(0.2);\n+        setMaxGrowth(10.0);\n+\n+    }\n+\n+    /**\n+     * Build a multistep integrator with the given stepsize bounds.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * @param name name of the method\n+     * @param nSteps number of steps of the multistep method\n+     * (including the one being computed)\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     */\n+    protected MultistepIntegrator(final String name, final int nSteps,\n+                                  final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double[] vecAbsoluteTolerance,\n+                                  final double[] vecRelativeTolerance) {\n+        super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+        starter = new DormandPrince853Integrator(minStep, maxStep,\n+                                                 vecAbsoluteTolerance,\n+                                                 vecRelativeTolerance);\n+        this.nSteps = nSteps;\n+        transformer = NordsieckTransformer.getInstance(nSteps);\n+\n+        exp = -1.0 / order;\n+\n+        // set the default values of the algorithm control parameters\n+        setSafety(0.9);\n+        setMinReduction(0.2);\n+        setMaxGrowth(10.0);\n+\n     }\n \n     /**\n     }\n \n     /** Start the integration.\n-     * <p>This method computes the first few steps of the multistep method,\n-     * using the underlying starter integrator, ensuring the returned steps\n-     * all belong to the same smooth range.</p>\n-     * <p>In order to ensure smoothness, the start phase is automatically\n-     * restarted when a state or derivative reset is triggered by the\n-     * registered events handlers before this start phase is completed. As\n-     * an example, consider integrating a differential equation from t=0\n-     * to t=100 with a 4 steps method and step size equal to 0.2. If an event\n-     * resets the state at t=0.5, the start phase will not end at t=0.6 with\n-     * steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps\n-     * at [0.5, 0.7, 0.9, 1.1].</p>\n-     * <p>A side effect of the need for smoothness is that an ODE triggering\n-     * short period regular resets will remain in the start phase throughout\n-     * the integration range if the step size or the number of steps to store\n-     * are too large.</p>\n-     * <p>If the start phase ends prematurely (because of some triggered event\n-     * for example), then the time of latest previous steps will be set to\n-     * <code>Double.NaN</code>.</p>\n-     * @param n number of steps to store\n-     * @param h signed step size to use for the first steps\n-     * @param manager discrete events manager to use\n+     * <p>This method computes one step using the underlying starter integrator,\n+     * and initializes the Nordsieck vector at step start. The starter integrator\n+     * purpose is only to establish initial conditions, it does not really change\n+     * time by itself. The top level multistep integrator remains in charge of\n+     * handling time propagation and events handling as it will starts its own\n+     * computation right from the beginning. In a sense, the starter integrator\n+     * can be seen as a dummy one and so it will never trigger any user event nor\n+     * call any user step handler.</p>\n      * @param t0 initial time\n-     * @param y state vector: contains the initial value of the state vector at t0,\n-     * will be used to put the state vector at each successful step and hence\n-     * contains the final value at the end of the start phase\n-     * @return time of the end of the start phase\n+     * @param y0 initial value of the state vector at t0\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n      * @throws IntegratorException if the integrator cannot perform integration\n      * @throws DerivativeException this exception is propagated to the caller if\n      * the underlying user function triggers one\n      */\n-    protected double start(final int n, final double h,\n-                           final CombinedEventsManager manager,\n-                           final double t0, final double[] y)\n+    protected void start(final double t0, final double[] y0, final double t)\n         throws DerivativeException, IntegratorException {\n \n-        // clear the first steps\n-        Arrays.fill(previousT, Double.NaN);\n-        Arrays.fill(previousF, null);\n-\n-        // configure the event handlers\n-        starter.clearEventHandlers();\n-        for (EventState state : manager.getEventsStates()) {\n-            starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),\n-                                    state.getMaxCheckInterval(),\n-                                    state.getConvergence(), state.getMaxIterationCount());\n-        }\n-\n-        // configure the step handlers\n-        starter.clearStepHandlers();\n-        for (final StepHandler handler : stepHandlers) {\n-            // add the user defined step handlers, filtering out the isLast indicator\n-            starter.addStepHandler(new FilteringWrapper(handler));\n-        }\n-\n-        // add one specific step handler to store the first steps\n-        final StoringStepHandler store = new StoringStepHandler(n);\n-        starter.addStepHandler(new StepNormalizer(h, store));\n-\n-        // integrate over the first few steps, ensuring no intermediate reset occurs\n-        double t = t0;\n-        double stopTime = Double.NaN;\n-        FirstOrderDifferentialEquations equations =\n-            new CountingDifferentialEquations(y.length);\n-        do {\n-            resetTime = Double.NaN;\n-            final double dt = (n - 0.9999) * h;\n-            for (EventHandler handler : starter.getEventHandlers()) {\n-                ((ResetCheckingWrapper) handler).setRange(t, Math.abs(dt));\n-            }\n-            store.restart();\n-\n-            // we overshoot by 1/10000 step the end to make sure we don't miss the last point\n-            stopTime = starter.integrate(equations, t, y, t + dt, y);\n-\n-            if (!Double.isNaN(resetTime)) {\n-                // there was an intermediate reset, we restart\n-                t = resetTime;\n-            }\n-        } while (!Double.isNaN(resetTime));\n-\n-        // clear configuration\n+        // make sure NO user event nor user step handler is triggered,\n+        // this is the task of the top level integrator, not the task\n+        // of the starter integrator\n         starter.clearEventHandlers();\n         starter.clearStepHandlers();\n \n-        if (store.getFinalState() != null) {\n-            System.arraycopy(store.getFinalState(), 0, y, 0, y.length);\n-        }\n-        return stopTime;\n-\n-    }\n-\n-    /** Rotate the previous steps arrays.\n-     */\n-    protected void rotatePreviousSteps() {\n-        final double[] rolled = previousF[previousT.length - 1];\n-        for (int k = previousF.length - 1; k > 0; --k) {\n-            previousT[k] = previousT[k - 1];\n-            previousF[k] = previousF[k - 1];\n-        }\n-        previousF[0] = rolled;\n-    }\n-\n-    /** Event handler wrapper to check if state or derivatives have been reset. */\n-    private class ResetCheckingWrapper implements EventHandler {\n+        // set up one specific step handler to extract initial Nordsieck vector\n+        starter.addStepHandler(new NordsieckInitializer(y0.length));\n+\n+        // start integration, expecting a InitializationCompletedMarkerException\n+        try {\n+            starter.integrate(new CountingDifferentialEquations(y0.length),\n+                              t0, y0, t, new double[y0.length]);\n+        } catch (DerivativeException de) {\n+            if (!(de instanceof InitializationCompletedMarkerException)) {\n+                // this is not the expected nominal interruption of the start integrator\n+                throw de;\n+            }\n+        }\n+\n+        // remove the specific step handler\n+        starter.clearStepHandlers();\n+\n+    }\n+\n+    /** Get the minimal reduction factor for stepsize control.\n+     * @return minimal reduction factor\n+     */\n+    public double getMinReduction() {\n+        return minReduction;\n+    }\n+\n+    /** Set the minimal reduction factor for stepsize control.\n+     * @param minReduction minimal reduction factor\n+     */\n+    public void setMinReduction(final double minReduction) {\n+        this.minReduction = minReduction;\n+    }\n+\n+    /** Get the maximal growth factor for stepsize control.\n+     * @return maximal growth factor\n+     */\n+    public double getMaxGrowth() {\n+        return maxGrowth;\n+    }\n+\n+    /** Set the maximal growth factor for stepsize control.\n+     * @param maxGrowth maximal growth factor\n+     */\n+    public void setMaxGrowth(final double maxGrowth) {\n+        this.maxGrowth = maxGrowth;\n+    }\n+\n+    /** Get the safety factor for stepsize control.\n+     * @return safety factor\n+     */\n+    public double getSafety() {\n+      return safety;\n+    }\n+\n+    /** Set the safety factor for stepsize control.\n+     * @param safety safety factor\n+     */\n+    public void setSafety(final double safety) {\n+      this.safety = safety;\n+    }\n+\n+    /** Compute step grow/shrink factor according to normalized error.\n+     * @param error normalized error of the current step\n+     * @return grow/shrink factor for next step\n+     */\n+    protected double computeStepGrowShrinkFactor(final double error) {\n+        return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        oos.writeInt(nSteps);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            ois.defaultReadObject();\n+            final int nSteps = ois.readInt();\n+\n+            final Class<MultistepIntegrator> cl = MultistepIntegrator.class;\n+            final Field f = cl.getDeclaredField(\"transformer\");\n+            f.setAccessible(true);\n+            f.set(this, NordsieckTransformer.getInstance(nSteps));\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+    /** Specialized step handler storing the first step. */\n+    private class NordsieckInitializer implements StepHandler {\n \n         /** Serializable version identifier. */\n-        private static final long serialVersionUID = -3138614051962269485L;\n-\n-        /** Wrapped event handler. */\n-        private final EventHandler handler;\n-\n-        /** Range start. */\n-        private double rangeStart;\n-\n-        /** Range size. */\n-        private double rangeSize;\n-\n-        /** Build a new instance.\n-         * @param handler event handler to wrap\n+        private static final long serialVersionUID = 4452937833660410413L;\n+\n+        /** Problem dimension. */\n+        private final int n;\n+\n+        /** Simple constructor.\n+         * @param n problem dimension\n          */\n-        public ResetCheckingWrapper(final EventHandler handler) {\n-            this.handler = handler;\n-        }\n-\n-        /** Set the range.\n-         * @param rangeStart range start\n-         * @param rangeSize range size\n-         */\n-        public void setRange(final double rangeStart, final double rangeSize) {\n-            this.rangeStart = rangeStart;\n-            this.rangeSize  = rangeSize;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public int eventOccurred(double t, double[] y, boolean increasing)\n-            throws EventException {\n-            final int action = handler.eventOccurred(t, y, increasing);\n-            if (Math.abs(t - rangeStart) < 1.0e-10 * rangeSize) {\n-                // we have encountered again an already handled reset, don't stop here\n-                return action;\n-            }\n-            if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {\n-                // a singularity has been encountered\n-                // we need to restart the start phase\n-                resetTime = t;\n-                return STOP;\n-            }\n-            return action;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double g(double t, double[] y) throws EventException {\n-            return handler.g(t, y);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void resetState(double t, double[] y) throws EventException {\n-            handler.resetState(t, y);\n-        }\n-        \n-    }\n-\n-    /** Step handler wrapper filtering out the isLast indicator. */\n-    private class FilteringWrapper implements StepHandler {\n-\n-        /** Serializable version identifier. */\n-        private static final long serialVersionUID = 4607975253344802232L;\n-\n-        /** Wrapped step handler. */\n-        private final StepHandler handler;\n-\n-        /** Build a new instance.\n-         * @param handler step handler to wrap\n-         */\n-        public FilteringWrapper(final StepHandler handler) {\n-            this.handler = handler;\n+        public NordsieckInitializer(final int n) {\n+            this.n = n;\n         }\n \n         /** {@inheritDoc} */\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n-                throws DerivativeException {\n-            // we force the isLast indicator to false EXCEPT if some event handler triggered a stop\n-            handler.handleStep(interpolator, eventsHandlersManager.stop());\n+            throws DerivativeException {\n+\n+            final double prev = interpolator.getPreviousTime();\n+            final double curr = interpolator.getCurrentTime();\n+            stepStart = prev;\n+            stepSize  = (curr - prev) / nSteps;\n+\n+            // compute the first scaled derivative\n+            interpolator.setInterpolatedTime(prev);\n+            scaled = interpolator.getInterpolatedDerivatives().clone();\n+            for (int j = 0; j < n; ++j) {\n+                scaled[j] *= stepSize;\n+            }\n+\n+            // compute the high order scaled derivatives\n+            final double[][] multistep = new double[nSteps - 1][];\n+            for (int i = 1; i < nSteps; ++i) {\n+                interpolator.setInterpolatedTime(prev + stepSize * i);\n+                final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n+                for (int j = 0; j < n; ++j) {\n+                    msI[j] *= stepSize;\n+                }\n+                multistep[i - 1] = msI;\n+            }\n+            nordsieck = transformer.initializeHighOrderDerivatives(scaled, multistep);\n+\n+            // stop the integrator after the first step has been handled\n+            throw new InitializationCompletedMarkerException();\n+\n         }\n \n         /** {@inheritDoc} */\n         public boolean requiresDenseOutput() {\n-            return handler.requiresDenseOutput();\n+            return true;\n         }\n \n         /** {@inheritDoc} */\n         public void reset() {\n-            handler.reset();\n-        }\n-        \n-    }\n-\n-    /** Specialized step handler storing the first few steps. */\n-    private class StoringStepHandler implements FixedStepHandler {\n+            // nothing to do\n+        }\n+\n+    }\n+\n+    /** Marker exception used ONLY to stop the starter integrator after first step. */\n+    private static class InitializationCompletedMarkerException\n+        extends DerivativeException {\n \n         /** Serializable version identifier. */\n-        private static final long serialVersionUID = 4592974435520688797L;\n-\n-        /** Number of steps to store. */\n-        private final int n;\n-\n-        /** Counter for already stored steps. */\n-        private int count;\n-\n-        /** Final state. */\n-        private double[] finalState;\n-\n-        /** Build a new instance.\n-         * @param n number of steps to store\n-         */\n-        public StoringStepHandler(final int n) {\n-            this.n = n;\n-            restart();\n-        }\n-\n-        /** Restart storage.\n-         */\n-        public void restart() {\n-            count = 0;\n-            finalState = null;\n-        }\n-\n-        /** Get the final state.\n-         * @return final state\n-         */\n-        public double[] getFinalState() {\n-            return finalState;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void handleStep(final double t, final double[] y, final double[] yDot,\n-                               final boolean isLast) {\n-            if (count++ < n) {\n-                previousT[n - count] = t;\n-                previousF[n - count] = yDot.clone();\n-                if (count == n) {\n-                    finalState = y.clone();\n-                }\n-            }\n+        private static final long serialVersionUID = -4105805787353488365L;\n+\n+        /** Simple constructor. */\n+        public InitializationCompletedMarkerException() {\n+            super((Throwable) null);\n         }\n \n     }", "timestamp": 1245521604, "metainfo": ""}