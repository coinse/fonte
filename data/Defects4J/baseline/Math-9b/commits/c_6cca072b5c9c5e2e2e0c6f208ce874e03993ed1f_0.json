{"sha": "6cca072b5c9c5e2e2e0c6f208ce874e03993ed1f", "log": "MATH-451 In solvers, the maximum number of evaluations is passed as a parameter to the method \"solve\". The \"setMaxEvaluations\" accessor is removed.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateRealSolver.java\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void setup(DifferentiableUnivariateRealFunction f,\n-                         double min, double max,\n-                         double startValue) {\n-        super.setup(f, min, max, startValue);\n+    protected void setup(int maxEval, DifferentiableUnivariateRealFunction f,\n+                         double min, double max, double startValue) {\n+        super.setup(maxEval, f, min, max, startValue);\n         functionDerivative = f.derivative();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AbstractPolynomialSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractPolynomialSolver.java\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void setup(PolynomialFunction f,\n-                         double min, double max,\n-                         double startValue) {\n-        super.setup(f, min, max, startValue);\n+    protected void setup(int maxEval, PolynomialFunction f,\n+                             double min, double max, double startValue) {\n+        super.setup(maxEval, f, min, max, startValue);\n         polynomialFunction = f;\n     }\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n  */\n public abstract class BaseAbstractUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n     implements BaseUnivariateRealSolver<FUNC> {\n+    /** Default maximum number of evaluations */\n+    public static final int DEFAULT_MAX_EVALUATIONS = 100;\n     /** Default absolute accuracy */\n     public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     /** Default relative accuracy. */\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        evaluations.setMaximalCount(maxEvaluations);\n-    }\n-    /** {@inheritDoc} */\n     public int getMaxEvaluations() {\n         return evaluations.getMaximalCount();\n     }\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n-     */\n-    protected void setup(FUNC f,\n+     * @param maxEval Maximum number of evaluations.\n+     */\n+    protected void setup(int maxEval,\n+                         FUNC f,\n                          double min, double max,\n                          double startValue) {\n         // Checks.\n         searchMax = max;\n         searchStart = startValue;\n         function = f;\n+        evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n     }\n \n     /** {@inheritDoc} */\n     public double solve(FUNC f, double min, double max, double startValue) {\n+        return solve(DEFAULT_MAX_EVALUATIONS, f, min, max, startValue);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(FUNC f, double min, double max) {\n+        return solve(DEFAULT_MAX_EVALUATIONS, f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(FUNC f, double startValue) {\n+        return solve(DEFAULT_MAX_EVALUATIONS, f, startValue);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n         // Initialization.\n-        setup(f, min, max, startValue);\n+        setup(maxEval, f, min, max, startValue);\n \n         // Perform computation.\n         return doSolve();\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(FUNC f, double min, double max) {\n-        return solve(f, min, max, min + 0.5 * (max - min));\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double solve(FUNC f, double startValue) {\n-        return solve(f, Double.NaN, Double.NaN, startValue);\n+    public double solve(int maxEval, FUNC f, double min, double max) {\n+        return solve(maxEval, f, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(int maxEval, FUNC f, double startValue) {\n+        return solve(maxEval, f, Double.NaN, Double.NaN, startValue);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n  * @since 3.0\n  */\n public interface BaseUnivariateRealSolver<FUNC extends UnivariateRealFunction> {\n-    /**\n-     * Set the maximal number of function evaluations.\n-     *\n-     * @param maxEvaluations Maximal number of function evaluations.\n-     */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n     /**\n      * Get the maximal number of function evaluations.\n      *\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @return a value where the function is zero.\n-     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n-     * do not satisfy the requirements specified by the solver.\n-     * @since 2.0\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the default allowed number of evaluations is exceeded.\n      */\n     double solve(FUNC f, double min, double max);\n \n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n      * @return a value where the function is zero.\n-     * @throws IllegalArgumentException if {@code min > max} or the arguments\n-     * do not satisfy the requirements specified by the solver.\n-     * @since 2.0\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the default allowed number of evaluations is exceeded.\n      */\n     double solve(FUNC f, double min, double max, double startValue);\n \n     /**\n      * Solve for a zero in the vicinity of {@code startValue}.\n-     * A solver may require that the interval brackets a single zero root.\n      *\n      * @param f Function to solve.\n      * @param startValue Start value to use.\n      * @return a value where the function is zero.\n-     * @throws IllegalArgumentException if {@code min > max} or the arguments\n-     * do not satisfy the requirements specified by the solver.\n-     * @since 2.0\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the default allowed number of evaluations is exceeded.\n      */\n     double solve(FUNC f, double startValue);\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param maxEval Maximum number of evaluations.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max);\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param maxEval Maximum number of evaluations.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max, double startValue);\n+\n+    /**\n+     * Solve for a zero in the vicinity of {@code startValue}.\n+     *\n+     * @param f Function to solve.\n+     * @param startValue Start value to use.\n+     * @return a value where the function is zero.\n+     * @param maxEval Maximum number of evaluations.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double startValue);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n             throw new NullArgumentException(LocalizedFormats.FUNCTION);\n         }\n         final UnivariateRealSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(Integer.MAX_VALUE);\n-        return solver.solve(function, x0, x1);\n+        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n     }\n \n     /**\n             throw new NullArgumentException(LocalizedFormats.FUNCTION);\n         }\n         final UnivariateRealSolver solver = new BrentSolver(absoluteAccuracy);\n-        solver.setMaxEvaluations(Integer.MAX_VALUE);\n-        return solver.solve(function, x0, x1);\n+        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n                         }\n                     };\n                     final BrentSolver solver = new BrentSolver(convergence);\n-                    solver.setMaxEvaluations(maxIterationCount);\n-                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+                    final double root = (ta <= tb) ?\n+                        solver.solve(maxIterationCount, f, ta, tb) :\n+                        solver.solve(maxIterationCount, f, tb, ta);\n                     if ((FastMath.abs(root - ta) <= convergence) &&\n                          (FastMath.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n      */\n     public void setLineSearchSolver(final UnivariateRealSolver lineSearchSolver) {\n         solver = lineSearchSolver;\n-        solver.setMaxEvaluations(getMaxEvaluations());\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize() throws MathUserException {\n+    protected RealPointValuePair doOptimize() {\n         // Initialization.\n         if (preconditioner == null) {\n             preconditioner = new IdentityPreconditioner();\n         }\n         if (solver == null) {\n             solver = new BrentSolver();\n-            solver.setMaxEvaluations(getMaxEvaluations());\n         }\n         point = getStartPoint();\n         final GoalType goal = getGoalType();\n \n         RealPointValuePair current = null;\n         int iter = 0;\n+        int maxEval = getMaxEvaluations();\n         while (true) {\n             ++iter;\n \n             // XXX Last parameters is set to a value clode to zero in order to\n             // work around the divergence problem in the \"testCircleFitting\"\n             // unit test (see MATH-439).\n-            final double step = solver.solve(lsf, 0, uB, 1e-15);\n+            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n+            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n \n             // Validate new point.\n             for (int i = 0; i < point.length; ++i) {\n      * @param a lower bound of the interval.\n      * @param h initial step to try.\n      * @return b such that f(a) and f(b) have opposite signs.\n-     * @exception MathIllegalStateException if no bracket can be found.\n-     * @exception MathUserException if function throws one.\n+     * @throws MathIllegalStateException if no bracket can be found.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * function throws one.\n      */\n     private double findUpperBound(final UnivariateRealFunction f,\n-                                  final double a, final double h)\n-        throws MathUserException {\n+                                  final double a, final double h) {\n         final double yA = f.value(a);\n         double yB = yA;\n         for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n         }\n \n         /** {@inheritDoc} */\n-        public double value(double x) throws MathUserException {\n+        public double value(double x) {\n             // current point in the search direction\n             final double[] shiftedPoint = point.clone();\n             for (int i = 0; i < shiftedPoint.length; ++i) {\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n-        solver.setMaxEvaluations(50);\n         result = solver.solve(f, 3, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         double result;\n \n         BisectionSolver solver = new BisectionSolver();\n-        solver.setMaxEvaluations(50);\n         result = solver.solve(f, -0.2, 0.2);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n     }\n \n     @Test\n-    public void testMath369() throws Exception {\n+    public void testMath369() {\n         UnivariateRealFunction f = new SinFunction();\n         BisectionSolver solver = new BisectionSolver();\n-        solver.setMaxEvaluations(40);\n         Assert.assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n     }\n-\n-    /**\n-     *\n-     */\n-    @Test\n-    public void testSetMaximalEvaluationCount(){\n-        int expected = 100;\n-        BisectionSolver solver = new BisectionSolver();\n-        solver.setMaxEvaluations(expected);\n-        Assert.assertEquals(expected, solver.getMaxEvaluations());\n-    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.junit.Assert;\n import org.junit.Test;\n \n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(10);\n         // Somewhat benign interval. The function is monotone.\n         result = solver.solve(f, 3, 4);\n         // System.out.println(\n         double result;\n         // Brent-Dekker solver.\n         UnivariateRealSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(20);\n         // Symmetric bracket around 0. Test whether solvers can handle hitting\n         // the root in the first iteration.\n         result = solver.solve(f, -0.2, 0.2);\n        //     \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n         Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         Assert.assertTrue(solver.getEvaluations() <= 15);\n+\n+        try {\n+            result = solver.solve(5, f, 0.85, 5);\n+        } catch (TooManyEvaluationsException e) {\n+            // Expected.\n+        }\n     }\n \n     @Test\n     public void testRootEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n         BrentSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(10);\n \n         // endpoint is root\n         double result = solver.solve(f, FastMath.PI, 4);\n \n         result = solver.solve(f, 3, FastMath.PI, 3.07);\n         Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n     }\n \n     @Test\n     public void testBadEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n         BrentSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(10);\n         try {  // bad interval\n             solver.solve(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5);\n-            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5, 1.2);\n-            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n     }\n     public void testInitialGuess() {\n         MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n         BrentSolver solver = new BrentSolver();\n-        solver.setMaxEvaluations(20);\n         double result;\n \n         // no guess\n         // invalid guess (it *is* a root, but outside of the range)\n         try {\n           result = solver.solve(f, 0.6, 7.0, 0.0);\n-          Assert.fail(\"an IllegalArgumentException was expected\");\n-        } catch (IllegalArgumentException iae) {\n+          Assert.fail(\"a NumberIsTooLargeException was expected\");\n+        } catch (NumberIsTooLargeException iae) {\n             // expected behaviour\n         }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         double coefficients[] = { -1.0, 4.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n         LaguerreSolver solver = new LaguerreSolver();\n-        solver.setMaxEvaluations(10);\n \n         min = 0.0; max = 1.0; expected = 0.25;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n         LaguerreSolver solver = new LaguerreSolver();\n-        solver.setMaxEvaluations(10);\n \n         min = 0.0; max = 2.0; expected = 0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n         double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n         LaguerreSolver solver = new LaguerreSolver();\n-        solver.setMaxEvaluations(10);\n \n         min = -2.0; max = 2.0; expected = -1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n         LaguerreSolver solver = new LaguerreSolver();\n-        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             solver.solve(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n-        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     public void testQuinticFunction() {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n-        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new MullerSolver2();\n-        solver.setMaxEvaluations(55);\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver2();\n-        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             solver.solve(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+            Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n-        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     public void testQuinticFunction() {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n-        solver.setMaxEvaluations(15);\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new MullerSolver();\n-        solver.setMaxEvaluations(25);\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n-        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             double root = solver.solve(f, 1, -1);\n             System.out.println(\"root=\" + root);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+            Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n-        solver.setMaxEvaluations(10);\n         result = solver.solve(f, 3, 4);\n         Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         double result;\n \n         NewtonSolver solver = new NewtonSolver();\n-        solver.setMaxEvaluations(30);\n         result = solver.solve(f, -0.2, 0.2);\n         Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n     public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n-        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n     public void testQuinticFunction() {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n-        solver.setMaxEvaluations(15);\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n     public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new RiddersSolver();\n-        solver.setMaxEvaluations(20);\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n     public void testParameters() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n-        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             solver.solve(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n         } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+            Assert.fail(\"Expecting NoBracketingException - no bracketing\");\n         } catch (NoBracketingException ex) {\n             // expected\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new SecantSolver();\n-        solver.setMaxEvaluations(10);\n \n         result = solver.solve(f, 3, 4);\n         //System.out.println(\n         double result;\n         // Brent-Dekker solver.\n         UnivariateRealSolver solver = new SecantSolver();\n-        solver.setMaxEvaluations(20);\n         result = solver.solve(f, -0.2, 0.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n     public void testRootEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n         SecantSolver solver = new SecantSolver();\n-        solver.setMaxEvaluations(10);\n \n         // endpoint is root\n         double result = solver.solve(f, FastMath.PI, 4);\n     public void testBadEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n         SecantSolver solver = new SecantSolver();\n-        solver.setMaxEvaluations(10);\n         try {  // bad interval\n             solver.solve(f, 1, -1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5);\n-            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5, 1.2);\n-            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n                                                   new GaussianRandomGenerator(g));\n         MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n-        optimizer.setMaxEvaluations(100);\n-        assertEquals(100, optimizer.getMaxEvaluations());\n+        optimizer.setMaxEvaluations(200);\n+        assertEquals(200, optimizer.getMaxEvaluations());\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n         BrentSolver solver = new BrentSolver();\n         RealPointValuePair optimum =\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n         }, new double[] { 32, 23, 33, 31 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n+        optimizer.setMaxEvaluations(200);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n         BrentSolver solver = new BrentSolver(1e-15, 1e-15);\n         optimizer.setLineSearchSolver(solver);", "timestamp": 1291462272, "metainfo": ""}