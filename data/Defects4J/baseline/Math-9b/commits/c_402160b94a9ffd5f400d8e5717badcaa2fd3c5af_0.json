{"sha": "402160b94a9ffd5f400d8e5717badcaa2fd3c5af", "log": "Newton's method using the new differentiable interface.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">bisection algorithm</a>\n  *  for finding zeros of univariate real functions.  This algorithm will find only one zero in the given interval.\n  * The function should be continuous but not necessarily smooth.\n- * @version $Revision: 1.12 $ $Date: 2004/02/20 06:22:39 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/08 21:19:17 $\n  */\n public class BisectionSolver extends UnivariateRealSolverImpl implements Serializable {\n     /**\n         \n         int i = 0;\n         while (i < maximalIterationCount) {\n-            m = midpoint(min, max);\n+            m = UnivariateRealSolverUtils.midpoint(min, max);\n             fmin = f.value(min);\n             fm = f.value(m);\n \n             }\n \n             if (Math.abs(max - min) <= absoluteAccuracy) {\n-                m = midpoint(min, max);\n+                m = UnivariateRealSolverUtils.midpoint(min, max);\n                 setResult(m, i);\n                 return m;\n             }\n         \n         throw new MathException(\"Maximum number of iterations exceeded\");\n     }\n-\n-    /**\n-     * Compute the midpoint of two values.\n-     * @param a first value.\n-     * @param b second value.\n-     * @return the midpoint. \n-     */\n-    public static double midpoint(double a, double b) {\n-        return (a + b) * .5;\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+/*\n+ *\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\\\n+ * Newton's Method</a> for finding zeros of real univariate functions. This\n+ * algorithm will find only one zero in the given interval.  The function should\n+ * be continuous but not necessarily smooth.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/04/08 21:19:17 $\n+ */\n+public class NewtonSolver extends UnivariateRealSolverImpl implements Serializable {\n+    \n+    /** The first derivative of the target function. */\n+    private UnivariateRealFunction derivative;\n+    \n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     */\n+    public NewtonSolver(DifferentiableUnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+        derivative = f.derivative();\n+    }\n+\n+    /**\n+     * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max) throws MathException {\n+        return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));\n+    }\n+\n+    /**\n+     * Find a zero near the value <code>startValue</code>.\n+     * @param min the lower bound for the interval (ignored).\n+     * @param max the upper bound for the interval (ignored).\n+     * @param startValue the start value to use.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max, double startValue)\n+        throws MathException {\n+        \n+        clearResult();\n+\n+        double x0 = startValue;\n+        double x1;\n+        \n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            x1 = x0 - (f.value(x0) / derivative.value(x0));\n+\n+            if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n+                \n+                setResult(x1, i);\n+                return x1;\n+            }\n+            \n+            x0 = x1;\n+            ++i;\n+        }\n+        \n+        throw new MathException(\"Maximum number of iterations exceeded\");\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * <code>UnivariateRealSolverFactory.newInstance().</code>  The default is\n  * {@link UnivariateRealSolverFactoryImpl}.\n  * \n- * @version $Revision: 1.13 $ $Date: 2004/02/22 22:01:29 $\n+ * @version $Revision: 1.14 $ $Date: 2004/04/08 21:19:17 $\n  */\n public abstract class UnivariateRealSolverFactory {\n     /**\n     \n     /**\n      * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * solver is an implementation of Newton's Method.\n+     * @param f the function.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newNewtonSolver(\n+        DifferentiableUnivariateRealFunction f);\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n      * solver is an implementation of the secant method.\n      * @param f the function.\n      * @return the new solver.\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n \n import java.io.Serializable;\n \n-\n /**\n  * A concrete {@link  UnivariateRealSolverFactory}.  This is the default solver factory\n  * used by commons-math.\n  * <p>\n  * The default solver returned by this factory is a {@link BrentSolver}.\n  * \n- * @version $Revision: 1.10 $ $Date: 2004/02/22 22:01:29 $\n+ * @version $Revision: 1.11 $ $Date: 2004/04/08 21:19:17 $\n  */\n public class UnivariateRealSolverFactoryImpl\n     extends UnivariateRealSolverFactory implements Serializable {\n     public UnivariateRealSolver newBrentSolver(UnivariateRealFunction f) {\n         return new BrentSolver(f);\n     }\n-\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * solver is an implementation of Newton's Method.\n+     * @param f the function.\n+     * @return the new solver.\n+     */\n+    public UnivariateRealSolver newNewtonSolver(\n+        DifferentiableUnivariateRealFunction f) {\n+        \n+        return new NewtonSolver(f);\n+    }\n+    \n     /**\n      * Create a new {@link UnivariateRealSolver} for the given function.  The\n      * solver is an implementation of the secant method.\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n- * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:14 $\n+ * @version $Revision: 1.8 $ $Date: 2004/04/08 21:19:17 $\n  */\n public class UnivariateRealSolverUtils {\n     /**\n     \n         return new double[]{a, b};\n     }\n+\n+    /**\n+     * Compute the midpoint of two values.\n+     * @param a first value.\n+     * @param b second value.\n+     * @return the midpoint. \n+     */\n+    public static double midpoint(double a, double b) {\n+        return (a + b) * .5;\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n+/*\n+ * \n+ * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy\n+ * of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *  \n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/04/08 21:19:17 $\n+ */\n+public final class NewtonSolverTest extends TestCase {\n+    /**\n+     *\n+     */\n+    public void testSinZero() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new NewtonSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+    /**\n+     *\n+     */\n+    public void testQuinticZero() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        result = solver.solve(-0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(-0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(-0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n /**\n  * Auxillary class for testing solvers.\n  *\n- * @version $Revision: 1.11 $ $Date: 2004/02/21 21:35:16 $ \n+ * @version $Revision: 1.12 $ $Date: 2004/04/08 21:19:17 $ \n  */\n-public class QuinticFunction implements UnivariateRealFunction {\n+public class QuinticFunction implements DifferentiableUnivariateRealFunction {\n \n     /* Evaluate quintic.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n         return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n     }\n \n-    /* First derivative of quintic.\n-     */\n-    public double firstDerivative(double x) throws MathException {\n-        return (5*x*x-3.75)*x*x+0.25;\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws MathException {\n+                return (5*x*x-3.75)*x*x+0.25;\n+            }\n+        };\n     }\n-\n }\n--- a/src/test/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/SinFunction.java\n  * which means linear approximation (Regula Falsi) will converge\n  * quadratically.\n  * \n- * @version $Revision: 1.11 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.12 $ $Date: 2004/04/08 21:19:17 $\n  */\n-public class SinFunction implements UnivariateRealFunction {\n+public class SinFunction implements DifferentiableUnivariateRealFunction {\n \n     /* Evaluate sinus fuction.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n \n     /* First derivative of sinus function\n      */\n-    public double firstDerivative(double x) throws MathException {\n-        return Math.cos(x);\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws MathException {\n+                return Math.cos(x);\n+            }\n+        };\n     }\n \n }", "timestamp": 1081459157, "metainfo": ""}