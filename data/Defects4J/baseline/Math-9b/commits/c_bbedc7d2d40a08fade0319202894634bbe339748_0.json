{"sha": "bbedc7d2d40a08fade0319202894634bbe339748", "log": "Fixed svn props.  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n-/*\n- * Copyright 2003-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n- * Romberg Algorithm</a> for integrating of real univariate functions. For\n- * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n- * chapter 3.\n- * <p>\n- * Romberg integration employs k successvie refinements of the trapezoid\n- * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n- * is a special case of k = 2.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = -1058849527738180243L;\n-\n-    /**\n-     * Construct an integrator for the given function.\n-     * \n-     * @param f function to solve\n-     */\n-    public RombergIntegrator(UnivariateRealFunction f) {\n-        super(f, 32);\n-    }\n-\n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double integrate(double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException, IllegalArgumentException {\n-        \n-        int i = 1, j, m = maximalIterationCount + 1;\n-        // Array strcture here can be improved for better space\n-        // efficiency because only the lower triangle is used.\n-        double r, t[][] = new double[m][m], s, olds;\n-\n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n-\n-        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n-        t[0][0] = qtrap.stage(min, max, 0);\n-        olds = t[0][0];\n-        while (i <= maximalIterationCount) {\n-            t[i][0] = qtrap.stage(min, max, i);\n-            for (j = 1; j <= i; j++) {\n-                // Richardson extrapolation coefficient\n-                r = (1L << (2 * j)) -1;\n-                t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;\n-            }\n-            s = t[i][i];\n-            if (i >= minimalIterationCount) {\n-                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n-                    setResult(s, i);\n-                    return result;\n-                }\n-            }\n-            olds = s;\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-\n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 32 bisection refinements due to higher order divider\n-        if (maximalIterationCount > 32) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 32] range: \" +\n-                maximalIterationCount);\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n+ * Romberg Algorithm</a> for integrating of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * Romberg integration employs k successvie refinements of the trapezoid\n+ * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n+ * is a special case of k = 2.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -1058849527738180243L;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public RombergIntegrator(UnivariateRealFunction f) {\n+        super(f, 32);\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws ConvergenceException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1, j, m = maximalIterationCount + 1;\n+        // Array strcture here can be improved for better space\n+        // efficiency because only the lower triangle is used.\n+        double r, t[][] = new double[m][m], s, olds;\n+\n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n+        t[0][0] = qtrap.stage(min, max, 0);\n+        olds = t[0][0];\n+        while (i <= maximalIterationCount) {\n+            t[i][0] = qtrap.stage(min, max, i);\n+            for (j = 1; j <= i; j++) {\n+                // Richardson extrapolation coefficient\n+                r = (1L << (2 * j)) -1;\n+                t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;\n+            }\n+            s = t[i][i];\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 32 bisection refinements due to higher order divider\n+        if (maximalIterationCount > 32) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 32] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n- * Simpson's Rule</a> for integrating of real univariate functions. For\n- * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n- * chapter 3.\n- * <p>\n- * This implementation employs basic trapezoid rule as building blocks to\n- * calculate the Simpson's rule of alternating 2/3 and 4/3.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = 3405465123320678216L;\n-\n-    /**\n-     * Construct an integrator for the given function.\n-     * \n-     * @param f function to solve\n-     */\n-    public SimpsonIntegrator(UnivariateRealFunction f) {\n-        super(f, 64);\n-    }\n-\n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double integrate(double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException, IllegalArgumentException {\n-        \n-        int i = 1;\n-        double s, olds, t, oldt;\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n-\n-        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n-        if (minimalIterationCount == 1) {\n-            s = (4 * qtrap.stage(min, max, 1) - qtrap.stage(min, max, 0)) / 3.0;\n-            setResult(s, 1);\n-            return result;\n-        }\n-        // Simpson's rule requires at least two trapezoid stages.\n-        olds = 0;\n-        oldt = qtrap.stage(min, max, 0);\n-        while (i <= maximalIterationCount) {\n-            t = qtrap.stage(min, max, i);\n-            s = (4 * t - oldt) / 3.0;\n-            if (i >= minimalIterationCount) {\n-                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n-                    setResult(s, i);\n-                    return result;\n-                }\n-            }\n-            olds = s;\n-            oldt = t;\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-\n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 64 bisection refinements\n-        if (maximalIterationCount > 64) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 64] range: \" +\n-                maximalIterationCount);\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n+ * Simpson's Rule</a> for integrating of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * This implementation employs basic trapezoid rule as building blocks to\n+ * calculate the Simpson's rule of alternating 2/3 and 4/3.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 3405465123320678216L;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public SimpsonIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws ConvergenceException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double s, olds, t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n+        if (minimalIterationCount == 1) {\n+            s = (4 * qtrap.stage(min, max, 1) - qtrap.stage(min, max, 0)) / 3.0;\n+            setResult(s, 1);\n+            return result;\n+        }\n+        // Simpson's rule requires at least two trapezoid stages.\n+        olds = 0;\n+        oldt = qtrap.stage(min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = qtrap.stage(min, max, i);\n+            s = (4 * t - oldt) / 3.0;\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            oldt = t;\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 64] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n- * Trapezoidal Rule</a> for integrating of real univariate functions. For\n- * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n- * chapter 3.\n- * <p>\n- * The function should be integrable.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = 4978222553983172543L;\n-\n-    /** intermediate result */\n-    private double s;\n-\n-    /**\n-     * Construct an integrator for the given function.\n-     * \n-     * @param f function to solve\n-     */\n-    public TrapezoidIntegrator(UnivariateRealFunction f) {\n-        super(f, 64);\n-    }\n-\n-    /**\n-     * Compute the n-th stage integral of trapezoid rule. This function\n-     * should only be called by API <code>integrate()</code> in the package.\n-     * To save time it does not verify arguments - caller does.\n-     * <p>\n-     * The interval is divided equally into 2^n sections rather than an\n-     * arbitrary m sections because this configuration can best utilize the\n-     * alrealy computed values.\n-     *\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n-     * @return the value of n-th stage integral\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     */\n-    double stage(double min, double max, int n) throws\n-        FunctionEvaluationException {\n-        \n-        long i, np;\n-        double x, spacing, sum = 0;\n-        \n-        if (n == 0) {\n-            s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n-            return s;\n-        } else {\n-            np = 1L << (n-1);           // number of new points in this stage\n-            spacing = (max - min) / np; // spacing between adjacent new points\n-            x = min + 0.5 * spacing;    // the first new point\n-            for (i = 0; i < np; i++) {\n-                sum += f.value(x);\n-                x += spacing;\n-            }\n-            // add the new sum to previously calculated result\n-            s = 0.5 * (s + sum * spacing);\n-            return s;\n-        }\n-    }\n-\n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double integrate(double min, double max) throws ConvergenceException,\n-        FunctionEvaluationException, IllegalArgumentException {\n-        \n-        int i = 1;\n-        double t, oldt;\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        verifyIterationCount();\n-\n-        oldt = stage(min, max, 0);\n-        while (i <= maximalIterationCount) {\n-            t = stage(min, max, i);\n-            if (i >= minimalIterationCount) {\n-                if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {\n-                    setResult(t, i);\n-                    return result;\n-                }\n-            }\n-            oldt = t;\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-\n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        super.verifyIterationCount();\n-        // at most 64 bisection refinements\n-        if (maximalIterationCount > 64) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 64] range: \" +\n-                maximalIterationCount);\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n+ * Trapezoidal Rule</a> for integrating of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * The function should be integrable.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 4978222553983172543L;\n+\n+    /** intermediate result */\n+    private double s;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public TrapezoidIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral of trapezoid rule. This function\n+     * should only be called by API <code>integrate()</code> in the package.\n+     * To save time it does not verify arguments - caller does.\n+     * <p>\n+     * The interval is divided equally into 2^n sections rather than an\n+     * arbitrary m sections because this configuration can best utilize the\n+     * alrealy computed values.\n+     *\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n+     * @return the value of n-th stage integral\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     */\n+    double stage(double min, double max, int n) throws\n+        FunctionEvaluationException {\n+        \n+        long i, np;\n+        double x, spacing, sum = 0;\n+        \n+        if (n == 0) {\n+            s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n+            return s;\n+        } else {\n+            np = 1L << (n-1);           // number of new points in this stage\n+            spacing = (max - min) / np; // spacing between adjacent new points\n+            x = min + 0.5 * spacing;    // the first new point\n+            for (i = 0; i < np; i++) {\n+                sum += f.value(x);\n+                x += spacing;\n+            }\n+            // add the new sum to previously calculated result\n+            s = 0.5 * (s + sum * spacing);\n+            return s;\n+        }\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws ConvergenceException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        oldt = stage(min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = stage(min, max, i);\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {\n+                    setResult(t, i);\n+                    return result;\n+                }\n+            }\n+            oldt = t;\n+            i++;\n+        }\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 64] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Interface for univariate real integration algorithms.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public interface UnivariateRealIntegrator {\n-\n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * <p>\n-     * Usually a high iteration count indicates convergence problem. However,\n-     * the \"reasonable value\" varies widely for different cases.  Users are\n-     * advised to use the default value.\n-     * <p>\n-     * A <code>ConvergenceException</code> will be thrown if this number\n-     * is exceeded.\n-     *  \n-     * @param count maximum number of iterations\n-     */\n-    void setMaximalIterationCount(int count);\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    int getMaximalIterationCount();\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     * <p>\n-     * The default value is supplied by the implementation.\n-     * \n-     * @see #setMaximalIterationCount(int)\n-     */\n-    void resetMaximalIterationCount();\n-\n-    /**\n-     * Set the lower limit for the number of iterations.\n-     * <p>\n-     * Minimal iteration is needed to avoid false early convergence, e.g.\n-     * the sample points happen to be zeroes of the function. Users can\n-     * use the default value or choose one that they see as appropriate.\n-     * <p>\n-     * A <code>ConvergenceException</code> will be thrown if this number\n-     * is not met.\n-     *\n-     * @param count minimum number of iterations\n-     */\n-    void setMinimalIterationCount(int count);\n-\n-    /**\n-     * Get the lower limit for the number of iterations.\n-     * \n-     * @return the actual lower limit\n-     */\n-    int getMinimalIterationCount();\n-\n-    /**\n-     * Reset the lower limit for the number of iterations to the default.\n-     * <p>\n-     * The default value is supplied by the implementation.\n-     * \n-     * @see #setMinimalIterationCount(int)\n-     */\n-    void resetMinimalIterationCount();\n-\n-    /**\n-     * Set the relative accuracy.\n-     * <p>\n-     * This is used to stop iterations.\n-     * \n-     * @param accuracy the relative accuracy\n-     * @throws IllegalArgumentException if the accuracy can't be achieved\n-     * or is otherwise deemed unreasonable\n-     */\n-    void setRelativeAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     *\n-     * @return the accuracy\n-     */\n-    double getRelativeAccuracy();\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     * <p>\n-     * The default value is provided by the implementation.\n-     *\n-     * @see #setRelativeAccuracy(double)\n-     */\n-    void resetRelativeAccuracy();\n-\n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if min > max or the endpoints do not\n-     * satisfy the requirements specified by the integrator\n-     */\n-    double integrate(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException, IllegalArgumentException;\n-\n-    /**\n-     * Get the result of the last run of the integrator.\n-     * \n-     * @return the last result\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n-     */\n-    double getResult() throws IllegalStateException;\n-\n-    /**\n-     * Get the number of iterations in the last run of the integrator.\n-     * <p>\n-     * This is mainly meant for testing purposes. It may occasionally\n-     * help track down performance problems: if the iteration count\n-     * is notoriously high, check whether the function is evaluated\n-     * properly, and whether another integrator is more amenable to the\n-     * problem.\n-     * \n-     * @return the last iteration count\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n-     */\n-    int getIterationCount() throws IllegalStateException;\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Interface for univariate real integration algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateRealIntegrator {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * <p>\n+     * Usually a high iteration count indicates convergence problem. However,\n+     * the \"reasonable value\" varies widely for different cases.  Users are\n+     * advised to use the default value.\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is exceeded.\n+     *  \n+     * @param count maximum number of iterations\n+     */\n+    void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the implementation.\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the lower limit for the number of iterations.\n+     * <p>\n+     * Minimal iteration is needed to avoid false early convergence, e.g.\n+     * the sample points happen to be zeroes of the function. Users can\n+     * use the default value or choose one that they see as appropriate.\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is not met.\n+     *\n+     * @param count minimum number of iterations\n+     */\n+    void setMinimalIterationCount(int count);\n+\n+    /**\n+     * Get the lower limit for the number of iterations.\n+     * \n+     * @return the actual lower limit\n+     */\n+    int getMinimalIterationCount();\n+\n+    /**\n+     * Reset the lower limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the implementation.\n+     * \n+     * @see #setMinimalIterationCount(int)\n+     */\n+    void resetMinimalIterationCount();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * <p>\n+     * This is used to stop iterations.\n+     * \n+     * @param accuracy the relative accuracy\n+     * @throws IllegalArgumentException if the accuracy can't be achieved\n+     * or is otherwise deemed unreasonable\n+     */\n+    void setRelativeAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     *\n+     * @return the accuracy\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * <p>\n+     * The default value is provided by the implementation.\n+     *\n+     * @see #setRelativeAccuracy(double)\n+     */\n+    void resetRelativeAccuracy();\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the integrator\n+     */\n+    double integrate(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Get the result of the last run of the integrator.\n+     * \n+     * @return the last result\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    double getResult() throws IllegalStateException;\n+\n+    /**\n+     * Get the number of iterations in the last run of the integrator.\n+     * <p>\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the function is evaluated\n+     * properly, and whether another integrator is more amenable to the\n+     * problem.\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    int getIterationCount() throws IllegalStateException;\n+}\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Provide a default implementation for several generic functions.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public abstract class UnivariateRealIntegratorImpl implements\n-    UnivariateRealIntegrator, Serializable {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = -3365294665201465048L;\n-\n-    /** maximum relative error */\n-    protected double relativeAccuracy;\n-\n-    /** maximum number of iterations */\n-    protected int maximalIterationCount;\n-\n-    /** minimum number of iterations */\n-    protected int minimalIterationCount;\n-\n-    /** default maximum relative error */\n-    protected double defaultRelativeAccuracy;\n-\n-    /** default maximum number of iterations */\n-    protected int defaultMaximalIterationCount;\n-\n-    /** default minimum number of iterations */\n-    protected int defaultMinimalIterationCount;\n-\n-    /** indicates whether an integral has been computed */\n-    protected boolean resultComputed = false;\n-\n-    /** the last computed integral */\n-    protected double result;\n-\n-    /** the last iteration count */\n-    protected int iterationCount;\n-\n-    /** the integrand function */\n-    protected UnivariateRealFunction f;\n-\n-    /**\n-     * Construct an integrator with given iteration count and accuracy.\n-     * \n-     * @param f the integrand function\n-     * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the iteration\n-     * limits are not valid\n-     */\n-    protected UnivariateRealIntegratorImpl(\n-        UnivariateRealFunction f,\n-        int defaultMaximalIterationCount) throws IllegalArgumentException {\n-        \n-        if (f == null) {\n-            throw new IllegalArgumentException(\"Function can not be null.\");\n-        }\n-\n-        this.f = f;\n-        // parameters that may depend on algorithm\n-        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n-        this.maximalIterationCount = defaultMaximalIterationCount;\n-        // parameters that are problem specific\n-        this.defaultRelativeAccuracy = 1E-6;\n-        this.relativeAccuracy = defaultRelativeAccuracy;\n-        this.defaultMinimalIterationCount = 3;\n-        this.minimalIterationCount = defaultMinimalIterationCount;\n-        \n-        verifyIterationCount();\n-    }\n-\n-    /**\n-     * Access the last computed integral.\n-     * \n-     * @return the last computed integral\n-     * @throws IllegalStateException if no integral has been computed\n-     */\n-    public double getResult() throws IllegalStateException {\n-        if (resultComputed) {\n-            return result;\n-        } else {\n-            throw new IllegalStateException(\"No result available.\");\n-        }\n-    }\n-\n-    /**\n-     * Access the last iteration count.\n-     * \n-     * @return the last iteration count\n-     * @throws IllegalStateException if no integral has been computed\n-     */\n-    public int getIterationCount() throws IllegalStateException {\n-        if (resultComputed) {\n-            return iterationCount;\n-        } else {\n-            throw new IllegalStateException(\"No result available.\");\n-        }\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     * \n-     * @param result the result to set\n-     * @param iterationCount the iteration count to set\n-     */\n-    protected final void setResult(double result, int iterationCount) {\n-        this.result = result;\n-        this.iterationCount = iterationCount;\n-        this.resultComputed = true;\n-    }\n-\n-    /**\n-     * Convenience function for implementations.\n-     */\n-    protected final void clearResult() {\n-        this.resultComputed = false;\n-    }\n-\n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * \n-     * @param count maximum number of iterations\n-     */\n-    public void setMaximalIterationCount(int count) {\n-        maximalIterationCount = count;\n-    }\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    public int getMaximalIterationCount() {\n-        return maximalIterationCount;\n-    }\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     */\n-    public void resetMaximalIterationCount() {\n-        maximalIterationCount = defaultMaximalIterationCount;\n-    }\n-\n-    /**\n-     * Set the lower limit for the number of iterations.\n-     * \n-     * @param count minimum number of iterations\n-     */\n-    public void setMinimalIterationCount(int count) {\n-        minimalIterationCount = count;\n-    }\n-\n-    /**\n-     * Get the lower limit for the number of iterations.\n-     * \n-     * @return the actual lower limit\n-     */\n-    public int getMinimalIterationCount() {\n-        return minimalIterationCount;\n-    }\n-\n-    /**\n-     * Reset the lower limit for the number of iterations to the default.\n-     */\n-    public void resetMinimalIterationCount() {\n-        minimalIterationCount = defaultMinimalIterationCount;\n-    }\n-\n-    /**\n-     * Set the relative accuracy.\n-     * \n-     * @param accuracy the relative accuracy\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the integrator or is otherwise deemed unreasonable\n-     */\n-    public void setRelativeAccuracy(double accuracy) {\n-        relativeAccuracy = accuracy;\n-    }\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     *\n-     * @return the accuracy\n-     */\n-    public double getRelativeAccuracy() {\n-        return relativeAccuracy;\n-    }\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     */\n-    public void resetRelativeAccuracy() {\n-        relativeAccuracy = defaultRelativeAccuracy;\n-    }\n-\n-    /**\n-     * Returns true if the arguments form a (strictly) increasing sequence\n-     * \n-     * @param start first number\n-     * @param mid second number\n-     * @param end third number\n-     * @return true if the arguments form an increasing sequence\n-     */\n-    protected boolean isSequence(double start, double mid, double end) {\n-        return (start < mid) && (mid < end);\n-    }\n-\n-    /**\n-     * Verifies that the endpoints specify an interval.\n-     * \n-     * @param lower lower endpoint\n-     * @param upper upper endpoint\n-     * @throws IllegalArgumentException if not interval\n-     */\n-    protected void verifyInterval(double lower, double upper) throws\n-        IllegalArgumentException {\n-        if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"Endpoints do not specify an interval: [\" + lower +\n-                \", \" + upper + \"]\");\n-        }       \n-    }\n-\n-    /**\n-     * Verifies that the upper and lower limits of iterations are valid.\n-     * \n-     * @throws IllegalArgumentException if not valid\n-     */\n-    protected void verifyIterationCount() throws IllegalArgumentException {\n-        if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {\n-            throw new IllegalArgumentException\n-                (\"Invalid iteration limits: min=\" + minimalIterationCount +\n-                \" max=\" + maximalIterationCount);\n-        }       \n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Provide a default implementation for several generic functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class UnivariateRealIntegratorImpl implements\n+    UnivariateRealIntegrator, Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3365294665201465048L;\n+\n+    /** maximum relative error */\n+    protected double relativeAccuracy;\n+\n+    /** maximum number of iterations */\n+    protected int maximalIterationCount;\n+\n+    /** minimum number of iterations */\n+    protected int minimalIterationCount;\n+\n+    /** default maximum relative error */\n+    protected double defaultRelativeAccuracy;\n+\n+    /** default maximum number of iterations */\n+    protected int defaultMaximalIterationCount;\n+\n+    /** default minimum number of iterations */\n+    protected int defaultMinimalIterationCount;\n+\n+    /** indicates whether an integral has been computed */\n+    protected boolean resultComputed = false;\n+\n+    /** the last computed integral */\n+    protected double result;\n+\n+    /** the last iteration count */\n+    protected int iterationCount;\n+\n+    /** the integrand function */\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct an integrator with given iteration count and accuracy.\n+     * \n+     * @param f the integrand function\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the iteration\n+     * limits are not valid\n+     */\n+    protected UnivariateRealIntegratorImpl(\n+        UnivariateRealFunction f,\n+        int defaultMaximalIterationCount) throws IllegalArgumentException {\n+        \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"Function can not be null.\");\n+        }\n+\n+        this.f = f;\n+        // parameters that may depend on algorithm\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+        // parameters that are problem specific\n+        this.defaultRelativeAccuracy = 1E-6;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.defaultMinimalIterationCount = 3;\n+        this.minimalIterationCount = defaultMinimalIterationCount;\n+        \n+        verifyIterationCount();\n+    }\n+\n+    /**\n+     * Access the last computed integral.\n+     * \n+     * @return the last computed integral\n+     * @throws IllegalStateException if no integral has been computed\n+     */\n+    public double getResult() throws IllegalStateException {\n+        if (resultComputed) {\n+            return result;\n+        } else {\n+            throw new IllegalStateException(\"No result available.\");\n+        }\n+    }\n+\n+    /**\n+     * Access the last iteration count.\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if no integral has been computed\n+     */\n+    public int getIterationCount() throws IllegalStateException {\n+        if (resultComputed) {\n+            return iterationCount;\n+        } else {\n+            throw new IllegalStateException(\"No result available.\");\n+        }\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * \n+     * @param count maximum number of iterations\n+     */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Set the lower limit for the number of iterations.\n+     * \n+     * @param count minimum number of iterations\n+     */\n+    public void setMinimalIterationCount(int count) {\n+        minimalIterationCount = count;\n+    }\n+\n+    /**\n+     * Get the lower limit for the number of iterations.\n+     * \n+     * @return the actual lower limit\n+     */\n+    public int getMinimalIterationCount() {\n+        return minimalIterationCount;\n+    }\n+\n+    /**\n+     * Reset the lower limit for the number of iterations to the default.\n+     */\n+    public void resetMinimalIterationCount() {\n+        minimalIterationCount = defaultMinimalIterationCount;\n+    }\n+\n+    /**\n+     * Set the relative accuracy.\n+     * \n+     * @param accuracy the relative accuracy\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the integrator or is otherwise deemed unreasonable\n+     */\n+    public void setRelativeAccuracy(double accuracy) {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     *\n+     * @return the accuracy\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+    /**\n+     * Returns true if the arguments form a (strictly) increasing sequence\n+     * \n+     * @param start first number\n+     * @param mid second number\n+     * @param end third number\n+     * @return true if the arguments form an increasing sequence\n+     */\n+    protected boolean isSequence(double start, double mid, double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+\n+    /**\n+     * Verifies that the endpoints specify an interval.\n+     * \n+     * @param lower lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException if not interval\n+     */\n+    protected void verifyInterval(double lower, double upper) throws\n+        IllegalArgumentException {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"Endpoints do not specify an interval: [\" + lower +\n+                \", \" + upper + \"]\");\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the upper and lower limits of iterations are valid.\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {\n+            throw new IllegalArgumentException\n+                (\"Invalid iteration limits: min=\" + minimalIterationCount +\n+                \" max=\" + maximalIterationCount);\n+        }       \n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/RombergIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/RombergIntegratorTest.java\n-/*\n- * Copyright 2003-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Romberg integrator.\n- * <p>\n- * Romberg algorithm is very fast for good behavior integrand. Test runs\n- * show that for a default relative accuracy of 1E-6, it generally takes\n- * takes less than 5 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class RombergIntegratorTest extends TestCase {\n-\n-    /**\n-     * Test of integrator for the sine function.\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of integrator for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the integrator.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n-\n-        try {\n-            // bad interval\n-            integrator.integrate(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(50);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Romberg integrator.\n+ * <p>\n+ * Romberg algorithm is very fast for good behavior integrand. Test runs\n+ * show that for a default relative accuracy of 1E-6, it generally takes\n+ * takes less than 5 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RombergIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(50);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/SimpsonIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/SimpsonIntegratorTest.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Simpson integrator.\n- * <p>\n- * Test runs show that for a default relative accuracy of 1E-6, it\n- * generally takes 5 to 10 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class SimpsonIntegratorTest extends TestCase {\n-\n-    /**\n-     * Test of integrator for the sine function.\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of integrator for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the integrator.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n-\n-        try {\n-            // bad interval\n-            integrator.integrate(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(99);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Simpson integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 5 to 10 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class SimpsonIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/TrapezoidIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/TrapezoidIntegratorTest.java\n-/*\n- * Copyright 2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for trapezoid integrator.\n- * <p>\n- * Test runs show that for a default relative accuracy of 1E-6, it\n- * generally takes 10 to 15 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class TrapezoidIntegratorTest extends TestCase {\n-\n-    /**\n-     * Test of integrator for the sine function.\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of integrator for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n-        result = integrator.integrate(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the integrator.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n-\n-        try {\n-            // bad interval\n-            integrator.integrate(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(5);\n-            integrator.setMaximalIterationCount(4);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad iteration limits\n-            integrator.setMinimalIterationCount(10);\n-            integrator.setMaximalIterationCount(99);\n-            integrator.integrate(-1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for trapezoid integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 10 to 15 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class TrapezoidIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1124740737, "metainfo": ""}