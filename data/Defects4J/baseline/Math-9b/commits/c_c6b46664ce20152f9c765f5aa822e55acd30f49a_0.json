{"sha": "c6b46664ce20152f9c765f5aa822e55acd30f49a", "log": "Improved javadoc to explain how switching functions should behave across events in ODE events detection.  JIRA: MATH-937  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ode/events/EventHandler.java\n+++ b/src/main/java/org/apache/commons/math3/ode/events/EventHandler.java\n  */\n \n package org.apache.commons.math3.ode.events;\n+\n \n /** This interface represents a handler for discrete events triggered\n  * during ODE integration.\n    * The switching function must be continuous in its roots neighborhood\n    * (but not necessarily smooth), as the integrator will need to find its\n    * roots to locate precisely the events.</p>\n+   * <p>Also note that the integrator expect that once an event has occurred,\n+   * the sign of the switching function at the start of the next step (i.e.\n+   * just after the event) is the opposite of the sign just before the event.\n+   * This consistency between the steps <string>must</strong> be preserved,\n+   * otherwise {@link org.apache.commons.math3.exception.NoBracketingException\n+   * exceptions} related to root not being bracketed will occur.</p>\n+   * <p>This need for consistency is sometimes tricky to achieve. A typical\n+   * example is using an event to model a ball bouncing on the floor. The first\n+   * idea to represent this would be to have {@code g(t) = h(t)} where h is the\n+   * height above the floor at time {@code t}. When {@code g(t)} reaches 0, the\n+   * ball is on the floor, so it should bounce and the typical way to do this is\n+   * to reverse its vertical velocity. However, this would mean that before the\n+   * event {@code g(t)} was decreasing from positive values to 0, and after the\n+   * event {@code g(t)} would be increasing from 0 to positive values again.\n+   * Consistency is broken here! The solution here is to have {@code g(t) = sign\n+   * * h(t)}, where sign is a variable with initial value set to {@code +1}. Each\n+   * time {@link #eventOccurred(double, double[], boolean) eventOccurred} is called,\n+   * {@code sign} is reset to {@code -sign}. This allows the {@code g(t)}\n+   * function to remain continuous (and even smooth) even across events, despite\n+   * {@code h(t)} is not. Basically, the event is used to <em>fold</em> {@code h(t)}\n+   * at bounce points, and {@code sign} is used to <em>unfold</em> it back, so the\n+   * solvers sees a {@code g(t)} function which behaves smoothly even across events.</p>\n \n    * @param t current value of the independent <i>time</i> variable\n    * @param y array containing the current value of the state vector", "timestamp": 1362159406, "metainfo": ""}