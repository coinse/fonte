{"sha": "d50d68fb2c8cfbcf9dd786d404def57bfc9de7d5", "log": "Added and used a specialized exception for duplicate abscissas in sampled functions  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+/**\n+ * Exeption thrown when a sample contains several entries at the same abscissa.\n+ * @version $Revision:$\n+ */\n+public class DuplicateSampleAbscissaException extends MathException  {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2271007547170169872L;\n+\n+    /**\n+     * Construct an exception indicating the duplicate abscissa.\n+     * @param abscissa duplicate abscissa\n+     * @param i1 index of one entry having the duplicate abscissa\n+     * @param i2 index of another entry having the duplicate abscissa\n+     */\n+    public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n+        super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n+              new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });\n+    }\n+\n+    /**\n+     * Get the duplicate abscissa.\n+     * @return duplicate abscissa\n+     */\n+    public double getDuplicateAbscissa() {\n+        return ((Double) getArguments()[0]).doubleValue();\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import java.io.Serializable;\n-import org.apache.commons.math.MathException;\n-\n-/**\n- * Implements the <a href=\"\n- * \"http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html\">\n- * Divided Difference Algorithm</a> for interpolation of real univariate\n- * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n- * ISBN 038795452X, chapter 2.\n- * <p>\n- * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n- * this class provides an easy-to-use interface to it.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n-    Serializable {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = 107049519551235069L;\n-\n-    /**\n-     * Computes an interpolating function for the data set.\n-     *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @return a function which interpolates the data set\n-     * @throws MathException if arguments are invalid\n-     */\n-    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n-        MathException {\n-\n-        /**\n-         * a[] and c[] are defined in the general formula of Newton form:\n-         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n-         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n-         */\n-        double a[], c[];\n-\n-        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n-\n-        /**\n-         * When used for interpolation, the Newton form formula becomes\n-         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\n-         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n-         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n-         * <p>\n-         * Note x[], y[], a[] have the same length but c[]'s size is one less.\n-         */\n-        c = new double[x.length-1];\n-        for (int i = 0; i < c.length; i++) {\n-            c[i] = x[i];\n-        }\n-        a = computeDividedDifference(x, y);\n-\n-        PolynomialFunctionNewtonForm p;\n-        p = new PolynomialFunctionNewtonForm(a, c);\n-        return p;\n-    }\n-\n-    /**\n-     * Returns a copy of the divided difference array.\n-     * <p> \n-     * The divided difference array is defined recursively by <pre>\n-     * f[x0] = f(x0)\n-     * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n-     * </pre><p>\n-     * The computational complexity is O(N^2).\n-     *\n-     * @return a fresh copy of the divided difference array\n-     * @throws MathException if any abscissas coincide\n-     */\n-    protected static double[] computeDividedDifference(double x[], double y[])\n-        throws MathException {\n-\n-        int i, j, n;\n-        double divdiff[], a[], denominator;\n-\n-        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n-\n-        n = x.length;\n-        divdiff = new double[n];\n-        for (i = 0; i < n; i++) {\n-            divdiff[i] = y[i];      // initialization\n-        }\n-\n-        a = new double [n];\n-        a[0] = divdiff[0];\n-        for (i = 1; i < n; i++) {\n-            for (j = 0; j < n-i; j++) {\n-                denominator = x[j+i] - x[j];\n-                if (denominator == 0.0) {\n-                    // This happens only when two abscissas are identical.\n-                    throw new MathException\n-                        (\"Identical abscissas cause division by zero.\");\n-                }\n-                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n-            }\n-            a[i] = divdiff[0];\n-        }\n-\n-        return a;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+\n+/**\n+ * Implements the <a href=\"\n+ * \"http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html\">\n+ * Divided Difference Algorithm</a> for interpolation of real univariate\n+ * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n+ * ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 107049519551235069L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws DuplicateSampleAbscissaException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        DuplicateSampleAbscissaException {\n+\n+        /**\n+         * a[] and c[] are defined in the general formula of Newton form:\n+         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+         */\n+        double a[], c[];\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        /**\n+         * When used for interpolation, the Newton form formula becomes\n+         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\n+         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n+         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n+         * <p>\n+         * Note x[], y[], a[] have the same length but c[]'s size is one less.\n+         */\n+        c = new double[x.length-1];\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = x[i];\n+        }\n+        a = computeDividedDifference(x, y);\n+\n+        PolynomialFunctionNewtonForm p;\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns a copy of the divided difference array.\n+     * <p> \n+     * The divided difference array is defined recursively by <pre>\n+     * f[x0] = f(x0)\n+     * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n+     * </pre><p>\n+     * The computational complexity is O(N^2).\n+     *\n+     * @return a fresh copy of the divided difference array\n+     * @throws DuplicateSampleAbscissaException if any abscissas coincide\n+     */\n+    protected static double[] computeDividedDifference(double x[], double y[])\n+        throws DuplicateSampleAbscissaException {\n+\n+        int i, j, n;\n+        double divdiff[], a[], denominator;\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        divdiff = new double[n];\n+        for (i = 0; i < n; i++) {\n+            divdiff[i] = y[i];      // initialization\n+        }\n+\n+        a = new double [n];\n+        a[0] = divdiff[0];\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                denominator = x[j+i] - x[j];\n+                if (denominator == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[j], j, j+i);\n+                }\n+                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n+            }\n+            a[i] = divdiff[0];\n+        }\n+\n+        return a;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import java.io.Serializable;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Implements the representation of a real polynomial function in\n- * <a href=\"http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html\">\n- * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\n- * Analysis</b>, ISBN 038795452X, chapter 2.\n- * <p>\n- * The approximated function should be smooth enough for Lagrange polynomial\n- * to work well. Otherwise, consider using splines instead.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,\n-    Serializable {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = -3965199246151093920L;\n-\n-    /**\n-     * The coefficients of the polynomial, ordered by degree -- i.e.\n-     * coefficients[0] is the constant term and coefficients[n] is the \n-     * coefficient of x^n where n is the degree of the polynomial.\n-     */\n-    private double coefficients[];\n-\n-    /**\n-     * Interpolating points (abscissas) and the function values at these points.\n-     */\n-    private double x[], y[];\n-\n-    /**\n-     * Whether the polynomial coefficients are available.\n-     */\n-    private boolean coefficientsComputed;\n-\n-    /**\n-     * Construct a Lagrange polynomial with the given abscissas and function\n-     * values. The order of interpolating points are not important.\n-     * <p>\n-     * The constructor makes copy of the input arrays and assigns them.\n-     * \n-     * @param x interpolating points\n-     * @param y function values at interpolating points\n-     * @throws IllegalArgumentException if input arrays are not valid\n-     */\n-    PolynomialFunctionLagrangeForm(double x[], double y[]) throws\n-        IllegalArgumentException {\n-\n-        verifyInterpolationArray(x, y);\n-        this.x = new double[x.length];\n-        this.y = new double[y.length];\n-        System.arraycopy(x, 0, this.x, 0, x.length);\n-        System.arraycopy(y, 0, this.y, 0, y.length);\n-        coefficientsComputed = false;\n-    }\n-\n-    /**\n-     * Calculate the function value at the given point.\n-     *\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws FunctionEvaluationException if a runtime error occurs\n-     * @see UnivariateRealFunction#value(double)\n-     */\n-    public double value(double z) throws FunctionEvaluationException {\n-       return evaluate(x, y, z);\n-    }\n-\n-    /**\n-     * Returns the degree of the polynomial.\n-     * \n-     * @return the degree of the polynomial\n-     */\n-    public int degree() {\n-        return x.length - 1;\n-    }\n-\n-    /**\n-     * Returns a copy of the interpolating points array.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of the interpolating points array\n-     */\n-    public double[] getInterpolatingPoints() {\n-        double[] out = new double[x.length];\n-        System.arraycopy(x, 0, out, 0, x.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Returns a copy of the interpolating values array.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of the interpolating values array\n-     */\n-    public double[] getInterpolatingValues() {\n-        double[] out = new double[y.length];\n-        System.arraycopy(y, 0, out, 0, y.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Returns a copy of the coefficients array.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of the coefficients array\n-     */\n-    public double[] getCoefficients() {\n-        if (!coefficientsComputed) {\n-            computeCoefficients();\n-        }\n-        double[] out = new double[coefficients.length];\n-        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Evaluate the Lagrange polynomial using \n-     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n-     * Neville's Algorithm</a>. It takes O(N^2) time.\n-     * <p>\n-     * This function is made public static so that users can call it directly\n-     * without instantiating PolynomialFunctionLagrangeForm object.\n-     *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws FunctionEvaluationException if a runtime error occurs\n-     * @throws IllegalArgumentException if inputs are not valid\n-     */\n-    public static double evaluate(double x[], double y[], double z) throws\n-        FunctionEvaluationException, IllegalArgumentException {\n-\n-        int i, j, n, nearest = 0;\n-        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n-\n-        verifyInterpolationArray(x, y);\n-\n-        n = x.length;\n-        c = new double[n];\n-        d = new double[n];\n-        min_dist = Double.POSITIVE_INFINITY;\n-        for (i = 0; i < n; i++) {\n-            // initialize the difference arrays\n-            c[i] = y[i];\n-            d[i] = y[i];\n-            // find out the abscissa closest to z\n-            dist = Math.abs(z - x[i]);\n-            if (dist < min_dist) {\n-                nearest = i;\n-                min_dist = dist;\n-            }\n-        }\n-\n-        // initial approximation to the function value at z\n-        value = y[nearest];\n-\n-        for (i = 1; i < n; i++) {\n-            for (j = 0; j < n-i; j++) {\n-                tc = x[j] - z;\n-                td = x[i+j] - z;\n-                divider = x[j] - x[i+j];\n-                if (divider == 0.0) {\n-                    // This happens only when two abscissas are identical.\n-                    throw new FunctionEvaluationException(z, \n-                        \"Identical abscissas cause division by zero: x[\" +\n-                        i + \"] = x[\" + (i+j) + \"] = \" + x[i]);\n-                }\n-                // update the difference arrays\n-                w = (c[j+1] - d[j]) / divider;\n-                c[j] = tc * w;\n-                d[j] = td * w;\n-            }\n-            // sum up the difference terms to get the final value\n-            if (nearest < 0.5*(n-i+1)) {\n-                value += c[nearest];    // fork down\n-            } else {\n-                nearest--;\n-                value += d[nearest];    // fork up\n-            }\n-        }\n-\n-        return value;\n-    }\n-\n-    /**\n-     * Calculate the coefficients of Lagrange polynomial from the\n-     * interpolation data. It takes O(N^2) time.\n-     * <p>\n-     * Note this computation can be ill-conditioned. Use with caution\n-     * and only when it is necessary.\n-     *\n-     * @throws ArithmeticException if any abscissas coincide\n-     */\n-    protected void computeCoefficients() throws ArithmeticException {\n-        int i, j, n;\n-        double c[], tc[], d, t;\n-\n-        n = degree() + 1;\n-        coefficients = new double[n];\n-        for (i = 0; i < n; i++) {\n-            coefficients[i] = 0.0;\n-        }\n-\n-        // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n-        c = new double[n+1];\n-        c[0] = 1.0;\n-        for (i = 0; i < n; i++) {\n-            for (j = i; j > 0; j--) {\n-                c[j] = c[j-1] - c[j] * x[i];\n-            }\n-            c[0] *= (-x[i]);\n-            c[i+1] = 1;\n-        }\n-\n-        tc = new double[n];\n-        for (i = 0; i < n; i++) {\n-            // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n-            d = 1;\n-            for (j = 0; j < n; j++) {\n-                if (i != j) {\n-                    d *= (x[i] - x[j]);\n-                }\n-            }\n-            if (d == 0.0) {\n-                // This happens only when two abscissas are identical.\n-                throw new ArithmeticException\n-                    (\"Identical abscissas cause division by zero.\");\n-            }\n-            t = y[i] / d;\n-            // Lagrange polynomial is the sum of n terms, each of which is a\n-            // polynomial of degree n-1. tc[] are the coefficients of the i-th\n-            // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n-            tc[n-1] = c[n];     // actually c[n] = 1\n-            coefficients[n-1] += t * tc[n-1];\n-            for (j = n-2; j >= 0; j--) {\n-                tc[j] = c[j+1] + tc[j+1] * x[i];\n-                coefficients[j] += t * tc[j];\n-            }\n-        }\n-\n-        coefficientsComputed = true;\n-    }\n-\n-    /**\n-     * Verifies that the interpolation arrays are valid.\n-     * <p>\n-     * The interpolating points must be distinct. However it is not\n-     * verified here, it is checked in evaluate() and computeCoefficients().\n-     * \n-     * @throws IllegalArgumentException if not valid\n-     * @see #evaluate(double[], double[], double)\n-     * @see #computeCoefficients()\n-     */\n-    protected static void verifyInterpolationArray(double x[], double y[]) throws\n-        IllegalArgumentException {\n-\n-        if (x.length < 2 || y.length < 2) {\n-            throw new IllegalArgumentException\n-                (\"Interpolation requires at least two points.\");\n-        }\n-        if (x.length != y.length) {\n-            throw new IllegalArgumentException\n-                (\"Abscissa and value arrays must have the same length.\");\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * <a href=\"http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html\">\n+ * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\n+ * Analysis</b>, ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The approximated function should be smooth enough for Lagrange polynomial\n+ * to work well. Otherwise, consider using splines instead.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3965199246151093920L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Interpolating points (abscissas) and the function values at these points.\n+     */\n+    private double x[], y[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Lagrange polynomial with the given abscissas and function\n+     * values. The order of interpolating points are not important.\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.\n+     * \n+     * @param x interpolating points\n+     * @param y function values at interpolating points\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    PolynomialFunctionLagrangeForm(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        verifyInterpolationArray(x, y);\n+        this.x = new double[x.length];\n+        this.y = new double[y.length];\n+        System.arraycopy(x, 0, this.x, 0, x.length);\n+        System.arraycopy(y, 0, this.y, 0, y.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+        try {\n+            return evaluate(x, y, z);\n+        } catch (DuplicateSampleAbscissaException e) {\n+            throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return x.length - 1;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating points array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the interpolating points array\n+     */\n+    public double[] getInterpolatingPoints() {\n+        double[] out = new double[x.length];\n+        System.arraycopy(x, 0, out, 0, x.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating values array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the interpolating values array\n+     */\n+    public double[] getInterpolatingValues() {\n+        double[] out = new double[y.length];\n+        System.arraycopy(y, 0, out, 0, y.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Lagrange polynomial using \n+     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+     * Neville's Algorithm</a>. It takes O(N^2) time.\n+     * <p>\n+     * This function is made public static so that users can call it directly\n+     * without instantiating PolynomialFunctionLagrangeForm object.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws DuplicateSampleAbscissaException if the sample has duplicate abscissas\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double x[], double y[], double z) throws\n+        DuplicateSampleAbscissaException, IllegalArgumentException {\n+\n+        int i, j, n, nearest = 0;\n+        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n+\n+        verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        c = new double[n];\n+        d = new double[n];\n+        min_dist = Double.POSITIVE_INFINITY;\n+        for (i = 0; i < n; i++) {\n+            // initialize the difference arrays\n+            c[i] = y[i];\n+            d[i] = y[i];\n+            // find out the abscissa closest to z\n+            dist = Math.abs(z - x[i]);\n+            if (dist < min_dist) {\n+                nearest = i;\n+                min_dist = dist;\n+            }\n+        }\n+\n+        // initial approximation to the function value at z\n+        value = y[nearest];\n+\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                tc = x[j] - z;\n+                td = x[i+j] - z;\n+                divider = x[j] - x[i+j];\n+                if (divider == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[i], i, i+j);\n+                }\n+                // update the difference arrays\n+                w = (c[j+1] - d[j]) / divider;\n+                c[j] = tc * w;\n+                d[j] = td * w;\n+            }\n+            // sum up the difference terms to get the final value\n+            if (nearest < 0.5*(n-i+1)) {\n+                value += c[nearest];    // fork down\n+            } else {\n+                nearest--;\n+                value += d[nearest];    // fork up\n+            }\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the coefficients of Lagrange polynomial from the\n+     * interpolation data. It takes O(N^2) time.\n+     * <p>\n+     * Note this computation can be ill-conditioned. Use with caution\n+     * and only when it is necessary.\n+     *\n+     * @throws ArithmeticException if any abscissas coincide\n+     */\n+    protected void computeCoefficients() throws ArithmeticException {\n+        int i, j, n;\n+        double c[], tc[], d, t;\n+\n+        n = degree() + 1;\n+        coefficients = new double[n];\n+        for (i = 0; i < n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n+        c = new double[n+1];\n+        c[0] = 1.0;\n+        for (i = 0; i < n; i++) {\n+            for (j = i; j > 0; j--) {\n+                c[j] = c[j-1] - c[j] * x[i];\n+            }\n+            c[0] *= (-x[i]);\n+            c[i+1] = 1;\n+        }\n+\n+        tc = new double[n];\n+        for (i = 0; i < n; i++) {\n+            // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n+            d = 1;\n+            for (j = 0; j < n; j++) {\n+                if (i != j) {\n+                    d *= (x[i] - x[j]);\n+                }\n+            }\n+            if (d == 0.0) {\n+                // This happens only when two abscissas are identical.\n+                throw new ArithmeticException\n+                    (\"Identical abscissas cause division by zero.\");\n+            }\n+            t = y[i] / d;\n+            // Lagrange polynomial is the sum of n terms, each of which is a\n+            // polynomial of degree n-1. tc[] are the coefficients of the i-th\n+            // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n+            tc[n-1] = c[n];     // actually c[n] = 1\n+            coefficients[n-1] += t * tc[n-1];\n+            for (j = n-2; j >= 0; j--) {\n+                tc[j] = c[j+1] + tc[j+1] * x[i];\n+                coefficients[j] += t * tc[j];\n+            }\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the interpolation arrays are valid.\n+     * <p>\n+     * The interpolating points must be distinct. However it is not\n+     * verified here, it is checked in evaluate() and computeCoefficients().\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     * @see #evaluate(double[], double[], double)\n+     * @see #computeCoefficients()\n+     */\n+    protected static void verifyInterpolationArray(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 2 || y.length < 2) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation requires at least two points.\");\n+        }\n+        if (x.length != y.length) {\n+            throw new IllegalArgumentException\n+                (\"Abscissa and value arrays must have the same length.\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision:$\n+ */\n+public class DuplicateSampleAbscissaExceptionTest extends TestCase {\n+    \n+    public void testConstructor(){\n+        DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"1.2\") > 0);\n+        assertEquals(1.2, ex.getDuplicateAbscissa(), 0);\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}", "timestamp": 1171308436, "metainfo": ""}