{"sha": "4b1e08ea11ba68f8900b6a6f0fd423715c2c0fd9", "log": "added Cholesky decomposition  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n-    // org.apache.commons.math.random.NotPositiveDefiniteMatrixException\n+    // org.apache.commons.math.linear.NotPositiveDefiniteMatrixException\n     { \"not positive definite matrix\",\n       \"matrice non d\\u00e9finie positive\" },\n+\n+    // org.apache.commons.math.linear.NotSymmetricMatrixException\n+    { \"not symmetric matrix\",\n+      \"matrice non symm\\u00e9trique\" },\n \n     // org.apache.commons.math.fraction.FractionConversionException\n     { \"Unable to convert {0} to fraction after {1} iterations\",\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * Cholesky decomposition of a real symmetric positive-definite matrix.\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getLT() getLT} method has been added,</li>\n+ *   <li>the <code>isspd</code> method has been removed, the constructors of\n+ *   implementation classes being expected to throw {@link\n+ *   NotPositiveDefiniteMatrixException} when a matrix cannot be decomposed,</li>\n+ *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n+ *   <li>the <code>solve</code> method has been replaced by a {@link\n+ *   #getSolver() getSolver} method and the equivalent method provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface CholeskyDecomposition extends Serializable {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix\n+     */\n+    RealMatrix getL();\n+\n+    /**\n+     * Returns the transpose of the matrix L of the decomposition.\n+     * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n+     * @return the transpose of the matrix L of the decomposition\n+     */\n+    RealMatrix getLT();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+\n+/**\n+ * Calculates the Cholesky decomposition of a matrix.\n+ * <p>The Cholesky decomposition of a real symmetric positive-definite\n+ * matrix A consists of a lower triangular matrix L with same size that\n+ * satisfy: A = LL<sup>T</sup>Q = I). In a sense, this is the square root of A.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2036131698031167221L;\n+\n+    /** Default threshold above which off-diagonal elements are considered too different\n+     * and matrix not symmetric. */\n+    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n+\n+    /** Default threshold below which diagonal elements are considered null\n+     * and matrix not positive definite. */\n+    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n+\n+    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+    private double[][] lTData;\n+\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+\n+    /** Cached value of LT. */\n+    private RealMatrix cachedLT;\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * <p>\n+     * Calling this constructor is equivalent to call {@link\n+     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n+     * thresholds set to the default values {@link\n+     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n+     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n+     * </p>\n+     * @param matrix the matrix to decompose\n+     * @exception NonSquareMatrixException if matrix is not square\n+     * @exception NotSymmetricMatrixException if matrix is not symmetric\n+     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite\n+     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecompositionImpl(final RealMatrix matrix)\n+        throws NonSquareMatrixException,\n+               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n+        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n+             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n+    }\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * @param matrix the matrix to decompose\n+     * @param relativeSymmetryThreshold threshold above which off-diagonal\n+     * elements are considered too different and matrix not symmetric\n+     * @param absolutePositivityThreshold threshold below which diagonal\n+     * elements are considered null and matrix not positive definite\n+     * @exception NonSquareMatrixException if matrix is not square\n+     * @exception NotSymmetricMatrixException if matrix is not symmetric\n+     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite\n+     * @see #CholeskyDecompositionImpl(RealMatrix)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecompositionImpl(final RealMatrix matrix,\n+                                     final double relativeSymmetryThreshold,\n+                                     final double absolutePositivityThreshold)\n+        throws NonSquareMatrixException,\n+               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n+\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int order = matrix.getRowDimension();\n+        lTData   = matrix.getData();\n+        cachedL  = null;\n+        cachedLT = null;\n+\n+        // check the matrix before transformation\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] lI = lTData[i];\n+\n+            // check diagonal element\n+            if (lTData[i][i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n+\n+            // check off-diagonal elements (and reset them to 0)\n+            for (int j = i + 1; j < order; ++j) {\n+                final double[] lJ = lTData[j];\n+                final double lIJ = lI[j];\n+                final double lJI = lJ[i];\n+                final double maxDelta =\n+                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n+                if (Math.abs(lIJ - lJI) > maxDelta) {\n+                    throw new NotSymmetricMatrixException();\n+                }\n+                lJ[i] = 0;\n+           }\n+        }\n+\n+        // transform the matrix\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] ltI = lTData[i];\n+            ltI[i] = Math.sqrt(ltI[i]);\n+            final double inverse = 1.0 / ltI[i];\n+\n+            for (int q = order - 1; q > i; --q) {\n+                ltI[q] *= inverse;\n+                final double[] ltQ = lTData[q];\n+                for (int p = q; p < order; ++p) {\n+                    ltQ[p] -= ltI[q] * ltI[p];\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL() {\n+        if (cachedL == null) {\n+            cachedL = getLT().transpose();\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getLT() {\n+\n+        if (cachedLT == null) {\n+            cachedLT = MatrixUtils.createRealMatrix(lTData);\n+        }\n+\n+        // return the cached matrix\n+        return cachedLT;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant() {\n+        double determinant = 1.0;\n+        for (int i = 0; i < lTData.length; ++i) {\n+            double lTii = lTData[i][i];\n+            determinant *= lTii * lTii;\n+        }\n+        return determinant;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lTData);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -7288829864732555901L;\n+\n+        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+        private final double[][] lTData;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lData row-oriented storage for L<sup>T</sup> matrix data\n+         */\n+        private Solver(final double[][] lTData) {\n+            this.lTData = lTData;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            // if we get this far, the matrix was positive definite, hence non-singular\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = lTData.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        new Object[] { b.length, m });\n+            }\n+\n+            final double[] x = b.clone();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                x[j] /= lJ[j];\n+                final double xJ = x[j];\n+                for (int i = j + 1; i < m; i++) {\n+                    x[i] -= xJ * lJ[i];\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                x[j] /= lTData[j][j];\n+                final double xJ = x[j];\n+                for (int i = 0; i < j; i++) {\n+                    x[i] -= xJ * lTData[i][j];\n+                }\n+            }\n+\n+            return x;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((RealVectorImpl) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = lTData.length;\n+                if (b.getDimension() != m) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"vector length mismatch: got {0} but expected {1}\",\n+                            new Object[] { b.getDimension(), m });\n+                }\n+\n+                final double[] x = b.getData();\n+\n+                // Solve LY = b\n+                for (int j = 0; j < m; j++) {\n+                    final double[] lJ = lTData[j];\n+                    x[j] /= lJ[j];\n+                    final double xJ = x[j];\n+                    for (int i = j + 1; i < m; i++) {\n+                        x[i] -= xJ * lJ[i];\n+                    }\n+                }\n+\n+                // Solve LTX = Y\n+                for (int j = m - 1; j >= 0; j--) {\n+                    x[j] /= lTData[j][j];\n+                    final double xJ = x[j];\n+                    for (int i = 0; i < j; i++) {\n+                        x[i] -= xJ * lTData[i][j];\n+                    }\n+                }\n+\n+                return new RealVectorImpl(x, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVectorImpl solve(RealVectorImpl b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            return new RealVectorImpl(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = lTData.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        new Object[] { b.getRowDimension(), b.getColumnDimension(), m, \"n\"});\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            double[][] x = b.getData();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                final double lJJ = lJ[j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = j + 1; i < m; i++) {\n+                    final double[] xI = x[i];\n+                    final double lJI = lJ[i];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lJI;\n+                    }\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                final double lJJ = lTData[j][j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = 0; i < j; i++) {\n+                    final double[] xI = x[i];\n+                    final double lIJ = lTData[i][j];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lIJ;\n+                    }\n+                }\n+            }\n+\n+            return new RealMatrixImpl(x, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() throws InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** \n+ * This class represents exceptions thrown when a matrix expected to\n+ * be symmetric is not\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class NotSymmetricMatrixException extends MathException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7012803946709786097L;\n+\n+    /** Simple constructor.\n+     * build an exception with a default message.\n+     */\n+    public NotSymmetricMatrixException() {\n+        super(\"not symmetric matrix\", null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class CholeskyDecompositionImplTest extends TestCase {\n+\n+    private double[][] testData = new double[][] {\n+            {  1,  2,   4,   7,  11 },\n+            {  2, 13,  23,  38,  58 },\n+            {  4, 23,  77, 122, 182 },\n+            {  7, 38, 122, 294, 430 },\n+            { 11, 58, 182, 430, 855 }\n+    };\n+\n+    public CholeskyDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CholeskyDecompositionImplTest.class);\n+        suite.setName(\"CholeskyDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() throws MathException {\n+        CholeskyDecomposition llt =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+        assertEquals(testData.length, llt.getL().getRowDimension());\n+        assertEquals(testData.length, llt.getL().getColumnDimension());\n+        assertEquals(testData.length, llt.getLT().getRowDimension());\n+        assertEquals(testData.length, llt.getLT().getColumnDimension());\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n+        } catch (NonSquareMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test non-symmetric matrix */\n+    public void testNotSymmetricMatrixException() {\n+        try {\n+            double[][] changed = testData.clone();\n+            changed[0][changed[0].length - 1] += 1.0e-5;\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));\n+        } catch (NotSymmetricMatrixException e) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test non positive definite matrix */\n+    public void testNotPositiveDefinite() {\n+        try {\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n+                    { 14, 11, 13, 15, 24 },\n+                    { 11, 34, 13, 8,  25 },\n+                    { 13, 13, 14, 15, 21 },\n+                    { 15, 8,  15, 18, 23 },\n+                    { 24, 25, 21, 23, 45 }\n+            }));\n+        } catch (NotPositiveDefiniteMatrixException e) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test A = LLT */\n+    public void testAEqualLLT() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.multiply(lt).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test that L is lower triangular */\n+    public void testLLowerTriangular() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(0.0, l.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that LT is transpose of L */\n+    public void testLTTransposed() throws MathException {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);\n+        RealMatrix l  = llt.getL();\n+        RealMatrix lt = llt.getLT();\n+        double norm = l.subtract(lt.transpose()).getNorm();\n+        assertEquals(0, norm, 1.0e-15);\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues() throws MathException {\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {  1,  0,  0,  0,  0 },\n+                {  2,  3,  0,  0,  0 },\n+                {  4,  5,  6,  0,  0 },\n+                {  7,  8,  9, 10,  0 },\n+                { 11, 12, 13, 14, 15 }\n+        });\n+       CholeskyDecomposition llt =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));\n+\n+        // check values against known references\n+        RealMatrix l = llt.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix lt = llt.getLT();\n+        assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l  == llt.getL());\n+        assertTrue(lt == llt.getLT());\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/CholeskySolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.MathException;\n+\n+public class CholeskySolverTest extends TestCase {\n+\n+    private double[][] testData = new double[][] {\n+            {  1,  2,   4,   7,  11 },\n+            {  2, 13,  23,  38,  58 },\n+            {  4, 23,  77, 122, 182 },\n+            {  7, 38, 122, 294, 430 },\n+            { 11, 58, 182, 430, 855 }\n+    };\n+\n+    public CholeskySolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CholeskySolverTest.class);\n+        suite.setName(\"LUSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() throws MathException {\n+        DecompositionSolver solver =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() throws MathException {\n+        DecompositionSolver solver =\n+            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                {   78,  -13,    1 },\n+                {  414,  -62,   -1 },\n+                { 1312, -202,  -37 },\n+                { 2989, -542,  145 },\n+                { 5510, -1465, 201 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1,  0,  1 },\n+                { 0,  1,  1 },\n+                { 2,  1, -4 },\n+                { 2,  2,  2 },\n+                { 5, -3,  0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() throws MathException {\n+        assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);\n+    }\n+\n+    private double getDeterminant(RealMatrix m) throws MathException {\n+        return new CholeskyDecompositionImpl(m).getDeterminant();\n+    }\n+\n+}", "timestamp": 1234720412, "metainfo": ""}