{"sha": "2f90cfdde4bbed36a9d6acdba15bd7b88d058050", "log": "MATH-899 Fixed copy/paste bug.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n      * {@inheritDoc}\n      */\n     public synchronized int nextInt(int n) {\n-        return wrapped.nextInt();\n+        return wrapped.nextInt(n);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/random/SynchronizedRandomGeneratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.random;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class SynchronizedRandomGeneratorTest {\n+    private final int numberOfThreads = 5;\n+    private final int numberOfGenerators = 5;\n+    private final int numberOfSamples = 100000;\n+\n+    @Test\n+    public void testAdapter() {\n+        final int seed = 12345;\n+        final RandomGenerator orig = new MersenneTwister(seed);\n+        final RandomGenerator wrap\n+            = new SynchronizedRandomGenerator(new MersenneTwister(seed));\n+\n+        final int bSize = 67;\n+        final byte[] bOrig = new byte[bSize];\n+        final byte[] bWrap = new byte[bSize];\n+\n+        for (int i = 0; i < 100; i++) {\n+            orig.nextBytes(bOrig);\n+            wrap.nextBytes(bWrap);\n+            for (int k = 0; k < bSize; k++) {\n+                Assert.assertEquals(bOrig[k], bWrap[k]);\n+            }\n+\n+            Assert.assertEquals(orig.nextInt(), wrap.nextInt());\n+\n+            final int range = (i + 1) * 89;\n+            Assert.assertEquals(orig.nextInt(range), wrap.nextInt(range));\n+\n+            Assert.assertEquals(orig.nextLong(), wrap.nextLong());\n+            Assert.assertEquals(orig.nextBoolean(), wrap.nextBoolean());\n+            Assert.assertEquals(orig.nextFloat(), wrap.nextFloat(), 0);\n+            Assert.assertEquals(orig.nextDouble(), wrap.nextDouble(), 0);\n+            Assert.assertEquals(orig.nextGaussian(), wrap.nextGaussian(), 0);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testMath899Sync() throws Throwable {\n+        double[] v = null;\n+        try {\n+            // Running the test several times in order to decrease the\n+            // probability that a non-thread-safe code did not trigger\n+            // a concurrency problem.\n+            for (int i = 0; i < 10; i++) {\n+                v = doTestMath899(true, numberOfThreads, numberOfGenerators, numberOfSamples);\n+            }\n+        } catch (InterruptedException e) {\n+            Assert.fail(e.getMessage());\n+        } catch (ExecutionException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    /**\n+     * @param sync Whether to use a synchronizing wrapper.\n+     */\n+    private double[] doTestMath899(final boolean sync,\n+                                   final int numThreads,\n+                                   final int numGenerators,\n+                                   final int numSamples)\n+        throws InterruptedException,\n+               ExecutionException {\n+        final RandomGenerator rng = new MersenneTwister();\n+        final RandomGenerator wrapper = sync ? new SynchronizedRandomGenerator(rng) : rng;\n+\n+        final List<Callable<Double>> tasks = new ArrayList<Callable<Double>>();\n+        for (int i = 0; i < numGenerators; i++) {\n+            tasks.add(new Callable<Double>() {\n+                    public Double call() {\n+                        Double lastValue = 0d;\n+                        for (int j = 0; j < numSamples; j++) {\n+                            lastValue = wrapper.nextGaussian();\n+                        }\n+                        return lastValue;\n+                    }\n+                });\n+        }\n+\n+        final ExecutorService exec = Executors.newFixedThreadPool(numThreads);\n+        final List<Future<Double>> results = exec.invokeAll(tasks);\n+\n+        final double[] values = new double[numGenerators];\n+        for (int i = 0; i < numGenerators; i++) {\n+            values[i] = results.get(i).get();\n+        }\n+        return values;\n+    }\n+}", "timestamp": 1353278885, "metainfo": ""}