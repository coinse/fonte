{"sha": "b4dc65be701ab2e5d8d69c2bd7f0c5a1f5fab47f", "log": "Added expm1 and log1p to DSCompiler and DerivativeStructure.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n \n     }\n \n+    /** Compute exp(x) - 1 of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * exponential the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void expm1(final double[] operand, final int operandOffset,\n+                      final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.expm1(operand[operandOffset]);\n+        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n     /** Compute natural logarithm of a derivative structure.\n      * @param operand array holding the operand\n      * @param operandOffset offset of the operand in its array\n         function[0] = FastMath.log(operand[operandOffset]);\n         if (order > 0) {\n             double inv = 1.0 / operand[operandOffset];\n+            double xk  = inv;\n+            for (int i = 1; i <= order; ++i) {\n+                function[i] = xk;\n+                xk *= -i * inv;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Computes of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * logarithm the result array <em>cannot</em> be the input\n+     * array)\n+     */\n+    public void log1p(final double[] operand, final int operandOffset,\n+                      final double[] result, final int resultOffset) {\n+        \n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.log1p(operand[operandOffset]);\n+        if (order > 0) {\n+            double inv = 1.0 / (1.0 + operand[operandOffset]);\n             double xk  = inv;\n             for (int i = 1; i <= order; ++i) {\n                 function[i] = xk;\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n         return result;\n     }\n \n+    /** Exponential minus 1.\n+     * @return exponential minus one of the instance\n+     */\n+    public DerivativeStructure expm1() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.expm1(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n     /** Natural logarithm.\n      * @return logarithm of the instance\n      */\n     public DerivativeStructure log() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Shifted natural logarithm.\n+     * @return logarithm of one plus the instance\n+     */\n+    public DerivativeStructure log1p() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.log1p(data, 0, result.data, 0);\n         return result;\n     }\n \n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testExpm1Definition() {\n+        double epsilon = 3.0e-16;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure expm11 = dsX.expm1();\n+                DerivativeStructure expm12 = dsX.exp().subtract(dsX.getField().getOne());\n+                DerivativeStructure zero = expm11.subtract(expm12);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testLog() {\n         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n     }\n \n     @Test\n+    public void testLog1pDefinition() {\n+        double epsilon = 3.0e-16;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure log1p1 = dsX.log1p();\n+                DerivativeStructure log1p2 = dsX.add(dsX.getField().getOne()).log();\n+                DerivativeStructure zero = log1p1.subtract(log1p2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testLogExp() {\n         double[] epsilon = new double[] { 2.0e-16, 2.0e-16, 3.0e-16, 2.0e-15, 6.0e-15 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n             for (double x = 0.1; x < 1.2; x += 0.001) {\n                 DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n                 DerivativeStructure rebuiltX = dsX.exp().log();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLog1pExpm1() {\n+        double[] epsilon = new double[] { 6.0e-17, 3.0e-16, 5.0e-16, 9.0e-16, 6.0e-15 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.expm1().log1p();\n                 DerivativeStructure zero = rebuiltX.subtract(dsX);\n                 for (int n = 0; n <= maxOrder; ++n) {\n                     Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);", "timestamp": 1345111628, "metainfo": ""}