{"sha": "b2d25e07988b85fe3dee62ffaa7586144eb44535", "log": "added support for max number of evaluations to ODE integrators  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import java.util.Collection;\n import java.util.Collections;\n \n+import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.events.EventState;\n     /** Name of the method. */\n     private final String name;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /** Differential equations to integrate. */\n+    private transient FirstOrderDifferentialEquations equations;\n+\n     /** Step handler. */\n     protected Collection<StepHandler> stepHandlers;\n \n         stepStart = Double.NaN;\n         stepSize  = Double.NaN;\n         eventsHandlersManager = new CombinedEventsManager();\n+        setMaxEvaluations(-1);\n+        resetEvaluations();\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public double getCurrentSignedStepsize() {\n         return stepSize;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** Reset the number of evaluations to zero.\n+     */\n+    protected void resetEvaluations() {\n+        evaluations = 0;\n+    }\n+\n+    /** Set the differential equations.\n+     * @see #computeDerivatives(double, double[], double[])\n+     */\n+    protected void setEquations(final FirstOrderDifferentialEquations equations) {\n+        this.equations = equations;\n+    }\n+\n+    /** Compute the derivatives and check the number of evaluations.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+        throws DerivativeException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+        }\n+        equations.computeDerivatives(t, y, yDot);\n     }\n \n     /** Perform some sanity checks on the integration parameters.\n--- a/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n      */\n     protected double start(final int n, final double h,\n                            final CombinedEventsManager manager,\n-                           final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y)\n         throws DerivativeException, IntegratorException {\n \n         // integrate over the first few steps, ensuring no intermediate reset occurs\n         double t = t0;\n         double stopTime = Double.NaN;\n+        FirstOrderDifferentialEquations equations =\n+            new CountingDifferentialEquations(y.length);\n         do {\n             resetTime = Double.NaN;\n             final double dt = (n - 0.9999) * h;\n \n     }\n \n+    /** Wrapper for differential equations, ensuring start evaluations are counted. */\n+    private class CountingDifferentialEquations implements FirstOrderDifferentialEquations {\n+\n+        /** Serializable uid. */\n+        private static final long serialVersionUID = -6329212616396607764L;\n+\n+        /** Dimension of the problem. */\n+        private final int dimension;\n+\n+        /** Simple constructor.\n+         * @param dimension dimension of the problem\n+         */\n+        public CountingDifferentialEquations(final int dimension) {\n+            this.dimension = dimension;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(double t, double[] y, double[] dot)\n+                throws DerivativeException {\n+            MultistepIntegrator.this.computeDerivatives(t, y, dot);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return dimension;\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/ode/ODEIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/ODEIntegrator.java\n      */\n     double getCurrentSignedStepsize();\n \n+    /** Set the maximal number of differential equations function evaluations.\n+     * <p>The purpose of this method is to avoid infinite loops which can occur\n+     * for example when stringent error constraints are set or when lots of\n+     * discrete events are triggered, thus leading to many rejected steps.</p>\n+     * @param maxEvaluations maximal number of function evaluations (negative\n+     * values are silently converted to maximal integer value, thus representing\n+     * almost unlimited evaluations)\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the differential equations function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * <code>integrate</code> method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the differential equations function\n+     */\n+    int getEvaluations();\n+\n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n         final int n = y0.length;\n         sanityChecks(equations, t0, y0, t, y);\n+        setEquations(equations);\n+        resetEvaluations();\n         final boolean forward = (t > t0);\n \n         // initialize working arrays\n         CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n \n         // compute the first few steps using the configured starter integrator\n-        double stopTime =\n-            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        double stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n         if (Double.isNaN(previousT[0])) {\n             return stopTime;\n         }\n             // update the Nordsieck vector\n             final double[] f0 = previousF[0];\n             previousT[0] = nextStep;\n-            equations.computeDerivatives(nextStep, y, f0);\n+            computeDerivatives(nextStep, y, f0);\n             nordsieck = coefficients.msUpdate.multiply(nordsieck);\n             final double[] end = new double[y0.length];\n             for (int j = 0; j < y0.length; ++j) {\n \n                 // some events handler has triggered changes that\n                 // invalidate the derivatives, we need to restart from scratch\n-                stopTime =\n-                    start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n                 if (Double.isNaN(previousT[0])) {\n                     return stopTime;\n                 }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n \n         final int n = y0.length;\n         sanityChecks(equations, t0, y0, t, y);\n+        setEquations(equations);\n+        resetEvaluations();\n         final boolean forward = (t > t0);\n \n         // initialize working arrays\n         CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n \n         // compute the first few steps using the configured starter integrator\n-        double stopTime =\n-            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        double stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n         if (Double.isNaN(previousT[0])) {\n             return stopTime;\n         }\n                 // evaluate a first estimate of the derivative (first E in the PECE sequence)\n                 final double[] f0 = previousF[0];\n                 previousT[0] = stepEnd;\n-                equations.computeDerivatives(stepEnd, yTmp, f0);\n+                computeDerivatives(stepEnd, yTmp, f0);\n \n                 // update Nordsieck vector\n                 final RealMatrix nordsieckTmp = coefficients.msUpdate.multiply(nordsieck);\n                 nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n \n                 // evaluate a final estimate of the derivative (second E in the PECE sequence)\n-                equations.computeDerivatives(stepEnd, yTmp, f0);\n+                computeDerivatives(stepEnd, yTmp, f0);\n \n                 // update Nordsieck vector\n                 final double[] correctedScaled = new double[y0.length];\n \n                 // some events handler has triggered changes that\n                 // invalidate the derivatives, we need to restart from scratch\n-                stopTime =\n-                    start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                stopTime = start(previousF.length, stepSize, manager, stepStart, y);\n                 if (Double.isNaN(previousT[0])) {\n                     return stopTime;\n                 }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n     for (int j = 0; j < y0.length; ++j) {\n       y1[j] = y0[j] + h * yDot0[j];\n     }\n-    equations.computeDerivatives(t0 + h, y1, yDot1);\n+    computeDerivatives(t0 + h, y1, yDot1);\n \n     // estimate the second derivative of the solution\n     double yDDotOnScale = 0;\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n+import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n \n   /** {@inheritDoc} */\n   @Override\n-  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+  public void reinitialize(final AbstractIntegrator integrator,\n                            final double[] y, final double[][] yDotK, final boolean forward) {\n-    super.reinitialize(equations, y, yDotK, forward);\n+    super.reinitialize(integrator, y, yDotK, forward);\n     v1 = null;\n     v2 = null;\n     v3 = null;\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectOutput;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n \n   /** {@inheritDoc} */\n   @Override\n-  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+  public void reinitialize(final AbstractIntegrator integrator,\n                            final double[] y, final double[][] yDotK, final boolean forward) {\n \n-    super.reinitialize(equations, y, yDotK, forward);\n+    super.reinitialize(integrator, y, yDotK, forward);\n \n     final int dimension = currentState.length;\n \n           k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+    integrator.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n \n     // k15\n     for (int j = 0; j < currentState.length; ++j) {\n          k15_14 * yDotKLast[0][j];\n      yTmp[j] = currentState[j] + h * s;\n     }\n-    equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+    integrator.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n \n     // k16\n     for (int j = 0; j < currentState.length; ++j) {\n           k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+    integrator.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n   throws DerivativeException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n     final boolean forward = (t > t0);\n \n     // create some internal working arrays\n     AbstractStepInterpolator interpolator;\n     if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n-      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n       interpolator = new DummyStepInterpolator(yTmp, forward);\n \n         if (firstTime || !fsal) {\n           // first stage\n-          equations.computeDerivatives(stepStart, y, yDotK[0]);\n+          computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n             yTmp[j] = y[j] + stepSize * sum;\n           }\n \n-          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n \n         }\n \n       if (manager.reset(stepStart, y) && ! lastStep) {\n         // some event handler has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n-        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        computeDerivatives(stepStart, y, yDotK[0]);\n       }\n \n       if (! lastStep) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n \n   /** Perform integration over one step using substeps of a modified\n    * midpoint method.\n-   * @param equations differential equations to integrate\n    * @param t0 initial time\n    * @param y0 initial value of the state vector at t0\n    * @param step global step\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n-  private boolean tryStep(final FirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] y0, final double step, final int k,\n+  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                           final double[] scale, final double[][] f,\n                           final double[] yMiddle, final double[] yEnd,\n                           final double[] yTmp)\n       yTmp[i] = y0[i];\n       yEnd[i] = y0[i] + subStep * f[0][i];\n     }\n-    equations.computeDerivatives(t, yEnd, f[1]);\n+    computeDerivatives(t, yEnd, f[1]);\n \n     // other substeps\n     for (int j = 1; j < n; ++j) {\n         yTmp[i]       = middle;\n       }\n \n-      equations.computeDerivatives(t, yEnd, f[j+1]);\n+      computeDerivatives(t, yEnd, f[j+1]);\n \n       // stability check\n       if (performTest && (j <= maxChecks) && (k < maxIter)) {\n   throws DerivativeException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n     final boolean forward = (t > t0);\n \n     // create some internal working arrays\n \n         // first evaluation, at the beginning of the step\n         if (! firstStepAlreadyComputed) {\n-          equations.computeDerivatives(stepStart, y, yDot0);\n+          computeDerivatives(stepStart, y, yDot0);\n         }\n \n         if (firstTime) {\n         ++k;\n \n         // modified midpoint integration with the current substep\n-        if ( ! tryStep(equations, stepStart, y, stepSize, k, scale, fk[k],\n+        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                        (k == 0) ? yMidDots[0] : diagonal[k-1],\n                        (k == 0) ? y1 : y1Diag[k-1],\n                        yTmp)) {\n         }\n \n         // derivative at end of step\n-        equations.computeDerivatives(stepStart + stepSize, y1, yDot1);\n+        computeDerivatives(stepStart + stepSize, y1, yDot1);\n \n         final int mu = 2 * k - mudif + 3;\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n   throws DerivativeException, IntegratorException {\n \n     sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n     final boolean forward = (t > t0);\n \n     // create some internal working arrays\n     AbstractStepInterpolator interpolator;\n     if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n-      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n       interpolator = new DummyStepInterpolator(yTmp, forward);\n       for (boolean loop = true; loop;) {\n \n         // first stage\n-        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        computeDerivatives(stepStart, y, yDotK[0]);\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n             yTmp[j] = y[j] + stepSize * sum;\n           }\n \n-          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n \n         }\n \n       if (manager.reset(stepStart, y) && ! lastStep) {\n         // some events handler has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n-        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        computeDerivatives(stepStart, y, yDotK[0]);\n       }\n \n       // make sure step size is set to default before next step\n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n \n /** This class represents an interpolator over the last step during an\n    */\n   protected RungeKuttaStepInterpolator() {\n     super();\n-    yDotK     = null;\n-    equations = null;\n+    yDotK      = null;\n+    integrator = null;\n   }\n \n   /** Copy constructor.\n \n     // we cannot keep any reference to the equations in the copy\n     // the interpolator should have been finalized before\n-    equations = null;\n+    integrator = null;\n \n   }\n \n    * {@link AbstractStepInterpolator#getInterpolatedState\n    * getInterpolatedState} method (for an interpolator which needs a\n    * finalization) or if it clones the step interpolator.</p>\n-   * @param equations set of differential equations being integrated\n+   * @param integrator integrator being used\n    * @param y reference to the integrator array holding the state at\n    * the end of the step\n    * @param yDotK reference to the integrator array holding all the\n    * intermediate slopes\n    * @param forward integration direction indicator\n    */\n-  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+  public void reinitialize(final AbstractIntegrator integrator,\n                            final double[] y, final double[][] yDotK, final boolean forward) {\n     reinitialize(y, forward);\n     this.yDotK = yDotK;\n-    this.equations = equations;\n+    this.integrator = integrator;\n   }\n \n   /** {@inheritDoc} */\n       }\n     }\n \n-    equations = null;\n+    integrator = null;\n \n     if (currentState != null) {\n         // we can now set the interpolated time and state\n   /** Slopes at the intermediate points */\n   protected double[][] yDotK;\n \n-  /** Reference to the differential equations being integrated. */\n-  protected FirstOrderDifferentialEquations equations;\n+  /** Reference to the integrator. */\n+  protected AbstractIntegrator integrator;\n \n }\n--- a/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n \n package org.apache.commons.math.ode.sampling;\n \n+import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n-import java.io.IOException;\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.ode.DerivativeException;\n \n    * @throws DerivativeException this exception is propagated to the\n    * caller if the underlying user function triggers one\n-\n    */\n   public final void finalizeStep()\n     throws DerivativeException {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n         assertTrue(handler.getMaximalValueError() < 9.0e-9);\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n         assertEquals(\"Adams-Bashforth\", integ.getName());\n+        assertTrue(integ.getEvaluations() > 1000);\n+        assertEquals(Integer.MAX_VALUE, integ.getMaxEvaluations());\n+\n+    }\n+\n+    @Test(expected = DerivativeException.class)\n+    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double range = pb.getFinalTime() - pb.getInitialTime();\n+        double step = range * 0.001;\n+\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.setMaxEvaluations(1000);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n \n     }\n \n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         ObjectOutputStream    oos = new ObjectOutputStream(bos);\n         oos.writeObject(new AdamsBashforthIntegrator(8, step));\n-        assertTrue(bos.size() > 2800);\n-        assertTrue(bos.size() < 2900);\n+        assertTrue(bos.size() > 2900);\n+        assertTrue(bos.size() < 3000);\n \n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         ObjectOutputStream    oos = new ObjectOutputStream(bos);\n         oos.writeObject(new AdamsMoultonIntegrator(8, step));\n-        assertTrue(bos.size() > 2800);\n-        assertTrue(bos.size() < 2900);\n+        assertTrue(bos.size() > 2900);\n+        assertTrue(bos.size() < 3000);\n \n         ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n         ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n       assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n     assertTrue(pb.getCalls() < 2800);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n       assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n     assertTrue(pb.getCalls() < 3300);\n \n   }\n                     pb1.getInitialTime(), pb1.getInitialState(),\n                     pb1.getFinalTime(), new double[pb1.getDimension()]);\n     int callsWithoutDenseOutput = pb1.getCalls();\n+    assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);\n \n     integ.addStepHandler(new InterpolatingStepHandler());\n     integ.integrate(pb2,\n                     pb2.getInitialTime(), pb2.getInitialState(),\n                     pb2.getFinalTime(), new double[pb2.getDimension()]);\n     int callsWithDenseOutput = pb2.getCalls();\n+    assertEquals(integ.getEvaluations(), callsWithDenseOutput);\n \n     assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n     interpolator.storeTime(0);\n     interpolator.shift();\n     interpolator.storeTime(1);\n     double[] y = y0.clone();\n     double[][] yDot = { new double[y0.length] };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n     interpolator.storeTime(t0);\n \n     double dt = 1.0;\n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n     interpolator.storeTime(0);\n     interpolator.shift();\n     interpolator.storeTime(1);\n \n   }\n \n-  private static class DummyEquations\n-    implements FirstOrderDifferentialEquations {\n-    private static final long serialVersionUID = 291437140744677100L;\n-    public int getDimension() {\n-      return 0;\n-    }\n-    public void computeDerivatives(double t, double[] y, double[] yDot) {\n-    }\n+  private static class DummyIntegrator extends RungeKuttaIntegrator {\n+\n+      private static final long serialVersionUID = -6936405965711773334L;\n+\n+      protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {\n+          super(\"dummy\", new double[0], new double[0][0], new double[0], prototype, Double.NaN);\n+      }\n+\n   }\n \n }\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n       assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n \n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n+    assertEquals(integ.getEvaluations(), pb.getCalls());\n     assertTrue(pb.getCalls() < 2150);\n \n   }\n--- a/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n       assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n \n       int calls = pb.getCalls();\n+      assertEquals(integ.getEvaluations(), calls);\n       assertTrue(calls <= previousCalls);\n       previousCalls = calls;\n ", "timestamp": 1244575999, "metainfo": ""}