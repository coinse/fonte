{"sha": "7f9c5b6c89e858024f1b3ad72059e76661d300fd", "log": "fixed javadoc, checkstyle and findbugs warnings  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/MathParseException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathParseException.java\n  */\n package org.apache.commons.math.exception;\n \n+import org.apache.commons.math.exception.util.ExceptionContextProvider;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.util.ExceptionContext;\n-import org.apache.commons.math.exception.util.ExceptionContextProvider;\n \n /**\n  * Class to signal parse failures.\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n \n     /**\n      * <p>\n-     * Subtracts the value of a {@code long} from the value of this \n+     * Subtracts the value of a {@code long} from the value of this\n      * {@code BigFraction}, returning the result in reduced form.\n      * </p>\n      *\n      * @param l the {@code long} to subtract.\n-     * @return a {@ code BigFraction} instance with the resulting values.\n+     * @return a {@code BigFraction} instance with the resulting values.\n      */\n     public BigFraction subtract(final long l) {\n         return subtract(BigInteger.valueOf(l));\n--- a/src/main/java/org/apache/commons/math/geometry/VectorFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/VectorFormat.java\n  * returned. In the second case, however, the parse position after parsing will be\n  * just after the closing curly brace, i.e. just before the trailing space.</p>\n  *\n- * @version $Id:$\n+ * @param <S> Type of the space.\n+ * @version $Id$\n  * @since 3.0\n  */\n public abstract class VectorFormat<S extends Space> {\n      * @throws MathParseException if the beginning of the specified string\n      * cannot be parsed.\n      */\n-    public abstract Vector<S> parse(String source);\n+    public abstract Vector<S> parse(String source) throws MathParseException;\n \n     /**\n      * Parses a string to produce a {@link Vector} object.\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n \n import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n-import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n \n /** This class represents a 1D region: a set of intervals.\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n      * boundary does not really separate an inside open from an outside\n      * open (open having here its topological meaning), then subsequent\n      * calls to the {@link\n-     * Region#checkPoint(org.apache.commons.math.geometry.partitioning.Point)\n+     * org.apache.commons.math.geometry.partitioning.Region#checkPoint(org.apache.commons.math.geometry.Vector)\n      * checkPoint} method will not be meaningful anymore.</p>\n      * <p>If the boundary is empty, the region will represent the whole\n      * space.</p>\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/OrientedPoint.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/OrientedPoint.java\n \n import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.geometry.partitioning.Hyperplane;\n-import org.apache.commons.math.geometry.partitioning.Region;\n-import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n \n /** This class represents a 1D oriented hyperplane.\n  * <p>An hyperplane in 1D is a simple point, its orientation being a\n  * boolean.</p>\n  * <p>Instances of this class are guaranteed to be immutable.</p>\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class OrientedPoint implements Hyperplane<Euclidean1D> {\n     /** Build a region covering the whole hyperplane.\n      * <p>Since this class represent zero dimension spaces which does\n      * not have lower dimension sub-spaces, this method returns a dummy\n-     * implementation of a {@link Region Region} (always the same\n-     * instance). This implementation is only used to allow the {@link\n-     * SubHyperplane SubHyperplane} class implementation to work\n-     * properly, it should <em>not</em> be used otherwise.</p>\n+     * implementation of a {@link\n+     * org.apache.commons.math.geometry.partitioning.Region Region}\n+     * (always the same instance). This implementation is only used to\n+     * allow the {@link\n+     * org.apache.commons.math.geometry.partitioning.SubHyperplane\n+     * SubHyperplane} class implementation to work properly, it should\n+     * <em>not</em> be used otherwise.</p>\n      * @return a dummy region\n      */\n     public SubOrientedPoint wholeHyperplane() {\n         return new IntervalsSet();\n     }\n \n-    /** Check if the instance has the same orientation as another hyperplane.\n-     * <p>This method is expected to be called on parallel hyperplanes\n-     * (i.e. when the {@link #side side} method would return {@link\n-     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER}\n-     * for some sub-hyperplane having the specified hyperplane\n-     * as its underlying hyperplane). The method should <em>not</em>\n-     * re-check for parallelism, only for orientation, typically by\n-     * testing something like the sign of the dot-products of\n-     * normals.</p>\n-     * @param other other hyperplane to check against the instance\n-     * @return true if the instance and the other hyperplane have\n-     * the same orientation\n-     */\n+    /** {@inheritDoc} */\n     public boolean sameOrientationAs(final Hyperplane<Euclidean1D> other) {\n         return !(direct ^ ((OrientedPoint) other).direct);\n     }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/SubOrientedPoint.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/SubOrientedPoint.java\n import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.Side;\n \n-/** This class represents sub-hyperplane for {@link OrOrientedPoint}.\n+/** This class represents sub-hyperplane for {@link OrientedPoint}.\n  * <p>An hyperplane in 1D is a simple point, its orientation being a\n  * boolean.</p>\n  * <p>Instances of this class are guaranteed to be immutable.</p>\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class SubOrientedPoint extends AbstractSubHyperplane<Euclidean1D, Euclidean1D> {\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Line.java\n  * left half plane is the set of points with negative offsets and the\n  * right half plane is the set of points with positive offsets.</p>\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class Line implements Hyperplane<Euclidean2D>, Embedding<Euclidean2D, Euclidean1D> {\n      * @param line line to check\n      * @return offset of the line\n      */\n-    public double getOffset(final Hyperplane<Euclidean2D> hyperplane) {\n-        Line line = (Line) hyperplane;\n+    public double getOffset(final Line line) {\n         return originOffset +\n                ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n     }\n \n-    /** Get the offset (oriented distance) of a point to the line.\n-     * <p>The offset is 0 if the point belongs to the line, it is\n-     * positive if the point is on the right side of the line and\n-     * negative if it is on the left side, according to its natural\n-     * orientation.</p>\n-     * @param point point to check (must be a {@link Vector2D Vector2D} instance)\n-     * @return offset of the point\n-     */\n+    /** {@inheritDoc} */\n     public double getOffset(final Vector<Euclidean2D> point) {\n         Vector2D p2 = (Vector2D) point;\n         return sin * p2.getX() - cos * p2.getY() + originOffset;\n     }\n \n-    /** Check if the instance has the same orientation as another hyperplane.\n-     * <p>This method is expected to be called on parallel hyperplanes\n-     * (i.e. when the {@link #side side} method would return {@link\n-     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n-     * for some sub-hyperplane having the specified hyperplane\n-     * as its underlying hyperplane). The method should <em>not</em>\n-     * re-check for parallelism, only for orientation, typically by\n-     * testing something like the sign of the dot-products of\n-     * normals.</p>\n-     * @param other other hyperplane to check against the instance\n-     * @return true if the instance and the other hyperplane have\n-     * the same orientation\n-     */\n+    /** {@inheritDoc} */\n     public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) {\n         final Line otherL = (Line) other;\n         return (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/NestedLoops.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/NestedLoops.java\n  * internal loops is computed as the reverse of the orientation of\n  * their immediate surrounding loop.</p>\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n class NestedLoops {\n             final Vector2D previous = current;\n             current = loop[i];\n             final Line   line   = new Line(previous, current);\n-            final IntervalsSet region = \n+            final IntervalsSet region =\n                 new IntervalsSet(line.toSubSpace(previous).getX(), line.toSubSpace(current).getX());\n             edges.add(new SubLine(line, region));\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.BSPTree;\n-import org.apache.commons.math.geometry.partitioning.Region;\n import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math.geometry.partitioning.AbstractRegion;\n import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represents a 2D region: a set of polygons.\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n      * boundary does not really separate an inside open from an outside\n      * open (open having here its topological meaning), then subsequent\n      * calls to the {@link\n-     * Region#checkPoint(org.apache.commons.math.geometry.partitioning.Point)\n+     * org.apache.commons.math.geometry.partitioning.Region#checkPoint(org.apache.commons.math.geometry.Vector)\n      * checkPoint} method will not be meaningful anymore.</p>\n      * <p>If the boundary is empty, the region will represent the whole\n      * space.</p>\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n  * @param <S> Type of the space.\n  * @param <T> Type of the sub-space.\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public abstract class AbstractRegion<S extends Space, T extends Space> implements Region<S> {\n \n     /** {@inheritDoc} */\n     public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);\n+\n+    /** Build a convex region from an array of bounding hyperplanes.\n+     * @param hyperplanes array of bounding hyperplanes (if null, an\n+     * empty region will be built)\n+     */\n+    public AbstractRegion(final Hyperplane<S>[] hyperplanes) {\n+        if ((hyperplanes == null) || (hyperplanes.length == 0)) {\n+            tree = new BSPTree<S>(Boolean.FALSE);\n+        } else {\n+\n+            // use the first hyperplane to build the right class\n+            tree = hyperplanes[0].wholeSpace().getTree(false);\n+\n+            // chop off parts of the space\n+            BSPTree<S> node = tree;\n+            node.setAttribute(Boolean.TRUE);\n+            for (final Hyperplane<S> hyperplane : hyperplanes) {\n+                if (node.insertCut(hyperplane)) {\n+                    node.setAttribute(null);\n+                    node.getPlus().setAttribute(Boolean.FALSE);\n+                    node = node.getMinus();\n+                    node.setAttribute(Boolean.TRUE);\n+                }\n+            }\n+\n+        }\n+\n+    }\n \n     /** Recursively build a tree by inserting cut sub-hyperplanes.\n      * @param node current tree node (it is a leaf node at the beginning\n \n     }\n \n-    /** Build a convex region from an array of bounding hyperplanes.\n-     * @param hyperplanes array of bounding hyperplanes (if null, an\n-     * empty region will be built)\n-     * @return a new convex region, or null if the collection is empty\n-     */\n-    public AbstractRegion(final Hyperplane<S>[] hyperplanes) {\n-        if ((hyperplanes == null) || (hyperplanes.length == 0)) {\n-            tree = new BSPTree<S>(Boolean.FALSE);\n-        } else {\n-\n-            // use the first hyperplane to build the right class\n-            tree = hyperplanes[0].wholeSpace().getTree(false);\n-\n-            // chop off parts of the space\n-            BSPTree<S> node = tree;\n-            node.setAttribute(Boolean.TRUE);\n-            for (final Hyperplane<S> hyperplane : hyperplanes) {\n-                if (node.insertCut(hyperplane)) {\n-                    node.setAttribute(null);\n-                    node.getPlus().setAttribute(Boolean.FALSE);\n-                    node = node.getMinus();\n-                    node.setAttribute(Boolean.TRUE);\n-                }\n-            }\n-\n-        }\n-\n-    }\n-\n     /** {@inheritDoc} */\n     public AbstractRegion<S, T> copySelf() {\n         return buildNew(tree.copySelf());\n      * @param node root node of the region\n      * @param point point to check\n      * @return a code representing the point status: either {@link\n-     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n+     * Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE\n+     * OUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}\n      */\n     protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {\n         final BSPTree<S> cell = node.getCell(point);\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java\n  * hyperplanes are the cut hyperplanes closer to the tree root.</p>\n \n  * @param <S> Type of the embedding space.\n+ * @param <T> Type of the embedded sub-space.\n \n  * @version $Revision$\n  * @since 3.0\n     }\n \n     /** Build a sub-hyperplane from an hyperplane and a region.\n-     * @param hyperplane underlying hyperplane\n-     * @param remainingRegion remaining region of the hyperplane\n+     * @param hyper underlying hyperplane\n+     * @param remaining remaining region of the hyperplane\n+     * @return a new sub-hyperplane\n      */\n-    protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyperplane,\n-                                                            final Region<T> remainingRegion);\n+    protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyper,\n+                                                            final Region<T> remaining);\n \n     /** {@inheritDoc} */\n     public AbstractSubHyperplane<S, T> copySelf() {\n     }\n \n     /** {@inheritDoc} */\n-    public abstract Side side(Hyperplane<S> hyperplane);\n+    public abstract Side side(Hyperplane<S> hyper);\n \n     /** {@inheritDoc} */\n-    public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);\n+    public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyper);\n \n     /** {@inheritDoc} */\n     public boolean isEmpty() {\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n \n  * @param <S> Type of the space.\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class BSPTree<S extends Space> {\n      * cells would use four different objects to implement the final\n      * merging phase of the four set operations union, intersection,\n      * difference and symmetric difference (exclusive or).</p>\n-     * @param <SpacePoint> Type of the space points.\n-     * @param <SubSpacePoint> Type of the sub-space points.\n-     * @version $Revision$ $Date$\n+     * @param <S> Type of the space.\n      */\n     public static interface LeafMerger<S extends Space> {\n \n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java\n  *   </li>\n  * </ul>\n \n- * @param <SpacePoint> Type of the space points.\n- * @param <SubSpacePoint> Type of the sub-space points.\n+ * @param <S> Type of the space.\n \n  * @see BSPTree\n  * @see SubHyperplane\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public interface BSPTreeVisitor<S extends Space> {\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java\n  * processing methods.</p>\n  * @param <S> Type of the space.\n  * @see Region#getTree\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class BoundaryAttribute<S extends Space> {\n      * boundary and has the outside of the region on the plus side of\n      * its underlying hyperplane (may be null).\n      */\n-    final SubHyperplane<S> plusOutside;\n+    private final SubHyperplane<S> plusOutside;\n \n     /** Part of the node cut sub-hyperplane that belongs to the\n      * boundary and has the inside of the region on the plus side of\n      * its underlying hyperplane (may be null).\n      */\n-    final SubHyperplane<S> plusInside;\n+    private final SubHyperplane<S> plusInside;\n \n     /** Simple constructor.\n      * @param plusOutside part of the node cut sub-hyperplane that\n         return plusInside;\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java\n \n /** Visitor computing the boundary size.\n  * @param <S> Type of the space.\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n class BoundarySizeVisitor<S extends Space> implements BSPTreeVisitor<S> {\n         @SuppressWarnings(\"unchecked\")\n         final BoundaryAttribute<S> attribute =\n             (BoundaryAttribute<S>) node.getAttribute();\n-        if (attribute.plusOutside != null) {\n-            boundarySize += attribute.plusOutside.getSize();\n+        if (attribute.getPlusOutside() != null) {\n+            boundarySize += attribute.getPlusOutside().getSize();\n         }\n-        if (attribute.plusInside != null) {\n-            boundarySize += attribute.plusInside.getSize();\n+        if (attribute.getPlusInside() != null) {\n+            boundarySize += attribute.getPlusInside().getSize();\n         }\n     }\n \n         return boundarySize;\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java\n  * space). They can be more exotic objects in specific fields, for\n  * example a circle on the surface of the unit sphere.</p>\n \n- * @param <SpacePoint> Type of the space points.\n+ * @param <S> Type of the space.\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public interface Hyperplane<S extends Space> {\n     double getOffset(Vector<S> point);\n \n     /** Check if the instance has the same orientation as another hyperplane.\n-     * <p>This method is expected to be called on parallel hyperplanes\n-     * (i.e. when the {@link #side side} method would return {@link\n-     * Side#HYPER} for some sub-hyperplane having the specified hyperplane\n-     * as its underlying hyperplane). The method should <em>not</em>\n-     * re-check for parallelism, only for orientation, typically by\n-     * testing something like the sign of the dot-products of\n-     * normals.</p>\n+     * <p>This method is expected to be called on parallel hyperplanes. The\n+     * method should <em>not</em> re-check for parallelism, only for\n+     * orientation, typically by testing something like the sign of the\n+     * dot-products of normals.</p>\n      * @param other other hyperplane to check against the instance\n      * @return true if the instance and the other hyperplane have\n      * the same orientation\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Region.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Region.java\n \n  * @param <S> Type of the space.\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public interface Region<S extends Space> {\n     /** Compute the relative position of the instance with respect to an\n      * hyperplane.\n      * @param hyperplane reference hyperplane\n-     * @return one of {@link Hyperplane.Side#PLUS Hyperplane.Side.PLUS}, {@link\n-     * Hyperplane.Side#MINUS Hyperplane.Side.MINUS}, {@link Hyperplane.Side#BOTH\n-     * Hyperplane.Side.BOTH} or {@link Hyperplane.Side#HYPER Hyperplane.Side.HYPER}\n-     * (the latter result can occur only if the tree contains only one\n-     * cut hyperplane)\n+     * @return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\n+     * Side.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\n+     * Side.HYPER} (the latter result can occur only if the tree\n+     * contains only one cut hyperplane)\n      */\n     Side side(final Hyperplane<S> hyperplane);\n \n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java\n \n  * @param <S> Type of the embedding space.\n \n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public interface SubHyperplane<S extends Space> {\n      */\n     SubHyperplane<S> reunite(SubHyperplane<S> other);\n \n-    /** Class holding the results of the {@link Hyperplane#split Hyperplane.split}\n-     * method.\n-     * @param <S> Type of the embedding space.\n-     * @param <T> Type of the embedded sub-space.\n+    /** Class holding the results of the {@link #split split} method.\n+     * @param <U> Type of the embedding space.\n      */\n     public static class SplitSubHyperplane<U extends Space> {\n \n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n     private class NordsieckInitializer implements StepHandler {\n \n         /** Steps counter. */\n-        int count;\n+        private int count;\n \n         /** First steps times. */\n-        final double[] t;\n+        private final double[] t;\n \n         /** First steps states. */\n-        final double[][] y;\n+        private final double[][] y;\n \n         /** First steps derivatives. */\n-        final double[][] yDot;\n+        private final double[][] yDot;\n \n         /** Simple constructor.\n          * @param nSteps number of steps of the multistep method (excluding the one being computed)\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param h step size to use for scaling\n+     * @param t first steps times\n+     * @param y first steps states\n+     * @param yDot first steps derivatives\n+     * @return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\n+     * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)\n+     */\n     public Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t,\n                                                                final double[][] y,\n                                                                final double[][] yDot) {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n     /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n     /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n-\n-    /** Default amount of error to accept in floating point comparisons (as ulps). */\n-    private static final int DEFAULT_ULPS = 10;\n \n     /** Amount of error to accept in floating point comparisons (as ulps). */\n     protected final int maxUlps;\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n      * @param <T> type of the points to cluster\n      * @param clusters the {@link Cluster}s to add the points to\n      * @param points the points to add to the given {@link Cluster}s\n+     * @param assignments points assignments to clusters\n      * @return the number of points assigned to different clusters as the iteration before\n      */\n     private static <T extends Clusterable<T>> int\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      }\n \n     /**\n-     * <p>Reduce {@code |a - offset|} to the primary interval \n+     * <p>Reduce {@code |a - offset|} to the primary interval\n      * {@code [0, |period|)}.</p>\n-     * \n+     *\n      * <p>Specifically, the value returned is <br/>\n      * {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>\n-     * \n+     *\n      * <p>If any of the parameters are {@code NaN} or infinite, the result is\n      * {@code NaN}.</p>\n      *", "timestamp": 1307129036, "metainfo": ""}