{"sha": "615ca9a000c253575e6f62bed87db6110b750834", "log": "Fixed Levenberg-Marquardt optimizer that did not use the vectorial convergence checker. Now this optimizer can use either the general vectorial convergence checker or its own specialized convergence settings. Minor changes had to be introduced in the test data, they have been validated JIRA: MATH-362   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n  *\n  * <p>The resolution engine is a simple translation of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n- * changes. The changes include the over-determined resolution and the Q.R.\n- * decomposition which has been rewritten following the algorithm described in the\n+ * changes. The changes include the over-determined resolution, the use of\n+ * inherited convergence checker and the Q.R. decomposition which has been\n+ * rewritten following the algorithm described in the\n  * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n  * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986.</p>\n  * <p>The authors of the original fortran version are:\n      * Build an optimizer for least squares problems.\n      * <p>The default values for the algorithm settings are:\n      *   <ul>\n+     *    <li>{@link #setConvergenceChecker vectorial convergence checker}: null</li>\n      *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n      *    <li>{@link #setMaxIterations maximal iterations}: 1000</li>\n      *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n      *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n      *   </ul>\n      * </p>\n+     * <p>These default values may be overridden after construction. If the {@link\n+     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n+     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n+     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n      */\n     public LevenbergMarquardtOptimizer() {\n \n         setMaxIterations(1000);\n \n         // default values for the tuning parameters\n+        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);\n \n     /**\n      * Set the desired relative error in the sum of squares.\n-     *\n+     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n+     * convergence checker} is set to null.</p>\n      * @param costRelativeTolerance desired relative error in the sum of squares\n      */\n     public void setCostRelativeTolerance(double costRelativeTolerance) {\n \n     /**\n      * Set the desired relative error in the approximate solution parameters.\n-     *\n+     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n+     * convergence checker} is set to null.</p>\n      * @param parRelativeTolerance desired relative error\n      * in the approximate solution parameters\n      */\n \n     /**\n      * Set the desired max cosine on the orthogonality.\n-     *\n+     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n+     * vectorial convergence checker} being null or non-null.</p>\n      * @param orthoTolerance desired max cosine on the orthogonality\n      * between the function vector and the columns of the jacobian\n      */\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n \n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n+            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return new VectorialPointValuePair(point, objective);\n+                return current;\n             }\n \n             // rescale if necessary\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n+                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n                 }\n \n                 // tests for convergence.\n-                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n-                        (preRed <= costRelativeTolerance) &&\n-                        (ratio <= 2.0)) ||\n+                if (checker != null) {\n+                    // we use the vectorial convergence checker\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        return current;                        \n+                    }\n+                } else {\n+                    // we use the Levenberg-Marquardt specific convergence parameters\n+                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                         (preRed <= costRelativeTolerance) &&\n+                         (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                    return new VectorialPointValuePair(point, objective);\n+                        return current;\n+                    }\n                 }\n \n                 // tests for termination and stringent tolerances\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-10, 1.0e-10));\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n         VectorialPointValuePair optimum =\n             optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n     minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n                                              12432.833948863, 6.9988751744895,\n                                              new double[] {\n-                                               11.4130046614746,\n-                                               -0.896796038685958\n+                                               11.4121122022341,\n+                                               -0.8968550851268697\n                                              }), false);\n     minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n                                              11426454.595762, 6.99887517242903,\n                                              new double[] {\n-                                               11.4127817857886,\n-                                               -0.89680510749204\n+                                               11.412069435091231,\n+                                               -0.8968582807605691\n                                              }), false);\n   }\n \n     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                             64.5856498144943, 11.1517793413499,\n                                             new double[] {\n-                                             0.257819926636811, 0.257829976764542\n+                                             0.2578330049, 0.257829976764542\n                                             }), false);\n   }\n \n                                  function.getTarget(), function.getWeight(),\n                                  function.getStartPoint());\n           assertFalse(exceptionExpected);\n-          assertTrue(function.checkTheoreticalMinCost(optimizer.getRMS()));\n-          assertTrue(function.checkTheoreticalMinParams(optimum));\n+          function.checkTheoreticalMinCost(optimizer.getRMS());\n+          function.checkTheoreticalMinParams(optimum);\n       } catch (OptimizationException lsse) {\n           assertTrue(exceptionExpected);\n       } catch (FunctionEvaluationException fe) {\n           return startParams.length;\n       }\n \n-      public boolean checkTheoreticalMinCost(double rms) {\n+      public void checkTheoreticalMinCost(double rms) {\n           double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-          return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n-      }\n-\n-      public boolean checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n+          assertEquals(theoreticalMinCost, Math.sqrt(m) * rms, threshold);\n+      }\n+\n+      public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n           double[] params = optimum.getPointRef();\n           if (theoreticalMinParams != null) {\n               for (int i = 0; i < theoreticalMinParams.length; ++i) {\n                   double mi = theoreticalMinParams[i];\n                   double vi = params[i];\n-                  if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n-                      return false;\n-                  }\n+                  assertEquals(mi, vi, paramsAccuracy * (1.0 + Math.abs(mi)));\n               }\n           }\n-          return true;\n       }\n \n       public MultivariateMatrixFunction jacobian() {", "timestamp": 1275156950, "metainfo": ""}