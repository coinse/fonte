{"sha": "b3cbb097ddd902b5d980cdab46b7e0dba10975b6", "log": "Merged HypergeometricDistribution and HypergeometricDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.ArithmeticUtils;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * The Hypergeometric Distribution.\n+ * Implementation of the hypergeometric distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">\n- * Hypergeometric Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Hypergeometric_distribution\">Hypergeometric distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">Hypergeometric distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface HypergeometricDistribution extends IntegerDistribution {\n+public class HypergeometricDistribution extends AbstractIntegerDistribution\n+    implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -436928820673516179L;\n+    /** The number of successes in the population. */\n+    private final int numberOfSuccesses;\n+    /** The population size. */\n+    private final int populationSize;\n+    /** The sample size. */\n+    private final int sampleSize;\n+\n+    /**\n+     * Construct a new hypergeometric distribution with the specified population\n+     * size, number of successes in the population, and sample size.\n+     *\n+     * @param populationSize Population size.\n+     * @param numberOfSuccesses Number of successes in the population.\n+     * @param sampleSize Sample size.\n+     * @throws NotPositiveException if {@code numberOfSuccesses < 0},\n+     * or {@code populationSize < 0}.\n+     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n+     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n+     * or {@code sampleSize > populationSize}.\n+     */\n+    public HypergeometricDistribution(int populationSize,\n+                                          int numberOfSuccesses,\n+                                          int sampleSize)\n+        throws NotPositiveException,\n+        NotStrictlyPositiveException,\n+        NumberIsTooLargeException {\n+        if (populationSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n+                                                   populationSize);\n+        }\n+        if (numberOfSuccesses < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+                                           numberOfSuccesses);\n+        }\n+        if (sampleSize < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                                           sampleSize);\n+        }\n+\n+        if (numberOfSuccesses > populationSize) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n+                                                numberOfSuccesses, populationSize, true);\n+        }\n+        if (sampleSize > populationSize) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n+                                                sampleSize, populationSize, true);\n+        }\n+\n+        this.numberOfSuccesses = numberOfSuccesses;\n+        this.populationSize = populationSize;\n+        this.sampleSize = sampleSize;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(int x) {\n+        double ret;\n+\n+        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n+        if (x < domain[0]) {\n+            ret = 0.0;\n+        } else if (x >= domain[1]) {\n+            ret = 1.0;\n+        } else {\n+            ret = innerCumulativeProbability(domain[0], x, 1, populationSize,\n+                                             numberOfSuccesses, sampleSize);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Return the domain for the given hypergeometric distribution parameters.\n+     *\n+     * @param n Population size.\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n+     * @return a two element array containing the lower and upper bounds of the\n+     * hypergeometric distribution.\n+     */\n+    private int[] getDomain(int n, int m, int k) {\n+        return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return getLowerDomain(populationSize, numberOfSuccesses, sampleSize);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return getUpperDomain(sampleSize, numberOfSuccesses);\n+    }\n+\n+    /**\n+     * Return the lowest domain value for the given hypergeometric distribution\n+     * parameters.\n+     *\n+     * @param n Population size.\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n+     * @return the lowest domain value of the hypergeometric distribution.\n+     */\n+    private int getLowerDomain(int n, int m, int k) {\n+        return FastMath.max(0, m - (n - k));\n+    }\n+\n     /**\n      * Access the number of successes.\n      *\n      * @return the number of successes.\n      */\n-    int getNumberOfSuccesses();\n+    public int getNumberOfSuccesses() {\n+        return numberOfSuccesses;\n+    }\n \n     /**\n      * Access the population size.\n      *\n      * @return the population size.\n      */\n-    int getPopulationSize();\n+    public int getPopulationSize() {\n+        return populationSize;\n+    }\n \n     /**\n      * Access the sample size.\n      *\n      * @return the sample size.\n      */\n-    int getSampleSize();\n+    public int getSampleSize() {\n+        return sampleSize;\n+    }\n+\n+    /**\n+     * Return the highest domain value for the given hypergeometric distribution\n+     * parameters.\n+     *\n+     * @param m Number of successes in the population.\n+     * @param k Sample size.\n+     * @return the highest domain value of the hypergeometric distribution.\n+     */\n+    private int getUpperDomain(int m, int k) {\n+        return FastMath.min(k, m);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double probability(int x) {\n+        double ret;\n+\n+        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n+        if (x < domain[0] || x > domain[1]) {\n+            ret = 0.0;\n+        } else {\n+            double p = (double) sampleSize / (double) populationSize;\n+            double q = (double) (populationSize - sampleSize) / (double) populationSize;\n+            double p1 = SaddlePointExpansion.logBinomialProbability(x,\n+                    numberOfSuccesses, p, q);\n+            double p2 =\n+                SaddlePointExpansion.logBinomialProbability(sampleSize - x,\n+                    populationSize - numberOfSuccesses, p, q);\n+            double p3 =\n+                SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);\n+            ret = FastMath.exp(p1 + p2 - p3);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, defined by the given hypergeometric\n+     * distribution parameters, this method returns {@code P(X = x)}.\n+     *\n+     * @param x Value at which the PMF is evaluated.\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return PMF for the distribution.\n+     */\n+    private double probability(int n, int m, int k, int x) {\n+        return FastMath.exp(ArithmeticUtils.binomialCoefficientLog(m, x) +\n+               ArithmeticUtils.binomialCoefficientLog(n - m, k - x) -\n+               ArithmeticUtils.binomialCoefficientLog(n, k));\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns {@code P(X >= x)}.\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return the upper tail CDF for this distribution.\n+     * @since 1.1\n+     */\n+    public double upperCumulativeProbability(int x) {\n+        double ret;\n+\n+        final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n+        if (x < domain[0]) {\n+            ret = 1.0;\n+        } else if (x > domain[1]) {\n+            ret = 0.0;\n+        } else {\n+            ret = innerCumulativeProbability(domain[1], x, -1, populationSize,\n+                                             numberOfSuccesses, sampleSize);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns\n+     * {@code P(x0 <= X <= x1)}.\n+     * This probability is computed by summing the point probabilities for the\n+     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n+     * {@code dx}.\n+     *\n+     * @param x0 Inclusive lower bound.\n+     * @param x1 Inclusive upper bound.\n+     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n+     * 0 indicates summing from x1 to x0).\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return {@code P(x0 <= X <= x1)}.\n+     */\n+    private double innerCumulativeProbability(int x0, int x1, int dx,\n+                                              int n, int m, int k) {\n+        double ret = probability(n, m, k, x0);\n+        while (x0 != x1) {\n+            x0 += dx;\n+            ret += probability(n, m, k, x0);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For population size {@code N}, number of successes {@code m}, and sample\n+     * size {@code n}, the lower bound of the support is\n+     * {@code max(0, n + m - N)}.\n+     *\n+     * @return lower bound of the support\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return FastMath.max(0,\n+                getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of successes {@code m} and sample size {@code n}, the upper\n+     * bound of the support is {@code min(m, n)}.\n+     *\n+     * @return upper bound of the support\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For population size {@code N}, number of successes {@code m}, and sample\n+     * size {@code n}, the mean is {@code n * m / N}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return (double)(getSampleSize() * getNumberOfSuccesses()) / (double)getPopulationSize();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For population size {@code N}, number of successes {@code m}, and sample\n+     * size {@code n}, the variance is\n+     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double N = getPopulationSize();\n+        final double m = getNumberOfSuccesses();\n+        final double n = getSampleSize();\n+        return ( n * m * (N - n) * (N - m) ) / ( (N*N * (N - 1)) );\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ContinuousDistribution;\n import org.apache.commons.math.distribution.FDistribution;\n-import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n+import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.IntegerDistribution;\n import org.apache.commons.math.distribution.PascalDistributionImpl;\n import org.apache.commons.math.distribution.TDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link HypergeometricDistributionImpl Hypergeometric Distribution}.\n+     * Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n-        return nextInversionDeviate(new HypergeometricDistributionImpl(populationSize, numberOfSuccesses, sampleSize));\n+        return nextInversionDeviate(new HypergeometricDistribution(populationSize, numberOfSuccesses, sampleSize));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new HypergeometricDistributionImpl(10,5, 5);\n+        return new HypergeometricDistribution(10,5, 5);\n     }\n \n     /** Creates the default probability density test input values */\n     /** Verify that if there are no failures, mass is concentrated on sampleSize */\n     @Test\n     public void testDegenerateNoFailures() throws Exception {\n-        setDistribution(new HypergeometricDistributionImpl(5,5,3));\n+        setDistribution(new HypergeometricDistribution(5,5,3));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n     /** Verify that if there are no successes, mass is concentrated on 0 */\n     @Test\n     public void testDegenerateNoSuccesses() throws Exception {\n-        setDistribution(new HypergeometricDistributionImpl(5,0,3));\n+        setDistribution(new HypergeometricDistribution(5,0,3));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n     /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */\n     @Test\n     public void testDegenerateFullSample() throws Exception {\n-        setDistribution(new HypergeometricDistributionImpl(5,3,5));\n+        setDistribution(new HypergeometricDistribution(5,3,5));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});\n     @Test\n     public void testPreconditions() {\n         try {\n-            new HypergeometricDistributionImpl(0, 3, 5);\n+            new HypergeometricDistribution(0, 3, 5);\n             Assert.fail(\"negative population size. NotStrictlyPositiveException expected\");\n         } catch(NotStrictlyPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new HypergeometricDistributionImpl(5, -1, 5);\n+            new HypergeometricDistribution(5, -1, 5);\n             Assert.fail(\"negative number of successes. NotPositiveException expected\");\n         } catch(NotPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new HypergeometricDistributionImpl(5, 3, -1);\n+            new HypergeometricDistribution(5, 3, -1);\n             Assert.fail(\"negative sample size. NotPositiveException expected\");\n         } catch(NotPositiveException ex) {\n             // Expected.\n         }\n         try {\n-            new HypergeometricDistributionImpl(5, 6, 5);\n+            new HypergeometricDistribution(5, 6, 5);\n             Assert.fail(\"numberOfSuccesses > populationSize. NumberIsTooLargeException expected\");\n         } catch(NumberIsTooLargeException ex) {\n             // Expected.\n         }\n         try {\n-            new HypergeometricDistributionImpl(5, 3, 6);\n+            new HypergeometricDistribution(5, 3, 6);\n             Assert.fail(\"sampleSize > populationSize. NumberIsTooLargeException expected\");\n         } catch(NumberIsTooLargeException ex) {\n             // Expected.\n \n     @Test\n     public void testAccessors() {\n-        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5, 3, 4);\n+        HypergeometricDistribution dist = new HypergeometricDistribution(5, 3, 4);\n         Assert.assertEquals(5, dist.getPopulationSize());\n         Assert.assertEquals(3, dist.getNumberOfSuccesses());\n         Assert.assertEquals(4, dist.getSampleSize());\n     }\n \n     private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {\n-        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);\n+        HypergeometricDistribution dist = new HypergeometricDistribution(populationSize, numberOfSucceses, sampleSize);\n         for (int i = 0; i < data.length; ++i) {\n             int x = (int)data[i][0];\n             double pdf = data[i][1];\n     public void testMoments() {\n         final double tol = 1e-9;\n         HypergeometricDistribution dist;\n-        \n-        dist = new HypergeometricDistributionImpl(1500, 40, 100);\n+\n+        dist = new HypergeometricDistribution(1500, 40, 100);\n         Assert.assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol); \n-        \n-        dist = new HypergeometricDistributionImpl(3000, 55, 200);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol);\n+\n+        dist = new HypergeometricDistribution(3000, 55, 200);\n         Assert.assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.ExponentialDistribution;\n import org.apache.commons.math.distribution.FDistribution;\n import org.apache.commons.math.distribution.GammaDistribution;\n-import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n+import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistributionTest;\n import org.apache.commons.math.distribution.PascalDistributionImpl;\n import org.apache.commons.math.distribution.PascalDistributionTest;\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n-        HypergeometricDistributionImpl distribution = (HypergeometricDistributionImpl) testInstance.makeDistribution();\n+        HypergeometricDistribution distribution = (HypergeometricDistribution) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         for (int i = 0; i < length; i++) {", "timestamp": 1322292326, "metainfo": ""}