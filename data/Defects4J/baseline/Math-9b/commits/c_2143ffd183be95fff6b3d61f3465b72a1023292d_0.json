{"sha": "2143ffd183be95fff6b3d61f3465b72a1023292d", "log": "Missing @Override  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double doIntegrate()\n         throws TooManyEvaluationsException, MaxCountExceededException {\n \n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double doIntegrate()\n         throws TooManyEvaluationsException, MaxCountExceededException {\n \n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double doIntegrate()\n         throws TooManyEvaluationsException, MaxCountExceededException {\n \n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected double doIntegrate()\n         throws TooManyEvaluationsException, MaxCountExceededException {\n \n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n         /** Get hash code.\n          * @return hash code\n          */\n+        @Override\n         public int hashCode() {\n             return (v << 16) ^ w;\n         }\n          * @param key other key\n          * @return true if the instance and the other key refer to the same polynomial\n          */\n+        @Override\n         public boolean equals(final Object key) {\n \n             if ((key == null) || !(key instanceof JacobiKey)) {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected final double doSolve() {\n         // Get initial solution\n         double x0 = getMin();\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n         return new IntervalsSet(tree);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeGeometricalProperties() {\n         if (getTree(false).getCut() == null) {\n             setBarycenter(Vector1D.NaN);\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/SubOrientedPoint.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/SubOrientedPoint.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getSize() {\n         return 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected AbstractSubHyperplane<Euclidean1D, Euclidean1D> buildNew(final Hyperplane<Euclidean1D> hyperplane,\n                                                                        final Region<Euclidean1D> remainingRegion) {\n         return new SubOrientedPoint(hyperplane, remainingRegion);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Side side(final Hyperplane<Euclidean1D> hyperplane) {\n         final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n         return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public SplitSubHyperplane<Euclidean1D> split(final Hyperplane<Euclidean1D> hyperplane) {\n         final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n         return (global < -1.0e-10) ?\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1DFormat.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StringBuffer format(final Vector<Euclidean1D> vector, final StringBuffer toAppendTo,\n                                final FieldPosition pos) {\n         final Vector1D p1 = (Vector1D) vector;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Vector1D parse(final String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector1D result = parse(source, parsePosition);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Vector1D parse(final String source, final ParsePosition pos) {\n         final double[] coordinates = parseCoordinates(1, source, pos);\n         if (coordinates == null) {\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) {\n         return new PolyhedronsSet(tree);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeGeometricalProperties() {\n \n         // compute the contribution of all boundary facets\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected AbstractSubHyperplane<Euclidean3D, Euclidean2D> buildNew(final Hyperplane<Euclidean3D> hyperplane,\n                                                                        final Region<Euclidean2D> remainingRegion) {\n         return new SubPlane(hyperplane, remainingRegion);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Side side(Hyperplane<Euclidean3D> hyperplane) {\n \n         final Plane otherPlane = (Plane) hyperplane;\n      * on the plus side of the instance and the part of the\n      * instance on the minus side of the instance\n      */\n+    @Override\n     public SplitSubHyperplane<Euclidean3D> split(Hyperplane<Euclidean3D> hyperplane) {\n \n         final Plane otherPlane = (Plane) hyperplane;\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DFormat.java\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n+    @Override\n     public StringBuffer format(final Vector<Euclidean3D> vector, final StringBuffer toAppendTo,\n                                final FieldPosition pos) {\n         final Vector3D v3 = (Vector3D) vector;\n      * @throws MathParseException if the beginning of the specified string\n      * cannot be parsed.\n      */\n+    @Override\n     public Vector3D parse(final String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Vector3D} object.\n      */\n+    @Override\n     public Vector3D parse(final String source, final ParsePosition pos) {\n         final double[] coordinates = parseCoordinates(3, source, pos);\n         if (coordinates == null) {\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n         return new PolygonsSet(tree);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected void computeGeometricalProperties() {\n \n         final Vector2D[][] v = getVertices();\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane,\n                                                                        final Region<Euclidean1D> remainingRegion) {\n         return new SubLine(hyperplane, remainingRegion);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n \n         final Line    thisLine  = (Line) getHyperplane();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n \n         final Line    thisLine  = (Line) getHyperplane();\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2DFormat.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StringBuffer format(final Vector<Euclidean2D> vector, final StringBuffer toAppendTo,\n                                final FieldPosition pos) {\n         final Vector2D p2 = (Vector2D) vector;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Vector2D parse(final String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector2D result = parse(source, parsePosition);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Vector2D parse(final String source, final ParsePosition pos) {\n         final double[] coordinates = parseCoordinates(2, source, pos);\n         if (coordinates == null) {\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArrayRealVector ebeDivide(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             final double[] vData = ((ArrayRealVector) v).data;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector projection(RealVector v) {\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getEntry(int index) {\n         return data[index];\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getDimension() {\n         return data.length;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector append(RealVector v) {\n         try {\n             return new ArrayRealVector(this, (ArrayRealVector) v);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector append(double in) {\n         final double[] out = new double[data.length + 1];\n         System.arraycopy(data, 0, out, 0, data.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector getSubVector(int index, int n) {\n         ArrayRealVector out = new ArrayRealVector(n);\n         try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setEntry(int index, double value) {\n         try {\n             data[index] = value;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void addToEntry(int index, double increment) {\n         data[index] += increment;\n     }\n      * @return {@code true} if any coordinate of this vector is {@code NaN},\n      * {@code false} otherwise.\n      */\n+    @Override\n     public boolean isNaN() {\n         for (double v : data) {\n             if (Double.isNaN(v)) {\n      * @return {@code true} if any coordinate of this vector is infinite and\n      * none are {@code NaN}, {@code false} otherwise.\n      */\n+    @Override\n     public boolean isInfinite() {\n         if (isNaN()) {\n             return false;\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector append(RealVector v) {\n         if (v instanceof OpenMapRealVector) {\n             return append((OpenMapRealVector) v);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector append(double d) {\n         OpenMapRealVector res = new OpenMapRealVector(this, 1);\n         res.setEntry(virtualSize, d);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector getSubVector(int index, int n) {\n         checkIndex(index);\n         checkIndex(index + n - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int getDimension() {\n         return virtualSize;\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getEntry(int index) {\n         checkIndex(index);\n         return entries.get(index);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public boolean isInfinite() {\n         boolean infiniteFound = false;\n         Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public boolean isNaN() {\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector projection(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setEntry(int index, double value) {\n         checkIndex(index);\n         if (!isDefaultValue(value)) {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public abstract void integrate (ExpandableStatefulODE equations, double t)\n     throws MathIllegalStateException, MathIllegalArgumentException;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public void integrate(final ExpandableStatefulODE equations, final double t)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n ", "timestamp": 1320400146, "metainfo": ""}