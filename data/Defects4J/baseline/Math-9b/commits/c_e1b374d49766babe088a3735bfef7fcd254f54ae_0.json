{"sha": "e1b374d49766babe088a3735bfef7fcd254f54ae", "log": "Allow discrete events to be detected by ODE solvers also at step start.  JIRA: MATH-605  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n             MathUtils.equals(nextTime, lastTime, 1)) {\n             nextTime += h;\n         }\n+\n+        // Process normalized steps as long as they are in the current step.\n         boolean nextInStep = isNextInStep(nextTime, interpolator);\n         while (nextInStep) {\n             // Output the stored previous step.\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/events/OverlappingEventsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode.events;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.analysis.solvers.BaseSecantSolver;\n+import org.apache.commons.math.analysis.solvers.PegasusSolver;\n+import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for overlapping state events. Also tests an event function that does\n+ * not converge to zero, but does have values of opposite sign around its root.\n+ */\n+public class OverlappingEventsTest implements FirstOrderDifferentialEquations {\n+\n+    /** Expected event times for first event. */\n+    private static final double[] EVENT_TIMES1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0,\n+                                                  7.0, 8.0, 9.0};\n+\n+    /** Expected event times for second event. */\n+    private static final double[] EVENT_TIMES2 = {0.5, 1.0, 1.5, 2.0, 2.5, 3.0,\n+                                                  3.5, 4.0, 4.5, 5.0, 5.5, 6.0,\n+                                                  6.5, 7.0, 7.5, 8.0, 8.5, 9.0,\n+                                                  9.5};\n+\n+    /** Test for events that occur at the exact same time, but due to numerical\n+     * calculations occur very close together instead. Uses event type 0. See\n+     * {@link Event#g}.\n+     * @throws EventException in case of event evaluation failure\n+     * @throws IntegratorException in case of integration failure\n+     * @throws MathUserException in case of derivative evaluation failure\n+     */\n+    @Test\n+    public void testOverlappingEvents0() throws MathUserException, IntegratorException, EventException {\n+        test(0);\n+    }\n+\n+    /** Test for events that occur at the exact same time, but due to numerical\n+     * calculations occur very close together instead. Uses event type 1. See\n+     * {@link Event#g}.\n+     * @throws EventException in case of event evaluation failure\n+     * @throws IntegratorException in case of integration failure\n+     * @throws MathUserException in case of derivative evaluation failure\n+     */\n+    @Test\n+    public void testOverlappingEvents1() throws MathUserException, IntegratorException, EventException {\n+        test(1);\n+    }\n+\n+    /** Test for events that occur at the exact same time, but due to numerical\n+     * calculations occur very close together instead.\n+     * @param eventType the type of events to use. See {@link Event#g}\n+     * @throws EventException in case of event evaluation failure\n+     * @throws IntegratorException in case of integration failure\n+     * @throws MathUserException in case of derivative evaluation failure\n+     */\n+    public void test(int eventType) throws MathUserException, IntegratorException, EventException {\n+        double e = 1e-15;\n+        FirstOrderIntegrator integrator = new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);\n+        BaseSecantSolver rootSolver = new PegasusSolver(e, e);\n+        EventHandler evt1 = new Event(0, eventType);\n+        EventHandler evt2 = new Event(1, eventType);\n+        integrator.addEventHandler(evt1, 0.1, e, 999, rootSolver);\n+        integrator.addEventHandler(evt2, 0.1, e, 999, rootSolver);\n+        double t = 0.0;\n+        double tEnd = 10.0;\n+        double[] y = {0.0, 0.0};\n+        List<Double> events1 = new ArrayList<Double>();\n+        List<Double> events2 = new ArrayList<Double>();\n+        while (t < tEnd) {\n+            t = integrator.integrate(this, t, y, tEnd, y);\n+            //System.out.println(\"t=\" + t + \",\\t\\ty=[\" + y[0] + \",\" + y[1] + \"]\");\n+\n+            if (y[0] >= 1.0) {\n+                y[0] = 0.0;\n+                events1.add(t);\n+                //System.out.println(\"Event 1 @ t=\" + t);\n+            }\n+            if (y[1] >= 1.0) {\n+                y[1] = 0.0;\n+                events2.add(t);\n+                //System.out.println(\"Event 2 @ t=\" + t);\n+            }\n+        }\n+        Assert.assertEquals(EVENT_TIMES1.length, events1.size());\n+        Assert.assertEquals(EVENT_TIMES2.length, events2.size());\n+        for(int i = 0; i < EVENT_TIMES1.length; i++) {\n+            Assert.assertEquals(EVENT_TIMES1[i], events1.get(i), 1e-7);\n+        }\n+        for(int i = 0; i < EVENT_TIMES2.length; i++) {\n+            Assert.assertEquals(EVENT_TIMES2[i], events2.get(i), 1e-7);\n+        }\n+        //System.out.println();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return 2;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeDerivatives(double t, double[] y, double[] yDot) throws MathUserException {\n+        yDot[0] = 1.0;\n+        yDot[1] = 2.0;\n+    }\n+\n+    /** State events for this unit test. */\n+    private class Event implements EventHandler {\n+        /** The index of the continuous variable to use. */\n+        private final int idx;\n+\n+        /** The event type to use. See {@link #g}. */\n+        private final int eventType;\n+\n+        /** Constructor for the {@link Event} class.\n+         * @param idx the index of the continuous variable to use\n+         * @param eventType the type of event to use. See {@link #g}\n+         */\n+        public Event(int idx, int eventType) {\n+            this.idx = idx;\n+            this.eventType = eventType;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) throws EventException {\n+            return (eventType == 0) ? y[idx] >= 1.0 ? 1.0 : -1.0\n+                                    : y[idx] - 1.0;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y, boolean increasing) throws EventException {\n+            return STOP;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) throws EventException {\n+            // Never called.\n+        }\n+    }\n+}", "timestamp": 1311166031, "metainfo": ""}