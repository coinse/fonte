{"sha": "2a04f6084032eef1bac035b46429050cb9ecb019", "log": "Cosmetic changes + \"final\" keyword.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n     private static final double F_5_6 = 5d / 6d;\n     /** Constant: {@value}. */\n     private static final double F_1_2 = 1d / 2d;\n+    /** Constant: {@value}. */\n+    private static final double F_1_4 = 1d / 4d;\n \n     /**\n      * Private Constructor\n         }\n \n         if (xa > 1.633123935319537E16) { // Very large input\n-            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n+            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n         }\n \n         /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n      * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n      */\n     public static double atan2(double y, double x) {\n-        if (x !=x || y != y) {\n+        if (x != x || y != y) {\n             return Double.NaN;\n         }\n \n-        if (y == 0.0) {\n-            double result = x*y;\n-            double invx = 1.0/x;\n-            double invy = 1.0/y;\n-\n-            if (invx == 0.0) { // X is infinite\n+        if (y == 0) {\n+            final double result = x * y;\n+            final double invx = 1d / x;\n+            final double invy = 1d / y;\n+\n+            if (invx == 0) { // X is infinite\n                 if (x > 0) {\n                     return y; // return +/- 0.0\n                 } else {\n                 }\n             }\n \n-            if (x < 0.0 || invx < 0.0) {\n-                if (y < 0.0 || invy < 0.0) {\n+            if (x < 0 || invx < 0) {\n+                if (y < 0 || invy < 0) {\n                     return -Math.PI;\n                 } else {\n                     return Math.PI;\n \n         if (y == Double.POSITIVE_INFINITY) {\n             if (x == Double.POSITIVE_INFINITY) {\n-                return Math.PI/4.0;\n+                return Math.PI * F_1_4;\n             }\n \n             if (x == Double.NEGATIVE_INFINITY) {\n                 return Math.PI * F_3_4;\n             }\n \n-            return Math.PI/2.0;\n+            return Math.PI * F_1_2;\n         }\n \n         if (y == Double.NEGATIVE_INFINITY) {\n             if (x == Double.POSITIVE_INFINITY) {\n-                return -Math.PI/4.0;\n+                return -Math.PI * F_1_4;\n             }\n \n             if (x == Double.NEGATIVE_INFINITY) {\n                 return -Math.PI * F_3_4;\n             }\n \n-            return -Math.PI/2.0;\n+            return -Math.PI * F_1_2;\n         }\n \n         if (x == Double.POSITIVE_INFINITY) {\n-            if (y > 0.0 || 1/y > 0.0) {\n-                return 0.0;\n-            }\n-\n-            if (y < 0.0 || 1/y < 0.0) {\n-                return -0.0;\n+            if (y > 0 || 1 / y > 0) {\n+                return 0d;\n+            }\n+\n+            if (y < 0 || 1 / y < 0) {\n+                return -0d;\n             }\n         }\n \n         if (x == Double.NEGATIVE_INFINITY)\n         {\n-            if (y > 0.0 || 1/y > 0.0) {\n+            if (y > 0.0 || 1 / y > 0.0) {\n                 return Math.PI;\n             }\n \n-            if (y < 0.0 || 1/y < 0.0) {\n+            if (y < 0 || 1 / y < 0) {\n                 return -Math.PI;\n             }\n         }\n         // Neither y nor x can be infinite or NAN here\n \n         if (x == 0) {\n-            if (y > 0.0 || 1/y > 0.0) {\n-                return Math.PI/2.0;\n-            }\n-\n-            if (y < 0.0 || 1/y < 0.0) {\n-                return -Math.PI/2.0;\n+            if (y > 0 || 1 / y > 0) {\n+                return Math.PI * F_1_2;\n+            }\n+\n+            if (y < 0 || 1 / y < 0) {\n+                return -Math.PI * F_1_2;\n             }\n         }\n \n         // Compute ratio r = y/x\n-        final double r = y/x;\n+        final double r = y / x;\n         if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n             return atan(r, 0, x < 0);\n         }\n \n         rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n \n-        double temp = ra + rb;\n+        final double temp = ra + rb;\n         rb = -(temp - ra - rb);\n         ra = temp;\n \n         if (ra == 0) { // Fix up the sign so atan works correctly\n-            ra = copySign(0.0, y);\n+            ra = copySign(0d, y);\n         }\n \n         // Call atan\n-        double result = atan(ra, rb, x < 0);\n+        final double result = atan(ra, rb, x < 0);\n \n         return result;\n     }", "timestamp": 1328793486, "metainfo": ""}