{"sha": "dd4efa43349e74832b092ba33a92275b68cab9d3", "log": "MATH-689 Moved arrays utilities from \"MathUtils\" to \"MathArrays\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/function/StepFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/StepFunction.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * <a href=\"http://en.wikipedia.org/wiki/Step_function\">\n         if (y.length != x.length) {\n             throw new DimensionMismatchException(y.length, x.length);\n         }\n-        MathUtils.checkOrder(x);\n+        MathArrays.checkOrder(x);\n \n-        abscissa = MathUtils.copyOf(x);\n-        ordinate = MathUtils.copyOf(y);\n+        abscissa = MathArrays.copyOf(x);\n+        ordinate = MathArrays.copyOf(y);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Function that implements the\n             throw new DimensionMismatchException(xLen, d2FdXdY.length);\n         }\n \n-        MathUtils.checkOrder(x);\n-        MathUtils.checkOrder(y);\n+        MathArrays.checkOrder(x);\n+        MathArrays.checkOrder(y);\n \n         xval = x.clone();\n         yval = y.clone();\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Generates a bicubic interpolating function.\n             throw new DimensionMismatchException(xval.length, fval.length);\n         }\n \n-        MathUtils.checkOrder(xval);\n-        MathUtils.checkOrder(yval);\n+        MathArrays.checkOrder(xval);\n+        MathArrays.checkOrder(yval);\n \n         final int xLen = xval.length;\n         final int yLen = yval.length;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Implements a linear function for interpolation of real univariate functions.\n         // Number of intervals.  The number of data points is n + 1.\n         int n = x.length - 1;\n \n-        MathUtils.checkOrder(x);\n+        MathArrays.checkOrder(x);\n \n         // Slope of the lines between the datapoints.\n         final double m[] = new double[n];\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n         checkAllFiniteReal(yval);\n         checkAllFiniteReal(weights);\n \n-        MathUtils.checkOrder(xval);\n+        MathArrays.checkOrder(xval);\n \n         if (n == 1) {\n             return new double[]{yval[0]};\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.fitting.PolynomialFitter;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n             }\n         }\n \n-        MathUtils.checkOrder(xval);\n-        MathUtils.checkOrder(yval);\n+        MathArrays.checkOrder(xval);\n+        MathArrays.checkOrder(yval);\n \n         // For each line y[j] (0 <= j < yLen), construct a polynomial, with\n         // respect to variable x, fitting array fval[][j]\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n         // Number of intervals.  The number of data points is n + 1.\n         int n = x.length - 1;\n \n-        MathUtils.checkOrder(x);\n+        MathArrays.checkOrder(x);\n \n         // Differences between knot points\n         double h[] = new double[n];\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Function that implements the\n             throw new DimensionMismatchException(xLen, d3FdXdYdZ.length);\n         }\n \n-        MathUtils.checkOrder(x);\n-        MathUtils.checkOrder(y);\n-        MathUtils.checkOrder(z);\n+        MathArrays.checkOrder(x);\n+        MathArrays.checkOrder(y);\n+        MathArrays.checkOrder(z);\n \n         xval = x.clone();\n         yval = y.clone();\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Generates a tricubic interpolating function.\n             throw new DimensionMismatchException(xval.length, fval.length);\n         }\n \n-        MathUtils.checkOrder(xval);\n-        MathUtils.checkOrder(yval);\n-        MathUtils.checkOrder(zval);\n+        MathArrays.checkOrder(xval);\n+        MathArrays.checkOrder(yval);\n+        MathArrays.checkOrder(zval);\n \n         final int xLen = xval.length;\n         final int yLen = yval.length;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealPeriodicInterpolator.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n \n /**\n             throw new NumberIsTooSmallException(xval.length, extend, true);\n         }\n \n-        MathUtils.checkOrder(xval);\n+        MathArrays.checkOrder(xval);\n         final double offset = xval[0];\n \n         final int len = xval.length + extend * 2;\n             y[index] = yval[i];\n         }\n \n-        MathUtils.sortInPlace(x, y);\n+        MathArrays.sortInPlace(x, y);\n \n         final UnivariateRealFunction f = interpolator.interpolate(x, y);\n         return new UnivariateRealFunction() {\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n         coefficientsComputed = false;\n \n         if (!verifyInterpolationArray(x, y, false)) {\n-            MathUtils.sortInPlace(this.x, this.y);\n+            MathArrays.sortInPlace(this.x, this.y);\n             // Second check in case some abscissa is duplicated.\n             verifyInterpolationArray(this.x, this.y, true);\n         }\n         System.arraycopy(x, 0, xNew, 0, x.length);\n         System.arraycopy(y, 0, yNew, 0, y.length);\n \n-        MathUtils.sortInPlace(xNew, yNew);\n+        MathArrays.sortInPlace(xNew, yNew);\n         // Second check in case some abscissa is duplicated.\n         verifyInterpolationArray(xNew, yNew, true);\n         return evaluateInternal(xNew, yNew, z);\n             throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n         }\n \n-        return MathUtils.checkOrder(x, MathUtils.OrderDirection.INCREASING, true, abort);\n+        return MathArrays.checkOrder(x, MathArrays.OrderDirection.INCREASING, true, abort);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.OutOfRangeException;\n         if (knots.length - 1 != polynomials.length) {\n             throw new DimensionMismatchException(polynomials.length, knots.length);\n         }\n-        MathUtils.checkOrder(knots);\n+        MathArrays.checkOrder(knots);\n \n         this.n = knots.length -1;\n         this.knots = new double[n + 1];\n--- a/src/main/java/org/apache/commons/math/exception/NonMonotonicSequenceException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NonMonotonicSequenceException.java\n  */\n package org.apache.commons.math.exception;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n     /**\n      * Direction (positive for increasing, negative for decreasing).\n      */\n-    private final MathUtils.OrderDirection direction;\n+    private final MathArrays.OrderDirection direction;\n     /**\n      * Whether the sequence must be strictly increasing or decreasing.\n      */\n     public NonMonotonicSequenceException(Number wrong,\n                                          Number previous,\n                                          int index) {\n-        this(wrong, previous, index, MathUtils.OrderDirection.INCREASING, true);\n+        this(wrong, previous, index, MathArrays.OrderDirection.INCREASING, true);\n     }\n \n     /**\n     public NonMonotonicSequenceException(Number wrong,\n                                          Number previous,\n                                          int index,\n-                                         MathUtils.OrderDirection direction,\n+                                         MathArrays.OrderDirection direction,\n                                          boolean strict) {\n-        super(direction == MathUtils.OrderDirection.INCREASING ?\n+        super(direction == MathArrays.OrderDirection.INCREASING ?\n               (strict ?\n                LocalizedFormats.NOT_STRICTLY_INCREASING_SEQUENCE :\n                LocalizedFormats.NOT_INCREASING_SEQUENCE) :\n     /**\n      * @return the order direction.\n      **/\n-    public MathUtils.OrderDirection getDirection() {\n+    public MathArrays.OrderDirection getDirection() {\n         return direction;\n     }\n     /**\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n import org.apache.commons.math.geometry.Space;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * This class implements vectors in a three-dimensional space.\n      * @param u2 second base (unscaled) vector\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n-        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x);\n-        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y);\n-        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z);\n+        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n+        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n+        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n     }\n \n     /** Linear constructor\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                     double a3, Vector3D u3) {\n-        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n-        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n-        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n+        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n+        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n+        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n     }\n \n     /** Linear constructor\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                     double a3, Vector3D u3, double a4, Vector3D u4) {\n-        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n-        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n-        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n+        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n+        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n+        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n     }\n \n     /** Get the abscissa of the vector.\n      * algorithms to preserve accuracy and reduce cancellation effects.\n      * It should be very accurate even for nearly orthogonal vectors.\n      * </p>\n-     * @see MathUtils#linearCombination(double, double, double, double, double, double)\n+     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n      */\n     public double dotProduct(final Vector<Euclidean3D> v) {\n         final Vector3D v3 = (Vector3D) v;\n-        return MathUtils.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n+        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n     }\n \n     /** Compute the cross-product of the instance with another vector.\n      */\n     public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n         final Vector3D v3 = (Vector3D) v;\n-        return new Vector3D(MathUtils.linearCombination(y, v3.z, -z, v3.y),\n-                            MathUtils.linearCombination(z, v3.x, -x, v3.z),\n-                            MathUtils.linearCombination(x, v3.y, -y, v3.x));\n+        return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\n+                            MathArrays.linearCombination(z, v3.x, -x, v3.z),\n+                            MathArrays.linearCombination(x, v3.y, -y, v3.x));\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/PivotingQRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/PivotingQRDecomposition.java\n package org.apache.commons.math.linear;\n \n import java.util.Arrays;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n     }\n \n     public int[] getOrder() {\n-        return MathUtils.copyOf(permutation);\n+        return MathArrays.copyOf(permutation);\n     }\n \n     public PivotingQRDecomposition(RealMatrix matrix) throws ConvergenceException {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Powell's BOBYQA algorithm. This implementation is translated and\n                            double[] upperBound,\n                            double initialTrustRegionRadius,\n                            double stoppingTrustRegionRadius) {\n-        this.lowerBound = lowerBound == null ? null : MathUtils.copyOf(lowerBound);\n-        this.upperBound = upperBound == null ? null : MathUtils.copyOf(upperBound);\n+        this.lowerBound = lowerBound == null ? null : MathArrays.copyOf(lowerBound);\n+        this.upperBound = upperBound == null ? null : MathArrays.copyOf(upperBound);\n         this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n         this.initialTrustRegionRadius = initialTrustRegionRadius;\n         this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.random.MersenneTwister;\n import org.apache.commons.math.random.RandomGenerator;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * <p>An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)\n                 int[] arindex = sortedIndices(fitness);\n                 // Calculate new xmean, this is selection and recombination\n                 RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n-                RealMatrix bestArx = selectColumns(arx, MathUtils.copyOf(arindex, mu));\n+                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                 xmean = bestArx.multiply(weights);\n-                RealMatrix bestArz = selectColumns(arz, MathUtils.copyOf(arindex, mu));\n+                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                 RealMatrix zmean = bestArz.multiply(weights);\n                 boolean hsig = updateEvolutionPaths(zmean, xold);\n                 if (diagonalOnly <= 0) {\n                 // prepare vectors, compute negative updating matrix Cneg\n                 int[] arReverseIndex = reverse(arindex);\n                 RealMatrix arzneg\n-                    = selectColumns(arz, MathUtils.copyOf(arReverseIndex, mu));\n+                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                 RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                 int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                 RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n             double alphaMin = 0;\n \n             for (int i = 0; i < n; i++) {\n-                final double[] d = MathUtils.copyOf(direc[i]);\n+                final double[] d = MathArrays.copyOf(direc[i]);\n \n                 fX2 = fVal;\n \n--- a/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java\n import java.io.Serializable;\n import java.util.Collection;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * A simple implementation of {@link Clusterable} for points with integer coordinates.\n \n     /** {@inheritDoc} */\n     public double distanceFrom(final EuclideanIntegerPoint p) {\n-        return MathUtils.distance(point, p.getPoint());\n+        return MathArrays.distance(point, p.getPoint());\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/stat/regression/MillerUpdatingRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/MillerUpdatingRegression.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * <p>This class is a concrete implementation of the {@link UpdatingMultipleLinearRegression} interface.</p>\n                     x.length, nvars);\n         }\n         if (!this.hasIntercept) {\n-            include(MathUtils.copyOf(x, x.length), 1.0, y);\n+            include(MathArrays.copyOf(x, x.length), 1.0, y);\n         } else {\n             double[] tmp = new double[x.length + 1];\n             System.arraycopy(x, 0, tmp, 1, x.length);\n      * @return int[] with the current order of the regressors\n      */\n     public int[] getOrderOfRegressors(){\n-        return MathUtils.copyOf(vorder);\n+        return MathArrays.copyOf(vorder);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/regression/RegressionResults.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/RegressionResults.java\n import java.io.Serializable;\n import java.util.Arrays;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n /**\n  * Results of a Multiple Linear Regression model fit.\n             final boolean containsConstant,\n             final boolean copyData) {\n         if (copyData) {\n-            this.parameters = MathUtils.copyOf(parameters);\n+            this.parameters = MathArrays.copyOf(parameters);\n             this.varCovData = new double[varcov.length][];\n             for (int i = 0; i < varcov.length; i++) {\n-                this.varCovData[i] = MathUtils.copyOf(varcov[i]);\n+                this.varCovData[i] = MathArrays.copyOf(varcov[i]);\n             }\n         } else {\n             this.parameters = parameters;\n         if (this.parameters == null) {\n             return null;\n         }\n-        return MathUtils.copyOf(parameters);\n+        return MathArrays.copyOf(parameters);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/MathArrays.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Collections;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+\n+/**\n+ * Arrays utilities.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class MathArrays {\n+    /** Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}). */\n+    private static final int SPLIT_FACTOR = 0x8000001;\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private MathArrays() {}\n+\n+    /**\n+     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>1</sub> distance between the two points\n+     */\n+    public static double distance1(double[] p1, double[] p2) {\n+        double sum = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            sum += FastMath.abs(p1[i] - p2[i]);\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>1</sub> distance between the two points\n+     */\n+    public static int distance1(int[] p1, int[] p2) {\n+      int sum = 0;\n+      for (int i = 0; i < p1.length; i++) {\n+          sum += FastMath.abs(p1[i] - p2[i]);\n+      }\n+      return sum;\n+    }\n+\n+    /**\n+     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>2</sub> distance between the two points\n+     */\n+    public static double distance(double[] p1, double[] p2) {\n+        double sum = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            final double dp = p1[i] - p2[i];\n+            sum += dp * dp;\n+        }\n+        return FastMath.sqrt(sum);\n+    }\n+\n+    /**\n+     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>2</sub> distance between the two points\n+     */\n+    public static double distance(int[] p1, int[] p2) {\n+      double sum = 0;\n+      for (int i = 0; i < p1.length; i++) {\n+          final double dp = p1[i] - p2[i];\n+          sum += dp * dp;\n+      }\n+      return FastMath.sqrt(sum);\n+    }\n+\n+    /**\n+     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>&infin;</sub> distance between the two points\n+     */\n+    public static double distanceInf(double[] p1, double[] p2) {\n+        double max = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>&infin;</sub> distance between the two points\n+     */\n+    public static int distanceInf(int[] p1, int[] p2) {\n+        int max = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Specification of ordering direction.\n+     */\n+    public static enum OrderDirection {\n+        /** Constant for increasing direction. */\n+        INCREASING,\n+        /** Constant for decreasing direction. */\n+        DECREASING\n+    }\n+\n+    /**\n+     * Check that an array is monotonically increasing or decreasing.\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @return {@code true} if sorted, {@code false} otherwise.\n+     */\n+    public static boolean isMonotonic(Comparable[] val,\n+                                      OrderDirection dir,\n+                                      boolean strict) {\n+        Comparable previous = val[0];\n+        final int max = val.length;\n+        int comp;\n+        for (int i = 1; i < max; i++) {\n+            switch (dir) {\n+            case INCREASING:\n+                comp = -val[i].compareTo(previous);\n+                if (strict) {\n+                    if (0 <= comp) {\n+                        return false;\n+                    }\n+                } else {\n+                    if ( comp > 0) {\n+                        return false;\n+                    }\n+                }\n+                break;\n+            case DECREASING:\n+                comp = val[i].compareTo(previous);\n+                if (strict) {\n+                    if (comp >= 0) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (comp > 0) {\n+                       return false;\n+                    }\n+                }\n+                break;\n+            default:\n+                // Should never happen.\n+                throw new MathInternalError();\n+            }\n+\n+            previous = val[i];\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Check that an array is monotonically increasing or decreasing.\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @return {@code true} if sorted, {@code false} otherwise.\n+     */\n+    public static boolean isMonotonic(double[] val,\n+                                      OrderDirection dir,\n+                                      boolean strict) {\n+        return checkOrder(val, dir, strict, false);\n+    }\n+\n+    /**\n+     * Check that the given array is sorted.\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @param abort Whether to throw an exception if the check fails.\n+     * @return {@code true} if the array is sorted.\n+     * @throws NonMonotonicSequenceException if the array is not sorted\n+     * and {@code abort} is {@code true}.\n+     */\n+    public static boolean checkOrder(double[] val, OrderDirection dir,\n+                                     boolean strict, boolean abort) {\n+        double previous = val[0];\n+        final int max = val.length;\n+\n+        int index;\n+        ITEM:\n+        for (index = 1; index < max; index++) {\n+            switch (dir) {\n+            case INCREASING:\n+                if (strict) {\n+                    if (val[index] <= previous) {\n+                        break ITEM;\n+                    }\n+                } else {\n+                    if (val[index] < previous) {\n+                        break ITEM;\n+                    }\n+                }\n+                break;\n+            case DECREASING:\n+                if (strict) {\n+                    if (val[index] >= previous) {\n+                        break ITEM;\n+                    }\n+                } else {\n+                    if (val[index] > previous) {\n+                        break ITEM;\n+                    }\n+                }\n+                break;\n+            default:\n+                // Should never happen.\n+                throw new MathInternalError();\n+            }\n+\n+            previous = val[index];\n+        }\n+\n+        if (index == max) {\n+            // Loop completed.\n+            return true;\n+        }\n+\n+        // Loop early exit means wrong ordering.\n+        if (abort) {\n+            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Check that the given array is sorted.\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @throws NonMonotonicSequenceException if the array is not sorted.\n+     * @since 2.2\n+     */\n+    public static void checkOrder(double[] val, OrderDirection dir,\n+                                  boolean strict) {\n+        checkOrder(val, dir, strict, true);\n+    }\n+\n+    /**\n+     * Check that the given array is sorted in strictly increasing order.\n+     *\n+     * @param val Values.\n+     * @throws NonMonotonicSequenceException if the array is not sorted.\n+     * @since 2.2\n+     */\n+    public static void checkOrder(double[] val) {\n+        checkOrder(val, OrderDirection.INCREASING, true);\n+    }\n+\n+    /**\n+     * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n+     * Translation of the minpack enorm subroutine.\n+     *\n+     * The redistribution policy for MINPACK is available\n+     * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+     * convenience, it is reproduced below.</p>\n+     *\n+     * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+     * <tr><td>\n+     *    Minpack Copyright Notice (1999) University of Chicago.\n+     *    All rights reserved\n+     * </td></tr>\n+     * <tr><td>\n+     * Redistribution and use in source and binary forms, with or without\n+     * modification, are permitted provided that the following conditions\n+     * are met:\n+     * <ol>\n+     *  <li>Redistributions of source code must retain the above copyright\n+     *      notice, this list of conditions and the following disclaimer.</li>\n+     * <li>Redistributions in binary form must reproduce the above\n+     *     copyright notice, this list of conditions and the following\n+     *     disclaimer in the documentation and/or other materials provided\n+     *     with the distribution.</li>\n+     * <li>The end-user documentation included with the redistribution, if any,\n+     *     must include the following acknowledgment:\n+     *     {@code This product includes software developed by the University of\n+     *           Chicago, as Operator of Argonne National Laboratory.}\n+     *     Alternately, this acknowledgment may appear in the software itself,\n+     *     if and wherever such third-party acknowledgments normally appear.</li>\n+     * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+     *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+     *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+     *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+     *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+     *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+     *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+     *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+     *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+     *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+     *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+     *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+     *     BE CORRECTED.</strong></li>\n+     * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+     *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+     *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+     *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+     *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+     *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+     *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+     *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+     *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+     *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+     * <ol></td></tr>\n+     * </table>\n+     *\n+     * @param v Vector of doubles.\n+     * @return the 2-norm of the vector.\n+     * @since 2.2\n+     */\n+    public static double safeNorm(double[] v) {\n+        double rdwarf = 3.834e-20;\n+        double rgiant = 1.304e+19;\n+        double s1 = 0;\n+        double s2 = 0;\n+        double s3 = 0;\n+        double x1max = 0;\n+        double x3max = 0;\n+        double floatn = (double) v.length;\n+        double agiant = rgiant / floatn;\n+        for (int i = 0; i < v.length; i++) {\n+            double xabs = Math.abs(v[i]);\n+            if (xabs < rdwarf || xabs > agiant) {\n+                if (xabs > rdwarf) {\n+                    if (xabs > x1max) {\n+                        double r = x1max / xabs;\n+                        s1= 1 + s1 * r * r;\n+                        x1max = xabs;\n+                    } else {\n+                        double r = xabs / x1max;\n+                        s1 += r * r;\n+                    }\n+                } else {\n+                    if (xabs > x3max) {\n+                        double r = x3max / xabs;\n+                        s3= 1 + s3 * r * r;\n+                        x3max = xabs;\n+                    } else {\n+                        if (xabs != 0) {\n+                            double r = xabs / x3max;\n+                            s3 += r * r;\n+                        }\n+                    }\n+                }\n+            } else {\n+                s2 += xabs * xabs;\n+            }\n+        }\n+        double norm;\n+        if (s1 != 0) {\n+            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n+        } else {\n+            if (s2 == 0) {\n+                norm = x3max * Math.sqrt(s3);\n+            } else {\n+                if (s2 >= x3max) {\n+                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n+                } else {\n+                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n+                }\n+            }\n+        }\n+        return norm;\n+    }\n+\n+    /**\n+     * Sort an array in ascending order in place and perform the same reordering\n+     * of entries on other arrays. For example, if\n+     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then\n+     * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},\n+     * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n+     *\n+     * @param x Array to be sorted and used as a pattern for permutation\n+     * of the other arrays.\n+     * @param yList Set of arrays whose permutations of entries will follow\n+     * those performed on {@code x}.\n+     * @throws DimensionMismatchException if any {@code y} is not the same\n+     * size as {@code x}.\n+     * @throws NullArgumentException if {@code x} or any {@code y} is null.\n+     * @since 3.0\n+     */\n+    public static void sortInPlace(double[] x,\n+                                   double[] ... yList) {\n+        sortInPlace(x, OrderDirection.INCREASING, yList);\n+    }\n+\n+    /**\n+     * Sort an array in place and perform the same reordering of entries on\n+     * other arrays.  This method works the same as\n+     * {@link #sortInPlace(double[], double[] ...)}, but allows the order of\n+     * the sort to be provided in the {@code dir} parameter.\n+     *\n+     * @param x Array to be sorted and used as a pattern for permutation\n+     * of the other arrays.\n+     * @param dir Order direction.\n+     * @param yList Set of arrays whose permutations of entries will follow\n+     * those performed on {@code x}.\n+     * @throws DimensionMismatchException if any {@code y} is not the same\n+     * size as {@code x}.\n+     * @throws NullArgumentException if {@code x} or any {@code y} is null\n+     * @since 3.0\n+     */\n+    public static void sortInPlace(double[] x,\n+                                   final OrderDirection dir,\n+                                   double[] ... yList) {\n+        if (x == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        final int len = x.length;\n+        final List<Pair<Double, double[]>> list\n+            = new ArrayList<Pair<Double, double[]>>(len);\n+\n+        final int yListLen = yList.length;\n+        for (int i = 0; i < len; i++) {\n+            final double[] yValues = new double[yListLen];\n+            for (int j = 0; j < yListLen; j++) {\n+                double[] y = yList[j];\n+                if (y == null) {\n+                    throw new NullArgumentException();\n+                }\n+                if (y.length != len) {\n+                    throw new DimensionMismatchException(y.length, len);\n+                }\n+                yValues[j] = y[i];\n+            }\n+            list.add(new Pair<Double, double[]>(x[i], yValues));\n+        }\n+\n+        final Comparator<Pair<Double, double[]>> comp\n+            = new Comparator<Pair<Double, double[]>>() {\n+            public int compare(Pair<Double, double[]> o1,\n+                               Pair<Double, double[]> o2) {\n+                int val;\n+                switch (dir) {\n+                case INCREASING:\n+                    val = o1.getKey().compareTo(o2.getKey());\n+                break;\n+                case DECREASING:\n+                    val = o2.getKey().compareTo(o1.getKey());\n+                break;\n+                default:\n+                    // Should never happen.\n+                    throw new MathInternalError();\n+                }\n+                return val;\n+            }\n+        };\n+\n+        Collections.sort(list, comp);\n+\n+        for (int i = 0; i < len; i++) {\n+            final Pair<Double, double[]> e = list.get(i);\n+            x[i] = e.getKey();\n+            final double[] yValues = e.getValue();\n+            for (int j = 0; j < yListLen; j++) {\n+                yList[j][i] = yValues[j];\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @return the copied array.\n+     */\n+     public static int[] copyOf(int[] source) {\n+         return copyOf(source, source.length);\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @return the copied array.\n+     */\n+     public static double[] copyOf(double[] source) {\n+         return copyOf(source, source.length);\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @param len Number of entries to copy. If smaller then the source\n+     * length, the copy will be truncated, if larger it will padded with\n+     * zeroes.\n+     * @return the copied array.\n+     */\n+    public static int[] copyOf(int[] source, int len) {\n+         final int[] output = new int[len];\n+         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n+         return output;\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @param len Number of entries to copy. If smaller then the source\n+     * length, the copy will be truncated, if larger it will padded with\n+     * zeroes.\n+     * @return the copied array.\n+     */\n+    public static double[] copyOf(double[] source, int len) {\n+         final double[] output = new double[len];\n+         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n+         return output;\n+     }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     *\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     */\n+    public static double linearCombination(final double[] a, final double[] b) {\n+        final int len = a.length;\n+        if (len != b.length) {\n+            throw new DimensionMismatchException(len, b.length);\n+        }\n+\n+        final double[] prodHigh = new double[len];\n+        double prodLowSum = 0;\n+\n+        for (int i = 0; i < len; i++) {\n+            final double ai = a[i];\n+            final double ca = SPLIT_FACTOR * ai;\n+            final double aHigh = ca - (ca - ai);\n+            final double aLow = ai - aHigh;\n+\n+            final double bi = b[i];\n+            final double cb = SPLIT_FACTOR * bi;\n+            final double bHigh = cb - (cb - bi);\n+            final double bLow = bi - bHigh;\n+            prodHigh[i] = ai * bi;\n+            final double prodLow = aLow * bLow - (((prodHigh[i] -\n+                                                    aHigh * bHigh) -\n+                                                   aLow * bHigh) -\n+                                                  aHigh * bLow);\n+            prodLowSum += prodLow;\n+        }\n+\n+\n+        final double prodHighCur = prodHigh[0];\n+        double prodHighNext = prodHigh[1];\n+        double sHighPrev = prodHighCur + prodHighNext;\n+        double sPrime = sHighPrev - prodHighNext;\n+        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n+\n+        final int lenMinusOne = len - 1;\n+        for (int i = 1; i < lenMinusOne; i++) {\n+            prodHighNext = prodHigh[i + 1];\n+            final double sHighCur = sHighPrev + prodHighNext;\n+            sPrime = sHighCur - prodHighNext;\n+            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+            sHighPrev = sHighCur;\n+        }\n+\n+        double result = sHighPrev + (prodLowSum + sLowSum);\n+\n+        if (Double.isNaN(result)) {\n+            // either we have split infinite numbers or some coefficients were NaNs,\n+            // just rely on the naive implementation and let IEEE754 handle this\n+            result = 0;\n+            for (int i = 0; i < len; ++i) {\n+                result += a[i] * b[i];\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n+     * so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects. It is based\n+     * on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(double, double, double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // use IEEE754 floating point arithmetic rounding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variable naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // final rounding, s12 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        double result = s12High + (prod1Low + prod2Low + s12Low);\n+\n+        if (Double.isNaN(result)) {\n+            // either we have split infinite numbers or some coefficients were NaNs,\n+            // just rely on the naive implementation and let IEEE754 handle this\n+            result = a1 * b1 + a2 * b2;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2,\n+                                           final double a3, final double b3) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // do use IEEE754 floating point arithmetic rounding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variables naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // split a3 and b3 as two 26 bits numbers\n+        final double ca3        = SPLIT_FACTOR * a3;\n+        final double a3High     = ca3 - (ca3 - a3);\n+        final double a3Low      = a3 - a3High;\n+        final double cb3        = SPLIT_FACTOR * b3;\n+        final double b3High     = cb3 - (cb3 - b3);\n+        final double b3Low      = b3 - b3High;\n+\n+        // accurate multiplication a3 * b3\n+        final double prod3High  = a3 * b3;\n+        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n+        final double s123High   = s12High + prod3High;\n+        final double s123Prime  = s123High - prod3High;\n+        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n+\n+        // final rounding, s123 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n+\n+        if (Double.isNaN(result)) {\n+            // either we have split infinite numbers or some coefficients were NaNs,\n+            // just rely on the naive implementation and let IEEE754 handle this\n+            result = a1 * b1 + a2 * b2 + a3 * b3;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(double, double, double, double)\n+     * @see #linearCombination(double, double, double, double, double, double)\n+     */\n+    public static double linearCombination(final double a1, final double b1,\n+                                           final double a2, final double b2,\n+                                           final double a3, final double b3,\n+                                           final double a4, final double b4) {\n+\n+        // the code below is split in many additions/subtractions that may\n+        // appear redundant. However, they should NOT be simplified, as they\n+        // do use IEEE754 floating point arithmetic rounding properties.\n+        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n+        // The variables naming conventions are that xyzHigh contains the most significant\n+        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n+        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n+        // be represented in only one double precision number so we preserve two numbers\n+        // to hold it as long as we can, combining the high and low order bits together\n+        // only at the end, after cancellation may have occurred on high order bits\n+\n+        // split a1 and b1 as two 26 bits numbers\n+        final double ca1        = SPLIT_FACTOR * a1;\n+        final double a1High     = ca1 - (ca1 - a1);\n+        final double a1Low      = a1 - a1High;\n+        final double cb1        = SPLIT_FACTOR * b1;\n+        final double b1High     = cb1 - (cb1 - b1);\n+        final double b1Low      = b1 - b1High;\n+\n+        // accurate multiplication a1 * b1\n+        final double prod1High  = a1 * b1;\n+        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n+\n+        // split a2 and b2 as two 26 bits numbers\n+        final double ca2        = SPLIT_FACTOR * a2;\n+        final double a2High     = ca2 - (ca2 - a2);\n+        final double a2Low      = a2 - a2High;\n+        final double cb2        = SPLIT_FACTOR * b2;\n+        final double b2High     = cb2 - (cb2 - b2);\n+        final double b2Low      = b2 - b2High;\n+\n+        // accurate multiplication a2 * b2\n+        final double prod2High  = a2 * b2;\n+        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n+\n+        // split a3 and b3 as two 26 bits numbers\n+        final double ca3        = SPLIT_FACTOR * a3;\n+        final double a3High     = ca3 - (ca3 - a3);\n+        final double a3Low      = a3 - a3High;\n+        final double cb3        = SPLIT_FACTOR * b3;\n+        final double b3High     = cb3 - (cb3 - b3);\n+        final double b3Low      = b3 - b3High;\n+\n+        // accurate multiplication a3 * b3\n+        final double prod3High  = a3 * b3;\n+        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n+\n+        // split a4 and b4 as two 26 bits numbers\n+        final double ca4        = SPLIT_FACTOR * a4;\n+        final double a4High     = ca4 - (ca4 - a4);\n+        final double a4Low      = a4 - a4High;\n+        final double cb4        = SPLIT_FACTOR * b4;\n+        final double b4High     = cb4 - (cb4 - b4);\n+        final double b4Low      = b4 - b4High;\n+\n+        // accurate multiplication a4 * b4\n+        final double prod4High  = a4 * b4;\n+        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n+\n+        // accurate addition a1 * b1 + a2 * b2\n+        final double s12High    = prod1High + prod2High;\n+        final double s12Prime   = s12High - prod2High;\n+        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n+        final double s123High   = s12High + prod3High;\n+        final double s123Prime  = s123High - prod3High;\n+        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n+\n+        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n+        final double s1234High  = s123High + prod4High;\n+        final double s1234Prime = s1234High - prod4High;\n+        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n+\n+        // final rounding, s1234 may have suffered many cancellations, we try\n+        // to recover some bits from the extra words we have saved up to now\n+        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n+\n+        if (Double.isNaN(result)) {\n+            // either we have split infinite numbers or some coefficients were NaNs,\n+            // just rely on the naive implementation and let IEEE754 handle this\n+            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n+        }\n+\n+        return result;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-\n-import org.apache.commons.math.exception.DimensionMismatchException;\n+\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.MathInternalError;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n                479001600l,         6227020800l,         87178291200l,\n            1307674368000l,     20922789888000l,     355687428096000l,\n         6402373705728000l, 121645100408832000l, 2432902008176640000l };\n-\n-    /** Factor used for splitting double numbers: n = 2^27 + 1. */\n-    private static final int SPLIT_FACTOR = 0x8000001;\n \n     /**\n      * Private Constructor\n     }\n \n     /**\n-     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>1</sub> distance between the two points\n-     */\n-    public static double distance1(double[] p1, double[] p2) {\n-        double sum = 0;\n-        for (int i = 0; i < p1.length; i++) {\n-            sum += FastMath.abs(p1[i] - p2[i]);\n-        }\n-        return sum;\n-    }\n-\n-    /**\n-     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>1</sub> distance between the two points\n-     */\n-    public static int distance1(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          sum += FastMath.abs(p1[i] - p2[i]);\n-      }\n-      return sum;\n-    }\n-\n-    /**\n-     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>2</sub> distance between the two points\n-     */\n-    public static double distance(double[] p1, double[] p2) {\n-        double sum = 0;\n-        for (int i = 0; i < p1.length; i++) {\n-            final double dp = p1[i] - p2[i];\n-            sum += dp * dp;\n-        }\n-        return FastMath.sqrt(sum);\n-    }\n-\n-    /**\n-     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>2</sub> distance between the two points\n-     */\n-    public static double distance(int[] p1, int[] p2) {\n-      double sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final double dp = p1[i] - p2[i];\n-          sum += dp * dp;\n-      }\n-      return FastMath.sqrt(sum);\n-    }\n-\n-    /**\n-     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>&infin;</sub> distance between the two points\n-     */\n-    public static double distanceInf(double[] p1, double[] p2) {\n-        double max = 0;\n-        for (int i = 0; i < p1.length; i++) {\n-            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n-        }\n-        return max;\n-    }\n-\n-    /**\n-     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n-     *\n-     * @param p1 the first point\n-     * @param p2 the second point\n-     * @return the L<sub>&infin;</sub> distance between the two points\n-     */\n-    public static int distanceInf(int[] p1, int[] p2) {\n-        int max = 0;\n-        for (int i = 0; i < p1.length; i++) {\n-            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n-        }\n-        return max;\n-    }\n-\n-    /**\n-     * Specification of ordering direction.\n-     */\n-    public static enum OrderDirection {\n-        /** Constant for increasing direction. */\n-        INCREASING,\n-        /** Constant for decreasing direction. */\n-        DECREASING\n-    }\n-\n-    /**\n-     * Check that an array is monotone increasing or decreasing.\n-     *\n-     * @param val Values.\n-     * @param dir Ordering direction.\n-     * @param strict Whether the order should be strict.\n-     * @return {@code true} if sorted, {@code false} otherwise.\n-     */\n-    public static boolean isMonotone(Comparable[] val,\n-                                     OrderDirection dir,\n-                                     boolean strict){\n-        Comparable previous = val[0];\n-        final int max = val.length;\n-        int comp;\n-        for (int i = 1; i < max; i++) {\n-            switch (dir) {\n-            case INCREASING:\n-                comp = -val[i].compareTo(previous);\n-                if (strict) {\n-                    if (0 <= comp) {\n-                        return false;\n-                    }\n-                } else {\n-                    if ( comp > 0) {\n-                        return false;\n-                    }\n-                }\n-                break;\n-            case DECREASING:\n-                comp = val[i].compareTo(previous);\n-                if (strict) {\n-                    if (comp >= 0) {\n-                        return false;\n-                    }\n-                } else {\n-                    if (comp > 0) {\n-                       return false;\n-                    }\n-                }\n-                break;\n-            default:\n-                // Should never happen.\n-                throw new MathInternalError();\n-            }\n-\n-            previous = val[i];\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Check that an array is monotone increasing or decreasing.\n-     *\n-     * @param val Values.\n-     * @param dir Ordering direction.\n-     * @param strict Whether the order should be strict.\n-     * @return {@code true} if sorted, {@code false} otherwise.\n-     */\n-    public static boolean isMonotone(double[] val,\n-                                     OrderDirection dir,\n-                                     boolean strict){\n-        double previous = val[0];\n-        final int max = val.length;\n-        for (int i = 1; i < max; i++) {\n-            switch (dir) {\n-            case INCREASING:\n-                if (strict) {\n-                    if (val[i] <= previous) {\n-                        return false;\n-                    }\n-                } else {\n-                    if (val[i] < previous) {\n-                        return false;\n-                    }\n-                }\n-                break;\n-            case DECREASING:\n-                if (strict) {\n-                    if (val[i] >= previous) {\n-                        return false;\n-                    }\n-                } else {\n-                    if (val[i] > previous) {\n-                        return false;\n-                    }\n-                }\n-                break;\n-            default:\n-                // Should never happen.\n-                throw new MathInternalError();\n-            }\n-            previous = val[i];\n-        }\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Check that the given array is sorted.\n-     *\n-     * @param val Values.\n-     * @param dir Ordering direction.\n-     * @param strict Whether the order should be strict.\n-     * @param abort Whether to throw an exception if the check fails.\n-     * @return {@code true} if the array is sorted.\n-     * @throws NonMonotonicSequenceException if the array is not sorted\n-     * and {@code abort} is {@code true}.\n-     */\n-    public static boolean checkOrder(double[] val, OrderDirection dir,\n-                                     boolean strict, boolean abort) {\n-        double previous = val[0];\n-        final int max = val.length;\n-\n-        int index;\n-        ITEM:\n-        for (index = 1; index < max; index++) {\n-            switch (dir) {\n-            case INCREASING:\n-                if (strict) {\n-                    if (val[index] <= previous) {\n-                        break ITEM;\n-                    }\n-                } else {\n-                    if (val[index] < previous) {\n-                        break ITEM;\n-                    }\n-                }\n-                break;\n-            case DECREASING:\n-                if (strict) {\n-                    if (val[index] >= previous) {\n-                        break ITEM;\n-                    }\n-                } else {\n-                    if (val[index] > previous) {\n-                        break ITEM;\n-                    }\n-                }\n-                break;\n-            default:\n-                // Should never happen.\n-                throw new MathInternalError();\n-            }\n-            previous = val[index];\n-        }\n-\n-        if (index == max) {\n-            // Loop completed.\n-            return true;\n-        }\n-\n-        // Loop early exit means wrong ordering.\n-        if (abort) {\n-            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Check that the given array is sorted.\n-     *\n-     * @param val Values.\n-     * @param dir Ordering direction.\n-     * @param strict Whether the order should be strict.\n-     * @throws NonMonotonicSequenceException if the array is not sorted.\n-     * @since 2.2\n-     */\n-    public static void checkOrder(double[] val, OrderDirection dir,\n-                                  boolean strict) {\n-        checkOrder(val, dir, strict, true);\n-    }\n-\n-    /**\n-     * Check that the given array is sorted in strictly increasing order.\n-     *\n-     * @param val Values.\n-     * @throws NonMonotonicSequenceException if the array is not sorted.\n-     * @since 2.2\n-     */\n-    public static void checkOrder(double[] val) {\n-        checkOrder(val, OrderDirection.INCREASING, true);\n-    }\n-\n-    /**\n      * Check that the argument is a real number.\n      *\n      * @param x Argument.\n     }\n \n     /**\n-     * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n-     * Translation of the minpack enorm subroutine.\n-     *\n-     * The redistribution policy for MINPACK is available <a\n-     * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n-     * is reproduced below.</p>\n-     *\n-     * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n-     * <tr><td>\n-     *    Minpack Copyright Notice (1999) University of Chicago.\n-     *    All rights reserved\n-     * </td></tr>\n-     * <tr><td>\n-     * Redistribution and use in source and binary forms, with or without\n-     * modification, are permitted provided that the following conditions\n-     * are met:\n-     * <ol>\n-     *  <li>Redistributions of source code must retain the above copyright\n-     *      notice, this list of conditions and the following disclaimer.</li>\n-     * <li>Redistributions in binary form must reproduce the above\n-     *     copyright notice, this list of conditions and the following\n-     *     disclaimer in the documentation and/or other materials provided\n-     *     with the distribution.</li>\n-     * <li>The end-user documentation included with the redistribution, if any,\n-     *     must include the following acknowledgment:\n-     *     {@code This product includes software developed by the University of\n-     *           Chicago, as Operator of Argonne National Laboratory.}\n-     *     Alternately, this acknowledgment may appear in the software itself,\n-     *     if and wherever such third-party acknowledgments normally appear.</li>\n-     * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n-     *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n-     *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n-     *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n-     *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n-     *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n-     *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n-     *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n-     *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n-     *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n-     *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n-     *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n-     *     BE CORRECTED.</strong></li>\n-     * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n-     *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n-     *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n-     *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n-     *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n-     *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n-     *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n-     *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n-     *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n-     *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n-     * <ol></td></tr>\n-     * </table>\n-     *\n-     * @param v vector of doubles\n-     * @return the 2-norm of the vector\n-     * @since 2.2\n-     */\n-    public static double safeNorm(double[] v) {\n-        double rdwarf = 3.834e-20;\n-        double rgiant = 1.304e+19;\n-        double s1 = 0;\n-        double s2 = 0;\n-        double s3 = 0;\n-        double x1max = 0;\n-        double x3max = 0;\n-        double floatn = (double) v.length;\n-        double agiant = rgiant / floatn;\n-        for (int i = 0; i < v.length; i++) {\n-            double xabs = Math.abs(v[i]);\n-            if (xabs < rdwarf || xabs > agiant) {\n-                if (xabs > rdwarf) {\n-                    if (xabs > x1max) {\n-                        double r = x1max / xabs;\n-                        s1= 1 + s1 * r * r;\n-                        x1max = xabs;\n-                    } else {\n-                        double r = xabs / x1max;\n-                        s1 += r * r;\n-                    }\n-                } else {\n-                    if (xabs > x3max) {\n-                        double r = x3max / xabs;\n-                        s3= 1 + s3 * r * r;\n-                        x3max = xabs;\n-                    } else {\n-                        if (xabs != 0) {\n-                            double r = xabs / x3max;\n-                            s3 += r * r;\n-                        }\n-                    }\n-                }\n-            } else {\n-                s2 += xabs * xabs;\n-            }\n-        }\n-        double norm;\n-        if (s1 != 0) {\n-            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n-        } else {\n-            if (s2 == 0) {\n-                norm = x3max * Math.sqrt(s3);\n-            } else {\n-                if (s2 >= x3max) {\n-                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n-                } else {\n-                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n-                }\n-            }\n-        }\n-        return norm;\n-    }\n-\n-    /**\n-     * Sort an array in ascending order in place and perform the same reordering\n-     * of entries on other arrays. For example, if\n-     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then \n-     * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},\n-     * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n-     *\n-     * @param x Array to be sorted and used as a pattern for permutation\n-     * of the other arrays.\n-     * @param yList Set of arrays whose permutations of entries will follow\n-     * those performed on {@code x}.\n-     * @throws DimensionMismatchException if any {@code y} is not the same\n-     * size as {@code x}.\n-     * @throws NullArgumentException if {@code x} or any {@code y} is null.\n-     * @since 3.0\n-     */\n-    public static void sortInPlace(double[] x,\n-                                   double[] ... yList) {\n-        sortInPlace(x, OrderDirection.INCREASING, yList);\n-    }\n-\n-    /**\n-     * Sort an array in place and perform the same reordering of entries on\n-     * other arrays.  This method works the same as\n-     * {@link #sortInPlace(double[], double[]...)}, but allows the order of the\n-     * sort to be provided in the {@code dir} parameter.\n-     * \n-     * @param x Array to be sorted and used as a pattern for permutation\n-     * of the other arrays.\n-     * @param dir Order direction.\n-     * @param yList Set of arrays whose permutations of entries will follow\n-     * those performed on {@code x}.\n-     * @throws DimensionMismatchException if any {@code y} is not the same\n-     * size as {@code x}.\n-     * @throws NullArgumentException if {@code x} or any {@code y} is null\n-     * @since 3.0\n-     */\n-    public static void sortInPlace(double[] x,\n-                                   final OrderDirection dir,\n-                                   double[] ... yList) {\n-        if (x == null) {\n-            throw new NullArgumentException();\n-        }\n-\n-        final int len = x.length;\n-        final List<Pair<Double, double[]>> list\n-            = new ArrayList<Pair<Double, double[]>>(len);\n-\n-        final int yListLen = yList.length;\n-        for (int i = 0; i < len; i++) {\n-            final double[] yValues = new double[yListLen];\n-            for (int j = 0; j < yListLen; j++) {\n-                double[] y = yList[j];\n-                if (y == null) {\n-                    throw new NullArgumentException();\n-                }\n-                if (y.length != len) {\n-                    throw new DimensionMismatchException(y.length, len);\n-                }\n-                yValues[j] = y[i];\n-            }\n-            list.add(new Pair<Double, double[]>(x[i], yValues));\n-        }\n-\n-        final Comparator<Pair<Double, double[]>> comp\n-            = new Comparator<Pair<Double, double[]>>() {\n-            public int compare(Pair<Double, double[]> o1,\n-                               Pair<Double, double[]> o2) {\n-                int val;\n-                switch (dir) {\n-                case INCREASING:\n-                    val = o1.getKey().compareTo(o2.getKey());\n-                break;\n-                case DECREASING:\n-                    val = o2.getKey().compareTo(o1.getKey());\n-                break;\n-                default:\n-                    // Should never happen.\n-                    throw new MathInternalError();\n-                }\n-                return val;\n-            }\n-        };\n-\n-        Collections.sort(list, comp);\n-\n-        for (int i = 0; i < len; i++) {\n-            final Pair<Double, double[]> e = list.get(i);\n-            x[i] = e.getKey();\n-            final double[] yValues = e.getValue();\n-            for (int j = 0; j < yListLen; j++) {\n-                yList[j][i] = yValues[j];\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Creates a copy of the {@code source} array.\n-     *\n-     * @param source Array to be copied.\n-     * @return the copied array.\n-     */\n-     public static int[] copyOf(int[] source) {\n-         return copyOf(source, source.length);\n-     }\n-\n-    /**\n-     * Creates a copy of the {@code source} array.\n-     *\n-     * @param source Array to be copied.\n-     * @return the copied array.\n-     */\n-     public static double[] copyOf(double[] source) {\n-         return copyOf(source, source.length);\n-     }\n-\n-    /**\n-     * Creates a copy of the {@code source} array.\n-     *\n-     * @param source Array to be copied.\n-     * @param len Number of entries to copy. If smaller then the source\n-     * length, the copy will be truncated, if larger it will padded with\n-     * zeroes.\n-     * @return the copied array.\n-     */\n-    public static int[] copyOf(int[] source, int len) {\n-         final int[] output = new int[len];\n-         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n-         return output;\n-     }\n-\n-    /**\n-     * Creates a copy of the {@code source} array.\n-     *\n-     * @param source Array to be copied.\n-     * @param len Number of entries to copy. If smaller then the source\n-     * length, the copy will be truncated, if larger it will padded with\n-     * zeroes.\n-     * @return the copied array.\n-     */\n-    public static double[] copyOf(double[] source, int len) {\n-         final double[] output = new double[len];\n-         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n-         return output;\n-     }\n-\n-    /**\n      * Checks that an object is not null.\n      *\n      * @param o Object to be checked.\n             throw new NullArgumentException();\n         }\n     }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n-     * so by using specific multiplication and addition algorithms to\n-     * preserve accuracy and reduce cancellation effects. It is based\n-     * on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub>\n-     * @see #linearCombination(double, double, double, double, double, double)\n-     * @see #linearCombination(double, double, double, double, double, double, double, double)\n-     */\n-    public static double linearCombination(final double a1, final double b1,\n-                                           final double a2, final double b2) {\n-\n-        // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they should NOT be simplified, as they\n-        // use IEEE754 floating point arithmetic rounding properties.\n-        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n-        // The variable naming conventions are that xyzHigh contains the most significant\n-        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n-        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n-        // be represented in only one double precision number so we preserve two numbers\n-        // to hold it as long as we can, combining the high and low order bits together\n-        // only at the end, after cancellation may have occurred on high order bits\n-\n-        // split a1 and b1 as two 26 bits numbers\n-        final double ca1        = SPLIT_FACTOR * a1;\n-        final double a1High     = ca1 - (ca1 - a1);\n-        final double a1Low      = a1 - a1High;\n-        final double cb1        = SPLIT_FACTOR * b1;\n-        final double b1High     = cb1 - (cb1 - b1);\n-        final double b1Low      = b1 - b1High;\n-\n-        // accurate multiplication a1 * b1\n-        final double prod1High  = a1 * b1;\n-        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n-\n-        // split a2 and b2 as two 26 bits numbers\n-        final double ca2        = SPLIT_FACTOR * a2;\n-        final double a2High     = ca2 - (ca2 - a2);\n-        final double a2Low      = a2 - a2High;\n-        final double cb2        = SPLIT_FACTOR * b2;\n-        final double b2High     = cb2 - (cb2 - b2);\n-        final double b2Low      = b2 - b2High;\n-\n-        // accurate multiplication a2 * b2\n-        final double prod2High  = a2 * b2;\n-        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n-\n-        // accurate addition a1 * b1 + a2 * b2\n-        final double s12High    = prod1High + prod2High;\n-        final double s12Prime   = s12High - prod2High;\n-        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n-\n-        // final rounding, s12 may have suffered many cancellations, we try\n-        // to recover some bits from the extra words we have saved up to now\n-        double result = s12High + (prod1Low + prod2Low + s12Low);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = a1 * b1 + a2 * b2;\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * @see #linearCombination(double, double, double, double)\n-     * @see #linearCombination(double, double, double, double, double, double, double, double)\n-     */\n-    public static double linearCombination(final double a1, final double b1,\n-                                           final double a2, final double b2,\n-                                           final double a3, final double b3) {\n-\n-        // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they should NOT be simplified, as they\n-        // do use IEEE754 floating point arithmetic rounding properties.\n-        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n-        // The variables naming conventions are that xyzHigh contains the most significant\n-        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n-        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n-        // be represented in only one double precision number so we preserve two numbers\n-        // to hold it as long as we can, combining the high and low order bits together\n-        // only at the end, after cancellation may have occurred on high order bits\n-\n-        // split a1 and b1 as two 26 bits numbers\n-        final double ca1        = SPLIT_FACTOR * a1;\n-        final double a1High     = ca1 - (ca1 - a1);\n-        final double a1Low      = a1 - a1High;\n-        final double cb1        = SPLIT_FACTOR * b1;\n-        final double b1High     = cb1 - (cb1 - b1);\n-        final double b1Low      = b1 - b1High;\n-\n-        // accurate multiplication a1 * b1\n-        final double prod1High  = a1 * b1;\n-        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n-\n-        // split a2 and b2 as two 26 bits numbers\n-        final double ca2        = SPLIT_FACTOR * a2;\n-        final double a2High     = ca2 - (ca2 - a2);\n-        final double a2Low      = a2 - a2High;\n-        final double cb2        = SPLIT_FACTOR * b2;\n-        final double b2High     = cb2 - (cb2 - b2);\n-        final double b2Low      = b2 - b2High;\n-\n-        // accurate multiplication a2 * b2\n-        final double prod2High  = a2 * b2;\n-        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n-\n-        // split a3 and b3 as two 26 bits numbers\n-        final double ca3        = SPLIT_FACTOR * a3;\n-        final double a3High     = ca3 - (ca3 - a3);\n-        final double a3Low      = a3 - a3High;\n-        final double cb3        = SPLIT_FACTOR * b3;\n-        final double b3High     = cb3 - (cb3 - b3);\n-        final double b3Low      = b3 - b3High;\n-\n-        // accurate multiplication a3 * b3\n-        final double prod3High  = a3 * b3;\n-        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n-\n-        // accurate addition a1 * b1 + a2 * b2\n-        final double s12High    = prod1High + prod2High;\n-        final double s12Prime   = s12High - prod2High;\n-        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n-\n-        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n-        final double s123High   = s12High + prod3High;\n-        final double s123Prime  = s123High - prod3High;\n-        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n-\n-        // final rounding, s123 may have suffered many cancellations, we try\n-        // to recover some bits from the extra words we have saved up to now\n-        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = a1 * b1 + a2 * b2 + a3 * b3;\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * <p>\n-     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * to high accuracy. It does so by using specific multiplication and\n-     * addition algorithms to preserve accuracy and reduce cancellation effects.\n-     * It is based on the 2005 paper <a\n-     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n-     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     * </p>\n-     * @param a1 first factor of the first term\n-     * @param b1 second factor of the first term\n-     * @param a2 first factor of the second term\n-     * @param b2 second factor of the second term\n-     * @param a3 first factor of the third term\n-     * @param b3 second factor of the third term\n-     * @param a4 first factor of the third term\n-     * @param b4 second factor of the third term\n-     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n-     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n-     * a<sub>4</sub>&times;b<sub>4</sub>\n-     * @see #linearCombination(double, double, double, double)\n-     * @see #linearCombination(double, double, double, double, double, double)\n-     */\n-    public static double linearCombination(final double a1, final double b1,\n-                                           final double a2, final double b2,\n-                                           final double a3, final double b3,\n-                                           final double a4, final double b4) {\n-\n-        // the code below is split in many additions/subtractions that may\n-        // appear redundant. However, they should NOT be simplified, as they\n-        // do use IEEE754 floating point arithmetic rounding properties.\n-        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n-        // The variables naming conventions are that xyzHigh contains the most significant\n-        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n-        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n-        // be represented in only one double precision number so we preserve two numbers\n-        // to hold it as long as we can, combining the high and low order bits together\n-        // only at the end, after cancellation may have occurred on high order bits\n-\n-        // split a1 and b1 as two 26 bits numbers\n-        final double ca1        = SPLIT_FACTOR * a1;\n-        final double a1High     = ca1 - (ca1 - a1);\n-        final double a1Low      = a1 - a1High;\n-        final double cb1        = SPLIT_FACTOR * b1;\n-        final double b1High     = cb1 - (cb1 - b1);\n-        final double b1Low      = b1 - b1High;\n-\n-        // accurate multiplication a1 * b1\n-        final double prod1High  = a1 * b1;\n-        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n-\n-        // split a2 and b2 as two 26 bits numbers\n-        final double ca2        = SPLIT_FACTOR * a2;\n-        final double a2High     = ca2 - (ca2 - a2);\n-        final double a2Low      = a2 - a2High;\n-        final double cb2        = SPLIT_FACTOR * b2;\n-        final double b2High     = cb2 - (cb2 - b2);\n-        final double b2Low      = b2 - b2High;\n-\n-        // accurate multiplication a2 * b2\n-        final double prod2High  = a2 * b2;\n-        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n-\n-        // split a3 and b3 as two 26 bits numbers\n-        final double ca3        = SPLIT_FACTOR * a3;\n-        final double a3High     = ca3 - (ca3 - a3);\n-        final double a3Low      = a3 - a3High;\n-        final double cb3        = SPLIT_FACTOR * b3;\n-        final double b3High     = cb3 - (cb3 - b3);\n-        final double b3Low      = b3 - b3High;\n-\n-        // accurate multiplication a3 * b3\n-        final double prod3High  = a3 * b3;\n-        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n-\n-        // split a4 and b4 as two 26 bits numbers\n-        final double ca4        = SPLIT_FACTOR * a4;\n-        final double a4High     = ca4 - (ca4 - a4);\n-        final double a4Low      = a4 - a4High;\n-        final double cb4        = SPLIT_FACTOR * b4;\n-        final double b4High     = cb4 - (cb4 - b4);\n-        final double b4Low      = b4 - b4High;\n-\n-        // accurate multiplication a4 * b4\n-        final double prod4High  = a4 * b4;\n-        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n-\n-        // accurate addition a1 * b1 + a2 * b2\n-        final double s12High    = prod1High + prod2High;\n-        final double s12Prime   = s12High - prod2High;\n-        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n-\n-        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n-        final double s123High   = s12High + prod3High;\n-        final double s123Prime  = s123High - prod3High;\n-        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n-\n-        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n-        final double s1234High  = s123High + prod4High;\n-        final double s1234Prime = s1234High - prod4High;\n-        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n-\n-        // final rounding, s1234 may have suffered many cancellations, we try\n-        // to recover some bits from the extra words we have saved up to now\n-        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    /**\n-     * Compute a linear combination accurately.\n-     * This method computes the sum of the products\n-     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n-     * It does so by using specific multiplication and addition algorithms to\n-     * preserve accuracy and reduce cancellation effects.\n-     * <br/>\n-     * It is based on the 2005 paper\n-     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n-     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n-     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n-     *\n-     * @param a Factors.\n-     * @param b Factors.\n-     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n-     */\n-    public static double linearCombination(final double[] a, final double[] b) {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n-\n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n-\n-        for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n-\n-\n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n-\n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n-        }\n-\n-        double result = sHighPrev + (prodLowSum + sLowSum);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Converter between unidimensional storage structure and multidimensional\n          * @return the indices within the multidimensional counter.\n          */\n         public int[] getCounts() {\n-            return MathUtils.copyOf(counter);\n+            return MathArrays.copyOf(counter);\n         }\n \n         /**\n      */\n     public MultidimensionalCounter(int ... size) {\n         dimension = size.length;\n-        this.size = MathUtils.copyOf(size);\n+        this.size = MathArrays.copyOf(size);\n \n         uniCounterOffset = new int[dimension];\n \n      * @return the sizes of the multidimensional counter in each dimension.\n      */\n     public int[] getSizes() {\n-        return MathUtils.copyOf(size);\n+        return MathArrays.copyOf(size);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math/util/Precision.java\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n \n     /**\n-     * Private Constructor\n+     * Private constructor.\n      */\n     private Precision() {}\n \n--- a/src/test/java/org/apache/commons/math/exception/NonMonotonicSequenceExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/exception/NonMonotonicSequenceExceptionTest.java\n  */\n package org.apache.commons.math.exception;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n \n import org.junit.Assert;\n import org.junit.Test;\n     @Test\n     public void testAccessors() {\n         NonMonotonicSequenceException e\n-            = new NonMonotonicSequenceException(0, -1, 1, MathUtils.OrderDirection.DECREASING, false);\n+            = new NonMonotonicSequenceException(0, -1, 1, MathArrays.OrderDirection.DECREASING, false);\n         Assert.assertEquals(0, e.getArgument());\n         Assert.assertEquals(-1, e.getPrevious());\n         Assert.assertEquals(1, e.getIndex());\n-        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.DECREASING);\n+        Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.DECREASING);\n         Assert.assertFalse(e.getStrict());\n \n         e = new NonMonotonicSequenceException(-1, 0, 1);\n         Assert.assertEquals(-1, e.getArgument());\n         Assert.assertEquals(0, e.getPrevious());\n         Assert.assertEquals(1, e.getIndex());\n-        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.INCREASING);\n+        Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.INCREASING);\n         Assert.assertTrue(e.getStrict());\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/MathArraysTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.Arrays;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.random.Well1024a;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for the {@link MathArrays} class.\n+ *\n+ * @version $Id$\n+ */\n+public class MathArraysTest {\n+    @Test\n+    public void testL1DistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        Assert.assertTrue(Precision.equals(7.0, MathArrays.distance1(p1, p2), 1));\n+    }\n+\n+    @Test\n+    public void testL1DistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        Assert.assertEquals(7, MathArrays.distance1(p1, p2));\n+    }\n+\n+    @Test\n+    public void testL2DistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        Assert.assertTrue(Precision.equals(5.0, MathArrays.distance(p1, p2), 1));\n+    }\n+\n+    @Test\n+    public void testL2DistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        Assert.assertTrue(Precision.equals(5, MathArrays.distance(p1, p2), 1));\n+    }\n+\n+    @Test\n+    public void testLInfDistanceDouble() {\n+        double[] p1 = { 2.5,  0.0 };\n+        double[] p2 = { -0.5, 4.0 };\n+        Assert.assertTrue(Precision.equals(4.0, MathArrays.distanceInf(p1, p2), 1));\n+    }\n+\n+    @Test\n+    public void testLInfDistanceInt() {\n+        int[] p1 = { 3, 0 };\n+        int[] p2 = { 0, 4 };\n+        Assert.assertEquals(4, MathArrays.distanceInf(p1, p2));\n+    }\n+\n+    @Test\n+    public void testCheckOrder() {\n+        MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 15},\n+                             MathArrays.OrderDirection.INCREASING, true);\n+        MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 2},\n+                             MathArrays.OrderDirection.INCREASING, false);\n+        MathArrays.checkOrder(new double[] {3, -5.5, -11, -27.5},\n+                             MathArrays.OrderDirection.DECREASING, true);\n+        MathArrays.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},\n+                             MathArrays.OrderDirection.DECREASING, false);\n+\n+        try {\n+            MathArrays.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},\n+                                 MathArrays.OrderDirection.INCREASING, true);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonMonotonicSequenceException e) {\n+            // Expected\n+        }\n+        try {\n+            MathArrays.checkOrder(new double[] {-15, -5.5, -1, -2, 2},\n+                                 MathArrays.OrderDirection.INCREASING, false);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonMonotonicSequenceException e) {\n+            // Expected\n+        }\n+        try {\n+            MathArrays.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},\n+                                 MathArrays.OrderDirection.DECREASING, true);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonMonotonicSequenceException e) {\n+            // Expected\n+        }\n+        try {\n+            MathArrays.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},\n+                                 MathArrays.OrderDirection.DECREASING, false);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonMonotonicSequenceException e) {\n+            // Expected\n+        }\n+        try {\n+            MathArrays.checkOrder(new double[] {3, 0, -5.5, -11, -10},\n+                                 MathArrays.OrderDirection.DECREASING, false);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NonMonotonicSequenceException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testIsMonotone() {\n+        if(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2, 15 },\n+                                MathArrays.OrderDirection.INCREASING, true)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -2, 2 },\n+                                MathArrays.OrderDirection.INCREASING, false)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathArrays.isMonotonic(new double[] { 3, 3, -5.5, -11, -27.5 },\n+                                MathArrays.OrderDirection.DECREASING, true)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+        if( MathArrays.isMonotonic(new double[] { 3, -1, 0, -5.5, -11, -27.5 },\n+                                 MathArrays.OrderDirection.DECREASING, false)) {\n+        Assert.fail(\"an exception should have been thrown\");\n+        }\n+    }\n+\n+    @Test\n+    public void testIsMonotoneComparable() {\n+        if (MathArrays.isMonotonic(new Double[] { new Double(-15),\n+                                                new Double(-5.5),\n+                                                new Double(-1),\n+                                                new Double(-1),\n+                                                new Double(2),\n+                                                new Double(15)},\n+                MathArrays.OrderDirection.INCREASING, true)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if (MathArrays.isMonotonic(new Double[] { new Double(-15),\n+                                                new Double(-5.5),\n+                                                new Double(-1),\n+                                                new Double(-2),\n+                                                new Double(2)},\n+                MathArrays.OrderDirection.INCREASING, false)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if (MathArrays.isMonotonic(new Double[] { new Double(3),\n+                                                new Double(3),\n+                                                new Double(-5.5),\n+                                                new Double(-11),\n+                                                new Double(-27.5)},\n+                MathArrays.OrderDirection.DECREASING, true)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+        if (MathArrays.isMonotonic(new Double[] {new Double(3),\n+                                               new Double(-1),\n+                                               new Double(0),\n+                                               new Double(-5.5),\n+                                               new Double(-11),\n+                                               new Double(-27.5)},\n+                MathArrays.OrderDirection.DECREASING, false)) {\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+    }\n+\n+    @Test\n+    public void testSortInPlace() {\n+        final double[] x1 = {2,   5,  -3, 1,  4};\n+        final double[] x2 = {4,  25,   9, 1, 16};\n+        final double[] x3 = {8, 125, -27, 1, 64};\n+\n+        MathArrays.sortInPlace(x1, x2, x3);\n+\n+        Assert.assertEquals(-3,  x1[0], Math.ulp(1d));\n+        Assert.assertEquals(9,   x2[0], Math.ulp(1d));\n+        Assert.assertEquals(-27, x3[0], Math.ulp(1d));\n+\n+        Assert.assertEquals(1, x1[1], Math.ulp(1d));\n+        Assert.assertEquals(1, x2[1], Math.ulp(1d));\n+        Assert.assertEquals(1, x3[1], Math.ulp(1d));\n+\n+        Assert.assertEquals(2, x1[2], Math.ulp(1d));\n+        Assert.assertEquals(4, x2[2], Math.ulp(1d));\n+        Assert.assertEquals(8, x3[2], Math.ulp(1d));\n+\n+        Assert.assertEquals(4,  x1[3], Math.ulp(1d));\n+        Assert.assertEquals(16, x2[3], Math.ulp(1d));\n+        Assert.assertEquals(64, x3[3], Math.ulp(1d));\n+\n+        Assert.assertEquals(5,   x1[4], Math.ulp(1d));\n+        Assert.assertEquals(25,  x2[4], Math.ulp(1d));\n+        Assert.assertEquals(125, x3[4], Math.ulp(1d));\n+    }\n+    \n+    @Test\n+    /** Example in javadoc */\n+    public void testSortInPlaceExample() {\n+        final double[] x = {3, 1, 2};\n+        final double[] y = {1, 2, 3};\n+        final double[] z = {0, 5, 7};\n+        MathArrays.sortInPlace(x, y, z);\n+        final double[] sx = {1, 2, 3};\n+        final double[] sy = {2, 3, 1};\n+        final double[] sz = {5, 7, 0};\n+        Assert.assertTrue(Arrays.equals(sx, x));\n+        Assert.assertTrue(Arrays.equals(sy, y));\n+        Assert.assertTrue(Arrays.equals(sz, z));\n+    }\n+    \n+    @Test\n+    public void testSortInPlaceFailures() {\n+        final double[] nullArray = null;\n+        final double[] one = {1};\n+        final double[] two = {1, 2};\n+        final double[] onep = {2};\n+        try {\n+            MathArrays.sortInPlace(one, two);\n+            Assert.fail(\"Expecting DimensionMismatchException\");\n+        } catch (DimensionMismatchException ex) {\n+            // expected\n+        }\n+        try {\n+            MathArrays.sortInPlace(one, nullArray);\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            MathArrays.sortInPlace(one, onep, nullArray);\n+            Assert.fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfInt() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int[] dest = MathArrays.copyOf(source);\n+\n+        Assert.assertEquals(dest.length, source.length);\n+        for (int i = 0; i < source.length; i++) {\n+            Assert.assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfInt2() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int offset = 3;\n+        final int[] dest = MathArrays.copyOf(source, source.length - offset);\n+\n+        Assert.assertEquals(dest.length, source.length - offset);\n+        for (int i = 0; i < source.length - offset; i++) {\n+            Assert.assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfInt3() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int offset = 3;\n+        final int[] dest = MathArrays.copyOf(source, source.length + offset);\n+\n+        Assert.assertEquals(dest.length, source.length + offset);\n+        for (int i = 0; i < source.length; i++) {\n+            Assert.assertEquals(source[i], dest[i]);\n+        }\n+        for (int i = source.length; i < source.length + offset; i++) {\n+            Assert.assertEquals(0, dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfDouble() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final double[] dest = MathArrays.copyOf(source);\n+\n+        Assert.assertEquals(dest.length, source.length);\n+        for (int i = 0; i < source.length; i++) {\n+            Assert.assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfDouble2() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final int offset = 3;\n+        final double[] dest = MathArrays.copyOf(source, source.length - offset);\n+\n+        Assert.assertEquals(dest.length, source.length - offset);\n+        for (int i = 0; i < source.length - offset; i++) {\n+            Assert.assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyOfDouble3() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final int offset = 3;\n+        final double[] dest = MathArrays.copyOf(source, source.length + offset);\n+\n+        Assert.assertEquals(dest.length, source.length + offset);\n+        for (int i = 0; i < source.length; i++) {\n+            Assert.assertEquals(source[i], dest[i], 0);\n+        }\n+        for (int i = source.length; i < source.length + offset; i++) {\n+            Assert.assertEquals(0, dest[i], 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombination1() {\n+        final double[] a = new double[] {\n+            -1321008684645961.0 / 268435456.0,\n+            -5774608829631843.0 / 268435456.0,\n+            -7645843051051357.0 / 8589934592.0\n+        };\n+        final double[] b = new double[] {\n+            -5712344449280879.0 / 2097152.0,\n+            -4550117129121957.0 / 2097152.0,\n+            8846951984510141.0 / 131072.0\n+        };\n+\n+        final double abSumInline = MathArrays.linearCombination(a[0], b[0],\n+                                                                a[1], b[1],\n+                                                                a[2], b[2]);\n+        final double abSumArray = MathArrays.linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline, abSumArray, 0);\n+    }\n+\n+    @Test\n+    public void testLinearCombination2() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(553267312521321234l);\n+\n+        for (int i = 0; i < 10000; ++i) {\n+            final double ux = 1e17 * random.nextDouble();\n+            final double uy = 1e17 * random.nextDouble();\n+            final double uz = 1e17 * random.nextDouble();\n+            final double vx = 1e17 * random.nextDouble();\n+            final double vy = 1e17 * random.nextDouble();\n+            final double vz = 1e17 * random.nextDouble();\n+            final double sInline = MathArrays.linearCombination(ux, vx,\n+                                                                uy, vy,\n+                                                                uz, vz);\n+            final double sArray = MathArrays.linearCombination(new double[] {ux, uy, uz},\n+                                                               new double[] {vx, vy, vz});\n+            Assert.assertEquals(sInline, sArray, 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testLinearCombinationInfinite() {\n+        final double[][] a = new double[][] {\n+            { 1, 2, 3, 4},\n+            { 1, Double.POSITIVE_INFINITY, 3, 4},\n+            { 1, 2, Double.POSITIVE_INFINITY, 4},\n+            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},\n+            { 1, 2, 3, 4},\n+            { 1, 2, 3, 4},\n+            { 1, 2, 3, 4},\n+            { 1, 2, 3, 4}\n+        };\n+        final double[][] b = new double[][] {\n+            { 1, -2, 3, 4},\n+            { 1, -2, 3, 4},\n+            { 1, -2, 3, 4},\n+            { 1, -2, 3, 4},\n+            { 1, Double.POSITIVE_INFINITY, 3, 4},\n+            { 1, -2, Double.POSITIVE_INFINITY, 4},\n+            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},\n+            { Double.NaN, -2, 3, 4}\n+        };\n+\n+        Assert.assertEquals(-3,\n+                            MathArrays.linearCombination(a[0][0], b[0][0],\n+                                                         a[0][1], b[0][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(6,\n+                            MathArrays.linearCombination(a[0][0], b[0][0],\n+                                                         a[0][1], b[0][1],\n+                                                         a[0][2], b[0][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(22,\n+                            MathArrays.linearCombination(a[0][0], b[0][0],\n+                                                         a[0][1], b[0][1],\n+                                                         a[0][2], b[0][2],\n+                                                         a[0][3], b[0][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(22, MathArrays.linearCombination(a[0], b[0]), 1.0e-10);\n+\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[1][0], b[1][0],\n+                                                         a[1][1], b[1][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[1][0], b[1][0],\n+                                                         a[1][1], b[1][1],\n+                                                         a[1][2], b[1][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[1][0], b[1][0],\n+                                                         a[1][1], b[1][1],\n+                                                         a[1][2], b[1][2],\n+                                                         a[1][3], b[1][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1], b[1]), 1.0e-10);\n+\n+        Assert.assertEquals(-3,\n+                            MathArrays.linearCombination(a[2][0], b[2][0],\n+                                                         a[2][1], b[2][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[2][0], b[2][0],\n+                                                         a[2][1], b[2][1],\n+                                                         a[2][2], b[2][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[2][0], b[2][0],\n+                                                         a[2][1], b[2][1],\n+                                                         a[2][2], b[2][2],\n+                                                         a[2][3], b[2][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2], b[2]), 1.0e-10);\n+\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[3][0], b[3][0],\n+                                                         a[3][1], b[3][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[3][0], b[3][0],\n+                                                         a[3][1], b[3][1],\n+                                                         a[3][2], b[3][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n+                            MathArrays.linearCombination(a[3][0], b[3][0],\n+                                                         a[3][1], b[3][1],\n+                                                         a[3][2], b[3][2],\n+                                                         a[3][3], b[3][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3], b[3]), 1.0e-10);\n+\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[4][0], b[4][0],\n+                                                         a[4][1], b[4][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[4][0], b[4][0],\n+                                                         a[4][1], b[4][1],\n+                                                         a[4][2], b[4][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[4][0], b[4][0],\n+                                                         a[4][1], b[4][1],\n+                                                         a[4][2], b[4][2],\n+                                                         a[4][3], b[4][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4], b[4]), 1.0e-10);\n+\n+        Assert.assertEquals(-3,\n+                            MathArrays.linearCombination(a[5][0], b[5][0],\n+                                                         a[5][1], b[5][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[5][0], b[5][0],\n+                                                         a[5][1], b[5][1],\n+                                                         a[5][2], b[5][2]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[5][0], b[5][0],\n+                                                         a[5][1], b[5][1],\n+                                                         a[5][2], b[5][2],\n+                                                         a[5][3], b[5][3]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5], b[5]), 1.0e-10);\n+\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[6][0], b[6][0],\n+                                                         a[6][1], b[6][1]),\n+                            1.0e-10);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY,\n+                            MathArrays.linearCombination(a[6][0], b[6][0],\n+                                                         a[6][1], b[6][1],\n+                                                         a[6][2], b[6][2]),\n+                            1.0e-10);\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6][0], b[6][0],\n+                                                                    a[6][1], b[6][1],\n+                                                                    a[6][2], b[6][2],\n+                                                                    a[6][3], b[6][3])));\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6], b[6])));\n+\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0],\n+                                                                    a[7][1], b[7][1])));\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0],\n+                                                                    a[7][1], b[7][1],\n+                                                                    a[7][2], b[7][2])));\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0],\n+                                                                    a[7][1], b[7][1],\n+                                                                    a[7][2], b[7][2],\n+                                                                    a[7][3], b[7][3])));\n+        Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7], b[7])));\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n \n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n-import org.apache.commons.math.random.Well1024a;\n import org.junit.Assert;\n import org.junit.Test;\n \n     }\n \n     @Test\n-    public void testL1DistanceDouble() {\n-        double[] p1 = { 2.5,  0.0 };\n-        double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(Precision.equals(7.0, MathUtils.distance1(p1, p2), 1));\n-    }\n-\n-    @Test\n-    public void testL1DistanceInt() {\n-        int[] p1 = { 3, 0 };\n-        int[] p2 = { 0, 4 };\n-        Assert.assertEquals(7, MathUtils.distance1(p1, p2));\n-    }\n-\n-    @Test\n-    public void testL2DistanceDouble() {\n-        double[] p1 = { 2.5,  0.0 };\n-        double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(Precision.equals(5.0, MathUtils.distance(p1, p2), 1));\n-    }\n-\n-    @Test\n-    public void testL2DistanceInt() {\n-        int[] p1 = { 3, 0 };\n-        int[] p2 = { 0, 4 };\n-        Assert.assertTrue(Precision.equals(5, MathUtils.distance(p1, p2), 1));\n-    }\n-\n-    @Test\n-    public void testLInfDistanceDouble() {\n-        double[] p1 = { 2.5,  0.0 };\n-        double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(Precision.equals(4.0, MathUtils.distanceInf(p1, p2), 1));\n-    }\n-\n-    @Test\n-    public void testLInfDistanceInt() {\n-        int[] p1 = { 3, 0 };\n-        int[] p2 = { 0, 4 };\n-        Assert.assertEquals(4, MathUtils.distanceInf(p1, p2));\n-    }\n-\n-    @Test\n-    public void testCheckOrder() {\n-        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15},\n-                             MathUtils.OrderDirection.INCREASING, true);\n-        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2},\n-                             MathUtils.OrderDirection.INCREASING, false);\n-        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5},\n-                             MathUtils.OrderDirection.DECREASING, true);\n-        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},\n-                             MathUtils.OrderDirection.DECREASING, false);\n-\n-        try {\n-            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},\n-                                 MathUtils.OrderDirection.INCREASING, true);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NonMonotonicSequenceException e) {\n-            // Expected\n-        }\n-        try {\n-            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2},\n-                                 MathUtils.OrderDirection.INCREASING, false);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NonMonotonicSequenceException e) {\n-            // Expected\n-        }\n-        try {\n-            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},\n-                                 MathUtils.OrderDirection.DECREASING, true);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NonMonotonicSequenceException e) {\n-            // Expected\n-        }\n-        try {\n-            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},\n-                                 MathUtils.OrderDirection.DECREASING, false);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NonMonotonicSequenceException e) {\n-            // Expected\n-        }\n-        try {\n-            MathUtils.checkOrder(new double[] {3, 0, -5.5, -11, -10},\n-                                 MathUtils.OrderDirection.DECREASING, false);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NonMonotonicSequenceException e) {\n-            // Expected\n-        }\n-    }\n-\n-    @Test\n-    public void testIsMonotone() {\n-        if(MathUtils.isMonotone(new double[] {-15, -5.5, -1, -1, 2,15},\n-                             MathUtils.OrderDirection.INCREASING, true) ){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-        if(MathUtils.isMonotone(new double[] {-15, -5.5,-1,-2,2},\n-                             MathUtils.OrderDirection.INCREASING, false)){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-        if(MathUtils.isMonotone(new double[] {3,3,-5.5,-11,-27.5},\n-                             MathUtils.OrderDirection.DECREASING, true)){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-        if( MathUtils.isMonotone(new double[] {3,-1,0,-5.5,-11,-27.5},\n-                             MathUtils.OrderDirection.DECREASING, false) ){\n-        Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-    }\n-\n-    @Test\n-    public void testIsMonotoneComparable() {\n-        if(MathUtils.isMonotone(new Double[] {new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2), new Double(15)},\n-                             MathUtils.OrderDirection.INCREASING, true) ){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-        if(MathUtils.isMonotone(new Double[] {new Double(-15), new Double(-5.5), new Double(-1), new Double(-2), new Double(2)},\n-                             MathUtils.OrderDirection.INCREASING, false)){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-        if(MathUtils.isMonotone(new Double[] {new Double(3), new Double(3), new Double(-5.5), new Double(-11), new Double(-27.5)},\n-                             MathUtils.OrderDirection.DECREASING, true)){\n-            Assert.fail(\"an exception should have been thrown\");\n-        }\n-        if( MathUtils.isMonotone(new Double[] {new Double(3), new Double(-1), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5)},\n-                             MathUtils.OrderDirection.DECREASING, false) ){\n-        Assert.fail(\"an exception should have been thrown\");\n-        }\n-\n-    }\n-\n-    @Test\n     public void testCheckFinite() {\n         try {\n             MathUtils.checkFinite(Double.POSITIVE_INFINITY);\n     }\n \n     @Test\n-    public void testSortInPlace() {\n-        final double[] x1 = {2,   5,  -3, 1,  4};\n-        final double[] x2 = {4,  25,   9, 1, 16};\n-        final double[] x3 = {8, 125, -27, 1, 64};\n-\n-        MathUtils.sortInPlace(x1, x2, x3);\n-\n-        Assert.assertEquals(-3,  x1[0], Math.ulp(1d));\n-        Assert.assertEquals(9,   x2[0], Math.ulp(1d));\n-        Assert.assertEquals(-27, x3[0], Math.ulp(1d));\n-\n-        Assert.assertEquals(1, x1[1], Math.ulp(1d));\n-        Assert.assertEquals(1, x2[1], Math.ulp(1d));\n-        Assert.assertEquals(1, x3[1], Math.ulp(1d));\n-\n-        Assert.assertEquals(2, x1[2], Math.ulp(1d));\n-        Assert.assertEquals(4, x2[2], Math.ulp(1d));\n-        Assert.assertEquals(8, x3[2], Math.ulp(1d));\n-\n-        Assert.assertEquals(4,  x1[3], Math.ulp(1d));\n-        Assert.assertEquals(16, x2[3], Math.ulp(1d));\n-        Assert.assertEquals(64, x3[3], Math.ulp(1d));\n-\n-        Assert.assertEquals(5,   x1[4], Math.ulp(1d));\n-        Assert.assertEquals(25,  x2[4], Math.ulp(1d));\n-        Assert.assertEquals(125, x3[4], Math.ulp(1d));\n-    }\n-    \n-    @Test\n-    /** Example in javadoc */\n-    public void testSortInPlaceExample() {\n-        final double[] x = {3, 1, 2};\n-        final double[] y = {1, 2, 3};\n-        final double[] z = {0, 5, 7};\n-        MathUtils.sortInPlace(x, y, z);\n-        final double[] sx = {1, 2, 3};\n-        final double[] sy = {2, 3, 1};\n-        final double[] sz = {5, 7, 0};\n-        Assert.assertTrue(Arrays.equals(sx, x));\n-        Assert.assertTrue(Arrays.equals(sy, y));\n-        Assert.assertTrue(Arrays.equals(sz, z));\n-    }\n-    \n-    @Test\n-    public void testSortInPlaceFaliures() {\n-        final double[] nullArray = null;\n-        final double[] one = {1};\n-        final double[] two = {1, 2};\n-        final double[] onep = {2};\n-        try {\n-            MathUtils.sortInPlace(one, two);\n-            Assert.fail(\"Expecting DimensionMismatchException\");\n-        } catch (DimensionMismatchException ex) {\n-            // expected\n-        }\n-        try {\n-            MathUtils.sortInPlace(one, nullArray);\n-            Assert.fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            MathUtils.sortInPlace(one, onep, nullArray);\n-            Assert.fail(\"Expecting NullArgumentException\");\n-        } catch (NullArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfInt() {\n-        final int[] source = { Integer.MIN_VALUE,\n-                               -1, 0, 1, 3, 113, 4769,\n-                               Integer.MAX_VALUE };\n-        final int[] dest = MathUtils.copyOf(source);\n-\n-        Assert.assertEquals(dest.length, source.length);\n-        for (int i = 0; i < source.length; i++) {\n-            Assert.assertEquals(source[i], dest[i]);\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfInt2() {\n-        final int[] source = { Integer.MIN_VALUE,\n-                               -1, 0, 1, 3, 113, 4769,\n-                               Integer.MAX_VALUE };\n-        final int offset = 3;\n-        final int[] dest = MathUtils.copyOf(source, source.length - offset);\n-\n-        Assert.assertEquals(dest.length, source.length - offset);\n-        for (int i = 0; i < source.length - offset; i++) {\n-            Assert.assertEquals(source[i], dest[i]);\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfInt3() {\n-        final int[] source = { Integer.MIN_VALUE,\n-                               -1, 0, 1, 3, 113, 4769,\n-                               Integer.MAX_VALUE };\n-        final int offset = 3;\n-        final int[] dest = MathUtils.copyOf(source, source.length + offset);\n-\n-        Assert.assertEquals(dest.length, source.length + offset);\n-        for (int i = 0; i < source.length; i++) {\n-            Assert.assertEquals(source[i], dest[i]);\n-        }\n-        for (int i = source.length; i < source.length + offset; i++) {\n-            Assert.assertEquals(0, dest[i], 0);\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfDouble() {\n-        final double[] source = { Double.NEGATIVE_INFINITY,\n-                                  -Double.MAX_VALUE,\n-                                  -1, 0,\n-                                  Double.MIN_VALUE,\n-                                  Math.ulp(1d),\n-                                  1, 3, 113, 4769,\n-                                  Double.MAX_VALUE,\n-                                  Double.POSITIVE_INFINITY };\n-        final double[] dest = MathUtils.copyOf(source);\n-\n-        Assert.assertEquals(dest.length, source.length);\n-        for (int i = 0; i < source.length; i++) {\n-            Assert.assertEquals(source[i], dest[i], 0);\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfDouble2() {\n-        final double[] source = { Double.NEGATIVE_INFINITY,\n-                                  -Double.MAX_VALUE,\n-                                  -1, 0,\n-                                  Double.MIN_VALUE,\n-                                  Math.ulp(1d),\n-                                  1, 3, 113, 4769,\n-                                  Double.MAX_VALUE,\n-                                  Double.POSITIVE_INFINITY };\n-        final int offset = 3;\n-        final double[] dest = MathUtils.copyOf(source, source.length - offset);\n-\n-        Assert.assertEquals(dest.length, source.length - offset);\n-        for (int i = 0; i < source.length - offset; i++) {\n-            Assert.assertEquals(source[i], dest[i], 0);\n-        }\n-    }\n-\n-    @Test\n-    public void testCopyOfDouble3() {\n-        final double[] source = { Double.NEGATIVE_INFINITY,\n-                                  -Double.MAX_VALUE,\n-                                  -1, 0,\n-                                  Double.MIN_VALUE,\n-                                  Math.ulp(1d),\n-                                  1, 3, 113, 4769,\n-                                  Double.MAX_VALUE,\n-                                  Double.POSITIVE_INFINITY };\n-        final int offset = 3;\n-        final double[] dest = MathUtils.copyOf(source, source.length + offset);\n-\n-        Assert.assertEquals(dest.length, source.length + offset);\n-        for (int i = 0; i < source.length; i++) {\n-            Assert.assertEquals(source[i], dest[i], 0);\n-        }\n-        for (int i = source.length; i < source.length + offset; i++) {\n-            Assert.assertEquals(0, dest[i], 0);\n-        }\n-    }\n-\n-    @Test\n     public void testCheckNotNull1() {\n         try {\n             Object obj = null;\n             // Expected.\n         }\n     }\n-\n-    @Test\n-    public void testLinearCombination1() {\n-        final double[] a = new double[] {\n-            -1321008684645961.0 / 268435456.0,\n-            -5774608829631843.0 / 268435456.0,\n-            -7645843051051357.0 / 8589934592.0\n-        };\n-        final double[] b = new double[] {\n-            -5712344449280879.0 / 2097152.0,\n-            -4550117129121957.0 / 2097152.0,\n-            8846951984510141.0 / 131072.0\n-        };\n-\n-        final double abSumInline = MathUtils.linearCombination(a[0], b[0],\n-                                                               a[1], b[1],\n-                                                               a[2], b[2]);\n-        final double abSumArray = MathUtils.linearCombination(a, b);\n-\n-        Assert.assertEquals(abSumInline, abSumArray, 0);\n-    }\n-\n-    @Test\n-    public void testLinearCombination2() {\n-        // we compare accurate versus naive dot product implementations\n-        // on regular vectors (i.e. not extreme cases like in the previous test)\n-        Well1024a random = new Well1024a(553267312521321234l);\n-\n-        for (int i = 0; i < 10000; ++i) {\n-            final double ux = 1e17 * random.nextDouble();\n-            final double uy = 1e17 * random.nextDouble();\n-            final double uz = 1e17 * random.nextDouble();\n-            final double vx = 1e17 * random.nextDouble();\n-            final double vy = 1e17 * random.nextDouble();\n-            final double vz = 1e17 * random.nextDouble();\n-            final double sInline = MathUtils.linearCombination(ux, vx,\n-                                                               uy, vy,\n-                                                               uz, vz);\n-            final double sArray = MathUtils.linearCombination(new double[] {ux, uy, uz},\n-                                                              new double[] {vx, vy, vz});\n-            Assert.assertEquals(sInline, sArray, 0);\n-        }\n-    }\n-\n-    @Test\n-    public void testLinearCombinationInfinite() {\n-        final double[][] a = new double[][] {\n-            { 1, 2, 3, 4},\n-            { 1, Double.POSITIVE_INFINITY, 3, 4},\n-            { 1, 2, Double.POSITIVE_INFINITY, 4},\n-            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},\n-            { 1, 2, 3, 4},\n-            { 1, 2, 3, 4},\n-            { 1, 2, 3, 4},\n-            { 1, 2, 3, 4}\n-        };\n-        final double[][] b = new double[][] {\n-            { 1, -2, 3, 4},\n-            { 1, -2, 3, 4},\n-            { 1, -2, 3, 4},\n-            { 1, -2, 3, 4},\n-            { 1, Double.POSITIVE_INFINITY, 3, 4},\n-            { 1, -2, Double.POSITIVE_INFINITY, 4},\n-            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},\n-            { Double.NaN, -2, 3, 4}\n-        };\n-\n-        Assert.assertEquals(-3,\n-                            MathUtils.linearCombination(a[0][0], b[0][0],\n-                                                        a[0][1], b[0][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(6,\n-                            MathUtils.linearCombination(a[0][0], b[0][0],\n-                                                        a[0][1], b[0][1],\n-                                                        a[0][2], b[0][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(22,\n-                            MathUtils.linearCombination(a[0][0], b[0][0],\n-                                                        a[0][1], b[0][1],\n-                                                        a[0][2], b[0][2],\n-                                                        a[0][3], b[0][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(22, MathUtils.linearCombination(a[0], b[0]), 1.0e-10);\n-\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[1][0], b[1][0],\n-                                                        a[1][1], b[1][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[1][0], b[1][0],\n-                                                        a[1][1], b[1][1],\n-                                                        a[1][2], b[1][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[1][0], b[1][0],\n-                                                        a[1][1], b[1][1],\n-                                                        a[1][2], b[1][2],\n-                                                        a[1][3], b[1][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.linearCombination(a[1], b[1]), 1.0e-10);\n-\n-        Assert.assertEquals(-3,\n-                            MathUtils.linearCombination(a[2][0], b[2][0],\n-                                                        a[2][1], b[2][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[2][0], b[2][0],\n-                                                        a[2][1], b[2][1],\n-                                                        a[2][2], b[2][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[2][0], b[2][0],\n-                                                        a[2][1], b[2][1],\n-                                                        a[2][2], b[2][2],\n-                                                        a[2][3], b[2][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[2], b[2]), 1.0e-10);\n-\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[3][0], b[3][0],\n-                                                        a[3][1], b[3][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[3][0], b[3][0],\n-                                                        a[3][1], b[3][1],\n-                                                        a[3][2], b[3][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY,\n-                            MathUtils.linearCombination(a[3][0], b[3][0],\n-                                                        a[3][1], b[3][1],\n-                                                        a[3][2], b[3][2],\n-                                                        a[3][3], b[3][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.linearCombination(a[3], b[3]), 1.0e-10);\n-\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[4][0], b[4][0],\n-                                                        a[4][1], b[4][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[4][0], b[4][0],\n-                                                        a[4][1], b[4][1],\n-                                                        a[4][2], b[4][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[4][0], b[4][0],\n-                                                        a[4][1], b[4][1],\n-                                                        a[4][2], b[4][2],\n-                                                        a[4][3], b[4][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[4], b[4]), 1.0e-10);\n-\n-        Assert.assertEquals(-3,\n-                            MathUtils.linearCombination(a[5][0], b[5][0],\n-                                                        a[5][1], b[5][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[5][0], b[5][0],\n-                                                        a[5][1], b[5][1],\n-                                                        a[5][2], b[5][2]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[5][0], b[5][0],\n-                                                        a[5][1], b[5][1],\n-                                                        a[5][2], b[5][2],\n-                                                        a[5][3], b[5][3]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[5], b[5]), 1.0e-10);\n-\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[6][0], b[6][0],\n-                                                        a[6][1], b[6][1]),\n-                            1.0e-10);\n-        Assert.assertEquals(Double.POSITIVE_INFINITY,\n-                            MathUtils.linearCombination(a[6][0], b[6][0],\n-                                                        a[6][1], b[6][1],\n-                                                        a[6][2], b[6][2]),\n-                            1.0e-10);\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[6][0], b[6][0],\n-                                                                   a[6][1], b[6][1],\n-                                                                   a[6][2], b[6][2],\n-                                                                   a[6][3], b[6][3])));\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[6], b[6])));\n-\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],\n-                                                        a[7][1], b[7][1])));\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],\n-                                                        a[7][1], b[7][1],\n-                                                        a[7][2], b[7][2])));\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],\n-                                                                   a[7][1], b[7][1],\n-                                                                   a[7][2], b[7][2],\n-                                                                   a[7][3], b[7][3])));\n-        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7], b[7])));\n-\n-    }\n-\n }", "timestamp": 1318373708, "metainfo": ""}