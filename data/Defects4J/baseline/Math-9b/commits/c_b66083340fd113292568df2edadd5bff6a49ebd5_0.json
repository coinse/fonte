{"sha": "b66083340fd113292568df2edadd5bff6a49ebd5", "log": "Array version of \"linearCombination\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n     }\n \n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     *\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     */\n+    public static double linearCombination(final double[] a, final double[] b) {\n+        final int len = a.length;\n+        if (len != b.length) {\n+            throw new DimensionMismatchException(len, b.length);\n+        }\n+\n+        final double[] prodHigh = new double[len];\n+        double prodLowSum = 0;\n+\n+        for (int i = 0; i < len; i++) {\n+            final double ai = a[i];\n+            final double ca = SPLIT_FACTOR * ai;\n+            final double aHigh = ca - (ca - ai);\n+            final double aLow = ai - aHigh;\n+\n+            final double bi = b[i];\n+            final double cb = SPLIT_FACTOR * bi;\n+            final double bHigh = cb - (cb - bi);\n+            final double bLow = bi - bHigh;\n+            prodHigh[i] = ai * bi;\n+            final double prodLow = aLow * bLow - (((prodHigh[i] -\n+                                                    aHigh * bHigh) -\n+                                                   aLow * bHigh) -\n+                                                  aHigh * bLow);\n+            prodLowSum += prodLow;\n+        }\n+\n+        final int lenMinusOne = len - 1;\n+        final double[] sHigh = new double[lenMinusOne];\n+\n+        sHigh[0] = prodHigh[0] + prodHigh[1];\n+        double sPrime = sHigh[0] - prodHigh[1];\n+        double sLowSum = (prodHigh[1] - (sHigh[0] - sPrime)) + (prodHigh[0] - sPrime);\n+\n+        for (int i = 1; i < lenMinusOne; i++) {\n+            final int prev = i - 1;\n+            final int next = i + 1;\n+            sHigh[i] = sHigh[prev] + prodHigh[next];\n+            sPrime = sHigh[i] - prodHigh[next];\n+            sLowSum += (prodHigh[next] - (sHigh[i] - sPrime)) + (sHigh[prev] - sPrime);\n+        }\n+\n+        return sHigh[lenMinusOne - 1] + (prodLowSum + sLowSum);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n             // Expected.\n         }\n     }\n+\n+    @Test\n+    public void testLinearCombination1() {\n+        final double[] a = new double[] {\n+            -1321008684645961.0 / 268435456.0,\n+            -5774608829631843.0 / 268435456.0,\n+            -7645843051051357.0 / 8589934592.0\n+        };\n+        final double[] b = new double[] {\n+            -5712344449280879.0 / 2097152.0,\n+            -4550117129121957.0 / 2097152.0,\n+            8846951984510141.0 / 131072.0\n+        };\n+\n+        final double abSumInline = MathUtils.linearCombination(a[0], b[0],\n+                                                               a[1], b[1],\n+                                                               a[2], b[2]);\n+        final double abSumArray = MathUtils.linearCombination(a, b);\n+\n+        Assert.assertEquals(abSumInline, abSumArray, 0);\n+    }\n }", "timestamp": 1312589629, "metainfo": ""}