{"sha": "daf025e7eb5c951a08eb630af00210ee2c5238db", "log": "added a lazy evaluation for step interpolators moved the possible exceptions from setInterpolatedTime (which now does almost nothing) to getInterpolatedState and getInterpolatedDerivatives (which now do the evaluations) renamed an internal function to make sure people overriding it don't forget to set the derivatives   ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n    */\n   public void setInterpolatedTime(final double time) {\n \n-    try {\n       // initialize the search with the complete steps table\n       int iMin = 0;\n       final StepInterpolator sMin = steps.get(iMin);\n \n       steps.get(index).setInterpolatedTime(time);\n \n-    } catch (DerivativeException de) {\n-      throw new MathRuntimeException(de, \"unexpected exception caught\");\n-    }\n-\n   }\n \n   /**\n    * Get the state vector of the interpolated point.\n    * @return state vector at time {@link #getInterpolatedTime}\n-   */\n-  public double[] getInterpolatedState() {\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public double[] getInterpolatedState() throws DerivativeException {\n     return steps.get(index).getInterpolatedState();\n   }\n \n--- a/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n \n   /** integration direction. */\n   private boolean forward;\n+\n+  /** indicator for dirty state. */\n+  private boolean dirtyState;\n+\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n     interpolatedDerivatives = null;\n     finalized               = false;\n     this.forward            = true;\n+    this.dirtyState         = true;\n   }\n \n   /** Simple constructor.\n \n     finalized         = false;\n     this.forward      = forward;\n+    this.dirtyState   = true;\n \n   }\n \n       interpolatedDerivatives = null;\n     }\n \n-    finalized = interpolator.finalized;\n-    forward   = interpolator.forward;\n+    finalized  = interpolator.finalized;\n+    forward    = interpolator.forward;\n+    dirtyState = interpolator.dirtyState;\n \n   }\n \n \n     finalized         = false;\n     this.forward      = forward;\n+    this.dirtyState   = true;\n \n   }\n \n    */\n   public void storeTime(final double t) {\n \n-    currentTime      = t;\n-    h                = currentTime - previousTime;\n-    interpolatedTime = t;\n-    System.arraycopy(currentState, 0, interpolatedState, 0,\n-                     currentState.length);\n+    currentTime = t;\n+    h           = currentTime - previousTime;\n+    setInterpolatedTime(t);\n \n     // the step is not finalized anymore\n-    finalized = false;\n+    finalized  = false;\n \n   }\n \n   }\n     \n   /** {@inheritDoc} */\n-  public void setInterpolatedTime(final double time)\n-      throws DerivativeException {\n+  public void setInterpolatedTime(final double time) {\n       interpolatedTime = time;\n-      final double oneMinusThetaH = currentTime - interpolatedTime;\n-      final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n-      computeInterpolatedState(theta, oneMinusThetaH);\n+      dirtyState       = true;\n   }\n \n   /** {@inheritDoc} */\n     return forward;\n   }\n \n-  /** Compute the state at the interpolated time.\n+  /** Compute the state and derivatives at the interpolated time.\n    * This is the main processing method that should be implemented by\n    * the derived classes to perform the interpolation.\n    * @param theta normalized interpolation abscissa within the step\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n-  protected abstract void computeInterpolatedState(double theta,\n-                                                   double oneMinusThetaH)\n+  protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n+                                                                 double oneMinusThetaH)\n     throws DerivativeException;\n     \n   /** {@inheritDoc} */\n-  public double[] getInterpolatedState() {\n-    return interpolatedState;\n-  }\n-\n-  /** {@inheritDoc} */\n-  public double[] getInterpolatedDerivatives() {\n-    return interpolatedDerivatives;\n+  public double[] getInterpolatedState() throws DerivativeException {\n+\n+      // lazy evaluation of the state\n+      if (dirtyState) {\n+          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n+          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n+          dirtyState = false;\n+      }\n+\n+      return interpolatedState;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedDerivatives() throws DerivativeException {\n+\n+      // lazy evaluation of the state\n+      if (dirtyState) {\n+          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n+          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n+          dirtyState = false;\n+      }\n+\n+      return interpolatedDerivatives;\n+\n   }\n \n   /**\n     currentTime   = in.readDouble();\n     h             = in.readDouble();\n     forward       = in.readBoolean();\n+    dirtyState    = true;\n \n     if (dimension < 0) {\n         currentState = null;\n--- a/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n \n package org.apache.commons.math.ode.sampling;\n \n+import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n-import java.io.IOException;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n \n    * underlying user function triggers one\n    */\n   @Override\n-  protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)\n+  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n     throws DerivativeException {\n       System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n   }\n     // read the base class \n     final double t = readBaseExternal(in);\n \n-    try {\n-      // we can now set the interpolated time and state\n-      setInterpolatedTime(t);\n-    } catch (DerivativeException e) {\n-      throw MathRuntimeException.createIOException(e);\n-    }\n+    // we can now set the interpolated time and state\n+    setInterpolatedTime(t);\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.io.ObjectOutput;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n-import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.nonstiff.AdamsIntegrator;\n \n /**\n  * This class implements an interpolator for integrators using Nordsieck representation.\n  * <p>This interpolator computes dense output around the current point.\n  * The interpolation equation is based on Taylor series formulas.\n  *\n- * @see AdamsIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n     /** Step size used in the first scaled derivative and Nordsieck vector. */\n     private double scalingH;\n+\n+    /** Reference time for all arrays.\n+     * <p>Sometimes, the reference time is the same as previousTime,\n+     * sometimes it is the same as currentTime, so we use a separate\n+     * field to avoid any confusion.\n+     * </p>\n+     */\n+    private double referenceTime;\n \n     /** First scaled derivative. */\n     private double[] scaled;\n     /** Reinitialize the instance\n      * <p>Beware that all arrays <em>must</em> be references to integrator\n      * arrays, in order to ensure proper update without copy.</p>\n+     * @param referenceTime time at which all arrays are defined\n      * @param scalingH step size used in the scaled and nordsieck arrays\n      * @param scaled reference to the integrator array holding the first\n      * scaled derivative\n      * @param nordsieck reference to the integrator matrix holding the\n      * nordsieck vector\n      */\n-    public void reinitialize(final double scalingH, final double[] scaled,\n-                             final RealMatrix nordsieck) {\n-        this.scalingH  = scalingH;\n-        this.scaled    = scaled;\n-        this.nordsieck = nordsieck;\n-    }\n-\n-    /** Store the current step time.\n-     * @param t current time\n-     */\n-    @Override\n-    public void storeTime(final double t) {\n-      currentTime      = t;\n-      h                = currentTime - previousTime;\n-      interpolatedTime = t;\n-      computeInterpolatedState(1.0, 0.0);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n-        final double x = theta * h;\n+    public void reinitialize(final double referenceTime, final double scalingH,\n+                             final double[] scaled, final RealMatrix nordsieck) {\n+        this.referenceTime = referenceTime;\n+        this.scalingH      = scalingH;\n+        this.scaled        = scaled;\n+        this.nordsieck     = nordsieck;\n+\n+        // make sure the state and derivatives will depend on the new arrays\n+        setInterpolatedTime(getInterpolatedTime());\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n+        final double x = interpolatedTime - referenceTime;\n         nordsieck.walkInOptimizedOrder(new StateEstimator(x, x / scalingH));\n     }\n \n             nordsieck = null;\n         }\n \n-        try {\n-            if (hasScaled && hasNordsieck) {\n-                // we can now set the interpolated time and state\n-                setInterpolatedTime(t);\n-            }\n-        } catch (DerivativeException e) {\n-            throw MathRuntimeException.createIOException(e);\n+        if (hasScaled && hasNordsieck) {\n+            // we can now set the interpolated time and state\n+            setInterpolatedTime(t);\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n    * specific state must be preserved, a copy of the instance must be\n    * created using {@link #copy()}.</p>\n    * @param time time of the interpolated point\n-   * @throws DerivativeException if this call induces an automatic\n-   * step finalization that throws one\n    */\n-  public void setInterpolatedTime(double time)\n-    throws DerivativeException;\n+  public void setInterpolatedTime(double time);\n \n   /**\n    * Get the state vector of the interpolated point.\n    * to be preserved across several calls.</p>\n    * @return state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedDerivatives()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n    */\n-  public double[] getInterpolatedState();\n+  public double[] getInterpolatedState()\n+      throws DerivativeException;\n \n   /**\n    * Get the derivatives of the state vector of the interpolated point.\n    * to be preserved across several calls.</p>\n    * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n    * @see #getInterpolatedState()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n    * @since 2.0\n    */\n-  public double[] getInterpolatedDerivatives();\n+  public double[] getInterpolatedDerivatives()\n+      throws DerivativeException;\n \n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by", "timestamp": 1244401477, "metainfo": ""}