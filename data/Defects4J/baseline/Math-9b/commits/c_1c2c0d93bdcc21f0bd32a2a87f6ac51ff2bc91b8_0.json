{"sha": "1c2c0d93bdcc21f0bd32a2a87f6ac51ff2bc91b8", "log": "added support for any kind of field in linear algebra we can now use FieldMatrix<Fraction> and use exact LU-decomposition on such matrices to solve linear systems  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n+    // org.apache.commons.math.ode.stiff.BDFIntegrator\n+    { \"unsupported order {0} for BDF methods, must be between {1} and {2}\",\n+      \"ordre {0} non support\\u00e9 pour les m\\u00e9thodes BDF, doit \\u00eatre entre {1} et {2}\" },\n+    { \"corrector failed to converge after {0} iterations at t = {1}\",\n+      \"\\u00e9chec de convergence du correcteur apr\\u00e8s {0} it\\u00e9rations \\u00e0 t = {1}\" },\n+\n     // org.apache.commons.math.ode.ContinuousOutputModel\n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"unexpected exception caught\",\n       \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n       \n     // org.apache.commons.math.linear.RealVectorImpl\n+    // org.apache.commons.math.linear.FieldVectorImpl\n     // org.apache.commons.math.linear.SparseRealVector\n     { \"index {0} out of allowed range [{1}, {2}]\",\n       \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n       \"la position {0} et la taille {1} sont incompatibles avec la taille du tableau d''entr\\u00e9e {2}\"},\n \n     // org.apache.commons.math.linear.AbstractRealMatrix\n+    // org.apache.commons.math.linear.AbstractFieldMatrix\n     { \"invalid row dimension: {0} (must be positive)\",\n       \"nombre de lignes invalide : {0} (doit \\u00eatre positif)\" },\n     { \"invalid column dimension: {0} (must be positive)\",\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n+\n+/**\n+ * Basic implementation of {@link FieldMatrix} methods regardless of the underlying storage.\n+ * <p>All the methods implemented here use {@link #getEntry(int, int)} to access\n+ * matrix elements. Derived class can provide faster implementations. </p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractFieldMatrix<T extends FieldElement<T>> implements FieldMatrix<T>, Serializable {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3665653040524315561L;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Build an array of elements.\n+     * @param rows number of rows\n+     * @param columns number of columns\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected T[][] buildArray(final int rows, final int columns) {\n+        return (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n+    }\n+\n+    /** Build an array of elements.\n+     * @param length of the array\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field,\n+                                  final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n+        }\n+        this.field = field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n+        return field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException;\n+\n+    /** {@inheritDoc} */\n+    public abstract FieldMatrix<T> copy();\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).add(m.getEntry(row, col)));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).subtract(m.getEntry(row, col)));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> scalarAdd(final T d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).add(d));\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> scalarMultiply(final T d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).multiply(d));\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum  = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(nRows, nCols);\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nSum; ++i) {\n+                    sum = sum.add(getEntry(row, i).multiply(m.getEntry(i, col)));\n+                }\n+                out.setEntry(row, col, sum);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[][] getData() {\n+\n+        final T[][] data = buildArray(getRowDimension(), getColumnDimension());\n+\n+        for (int i = 0; i < data.length; ++i) {\n+            final T[] dataI = data[i];\n+            for (int j = 0; j < dataI.length; ++j) {\n+                dataI[j] = getEntry(i, j);\n+            }\n+        }\n+\n+        return data;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        final FieldMatrix<T> subMatrix =\n+            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n+            }\n+        }\n+\n+        return subMatrix;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n+\n+        // copy entries\n+        final FieldMatrix<T> subMatrix =\n+            createMatrix(selectedRows.length, selectedColumns.length);\n+        subMatrix.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<T>(field.getZero()) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 5079316658710707181L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public T visit(final int row, final int column, final T value) {\n+                return getEntry(selectedRows[row], selectedColumns[column]);\n+            }\n+\n+        });\n+\n+        return subMatrix;\n+\n+    } \n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn,\n+                              final T[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        final int rowsCount    = endRow + 1 - startRow;\n+        final int columnsCount = endColumn + 1 - startColumn;\n+        if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    rowsCount, columnsCount);\n+        }\n+\n+        // copy entries\n+        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 1894428776156078725L;\n+\n+            /** Initial row index. */\n+            private int startRow;\n+\n+            /** Initial column index. */\n+            private int startColumn;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.startRow    = startRow;\n+                this.startColumn = startColumn;\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final T value) {\n+                destination[row - startRow][column - startColumn] = value;\n+            }\n+\n+        }, startRow, endRow, startColumn, endColumn);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n+        if ((destination.length < selectedRows.length) ||\n+            (destination[0].length < selectedColumns.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    selectedRows.length, selectedColumns.length);\n+        }\n+\n+        // copy entries\n+        for (int i = 0; i < selectedRows.length; i++) {\n+            final T[] destinationI = destination[i];\n+            for (int j = 0; j < selectedColumns.length; j++) {\n+                destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+        throws MatrixIndexException {\n+\n+        final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+\n+        for (int r = 1; r < nRows; ++r) {\n+            if (subMatrix[r].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        nCols, subMatrix[r].length); \n+            }\n+        }\n+\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        checkRowIndex(nRows + row - 1);\n+        checkColumnIndex(nCols + column - 1);\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            for (int j = 0; j < nCols; ++j) {\n+                setEntry(row + i, column + j, subMatrix[i][j]);\n+            }\n+        } \n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out.setEntry(0, i, getEntry(row, i));\n+        }\n+\n+        return out;\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, matrix.getEntry(0, i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final FieldMatrix<T> out = createMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            out.setEntry(i, 0, getEntry(i, column));\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, matrix.getEntry(i, 0));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> getRowVector(final int row)\n+        throws MatrixIndexException {\n+        return new FieldVectorImpl<T>(getRow(row), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (vector.getDimension() != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, vector.getDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws MatrixIndexException {\n+        return new FieldVectorImpl<T>(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (vector.getDimension() != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    vector.getDimension(), 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public T[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final T[] out = buildArray(nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out[i] = getEntry(row, i);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public T[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final T[] out = buildArray(nRows);\n+        for (int i = 0; i < nRows; ++i) {\n+            out[i] = getEntry(i, column);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public abstract T getEntry(int row, int column)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, T value)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, T increment)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, T factor)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(nCols, nRows);\n+        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 6281961451465720534L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final T value) {\n+                out.setEntry(column, row, value);\n+            }\n+\n+        });\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSquare() {\n+        return (getColumnDimension() == getRowDimension());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract int getRowDimension();\n+\n+    /** {@inheritDoc} */\n+    public abstract int getColumnDimension();\n+\n+    /** {@inheritDoc} */\n+    public T getTrace()\n+        throws NonSquareMatrixException {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new NonSquareMatrixException(nRows, nCols);\n+       }\n+        T trace = field.getZero();\n+        for (int i = 0; i < nRows; ++i) {\n+            trace = trace.add(getEntry(i, i));\n+        }\n+        return trace;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+\n+        final T[] out = buildArray(nRows);\n+        for (int row = 0; row < nRows; ++row) {\n+            T sum = field.getZero();\n+            for (int i = 0; i < nCols; ++i) {\n+                sum = sum.add(getEntry(row, i).multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> operate(final FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new FieldVectorImpl<T>(operate(((FieldVectorImpl<T>) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nCols);\n+            }\n+\n+            final T[] out = buildArray(nRows);\n+            for (int row = 0; row < nRows; ++row) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nCols; ++i) {\n+                    sum = sum.add(getEntry(row, i).multiply(v.getEntry(i)));\n+                }\n+                out[row] = sum;\n+            }\n+\n+            return new FieldVectorImpl<T>(out, false);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final T[] out = buildArray(nCols);\n+        for (int col = 0; col < nCols; ++col) {\n+            T sum = field.getZero();\n+            for (int i = 0; i < nRows; ++i) {\n+                sum = sum.add(getEntry(i, col).multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> preMultiply(final FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new FieldVectorImpl<T>(preMultiply(((FieldVectorImpl<T>) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nRows) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nRows);\n+            }\n+\n+            final T[] out = buildArray(nCols);\n+            for (int col = 0; col < nCols; ++col) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nRows; ++i) {\n+                    sum = sum.add(getEntry(i, col).multiply(v.getEntry(i)));\n+                }\n+                out[col] = sum;\n+            }\n+\n+            return new FieldVectorImpl<T>(out);\n+\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /**\n+     * Get a string representation for this matrix.\n+     * @return a string representation for this matrix\n+     */\n+    @Override\n+    public String toString() {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final StringBuffer res = new StringBuffer();\n+        String fullClassName = getClass().getName();\n+        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n+        res.append(shortClassName).append(\"{\");\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            if (i > 0) {\n+                res.append(\",\");\n+            }\n+            res.append(\"{\");\n+            for (int j = 0; j < nCols; ++j) {\n+                if (j > 0) {\n+                    res.append(\",\");\n+                }\n+                res.append(getEntry(i, j));\n+            } \n+            res.append(\"}\");\n+        } \n+\n+        res.append(\"}\");\n+        return res.toString();\n+\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>FieldMatrix</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof FieldMatrix == false) {\n+            return false;\n+        }\n+        FieldMatrix<T> m = (FieldMatrix<T>) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                if (!getEntry(row, col).equals(m.getEntry(row, col))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    @Override\n+    public int hashCode() {\n+        int ret = 322562;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * getEntry(row, col).hashCode();\n+           }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    protected void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           row, 0, getRowDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    protected void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           column, 0, getColumnDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn) {\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           startRow, endRow);\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           startColumn, endColumn);\n+        }\n+\n+    \n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n+        }\n+\n+        for (final int row : selectedRows) {\n+            checkRowIndex(row);\n+        }\n+        for (final int column : selectedColumns) {\n+            checkColumnIndex(column);\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is addition compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not addition compatible with instance\n+     */\n+    protected void checkAdditionCompatible(final FieldMatrix<T> m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is subtraction compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not subtraction compatible with instance\n+     */\n+    protected void checkSubtractionCompatible(final FieldMatrix<T> m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is multiplication compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not multiplication compatible with instance\n+     */\n+    protected void checkMultiplicationCompatible(final FieldMatrix<T> m) {\n+        if (getColumnDimension() != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/BigMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrix.java\n  * returns the element in the first row, first column of the matrix.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @deprecated as of 2.0, replaced by {@link FieldMatrix} with a {@link\n+ * org.apache.commons.math.util.BigReal} parameter\n  */\n+@Deprecated\n public interface BigMatrix {\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n  * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</li></ul></p>\n  * \n+ * @deprecated as of 2.0, replaced by {@link FieldMatrixImpl} with a {@link\n+ * org.apache.commons.math.util.BigReal} parameter\n  * @version $Revision$ $Date$\n  */\n+@Deprecated\n public class BigMatrixImpl implements BigMatrix, Serializable {\n     \n     /** Serialization id */\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Default implementation of the {@link FieldMatrixChangingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultFieldMatrixChangingVisitor<T extends FieldElement<T>>\n+    implements FieldMatrixChangingVisitor<T> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7138694000397476118L;\n+\n+    /** Zero element of the field. */\n+    private final T zero;\n+\n+    /** Build a new instance.\n+     * @param zero additive identity of the field\n+     */\n+    public DefaultFieldMatrixChangingVisitor(final T zero) {\n+        this.zero = zero;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T visit(int row, int column, T value)\n+        throws MatrixVisitorException {\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T end() {\n+        return zero;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Default implementation of the {@link FieldMatrixPreservingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultFieldMatrixPreservingVisitor<T extends FieldElement<T>>\n+    implements FieldMatrixPreservingVisitor<T> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7998898965168636198L;\n+\n+    /** Zero element of the field. */\n+    private final T zero;\n+\n+    /** Build a new instance.\n+     * @param zero additive identity of the field\n+     */\n+    public DefaultFieldMatrixPreservingVisitor(final T zero) {\n+        this.zero = zero;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void visit(int row, int column, T value)\n+        throws MatrixVisitorException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T end() {\n+        return zero;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n+\n+/**\n+ * Interface defining field-valued matrix with basic algebraic operations.\n+ * <p>\n+ * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ */\n+public interface FieldMatrix<T extends FieldElement<T>> extends Serializable {\n+\n+    /**\n+     * Get the type of field elements of the matrix.\n+     * @return type of field elements of the matrix\n+     */\n+    Field<T> getField();\n+\n+    /**\n+     * Create a new FieldMatrix<T> of the same type as the instance with the supplied\n+     * row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @return a new matrix of the same type as the instance\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @since 2.0\n+     */\n+    FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    FieldMatrix<T> copy();\n+\n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    FieldMatrix<T> subtract(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    FieldMatrix<T> scalarAdd(T d);\n+\n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    FieldMatrix<T> scalarMultiply(T d);\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    FieldMatrix<T> multiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    T[][] getData();\n+\n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n+       throws MatrixIndexException;\n+   \n+   /**\n+    * Gets a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+    * @return The subMatrix containing the data in the\n+    *         specified rows and columns\n+    * @exception MatrixIndexException if row or column selections are not valid\n+    */\n+   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+       throws MatrixIndexException;\n+\n+   /**\n+    * Copy a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param startRow Initial row index\n+    * @param endRow Final row index (inclusive)\n+    * @param startColumn Initial column index\n+    * @param endColumn Final column index (inclusive)\n+    * @param destination The arrays where the submatrix data should be copied\n+    * (if larger than rows/columns counts, only the upper-left part will be used)\n+    * @exception MatrixIndexException if the indices are not valid\n+    * @exception IllegalArgumentException if the destination array is too small\n+    */\n+  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                     T[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+  \n+  /**\n+   * Copy a submatrix. Rows and columns are indicated\n+   * counting from 0 to n-1.\n+   *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+   * @param destination The arrays where the submatrix data should be copied\n+   * (if larger than rows/columns counts, only the upper-left part will be used)\n+   * @exception MatrixIndexException if the indices are not valid\n+   * @exception IllegalArgumentException if the destination array is too small\n+   */\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+ \n+   /**\n+    * Replace the submatrix starting at <code>row, column</code> using data in\n+    * the input <code>subMatrix</code> array. Indexes are 0-based.\n+    * <p> \n+    * Example:<br>\n+    * Starting with <pre>\n+    * 1  2  3  4\n+    * 5  6  7  8\n+    * 9  0  1  2\n+    * </pre>\n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n+    * 1  2  3  4\n+    * 5  3  4  8\n+    * 9  5  6  2\n+    * </pre></p>\n+    * \n+    * @param subMatrix  array containing the submatrix replacement data\n+    * @param row  row coordinate of the top, left element to be replaced\n+    * @param column  column coordinate of the top, left element to be replaced\n+    * @throws MatrixIndexException  if subMatrix does not fit into this \n+    *    matrix from element in (row, column) \n+    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n+    *  (not all rows have the same length) or empty\n+    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @since 2.0\n+    */\n+   void setSubMatrix(T[][] subMatrix, int row, int column) \n+       throws MatrixIndexException;\n+\n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row matrix\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   FieldMatrix<T> getRowMatrix(int row) throws MatrixIndexException;\n+   \n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param matrix row matrix (must have one row and the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance row\n+    */\n+   void setRowMatrix(int row, FieldMatrix<T> matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column matrix\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   FieldMatrix<T> getColumnMatrix(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param matrix column matrix (must have one column and the same number of rows\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance column\n+    */\n+   void setColumnMatrix(int column, FieldMatrix<T> matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row vector\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   FieldVector<T> getRowVector(int row) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param vector row vector (must have the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance row\n+    */\n+   void setRowVector(int row, FieldVector<T> vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column vector\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   FieldVector<T> getColumnVector(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param vector column vector (must have the same number of rows as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance column\n+    */\n+   void setColumnVector(int column, FieldVector<T> vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    T[] getRow(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param array row matrix (must have the same number of columns as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance row\n+     */\n+    void setRow(int row, T[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param column the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    T[] getColumn(int column) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param array column array (must have the same number of rows as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance column\n+     */\n+    void setColumn(int column, T[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    T getEntry(int row, int column) throws MatrixIndexException;\n+\n+    /**\n+     * Set the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param value matrix entry to be set in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void setEntry(int row, int column, T value) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param increment value to add to the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void addToEntry(int row, int column, T increment) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param factor multiplication factor for the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void multiplyEntry(int row, int column, T factor) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    FieldMatrix<T> transpose();\n+\n+    /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    boolean isSquare();\n+\n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    int getRowDimension();\n+\n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    int getColumnDimension();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     * @throws NonSquareMatrixException if the matrix is not square\n+     */\n+    T getTrace() throws NonSquareMatrixException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    T[] operate(T[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    FieldVector<T> operate(FieldVector<T> v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    T[] preMultiply(T[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    FieldVector<T> preMultiply(FieldVector<T> v) throws IllegalArgumentException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldMatrixChangingVisitor<T extends FieldElement<?>> extends Serializable {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @return the new value to be set for the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    T visit(int row, int column, T value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    T end();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrixImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of FieldMatrix<T> using a {@link FieldElement}[][] array to store entries.\n+ * <p>\n+ * As specified in the {@link FieldMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ */\n+public class FieldMatrixImpl<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7260756672015356458L;\n+\n+    /** Entries of the matrix */\n+    protected T[][] data;\n+\n+    /**\n+     * Get the elements type from an array.\n+     * @param d data array\n+     * @return field to which array elements belong\n+     * @exception IllegalArgumentException if array is empty\n+     */\n+    private static Field<? extends FieldElement<?>> extractField(final FieldElement<? extends FieldElement<?>>[][] d)\n+        throws IllegalArgumentException {\n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+        if (d[0].length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+        return d[0][0].getField();\n+    }\n+\n+    /**\n+     * Get the elements type from an array.\n+     * @param d data array\n+     * @return field to which array elements belong\n+     * @exception IllegalArgumentException if array is empty\n+     */\n+    private static Field<? extends FieldElement<?>> extractField(final FieldElement<? extends FieldElement<?>>[] d)\n+        throws IllegalArgumentException {\n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+        return d[0].getField();\n+    }\n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    public FieldMatrixImpl(final Field<T> field) {\n+        super(field);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public FieldMatrixImpl(final Field<T> field,\n+                           final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(field, rowDimension, columnDimension);\n+        data = buildArray(rowDimension, columnDimension);\n+        final T zero = field.getZero();\n+        for (int i = 0; i < rowDimension; ++i) {\n+            Arrays.fill(data[i], zero);\n+        }\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #FieldMatrixImpl(T[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #FieldMatrixImpl(T[][], boolean)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public FieldMatrixImpl(final T[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        super((Field<T>) extractField(d));\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * FieldMatrix<T> and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #FieldMatrixImpl(T[][])\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public FieldMatrixImpl(final T[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        super((Field<T>) extractField(d));\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) FieldMatrix<T> using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public FieldMatrixImpl(final T[] v) {\n+        super((Field<T>) extractField(v));\n+        final int nRows = v.length;\n+        data = buildArray(nRows, 1);\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new FieldMatrixImpl<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+        return new FieldMatrixImpl<T>(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((FieldMatrixImpl<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public FieldMatrixImpl<T> add(final FieldMatrixImpl<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }\n+        }\n+\n+        return new FieldMatrixImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((FieldMatrixImpl<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public FieldMatrixImpl<T> subtract(final FieldMatrixImpl<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }\n+        }\n+\n+        return new FieldMatrixImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((FieldMatrixImpl<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public FieldMatrixImpl<T> multiply(final FieldMatrixImpl<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final T[][] outData = buildArray(nRows, nCols);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                T sum = getField().getZero();\n+                for (int i = 0; i < nSum; i++) {\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new FieldMatrixImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public T[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = buildArray(subMatrix.length, nCols);\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final T[] out = buildArray(nRows);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow = data[row];\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nCols; i++) {\n+                sum = sum.add(dataRow[i].multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final T[] out = buildArray(nCols);\n+        for (int col = 0; col < nCols; ++col) {\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nRows; ++i) {\n+                sum = sum.add(data[i][col].multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private T[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final T[][] out = buildArray(nRows, getColumnDimension());\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final T[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldMatrixPreservingVisitor<T extends FieldElement<?>> extends Serializable {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    void visit(int row, int column, T value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    T end();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a field-valued vector with basic algebraic operations.\n+ * <p>\n+ * vector element indexing is 0-based -- e.g., <code>getEntry(0)</code>\n+ * returns the first element of the vector.\n+ * </p>\n+ * <p>\n+ * The various <code>mapXxx</code> and <code>mapXxxToSelf</code> methods operate\n+ * on vectors element-wise, i.e. they perform the same operation (adding a scalar,\n+ * applying a function ...) on each element in turn. The <code>mapXxx</code>\n+ * versions create a new vector to hold the result and do not change the instance.\n+ * The <code>mapXxxToSelf</code> versions use the instance itself to store the\n+ * results, so the instance is changed by these methods. In both cases, the result\n+ * vector is returned by the methods, this allows to use the <i>fluent API</i>\n+ * style, like this:\n+ * </p>\n+ * <pre>\n+ *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n+ * </pre>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldVector<T extends FieldElement<T>> extends Serializable {\n+\n+    /**\n+     * Get the type of field elements of the vector.\n+     * @return type of field elements of the vector\n+     */\n+    Field<T> getField();\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     * @return vector copy\n+     */\n+    FieldVector<T> copy();\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> add(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> add(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> subtract(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> subtract(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * @param d value to be added to each entry\n+     * @return this + d\n+     */\n+    FieldVector<T> mapAdd(T d);\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be added to each entry\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapAddToSelf(T d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * @param d value to be subtracted to each entry\n+     * @return this - d\n+     */\n+    FieldVector<T> mapSubtract(T d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be subtracted to each entry\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapSubtractToSelf(T d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * @param d value to multiply all entries by\n+     * @return this * d\n+     */\n+    FieldVector<T> mapMultiply(T d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to multiply all entries by\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapMultiplyToSelf(T d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * @param d value to divide all entries by\n+     * @return this / d\n+     */\n+    FieldVector<T> mapDivide(T d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to divide all entries by\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapDivideToSelf(T d);\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    FieldVector<T> mapInv();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapInvToSelf();\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeMultiply(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeDivide(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns vector entries as a T array.\n+     * @return T array of entries\n+     */\n+     T[] getData();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    T dotProduct(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    T dotProduct(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> projection(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> projection(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldMatrix<T> outerProduct(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldMatrix<T> outerProduct(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     * <p>\n+     * The index start at 0 and must be lesser than the size,\n+     * otherwise a {@link MatrixIndexException} is thrown.\n+     * </p>\n+     * @param index  index location of entry to be fetched\n+     * @return vector entry at index\n+     * @throws MatrixIndexException if the index is not valid\n+     * @see #setEntry(int, T)\n+     */\n+    T getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #getEntry(int)\n+     */\n+    void setEntry(int index, T value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the size of the vector.\n+     * @return size\n+     */\n+    int getDimension();\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(FieldVector<T> v);\n+\n+    /**\n+     * Construct a vector by appending a T to this vector.\n+     * @param d T to append.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(T d);\n+\n+    /**\n+     * Construct a vector by appending a T array to this vector.\n+     * @param a T array to append.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(T[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    FieldVector<T> getSubVector(int index, int n)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, T[])\n+     */\n+    void setSubVector(int index, FieldVector<T> v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, FieldVector)\n+     */\n+    void setSubVector(int index, T[] v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    void set(T value);\n+\n+    /**\n+     * Convert the vector to a T array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    T[] toArray();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/FieldVectorImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * This class implements the {@link FieldVector<T>} interface with a {@link FieldElement} array.\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FieldVectorImpl<T extends FieldElement<T>> implements FieldVector<T> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7648186910365927050L;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of the vector. */\n+    protected T[] data;\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #FieldVectorImpl(FieldVectorImpl<T>, FieldVectorImpl<T>)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(T[])}, {@link #append(FieldVectorImpl<T>)}) to gather data\n+     * into this vector.</p>\n+     * @param field field to which the elements belong\n+     */\n+    public FieldVectorImpl(final Field<T> field) {\n+        this(field, 0);\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param field field to which the elements belong\n+     * @param size size of the vector\n+     */\n+    public FieldVectorImpl(Field<T> field, int size) {\n+        this.field = field;\n+        data = buildArray(size);\n+        Arrays.fill(data, field.getZero());\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public FieldVectorImpl(int size, T preset) {\n+        this(preset.getField(), size);\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of Ts.\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     */\n+    public FieldVectorImpl(T[] d)\n+        throws IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = d.clone();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\"); \n+        }\n+    }\n+\n+    /**\n+     * Create a new FieldVectorImpl using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * FieldVectorImpl and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #FieldVectorImpl(T[])\n+     */\n+    public FieldVectorImpl(T[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = copyArray ? d.clone() :  d;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of Ts.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public FieldVectorImpl(T[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        field = d[0].getField();\n+        data = buildArray(size);\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public FieldVectorImpl(FieldVector<T> v) {\n+        field = v.getField();\n+        data = buildArray(v.getDimension());\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public FieldVectorImpl(FieldVectorImpl<T> v) {\n+        field = v.getField();\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public FieldVectorImpl(FieldVectorImpl<T> v, boolean deep) {\n+        field = v.getField();\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public FieldVectorImpl(FieldVectorImpl<T> v1, FieldVectorImpl<T> v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.data.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public FieldVectorImpl(FieldVectorImpl<T> v1, T[] v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public FieldVectorImpl(T[] v1, FieldVectorImpl<T> v2) {\n+        field = v2.getField();\n+        data = buildArray(v1.length + v2.data.length);\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     * @exception IllegalArgumentException if both vectors are empty\n+     */\n+    public FieldVectorImpl(T[] v1, T[] v2) {\n+        try {\n+            data = buildArray(v1.length + v2.length);\n+            System.arraycopy(v1, 0, data, 0, v1.length);\n+            System.arraycopy(v2, 0, data, v1.length, v2.length);\n+            field = data[0].getField();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n+        return field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> copy() {\n+        return new FieldVectorImpl<T>(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return add((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].add(v.getEntry(i));\n+            }\n+            return new FieldVectorImpl<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(v[i]);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVectorImpl<T> add(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return (FieldVectorImpl<T>) add((T[]) v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return subtract((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].subtract(v.getEntry(i));\n+            }\n+            return new FieldVectorImpl<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(v[i]);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVectorImpl<T> subtract(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return (FieldVectorImpl<T>) subtract((T[]) v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAdd(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(d);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAddToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].add(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtract(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(d);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtractToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].subtract(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiply(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(d);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiplyToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].multiply(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivide(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].divide(d);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivideToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].divide(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInv() {\n+        T[] out = buildArray(data.length);\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = one.divide(data[i]);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInvToSelf() {\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = one.divide(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(v.getEntry(i));\n+            }\n+            return new FieldVectorImpl<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(v[i]);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVectorImpl<T> ebeMultiply(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return (FieldVectorImpl<T>) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v.getEntry(i));\n+            }\n+            return new FieldVectorImpl<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v[i]);\n+        }\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVectorImpl<T> ebeDivide(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return (FieldVectorImpl<T>) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public T[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T dot = field.getZero();\n+        for (int i = 0; i < data.length; i++) {\n+            dot = dot.add(data[i].multiply(v[i]));\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public T dotProduct(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(FieldVector<T> v) {\n+        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(T[] v) {\n+        return projection(new FieldVectorImpl<T>(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVectorImpl<T> projection(FieldVectorImpl<T> v) {\n+        return (FieldVectorImpl<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            final int m = data.length;\n+            final FieldMatrix<T> out = new FieldMatrixImpl<T>(field, m, m);\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n+                }\n+            }\n+            return out;\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldMatrix<T> outerProduct(FieldVectorImpl<T> v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final FieldMatrix<T> out = new FieldMatrixImpl<T>(field, m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i].multiply(v[j]));\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(FieldVector<T> v) {\n+        try {\n+            return append((FieldVectorImpl<T>) v);\n+        } catch (ClassCastException cce) {\n+            return new FieldVectorImpl<T>(this,new FieldVectorImpl<T>(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public FieldVectorImpl<T> append(FieldVectorImpl<T> v) {\n+        return new FieldVectorImpl<T>(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T in) {\n+        final T[] out = buildArray(data.length + 1);\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new FieldVectorImpl<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T[] in) {\n+        return new FieldVectorImpl<T>(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> getSubVector(int index, int n) {\n+        FieldVectorImpl<T> out = new FieldVectorImpl<T>(field, n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, T value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, FieldVector<T> v) {\n+        try {\n+            try {\n+                set(index, (FieldVectorImpl<T>) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, T[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, FieldVectorImpl<T> v)\n+        throws MatrixIndexException {\n+        setSubVector(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(T value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     * \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          FieldVector<T> rhs = (FieldVector<T>) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (!data[i].equals(rhs.getEntry(i))) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        int h = 3542;\n+        for (final T a : data) {\n+            h = h ^ a.hashCode();\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/decomposition/FieldDecompositionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear.decomposition;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldVector;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+\n+\n+/**\n+ * Interface handling decomposition algorithms that can solve A &times; X = B.\n+ * <p>Decomposition algorithms decompose an A matrix has a product of several specific\n+ * matrices from which they can solve A &times; X = B in least squares sense: they find X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n+ * square matrices and when the solution is an exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n+ * with non-square matrix A and with non-null minimal norm. If an exact linear\n+ * solution exists it is also the minimal norm solution.</p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldDecompositionSolver<T extends FieldElement<T>> extends Serializable {\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    T[] solve(final T[] b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldVector<T> solve(final FieldVector<T> b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldMatrix<T> solve(final FieldMatrix<T> b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    boolean isNonSingular();\n+\n+    /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldMatrix<T> getInverse()\n+        throws InvalidMatrixException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/decomposition/FieldLUDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear.decomposition;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.linear.FieldMatrix;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * LU-decomposition of a real matrix.\n+ * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n+ * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n+ * to rearrange the rows of A before so that it can be decomposed. L is a lower\n+ * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ * <ul>\n+ *   <li>a {@link #getP() getP} method has been added,</li>\n+ *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant()\n+ *   getDeterminant},</li>\n+ *   <li>the <code>getDoublePivot</code> method has been removed (but the int based\n+ *   {@link #getPivot() getPivot} method has been kept),</li>\n+ *   <li>the <code>solve</code> and <code>isNonSingular</code> methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @param <T> the type of the field elements\n+ * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldLUDecomposition<T extends FieldElement<T>> extends Serializable {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix (or null if decomposed matrix is singular)\n+     */\n+    FieldMatrix<T> getL();\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an upper-triangular matrix</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     */\n+    FieldMatrix<T> getU();\n+\n+    /**\n+     * Returns the P rows permutation matrix.\n+     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n+     * each row and each column, all other elements being set to 0.0.</p>\n+     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n+     * pivot permutation vector}.</p>\n+     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @see #getPivot()\n+     */\n+    FieldMatrix<T> getP();\n+\n+    /**\n+     * Returns the pivot permutation vector.\n+     * @return the pivot permutation vector\n+     * @see #getP()\n+     */\n+    int[] getPivot();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    T getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n+     * @return a solver\n+     */\n+    FieldDecompositionSolver<T> getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/decomposition/FieldLUDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear.decomposition;\n+\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.FieldVector;\n+import org.apache.commons.math.linear.FieldVectorImpl;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+\n+/**\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>Since {@link FieldElement field elements} do not provide an ordering\n+ * operator, the permutation matrix is computed here only in order to avoid\n+ * a zero pivot element, no attempt is done to get the largest pivot element.</p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FieldLUDecompositionImpl<T extends FieldElement<T>> implements FieldLUDecomposition<T> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1954692554563387537L;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of LU decomposition. */\n+    private T lu[][];\n+\n+    /** Pivot permutation associated with LU decomposition */\n+    private int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private boolean even;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private FieldMatrix<T> cachedL;\n+\n+    /** Cached value of U. */\n+    private FieldMatrix<T> cachedU;\n+\n+    /** Cached value of P. */\n+    private FieldMatrix<T> cachedP;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     * @exception NonSquareMatrixException if matrix is not square\n+     */\n+    public FieldLUDecompositionImpl(FieldMatrix<T> matrix)\n+        throws NonSquareMatrixException {\n+\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getColumnDimension();\n+        field = matrix.getField();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        even     = true;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            T sum = field.getZero();\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int nonZero = col; // permutation row\n+            for (int row = col; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+\n+                if (lu[nonZero][col].equals(field.getZero())) {\n+                    // try to select a better permutation choice\n+                    ++nonZero;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (nonZero >= m) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (nonZero != col) {\n+                T tmp = field.getZero();\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[nonZero][i];\n+                    lu[nonZero][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[nonZero];\n+                pivot[nonZero] = pivot[col];\n+                pivot[col] = temp;\n+                even = !even;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final T luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getL() {\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedL = new FieldMatrixImpl<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, field.getOne());\n+            }\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getU() {\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedU = new FieldMatrixImpl<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n+        }\n+        return cachedU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getP() {\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedP = new FieldMatrixImpl<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedP.setEntry(i, pivot[i], field.getOne());\n+            }\n+        }\n+        return cachedP;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T getDeterminant() {\n+        if (singular) {\n+            return field.getZero();\n+        } else {\n+            final int m = pivot.length;\n+            T determinant = even ? field.getOne() : field.getZero().subtract(field.getOne());\n+            for (int i = 0; i < m; i++) {\n+                determinant = determinant.multiply(lu[i][i]);\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldDecompositionSolver<T> getSolver() {\n+        return new Solver<T>(field, lu, pivot, singular);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver<T extends FieldElement<T>> implements FieldDecompositionSolver<T> {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -6353105415121373022L;\n+\n+        /** Field to which the elements belong. */\n+        private final Field<T> field;\n+\n+        /** Entries of LU decomposition. */\n+        private final T lu[][];\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param field field to which the matrix elements belong\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final Field<T> field, final T[][] lu,\n+                       final int[] pivot, final boolean singular) {\n+            this.field    = field;\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public T[] solve(T[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] = bp[col].divide(lu[col][col]);\n+                final T bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public FieldVector<T> solve(FieldVector<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((FieldVectorImpl<T>) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = pivot.length;\n+                if (b.getDimension() != m) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"vector length mismatch: got {0} but expected {1}\",\n+                            b.getDimension(), m);\n+                }\n+                if (singular) {\n+                    throw new SingularMatrixException();\n+                }\n+\n+                final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+\n+                // Apply permutations to b\n+                for (int row = 0; row < m; row++) {\n+                    bp[row] = b.getEntry(pivot[row]);\n+                }\n+\n+                // Solve LY = b\n+                for (int col = 0; col < m; col++) {\n+                    final T bpCol = bp[col];\n+                    for (int i = col + 1; i < m; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                // Solve UX = Y\n+                for (int col = m - 1; col >= 0; col--) {\n+                    bp[col] = bp[col].divide(lu[col][col]);\n+                    final T bpCol = bp[col];\n+                    for (int i = 0; i < col; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                return new FieldVectorImpl<T>(bp, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public FieldVectorImpl<T> solve(FieldVectorImpl<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            return new FieldVectorImpl<T>(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public FieldMatrix<T> solve(FieldMatrix<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n+            for (int row = 0; row < m; row++) {\n+                final T[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final T[] bpCol = bp[col];\n+                final T luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] = bpCol[j].divide(luDiag);\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            return new FieldMatrixImpl<T>(bp, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n+            final int m = pivot.length;\n+            final T one = field.getOne();\n+            FieldMatrix<T> identity = new FieldMatrixImpl<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                identity.setEntry(i, i, one);\n+            }\n+            return solve(identity);\n+        }\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/decomposition/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/decomposition/LUDecompositionImpl.java\n /**\n  * Calculates the LUP-decomposition of a square matrix.\n  * <p>The LUP-decomposition of a matrix A consists of three matrices\n- * L, U and P that satisfy: A = LUP, L is lower triangular, and U is\n+ * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\n  * upper triangular and P is a permutation matrix. All matrices are\n  * m&times;m.</p>\n  * <p>As shown by the presence of the P matrix, this decomposition is\n             // Pivot if necessary\n             if (max != col) {\n                 double tmp = 0;\n+                final double[] luMax = lu[max];\n+                final double[] luCol = lu[col];\n                 for (int i = 0; i < m; i++) {\n-                    tmp = lu[max][i];\n-                    lu[max][i] = lu[col][i];\n-                    lu[col][i] = tmp;\n+                    tmp = luMax[i];\n+                    luMax[i] = luCol[i];\n+                    luCol[i] = tmp;\n                 }\n                 int temp = pivot[max];\n                 pivot[max] = pivot[col];\n \n             // Solve LY = b\n             for (int col = 0; col < m; col++) {\n+                final double bpCol = bp[col];\n                 for (int i = col + 1; i < m; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n+                    bp[i] -= bpCol * lu[i][col];\n                 }\n             }\n \n             // Solve UX = Y\n             for (int col = m - 1; col >= 0; col--) {\n                 bp[col] /= lu[col][col];\n+                final double bpCol = bp[col];\n                 for (int i = 0; i < col; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n+                    bp[i] -= bpCol * lu[i][col];\n                 }\n             }\n \n \n                 // Solve LY = b\n                 for (int col = 0; col < m; col++) {\n+                    final double bpCol = bp[col];\n                     for (int i = col + 1; i < m; i++) {\n-                        bp[i] -= bp[col] * lu[i][col];\n+                        bp[i] -= bpCol * lu[i][col];\n                     }\n                 }\n \n                 // Solve UX = Y\n                 for (int col = m - 1; col >= 0; col--) {\n                     bp[col] /= lu[col][col];\n+                    final double bpCol = bp[col];\n                     for (int i = 0; i < col; i++) {\n-                        bp[i] -= bp[col] * lu[i][col];\n+                        bp[i] -= bpCol * lu[i][col];\n                     }\n                 }\n \n--- a/src/test/org/apache/commons/math/TestUtils.java\n+++ b/src/test/org/apache/commons/math/TestUtils.java\n \n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.complex.ComplexFormat;\n+import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n \n /**\n         }\n     }\n     \n+    /** verifies that two matrices are equal */              \n+    public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,\n+                                    FieldMatrix<? extends FieldElement<?>> observed) {\n+        \n+        if (observed == null) {\n+            Assert.fail(\"Observed is null\");\n+        }\n+        \n+        if (expected.getColumnDimension() != observed.getColumnDimension() || \n+                expected.getRowDimension() != observed.getRowDimension()) {\n+            StringBuffer messageBuffer = new StringBuffer();\n+            messageBuffer.append(\"Observed has incorrect dimensions.\"); \n+            messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() +\n+                    \" x \" + observed.getColumnDimension());\n+            messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() +\n+                    \" x \" + expected.getColumnDimension());\n+            Assert.fail(messageBuffer.toString());\n+        }\n+\n+        for (int i = 0; i < expected.getRowDimension(); ++i) {\n+            for (int j = 0; j < expected.getColumnDimension(); ++j) {\n+                FieldElement<?> eij = expected.getEntry(i, j);\n+                FieldElement<?> oij = observed.getEntry(i, j);\n+                Assert.assertEquals(eij, oij);\n+            }\n+        }\n+    }\n+    \n     /** verifies that two arrays are close (sup norm) */\n     public static void assertEquals(String msg, double[] m, double[] n,\n         double tolerance) {\n         }\n     }\n     \n+    /** verifies that two arrays are equal */\n+    public static void assertEquals(FieldElement<? extends FieldElement<?>>[] m,\n+                                    FieldElement<? extends FieldElement<?>>[] n) {\n+        if (m.length != n.length) {\n+            Assert.fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            Assert.assertEquals(m[i],n[i]);\n+        }\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n  *\n  * @version $Revision$ $Date$\n  */\n-\n+@Deprecated\n public final class BigMatrixImplTest extends TestCase {\n     \n     // Test data for String constructors\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.linear.decomposition.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n+\n+/**\n+ * Test cases for the {@link FieldMatrixImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class FieldMatrixImplTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };\n+    \n+    // Test data for group operations\n+    protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };\n+    protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};\n+    protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };\n+    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+       {new Fraction(-1),new Fraction(0),new Fraction(-8)} };\n+    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n+    protected Fraction[][] testDataInv = \n+        { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };\n+    protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};\n+    protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};\n+    protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};\n+    protected Fraction[][] testDataPlusInv = \n+        { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };\n+    \n+    // lu decomposition tests\n+    protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };\n+    protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };\n+    \n+    // singular matrices\n+    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n+    protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n+        {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd\n+    protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };\n+    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n+    \n+    // vectors\n+    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n+    \n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}}; \n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n+    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n+    protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}};\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}};\n+    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};\n+    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};\n+    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};\n+    // row matrices\n+    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};\n+    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};\n+    // column matrices\n+    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n+    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public FieldMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldMatrixImplTest.class);\n+        suite.setName(\"FieldMatrixImpl<Fraction> Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        FieldMatrixImpl<Fraction> m1 = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(m1.getData());\n+        assertEquals(m2,m1);\n+        FieldMatrixImpl<Fraction> m3 = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m4 = new FieldMatrixImpl<Fraction>(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        Fraction[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testDataInv);\n+        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        try {\n+            m.subtract(new FieldMatrixImpl<Fraction>(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n+        FieldMatrixImpl<Fraction> identity = new FieldMatrixImpl<Fraction>(id);\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        TestUtils.assertEquals(m.multiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.multiply(m), identity);\n+        TestUtils.assertEquals(m.multiply(identity), m);\n+        TestUtils.assertEquals(identity.multiply(mInv), mInv);\n+        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        try {\n+            m.multiply(new FieldMatrixImpl<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for FieldMatrixImpl<Fraction>Test.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};\n+    private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};\n+    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n+     \n+    public void testMultiply2() { \n+       FieldMatrix<Fraction> m3 = new FieldMatrixImpl<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new FieldMatrixImpl<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new FieldMatrixImpl<Fraction>(d5);\n+       TestUtils.assertEquals(m3.multiply(m4), m5);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(id);\n+        assertEquals(\"identity trace\",new Fraction(3),m.getTrace());\n+        m = new FieldMatrixImpl<Fraction>(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        TestUtils.assertEquals(new FieldMatrixImpl<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(id);\n+        TestUtils.assertEquals(testVector, m.operate(testVector));\n+        TestUtils.assertEquals(testVector, m.operate(new FieldVectorImpl<Fraction>(testVector)).getData());\n+        m = new FieldMatrixImpl<Fraction>(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }\n+        }, false);\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( new Fraction(3), b[0]);\n+        assertEquals( new Fraction(7), b[1]);\n+        assertEquals(new Fraction(11), b[2]);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(mIT, mTI);\n+        m = new FieldMatrixImpl<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new FieldMatrixImpl<Fraction>(testData2T);\n+        TestUtils.assertEquals(mt, m.transpose());\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n+        TestUtils.assertEquals(m.preMultiply(new FieldVectorImpl<Fraction>(testVector).getData()),\n+                               preMultTest);\n+        m = new FieldMatrixImpl<Fraction>(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = new FieldMatrixImpl<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new FieldMatrixImpl<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new FieldMatrixImpl<Fraction>(d5);\n+        TestUtils.assertEquals(m4.preMultiply(m3), m5);\n+        \n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n+        FieldMatrixImpl<Fraction> identity = new FieldMatrixImpl<Fraction>(id);\n+        TestUtils.assertEquals(m.preMultiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.preMultiply(m), identity);\n+        TestUtils.assertEquals(m.preMultiply(identity), m);\n+        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n+        try {\n+            m.preMultiply(new FieldMatrixImpl<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        TestUtils.assertEquals(m.getRow(0), testDataRow1);\n+        TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),new Fraction(2));\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = {\n+                {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                {new Fraction(2),new Fraction(5),new Fraction(3)}\n+        };\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = {\n+                {new Fraction(1),new Fraction(2)},\n+                {new Fraction(2),new Fraction(5)},\n+                {new Fraction(1), new Fraction(7)}\n+        };\n+        FieldMatrix<Fraction> n = new FieldMatrixImpl<Fraction>(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        Fraction[][] coefficientsData = {\n+                {new Fraction(2), new Fraction(3), new Fraction(-2)},\n+                {new Fraction(-1), new Fraction(7), new Fraction(6)},\n+                {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n+        };\n+        FieldMatrix<Fraction> coefficients = new FieldMatrixImpl<Fraction>(coefficientsData);\n+        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals(new Fraction(2).multiply(solution[0]).\n+                     add(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(2).multiply(solution[2])), constants[0]);\n+        assertEquals(new Fraction(-1).multiply(solution[0]).\n+                     add(new Fraction(7).multiply(solution[1])).\n+                     add(new Fraction(6).multiply(solution[2])), constants[1]);\n+        assertEquals(new Fraction(4).multiply(solution[0]).\n+                     subtract(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new FieldMatrixImpl<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new FieldMatrixImpl<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testCopySubMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                             new Fraction[1][1] :\n+                             new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new FieldMatrixImpl<Fraction>(reference), new FieldMatrixImpl<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                    new Fraction[1][1] :\n+                    new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new FieldMatrixImpl<Fraction>(reference), new FieldMatrixImpl<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new FieldMatrixImpl<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new FieldMatrixImpl<Fraction>(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new FieldMatrixImpl<Fraction>(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new FieldMatrixImpl<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new FieldMatrixImpl<Fraction>(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new FieldMatrixImpl<Fraction>(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new FieldVectorImpl<Fraction>(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        Fraction[] mColumn1 = columnToArray(subColumn1);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private Fraction[] columnToArray(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(Fraction[] expected, Fraction[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrixImpl<Fraction> m1 = (FieldMatrixImpl<Fraction>) m.copy();\n+        FieldMatrixImpl<Fraction> mt = (FieldMatrixImpl<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new FieldMatrixImpl<Fraction>(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        assertEquals(\"FieldMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance());\n+        assertEquals(\"FieldMatrixImpl{}\", m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        FieldMatrix<Fraction> expected = new FieldMatrixImpl<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                    {new Fraction(2),new Fraction(1),new Fraction(3)},\n+                    {new Fraction(1),new Fraction(2),new Fraction(4)}\n+             });\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new FieldMatrixImpl<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(1),new Fraction(3),new Fraction(3)},\n+                    {new Fraction(2),new Fraction(4),new Fraction(3)},\n+                    {new Fraction(1),new Fraction(2),new Fraction(4)}\n+             });\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new FieldMatrixImpl<Fraction>\n+            (new Fraction[][] {\n+                    {new Fraction(3),new Fraction(4),new Fraction(5)},\n+                    {new Fraction(4),new Fraction(7),new Fraction(5)},\n+                    {new Fraction(3),new Fraction(2),new Fraction(10)}\n+             });\n+        assertEquals(expected, m);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(FractionField.getInstance());\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        FieldMatrix<Fraction> m =\n+            new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+    \n+    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n+        private static final long serialVersionUID = -949750581026560454L;\n+        public SetVisitor() {\n+            super(Fraction.ZERO);\n+        }\n+        @Override\n+        public Fraction visit(int i, int j, Fraction value) {\n+            return new Fraction(i * 1024 + j, 1024);\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+        private static final long serialVersionUID = -8008915491884412915L;\n+        private int count;\n+        public GetVisitor() {\n+            super(Fraction.ZERO);\n+            count = 0;\n+        }\n+        @Override\n+        public void visit(int i, int j, Fraction value) {\n+            ++count;\n+            assertEquals(new Fraction(i * 1024 + j, 1024), value);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(FieldMatrix<Fraction> lu,\n+                           Fraction[][] lowerData,\n+                           Fraction[][] upperData)\n+        throws InvalidMatrixException {   \n+        if (!lu.isSquare() ||\n+            lowerData.length != lowerData[0].length ||\n+            upperData.length != upperData[0].length ||\n+            lowerData.length != upperData.length ||\n+            lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = Fraction.ZERO;\n+                } else if (i == j) {\n+                    lowerData[i][j] = Fraction.ONE;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = Fraction.ZERO;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        Fraction out[][] = new Fraction[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new FieldMatrixImpl<Fraction>(out);\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/FieldVectorImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link FieldVectorImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FieldVectorImplTest extends TestCase {\n+\n+    // \n+    protected Fraction[][] ma1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n+    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n+    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};\n+    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[][] mat1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+\n+    // Testclass to test the FieldVector<Fraction> interface \n+    // only with enough content to support the test\n+    public static class FieldVectorTestImpl<T extends FieldElement<T>>\n+        implements FieldVector<T>, Serializable {\n+\n+        private static final long serialVersionUID = 3970959016014158539L;\n+\n+        private final Field<T> field;\n+\n+        /** Entries of the vector. */\n+        protected T[] data;\n+\n+        /** Build an array of elements.\n+         * @param length size of the array to build\n+         * @return a new array\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        private T[] buildArray(final int length) {\n+            return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        }\n+\n+        public FieldVectorTestImpl(T[] d) {\n+            field = d[0].getField();\n+            data = d.clone();\n+        }\n+\n+        public Field<T> getField() {\n+            return field;\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public FieldVector<T> copy() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAdd(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAddToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtract(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtractToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapMultiply(T d) {\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(d);\n+            }\n+            return new FieldVectorTestImpl<T>(out);\n+        }\n+\n+        public FieldVector<T> mapMultiplyToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivide(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivideToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T[] getData() {\n+            return data.clone();\n+        }\n+\n+        public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+\n+        public T dotProduct(T[] v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v[i]));\n+            }\n+            return dot;\n+        }\n+\n+        public FieldVector<T> projection(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public FieldVector<T> append(FieldVector<T> v) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T[] a) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, T value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, FieldVector<T> v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(T value) {\n+            throw unsupported();\n+        }\n+\n+        public T[] toArray() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldVectorImplTest.class);\n+        suite.setName(\"FieldVectorImpl<Fraction> Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        FieldVectorImpl<Fraction> v0 = new FieldVectorImpl<Fraction>(FractionField.getInstance());\n+        assertEquals(0, v0.getDimension());\n+\n+        FieldVectorImpl<Fraction> v1 = new FieldVectorImpl<Fraction>(FractionField.getInstance(), 7);\n+        assertEquals(7, v1.getDimension());\n+        assertEquals(new Fraction(0), v1.getEntry(6));\n+\n+        FieldVectorImpl<Fraction> v2 = new FieldVectorImpl<Fraction>(5, new Fraction(123, 100));\n+        assertEquals(5, v2.getDimension());\n+        assertEquals(new Fraction(123, 100), v2.getEntry(4));\n+\n+        FieldVectorImpl<Fraction> v3 = new FieldVectorImpl<Fraction>(vec1);\n+        assertEquals(3, v3.getDimension());\n+        assertEquals(new Fraction(2), v3.getEntry(1));\n+\n+        FieldVectorImpl<Fraction> v4 = new FieldVectorImpl<Fraction>(vec4, 3, 2);\n+        assertEquals(2, v4.getDimension());\n+        assertEquals(new Fraction(4), v4.getEntry(0));\n+        try {\n+            new FieldVectorImpl<Fraction>(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVector<Fraction> v5_i = new FieldVectorImpl<Fraction>(dvec1);\n+        assertEquals(9, v5_i.getDimension());\n+        assertEquals(new Fraction(9), v5_i.getEntry(8));\n+\n+        FieldVectorImpl<Fraction> v5 = new FieldVectorImpl<Fraction>(dvec1);\n+        assertEquals(9, v5.getDimension());\n+        assertEquals(new Fraction(9), v5.getEntry(8));\n+\n+        FieldVectorImpl<Fraction> v6 = new FieldVectorImpl<Fraction>(dvec1, 3, 2);\n+        assertEquals(2, v6.getDimension());\n+        assertEquals(new Fraction(4), v6.getEntry(0));\n+        try {\n+            new FieldVectorImpl<Fraction>(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVectorImpl<Fraction> v7 = new FieldVectorImpl<Fraction>(v1);\n+        assertEquals(7, v7.getDimension());\n+        assertEquals(new Fraction(0), v7.getEntry(6));\n+\n+        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);\n+\n+        FieldVectorImpl<Fraction> v7_2 = new FieldVectorImpl<Fraction>(v7_i);\n+        assertEquals(3, v7_2.getDimension());\n+        assertEquals(new Fraction(2), v7_2.getEntry(1));\n+\n+        FieldVectorImpl<Fraction> v8 = new FieldVectorImpl<Fraction>(v1, true);\n+        assertEquals(7, v8.getDimension());\n+        assertEquals(new Fraction(0), v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        FieldVectorImpl<Fraction> v8_2 = new FieldVectorImpl<Fraction>(v1, false);\n+        assertEquals(7, v8_2.getDimension());\n+        assertEquals(new Fraction(0), v8_2.getEntry(6));\n+        assertEquals(v1.data, v8_2.data);\n+\n+        FieldVectorImpl<Fraction> v9 = new FieldVectorImpl<Fraction>(v1, v3);\n+        assertEquals(10, v9.getDimension());\n+        assertEquals(new Fraction(1), v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        FieldVectorImpl<Fraction> v1 = new FieldVectorImpl<Fraction>(vec1);\n+        FieldVectorImpl<Fraction> v2 = new FieldVectorImpl<Fraction>(vec2);\n+        FieldVectorImpl<Fraction> v4 = new FieldVectorImpl<Fraction>(vec4);\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        FieldVector<Fraction> v_append_1 = v1.append(v2);\n+        assertEquals(6, v_append_1.getDimension());\n+        assertEquals(new Fraction(4), v_append_1.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));\n+        assertEquals(4, v_append_2.getDimension());\n+        assertEquals(new Fraction(2), v_append_2.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_3 = v1.append(vec2);\n+        assertEquals(6, v_append_3.getDimension());\n+        assertEquals(new Fraction(4), v_append_3.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_4 = v1.append(v2_t);\n+        assertEquals(6, v_append_4.getDimension());\n+        assertEquals(new Fraction(4), v_append_4.getEntry(3));\n+\n+        FieldVector<Fraction> v_copy = v1.copy();\n+        assertEquals(3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        Fraction[] a_frac = v1.toArray();\n+        assertEquals(3, a_frac.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_frac);\n+\n+\n+//      FieldVectorImpl<Fraction> vout4 = (FieldVectorImpl<Fraction>) v1.clone();\n+//      assertEquals(3, vout4.getDimension());\n+//      assertEquals(v1.data, vout4.data);\n+\n+\n+        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);\n+        assertEquals(3, vout5.getDimension());\n+        assertEquals(new Fraction(5), vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVectorImpl<Fraction> v_set1 = (FieldVectorImpl<Fraction>) v1.copy();\n+        v_set1.setEntry(1, new Fraction(11));\n+        assertEquals(new Fraction(11), v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, new Fraction(11));\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVectorImpl<Fraction> v_set2 = (FieldVectorImpl<Fraction>) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(new Fraction(1), v_set2.getEntry(3));\n+        assertEquals(new Fraction(7), v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVectorImpl<Fraction> v_set3 = (FieldVectorImpl<Fraction>) v1.copy();\n+        v_set3.set(new Fraction(13));\n+        assertEquals(new Fraction(13), v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVectorImpl<Fraction> v_set4 = (FieldVectorImpl<Fraction>) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(new Fraction(4), v_set4.getEntry(3));\n+        assertEquals(new Fraction(7), v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        FieldVectorImpl<Fraction> vout10 = (FieldVectorImpl<Fraction>) v1.copy();       \n+        FieldVectorImpl<Fraction> vout10_2 = (FieldVectorImpl<Fraction>) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.setEntry(0, new Fraction(11, 10));\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        FieldVectorImpl<Fraction> v1 = new FieldVectorImpl<Fraction>(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n+        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n+        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n+        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n+        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n+        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n+        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n+        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n+        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInv = v1.mapInv();\n+        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        FieldVectorImpl<Fraction> v1 = new FieldVectorImpl<Fraction>(vec1);\n+        FieldVectorImpl<Fraction> v2 = new FieldVectorImpl<Fraction>(vec2);\n+        new FieldVectorImpl<Fraction>(vec_null);\n+\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        //octave =  v1 + v2\n+        FieldVectorImpl<Fraction> v_add = v1.add(v2);\n+        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add.getData(),result_add);\n+\n+        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);\n+        FieldVector<Fraction> v_add_i = v1.add(vt2);\n+        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+\n+        //octave =  v1 - v2\n+        FieldVectorImpl<Fraction> v_subtract = v1.subtract(v2);\n+        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract.getData(),result_subtract);\n+\n+        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);\n+        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i);\n+\n+        // octave v1 .* v2\n+        FieldVectorImpl<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);\n+        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply);\n+\n+        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);\n+\n+        // octave v1 ./ v2\n+        FieldVectorImpl<Fraction>  v_ebeDivide = v1.ebeDivide(v2);\n+        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide);\n+\n+        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2);\n+\n+        // octave  dot(v1,v2)\n+        Fraction dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(32), dot);\n+\n+        // octave  dot(v1,v2_t)\n+        Fraction dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+\n+        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+\n+        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+        FieldVectorImpl<Fraction> v_projection = v1.projection(v2);\n+        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection.getData(), result_projection);\n+\n+        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);\n+        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection_2.getData(), result_projection_2);\n+\n+    }  \n+\n+    public void testMisc() { \n+        FieldVectorImpl<Fraction> v1 = new FieldVectorImpl<Fraction>(vec1);\n+        FieldVectorImpl<Fraction> v4 = new FieldVectorImpl<Fraction>(vec4);\n+        FieldVector<Fraction> v4_2 = new FieldVectorImpl<Fraction>(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         Fraction[] dout1 = v1.copyOut();\n+        assertEquals(3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    /** verifies that two vectors are equals */\n+    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/decomposition/FieldLUDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear.decomposition;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+\n+public class FieldLUDecompositionImplTest extends TestCase {\n+    private Fraction[][] testData = {\n+            { new Fraction(1), new Fraction(2), new Fraction(3)},\n+            { new Fraction(2), new Fraction(5), new Fraction(3)},\n+            { new Fraction(1), new Fraction(0), new Fraction(8)}\n+    };\n+    private Fraction[][] testDataMinus = {\n+            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},\n+            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},\n+            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}\n+    };\n+    private Fraction[][] luData = {\n+            { new Fraction(2), new Fraction(3), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3), new Fraction(7) },\n+            { new Fraction(6), new Fraction(6), new Fraction(8) }\n+    };\n+    \n+    // singular matrices\n+    private Fraction[][] singular = {\n+            { new Fraction(2), new Fraction(3) },\n+            { new Fraction(2), new Fraction(3) }\n+    };\n+    private Fraction[][] bigSingular = {\n+            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },\n+            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },\n+            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }\n+    }; // 4th row = 1st + 2nd\n+\n+    public FieldLUDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FieldLUDecompositionImplTest.class);\n+        suite.setName(\"FieldLUDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertEquals(testData.length, LU.getL().getRowDimension());\n+        assertEquals(testData.length, LU.getL().getColumnDimension());\n+        assertEquals(testData.length, LU.getU().getRowDimension());\n+        assertEquals(testData.length, LU.getU().getColumnDimension());\n+        assertEquals(testData.length, LU.getP().getRowDimension());\n+        assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO },\n+                    { Fraction.ZERO, Fraction.ZERO }\n+            }));\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    public void testPAEqualLU() {\n+        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        FieldMatrix<Fraction> l = lu.getL();\n+        FieldMatrix<Fraction> u = lu.getU();\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new FieldMatrixImpl<Fraction>(testDataMinus);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), 17, 17);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            matrix.setEntry(i, i, Fraction.ONE);\n+        }\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n+\n+        matrix = new FieldMatrixImpl<Fraction>(singular);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+        matrix = new FieldMatrixImpl<Fraction>(bigSingular);\n+        lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n+        assertFalse(lu.getSolver().isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    public void testLLowerTriangular() {\n+        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            assertEquals(Fraction.ONE, l.getEntry(i, i));\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(Fraction.ZERO, l.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    public void testUUpperTriangular() {\n+        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(Fraction.ZERO, u.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    public void testPPermutation() {\n+        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();\n+\n+        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());\n+        FieldMatrix<Fraction> id  =\n+            new FieldMatrixImpl<Fraction>(FractionField.getInstance(),\n+                                          p.getRowDimension(), p.getRowDimension());\n+        for (int i = 0; i < id.getRowDimension(); ++i) {\n+            id.setEntry(i, i, Fraction.ONE);\n+        }\n+        TestUtils.assertEquals(id, ppT);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final Fraction e = p.getEntry(i, j);\n+                if (e.equals(Fraction.ZERO)) {\n+                    ++zeroCount;\n+                } else if (e.equals(Fraction.ONE)) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getRowDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    public void testSingular() {\n+        FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(testData));\n+        assertTrue(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(singular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+        lu = new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(bigSingular));\n+        assertFalse(lu.getSolver().isNonSingular());\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(testData));\n+        FieldMatrix<Fraction> lRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(2), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(-2), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1),  new Fraction(2), new Fraction(3) },\n+                { new Fraction(0), new Fraction(1), new Fraction(-3) },\n+                { new Fraction(0),  new Fraction(0), new Fraction(-1) }\n+        });\n+        FieldMatrix<Fraction> pRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) }\n+        });\n+        int[] pivotRef = { 0, 1, 2 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+       FieldLUDecomposition<Fraction> lu =\n+            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(luData));\n+        FieldMatrix<Fraction> lRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(3), new Fraction(1), new Fraction(0) },\n+                { new Fraction(1), new Fraction(0), new Fraction(1) }\n+        });\n+        FieldMatrix<Fraction> uRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(2), new Fraction(3), new Fraction(3)    },\n+                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },\n+                { new Fraction(0), new Fraction(0), new Fraction(4) }\n+        });\n+        FieldMatrix<Fraction> pRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(0), new Fraction(0) },\n+                { new Fraction(0), new Fraction(0), new Fraction(1) },\n+                { new Fraction(0), new Fraction(1), new Fraction(0) }\n+        });\n+        int[] pivotRef = { 0, 2, 1 };\n+\n+        // check values against known references\n+        FieldMatrix<Fraction> l = lu.getL();\n+        TestUtils.assertEquals(lRef, l);\n+        FieldMatrix<Fraction> u = lu.getU();\n+        TestUtils.assertEquals(uRef, u);\n+        FieldMatrix<Fraction> p = lu.getP();\n+        TestUtils.assertEquals(pRef, p);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+}", "timestamp": 1240159180, "metainfo": ""}