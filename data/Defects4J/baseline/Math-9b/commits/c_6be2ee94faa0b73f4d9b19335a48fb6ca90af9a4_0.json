{"sha": "6be2ee94faa0b73f4d9b19335a48fb6ca90af9a4", "log": "MATH-446 Removed checked exceptions. Some Javadoc cleanup. Tests upgraded to Junit 4 (MATH-423).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math/special/Beta.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.ContinuedFraction;\n import org.apache.commons.math.util.FastMath;\n \n  * @version $Revision$ $Date$\n  */\n public class Beta {\n-\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-15;\n \n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n-    private Beta() {\n-        super();\n-    }\n+    private Beta() {}\n \n     /**\n      * Returns the\n      * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n      * regularized beta function</a> I(x, a, b).\n      *\n-     * @param x the value.\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n-     * @return the regularized beta function I(x, a, b)\n+     * @param x Value.\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n+     * @return the regularized beta function I(x, a, b).\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n      * @throws MathException if the algorithm fails to converge.\n      */\n-    public static double regularizedBeta(double x, double a, double b)\n-        throws MathException\n-    {\n+    public static double regularizedBeta(double x, double a, double b) {\n         return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n \n      * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n      * regularized beta function</a> I(x, a, b).\n      *\n+     * @param x Value.\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n+     * @param epsilon When the absolute value of the nth item in the\n+     * series is less than epsilon the approximation ceases to calculate\n+     * further elements in the series.\n+     * @return the regularized beta function I(x, a, b)\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x,\n+                                         double a, double b,\n+                                         double epsilon) {\n+        return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the regularized beta function I(x, a, b).\n+     *\n      * @param x the value.\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n-     * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n-     * @return the regularized beta function I(x, a, b)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedBeta(double x, double a, double b,\n-        double epsilon) throws MathException\n-    {\n-        return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Returns the regularized beta function I(x, a, b).\n-     *\n-     * @param x the value.\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n      * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized beta function I(x, a, b)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedBeta(double x, double a, double b,\n-        int maxIterations) throws MathException\n-    {\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x,\n+                                         double a, double b,\n+                                         int maxIterations) {\n         return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n     }\n \n      * </ul>\n      *\n      * @param x the value.\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n      * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n+     * series is less than epsilon the approximation ceases to calculate\n+     * further elements in the series.\n      * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized beta function I(x, a, b)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedBeta(double x, final double a,\n-        final double b, double epsilon, int maxIterations) throws MathException\n-    {\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x,\n+                                         final double a, final double b,\n+                                         double epsilon, int maxIterations) {\n         double ret;\n \n-        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n-            (x > 1) || (a <= 0.0) || (b <= 0.0))\n-        {\n+        if (Double.isNaN(x) ||\n+            Double.isNaN(a) ||\n+            Double.isNaN(b) ||\n+            x < 0 ||\n+            x > 1 ||\n+            a <= 0.0 ||\n+            b <= 0.0) {\n             ret = Double.NaN;\n         } else if (x > (a + 1.0) / (a + b + 2.0)) {\n             ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n      *\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n-     * @return log(B(a, b))\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n+     * @return log(B(a, b)).\n      */\n     public static double logBeta(double a, double b) {\n         return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n      * Beta Function</a>, equation (1).</li>\n      * </ul>\n      *\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n+     * @param a Parameter {@code a}.\n+     * @param b Parameter {@code b}.\n      * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n+     * series is less than epsilon the approximation ceases to calculate\n+     * further elements in the series.\n      * @param maxIterations Maximum number of \"iterations\" to complete.\n-     * @return log(B(a, b))\n-     */\n-    public static double logBeta(double a, double b, double epsilon,\n-        int maxIterations) {\n-\n+     * @return log(B(a, b)).\n+     */\n+    public static double logBeta(double a, double b,\n+                                 double epsilon,\n+                                 int maxIterations) {\n         double ret;\n \n-        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n+        if (Double.isNaN(a) ||\n+            Double.isNaN(b) ||\n+            a <= 0.0 ||\n+            b <= 0.0) {\n             ret = Double.NaN;\n         } else {\n             ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n--- a/src/main/java/org/apache/commons/math/special/Erf.java\n+++ b/src/main/java/org/apache/commons/math/special/Erf.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class Erf {\n-\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n-    private Erf() {\n-        super();\n-    }\n+    private Erf() {}\n \n     /**\n-     * <p>Returns the error function</p>\n+     * Returns the error function.\n+     *\n      * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>\n      *\n      * <p>This implementation computes erf(x) using the\n      * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n      * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n      *\n-     * <p>The value returned is always between -1 and 1 (inclusive).  If {@code abs(x) > 40}, then\n-     * {@code erf(x)} is indistinguishable from either 1 or -1 as a double, so the appropriate extreme\n-     * value is returned.</p>\n+     * <p>The value returned is always between -1 and 1 (inclusive).\n+     * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n+     * either 1 or -1 as a double, so the appropriate extreme value is returned.\n+     * </p>\n      *\n      * @param x the value.\n      * @return the error function erf(x)\n-     * @throws MathException if the algorithm fails to converge.\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n      * @see Gamma#regularizedGammaP(double, double, double, int)\n      */\n-    public static double erf(double x) throws MathException {\n+    public static double erf(double x) {\n         if (FastMath.abs(x) > 40) {\n             return x > 0 ? 1 : -1;\n         }\n     }\n \n     /**\n-     * <p>Returns the complementary error function</p>\n-     * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt <br/>\n+     * Returns the complementary error function.\n+     *\n+     * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt\n+     * <br/>\n      *    = 1 - {@link #erf(double) erf(x)} </p>\n      *\n      * <p>This implementation computes erfc(x) using the\n      * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n      * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n      *\n-     * <p>The value returned is always between 0 and 2 (inclusive).  If {@code abs(x) > 40}, then\n-     * {@code erf(x)} is indistinguishable from either 0 or 2 as a double, so the appropriate extreme\n-     * value is returned.</p>\n+     * <p>The value returned is always between 0 and 2 (inclusive).\n+     * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n+     * either 0 or 2 as a double, so the appropriate extreme value is returned.\n+     * </p>\n      *\n      * @param x the value\n      * @return the complementary error function erfc(x)\n-     * @throws MathException if the algorithm fails to converge\n+     * @throws org.apache.commons.math.exception.MaxCountExceededException\n+     * if the algorithm fails to converge.\n      * @see Gamma#regularizedGammaQ(double, double, double, int)\n      * @since 2.2\n      */\n-    public static double erfc(double x) throws MathException {\n+    public static double erfc(double x) {\n         if (FastMath.abs(x) > 40) {\n             return x > 0 ? 0 : 2;\n         }\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.util.ContinuedFraction;\n import org.apache.commons.math.util.FastMath;\n  * @version $Revision$ $Date$\n  */\n public class Gamma {\n-\n     /**\n      * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n      * @since 2.0\n      */\n     public static final double GAMMA = 0.577215664901532860606512090082;\n-\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-15;\n-\n     /** Lanczos coefficients */\n-    private static final double[] LANCZOS =\n-    {\n+    private static final double[] LANCZOS = {\n         0.99999999999999709182,\n         57.156235665862923517,\n         -59.597960355475491248,\n         -.26190838401581408670e-4,\n         .36899182659531622704e-5,\n     };\n-\n     /** Avoid repeated computation of log of 2 PI in logGamma */\n     private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2.0 * FastMath.PI);\n-\n     // limits for switching algorithm in digamma\n     /** C limit. */\n     private static final double C_LIMIT = 49;\n-\n     /** S limit. */\n     private static final double S_LIMIT = 1e-5;\n \n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n-    private Gamma() {\n-        super();\n-    }\n+    private Gamma() {}\n \n     /**\n      * Returns the natural logarithm of the gamma function &#915;(x).\n      * </a></li>\n      * </ul>\n      *\n-     * @param x the value.\n+     * @param x Value.\n      * @return log(&#915;(x))\n      */\n     public static double logGamma(double x) {\n     /**\n      * Returns the regularized gamma function P(a, x).\n      *\n-     * @param a the a parameter.\n-     * @param x the value.\n-     * @return the regularized gamma function P(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedGammaP(double a, double x)\n-        throws MathException\n-    {\n+     * @param a Parameter.\n+     * @param x Value.\n+     * @return the regularized gamma function P(a, x).\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaP(double a, double x) {\n         return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n-\n \n     /**\n      * Returns the regularized gamma function P(a, x).\n      *\n      * The implementation of this method is based on:\n      * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n-     * Regularized Gamma Function</a>, equation (1).</li>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n-     * Incomplete Gamma Function</a>, equation (4).</li>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n-     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n-     * </li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     *   Regularized Gamma Function</a>, equation (1)\n+     *  </li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n+     *   Incomplete Gamma Function</a>, equation (4).\n+     *  </li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n+     *   Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n+     *  </li>\n      * </ul>\n      *\n      * @param a the a parameter.\n      * @param x the value.\n      * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n+     * series is less than epsilon the approximation ceases to calculate\n+     * further elements in the series.\n      * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized gamma function P(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n     public static double regularizedGammaP(double a,\n                                            double x,\n                                            double epsilon,\n-                                           int maxIterations)\n-        throws MathException\n-    {\n+                                           int maxIterations) {\n         double ret;\n \n         if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n             double n = 0.0; // current element index\n             double an = 1.0 / a; // n-th element in the series\n             double sum = an; // partial sum\n-            while (FastMath.abs(an/sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n+            while (FastMath.abs(an/sum) > epsilon &&\n+                   n < maxIterations &&\n+                   sum < Double.POSITIVE_INFINITY) {\n                 // compute next element in the series\n                 n = n + 1.0;\n                 an = an * (x / (a + n));\n      * @return the regularized gamma function Q(a, x)\n      * @throws MathException if the algorithm fails to converge.\n      */\n-    public static double regularizedGammaQ(double a, double x)\n-        throws MathException\n-    {\n+    public static double regularizedGammaQ(double a, double x) {\n         return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n \n      *\n      * The implementation of this method is based on:\n      * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n-     * Regularized Gamma Function</a>, equation (1).</li>\n-     * <li>\n-     * <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n-     * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     *   Regularized Gamma Function</a>, equation (1).\n+     *  </li>\n+     *  <li>\n+     *   <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n+     *   Regularized incomplete gamma function: Continued fraction representations\n+     *   (formula 06.08.10.0003)</a>\n+     *  </li>\n      * </ul>\n      *\n      * @param a the a parameter.\n      * @param x the value.\n      * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n+     * series is less than epsilon the approximation ceases to calculate\n+     * further elements in the series.\n      * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized gamma function P(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n     public static double regularizedGammaQ(final double a,\n                                            double x,\n                                            double epsilon,\n-                                           int maxIterations)\n-        throws MathException\n-    {\n+                                           int maxIterations) {\n         double ret;\n \n         if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n      * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n      * less than 10^5 and 10^-8 relative for results larger than that.</p>\n      *\n-     * @param x  the argument\n-     * @return   digamma(x) to within 10-8 relative or absolute error whichever is smaller\n-     * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\"> Digamma at wikipedia </a>\n-     * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\"> Bernardo&apos;s original article </a>\n+     * @param x Argument.\n+     * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma</a>\n+     * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\">Bernardo&apos;s original article </a>\n      * @since 2.0\n      */\n     public static double digamma(double x) {\n     }\n \n     /**\n-     * <p>Computes the trigamma function of x.  This function is derived by taking the derivative of\n-     * the implementation of digamma.</p>\n-     *\n-     * @param x  the argument\n-     * @return   trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n-     * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\"> Trigamma at wikipedia </a>\n+     * Computes the trigamma function of x.\n+     * This function is derived by taking the derivative of the implementation\n+     * of digamma.\n+     *\n+     * @param x Argument.\n+     * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma</a>\n      * @see Gamma#digamma(double)\n      * @since 2.0\n      */\n--- a/src/test/java/org/apache/commons/math/special/BetaTest.java\n+++ b/src/test/java/org/apache/commons/math/special/BetaTest.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class BetaTest extends TestCase {\n-    /**\n-     * Constructor for BetaTest.\n-     * @param name\n-     */\n-    public BetaTest(String name) {\n-        super(name);\n-    }\n-\n-    private void testRegularizedBeta(double expected, double x, double a,\n-        double b)\n-    {\n-        try {\n-            double actual = Beta.regularizedBeta(x, a, b);\n-            TestUtils.assertEquals(expected, actual, 10e-15);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+public class BetaTest {\n+    private void testRegularizedBeta(double expected, double x,\n+                                     double a, double b) {\n+        double actual = Beta.regularizedBeta(x, a, b);\n+        TestUtils.assertEquals(expected, actual, 10e-15);\n     }\n \n     private void testLogBeta(double expected, double a, double b) {\n         TestUtils.assertEquals(expected, actual, 10e-15);\n     }\n \n+    @Test\n     public void testRegularizedBetaNanPositivePositive() {\n         testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositiveNanPositive() {\n         testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositivePositiveNan() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);\n     }\n \n+    @Test\n     public void testRegularizedBetaNegativePositivePositive() {\n         testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositiveNegativePositive() {\n         testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositivePositiveNegative() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaZeroPositivePositive() {\n         testRegularizedBeta(0.0, 0.0, 1.0, 2.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositiveZeroPositive() {\n         testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositivePositiveZero() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);\n     }\n \n+    @Test\n     public void testRegularizedBetaPositivePositivePositive() {\n         testRegularizedBeta(0.75, 0.5, 1.0, 2.0);\n     }\n \n+    @Test\n     public void testLogBetaNanPositive() {\n         testLogBeta(Double.NaN, Double.NaN, 2.0);\n     }\n \n+    @Test\n     public void testLogBetaPositiveNan() {\n         testLogBeta(Double.NaN, 1.0, Double.NaN);\n     }\n \n+    @Test\n     public void testLogBetaNegativePositive() {\n         testLogBeta(Double.NaN, -1.0, 2.0);\n     }\n \n+    @Test\n     public void testLogBetaPositiveNegative() {\n         testLogBeta(Double.NaN, 1.0, -2.0);\n     }\n \n+    @Test\n     public void testLogBetaZeroPositive() {\n         testLogBeta(Double.NaN, 0.0, 2.0);\n     }\n \n+    @Test\n     public void testLogBetaPositiveZero() {\n         testLogBeta(Double.NaN, 1.0, 0.0);\n     }\n \n+    @Test\n     public void testLogBetaPositivePositive() {\n         testLogBeta(-0.693147180559945, 1.0, 2.0);\n     }\n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n \n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class ErfTest extends TestCase {\n-\n-    public void testErf0() throws MathException {\n+public class ErfTest {\n+    @Test\n+    public void testErf0() {\n         double actual = Erf.erf(0.0);\n         double expected = 0.0;\n-        assertEquals(expected, actual, 1.0e-15);\n-        assertEquals(1 - expected, Erf.erfc(0.0), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-15);\n+        Assert.assertEquals(1 - expected, Erf.erfc(0.0), 1.0e-15);\n     }\n \n-    public void testErf1960() throws MathException {\n+    @Test\n+    public void testErf1960() {\n         double x = 1.960 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.95;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);\n \n         actual = Erf.erf(-x);\n         expected = -expected;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n     }\n \n-    public void testErf2576() throws MathException {\n+    @Test\n+    public void testErf2576() {\n         double x = 2.576 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.99;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(x), 1e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(x), 1e-15);\n \n         actual = Erf.erf(-x);\n         expected = -expected;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n     }\n \n-    public void testErf2807() throws MathException {\n+    @Test\n+    public void testErf2807() {\n         double x = 2.807 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.995;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);\n \n         actual = Erf.erf(-x);\n         expected = -expected;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);\n     }\n \n-    public void testErf3291() throws MathException {\n+    @Test\n+    public void testErf3291() {\n         double x = 3.291 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.999;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - expected, Erf.erfc(x), 1.0e-5);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - expected, Erf.erfc(x), 1.0e-5);\n \n         actual = Erf.erf(-x);\n         expected = -expected;\n-        assertEquals(expected, actual, 1.0e-5);\n-        assertEquals(1 - expected, Erf.erfc(-x), 1.0e-5);\n+        Assert.assertEquals(expected, actual, 1.0e-5);\n+        Assert.assertEquals(1 - expected, Erf.erfc(-x), 1.0e-5);\n     }\n     \n     /**\n      * MATH-301, MATH-456\n      */\n+    @Test\n     public void testLargeValues() throws Exception {\n         for (int i = 1; i < 200; i*=10) {\n             double result = Erf.erf(i);\n-            assertFalse(Double.isNaN(result));\n-            assertTrue(result > 0 && result <= 1);\n+            Assert.assertFalse(Double.isNaN(result));\n+            Assert.assertTrue(result > 0 && result <= 1);\n             result = Erf.erf(-i);\n-            assertFalse(Double.isNaN(result));\n-            assertTrue(result >= -1 && result < 0);\n+            Assert.assertFalse(Double.isNaN(result));\n+            Assert.assertTrue(result >= -1 && result < 0);\n             result = Erf.erfc(i);\n-            assertFalse(Double.isNaN(result));\n-            assertTrue(result >= 0 && result < 1);\n+            Assert.assertFalse(Double.isNaN(result));\n+            Assert.assertTrue(result >= 0 && result < 1);\n             result = Erf.erfc(-i);\n-            assertFalse(Double.isNaN(result));\n-            assertTrue(result >= 1 && result <= 2);    \n+            Assert.assertFalse(Double.isNaN(result));\n+            Assert.assertTrue(result >= 1 && result <= 2);    \n         }\n-        assertEquals(-1, Erf.erf(Double.NEGATIVE_INFINITY), 0);\n-        assertEquals(1, Erf.erf(Double.POSITIVE_INFINITY), 0);\n-        assertEquals(2, Erf.erfc(Double.NEGATIVE_INFINITY), 0);\n-        assertEquals(0, Erf.erfc(Double.POSITIVE_INFINITY), 0);\n+        Assert.assertEquals(-1, Erf.erf(Double.NEGATIVE_INFINITY), 0);\n+        Assert.assertEquals(1, Erf.erf(Double.POSITIVE_INFINITY), 0);\n+        Assert.assertEquals(2, Erf.erfc(Double.NEGATIVE_INFINITY), 0);\n+        Assert.assertEquals(0, Erf.erfc(Double.POSITIVE_INFINITY), 0);\n     }\n     \n     /**\n      * Compare Erf.erf against reference values computed using GCC 4.2.1 (Apple OSX packaged version)\n      * erfl (extended precision erf).\n      */\n+    @Test\n     public void testErfGnu() throws Exception {\n         final double tol = 1E-15;\n         final double[] gnuValues = new double[] {-1, -1, -1, -1, -1, \n          1,  1,  1,  1};\n         double x = -10d;\n         for (int i = 0; i < 41; i++) {\n-            assertEquals(gnuValues[i], Erf.erf(x), tol);\n+            Assert.assertEquals(gnuValues[i], Erf.erf(x), tol);\n             x += 0.5d;\n         }\n     }\n      * Compare Erf.erfc against reference values computed using GCC 4.2.1 (Apple OSX packaged version)\n      * erfcl (extended precision erfc).\n      */\n+    @Test\n     public void testErfcGnu() throws Exception {\n         final double tol = 1E-15;\n         final double[] gnuValues = new double[] { 2,  2,  2,  2,  2, \n         2.7623240713337714448E-33, 4.1370317465138102353E-37, 3.7692144856548799402E-41, 2.0884875837625447567E-45};\n         double x = -10d;\n         for (int i = 0; i < 41; i++) {\n-            assertEquals(gnuValues[i], Erf.erfc(x), tol);\n+            Assert.assertEquals(gnuValues[i], Erf.erfc(x), tol);\n             x += 0.5d;\n         }\n     }\n      * \"Evaluating the Normal Distribution,\" Journal of Statistical Software, July, 2004.\n      * http//www.jstatsoft.org/v11/a05/paper\n      */\n+    @Test\n     public void testErfcMaple() throws Exception {\n         double[][] ref = new double[][]\n                         {{0.1, 4.60172162722971e-01},\n         };\n         for (int i = 0; i < 15; i++) {\n             final double result = 0.5*Erf.erfc(ref[i][0]/Math.sqrt(2));\n-            assertEquals(ref[i][1], result, 1E-15);\n+            Assert.assertEquals(ref[i][1], result, 1E-15);\n             TestUtils.assertRelativelyEquals(ref[i][1], result, 1E-13);\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/special/GammaTest.java\n+++ b/src/test/java/org/apache/commons/math/special/GammaTest.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class GammaTest extends TestCase {\n-\n-    public GammaTest(String name) {\n-        super(name);\n-    }\n-\n+public class GammaTest {\n     private void testRegularizedGamma(double expected, double a, double x) {\n-        try {\n-            double actualP = Gamma.regularizedGammaP(a, x);\n-            double actualQ = Gamma.regularizedGammaQ(a, x);\n-            TestUtils.assertEquals(expected, actualP, 10e-15);\n-            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        double actualP = Gamma.regularizedGammaP(a, x);\n+        double actualQ = Gamma.regularizedGammaQ(a, x);\n+        TestUtils.assertEquals(expected, actualP, 10e-15);\n+        TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);\n     }\n \n     private void testLogGamma(double expected, double x) {\n         TestUtils.assertEquals(expected, actual, 10e-15);\n     }\n \n+    @Test\n     public void testRegularizedGammaNanPositive() {\n         testRegularizedGamma(Double.NaN, Double.NaN, 1.0);\n     }\n \n+    @Test\n     public void testRegularizedGammaPositiveNan() {\n         testRegularizedGamma(Double.NaN, 1.0, Double.NaN);\n     }\n \n+    @Test\n     public void testRegularizedGammaNegativePositive() {\n         testRegularizedGamma(Double.NaN, -1.5, 1.0);\n     }\n \n+    @Test\n     public void testRegularizedGammaPositiveNegative() {\n         testRegularizedGamma(Double.NaN, 1.0, -1.0);\n     }\n \n+    @Test\n     public void testRegularizedGammaZeroPositive() {\n         testRegularizedGamma(Double.NaN, 0.0, 1.0);\n     }\n \n+    @Test\n     public void testRegularizedGammaPositiveZero() {\n         testRegularizedGamma(0.0, 1.0, 0.0);\n     }\n \n+    @Test\n     public void testRegularizedGammaPositivePositive() {\n         testRegularizedGamma(0.632120558828558, 1.0, 1.0);\n     }\n \n+    @Test\n     public void testLogGammaNan() {\n         testLogGamma(Double.NaN, Double.NaN);\n     }\n \n+    @Test\n     public void testLogGammaNegative() {\n         testLogGamma(Double.NaN, -1.0);\n     }\n \n+    @Test\n     public void testLogGammaZero() {\n         testLogGamma(Double.NaN, 0.0);\n     }\n \n+    @Test\n     public void testLogGammaPositive() {\n         testLogGamma(0.6931471805599457, 3.0);\n     }\n \n+    @Test\n     public void testDigammaLargeArgs() {\n         double eps = 1e-8;\n-        assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);\n-        assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);\n-        assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);\n-        assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);\n-        assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);\n-        assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);\n-        assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);\n-        assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);\n-        assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);\n-        assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);\n-        assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);\n+        Assert.assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);\n+        Assert.assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);\n+        Assert.assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);\n+        Assert.assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);\n+        Assert.assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);\n+        Assert.assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);\n+        Assert.assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);\n+        Assert.assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);\n+        Assert.assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);\n+        Assert.assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);\n+        Assert.assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);\n     }\n \n+    @Test\n     public void testDigammaSmallArgs() {\n         // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits\n         // see functions.wolfram.com\n         }\n     }\n \n+    @Test\n     public void testTrigamma() {\n         double eps = 1e-8;\n         // computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use\n                 100, 0.010050166663333571395\n         };\n         for (int i = data.length - 2; i >= 0; i -= 2) {\n-            assertEquals(String.format(\"trigamma %.0f\", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);\n+            Assert.assertEquals(String.format(\"trigamma %.0f\", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);\n         }\n     }\n \n     private void checkRelativeError(String msg, double expected, double actual, double tolerance) {\n-        assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual));\n+        Assert.assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual));\n     }\n }", "timestamp": 1300574999, "metainfo": ""}