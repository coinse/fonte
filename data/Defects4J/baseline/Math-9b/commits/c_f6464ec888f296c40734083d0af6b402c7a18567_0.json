{"sha": "f6464ec888f296c40734083d0af6b402c7a18567", "log": "\"PowellOptimizer\": Added a constructor for setting of the absolute tolerance, removed one redundant function evaluation. Line search relative tolerance explicitly set in the optimizer instance created in \"PowellOptimizerTest\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/PowellOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import java.util.Arrays;\n+\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n public class PowellOptimizer\n     extends AbstractScalarOptimizer {\n     /**\n-     * Defautl line search tolerance ({@value}).\n-     */\n-    public static final double DEFAULT_LINE_SEARCH_TOLERANCE = 1e-7;\n+     * Default relative tolerance for line search ({@value}).\n+     */\n+    public static final double DEFAULT_LS_RELATIVE_TOLERANCE = 1e-7;\n+    /**\n+     * Default absolute tolerance for line search ({@value}).\n+     */\n+    public static final double DEFAULT_LS_ABSOLUTE_TOLERANCE = 1e-11;\n     /**\n      * Line search.\n      */\n     private final LineSearch line;\n \n     /**\n-     * Constructor using the default line search tolerance (see the\n-     * {@link #PowellOptimizer(double) other constructor}).\n+     * Constructor with default line search tolerances (see the\n+     * {@link #PowellOptimizer(double,double) other constructor}).\n      */\n     public PowellOptimizer() {\n-        this(DEFAULT_LINE_SEARCH_TOLERANCE);\n-    }\n-\n-    /**\n-     * @param lineSearchTolerance Relative error tolerance for the line search\n-     * algorithm ({@link BrentOptimizer}).\n-     */\n-    public PowellOptimizer(double lineSearchTolerance) {\n-        line = new LineSearch(lineSearchTolerance);\n+        this(DEFAULT_LS_RELATIVE_TOLERANCE,\n+             DEFAULT_LS_ABSOLUTE_TOLERANCE);\n+    }\n+\n+    /**\n+     * Constructor with default absolute line search tolerances (see\n+     * the {@link #PowellOptimizer(double,double) other constructor}).\n+     *\n+     * @param lsRelativeTolerance Relative error tolerance for\n+     * the line search algorithm ({@link BrentOptimizer}).\n+     */\n+    public PowellOptimizer(double lsRelativeTolerance) {\n+        this(lsRelativeTolerance,\n+             DEFAULT_LS_ABSOLUTE_TOLERANCE);\n+    }\n+\n+    /**\n+     * @param lsRelativeTolerance Relative error tolerance for\n+     * the line search algorithm ({@link BrentOptimizer}).\n+     * @param lsAbsoluteTolerance Relative error tolerance for\n+     * the line search algorithm ({@link BrentOptimizer}).\n+     */\n+    public PowellOptimizer(double lsRelativeTolerance,\n+                           double lsAbsoluteTolerance) {\n+        line = new LineSearch(lsRelativeTolerance,\n+                              lsAbsoluteTolerance);\n     }\n \n     /** {@inheritDoc} */\n             int bigInd = 0;\n             double alphaMin = 0;\n \n-            double[] direc1 = new double[n];\n+            double[] direc1 = null;\n             for (int i = 0; i < n; i++) {\n-                direc1 = direc[i];\n+                direc1 = Arrays.copyOf(direc[i], n);\n \n                 fX2 = fVal;\n \n         private double valueAtOptimum = Double.NaN;\n \n         /**\n-         * @param tolerance Relative tolerance.\n-         */\n-        public LineSearch(double tolerance) {\n-            optim.setRelativeAccuracy(tolerance);\n-            optim.setAbsoluteAccuracy(Math.ulp(1d));\n+         * @param relativeTolerance Relative tolerance.\n+         * @param absoluteTolerance Absolute tolerance.\n+         */\n+        public LineSearch(double relativeTolerance,\n+                          double absoluteTolerance) {\n+            optim.setRelativeAccuracy(relativeTolerance);\n+            optim.setAbsoluteAccuracy(absoluteTolerance);\n         }\n \n         /**\n         public void search(final double[] p,\n                            final double[] d)\n             throws OptimizationException {\n+\n+            // Reset.\n+            optimum = Double.NaN;\n+            valueAtOptimum = Double.NaN;\n+\n             try {\n                 final int n = p.length;\n                 final UnivariateRealFunction f = new UnivariateRealFunction() {\n                             for (int i = 0; i < n; i++) {\n                                 x[i] = p[i] + alpha * d[i];\n                             }\n-                            return computeObjectiveValue(x);\n+                            final double obj = computeObjectiveValue(x);\n+                            return obj;\n                         }\n                     };\n \n                                          bracket.getLo(),\n                                          bracket.getHi(),\n                                          bracket.getMid());\n-                valueAtOptimum = f.value(optimum);\n+                valueAtOptimum = optim.getFunctionValue();\n             } catch (FunctionEvaluationException e) {\n                 throw new OptimizationException(e);\n             } catch (MaxIterationsExceededException e) {\n--- a/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/PowellOptimizerTest.java\n     public void testSumSinc() throws MathException {\n         final MultivariateRealFunction func = new SumSincFunction(-1);\n \n-        int dim = 10;\n+        int dim = 2;\n         final double[] minPoint = new double[dim];\n         for (int i = 0; i < dim; i++) {\n             minPoint[i] = 0;\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i];\n         }\n-        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n+        // doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-7);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i] + 3;\n         }\n-        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-7);\n     }\n \n     @Test\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i];\n         }\n-        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-8);\n+        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-5, 1e-9, 1e-8);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = minPoint[i] - 20;\n         }\n-        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);\n+        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-5, 1e-9, 1e-8);\n     }\n \n     @Test\n         for (int i = 0; i < dim; i++) {\n             init[i] = maxPoint[i];\n         }\n-        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);\n+        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-5, 1e-9, 1e-8);\n \n         // Initial is far from minimum.\n         for (int i = 0; i < dim; i++) {\n             init[i] = maxPoint[i] - 20;\n         }\n-        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);\n+        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-5, 1e-9, 1e-8);\n     }\n \n     /**\n      * @param optimum Expected optimum.\n      * @param init Starting point.\n      * @param goal Minimization or maximization.\n-     * @param objTol Tolerance (relative error on the objective function).\n-     * @param pointTol Tolerance on the position of the optimum.\n+     * @param xTol Tolerance (relative error on the objective function) for\n+     * \"Brent\" line search algorithm used by \"Powell\".\n+     * @param fTol Tolerance (relative error on the objective function) for\n+     * \"Powell\" algorithm.\n+     * @param pointTol Tolerance for checking that the optimum is correct.\n      */\n     private void doTest(MultivariateRealFunction func,\n                         double[] optimum,\n                         double[] init,\n                         GoalType goal,\n-                        double objTol,\n+                        double xTol,\n+                        double fTol,\n                         double pointTol)\n         throws MathException {\n-        final MultivariateRealOptimizer optim = new PowellOptimizer();\n-        optim.setConvergenceChecker(new SimpleScalarValueChecker(objTol, -1));\n+        final MultivariateRealOptimizer optim = new PowellOptimizer(xTol);\n+        optim.setConvergenceChecker(new SimpleScalarValueChecker(fTol, -1));\n \n         final RealPointValuePair result = optim.optimize(func, goal, init);\n         final double[] found = result.getPoint();", "timestamp": 1281018373, "metainfo": ""}