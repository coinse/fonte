{"sha": "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1", "log": "Separate implementation of secant solver from bracketing solvers.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.MathInternalError;\n \n /**\n- * Base class for all <em>Secant</em>-based methods for root-finding\n+ * Base class for all bracketing <em>Secant</em>-based methods for root-finding\n  * (approximating a zero of a univariate real function).\n  *\n- * <p>Implementation of the {@link SecantSolver <em>Secant</em>},\n- * {@link RegulaFalsiSolver <em>Regula Falsi</em>}, and\n+ * <p>Implementation of the {@link RegulaFalsiSolver <em>Regula Falsi</em>}, and\n  * {@link IllinoisSolver <em>Illinois</em>} methods is based on the\n  * following article: M. Dowell and P. Jarratt,\n  * <em>A modified regula falsi method for computing the root of an\n  * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,\n  * 1972.</p>\n  *\n+ * <p>The  {@link SecantSolver <em>secant<em>} method is <em>not</emp> a\n+ * bracketing method so it is not implemented here. It has a separate\n+ * implementation.</p>\n+ *\n  * @since 3.0\n  * @version $Id$\n  */\n-public abstract class BaseSecantSolver extends AbstractUnivariateRealSolver {\n+public abstract class BaseSecantSolver\n+    extends AbstractUnivariateRealSolver\n+    implements BracketedUnivariateRealSolver<UnivariateRealFunction> {\n+\n     /** Default absolute accuracy. */\n     protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n     /** The kinds of solutions that the algorithm may accept. */\n-    protected AllowedSolutions allowedSolutions = AllowedSolutions.EITHER_SIDE;\n+    private AllowedSolutions allowedSolutions;\n+\n     /** The <em>Secant</em>-based root-finding method to use. */\n     private final Method method;\n \n      */\n     protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n         super(absoluteAccuracy);\n+        this.allowedSolutions = AllowedSolutions.ANY_SIDE;\n         this.method = method;\n     }\n \n                                final double absoluteAccuracy,\n                                final Method method) {\n         super(relativeAccuracy, absoluteAccuracy);\n+        this.allowedSolutions = AllowedSolutions.ANY_SIDE;\n         this.method = method;\n     }\n \n     /** {@inheritDoc} */\n+    public double solve(final int maxEval, final UnivariateRealFunction f,\n+                        final double min, final double max,\n+                        final AllowedSolutions allowedSolutions) {\n+        return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolutions);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final int maxEval, final UnivariateRealFunction f,\n+                        final double min, final double max, final double startValue,\n+                        final AllowedSolutions allowedSolutions) {\n+        this.allowedSolutions = allowedSolutions;\n+        return super.solve(maxEval, f, min, max, startValue);\n+    }\n+\n+    /** {@inheritDoc} */\n     @Override\n+    public double solve(final int maxEval, final UnivariateRealFunction f,\n+                        final double min, final double max, final double startValue) {\n+        return solve(maxEval, f, min, max, startValue, AllowedSolutions.ANY_SIDE);\n+    }\n+\n+    /** {@inheritDoc} */\n     protected final double doSolve() {\n         // Get initial solution\n         double x0 = getMin();\n         final double rtol = getRelativeAccuracy();\n \n         // Keep track of inverted intervals, meaning that the left bound is\n-        // larger than the right bound. Not used for the original Secant\n-        // method.\n+        // larger than the right bound.\n         boolean inverted = false;\n \n         // Keep finding better approximations.\n             }\n \n             // Update the bounds with the new approximation.\n-            if (method == Method.SECANT) {\n-                x0 = x1;\n-                f0 = f1;\n-                x1 = x;\n-                f1 = fx;\n-            } else if (f1 * fx < 0) {\n+            if (f1 * fx < 0) {\n                 // We had [x0..x1]. We update it to [x1, x]. Note that the\n                 // value of x1 has switched to the other bound, thus inverting\n                 // the interval.\n             // the root than we already are.\n             if (FastMath.abs(f1) <= ftol) {\n                 switch (allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                      atol)) {\n                 switch (allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n \n     /** <em>Secant</em>-based root-finding methods. */\n     protected enum Method {\n-        /** The original {@link SecantSolver <em>Secant</em>} method. */\n-        SECANT,\n \n         /**\n          * The {@link RegulaFalsiSolver <em>Regula Falsi</em>} or\n         ILLINOIS,\n \n         /** The {@link PegasusSolver <em>Pegasus</em>} method. */\n-        PEGASUS,\n+        PEGASUS;\n+\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n  */\n \n package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <em>Secant</em> method for root-finding (approximating a\n  *\n  * @version $Id$\n  */\n-public class SecantSolver extends BaseSecantSolver {\n+public class SecantSolver extends AbstractUnivariateRealSolver {\n+\n+    /** Default absolute accuracy. */\n+    protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n     /** Construct a solver with default accuracy (1e-6). */\n     public SecantSolver() {\n-        super(DEFAULT_ABSOLUTE_ACCURACY, Method.SECANT);\n+        super(DEFAULT_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n      * @param absoluteAccuracy absolute accuracy\n      */\n     public SecantSolver(final double absoluteAccuracy) {\n-        super(absoluteAccuracy, Method.SECANT);\n+        super(absoluteAccuracy);\n     }\n \n     /**\n      */\n     public SecantSolver(final double relativeAccuracy,\n                         final double absoluteAccuracy) {\n-        super(relativeAccuracy, absoluteAccuracy, Method.SECANT);\n+        super(relativeAccuracy, absoluteAccuracy);\n     }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected final double doSolve() {\n+        // Get initial solution\n+        double x0 = getMin();\n+        double x1 = getMax();\n+        double f0 = computeObjectiveValue(x0);\n+        double f1 = computeObjectiveValue(x1);\n+\n+        // If one of the bounds is the exact root, return it. Since these are\n+        // not under-approximations or over-approximations, we can return them\n+        // regardless of the allowed solutions.\n+        if (f0 == 0.0) {\n+            return x0;\n+        }\n+        if (f1 == 0.0) {\n+            return x1;\n+        }\n+\n+        // Verify bracketing of initial solution.\n+        verifyBracketing(x0, x1);\n+\n+        // Get accuracies.\n+        final double ftol = getFunctionValueAccuracy();\n+        final double atol = getAbsoluteAccuracy();\n+        final double rtol = getRelativeAccuracy();\n+\n+        // Keep finding better approximations.\n+        while (true) {\n+\n+            // Calculate the next approximation.\n+            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+            final double fx = computeObjectiveValue(x);\n+\n+            // If the new approximation is the exact root, return it. Since\n+            // this is not an under-approximation or an over-approximation,\n+            // we can return it regardless of the allowed solutions.\n+            if (fx == 0.0) {\n+                return x;\n+            }\n+\n+            // Update the bounds with the new approximation.\n+            x0 = x1;\n+            f0 = f1;\n+            x1 = x;\n+            f1 = fx;\n+\n+            // If the function value of the last approximation is too small,\n+            // given the function value accuracy, then we can't get closer to\n+            // the root than we already are.\n+            if (FastMath.abs(f1) <= ftol) {\n+                return x1;\n+            }\n+\n+            // If the current interval is within the given accuracies, we\n+            // are satisfied with the current approximation.\n+            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n+                return x1;\n+            }\n+        }\n+    }\n+\n }", "timestamp": 1310296050, "metainfo": ""}