{"sha": "f182c916020a069b17900e3d2c37ebbc68c7439b", "log": "RealMatrix now throws two more runtime exceptions InvalidMatrixException and MatrixIndexException   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when a system attempts an operation on a matrix, and\n+ * that matrix does not satisfy the preconditions for the\n+ * aforementioned operation.\n+ * @version $Revision: 1.1 $ $Date: 2004/01/28 20:15:03 $\n+ */\n+public class InvalidMatrixException extends RuntimeException {\n+\n+    public InvalidMatrixException(String s) {\n+        super( s );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when an operation addresses a matrix coordinate (row,col)\n+ * which is outside of the dimensions of a matrix.\n+ * @version $Revision: 1.1 $ $Date: 2004/01/28 20:15:03 $\n+ */\n+public class MatrixIndexException extends RuntimeException {\n+\n+    public MatrixIndexException(String s) {\n+        super( s );\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n \n /**\n  * Interface defining a real-valued matrix with basic algebraic operations\n- * @version $Revision: 1.7 $ $Date: 2003/11/14 22:22:19 $\n+ * @version $Revision: 1.8 $ $Date: 2004/01/28 20:15:03 $\n  */\n public interface RealMatrix {\n \n      *\n      * @param row the row to be fetched\n      * @return array of entries in the row\n-     * @throws IllegalArgumentException if row > rowDimension\n-     */\n-    double[] getRow(int row) throws IllegalArgumentException;\n+     * @throws MatrixIndexException if the specified row is greater \n+     *                              than the number of rows in this matrix\n+     */\n+    double[] getRow(int row) throws MatrixIndexException;\n     \n     /**\n      * Returns the entries in column number <code>col</code> as an array.\n      *\n      * @param col  column to fetch\n      * @return array of entries in the column\n-     * @throws IllegalArgumentException if column > columnDimension\n-     */\n-    double[] getColumn(int col) throws IllegalArgumentException;\n+     * @throws MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    double[] getColumn(int col) throws MatrixIndexException;\n     \n     /**\n      * Returns the entry in the specified row and column.\n      *\n      * @param row  row location of entry to be fetched  \n      * @param column  column location of entry to be fetched\n-     * @return     matrix entry in row,column\n-     * @throws     IllegalArgumentException if entry does not exist\n-     */\n-    double getEntry(int row, int column) throws IllegalArgumentException;\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the specified coordinate is outside \n+     *                              the dimensions of this matrix\n+     */\n+    double getEntry(int row, int column) throws MatrixIndexException;\n     \n     /**\n      * Sets the entry in the specified row and column to the specified value.\n      * @param row    row location of entry to be set \n      * @param column    column location of entry to be set\n      * @param value  value to set \n-     * @throws IllegalArgumentException if entry does not exist\n+     * @throws MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n      */\n     void setEntry(int row, int column, double value) \n-        throws IllegalArgumentException;\n+        throws MatrixIndexException;\n     \n     /**\n      * Returns the transpose of this matrix.\n      * matrix = this and constant vector = <code>b</code>.\n      *\n      * @param b  constant vector\n-     * @return   vector of solution values to AX = b, where A is *this\n-     * @throws   IllegalArgumentException if rowDimension != b.length or matrix \n-     *           is singular\n-     */\n-    double[] solve(double[] b) throws IllegalArgumentException;\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length \n+     * @throws InvalidMatrixException if this matrix is square or singular\n+     */\n+    double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n     \n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * @param b  matrix of constant vectors forming RHS of linear systems to\n      * to solve\n      * @return matrix of solution vectors\n-     * @throws IllegalArgumentException if rowDimension != row dimension of b\n-     * or this is not square or singular\n-     */\n-    RealMatrix solve(RealMatrix b) throws IllegalArgumentException;\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is square or singular\n+     */\n+    RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n }\n \n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.\n  *\n- * @version $Revision: 1.9 $ $Date: 2003/11/23 20:16:17 $\n+ * @version $Revision: 1.10 $ $Date: 2004/01/28 20:15:03 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n-    /** Entries of the matrix */\n-    private double data[][] = null;\n-    \n-    /** Entries of LU decomposition.\n-     * All updates to data (other than luDecompostion) *must* set this to null\n-     */\n-    private double lu[][] = null;\n-    \n-    /** Pivot array associated with LU decompostion */\n-    private int[] pivot = null;\n-    \n-    /** Parity of the permutation associated with the LU decomposition */\n-    private int parity = 1;\n-    \n-    /** Bound to determine effective singularity in LU decomposition */\n-    private static double TOO_SMALL = 10E-12;\n-    \n-    /** \n-     * Creates a matrix with no data\n-     */\n-    public RealMatrixImpl() {\n-    }\n-    \n-    /**\n-     * Create a new RealMatrix with the supplied row and column dimensions.\n-     *\n-     * @param rowDimension      the number of rows in the new matrix\n-     * @param columnDimension   the number of columns in the new matrix\n-     */\n-    public RealMatrixImpl(int rowDimension,\n-    int columnDimension) {\n-        data = new double[rowDimension][columnDimension];\n-        lu = null;\n-    }\n-    \n-    /**\n-     * Create a new RealMatrix using the <code>data</code> as the underlying\n-     * data array.\n-     * <p>\n-     * The input array is copied, not referenced.\n-     *\n-     * @param d data for new matrix\n-     */\n-    public RealMatrixImpl(double[][] d) {\n-        this.copyIn(d);\n-        lu = null;\n-    }\n-    \n-    /**\n-     * Create a new (column) RealMatrix using <code>v</code> as the \n-     * data for the unique column of the <code>v.length x 1</code> matrix \n-     * created.\n-     * <p>\n-     * The input array is copied, not referenced.\n-     *\n-     * @param v column vector holding data for new matrix\n-     */\n-    public RealMatrixImpl(double[] v) {\n-        int nRows = v.length;\n-        data = new double[nRows][1];\n-        for (int row = 0; row < nRows; row++) {\n-            data[row][0] = v[row];\n-        }\n-    }\n-    \n-    /**\n-     * Create a new RealMatrix which is a copy of this.\n-     *\n-     * @return  the cloned matrix\n-     */\n-    public RealMatrix copy() {\n-        return new RealMatrixImpl(this.copyOut());\n-    }\n-    \n-    /**\n-     * Compute the sum of this and <code>m</code>.\n-     *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as this\n-     */\n-    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-        this.getRowDimension() != m.getRowDimension()) {\n-            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-        }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n-        double[][] mData = m.getData();\n-        for (int row = 0; row < rowCount; row++) {\n-            for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + mData[row][col];\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Compute  this minus <code>m</code>.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n-     */\n-    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-        this.getRowDimension() != m.getRowDimension()) {\n-            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-        }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n-        double[][] mData = m.getData();\n-        for (int row = 0; row < rowCount; row++) {\n-            for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] - mData[row][col];\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns the rank of the matrix.\n-     *\n-     * @return the rank of this matrix\n-     */\n-    public int getRank() {\n-        // FIXME: need to add singular value decomposition or drop this\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n-    \n-    \n-    /**\n-     * Returns the result of adding d to each entry of this.\n-     *\n-     * @param d    value to be added to each entry\n-     * @return     d + this\n-     */\n-    public RealMatrix scalarAdd(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n-        for (int row = 0; row < rowCount; row++) {\n-            for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns the result multiplying each entry of this by <code>d</code>\n-     * @param d  value to multiply all entries by\n-     * @return d * this\n-     */\n-    public RealMatrix scalarMultiply(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n-        for (int row = 0; row < rowCount; row++) {\n-            for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] * d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result postmultiplying this by <code>m</code>.\n-     * @param m    matrix to postmultiply by\n-     * @return     this*m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n-    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getRowDimension()) {\n-            throw new IllegalArgumentException\n-            (\"Matrices are not multiplication compatible.\");\n-        }\n-        int nRows = this.getRowDimension();\n-        int nCols = m.getColumnDimension();\n-        int nSum = this.getColumnDimension();\n-        double[][] mData = m.getData();\n-        double[][] outData = new double[nRows][nCols];\n-        double sum = 0;\n-        for (int row = 0; row < nRows; row++) {\n-            for (int col = 0; col < nCols; col++) {\n-                sum = 0;\n-                for (int i = 0; i < nSum; i++) {\n-                    sum += data[row][i] * mData[i][col];\n-                }\n-                outData[row][col] = sum;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns matrix entries as a two-dimensional array.\n-     * <p>\n-     * Makes a fresh copy of the underlying data.\n-     *\n-     * @return    2-dimensional array of entries\n-     */\n-    public double[][] getData() {\n-        return copyOut();\n-    }\n-    \n-    /**\n-     * Overwrites the underlying data for the matrix\n-     * with a fresh copy of <code>inData</code>.\n-     *\n-     * @param  inData 2-dimensional array of entries\n-     */\n-    public void setData(double[][] inData) {\n-        copyIn(inData);\n-        lu = null;\n-    }\n-    \n-    /**\n-     * Returns a reference to the underlying data array.\n-     * <p>\n-     * Does not make a fresh copy of the underlying data.\n-     *\n-     * @return 2-dimensional array of entries\n-     */\n-    public double[][] getDataRef() {\n-        return data;\n-    }\n-    \n-    /**\n-     * Overwrites the underlying data for the matrix\n-     * with a reference to <code>inData</code>.\n-     * <p>\n-     * Does not make a fresh copy of <code>data</code>.\n-     *\n-     * @param  inData 2-dimensional array of entries\n-     */\n-    public void setDataRef(double[][] inData) {\n-        this.data = inData;\n-        lu = null;\n-    }\n-    \n-    /**\n-     *\n-     * @return norm\n-     */\n-    public double getNorm() {\n-        double maxColSum = 0;\n-        for (int col = 0; col < this.getColumnDimension(); col++) {\n-            double sum = 0;\n-            for (int row = 0; row < this.getRowDimension(); row++) {\n-                sum += Math.abs(data[row][col]);\n-            }\n-            maxColSum = Math.max(maxColSum, sum);\n-        }\n-        return maxColSum;\n-    }\n-    \n-    /**\n-     *\n-     * @param row  the row to be fetched\n-     * @return array of entries in the row\n-     * @throws IllegalArgumentException if row > rowDimension or row < 1\n-     */\n-    public double[] getRow(int row) throws IllegalArgumentException {\n-        if (row > this.getRowDimension() || row < 1) {\n-            throw new IllegalArgumentException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        double[] out = new double[ncols];\n-        System.arraycopy(data[row - 1], 0, out, 0, ncols);\n-        return out;\n-    }\n-    \n-    /**\n-     * @param col column to fetch\n-     * @return array of entries in the column\n-     * @throws IllegalArgumentException if column > columnDimension or\n-     * column < 1\n-     */\n-    public double[] getColumn(int col) throws IllegalArgumentException {\n-        if (col > this.getColumnDimension() || col < 1) {\n-            throw new IllegalArgumentException(\"illegal column argument\");\n-        }\n-        int nRows = this.getRowDimension();\n-        double[] out = new double[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            out[row] = data[row][col - 1];\n-        }\n-        return out;\n-    }\n-    \n-    /**\n-     * @param row  row location of entry to be fetched\n-     * @param column  column location of entry to be fetched\n-     * @return matrix entry in row,column\n-     * @throws IllegalArgumentException if entry does not exist\n-     */\n-    public double getEntry(int row, int column)\n-    throws IllegalArgumentException {\n-        if (row < 1 || column < 1 || row > this.getRowDimension() ||\n-            column > this.getColumnDimension()) {\n-                \n-            throw new IllegalArgumentException\n-            (\"matrix entry does not exist\");\n-        }\n-        return data[row - 1][column - 1];\n-    }\n-    \n-    /**\n-     * @param row    row location of entry to be set\n-     * @param column    column location of entry to be set\n-     * @param value  value to set\n-     * @throws IllegalArgumentException if entry does not exist\n-     */\n-    public void setEntry(int row, int column, double value)\n-    throws IllegalArgumentException {\n-        if (row < 1 || column < 1 || row > this.getRowDimension() ||\n-            column > this.getColumnDimension()) {\n-                \n-            throw new IllegalArgumentException\n-            (\"matrix entry does not exist\");\n-        }\n-        data[row - 1][column - 1] = value;\n-        lu = null;\n-    }\n-    \n-    /**\n-     *\n-     * @return transpose matrix\n-     */\n-    public RealMatrix transpose() {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n-        double[][] outData = out.getDataRef();\n-        for (int row = 0; row < nRows; row++) {\n-            for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = data[row][col];\n-            }\n-        }\n-        return out;\n-    }   \n-    \n-    /**\n-     * @return inverse matrix\n-     * @throws IllegalArgumentException if this is not invertible\n-     */\n-    public RealMatrix inverse() throws IllegalArgumentException {\n-        return solve(getIdentity(this.getRowDimension()));\n-    }\n-    \n-    /**\n-     * @return determinant\n-     * @throws IllegalArgumentException if matrix is not square\n-     */\n-    public double getDeterminant() throws IllegalArgumentException {\n-        if (!isSquare()) {\n-            throw new IllegalArgumentException(\"matrix is not square\");\n-        }\n-        if (isSingular()) {  // note: this has side effect of attempting LU\n-            return 0d;        //       decomp if lu == null\n-        } else {\n-            double det = (double) parity;\n-            for (int i = 0; i < this.getRowDimension(); i++) {\n-                det *= lu[i][i];\n-            }\n-            return det;\n-        }\n-    }\n-    \n-    /**\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n-    public boolean isSquare() {\n-        return (this.getColumnDimension() == this.getRowDimension());\n-    }\n-    \n-    /**\n-     * @return true if the matrix is singular\n-     */\n-    public boolean isSingular() {\n-        if (lu == null) {\n-            try {\n-                LUDecompose();\n-                return false;\n-            } catch (IllegalArgumentException ex) {\n-                return true;\n-            }\n-        } else {            // LU decomp must have been successfully performed\n-            return false;   // so the matrix is not singular\n-        }\n-    }\n-    \n-    /**\n-     * @return rowDimension\n-     */\n-    public int getRowDimension() {\n-        return data.length;\n-    }\n-    \n-    /**\n-     * @return columnDimension\n-     */\n-    public int getColumnDimension() {\n-        return data[0].length;\n-    }\n-    \n-    /**\n-     * @return trace\n-     * @throws IllegalArgumentException if the matrix is not square\n-     */\n-    public double getTrace() throws IllegalArgumentException {\n-        if (!isSquare()) {\n-            throw new IllegalArgumentException(\"matrix is not square\");\n-        }\n-        double trace = data[0][0];\n-        for (int i = 1; i < this.getRowDimension(); i++) {\n-            trace += data[i][i];\n-        }\n-        return trace;\n-    }\n-    \n-    /**\n-     * @param v vector to operate on\n-     * @throws IllegalArgumentException if columnDimension != v.length\n-     * @return resulting vector\n-     */\n-    public double[] operate(double[] v) throws IllegalArgumentException {\n-        if (v.length != this.getColumnDimension()) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n-        }\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        double[] out = new double[v.length];\n-        for (int row = 0; row < nRows; row++) {\n-            double sum = 0;\n-            for (int i = 0; i < nCols; i++) {\n-                sum += data[row][i] * v[i];\n-            }\n-            out[row] = sum;\n-        }\n-        return out;      \n-    }\n-    \n-    /**\n-     * @param v vector to premultiply by\n-     * @throws IllegalArgumentException if rowDimension != v.length\n-     * @return resulting matrix\n-     */\n-    public RealMatrix preMultiply(double[] v) throws IllegalArgumentException {\n-        int nCols = this.getColumnDimension();\n-        if (v.length != nCols) {\n-            throw new IllegalArgumentException(\"vector has wrong length\");\n-        }\n-        // being a bit lazy here -- probably should implement directly, like\n-        // operate\n-        RealMatrix pm = new RealMatrixImpl(v).transpose();\n-        return pm.multiply(this);     \n-    }\n-    \n-    /**\n-     * @param b  constant vector\n-     * @return   vector of solution values to AX = b, where A is this\n-     * @throws   IllegalArgumentException if rowDimension != b.length or matrix\n-     *           is singular\n-     */\n-    public double[] solve(double[] b) throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n-        if (b.length != nRows) {\n-            throw new IllegalArgumentException\n-                (\"constant vector has wrong length\");\n-        }\n-        RealMatrix bMatrix = new RealMatrixImpl(b);\n-        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n-        double[] out = new double[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            out[row] = solution[row][0];\n-        }\n-        return out;\n-    }\n-       \n-    /**\n-     * Uses LU decomposition, performing the composition if the matrix has\n-     * not been decomposed, or if there have been changes to the matrix since\n-     * the last decomposition.\n-     *\n-     * @param b the constant vector\n-     * @return solution matrix\n-     * @throws IllegalArgumentException if this is singular or dimensions\n-     * do not match.\n-     */\n-    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException {\n-        if (!this.isSquare()) {\n-            throw new IllegalArgumentException\n-                (\"coefficient matrix is not square\");\n-        }\n-        if (b.getRowDimension() != this.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (this.isSingular()) {  // side effect: compute LU decomp\n-            throw new IllegalArgumentException(\"Matrix is singular.\");\n-        }\n-        \n-        int nCol = this.getColumnDimension();\n-        int nColB = b.getColumnDimension();\n-        int nRowB = b.getRowDimension();\n-        \n-        // Apply permutations to b\n-        double[][] bv = b.getData();\n-        double[][] bp = new double[nRowB][nColB];\n-        for (int row = 0; row < nRowB; row++) {\n-            for (int col = 0; col < nColB; col++) {\n-                bp[row][col] = bv[pivot[row]][col];\n-            }\n-        }\n-        bv = null;\n-        \n-        // Solve LY = b\n-        for (int col = 0; col < nCol; col++) {\n-            for (int i = col + 1; i < nCol; i++) {\n-                for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n-                }\n-            }\n-        }\n-        \n-        // Solve UX = Y\n-        for (int col = nCol - 1; col >= 0; col--) {\n-            for (int j = 0; j < nColB; j++) {\n-                bp[col][j] /= lu[col][col];\n-            }\n-            for (int i = 0; i < col; i++) {\n-                for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n-                }\n-            }\n-        }\n-        \n-        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n-        return outMat;\n-    }\n-    \n-    /**\n-     * Computes a new <a href=\"http://www.math.gatech.edu/~bourbaki/\n-     * math2601/Web-notes/2num.pdf\">LU decompostion</a> for this matrix,\n-     * storing the result for use by other methods.\n-     * <p>\n-     * <strong>Implementation Note</strong>:<br>\n-     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/\n-     * people/sd/lectures/nummeth98/linear.htm\">Crout's algortithm</a>,\n-     * with partial pivoting.\n-     * <p>\n-     * <strong>Usage Note</strong>:<br>\n-     * This method should rarely be invoked directly. Its only use is\n-     * to force recomputation of the LU decomposition when changes have been\n-     * made to the underlying data using direct array references. Changes\n-     * made using setXxx methods will trigger recomputation when needed\n-     * automatically.\n-     *\n-     * @throws IllegalArgumentException if the matrix is singular\n-     */\n-    public void LUDecompose() throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        if (nRows < nCols) {\n-            throw new IllegalArgumentException\n-              (\"LU decomposition requires row dimension >= column dimension\");\n-        }\n-        lu = this.getData();\n-        \n-        // Initialize pivot array and parity\n-        pivot = new int[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            pivot[row] = row;\n-        }\n-        parity = 1;\n-        \n-        // Loop over columns\n-        for (int col = 0; col < nCols; col++) {\n-            \n-            double sum = 0;\n-            \n-            // upper\n-            for (int row = 0; row < col; row++) {\n-                sum = lu[row][col];\n-                for (int i = 0; i < row; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n-                }\n-                lu[row][col] = sum;\n-            }\n-            \n-            // lower\n-            int max = col; // pivot row\n-            double largest = 0d;\n-            for (int row = col; row < nRows; row++) {\n-                sum = lu[row][col];\n-                for (int i = 0; i < col; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n-                }\n-                lu[row][col] = sum;\n-                \n-                // maintain best pivot choice\n-                if (Math.abs(sum) > largest) {\n-                    largest = Math.abs(sum);\n-                    max = row;\n-                }\n-            }\n-            \n-            // Singularity check\n-            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n-                lu = null;\n-                throw new IllegalArgumentException(\"matrix is singular\");\n-            }\n-            \n-            // Pivot if necessary\n-            if (max != col) {\n-                double tmp = 0;\n-                for (int i = 0; i < nCols; i++) {\n-                    tmp = lu[max][i];\n-                    lu[max][i] = lu[col][i];\n-                    lu[col][i] = tmp;\n-                }\n-                int temp = pivot[max];\n-                pivot[max] = pivot[col];\n-                pivot[col] = temp;\n-                parity = -parity;\n-            }\n-            \n-            //Divide the lower elements by the \"winning\" diagonal elt.\n-            for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] /= lu[col][col];\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * \n-     * @see java.lang.Object#toString()\n-     */\n-    public String toString() {\n-        StringBuffer res = new StringBuffer();\n-        res.append(\"RealMatrixImpl{\");\n-        for (int i=0; i<data.length; i++)  {\n-            if (i>0) res.append(\",\");\n-            res.append(\"{\");\n-            for (int j=0; j<data[0].length; j++) {\n-                if (j>0) res.append(\",\");\n-                res.append(data[i][j]);\n-            }//for\n-            res.append(\"}\");\n-        }//for\n-        res.append(\"}\");\n-        return res.toString();\n-    }//toString\n-    \n-    //------------------------ Protected methods\n-    \n-    /**\n-     * Returns <code>dimension x dimension</code> identity matrix.\n-     *\n-     * @param dimension dimension of identity matrix to generate\n-     * @return identity matrix\n-     */\n-    protected RealMatrix getIdentity(int dimension) {\n-        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n-        double[][] d = out.getDataRef();\n-        for (int row = 0; row < dimension; row++) {\n-            for (int col = 0; col < dimension; col++) {\n-                d[row][col] = row == col ? 1d : 0d;\n-            }\n-        }\n-        return out;\n-    }\n-    \n-    //------------------------ Private methods\n-    \n-    /**\n-     * Returns a fresh copy of the underlying data array.\n-     *\n-     * @return a copy of the underlying data array.\n-     */\n-    private double[][] copyOut() {\n-        int nRows = this.getRowDimension();\n-        double[][] out =\n-            new double[nRows][this.getColumnDimension()];\n-        // can't copy 2-d array in one shot, otherwise get row references\n-        for (int i = 0; i < nRows; i++) {\n-            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n-        }\n-        return out;\n-    }\n-    \n-    /**\n-     * Replaces data with a fresh copy of the input array.\n-     *\n-     * @param in data to copy in\n-     */\n-    private void copyIn(double[][] in) {\n-        int nRows = in.length;\n-        int nCols = in[0].length;\n-        data = new double[nRows][nCols];\n-        System.arraycopy(in, 0, data, 0, in.length);\n-        for (int i = 0; i < nRows ; i++) {\n-            System.arraycopy(in[i], 0, data[i], 0, nCols);\n-        }\n-        lu = null;\n-    }\n+\t/** Entries of the matrix */\n+\tprivate double data[][] = null;\n+\n+\t/** Entries of LU decomposition.\n+\t * All updates to data (other than luDecompostion) *must* set this to null\n+\t */\n+\tprivate double lu[][] = null;\n+\n+\t/** Pivot array associated with LU decompostion */\n+\tprivate int[] pivot = null;\n+\n+\t/** Parity of the permutation associated with the LU decomposition */\n+\tprivate int parity = 1;\n+\n+\t/** Bound to determine effective singularity in LU decomposition */\n+\tprivate static double TOO_SMALL = 10E-12;\n+\n+\t/** \n+\t * Creates a matrix with no data\n+\t */\n+\tpublic RealMatrixImpl() {\n+\t}\n+\n+\t/**\n+\t * Create a new RealMatrix with the supplied row and column dimensions.\n+\t *\n+\t * @param rowDimension      the number of rows in the new matrix\n+\t * @param columnDimension   the number of columns in the new matrix\n+\t */\n+\tpublic RealMatrixImpl(int rowDimension, int columnDimension) {\n+\t\tdata = new double[rowDimension][columnDimension];\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t * Create a new RealMatrix using the <code>data</code> as the underlying\n+\t * data array.\n+\t * <p>\n+\t * The input array is copied, not referenced.\n+\t *\n+\t * @param d data for new matrix\n+\t */\n+\tpublic RealMatrixImpl(double[][] d) {\n+\t\tthis.copyIn(d);\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t * Create a new (column) RealMatrix using <code>v</code> as the \n+\t * data for the unique column of the <code>v.length x 1</code> matrix \n+\t * created.\n+\t * <p>\n+\t * The input array is copied, not referenced.\n+\t *\n+\t * @param v column vector holding data for new matrix\n+\t */\n+\tpublic RealMatrixImpl(double[] v) {\n+\t\tint nRows = v.length;\n+\t\tdata = new double[nRows][1];\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tdata[row][0] = v[row];\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new RealMatrix which is a copy of this.\n+\t *\n+\t * @return  the cloned matrix\n+\t */\n+\tpublic RealMatrix copy() {\n+\t\treturn new RealMatrixImpl(this.copyOut());\n+\t}\n+\n+\t/**\n+\t * Compute the sum of this and <code>m</code>.\n+\t *\n+\t * @param m    matrix to be added\n+\t * @return     this + m\n+\t * @exception  IllegalArgumentException if m is not the same size as this\n+\t */\n+\tpublic RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+\t\tif (this.getColumnDimension() != m.getColumnDimension()\n+\t\t\t|| this.getRowDimension() != m.getRowDimension()) {\n+\t\t\tthrow new IllegalArgumentException(\"matrix dimension mismatch\");\n+\t\t}\n+\t\tint rowCount = this.getRowDimension();\n+\t\tint columnCount = this.getColumnDimension();\n+\t\tdouble[][] outData = new double[rowCount][columnCount];\n+\t\tdouble[][] mData = m.getData();\n+\t\tfor (int row = 0; row < rowCount; row++) {\n+\t\t\tfor (int col = 0; col < columnCount; col++) {\n+\t\t\t\toutData[row][col] = data[row][col] + mData[row][col];\n+\t\t\t}\n+\t\t}\n+\t\treturn new RealMatrixImpl(outData);\n+\t}\n+\n+\t/**\n+\t * Compute  this minus <code>m</code>.\n+\t *\n+\t * @param m    matrix to be subtracted\n+\t * @return     this + m\n+\t * @exception  IllegalArgumentException if m is not the same size as *this\n+\t */\n+\tpublic RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n+\t\tif (this.getColumnDimension() != m.getColumnDimension()\n+\t\t\t|| this.getRowDimension() != m.getRowDimension()) {\n+\t\t\tthrow new IllegalArgumentException(\"matrix dimension mismatch\");\n+\t\t}\n+\t\tint rowCount = this.getRowDimension();\n+\t\tint columnCount = this.getColumnDimension();\n+\t\tdouble[][] outData = new double[rowCount][columnCount];\n+\t\tdouble[][] mData = m.getData();\n+\t\tfor (int row = 0; row < rowCount; row++) {\n+\t\t\tfor (int col = 0; col < columnCount; col++) {\n+\t\t\t\toutData[row][col] = data[row][col] - mData[row][col];\n+\t\t\t}\n+\t\t}\n+\t\treturn new RealMatrixImpl(outData);\n+\t}\n+\n+\t/**\n+\t * Returns the rank of the matrix.\n+\t *\n+\t * @return the rank of this matrix\n+\t */\n+\tpublic int getRank() {\n+\t\t// @TODO need to add singular value decomposition or drop this\n+\t\tthrow new UnsupportedOperationException(\"not implemented yet\");\n+\t}\n+\n+\t/**\n+\t * Returns the result of adding d to each entry of this.\n+\t *\n+\t * @param d    value to be added to each entry\n+\t * @return     d + this\n+\t */\n+\tpublic RealMatrix scalarAdd(double d) {\n+\t\tint rowCount = this.getRowDimension();\n+\t\tint columnCount = this.getColumnDimension();\n+\t\tdouble[][] outData = new double[rowCount][columnCount];\n+\t\tfor (int row = 0; row < rowCount; row++) {\n+\t\t\tfor (int col = 0; col < columnCount; col++) {\n+\t\t\t\toutData[row][col] = data[row][col] + d;\n+\t\t\t}\n+\t\t}\n+\t\treturn new RealMatrixImpl(outData);\n+\t}\n+\n+\t/**\n+\t * Returns the result multiplying each entry of this by <code>d</code>\n+\t * @param d  value to multiply all entries by\n+\t * @return d * this\n+\t */\n+\tpublic RealMatrix scalarMultiply(double d) {\n+\t\tint rowCount = this.getRowDimension();\n+\t\tint columnCount = this.getColumnDimension();\n+\t\tdouble[][] outData = new double[rowCount][columnCount];\n+\t\tfor (int row = 0; row < rowCount; row++) {\n+\t\t\tfor (int col = 0; col < columnCount; col++) {\n+\t\t\t\toutData[row][col] = data[row][col] * d;\n+\t\t\t}\n+\t\t}\n+\t\treturn new RealMatrixImpl(outData);\n+\t}\n+\n+\t/**\n+\t * Returns the result postmultiplying this by <code>m</code>.\n+\t * @param m    matrix to postmultiply by\n+\t * @return     this*m\n+\t * @throws     IllegalArgumentException\n+\t *             if columnDimension(this) != rowDimension(m)\n+\t */\n+\tpublic RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+\t\tif (this.getColumnDimension() != m.getRowDimension()) {\n+\t\t\tthrow new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+\t\t}\n+\t\tint nRows = this.getRowDimension();\n+\t\tint nCols = m.getColumnDimension();\n+\t\tint nSum = this.getColumnDimension();\n+\t\tdouble[][] mData = m.getData();\n+\t\tdouble[][] outData = new double[nRows][nCols];\n+\t\tdouble sum = 0;\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tfor (int col = 0; col < nCols; col++) {\n+\t\t\t\tsum = 0;\n+\t\t\t\tfor (int i = 0; i < nSum; i++) {\n+\t\t\t\t\tsum += data[row][i] * mData[i][col];\n+\t\t\t\t}\n+\t\t\t\toutData[row][col] = sum;\n+\t\t\t}\n+\t\t}\n+\t\treturn new RealMatrixImpl(outData);\n+\t}\n+\n+\t/**\n+\t * Returns matrix entries as a two-dimensional array.\n+\t * <p>\n+\t * Makes a fresh copy of the underlying data.\n+\t *\n+\t * @return    2-dimensional array of entries\n+\t */\n+\tpublic double[][] getData() {\n+\t\treturn copyOut();\n+\t}\n+\n+\t/**\n+\t * Overwrites the underlying data for the matrix\n+\t * with a fresh copy of <code>inData</code>.\n+\t *\n+\t * @param  inData 2-dimensional array of entries\n+\t */\n+\tpublic void setData(double[][] inData) {\n+\t\tcopyIn(inData);\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t * Returns a reference to the underlying data array.\n+\t * <p>\n+\t * Does not make a fresh copy of the underlying data.\n+\t *\n+\t * @return 2-dimensional array of entries\n+\t */\n+\tpublic double[][] getDataRef() {\n+\t\treturn data;\n+\t}\n+\n+\t/**\n+\t * Overwrites the underlying data for the matrix\n+\t * with a reference to <code>inData</code>.\n+\t * <p>\n+\t * Does not make a fresh copy of <code>data</code>.\n+\t *\n+\t * @param  inData 2-dimensional array of entries\n+\t */\n+\tpublic void setDataRef(double[][] inData) {\n+\t\tthis.data = inData;\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t *\n+\t * @return norm\n+\t */\n+\tpublic double getNorm() {\n+\t\tdouble maxColSum = 0;\n+\t\tfor (int col = 0; col < this.getColumnDimension(); col++) {\n+\t\t\tdouble sum = 0;\n+\t\t\tfor (int row = 0; row < this.getRowDimension(); row++) {\n+\t\t\t\tsum += Math.abs(data[row][col]);\n+\t\t\t}\n+\t\t\tmaxColSum = Math.max(maxColSum, sum);\n+\t\t}\n+\t\treturn maxColSum;\n+\t}\n+\n+\t/**\n+\t * Returns the entries in row number <code>row</code> as an array.\n+\t *\n+\t * @param row the row to be fetched\n+\t * @return array of entries in the row\n+\t * @throws MatrixIndexException if the specified row is greater \n+\t *                              than the number of rows in this matrix\n+\t */\n+\tpublic double[] getRow(int row) throws MatrixIndexException {\n+\t\tif ( !isValidCoordinate( row, 1 ) ) {\n+\t\t\tthrow new MatrixIndexException(\"illegal row argument\");\n+\t\t}\n+\t\tint ncols = this.getColumnDimension();\n+\t\tdouble[] out = new double[ncols];\n+\t\tSystem.arraycopy(data[row - 1], 0, out, 0, ncols);\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Returns the entries in column number <code>col</code> as an array.\n+\t *\n+\t * @param col  column to fetch\n+\t * @return array of entries in the column\n+\t * @throws MatrixIndexException if the specified column is greater\n+\t *                              than the number of columns in this matrix\n+\t */\n+\tpublic double[] getColumn(int col) throws MatrixIndexException {\n+\t\tif ( !isValidCoordinate(1, col) ) {\n+\t\t\tthrow new MatrixIndexException(\"illegal column argument\");\n+\t\t}\n+\t\tint nRows = this.getRowDimension();\n+\t\tdouble[] out = new double[nRows];\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tout[row] = data[row][col - 1];\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Returns the entry in the specified row and column.\n+\t *\n+\t * @param row  row location of entry to be fetched  \n+\t * @param column  column location of entry to be fetched\n+\t * @return matrix entry in row,column\n+\t * @throws MatrixIndexException if the specified coordinate is outside \n+\t *                              the dimensions of this matrix\n+\t */\n+\tpublic double getEntry(int row, int column)\n+\t\tthrows MatrixIndexException {\n+\t\tif (!isValidCoordinate(row,column)) {\n+\t\t\tthrow new MatrixIndexException(\"matrix entry does not exist\");\n+\t\t}\n+\t\treturn data[row - 1][column - 1];\n+\t}\n+\n+\t/**\n+\t * Sets the entry in the specified row and column to the specified value.\n+\t *\n+\t * @param row    row location of entry to be set \n+\t * @param column    column location of entry to be set\n+\t * @param value  value to set \n+\t * @throws MatrixIndexException if the specified coordinate is outside\n+\t *                              he dimensions of this matrix\n+\t */\n+\tpublic void setEntry(int row, int column, double value)\n+\t\tthrows MatrixIndexException {\n+\t\tif (!isValidCoordinate(row,column)) {\n+\t\t\tthrow new MatrixIndexException(\"matrix entry does not exist\");\n+\t\t}\n+\t\tdata[row - 1][column - 1] = value;\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t *\n+\t * @return transpose matrix\n+\t */\n+\tpublic RealMatrix transpose() {\n+\t\tint nRows = this.getRowDimension();\n+\t\tint nCols = this.getColumnDimension();\n+\t\tRealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n+\t\tdouble[][] outData = out.getDataRef();\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tfor (int col = 0; col < nCols; col++) {\n+\t\t\t\toutData[col][row] = data[row][col];\n+\t\t\t}\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * @return inverse matrix\n+\t * @throws IllegalArgumentException if this is not invertible\n+\t */\n+\tpublic RealMatrix inverse() throws IllegalArgumentException {\n+\t\treturn solve(getIdentity(this.getRowDimension()));\n+\t}\n+\n+\t/**\n+\t * @return determinant\n+\t * @throws IllegalArgumentException if matrix is not square\n+\t */\n+\tpublic double getDeterminant() throws InvalidMatrixException {\n+\t\tif (!isSquare()) {\n+\t\t\tthrow new InvalidMatrixException(\"matrix is not square\");\n+\t\t}\n+\t\tif (isSingular()) { // note: this has side effect of attempting LU\n+\t\t\treturn 0d; //       decomp if lu == null\n+\t\t} else {\n+\t\t\tdouble det = (double) parity;\n+\t\t\tfor (int i = 0; i < this.getRowDimension(); i++) {\n+\t\t\t\tdet *= lu[i][i];\n+\t\t\t}\n+\t\t\treturn det;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the matrix is square (rowDimension = columnDimension)\n+\t */\n+\tpublic boolean isSquare() {\n+\t\treturn (this.getColumnDimension() == this.getRowDimension());\n+\t}\n+\n+\t/**\n+\t * @return true if the matrix is singular\n+\t */\n+\tpublic boolean isSingular() {\n+\t\t// @TODO A bad way to check for a singular matrix, is this the only way - kick off an LU decompose?\n+\t\tif (lu == null) {\n+\t\t\ttry {\n+\t\t\t\tLUDecompose();\n+\t\t\t\treturn false;\n+\t\t\t} catch (InvalidMatrixException ex) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else { // LU decomp must have been successfully performed\n+\t\t\treturn false; // so the matrix is not singular\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return rowDimension\n+\t */\n+\tpublic int getRowDimension() {\n+\t\treturn data.length;\n+\t}\n+\n+\t/**\n+\t * @return columnDimension\n+\t */\n+\tpublic int getColumnDimension() {\n+\t\treturn data[0].length;\n+\t}\n+\n+\t/**\n+\t * @return trace\n+\t * @throws IllegalArgumentException if the matrix is not square\n+\t */\n+\tpublic double getTrace() throws IllegalArgumentException {\n+\t\tif (!isSquare()) {\n+\t\t\tthrow new IllegalArgumentException(\"matrix is not square\");\n+\t\t}\n+\t\tdouble trace = data[0][0];\n+\t\tfor (int i = 1; i < this.getRowDimension(); i++) {\n+\t\t\ttrace += data[i][i];\n+\t\t}\n+\t\treturn trace;\n+\t}\n+\n+\t/**\n+\t * @param v vector to operate on\n+\t * @throws IllegalArgumentException if columnDimension != v.length\n+\t * @return resulting vector\n+\t */\n+\tpublic double[] operate(double[] v) throws IllegalArgumentException {\n+\t\tif (v.length != this.getColumnDimension()) {\n+\t\t\tthrow new IllegalArgumentException(\"vector has wrong length\");\n+\t\t}\n+\t\tint nRows = this.getRowDimension();\n+\t\tint nCols = this.getColumnDimension();\n+\t\tdouble[] out = new double[v.length];\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tdouble sum = 0;\n+\t\t\tfor (int i = 0; i < nCols; i++) {\n+\t\t\t\tsum += data[row][i] * v[i];\n+\t\t\t}\n+\t\t\tout[row] = sum;\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * @param v vector to premultiply by\n+\t * @throws IllegalArgumentException if rowDimension != v.length\n+\t * @return resulting matrix\n+\t */\n+\tpublic RealMatrix preMultiply(double[] v) throws IllegalArgumentException {\n+\t\tint nCols = this.getColumnDimension();\n+\t\tif (v.length != nCols) {\n+\t\t\tthrow new IllegalArgumentException(\"vector has wrong length\");\n+\t\t}\n+\t\t// being a bit lazy here -- probably should implement directly, like\n+\t\t// operate\n+\t\tRealMatrix pm = new RealMatrixImpl(v).transpose();\n+\t\treturn pm.multiply(this);\n+\t}\n+\n+\t/**\n+\t * Returns a matrix of (column) solution vectors for linear systems with\n+\t * coefficient matrix = this and constant vectors = columns of\n+\t * <code>b</code>. \n+\t *\n+\t * @param b  array of constant forming RHS of linear systems to\n+\t * to solve\n+\t * @return solution array\n+\t * @throws IllegalArgumentException if this.rowDimension != row dimension\n+\t * @throws InvalidMatrixException if this matrix is square or singular\n+\t */\n+\tpublic double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n+\t\tint nRows = this.getRowDimension();\n+\t\tif (b.length != nRows) {\n+\t\t\tthrow new IllegalArgumentException(\"constant vector has wrong length\");\n+\t\t}\n+\t\tRealMatrix bMatrix = new RealMatrixImpl(b);\n+\t\tdouble[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n+\t\tdouble[] out = new double[nRows];\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tout[row] = solution[row][0];\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Returns a matrix of (column) solution vectors for linear systems with\n+\t * coefficient matrix = this and constant vectors = columns of\n+\t * <code>b</code>. \n+\t *\n+\t * @param b  matrix of constant vectors forming RHS of linear systems to\n+\t * to solve\n+\t * @return matrix of solution vectors\n+\t * @throws IllegalArgumentException if this.rowDimension != row dimension\n+\t * @throws InvalidMatrixException if this matrix is square or singular\n+\t */\n+\tpublic RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n+\t\tif (b.getRowDimension() != this.getRowDimension()) {\n+\t\t\tthrow new IllegalArgumentException(\"Incorrect row dimension\");\n+\t\t}\n+\t\tif (!this.isSquare()) {\n+\t\t\tthrow new InvalidMatrixException(\"coefficient matrix is not square\");\n+\t\t}\n+\t\tif (this.isSingular()) { // side effect: compute LU decomp\n+\t\t\tthrow new InvalidMatrixException(\"Matrix is singular.\");\n+\t\t}\n+\n+\t\tint nCol = this.getColumnDimension();\n+\t\tint nColB = b.getColumnDimension();\n+\t\tint nRowB = b.getRowDimension();\n+\n+\t\t// Apply permutations to b\n+\t\tdouble[][] bv = b.getData();\n+\t\tdouble[][] bp = new double[nRowB][nColB];\n+\t\tfor (int row = 0; row < nRowB; row++) {\n+\t\t\tfor (int col = 0; col < nColB; col++) {\n+\t\t\t\tbp[row][col] = bv[pivot[row]][col];\n+\t\t\t}\n+\t\t}\n+\t\tbv = null;\n+\n+\t\t// Solve LY = b\n+\t\tfor (int col = 0; col < nCol; col++) {\n+\t\t\tfor (int i = col + 1; i < nCol; i++) {\n+\t\t\t\tfor (int j = 0; j < nColB; j++) {\n+\t\t\t\t\tbp[i][j] -= bp[col][j] * lu[i][col];\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Solve UX = Y\n+\t\tfor (int col = nCol - 1; col >= 0; col--) {\n+\t\t\tfor (int j = 0; j < nColB; j++) {\n+\t\t\t\tbp[col][j] /= lu[col][col];\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < col; i++) {\n+\t\t\t\tfor (int j = 0; j < nColB; j++) {\n+\t\t\t\t\tbp[i][j] -= bp[col][j] * lu[i][col];\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tRealMatrixImpl outMat = new RealMatrixImpl(bp);\n+\t\treturn outMat;\n+\t}\n+\n+\t/**\n+\t * Computes a new <a href=\"http://www.math.gatech.edu/~bourbaki/\n+\t * math2601/Web-notes/2num.pdf\">LU decompostion</a> for this matrix,\n+\t * storing the result for use by other methods.\n+\t * <p>\n+\t * <strong>Implementation Note</strong>:<br>\n+\t * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/\n+\t * people/sd/lectures/nummeth98/linear.htm\">Crout's algortithm</a>,\n+\t * with partial pivoting.\n+\t * <p>\n+\t * <strong>Usage Note</strong>:<br>\n+\t * This method should rarely be invoked directly. Its only use is\n+\t * to force recomputation of the LU decomposition when changes have been\n+\t * made to the underlying data using direct array references. Changes\n+\t * made using setXxx methods will trigger recomputation when needed\n+\t * automatically.\n+\t *\n+\t * @throws InvalidMatrixException if the matrix is singular or if the matrix has more rows than columns\n+\t */\n+\tpublic void LUDecompose() throws InvalidMatrixException {\n+\t\t// @TODO Bad method name - get rid of leading capitals\n+\t\t\n+\t\tint nRows = this.getRowDimension();\n+\t\tint nCols = this.getColumnDimension();\n+\t\tif (nRows < nCols) {\n+\t\t\tthrow new InvalidMatrixException(\"LU decomposition requires row dimension >= column dimension\");\n+\t\t}\n+\t\tlu = this.getData();\n+\n+\t\t// Initialize pivot array and parity\n+\t\tpivot = new int[nRows];\n+\t\tfor (int row = 0; row < nRows; row++) {\n+\t\t\tpivot[row] = row;\n+\t\t}\n+\t\tparity = 1;\n+\n+\t\t// Loop over columns\n+\t\tfor (int col = 0; col < nCols; col++) {\n+\n+\t\t\tdouble sum = 0;\n+\n+\t\t\t// upper\n+\t\t\tfor (int row = 0; row < col; row++) {\n+\t\t\t\tsum = lu[row][col];\n+\t\t\t\tfor (int i = 0; i < row; i++) {\n+\t\t\t\t\tsum -= lu[row][i] * lu[i][col];\n+\t\t\t\t}\n+\t\t\t\tlu[row][col] = sum;\n+\t\t\t}\n+\n+\t\t\t// lower\n+\t\t\tint max = col; // pivot row\n+\t\t\tdouble largest = 0d;\n+\t\t\tfor (int row = col; row < nRows; row++) {\n+\t\t\t\tsum = lu[row][col];\n+\t\t\t\tfor (int i = 0; i < col; i++) {\n+\t\t\t\t\tsum -= lu[row][i] * lu[i][col];\n+\t\t\t\t}\n+\t\t\t\tlu[row][col] = sum;\n+\n+\t\t\t\t// maintain best pivot choice\n+\t\t\t\tif (Math.abs(sum) > largest) {\n+\t\t\t\t\tlargest = Math.abs(sum);\n+\t\t\t\t\tmax = row;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Singularity check\n+\t\t\tif (Math.abs(lu[max][col]) < TOO_SMALL) {\n+\t\t\t\tlu = null;\n+\t\t\t\tthrow new InvalidMatrixException(\"matrix is singular\");\n+\t\t\t}\n+\n+\t\t\t// Pivot if necessary\n+\t\t\tif (max != col) {\n+\t\t\t\tdouble tmp = 0;\n+\t\t\t\tfor (int i = 0; i < nCols; i++) {\n+\t\t\t\t\ttmp = lu[max][i];\n+\t\t\t\t\tlu[max][i] = lu[col][i];\n+\t\t\t\t\tlu[col][i] = tmp;\n+\t\t\t\t}\n+\t\t\t\tint temp = pivot[max];\n+\t\t\t\tpivot[max] = pivot[col];\n+\t\t\t\tpivot[col] = temp;\n+\t\t\t\tparity = -parity;\n+\t\t\t}\n+\n+\t\t\t//Divide the lower elements by the \"winning\" diagonal elt.\n+\t\t\tfor (int row = col + 1; row < nRows; row++) {\n+\t\t\t\tlu[row][col] /= lu[col][col];\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * \n+\t * @see java.lang.Object#toString()\n+\t */\n+\tpublic String toString() {\n+\t\tStringBuffer res = new StringBuffer();\n+\t\tres.append(\"RealMatrixImpl{\");\n+\t\tfor (int i = 0; i < data.length; i++) {\n+\t\t\tif (i > 0)\n+\t\t\t\tres.append(\",\");\n+\t\t\tres.append(\"{\");\n+\t\t\tfor (int j = 0; j < data[0].length; j++) {\n+\t\t\t\tif (j > 0)\n+\t\t\t\t\tres.append(\",\");\n+\t\t\t\tres.append(data[i][j]);\n+\t\t\t} //for\n+\t\t\tres.append(\"}\");\n+\t\t} //for\n+\t\tres.append(\"}\");\n+\t\treturn res.toString();\n+\t} //toString\n+\n+\t//------------------------ Protected methods\n+\n+\t/**\n+\t * Returns <code>dimension x dimension</code> identity matrix.\n+\t *\n+\t * @param dimension dimension of identity matrix to generate\n+\t * @return identity matrix\n+\t */\n+\tprotected RealMatrix getIdentity(int dimension) {\n+\t\tRealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n+\t\tdouble[][] d = out.getDataRef();\n+\t\tfor (int row = 0; row < dimension; row++) {\n+\t\t\tfor (int col = 0; col < dimension; col++) {\n+\t\t\t\td[row][col] = row == col ? 1d : 0d;\n+\t\t\t}\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t//------------------------ Private methods\n+\n+\t/**\n+\t * Returns a fresh copy of the underlying data array.\n+\t *\n+\t * @return a copy of the underlying data array.\n+\t */\n+\tprivate double[][] copyOut() {\n+\t\tint nRows = this.getRowDimension();\n+\t\tdouble[][] out = new double[nRows][this.getColumnDimension()];\n+\t\t// can't copy 2-d array in one shot, otherwise get row references\n+\t\tfor (int i = 0; i < nRows; i++) {\n+\t\t\tSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Replaces data with a fresh copy of the input array.\n+\t *\n+\t * @param in data to copy in\n+\t */\n+\tprivate void copyIn(double[][] in) {\n+\t\tint nRows = in.length;\n+\t\tint nCols = in[0].length;\n+\t\tdata = new double[nRows][nCols];\n+\t\tSystem.arraycopy(in, 0, data, 0, in.length);\n+\t\tfor (int i = 0; i < nRows; i++) {\n+\t\t\tSystem.arraycopy(in[i], 0, data[i], 0, nCols);\n+\t\t}\n+\t\tlu = null;\n+\t}\n+\n+\t/**\n+\t * Tests a given coordinate as being valid or invalid\n+\t *\n+\t * @return true if the coordinate is with the current dimensions\n+\t */\n+\tprivate boolean isValidCoordinate(int row, int col) {\n+\t\tint nRows = this.getRowDimension();\n+\t\tint nCols = this.getColumnDimension();\n+\n+\t\treturn !(row < 1 || row > nRows || col < 1 || col > nCols);\n+\t}\n+\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n /**\n  * Test cases for the {@link RealMatrixImpl} class.\n  *\n- * @version $Revision: 1.8 $ $Date: 2003/11/23 20:34:41 $\n+ * @version $Revision: 1.9 $ $Date: 2004/01/28 20:15:03 $\n  */\n \n public final class RealMatrixImplTest extends TestCase {\n         RealMatrix bs = new RealMatrixImpl(bigSingular);\n         try {\n             RealMatrix a = bs.solve(bs);\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n             ;\n         }\n         try {\n             RealMatrix a = m.solve(bs);\n-            fail(\"Expecting illegalArgumentException\");\n+            fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             ;\n         }\n         } \n         try {\n             (new RealMatrixImpl(testData2)).LUDecompose();\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n             ;\n         }  \n     }\n         assertEquals(\"nonsingular test\",-3d,m.getDeterminant(),normTolerance);\n         try {\n             double a = new RealMatrixImpl(testData2).getDeterminant();\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n             ;\n         }      \n     }\n         assertClose(\"get col\",m.getColumn(3),testDataCol3,entryTolerance);\n         try {\n             double[] x = m.getRow(10);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n             ;\n         }\n         try {\n             double[] x = m.getColumn(-1);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n             ;\n         }\n     }\n         assertEquals(\"get entry\",m.getEntry(1,2),100d,entryTolerance);\n         try {\n             double x = m.getEntry(0,2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n             ;\n         }\n         try {\n             m.setEntry(1,4,200d);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n             ;\n         }\n     }", "timestamp": 1075320903, "metainfo": ""}