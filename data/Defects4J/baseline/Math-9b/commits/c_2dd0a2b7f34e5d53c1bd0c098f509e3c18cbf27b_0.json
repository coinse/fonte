{"sha": "2dd0a2b7f34e5d53c1bd0c098f509e3c18cbf27b", "log": "Additon of begin and length controls to StatUtils. Addition on test for array conditions.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n     public static double sum(double[] values) {\n+        return sum(values, 0, values.length);\n+    }\n+\n+    /**\n+     * The sum of the values that have been added to Univariate.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sum of the values or Double.NaN if the array is empty\n+     */\n+    public static double sum(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n         double accum = 0.0;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             accum += values[i];\n         }\n         return accum;\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n     public static double sumSq(double[] values) {\n+        return sumSq(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the available values.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sum of the squared values or Double.NaN if the array is empty\n+     */\n+    public static double sumSq(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n         double accum = 0.0;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             accum += Math.pow(values[i], 2.0);\n         }\n         return accum;\n      * @return the product values or Double.NaN if the array is empty\n      */\n     public static double product(double[] values) {\n-        double product = Double.NaN;\n-        if (values.length > 0) {\n-            product = 1.0;\n-            for (int i = 0; i < values.length; i++) {\n-                product *= values[i];\n-            }\n+        return product(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the product for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the product values or Double.NaN if the array is empty\n+     */\n+    public static double product(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+        double product = 1.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            product *= values[i];\n         }\n         return product;\n     }\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n     public static double sumLog(double[] values) {\n-        double sumLog = Double.NaN;\n-        if (values.length > 0) {\n-            sumLog = 0.0;\n-            for (int i = 0; i < values.length; i++) {\n-                sumLog += Math.log(values[i]);\n-            }\n+        return sumLog(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the sum of the natural logs for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sumLog value or Double.NaN if the array is empty\n+     */\n+    public static double sumLog(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+        double sumLog = 0.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            sumLog += Math.log(values[i]);\n         }\n         return sumLog;\n     }\n      * any of the values are &lt;= 0.\n      */\n     public static double geometricMean(double[] values) {\n-        return Math.exp(sumLog(values) / (double) values.length);\n+        return geometricMean(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the geometric mean for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the geometric mean or Double.NaN if the array is empty or\n+     * any of the values are &lt;= 0.\n+     */\n+    public static double geometricMean(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+        return Math.exp(sumLog(values, begin, length) / (double) length );\n     }\n \n     /**\n     }\n \n     /**\n+      * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n+      * arithmetic mean </a> of the available values \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+      * @return the mean of the values or Double.NaN if the array is empty\n+      */\n+    public static double mean(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+        return sum(values, begin, length) / ((double) length);\n+    }\n+\n+    /**\n      *      \n      * @param values Is a double[] containing the values\n      * @return the result, Double.NaN if no values for an empty array \n      * or 0.0 for a single value set.  \n      */\n     public static double standardDeviation(double[] values) {\n+        return standardDeviation(values, 0, values.length);\n+    }\n+\n+    /**\n+     *      \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n+     */\n+    public static double standardDeviation(\n+        double[] values,\n+        int begin,\n+        int length) {\n+        testInput(values, begin, length);\n         double stdDev = Double.NaN;\n         if (values.length != 0) {\n-            stdDev = Math.sqrt(variance(values));\n+            stdDev = Math.sqrt(variance(values, begin, length));\n         }\n         return (stdDev);\n     }\n      * or 0.0 for a single value set.  \n      */\n     public static double variance(double[] values) {\n+        return variance(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the variance of the available values. This uses a corrected\n+     * two pass algorithm of the following \n+     * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n+     * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n+     * \"Algorithms for Computing the Sample Variance: Analysis and\n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * 1983, American Statistician, vol. 37, pp. 242?247.\n+     * \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n+     */\n+    public static double variance(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+\n         double variance = Double.NaN;\n-\n         if (values.length == 1) {\n             variance = 0;\n         } else if (values.length > 1) {\n-            double mean = mean(values);\n+            double mean = mean(values, begin, length);\n             double accum = 0.0;\n             double accum2 = 0.0;\n-            for (int i = 0; i < values.length; i++) {\n+            for (int i = begin; i < begin + length; i++) {\n                 accum += Math.pow((values[i] - mean), 2.0);\n                 accum2 += (values[i] - mean);\n             }\n             variance =\n-                (accum - (Math.pow(accum2, 2) / (double) values.length))\n-                    / (double) (values.length - 1);\n+                (accum - (Math.pow(accum2, 2) / ((double)length)))\n+                    / (double) (length - 1);\n         }\n         return variance;\n     }\n      * @return the skewness of the values or Double.NaN if the array is empty\n      */\n     public static double skewness(double[] values) {\n+        return skewness(values, 0, values.length);\n+    }\n+        /**\n+     * Returns the skewness of a collection of values.  Skewness is a \n+     * measure of the assymetry of a given distribution. \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the skewness of the values or Double.NaN if the array is empty\n+     */\n+    public static double skewness(double[] values, int begin, int length) {\n+        \n+        testInput(values, begin, length);\n+        \n         // Initialize the skewness\n         double skewness = Double.NaN;\n \n         // Get the mean and the standard deviation\n-        double mean = mean(values);\n-        double stdDev = standardDeviation(values);\n+        double mean = mean(values, begin, length);\n+        double stdDev = standardDeviation(values, begin, length);\n \n         // Sum the cubes of the distance from the mean divided by the \n         // standard deviation\n         double accum = 0.0;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             accum += Math.pow((values[i] - mean) / stdDev, 3.0);\n         }\n \n         // Get N\n-        double n = values.length;\n+        double n = length;\n \n         // Calculate skewness\n         skewness = (n / ((n - 1) * (n - 2))) * accum;\n      * @return the kurtosis of the values or Double.NaN if the array is empty\n      */\n     public static double kurtosis(double[] values) {\n+        return kurtosis(values, 0, values.length);\n+    }\n+    \n+    /**\n+     * Returns the kurtosis for this collection of values. Kurtosis is a \n+     * measure of the \"peakedness\" of a distribution.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the kurtosis of the values or Double.NaN if the array is empty\n+     */\n+    public static double kurtosis(double[] values, int begin, int length) {\n+        \n+        testInput(values, begin, length);\n+    \n         // Initialize the kurtosis\n         double kurtosis = Double.NaN;\n \n         // Get the mean and the standard deviation\n-        double mean = mean(values);\n-        double stdDev = standardDeviation(values);\n+        double mean = mean(values, begin, length);\n+        double stdDev = standardDeviation(values, begin, length);\n \n         // Sum the ^4 of the distance from the mean divided by the \n         // standard deviation\n         double accum = 0.0;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             accum += Math.pow((values[i] - mean) / stdDev, 4.0);\n         }\n \n         // Get N\n-        double n = values.length;\n+        double n = length;\n \n         double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n         double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n \n         return kurtosis;\n     }\n-\n+    \n     /**\n      * Returns the maximum of the available values\n      * @param values Is a double[] containing the values\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n     public static double max(double[] values) {\n+        return max(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the maximum of the available values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the maximum of the values or Double.NaN if the array is empty\n+     */\n+    public static double max(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n         double max = Double.NaN;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             if (i == 0) {\n                 max = values[i];\n             } else {\n-                max = Math.max(max, values[i]);\n+                max = (max > values[i]) ? max : values[i];\n             }\n         }\n         return max;\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n     public static double min(double[] values) {\n+        return min(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the minimum of the available values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the minimum of the values or Double.NaN if the array is empty\n+     */\n+    public static double min(double[] values, int begin, int length) {\n+        testInput(values, begin, length);\n+\n         double min = Double.NaN;\n-        for (int i = 0; i < values.length; i++) {\n+        for (int i = begin; i < begin + length; i++) {\n             if (i == 0) {\n                 min = values[i];\n             } else {\n-                min = Math.min(min, values[i]);\n+                min = (min < values[i]) ? min : values[i];\n             }\n         }\n         return min;\n     }\n+\n+    /**\n+     * Private testInput method used by all methods to verify the content \n+     * of the array and indicies are correct.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     */\n+    private static void testInput(double[] values, int begin, int length) {\n+\n+        if (length > values.length)\n+            throw new IllegalArgumentException(\"length > values.length\");\n+\n+        if (begin + length > values.length)\n+            throw new IllegalArgumentException(\"begin + length > values.length\");\n+\n+        if (values == null)\n+            throw new IllegalArgumentException(\"input value array is null\");\n+\n+    }\n }\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n  *\n  * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n- * @version $Revision: 1.1 $ $Date: 2003/06/18 15:59:55 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/24 14:03:31 $\n  */\n \n public final class StatUtilsTest extends TestCase {\n             0.00001);\n     }\n \n+    public void testArrayIndexConditions() throws Exception {\n+        double[] values = { 1.0, 2.0, 3.0, 4.0 };\n+\n+        assertEquals(\"Sum not expected\", 5.0, StatUtils.sum(values,1,2),Double.MIN_VALUE);\n+        assertEquals(\"Sum not expected\", 3.0, StatUtils.sum(values,0,2),Double.MIN_VALUE);\n+        assertEquals(\"Sum not expected\", 7.0, StatUtils.sum(values,2,2),Double.MIN_VALUE);\n+        \n+    }\n }", "timestamp": 1056463412, "metainfo": ""}