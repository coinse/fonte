{"sha": "513511976ddc778f7c52d69bf43db3c3f4b88803", "log": "fixed checkstyle and findbugs errors  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/ScalarDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/ScalarDifferentiableOptimizer.java\n     void setConvergenceChecker(ScalarConvergenceChecker checker);\n \n     /** Get the convergence checker.\n-     * @param checker object to use to check for convergence\n+     * @return object used to check for convergence\n      */\n     ScalarConvergenceChecker getConvergenceChecker();\n \n--- a/src/java/org/apache/commons/math/optimization/ScalarOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/ScalarOptimizer.java\n     void setConvergenceChecker(ScalarConvergenceChecker checker);\n \n     /** Get the convergence checker.\n-     * @param checker object to use to check for convergence\n+     * @return object used to check for convergence\n      */\n     ScalarConvergenceChecker getConvergenceChecker();\n \n--- a/src/java/org/apache/commons/math/optimization/ScalarPointValuePair.java\n+++ b/src/java/org/apache/commons/math/optimization/ScalarPointValuePair.java\n      * it will be referenced\n      */\n     public ScalarPointValuePair(final double[] point, final double value,\n-                          final boolean copyArray) {\n+                                final boolean copyArray) {\n         this.point = copyArray ? point.clone() : point;\n         this.value  = value;\n     }\n--- a/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n     void setConvergenceChecker(VectorialConvergenceChecker checker);\n \n     /** Get the convergence checker.\n-     * @param checker object to use to check for convergence\n+     * @return object used to check for convergence\n      */\n     VectorialConvergenceChecker getConvergenceChecker();\n \n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n     /** Build an initial simplex.\n      * @param startPoint the start point for optimization\n-     * @exception IllegalArgumentException\n+     * @exception IllegalArgumentException if the start point does not match\n+     * simplex dimension\n      */\n     private void buildSimplex(final double[] startPoint)\n         throws IllegalArgumentException {\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n         // store least squares problem characteristics\n         this.f         = f;\n-        this.target    = target;\n-        this.weights   = weights;\n+        this.target    = target.clone();\n+        this.weights   = weights.clone();\n         this.variables = startPoint.clone();\n         this.residuals = new double[target.length];\n \n     }\n \n     /** Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception ObjectiveException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n     abstract protected VectorialPointValuePair doOptimize()\n     throws ObjectiveException, OptimizationException, IllegalArgumentException;\n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n      * and the maximal number of evaluation is set to\n      * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_EVALUATIONS}.\n      * @param useLU if true, the normal equations will be solved using LU\n-     * decomposition, otherwise it will be solved using QR decomposition\n+     * decomposition, otherwise they will be solved using QR decomposition\n      */\n     public GaussNewtonOptimizer(final boolean useLU) {\n         this.useLU = useLU;\n--- a/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n  */\n \n public class CorrelatedRandomVectorGenerator\n-implements RandomVectorGenerator {\n+    implements RandomVectorGenerator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7162933284241468177L;\n \n     /** Simple constructor.\n      * <p>Build a correlated random vector generator from its mean\n--- a/src/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n \n public class GaussianRandomGenerator implements NormalizedRandomGenerator {\n \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4698731518385853565L;\n+\n     /** Create a new generator.\n      * @param generator underlying random generator to use\n      */\n--- a/src/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n+import java.io.Serializable;\n+\n /** \n  * This interface represent a normalized random generator for\n  * scalars.\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public interface NormalizedRandomGenerator {\n+public interface NormalizedRandomGenerator extends Serializable {\n \n   /** Generate a random scalar with null mean and unit standard deviation.\n    * <p>This method does <strong>not</strong> specify the shape of the\n--- a/src/java/org/apache/commons/math/random/RandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/RandomVectorGenerator.java\n \n package org.apache.commons.math.random;\n \n+import java.io.Serializable;\n+\n /** This interface represents a random generator for whole vectors.\n  * \n  * @since 1.2\n  *\n  */\n \n-public interface RandomVectorGenerator {\n+public interface RandomVectorGenerator extends Serializable {\n \n   /** Generate a random vector.\n    * @return a random vector as an array of double.\n--- a/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n \n public class UncorrelatedRandomVectorGenerator\n   implements RandomVectorGenerator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -3268228248001718811L;\n \n   /** Simple constructor.\n    * <p>Build an uncorrelated random vector generator from\n--- a/src/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UniformRandomGenerator.java\n \n public class UniformRandomGenerator implements NormalizedRandomGenerator {\n \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1569292426375546027L;\n+\n     /** Create a new generator.\n      * @param generator underlying random generator to use\n      */\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n      * <code>0</code>.</li>\n      * </ul>\n      * \n-     * @param u any number\n-     * @param v any number\n+     * @param p any number\n+     * @param q any number\n      * @return the greatest common divisor, never negative\n      * @throws ArithmeticException\n      *             if the result cannot be represented as a nonnegative int\n--- a/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n             optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n     public void testColumnsPermutation() throws ObjectiveException, OptimizationException {\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n \n     }\n \n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n             fail(\"wrong exception caught\");\n         }\n         assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n     public void testQRColumnsPermutation() throws ObjectiveException, OptimizationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n-                    new double[] { 4.0, 6.0, 1.0 });\n+                              new double[] { 4.0, 6.0, 1.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n \n     }\n ", "timestamp": 1237152938, "metainfo": ""}