{"sha": "91f9106a9d21fab13a64bbed6eeb94c7e69e4b8f", "log": "Code cleanup: \"0.0\" -> \"0\", \"1.0\" -> \"1\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n                 for (int i = k; i < m; i++) {\n                     singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                 }\n-                if (singularValues[k] != 0.0) {\n-                    if (A[k][k] < 0.0) {\n+                if (singularValues[k] != 0) {\n+                    if (A[k][k] < 0) {\n                         singularValues[k] = -singularValues[k];\n                     }\n                     for (int i = k; i < m; i++) {\n                         A[i][k] /= singularValues[k];\n                     }\n-                    A[k][k] += 1.0;\n+                    A[k][k] += 1;\n                 }\n                 singularValues[k] = -singularValues[k];\n             }\n             for (int j = k + 1; j < n; j++) {\n                 if (k < nct &&\n-                    singularValues[k] != 0.0) {\n+                    singularValues[k] != 0) {\n                     // Apply the transformation.\n                     double t = 0;\n                     for (int i = k; i < m; i++) {\n                 for (int i = k + 1; i < n; i++) {\n                     e[k] = FastMath.hypot(e[k], e[i]);\n                 }\n-                if (e[k] != 0.0) {\n-                    if (e[k + 1] < 0.0) {\n+                if (e[k] != 0) {\n+                    if (e[k + 1] < 0) {\n                         e[k] = -e[k];\n                     }\n                     for (int i = k + 1; i < n; i++) {\n                         e[i] /= e[k];\n                     }\n-                    e[k + 1] += 1.0;\n+                    e[k + 1] += 1;\n                 }\n                 e[k] = -e[k];\n                 if (k + 1 < m &&\n                     e[k] != 0) {\n                     // Apply the transformation.\n                     for (int i = k + 1; i < m; i++) {\n-                        work[i] = 0.0;\n+                        work[i] = 0;\n                     }\n                     for (int j = k + 1; j < n; j++) {\n                         for (int i = k + 1; i < m; i++) {\n             singularValues[nct] = A[nct][nct];\n         }\n         if (m < p) {\n-            singularValues[p - 1] = 0.0;\n+            singularValues[p - 1] = 0;\n         }\n         if (nrt + 1 < p) {\n             e[nrt] = A[nrt][p - 1];\n         }\n-        e[p - 1] = 0.0;\n+        e[p - 1] = 0;\n \n         // Generate U.\n         for (int j = nct; j < n; j++) {\n             for (int i = 0; i < m; i++) {\n-                U[i][j] = 0.0;\n-            }\n-            U[j][j] = 1.0;\n+                U[i][j] = 0;\n+            }\n+            U[j][j] = 1;\n         }\n         for (int k = nct - 1; k >= 0; k--) {\n-            if (singularValues[k] != 0.0) {\n+            if (singularValues[k] != 0) {\n                 for (int j = k + 1; j < n; j++) {\n                     double t = 0;\n                     for (int i = k; i < m; i++) {\n                 for (int i = k; i < m; i++) {\n                     U[i][k] = -U[i][k];\n                 }\n-                U[k][k] = 1.0 + U[k][k];\n+                U[k][k] = 1 + U[k][k];\n                 for (int i = 0; i < k - 1; i++) {\n-                    U[i][k] = 0.0;\n+                    U[i][k] = 0;\n                 }\n             } else {\n                 for (int i = 0; i < m; i++) {\n-                    U[i][k] = 0.0;\n-                }\n-                U[k][k] = 1.0;\n+                    U[i][k] = 0;\n+                }\n+                U[k][k] = 1;\n             }\n         }\n \n                 }\n             }\n             for (int i = 0; i < n; i++) {\n-                V[i][k] = 0.0;\n-            }\n-            V[k][k] = 1.0;\n+                V[i][k] = 0;\n+            }\n+            V[k][k] = 1;\n         }\n \n         // Main iteration loop for the singular values.\n                     = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                     FastMath.abs(singularValues[k + 1]));\n                 if (FastMath.abs(e[k]) <= threshold) {\n-                    e[k] = 0.0;\n+                    e[k] = 0;\n                     break;\n                 }\n             }\n                     if (ks == k) {\n                         break;\n                     }\n-                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n-                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n+                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n+                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                     if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n-                        singularValues[ks] = 0.0;\n+                        singularValues[ks] = 0;\n                         break;\n                     }\n                 }\n                 // Deflate negligible s(p).\n                 case 1: {\n                     double f = e[p - 2];\n-                    e[p - 2] = 0.0;\n+                    e[p - 2] = 0;\n                     for (int j = p - 2; j >= k; j--) {\n                         double t = FastMath.hypot(singularValues[j], f);\n                         final double cs = singularValues[j] / t;\n                 // Split at negligible s(k).\n                 case 2: {\n                     double f = e[k - 1];\n-                    e[k - 1] = 0.0;\n+                    e[k - 1] = 0;\n                     for (int j = k; j < p; j++) {\n                         double t = FastMath.hypot(singularValues[j], f);\n                         final double cs = singularValues[j] / t;\n                     final double ek = e[k] / scale;\n                     final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                     final double c = (sp * epm1) * (sp * epm1);\n-                    double shift = 0.0;\n+                    double shift = 0;\n                     if (b != 0 ||\n                         c != 0) {\n                         shift = FastMath.sqrt(b * b + c);\n-                        if (b < 0.0) {\n+                        if (b < 0) {\n                             shift = -shift;\n                         }\n                         shift = c / (b + shift);\n                 // Convergence.\n                 default: {\n                     // Make the singular values positive.\n-                    if (singularValues[k] <= 0.0) {\n-                        singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;\n+                    if (singularValues[k] <= 0) {\n+                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n \n                         for (int i = 0; i <= pp; i++) {\n                             V[i][k] = -V[i][k];", "timestamp": 1313190706, "metainfo": ""}