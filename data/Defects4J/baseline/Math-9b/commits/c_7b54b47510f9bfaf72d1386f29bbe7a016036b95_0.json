{"sha": "7b54b47510f9bfaf72d1386f29bbe7a016036b95", "log": "completely redesigned Adams-Bashforth and Adams-Moulton integrators they are now provided by a single class and use the Nordsieck form with higher derivatives at current step instead of classical form with only first derivatives but at several steps. The implementation is simpler for both the integrators and the step interpolator and it allows a future enhancement with adaptive stepsize.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n+import org.apache.commons.math.linear.decomposition.FieldLUDecompositionImpl;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements explicit Adams-Bashforth and Adams-Moulton integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Bashforth (in fact due to Adams alone) methods are explicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3y'<sub>n</sub>-y'<sub>n-1</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23y'<sub>n</sub>-16y'<sub>n-1</sub>+5y'<sub>n-2</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55y'<sub>n</sub>-59y'<sub>n-1</sub>+37y'<sub>n-2</sub>-9y'<sub>n-3)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Bashforth method is of order k. There is no theoretical limit to the\n+ * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ *\n+ * <p>Adams-Moulton (also due to Adams alone) methods are implicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n+1, n, n-1 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n+1</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (y'<sub>n+1</sub>+y'<sub>n</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (5y'<sub>n+1</sub>+8y'<sub>n</sub>-y'<sub>n-1</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (9y'<sub>n+1</sub>+19y'<sub>n</sub>-5y'<sub>n-1</sub>+y'<sub>n-2)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Moulton method is of order k+1. There is no theoretical limit to the\n+ * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ *\n+ * <h3>Implementation details</h3>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>The definitions above use the classical representation with several previous first\n+ * derivatives. Lets define\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity). With these definitions,\n+ * Adams-Bashforth methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 3/2 s<sub>1</sub>(n) + [ -1/2 ] q<sub>n</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 23/12 s<sub>1</sub>(n) + [ -16/12 5/12 ] q<sub>n</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 55/24 s<sub>1</sub>(n) + [ -59/24 37/24 -9/24 ] q<sub>n</sub></li>\n+ *   <li>...</li>\n+ * </ul>and Adams-Moulton methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 1/2 s<sub>1</sub>(n+1) + [ 1/2 ] q<sub>n+1</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 5/12 s<sub>1</sub>(n+1) + [ 8/12 -1/12 ] q<sub>n+1</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 9/24 s<sub>1</sub>(n+1) + [ 19/24 -5/24 1/24 ] q<sub>n+1</sub></li>\n+ *   <li>...</li>\n+ * </ul></p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation (q<sub>n</sub> for Adams-Bashforth or q<sub>n+1</sub> for Adams-Moulton)\n+ * and Nordsieck vector\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<supT</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity). The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ * \n+ * <p>This class implements the Adams-Bashforth and Adams-Moulton method using the Nordsieck vector\n+ * (i.e. y<sub>n</sub>, s<sub>1</sub>(n) and r<sub>n</sub>) rather than the classical representation.\n+ * Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it leverages Adams-Bashforth and Adams-Moulton methods as in this representation\n+ *   they share most of their coefficients and most of their implementation,</li>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ * </ul></p>\n+ * \n+ * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre>\n+ * If the method is an Adams-Moulton method, the following additional correction is performed:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = r<sub>n+1</sub> + (s<sub>1</sub>(n) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>n+1</sub> and R<sub>n+1</sub> represent the\n+ * corrected states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the predicted states.</p>\n+ *\n+ * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,\n+ * they are precomputed once for all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5893911062100008922L;\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, CachedCoefficients> cache =\n+        new HashMap<Integer, CachedCoefficients>();\n+\n+    /** No correction integrator method name. */\n+    private static final String NO_CORRECTION_METHOD_NAME = \"Adams-Bashforth\";\n+\n+    /** Correction integrator method name. */\n+    private static final String CORRECTION_METHOD_NAME = \"Adams-Moulton\";\n+\n+    /** Correction indicator (to choose between Adams-Bashforth and Adams-Moulton). */\n+    private final boolean withCorrection;\n+\n+    /** Coefficients of the method. */\n+    private final transient CachedCoefficients coefficients;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Bashforth or Adams-Moulton integrator with the given order and step size.\n+     * @param order order of the method (must be greater than 1: due to\n+     * an implementation limitation the order 1 method is not supported)\n+     * @param withCorrection if true apply Adams-Moulton correction at end of\n+     * step, otherwise use only Adams-Bashforth prediction\n+     * @param step integration step size\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsIntegrator(final int order, final boolean withCorrection,\n+                           final double step)\n+        throws IllegalArgumentException {\n+\n+        super(withCorrection ? CORRECTION_METHOD_NAME : NO_CORRECTION_METHOD_NAME,\n+              order, new NordsieckStepInterpolator());\n+        if (order <= 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} is supported only for orders 2 or more\",\n+                  getName());\n+        }\n+        this.withCorrection = withCorrection;\n+\n+        // cache the coefficients for each order, to avoid recomputing them\n+        synchronized(cache) {\n+            CachedCoefficients coeff = cache.get(order);\n+            if (coeff == null) {\n+                coeff = new CachedCoefficients(order);\n+                cache.put(order, coeff);\n+            }\n+            coefficients = coeff;\n+        }\n+\n+        this.step = Math.abs(step);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0,\n+                            final double t, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = y0.length;\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, n);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final NordsieckStepInterpolator interpolator =\n+                (NordsieckStepInterpolator) prototype.copy();\n+        interpolator.reinitialize(yTmp, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = forward ? step : -step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        System.arraycopy(y, 0, yTmp, 0, n);\n+\n+        // convert to Nordsieck representation\n+        double[]   scaled    = convertToNordsieckLow();\n+        RealMatrix nordsieck = convertToNordsieckHigh(scaled);\n+        interpolator.reinitialize(stepSize, scaled, nordsieck);\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            if (withCorrection) {\n+\n+                // evaluate derivative at predicted state\n+                final double stepEnd = stepStart + stepSize;\n+                final double[] f0 = previousF[0];\n+                previousT[0] = stepEnd;\n+                equations.computeDerivatives(stepEnd, interpolator.getInterpolatedState(), f0);\n+\n+                // update Nordsieck vector\n+                nordsieck = coefficients.msUpdate.multiply(nordsieck);\n+                final double[] end = new double[y0.length];\n+                for (int j = 0; j < y0.length; ++j) {\n+                    end[j] = stepSize * f0[j];\n+                }\n+                nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));\n+                scaled = end;\n+\n+                // update interpolator\n+                nordsieck.walkInOptimizedOrder(new Corrector(y, scaled, yTmp));\n+                interpolator.reinitialize(stepSize, scaled, nordsieck);\n+\n+            }\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepStart + stepSize);\n+            if (manager.evaluateStep(interpolator)) {\n+                stepSize = manager.getEventTime() - stepStart;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = stepStart + stepSize;\n+            interpolator.setInterpolatedTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, n);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep) {\n+                // prepare next step\n+\n+                if (manager.reset(stepStart, y)) {\n+\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    stopTime =\n+                        start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                    if (Double.isNaN(previousT[0])) {\n+                        return stopTime;\n+                    }\n+                    stepStart = previousT[0];\n+\n+                    // convert to Nordsieck representation\n+                    scaled    = convertToNordsieckLow();\n+                    nordsieck = convertToNordsieckHigh(scaled);\n+\n+                } else {\n+\n+                    // evaluate differential equations for next step\n+                    final double[] f0 = previousF[0];\n+                    previousT[0] = stepStart;\n+                    equations.computeDerivatives(stepStart, y, f0);\n+                    if (!withCorrection) {\n+                        nordsieck = coefficients.msUpdate.multiply(nordsieck);\n+                    }\n+                    final double[] end = new double[y0.length];\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        end[j] = stepSize * f0[j];\n+                    }\n+                    nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));\n+                    scaled = end;\n+\n+                }\n+\n+                System.arraycopy(y, 0, yTmp, 0, n);\n+                interpolator.reinitialize(stepSize, scaled, nordsieck);\n+\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @return first scaled derivative\n+     */\n+    private double[] convertToNordsieckLow() {\n+\n+        final double[] f0 = previousF[0];\n+        final double[] scaled = new double[f0.length];\n+        for (int j = 0; j < f0.length; ++j) {\n+            scaled[j] = stepSize * f0[j];\n+        }\n+        return scaled;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @param scaled first scaled derivative\n+     * @return Nordsieck matrix of the higher scaled derivatives\n+     */\n+    private RealMatrix convertToNordsieckHigh(final double[] scaled) {\n+\n+        final double[] f0 = previousF[0];\n+        final double[][] multistep = new double[coefficients.msToN.getColumnDimension()][f0.length];\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            final double[] fI  = previousF[i + 1];\n+            for (int j = 0; j < f0.length; ++j) {\n+                msI[j] = stepSize * fI[j] - scaled[j];\n+            }\n+        }\n+\n+        return coefficients.msToN.multiply(new RealMatrixImpl(multistep, false));\n+\n+    }\n+\n+    /** Corrector for current state in Adams-Moulton method.\n+     * <p>\n+     * This visitor implements the Taylor series formula:\n+     * <pre>\n+     * Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub>\n+     * </pre>\n+     * </p>\n+     */\n+    private static class Corrector implements RealMatrixPreservingVisitor {\n+\n+        /** Previous state. */\n+        private final double[] previous;\n+\n+        /** Current scaled first derivative. */\n+        private final double[] scaled;\n+\n+        /** Placeholder where to put the recomputed current state. */\n+        private final double[] corrected;\n+\n+        /** Simple constructor.\n+         * @param previous previous state\n+         * @param scaled current scaled first derivative\n+         * @param corrected placeholder where to put the corrected current state\n+         */\n+        public Corrector(final double[] previous, final double[] scaled, final double[] corrected) {\n+            this.previous = previous;\n+            this.scaled    = scaled;\n+            this.corrected  = corrected;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            Arrays.fill(corrected, 0.0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            if ((row & 0x1) == 0) {\n+                corrected[column] -= value;\n+            } else {\n+                corrected[column] += value;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double end() {\n+            for (int i = 0; i < corrected.length; ++i) {\n+                corrected[i] += previous[i] + scaled[i];\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /** Updater for Nordsieck vector. */\n+    private static class NordsieckUpdater extends DefaultRealMatrixChangingVisitor {\n+\n+        /** Scaled first derivative at step start. */\n+        private final double[] start;\n+\n+        /** Scaled first derivative at step end. */\n+        private final double[] end;\n+\n+        /** Update coefficients. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param start scaled first derivative at step start\n+         * @param end scaled first derivative at step end\n+         * @param c1 update coefficients\n+         */\n+        public NordsieckUpdater(final double[] start, final double[] end,\n+                                final double[] c1) {\n+            this.start = start;\n+            this.end   = end;\n+            this.c1    = c1;\n+        }\n+\n+       /** {@inheritDoc} */\n+        @Override\n+        public double visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            return value + c1[row] * (start[column] - end[column]);\n+        }\n+\n+    }\n+\n+    /** Cache for already computed coefficients. */\n+    private static class CachedCoefficients {\n+\n+        /** Transformer between multistep and Nordsieck representations. */\n+        private final RealMatrix msToN;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'', y''' ... */\n+        private final RealMatrix msUpdate;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param order order of the method (must be greater than 1: due to\n+         * an implementation limitation the order 1 method is not supported)\n+         */\n+        public CachedCoefficients(int order) {\n+\n+            // compute exact coefficients\n+            FieldMatrix<BigFraction> bigNtoMS = buildP(order);\n+            FieldMatrix<BigFraction> bigMStoN =\n+                new FieldLUDecompositionImpl<BigFraction>(bigNtoMS).getSolver().getInverse();\n+            BigFraction[] u = new BigFraction[order - 1];\n+            Arrays.fill(u, BigFraction.ONE);\n+            BigFraction[] bigC1 = bigMStoN.operate(u);\n+\n+            // update coefficients are computed by combining transform from\n+            // Nordsieck to multistep, then shifting rows to represent step advance\n+            // then applying inverse transform\n+            BigFraction[][] shiftedP = bigNtoMS.getData();\n+            for (int i = shiftedP.length - 1; i > 0; --i) {\n+                // shift rows\n+                shiftedP[i] = shiftedP[i - 1];\n+            }\n+            shiftedP[0] = new BigFraction[order - 1];\n+            Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+            FieldMatrix<BigFraction> bigMSupdate =\n+                bigMStoN.multiply(new FieldMatrixImpl<BigFraction>(shiftedP, false));\n+\n+            // convert coefficients to double\n+            msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n+            msUpdate = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+            c1       = new double[order - 1];\n+            for (int i = 0; i < order - 1; ++i) {\n+                c1[i] = bigC1[i].doubleValue();\n+            }\n+\n+        }\n+\n+        /** Build the P matrix transforming multistep to Nordsieck.\n+         * <p>\n+         * <p>\n+         * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n+         * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n+         * The two representations share their two first components y(k) and\n+         * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n+         * <pre>\n+         * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n+         * </pre>\n+         * </p>\n+         * @param order order of the method (must be strictly positive)\n+         * @return P matrix\n+         */\n+        private static FieldMatrix<BigFraction> buildP(final int order) {\n+\n+            final BigFraction[][] pData = new BigFraction[order - 1][order - 1];\n+\n+            for (int i = 0; i < pData.length; ++i) {\n+                // build the P matrix elements from Taylor series formulas\n+                final BigFraction[] pI = pData[i];\n+                final int factor = -(i + 1);\n+                int aj = factor;\n+                for (int j = 0; j < pI.length; ++j) {\n+                    pI[j] = new BigFraction(aj * (j + 2));\n+                    aj *= factor;\n+                }\n+            }\n+\n+            return new FieldMatrixImpl<BigFraction>(pData, false);\n+\n+        }\n+\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        oos.writeInt(coefficients.msToN.getRowDimension() + 1);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            ois.defaultReadObject();\n+            final int order = ois.readInt();\n+\n+            final Class<AdamsIntegrator> cl = AdamsIntegrator.class;\n+            final Field f = cl.getDeclaredField(\"coefficients\");\n+            f.setAccessible(true);\n+\n+            // cache the coefficients for each order, to avoid recomputing them\n+            synchronized(cache) {\n+                CachedCoefficients coeff = cache.get(order);\n+                if (coeff == null) {\n+                    coeff = new CachedCoefficients(order);\n+                    cache.put(order, coeff);\n+                }\n+                f.set(this, coeff);\n+            }\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            throw new IOException(nsfe);\n+        } catch (IllegalAccessException iae) {\n+            throw new IOException(iae);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.junit.Test;\n+\n+public class AdamsIntegratorTest {\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheckBashforth() throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        new AdamsIntegrator(3, false, 0.01).integrate(pb,\n+                                                      0.0, new double[pb.getDimension()+10],\n+                                                      1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test\n+    public void decreasingStepsBashforth() throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+                FirstOrderIntegrator integ = new AdamsIntegrator(5, false, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n+                    assertTrue(error <= Math.abs(1.05 * previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void smallStepBashforth() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(3, false, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 2.0e-9);\n+        assertTrue(handler.getMaximalValueError() < 9.0e-9);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+\n+    }\n+\n+    @Test\n+    public void bigStepBashforth() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(3, false, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() > 0.06);\n+        assertTrue(handler.getMaximalValueError() > 0.06);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+\n+    }\n+\n+    @Test\n+    public void backwardBashforth() throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(5, false, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 8.0e-11);\n+        assertTrue(handler.getMaximalValueError() < 8.0e-11);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomialBashforth() throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+\n+        for (int order = 2; order < 9; ++order) {\n+            MultistepIntegrator integ = new AdamsIntegrator(order, false, step);\n+            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n+                                                                      1.0e-5, 1.0e-5));\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            if (order < 5) {\n+                assertTrue(handler.getMaximalValueError() > 1.0e-5);\n+            } else {\n+                assertTrue(handler.getMaximalValueError() < 7.0e-12);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void serializationBashforth()\n+        throws IntegratorException, DerivativeException,\n+               IOException, ClassNotFoundException {\n+\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+        oos.writeObject(new AdamsIntegrator(8, false, step));\n+        assertTrue(bos.size() > 3000);\n+        assertTrue(bos.size() < 3100);\n+\n+        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream     ois = new ObjectInputStream(bis);\n+        FirstOrderIntegrator integ  = (AdamsIntegrator) ois.readObject();\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        assertTrue(handler.getMaximalValueError() < 7.0e-13);\n+\n+    }\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheckMoulton()\n+        throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        new AdamsIntegrator(3, true, 0.01).integrate(pb,\n+                                                     0.0, new double[pb.getDimension()+10],\n+                                                     1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test\n+    public void decreasingStepsMoulton()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+                FirstOrderIntegrator integ = new AdamsIntegrator(5, true, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n+                    assertTrue(error <= Math.abs(1.05 * previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void smallStepMoulton()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(3, true, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 1.0e-14);\n+        assertTrue(handler.getMaximalValueError() < 2.0e-17);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+\n+    }\n+\n+    @Test\n+    public void bigStepMoulton()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(3, true, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getMaximalValueError() > 6.0e-6);\n+\n+    }\n+\n+    @Test\n+    public void backwardMoulton()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsIntegrator(5, true, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 1.0e-15);\n+        assertTrue(handler.getMaximalValueError() < 3.0e-16);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomialMoulton()\n+        throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+\n+        for (int order = 2; order < 9; ++order) {\n+            MultistepIntegrator integ = new AdamsIntegrator(order, true, step);\n+            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n+                                                                      1.0e-5, 1.0e-5));\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            assertTrue(handler.getMaximalValueError() < 2.0e-13);\n+        }\n+\n+    }\n+\n+}", "timestamp": 1243807646, "metainfo": ""}