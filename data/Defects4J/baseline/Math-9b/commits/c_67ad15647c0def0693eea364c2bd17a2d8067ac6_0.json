{"sha": "67ad15647c0def0693eea364c2bd17a2d8067ac6", "log": "MATH-792:   - various methods to visit the entries of a RealVector (entries are unmodified),   - default implementation in RealVector abstract class,   - unit tests in abstract RealVectorAbstractClass,   - all XxxRealVectorTest classes now extend RealVectorAbstractClass.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n \n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.analysis.FunctionUtils;\n     }\n \n     /**\n+     * Checks that the indices of a subvector are valid.\n+     *\n+     * @param start the index of the first entry of the subvector\n+     * @param end the index of the last entry of the subvector (inclusive)\n+     * @throws OutOfRangeException if {@code start} of {@code end} are not valid\n+     * @throws NumberIsTooSmallException if {@code end < start}\n+     */\n+    protected void checkIndices(final int start, final int end) {\n+        final int dim = getDimension();\n+        if ((start < 0) || (start >= dim)) {\n+            throw new OutOfRangeException(LocalizedFormats.INDEX,\n+                                          Integer.valueOf(start),\n+                                          Integer.valueOf(0),\n+                                          Integer.valueOf(dim - 1));\n+        }\n+        if ((end < 0) || (end >= dim)) {\n+            throw new OutOfRangeException(LocalizedFormats.INDEX,\n+                                          Integer.valueOf(end),\n+                                          Integer.valueOf(0),\n+                                          Integer.valueOf(dim - 1));\n+        }\n+        if (end < start){\n+            // TODO Use more specific error message\n+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n+                                                Integer.valueOf(end),\n+                                                Integer.valueOf(start),\n+                                                false);\n+        }\n+    }\n+\n+    /**\n      * Compute the sum of this vector and {@code v}.\n      * Returns a new vector. Does not change instance data.\n      *\n         return this;\n     }\n \n-    /**\n-     *  An entry in the vector.\n-     */\n+\n+    /**\n+     * Visits (but does not change) all entries of this vector in default order\n+     * (increasing index).\n+     *\n+     * @param visitor the visitor to be used to process the entries of this\n+     * vector\n+     * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n+     * at the end of the walk\n+     */\n+    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor) {\n+        final int dim = getDimension();\n+        visitor.start(dim, 0, dim - 1);\n+        for (int i = 0; i < dim; i++) {\n+            visitor.visit(i, getEntry(i));\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Visits (and possibly change) some entries of this vector in default order\n+     * (increasing index).\n+     *\n+     * @param visitor visitor to be used to process the entries of this vector\n+     * @param start the index of the first entry to be visited\n+     * @param end the index of the last entry to be visited (inclusive)\n+     * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n+     * at the end of the walk\n+     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n+     * the indices are not valid.\n+     */\n+    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n+                              int start, int end) {\n+        checkIndices(start, end);\n+        visitor.start(getDimension(), start, end);\n+        for (int i = start; i <= end; i++) {\n+            visitor.visit(i, getEntry(i));\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Visits (but does not change) all entries of this vector in optimized\n+     * order. The order in which the entries are visited is selected so as to\n+     * lead to the most efficient implementation; it might depend on the\n+     * concrete implementation of this abstract class.\n+     *\n+     * @param visitor the visitor to be used to process the entries of this\n+     * vector\n+     * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n+     * at the end of the walk\n+     */\n+    public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor) {\n+        return walkInDefaultOrder(visitor);\n+    }\n+\n+    /**\n+     * Visits (and possibly change) some entries of this vector in default order\n+     * (increasing index). The order in which the entries are visited is\n+     * selected so as to lead to the most efficient implementation; it might\n+     * depend on the concrete implementation of this abstract class.\n+     *\n+     * @param visitor visitor to be used to process the entries of this vector\n+     * @param start the index of the first entry to be visited\n+     * @param end the index of the last entry to be visited (inclusive)\n+     * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n+     * at the end of the walk\n+     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n+     * the indices are not valid.\n+     */\n+    public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor,\n+                                       int start, int end) {\n+        return walkInDefaultOrder(visitor, start, end);\n+    }\n+\n+    /** An entry in the vector. */\n     protected class Entry {\n         /** Index of this entry. */\n         private int index;\n--- a/src/main/java/org/apache/commons/math3/linear/RealVectorPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVectorPreservingVisitor.java\n      * End visiting a vector. This method is called once, after all entries of\n      * the vector have been visited.\n      *\n-     * @return the value that the {@code walkInXxxOrder} must return\n+     * @return the value returned by\n+     * {@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor)},\n+     * {@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor, int, int)},\n+     * {@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor)}\n+     * or\n+     * {@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor, int, int)\n      */\n-    // TODO Check above javadoc comment (add proper link to methods in\n-    // RealVector class)\n     double end();\n }\n--- a/src/test/java/org/apache/commons/math3/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/ArrayRealVectorTest.java\n  *\n  * @version $Id$\n  */\n-public class ArrayRealVectorTest {\n+public class ArrayRealVectorTest extends RealVectorAbstractTest {\n \n     //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n             Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n         }\n     }\n+\n+    @Override\n+    public RealVector create(final double[] data) {\n+        return new ArrayRealVector(data, true);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n+package org.apache.commons.math3.linear;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.junit.Test;\n+\n+\n+public abstract class RealVectorAbstractTest {\n+\n+    public abstract RealVector create(double[] data);\n+\n+    /** The whole vector is visited. */\n+    @Test\n+    public void testWalkInDefaultOrderPreservingVisitor1() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final RealVector v = create(data);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+\n+            private int expectedIndex;\n+\n+            public void visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(expectedIndex, actualIndex);\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                ++expectedIndex;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(0, actualStart);\n+                Assert.assertEquals(data.length - 1, actualEnd);\n+                expectedIndex = 0;\n+            }\n+\n+            public double end() {\n+                return 0;\n+            }\n+        };\n+        v.walkInDefaultOrder(visitor);\n+    }\n+\n+    /** Visiting an invalid subvector. */\n+    @Test\n+    public void testWalkInDefaultOrderPreservingVisitor2() {\n+        final RealVector v = create(new double[5]);\n+        try {\n+            v.walkInDefaultOrder(null, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(null, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(null, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(null, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(null, 4, 0);\n+            Assert.fail();\n+        } catch (NumberIsTooSmallException e) {\n+            // Expected behavior\n+        }\n+    }\n+\n+    /** Visiting a valid subvector. */\n+    @Test\n+    public void testWalkInDefaultOrderPreservingVisitor3() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final int expectedStart = 2;\n+        final int expectedEnd = 7;\n+        final RealVector v = create(data);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+\n+            private int expectedIndex;\n+\n+            public void visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(expectedIndex, actualIndex);\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                ++expectedIndex;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(expectedStart, actualStart);\n+                Assert.assertEquals(expectedEnd, actualEnd);\n+                expectedIndex = expectedStart;\n+            }\n+\n+            public double end() {\n+                return 0;\n+            }\n+        };\n+        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);\n+    }\n+\n+    /** The whole vector is visited. */\n+    @Test\n+    public void testWalkInOptimizedOrderPreservingVisitor1() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final RealVector v = create(data);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+            private final boolean[] visited = new boolean[data.length];\n+\n+            public void visit(final int actualIndex, final double actualValue) {\n+                visited[actualIndex] = true;\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(0, actualStart);\n+                Assert.assertEquals(data.length - 1, actualEnd);\n+                Arrays.fill(visited, false);\n+            }\n+\n+            public double end() {\n+                for (int i = 0; i < data.length; i++) {\n+                    Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n+                                      visited[i]);\n+                }\n+                return 0;\n+            }\n+        };\n+        v.walkInOptimizedOrder(visitor);\n+    }\n+\n+    /** Visiting an invalid subvector. */\n+    @Test\n+    public void testWalkInOptimizedOrderPreservingVisitor2() {\n+        final RealVector v = create(new double[5]);\n+        try {\n+            v.walkInOptimizedOrder(null, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(null, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(null, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(null, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(null, 4, 0);\n+            Assert.fail();\n+        } catch (NumberIsTooSmallException e) {\n+            // Expected behavior\n+        }\n+    }\n+\n+    /** Visiting a valid subvector. */\n+    @Test\n+    public void testWalkInOptimizedOrderPreservingVisitor3() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final int expectedStart = 2;\n+        final int expectedEnd = 7;\n+        final RealVector v = create(data);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+            private final boolean[] visited = new boolean[data.length];\n+\n+            public void visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                visited[actualIndex] = true;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(expectedStart, actualStart);\n+                Assert.assertEquals(expectedEnd, actualEnd);\n+                Arrays.fill(visited, true);\n+            }\n+\n+            public double end() {\n+                for (int i = expectedStart; i <= expectedEnd; i++) {\n+                    Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n+                                      visited[i]);\n+                }\n+                return 0;\n+            }\n+        };\n+        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorTest.java\n /**\n  * Tests for {@link RealVector}.\n  */\n-public class RealVectorTest {\n+public class RealVectorTest extends RealVectorAbstractTest{\n     private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n     private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };\n \n             Assert.assertEquals(v[i] + inc, x.getEntry(i), 0);\n         }\n     }\n+\n+    @Override\n+    public RealVector create(final double[] data) {\n+        return new OpenMapRealVector(data);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java\n  *\n  * @version $Id$\n  */\n-public class SparseRealVectorTest {\n+public class SparseRealVectorTest extends RealVectorAbstractTest {\n \n     //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n         u.ebeMultiply(v1);\n         u.ebeDivide(v1);\n     }\n+\n+    @Override\n+    public RealVector create(double[] data) {\n+        return new OpenMapRealVector(data);\n+    }\n }", "timestamp": 1338193873, "metainfo": ""}