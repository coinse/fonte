{"sha": "6b67f82c40bee7bb3e69258923110bec88057717", "log": "Checkstyle.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math3.optimization.GoalType;\n import org.apache.commons.math3.optimization.PointValuePair;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n-import org.apache.commons.math3.optimization.AbstractConvergenceChecker;\n import org.apache.commons.math3.optimization.MultivariateOptimizer;\n import org.apache.commons.math3.optimization.univariate.BracketFinder;\n import org.apache.commons.math3.optimization.univariate.BrentOptimizer;\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n     /**\n      * Check that an array is monotonically increasing or decreasing.\n      *\n+     * @param <T> the type of the elements in the specified array\n      * @param val Values.\n      * @param dir Ordering direction.\n      * @param strict Whether the order should be strict.\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n  * @version $Id$\n  */\n public class Precision {\n-\n-    /** Exponent offset in IEEE754 representation. */\n-    private static final long EXPONENT_OFFSET = 1023l;\n-\n     /**\n      * Smallest positive number such that {@code 1 - EPSILON} is not\n      * numerically equal to 1.\n      * <br/>\n      * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.\n      */\n-    public static final double EPSILON = Double.longBitsToDouble((EXPONENT_OFFSET - 53l) << 52);\n-    //This was previously expressed as = 0x1.0p-53;\n-    // However, OpenJDK (Sparc Solaris) cannot handle such small constants: MATH-721\n+    public static final double EPSILON;\n \n     /**\n      * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n      * In IEEE 754 arithmetic, this is also the smallest normalized\n      * number 2<sup>-1022</sup>.\n      */\n-    public static final double SAFE_MIN = Double.longBitsToDouble((EXPONENT_OFFSET - 1022l) << 52);\n-    // This was previously expressed as = 0x1.0p-1022;\n-    // However, OpenJDK (Sparc Solaris) cannot handle such small constants: MATH-721\n+    public static final double SAFE_MIN;\n+\n+    /** Exponent offset in IEEE754 representation. */\n+    private static final long EXPONENT_OFFSET = 1023l;\n \n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n     /** Offset to order signed double numbers lexicographically. */\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n+\n+    static {\n+        /*\n+         *  This was previously expressed as = 0x1.0p-53;\n+         *  However, OpenJDK (Sparc Solaris) cannot handle such small\n+         *  constants: MATH-721\n+         */\n+        EPSILON = Double.longBitsToDouble((EXPONENT_OFFSET - 53l) << 52);\n+\n+        /*\n+         * This was previously expressed as = 0x1.0p-1022;\n+         * However, OpenJDK (Sparc Solaris) cannot handle such small\n+         * constants: MATH-721\n+         */\n+        SAFE_MIN = Double.longBitsToDouble((EXPONENT_OFFSET - 1022l) << 52);\n+    }\n \n     /**\n      * Private constructor.", "timestamp": 1335785170, "metainfo": ""}