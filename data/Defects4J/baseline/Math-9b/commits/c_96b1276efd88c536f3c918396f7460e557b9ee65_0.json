{"sha": "96b1276efd88c536f3c918396f7460e557b9ee65", "log": "added an implementation of Dantzig's simplex algorithm to solve constrained linear optimization problems JIRA: MATH-246  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer\n     { \"unable to bracket optimum in line search\",\n       \"impossible d''encadrer l''optimum lors de la recherche lin\\u00e9aire\" },\n+\n+    // org.apache.commons.math.optimization.linear2.NoFeasibleSolutionException\n+    { \"no feasible solution\",\n+      \"aucune solution r\\u00e9alisable\" },\n+\n+    // org.apache.commons.math.optimization.linear2.UnboundedSolutionException\n+    { \"unbounded solution\",\n+      \"solution non born\\u00e9e\" },\n \n     // org.apache.commons.math.geometry.CardanEulerSingularityException\n     { \"Cardan angles singularity\",\n--- a/src/java/org/apache/commons/math/optimization/OptimizationException.java\n+++ b/src/java/org/apache/commons/math/optimization/OptimizationException.java\n import org.apache.commons.math.ConvergenceException;\n \n /** \n- * This class represents exceptions thrown by the estimation solvers.\n+ * This class represents exceptions thrown by optimizers.\n  *\n  * @version $Revision$ $Date$\n  * @since 1.2\n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n      * and the maximal number of evaluation is set to\n-     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_ITERATIONS}.\n+     * {@link AbstractLinearOptimizer#DEFAULT_MAX_ITERATIONS}.\n      * @param useLU if true, the normal equations will be solved using LU\n      * decomposition, otherwise they will be solved using QR decomposition\n      */\n--- a/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n      * and the maximal number of evaluation is set to\n-     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_EVALUATIONS}.\n+     * {@link AbstractLinearOptimizer#DEFAULT_MAX_EVALUATIONS}.\n      * @param updateFormula formula to use for updating the &beta; parameter,\n      * must be one of {@link UpdateFormula#FLETCHER_REEVES} or {@link\n      * UpdateFormula#POLAK_RIBIERE}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * Base class for implementing linear optimizers.\n+ * <p>This base class handles the boilerplate methods associated to thresholds\n+ * settings and iterations counters.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public abstract class AbstractLinearOptimizer implements LinearOptimizer {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8581325080951819398L;\n+\n+    /** Default maximal number of iterations allowed. */\n+    public static final int DEFAULT_MAX_ITERATIONS = 100;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Linear objective function. */\n+    protected LinearObjectiveFunction f;\n+\n+    /** Linear constraints. */\n+    protected Collection<LinearConstraint> constraints;\n+\n+    /** Type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}. */\n+    protected GoalType goalType;\n+\n+    /** Whether to restrict the variables to non-negative values. */\n+    protected boolean restrictToNonNegative;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The maximal number of evaluation is set to its default value.</p>\n+     */\n+    protected AbstractLinearOptimizer() {\n+        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            if (++iterations > maxIterations) {\n+                throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final LinearObjectiveFunction f,\n+                                       final Collection<LinearConstraint> constraints,\n+                                       final GoalType goalType, final boolean restrictToNonNegative)\n+         throws OptimizationException {\n+\n+        // store linear problem characteristics\n+        this.f                     = f;\n+        this.constraints           = constraints;\n+        this.goalType              = goalType;\n+        this.restrictToNonNegative = restrictToNonNegative;\n+\n+        iterations = 0;\n+\n+        // solve the problem\n+        return doOptimize();\n+\n+    }\n+\n+    /** Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception OptimizationException if no solution fulfilling the constraints\n+     * can be found in the allowed number of iterations\n+     */\n+    abstract protected RealPointValuePair doOptimize()\n+        throws OptimizationException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n+\n+\n+/**\n+ * A linear constraint for a linear optimization problem.\n+ * <p>\n+ * A linear constraint has one of the forms:\n+ * <ul>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ * </ul>\n+ * The c<sub>i</sub>, l<sub>i</sub> or r<sub>i</sub> are the coefficients of the constraints, the x<sub>i</sub>\n+ * are the coordinates of the current point and v is the value of the constraint.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LinearConstraint implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -764632794033034092L;\n+\n+    /** Coefficients of the constraint (left hand side). */\n+    private final RealVector coefficients;\n+\n+    /** Relationship between left and right hand sides (=, &lt;=, >=). */\n+    private final Relationship relationship;\n+\n+    /** Value of the constraint (right hand side). */\n+    private final double value;\n+\n+    /**\n+     * Build a constraint involving a single linear equation.\n+     * <p>\n+     * A linear constraint with a single linear equation has one of the forms:\n+     * <ul>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+     * </ul>\n+     * </p>\n+     * @param coefficients The coefficients of the constraint (left hand side)\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param value The value of the constraint (right hand side)\n+     */\n+    public LinearConstraint(final double[] coefficients, final Relationship relationship,\n+                            final double value) {\n+        this(new RealVectorImpl(coefficients), relationship, value);\n+    }\n+\n+    /**\n+     * Build a constraint involving a single linear equation.\n+     * <p>\n+     * A linear constraint with a single linear equation has one of the forms:\n+     * <ul>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+     * </ul>\n+     * </p>\n+     * @param coefficients The coefficients of the constraint (left hand side)\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param value The value of the constraint (right hand side)\n+     */\n+    public LinearConstraint(final RealVector coefficients, final Relationship relationship,\n+                            final double value) {\n+        this.coefficients = coefficients;\n+        this.relationship = relationship;\n+        this.value        = value;\n+    }\n+\n+    /**\n+     * Build a constraint involving two linear equations.\n+     * <p>\n+     * A linear constraint with two linear equation has one of the forms:\n+     * <ul>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     * </ul>\n+     * </p>\n+     * @param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint\n+     * @param lhsConstant The constant term of the linear expression on the left hand side of the constraint\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint\n+     * @param rhsConstant The constant term of the linear expression on the right hand side of the constraint\n+     */\n+    public LinearConstraint(final double[] lhsCoefficients, final double lhsConstant,\n+                            final Relationship relationship,\n+                            final double[] rhsCoefficients, final double rhsConstant) {\n+        double[] sub = new double[lhsCoefficients.length];\n+        for (int i = 0; i < sub.length; ++i) {\n+            sub[i] = lhsCoefficients[i] - rhsCoefficients[i];\n+        }\n+        this.coefficients = new RealVectorImpl(sub, false);\n+        this.relationship = relationship;\n+        this.value        = rhsConstant - lhsConstant;\n+    }\n+\n+    /**\n+     * Build a constraint involving two linear equations.\n+     * <p>\n+     * A linear constraint with two linear equation has one of the forms:\n+     * <ul>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     * </ul>\n+     * </p>\n+     * @param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint\n+     * @param lhsConstant The constant term of the linear expression on the left hand side of the constraint\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint\n+     * @param rhsConstant The constant term of the linear expression on the right hand side of the constraint\n+     */\n+    public LinearConstraint(final RealVector lhsCoefficients, final double lhsConstant,\n+                            final Relationship relationship,\n+                            final RealVector rhsCoefficients, final double rhsConstant) {\n+        this.coefficients = lhsCoefficients.subtract(rhsCoefficients);\n+        this.relationship = relationship;\n+        this.value        = rhsConstant - lhsConstant;\n+    }\n+\n+    /**\n+     * Get the coefficients of the constraint (left hand side).\n+     * @return coefficients of the constraint (left hand side)\n+     */\n+    public RealVector getCoefficients() {\n+        return coefficients;\n+    }\n+\n+    /**\n+     * Get the relationship between left and right hand sides.\n+     * @return relationship between left and right hand sides\n+     */\n+    public Relationship getRelationship() {\n+        return relationship;\n+    }\n+\n+    /**\n+     * Get the value of the constraint (right hand side).\n+     * @return value of the constraint (right hand side)\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n+\n+/**\n+ * An objective function for a linear optimization problem.\n+ * <p>\n+ * A linear objective function has one the form:\n+ * <pre>\n+ * c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> + d\n+ * </pre>\n+ * The c<sub>i</sub> and d are the coefficients of the equation,\n+ * the x<sub>i</sub> are the coordinates of the current point.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LinearObjectiveFunction implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4531815507568396090L;\n+\n+    /** Coefficients of the constraint (c<sub>i</sub>). */\n+    private final RealVector coefficients;\n+\n+    /** Constant term of the linear equation. */\n+    private final double constantTerm;\n+\n+    /**\n+     * @param coefficients The coefficients for the linear equation being optimized\n+     * @param constantTerm The constant term of the linear equation\n+     */\n+    public LinearObjectiveFunction(double[] coefficients, double constantTerm) {\n+        this(new RealVectorImpl(coefficients), constantTerm);\n+    }\n+\n+    /**\n+     * @param coefficients The coefficients for the linear equation being optimized\n+     * @param constantTerm The constant term of the linear equation\n+     */\n+    public LinearObjectiveFunction(RealVector coefficients, double constantTerm) {\n+        this.coefficients = coefficients;\n+        this.constantTerm = constantTerm;\n+    }\n+\n+    /**\n+     * Get the coefficients of the linear equation being optimized.\n+     * @return coefficients of the linear equation being optimized\n+     */\n+    public RealVector getCoefficients() {\n+        return coefficients;\n+    }\n+\n+    /**\n+     * Get the constant of the linear equation being optimized.\n+     * @return constant of the linear equation being optimized\n+     */\n+    public double getConstantTerm() {\n+        return constantTerm;\n+    }\n+\n+    /**\n+     * Compute the value of the linear equation at the current point\n+     * @param point point at which linear equation must be evaluated\n+     * @return value of the linear equation at the current point\n+     */\n+    public double getValue(final double[] point) {\n+        return coefficients.dotProduct(point) + constantTerm;\n+    }\n+\n+    /**\n+     * Compute the value of the linear equation at the current point\n+     * @param point point at which linear equation must be evaluated\n+     * @return value of the linear equation at the current point\n+     */\n+    public double getValue(final RealVector point) {\n+        return coefficients.dotProduct(point) + constantTerm;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/** \n+ * This interface represents an optimization algorithm for linear problems.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function. In the linear case the form of\n+ * the function is restricted to\n+ * <pre>\n+ * c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v\n+ * </pre>\n+ * and there may be linear constraints too, of one of the forms:\n+ * <ul>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ * </ul>\n+ * where the c<sub>i</sub>, l<sub>i</sub> or r<sub>i</sub> are the coefficients of\n+ * the constraints, the x<sub>i</sub> are the coordinates of the current point and\n+ * v is the value of the constraint.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface LinearOptimizer extends Serializable {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Optimizes an objective function.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @return point/value pair giving the optimal value for objective function\n+     * @exception OptimizationException if no solution fulfilling the constraints\n+     * can be found in the allowed number of iterations\n+     */\n+   RealPointValuePair optimize(LinearObjectiveFunction f, Collection<LinearConstraint> constraints,\n+                               GoalType goalType, boolean restrictToNonNegative)\n+        throws OptimizationException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/**\n+ * This class represents exceptions thrown by optimizers when no solution\n+ * fulfills the constraints.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NoFeasibleSolutionException extends OptimizationException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3044253632189082760L;\n+\n+    /** \n+     * Simple constructor using a default message.\n+     */\n+    public NoFeasibleSolutionException() {\n+        super(\"no feasible solution\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/Relationship.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+/**\n+ * Types of relationships between two cells in a Solver {@link LinearConstraint}.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public enum Relationship {\n+\n+    /** Equality relationship. */\n+    EQ(\"=\"),\n+\n+    /** Lesser than or equal relationship. */\n+    LEQ(\"<=\"),\n+\n+    /** Greater than or equal relationship. */\n+    GEQ(\">=\");\n+\n+    /** Display string for the relationship. */\n+    private String stringValue;\n+\n+    /** Simple constructor.\n+     * @param stringValue display string for the relationship\n+     */\n+    private Relationship(String stringValue) {\n+        this.stringValue = stringValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String toString() {\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Get the relationship obtained when multiplying all coefficients by -1.\n+     * @return relationship obtained when multiplying all coefficients by -1\n+     */\n+    public Relationship oppositeRelationship() {\n+        switch (this) {\n+        case LEQ :\n+            return GEQ;\n+        case GEQ :\n+            return LEQ;\n+        default :\n+            return EQ;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n+\n+\n+/**\n+ * Solves a linear problem using the Two-Phase Simplex Method.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimplexSolver extends AbstractLinearOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4886937648715323786L;\n+\n+    /** Default amount of error to accept in floating point comparisons. */ \n+    private static final double DEFAULT_EPSILON = 1.0e-10;\n+\n+    /** Amount of error to accept in floating point comparisons. */ \n+    protected final double epsilon;  \n+\n+    /**\n+     * Build a simplex solver with default settings.\n+     */\n+    public SimplexSolver() {\n+        this(DEFAULT_EPSILON);\n+    }\n+\n+    /**\n+     * Build a simplex solver with a specified accepted amount of error\n+     * @param epsilon the amount of error to accept in floating point comparisons\n+     */\n+    public SimplexSolver(final double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Returns the column with the most negative coefficient in the objective function row.\n+     * @param tableau simple tableau for the problem\n+     * @return column with the most negative coefficient\n+     */\n+    private Integer getPivotColumn(SimplexTableau tableau) {\n+        double minValue = 0;\n+        Integer minPos = null;\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (tableau.getEntry(0, i) < minValue) {\n+                minValue = tableau.getEntry(0, i);\n+                minPos = i;\n+            }\n+        }\n+        return minPos;\n+    }\n+\n+    /**\n+     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n+     * @param tableau simple tableau for the problem\n+     * @param col the column to test the ratio of.  See {@link #getPivotColumn()}\n+     * @return row with the minimum ratio\n+     */\n+    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n+        double minRatio = Double.MAX_VALUE;\n+        Integer minRatioPos = null;\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n+            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n+            if (tableau.getEntry(i, col) >= 0) {\n+                double ratio = rhs / tableau.getEntry(i, col);\n+                if (ratio < minRatio) {\n+                    minRatio = ratio;\n+                    minRatioPos = i; \n+                }\n+            }\n+        }\n+        return minRatioPos;\n+    }\n+\n+\n+    /**\n+     * Runs one iteration of the Simplex method on the given model.\n+     * @param tableau simple tableau for the problem\n+     * @throws OptimizationException if the maximal iteration count has been\n+     * exceeded or if the model is found not to have a bounded solution\n+     */\n+    protected void doIteration(final SimplexTableau tableau)\n+        throws OptimizationException {\n+\n+        incrementIterationsCounter();\n+\n+        Integer pivotCol = getPivotColumn(tableau);\n+        Integer pivotRow = getPivotRow(pivotCol, tableau);\n+        if (pivotRow == null) {\n+            throw new UnboundedSolutionException();\n+        }\n+\n+        // set the pivot element to 1\n+        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n+        tableau.divideRow(pivotRow, pivotVal);\n+\n+        // set the rest of the pivot column to 0\n+        for (int i = 0; i < tableau.getHeight(); i++) {\n+            if (i != pivotRow) {\n+                double multiplier = tableau.getEntry(i, pivotCol);\n+                tableau.subtractRow(i, pivotRow, multiplier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks whether Phase 1 is solved.\n+     * @param tableau simple tableau for the problem\n+     * @return whether Phase 1 is solved\n+     */\n+    private boolean isPhase1Solved(final SimplexTableau tableau) {\n+        if (tableau.getNumArtificialVariables() == 0) {\n+            return true;\n+        }\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (tableau.getEntry(0, i) < 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns whether the problem is at an optimal state.\n+     * @param tableau simple tableau for the problem\n+     * @return whether the model has been solved\n+     */\n+    public boolean isOptimal(final SimplexTableau tableau) {\n+        if (tableau.getNumArtificialVariables() > 0) {\n+            return false;\n+        }\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (tableau.getEntry(0, i) < 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Solves Phase 1 of the Simplex method.\n+     * @param tableau simple tableau for the problem\n+     * @exception OptimizationException if the maximal number of iterations is\n+     * exceeded, or if the problem is found not to have a bounded solution, or\n+     * if there is no feasible solution\n+     */\n+    protected void solvePhase1(final SimplexTableau tableau)\n+        throws OptimizationException {\n+        // make sure we're in Phase 1\n+        if (tableau.getNumArtificialVariables() == 0) {\n+            return;\n+        }\n+\n+        while (!isPhase1Solved(tableau)) {\n+            doIteration(tableau);\n+        }\n+\n+        // if W is not zero then we have no feasible solution\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+            throw new NoFeasibleSolutionException();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair doOptimize()\n+        throws OptimizationException {\n+        final SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, goalType, restrictToNonNegative);\n+        solvePhase1(tableau);\n+        tableau.discardArtificialVariables();\n+        while (!isOptimal(tableau)) {\n+            doIteration(tableau);\n+        }\n+        return tableau.getSolution();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * A tableau for use in the Simplex method.\n+ * \n+ * <p>\n+ * Example:\n+ * <pre>\n+ *   W |  Z |  x1 |  x2 |  x- | s1 |  s2 |  a1 |  RHS\n+ * ---------------------------------------------------\n+ *  -1    0    0     0     0     0     0     1     0   &lt;= phase 1 objective\n+ *   0    1   -15   -10    0     0     0     0     0   &lt;= phase 2 objective\n+ *   0    0    1     0     0     1     0     0     2   &lt;= constraint 1\n+ *   0    0    0     1     0     0     1     0     3   &lt;= constraint 2\n+ *   0    0    1     1     0     0     0     1     4   &lt;= constraint 3\n+ * </pre>\n+ * W: Phase 1 objective function</br>\n+ * Z: Phase 2 objective function</br>\n+ * x1 &amp; x2: Decision variables</br>\n+ * x-: Extra decision variable to allow for negative values</br>\n+ * s1 &amp; s2: Slack/Surplus variables</br>\n+ * a1: Artificial variable</br>\n+ * RHS: Right hand side</br>\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class SimplexTableau implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1369660067587938365L;\n+\n+    /** Linear objective function. */\n+    private final LinearObjectiveFunction f;\n+\n+    /** Linear constraints. */\n+    private final Collection<LinearConstraint> constraints;\n+\n+    /** Whether to restrict the variables to non-negative values. */\n+    private final boolean restrictToNonNegative;\n+\n+    /** Simple tableau. */\n+    protected RealMatrix tableau;\n+\n+    /** Number of decision variables. */\n+    protected final int numDecisionVariables;\n+\n+    /** Number of slack variables. */\n+    protected final int numSlackVariables;\n+\n+    /** Number of artificial variables. */\n+    protected int numArtificialVariables;\n+\n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative) {\n+        this.f                      = f;\n+        this.constraints            = constraints;\n+        this.restrictToNonNegative  = restrictToNonNegative;\n+        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n+        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n+                                      getConstraintTypeCounts(Relationship.GEQ);\n+        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n+                                      getConstraintTypeCounts(Relationship.GEQ);\n+        this.tableau = new RealMatrixImpl(createTableau(goalType == GoalType.MAXIMIZE));\n+        initialize();\n+    }\n+\n+    /**\n+     * Create the tableau by itself.\n+     * @param maximize if true, goal is to maximize the objective function\n+     * @return created tableau\n+     */\n+    protected double[][] createTableau(final boolean maximize) {\n+\n+        // create a matrix of the correct size\n+        List<LinearConstraint> constraints = getNormalizedConstraints();\n+        int width = numDecisionVariables + numSlackVariables +\n+        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n+        int height = constraints.size() + getNumObjectiveFunctions();\n+        double[][] matrix = new double[height][width];\n+\n+        // initialize the objective function rows\n+        if (getNumObjectiveFunctions() == 2) {\n+            matrix[0][0] = -1;\n+        }\n+        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n+        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n+        RealVector objectiveCoefficients =\n+            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n+            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n+            matrix[zIndex][width - 1] =\n+                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n+\n+                if (!restrictToNonNegative) {\n+                    matrix[zIndex][getSlackVariableOffset() - 1] =\n+                        getInvertedCoeffiecientSum(objectiveCoefficients);\n+                }\n+\n+                // initialize the constraint rows\n+                int slackVar = 0;\n+                int artificialVar = 0;\n+                for (int i = 0; i < constraints.size(); i++) {\n+                    LinearConstraint constraint = constraints.get(i);\n+                    int row = getNumObjectiveFunctions() + i;\n+\n+                    // decision variable coefficients\n+                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n+\n+                    // x-\n+                    if (!restrictToNonNegative) {\n+                        matrix[row][getSlackVariableOffset() - 1] =\n+                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                    }\n+\n+                    // RHS\n+                    matrix[row][width - 1] = constraint.getValue();\n+\n+                    // slack variables\n+                    if (constraint.getRelationship() == Relationship.LEQ) {\n+                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n+                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n+                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n+                    }\n+\n+                    // artificial variables\n+                    if ((constraint.getRelationship() == Relationship.EQ) ||\n+                        (constraint.getRelationship() == Relationship.GEQ)) {\n+                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n+                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n+                    }\n+                }\n+\n+                return matrix;\n+    }\n+\n+    /** Get the number of variables.\n+     * @return number of variables\n+     */\n+    public int getNumVariables() {\n+        return f.getCoefficients().getDimension();\n+    }\n+\n+    /**\n+     * Get new versions of the constraints which have positive right hand sides.\n+     * @return new versions of the constraints\n+     */\n+    public List<LinearConstraint> getNormalizedConstraints() {\n+        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n+        for (LinearConstraint constraint : constraints) {\n+            normalized.add(normalize(constraint));\n+        }\n+        return normalized;\n+    }\n+\n+    /**\n+     * Get a new equation equivalent to this one with a positive right hand side.\n+     * @param constraint reference constraint\n+     * @return new equation\n+     */\n+    private LinearConstraint normalize(final LinearConstraint constraint) {\n+        if (constraint.getValue() < 0) {\n+            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n+                                        constraint.getRelationship().oppositeRelationship(),\n+                                        -1 * constraint.getValue());\n+        }\n+        return new LinearConstraint(constraint.getCoefficients(), \n+                                    constraint.getRelationship(), constraint.getValue());\n+    }\n+\n+    /**\n+     * Get the number of objective functions in this tableau.\n+     * @return 2 for Phase 1.  1 for Phase 2.\n+     */\n+    protected final int getNumObjectiveFunctions() {\n+        return this.numArtificialVariables > 0 ? 2 : 1;\n+    }\n+\n+    /**\n+     * Get a count of constraints corresponding to a specified relationship.\n+     * @param relationship relationship to count\n+     * @return number of constraint with the specified relationship\n+     */\n+    private int getConstraintTypeCounts(final Relationship relationship) {\n+        int count = 0;\n+        for (final LinearConstraint constraint : constraints) {\n+            if (constraint.getRelationship() == relationship) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Puts the tableau in proper form by zeroing out the artificial variables\n+     * in the objective function via elementary row operations.\n+     */\n+    private void initialize() {\n+        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n+            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n+            subtractRow(0, row, 1.0);\n+        }\n+    }\n+\n+    /**\n+     * Get the -1 times the sum of all coefficients in the given array.\n+     * @param coefficients coefficients to sum\n+     * @return the -1 times the sum of all coefficients in the given array.\n+     */\n+    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+        double sum = 0;\n+        for (double coefficient : coefficients.getData()) {\n+            sum -= coefficient;\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col) {\n+        Integer row = null;\n+        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+            if (getEntry(i, col) != 0.0) {\n+                if (row == null) {\n+                    row = i;\n+                } else {\n+                    return null;\n+                }\n+            }\n+        }\n+        return row;\n+    }\n+\n+    /**\n+     * Removes the phase 1 objective function and artificial variables from this tableau.\n+     */\n+    protected void discardArtificialVariables() {\n+        if (numArtificialVariables == 0) {\n+            return;\n+        }\n+        int width = getWidth() - numArtificialVariables - 1;\n+        int height = getHeight() - 1;\n+        double[][] matrix = new double[height][width];\n+        for (int i = 0; i < height; i++) {\n+            for (int j = 0; j < width - 1; j++) {\n+                matrix[i][j] = getEntry(i + 1, j + 1);\n+            }\n+            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n+        }\n+        this.tableau = new RealMatrixImpl(matrix);\n+        this.numArtificialVariables = 0;\n+    }\n+\n+\n+    /**\n+     * @param src the source array\n+     * @param dest the destination array\n+     * @param destPos the destination position\n+     */\n+    private void copyArray(final double[] src, final double[] dest,\n+                           final int destPos) {\n+        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); \n+    }\n+\n+    /**\n+     * Get the current solution.\n+     * <p>\n+     * {@link #solve} should be called first for this to be the optimal solution.\n+     * </p>\n+     * @return current solution\n+     */\n+    protected RealPointValuePair getSolution() {\n+        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n+        double mostNegative = getDecisionVariableValue(getOriginalNumDecisionVariables());\n+        for (int i = 0; i < coefficients.length; i++) {\n+            coefficients[i] =\n+                getDecisionVariableValue(i) - (restrictToNonNegative ? 0 : mostNegative); \n+        }\n+        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n+    }\n+\n+    /**\n+     * Get the value of the given decision variable.  This is not the actual\n+     * value as it is guaranteed to be >= 0 and thus must be corrected before\n+     * being returned to the user.\n+     * \n+     * @param decisionVariable The index of the decision variable\n+     * @return The value of the given decision variable.\n+     */\n+    protected double getDecisionVariableValue(final int decisionVariable) {\n+        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + decisionVariable);\n+        return basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); \n+    }\n+\n+    /**\n+     * Subtracts a multiple of one row from another.\n+     * <p>\n+     * After application of this operation, the following will hold:\n+     *   minuendRow = minuendRow - multiple * subtrahendRow\n+     * </p>\n+     * @param dividendRow index of the row\n+     * @param divisor value of the divisor\n+     */\n+    protected void divideRow(final int dividendRow, final double divisor) {\n+        for (int j = 0; j < getWidth(); j++) {\n+            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n+        }\n+    }\n+\n+    /**\n+     * Subtracts a multiple of one row from another.\n+     * <p>\n+     * After application of this operation, the following will hold:\n+     *   minuendRow = minuendRow - multiple * subtrahendRow\n+     * </p>\n+     * @param minuendRow row index\n+     * @param subtrahendRow row index\n+     * @param multiple multiplication factor\n+     */\n+    protected void subtractRow(final int minuendRow, final int subtrahendRow,\n+                               final double multiple) {\n+        for (int j = 0; j < getWidth(); j++) {\n+            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -\n+                             multiple * tableau.getEntry(subtrahendRow, j));\n+        }\n+    }\n+\n+    /**\n+     * Get the width of the tableau.\n+     * @return width of the tableau\n+     */\n+    protected final int getWidth() {\n+        return tableau.getColumnDimension();\n+    }\n+\n+    /**\n+     * Get the height of the tableau.\n+     * @return height of the tableau\n+     */\n+    protected final int getHeight() {\n+        return tableau.getRowDimension();\n+    }\n+\n+    /** Get an entry of the tableau.\n+     * @param row row index\n+     * @param column column index\n+     * @return entry at (row, column)\n+     */\n+    protected final double getEntry(final int row, final int column) {\n+        return tableau.getEntry(row, column);\n+    }\n+\n+    /** Set an entry of the tableau.\n+     * @param row row index\n+     * @param column column index\n+     * param value for the entry\n+     */\n+    protected final void setEntry(final int row, final int column,\n+                                  final double value) {\n+        tableau.setEntry(row, column, value);\n+    }\n+\n+    /**\n+     * Get the offset of the first slack variable.\n+     * @return offset of the first slack variable\n+     */\n+    protected final int getSlackVariableOffset() {\n+        return getNumObjectiveFunctions() + numDecisionVariables;\n+    }\n+\n+    /**\n+     * Get the offset of the first artificial variable.\n+     * @return offset of the first artificial variable\n+     */\n+    protected final int getArtificialVariableOffset() {\n+        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n+    }\n+\n+    /**\n+     * Get the offset of the right hand side.\n+     * @return offset of the right hand side\n+     */\n+    protected final int getRhsOffset() {\n+        return getWidth() - 1;\n+    }\n+\n+    /**\n+     * Get the number of decision variables.\n+     * <p>\n+     * If variables are not restricted to positive values, this will include 1\n+     * extra decision variable to represent the absolute value of the most\n+     * negative variable.\n+     * </p>\n+     * @return number of decision variables\n+     * @see #getOriginalNumDecisionVariables()\n+     */\n+    protected final int getNumDecisionVariables() {\n+        return numDecisionVariables;\n+    }\n+\n+    /**\n+     * Get the original number of decision variables.\n+     * @return original number of decision variables\n+     * @see #getNumDecisionVariables()\n+     */\n+    protected final int getOriginalNumDecisionVariables() {\n+        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n+    }\n+\n+    /**\n+     * Get the number of slack variables.\n+     * @return number of slack variables\n+     */\n+    protected final int getNumSlackVariables() {\n+        return numSlackVariables;\n+    }\n+\n+    /**\n+     * Get the number of artificial variables.\n+     * @return number of artificial variables\n+     */\n+    protected final int getNumArtificialVariables() {\n+        return numArtificialVariables;\n+    }\n+\n+    /**\n+     * Get the tableau data.\n+     * @return tableau data\n+     */\n+    protected final double[][] getData() {\n+        return tableau.getData();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/**\n+ * This class represents exceptions thrown by optimizers when a solution\n+ * escapes to infinity.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class UnboundedSolutionException extends OptimizationException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 940539497277290619L;\n+\n+    /** \n+     * Simple constructor using a default message.\n+     */\n+    public UnboundedSolutionException() {\n+        super(\"unbounded solution\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+public class SimplexSolverTest extends TestCase {\n+\n+    public void testSimplexSolver() throws OptimizationException {\n+\n+        LinearObjectiveFunction f =\n+            new LinearObjectiveFunction(new double[] { 15, 10 }, 7);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(2.0, solution.getPoint()[0]);\n+        assertEquals(2.0, solution.getPoint()[1]);\n+        assertEquals(57.0, solution.getValue());\n+    }\n+\n+    /**\n+     * With no artificial variables needed (no equals and no greater than\n+     * constraints) we can go straight to Phase 2.\n+     */\n+    public void testModelWithNoArtificialVars() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(2.0, solution.getPoint()[0]);\n+        assertEquals(2.0, solution.getPoint()[1]);\n+        assertEquals(50.0, solution.getValue());\n+    }\n+\n+    public void testMinimization() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));\n+        constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        assertEquals(4.0, solution.getPoint()[0]);\n+        assertEquals(0.0, solution.getPoint()[1]);\n+        assertEquals(-13.0, solution.getValue());\n+    }\n+\n+    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));\n+        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+        assertEquals(-2.0, solution.getPoint()[0]);\n+        assertEquals(8.0, solution.getPoint()[1]);\n+        assertEquals(12.0, solution.getValue());\n+    }\n+\n+    public void testInfeasibleSolution() throws UnboundedSolutionException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));\n+        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        try {\n+            solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+            fail(\"An exception should have been thrown.\");\n+        } catch (NoFeasibleSolutionException e) {\n+            // expected;\n+        } catch (OptimizationException e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testUnboundedSolution() throws NoFeasibleSolutionException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        try {\n+            solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n+            fail(\"An exception should have been thrown.\");\n+        } catch (UnboundedSolutionException e) {\n+            // expected;\n+        } catch (OptimizationException e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testRestrictVariablesToNonNegative() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));\n+        constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));\n+        constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));\n+        constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));\n+        constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);\n+        assertEquals(480.419243986254, solution.getPoint()[1], .0000001);\n+        assertEquals(0.0, solution.getPoint()[2], .0000001);\n+        assertEquals(0.0, solution.getPoint()[3], .0000001);\n+        assertEquals(0.0, solution.getPoint()[4], .0000001);\n+        assertEquals(1438556.7491409, solution.getValue(), .0000001);\n+    }\n+\n+    public void testSomething() throws OptimizationException {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+        assertEquals(0, solution.getValue(), .0000001);\n+    }\n+\n+    public void testLargeModel() throws OptimizationException {\n+        double[] objective = new double[] {\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           12, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 12, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 12, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 12, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+                                           1, 1, 1, 1, 1, 1};\n+\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(equationFromString(objective.length, \"x0 + x1 + x2 + x3 - x12 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x0 + x1 + x2 + x3 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x14 + x15 + x16 + x17 - x26 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x14 + x15 + x16 + x17 - x12 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x28 + x29 + x30 + x31 - x40 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x28 + x29 + x30 + x31 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x42 + x43 + x44 + x45 - x54 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x42 + x43 + x44 + x45 - x40 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x56 + x57 + x58 + x59 - x68 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51\"));\n+        constraints.add(equationFromString(objective.length, \"x56 + x57 + x58 + x59 >= 44\"));\n+        constraints.add(equationFromString(objective.length, \"x70 + x71 + x72 + x73 - x82 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x70 + x71 + x72 + x73 - x68 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x84 + x85 + x86 + x87 - x96 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51\"));\n+        constraints.add(equationFromString(objective.length, \"x84 + x85 + x86 + x87 >= 44\"));\n+        constraints.add(equationFromString(objective.length, \"x98 + x99 + x100 + x101 - x110 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x98 + x99 + x100 + x101 - x96 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x112 + x113 + x114 + x115 - x124 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49\"));\n+        constraints.add(equationFromString(objective.length, \"x112 + x113 + x114 + x115 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x126 + x127 + x128 + x129 - x138 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x126 + x127 + x128 + x129 - x124 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x140 + x141 + x142 + x143 - x152 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59\"));\n+        constraints.add(equationFromString(objective.length, \"x140 + x141 + x142 + x143 >= 42\"));\n+        constraints.add(equationFromString(objective.length, \"x154 + x155 + x156 + x157 - x166 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x154 + x155 + x156 + x157 - x152 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x83 + x82 - x168 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x111 + x110 - x169 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x170 - x182 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x171 - x183 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x172 - x184 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x173 - x185 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x174 - x186 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x175 + x176 - x187 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x177 - x188 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x178 - x189 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x179 - x190 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x180 - x191 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x181 - x192 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x170 - x26 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x171 - x27 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x172 - x54 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x173 - x55 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x174 - x168 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x177 - x169 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x178 - x138 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x179 - x139 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x180 - x166 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x181 - x167 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x193 - x205 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x194 - x206 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x195 - x207 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x196 - x208 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x197 - x209 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x198 + x199 - x210 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x200 - x211 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x201 - x212 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x202 - x213 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x203 - x214 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x204 - x215 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x193 - x182 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x194 - x183 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x195 - x184 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x196 - x185 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x197 - x186 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x198 + x199 - x187 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x200 - x188 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x201 - x189 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x202 - x190 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x203 - x191 = 0\"));\n+        constraints.add(equationFromString(objective.length, \"x204 - x192 = 0\"));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+        assertEquals(13366.0, solution.getValue(), .0000001);\n+        //assertEquals(7518.0, solution.getValue(), .0000001);\n+    }\n+    \n+    /**\n+     * Converts a test string to a {@link LinearConstraint}.\n+     * Ex: x0 + x1 + x2 + x3 - x12 = 0\n+     */\n+    private LinearConstraint equationFromString(int numCoefficients, String s) {\n+        Relationship relationship;\n+        if (s.contains(\">=\")) {\n+            relationship = Relationship.GEQ;\n+        } else if (s.contains(\"<=\")) {\n+            relationship = Relationship.LEQ;\n+        } else if (s.contains(\"=\")) {\n+            relationship = Relationship.EQ;\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        String[] equationParts = s.split(\"[>|<]?=\");\n+        double rhs = Double.parseDouble(equationParts[1].trim());\n+\n+        RealVector lhs = new RealVectorImpl(numCoefficients);\n+        String left = equationParts[0].replaceAll(\" ?x\", \"\");\n+        String[] coefficients = left.split(\" \");\n+        for (String coefficient : coefficients) {\n+            double value = coefficient.charAt(0) == '-' ? -1 : 1;\n+            int index = Integer.parseInt(coefficient.replaceFirst(\"[+|-]\", \"\").trim());\n+            lhs.setEntry(index, value);\n+        }\n+        return new LinearConstraint(lhs, relationship, rhs);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.optimization.GoalType;\n+\n+import junit.framework.TestCase;\n+\n+public class SimplexTableauTest extends TestCase {\n+\n+    public void testInitialization() {    \n+        LinearObjectiveFunction f = createFunction();\n+        Collection<LinearConstraint> constraints = createConstraints();\n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false);\n+        double[][] expectedInitialTableau = {\n+                                             {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},\n+                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},\n+                                             { 0, 0,   1,   0, -1, 1, 0, 0,  2},\n+                                             { 0, 0,   0,   1, -1, 0, 1, 0,  3},\n+                                             { 0, 0,   1,   1, -2, 0, 0, 1,  4}\n+        };\n+        assertMatrixEquals(expectedInitialTableau, tableau.getData());\n+    }\n+\n+    public void testdiscardArtificialVariables() {    \n+        LinearObjectiveFunction f = createFunction();\n+        Collection<LinearConstraint> constraints = createConstraints();\n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false);\n+        double[][] expectedTableau = {\n+                                      { 1, -15, -10, 25, 0, 0, 0},\n+                                      { 0,   1,   0, -1, 1, 0, 2},\n+                                      { 0,   0,   1, -1, 0, 1, 3},\n+                                      { 0,   1,   1, -2, 0, 0, 4}\n+        };\n+        tableau.discardArtificialVariables();\n+        assertMatrixEquals(expectedTableau, tableau.getData());\n+    }\n+\n+    public void testTableauWithNoArtificialVars() {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));    \n+        SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false);\n+        double[][] initialTableau = {\n+                                     {1, -15, -10, 25, 0, 0, 0, 0},\n+                                     {0,   1,   0, -1, 1, 0, 0, 2},\n+                                     {0,   0,   1, -1, 0, 1, 0, 3},\n+                                     {0,   1,   1, -2, 0, 0, 1, 4}\n+        };\n+        assertMatrixEquals(initialTableau, tableau.getData());\n+    }\n+\n+    private LinearObjectiveFunction createFunction() {\n+        return new LinearObjectiveFunction(new double[] {15, 10}, 0);\n+    }\n+\n+    private Collection<LinearConstraint> createConstraints() {\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));\n+        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));\n+        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));\n+        return constraints;\n+    }\n+\n+    private void assertMatrixEquals(double[][] expected, double[][] result) {\n+        assertEquals(\"Wrong number of rows.\", expected.length, result.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals(\"Wrong number of columns.\", expected[i].length, result[i].length);\n+            for (int j = 0; j < expected[i].length; j++) {\n+                assertEquals(\"Wrong value at position [\" + i + \",\" + j + \"]\", expected[i][j], result[i][j]);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1238109930, "metainfo": ""}