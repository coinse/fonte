{"sha": "a42399673c48809aeb860f7187ee996b250c30b7", "log": "Some changes to the interface of iterative linear solvers. Replaced the confusing boolean param inPlace in the solve() methods by two sets of methods: solve() and solveInPlace().  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n  * <dt><a id=\"BARR1994\">Barret et al. (1994)</a></dt>\n  * <dd>R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. M. Donato, J. Dongarra,\n  * V. Eijkhout, R. Pozo, C. Romine and H. Van der Vorst,\n- * <em>Templates for the Solution of Linear Systems: Building Blocks for\n- * Iterative Methods</em>, SIAM</dd>\n+ * <a href=\"http://www.netlib.org/linalg/html_templates/Templates.html\"><em>\n+ * Templates for the Solution of Linear Systems: Building Blocks for Iterative\n+ * Methods</em></a>, SIAM</dd>\n  * <dt><a id=\"STRA2002\">Strakos and Tichy (2002)\n  * <dt>\n  * <dd>Z. Strakos and P. Tichy, <a\n      * The type of all events fired by this implementation of the Conjugate\n      * Gradient method.\n      *\n-     * @version $Id$\n+     * @version $Id: ConjugateGradient.java 1175404 2011-09-25 14:48:18Z\n+     * celestin $\n      */\n     public abstract static class ConjugateGradientEvent\n         extends IterativeLinearSolverEvent\n          * Creates a new instance of this class.\n          *\n          * @param source The iterative algorithm on which the event initially\n-         *        occurred.\n+         * occurred.\n          */\n         public ConjugateGradientEvent(final Object source) {\n             super(source);\n      * @param maxIterations Maximum number of iterations.\n      * @param delta &delta; parameter for the default stopping criterion.\n      * @param check {@code true} if positive definiteness of both matrix and\n-     *        preconditioner should be checked.\n+     * preconditioner should be checked.\n      */\n     public ConjugateGradient(final int maxIterations, final double delta,\n                              final boolean check) {\n      * @param manager Custom iteration manager.\n      * @param delta &delta; parameter for the default stopping criterion.\n      * @param check {@code true} if positive definiteness of both matrix and\n-     *        preconditioner should be checked.\n+     * preconditioner should be checked.\n      */\n     public ConjugateGradient(final IterationManager manager,\n                              final double delta, final boolean check) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector solve(final RealLinearOperator a,\n-                            final InvertibleRealLinearOperator m,\n-                            final RealVector b, final RealVector x0,\n-                            final boolean inPlace)\n+    public RealVector solveInPlace(final RealLinearOperator a,\n+                                   final InvertibleRealLinearOperator m,\n+                                   final RealVector b, final RealVector x0)\n         throws NullArgumentException, NonSquareLinearOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n-        checkParameters(a, m, b, x0, inPlace);\n+        checkParameters(a, m, b, x0);\n         final IterationManager manager = getIterationManager();\n         // Initialization of default stopping criterion\n         manager.resetIterationCount();\n         // p and x are constructed as copies of x0, since presumably, the type\n         // of x is optimized for the calculation of the matrix-vector product\n         // A.x.\n-        final RealVector x;\n-        if (inPlace) {\n-            x = x0;\n-        } else {\n-            if (x0 != null) {\n-                x = x0.copy();\n-            } else {\n-                x = new ArrayRealVector(a.getColumnDimension());\n-            }\n-        }\n+        final RealVector x = x0;\n         final RealVector p = x.copy();\n         RealVector q = a.operate(p);\n         manager.incrementIterationCount();\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolver.java\n      * Creates a new instance of this class, with custom iteration manager.\n      *\n      * @param manager Custom iteration manager.\n+     * @throws NullArgumentException if {@code manager} is {@code null}.\n      */\n-    public IterativeLinearSolver(final IterationManager manager) {\n+    public IterativeLinearSolver(final IterationManager manager)\n+        throws NullArgumentException {\n         MathUtils.checkNotNull(manager);\n         this.manager = manager;\n     }\n+\n     /**\n      * Performs all dimension checks on the parameters of\n-     * {@link #solve(RealLinearOperator, RealVector, RealVector, boolean)}, and\n-     * throws an exception if one of the checks fails.\n+     * {@link #solve(RealLinearOperator, RealVector, RealVector) solve} and\n+     * {@link #solveInPlace(RealLinearOperator, RealVector, RealVector) solveInPlace},\n+     * and throws an exception if one of the checks fails.\n      *\n      * @param a Linear operator A of the system.\n      * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution (can be {@code null} if\n-     *        {@code inPlace} is set to {@code false}).\n-     * @param inPlace {@code true} if the initial guess is to be updated with\n-     *        the current estimate of the solution.\n+     * @param x0 Initial guess of the solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.\n      * @throws NonSquareLinearOperatorException if {@code a} is not square.\n      * @throws DimensionMismatchException if {@code b} or {@code x0} have\n-     *         dimensions inconsistent with {@code a}.\n+     * dimensions inconsistent with {@code a}.\n      */\n     protected static void checkParameters(final RealLinearOperator a,\n                                           final RealVector b,\n-                                          final RealVector x0,\n-                                          final boolean inPlace)\n+                                          final RealVector x0)\n         throws NullArgumentException, NonSquareLinearOperatorException,\n         DimensionMismatchException {\n         MathUtils.checkNotNull(a);\n         MathUtils.checkNotNull(b);\n+        MathUtils.checkNotNull(x0);\n         if (a.getRowDimension() != a.getColumnDimension()) {\n             throw new NonSquareLinearOperatorException(a.getRowDimension(),\n                                                        a.getColumnDimension());\n             throw new DimensionMismatchException(b.getDimension(),\n                                                  a.getRowDimension());\n         }\n-        if (inPlace) {\n-            MathUtils.checkNotNull(x0);\n-        }\n-        if ((x0 != null) && (x0.getDimension() != a.getColumnDimension())) {\n+        if (x0.getDimension() != a.getColumnDimension()) {\n             throw new DimensionMismatchException(x0.getDimension(),\n                                                  a.getColumnDimension());\n         }\n \n     /**\n      * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b. If no initial estimate of the solution is provided, (0, &hellip;, 0)\n-     * is assumed.\n+     * b.\n      *\n      * @param a Linear operator A of the system.\n      * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution (can be {@code null} if\n-     *        {@code inPlace} is set to {@code false}).\n-     * @param inPlace {@code true} if the initial guess is to be updated with\n-     *        the current estimate of the solution.\n-     * @return A reference to {@code x0} (shallow copy) if {@code inPlace} was\n-     *         set to {@code true}. Otherwise, a new vector containing the\n-     *         solution.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} has dimensions\n+     * inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solve(RealLinearOperator a, RealVector b)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        x.set(0.);\n+        return solveInPlace(a, b, x);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution.\n+     * @return A new vector containing the solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.\n      * @throws NonSquareLinearOperatorException if {@code a} is not square.\n      * @throws DimensionMismatchException if {@code b} or {@code x0} have\n-     *         dimensions inconsistent with {@code a}.\n+     * dimensions inconsistent with {@code a}.\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     *         unless a custom {@link MaxCountExceededCallback callback} has\n-     *         been set at construction.\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n      */\n-    public abstract RealVector solve(RealLinearOperator a, RealVector b,\n-                                     RealVector x0, boolean inPlace)\n+    public RealVector solve(RealLinearOperator a, RealVector b, RealVector x0)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(x0);\n+        return solveInPlace(a, b, x0.copy());\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. The solution is computed in-place (initial guess is modified).\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution.\n+     * @return A reference to {@code x0} (shallow copy) updated with the\n+     * solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} or {@code x0} have\n+     * dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public abstract RealVector solveInPlace(RealLinearOperator a, RealVector b,\n+                                            RealVector x0)\n         throws NullArgumentException, NonSquareLinearOperatorException,\n         DimensionMismatchException, MaxCountExceededException;\n }\n--- a/src/main/java/org/apache/commons/math/linear/PreconditionedIterativeLinearSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/PreconditionedIterativeLinearSolver.java\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.IterationManager;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * This abstract class defines preconditioned iterative solvers. When A is\n      * Creates a new instance of this class, with custom iteration manager.\n      *\n      * @param manager Custom iteration manager.\n-     */\n-    public PreconditionedIterativeLinearSolver(final IterationManager manager) {\n+     * @throws NullArgumentException if {@code manager} is {@code null}.\n+     */\n+    public PreconditionedIterativeLinearSolver(final IterationManager manager)\n+        throws NullArgumentException {\n         super(manager);\n     }\n \n     /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solve(final RealLinearOperator a,\n+                            final InvertibleRealLinearOperator m,\n+                            final RealVector b, final RealVector x0)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(x0);\n+        return solveInPlace(a, m, b, x0.copy());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a, final RealVector b)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        x.set(0.);\n+        return solveInPlace(a, null, b, x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a, final RealVector b,\n+                            final RealVector x0)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(x0);\n+        return solveInPlace(a, null, b, x0.copy());\n+    }\n+\n+    /**\n      * Performs all dimension checks on the parameters of\n-     * {@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector, boolean)}\n+     * {@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector) solve}\n+     * and\n+     * {@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector) solveInPlace}\n      * , and throws an exception if one of the checks fails.\n      *\n      * @param a Linear operator A of the system.\n      * @param m Preconditioner (can be {@code null}).\n      * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution (can be {@code null} if\n-     *        {@code inPlace} is set to {@code false}).\n-     * @param inPlace {@code true} if the initial guess is to be updated with\n-     *        the current estimate of the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n-     *         square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     *         have dimensions inconsistent with {@code a}.\n+     * @param x0 Initial guess of the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n+     * have dimensions inconsistent with {@code a}.\n      */\n     protected static void checkParameters(final RealLinearOperator a,\n                                           final InvertibleRealLinearOperator m,\n                                           final RealVector b,\n-                                          final RealVector x0,\n-                                          final boolean inPlace)\n+                                          final RealVector x0)\n         throws NullArgumentException, NonSquareLinearOperatorException,\n         DimensionMismatchException {\n-        checkParameters(a, b, x0, inPlace);\n+        checkParameters(a, b, x0);\n         if (m != null) {\n             if (m.getColumnDimension() != m.getRowDimension()) {\n-                throw new NonSquareLinearOperatorException(\n-                                                           m.getColumnDimension(),\n+                throw new NonSquareLinearOperatorException(m.getColumnDimension(),\n                                                            m.getRowDimension());\n             }\n             if (m.getRowDimension() != a.getRowDimension()) {\n \n     /**\n      * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b. If no initial estimate of the solution is provided, (0, &hellip;, 0)\n-     * is assumed.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution (can be {@code null} if\n-     *        {@code inPlace} is set to {@code false}).\n-     * @param inPlace {@code true} if the initial guess is to be updated with\n-     *        the current estimate of the solution.\n-     * @return A reference to {@code x0} (shallow copy) if {@code update} was\n-     *         set to {@code true}. Otherwise, a new vector containing the\n-     *         solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n-     *         square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     *         have dimensions inconsistent with {@code a}.\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m} or {@code b} have\n+     * dimensions inconsistent with {@code a}.\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     *         unless a custom {@link MaxCountExceededCallback callback} has\n-     *         been set at construction.\n-     */\n-    public abstract RealVector solve(RealLinearOperator a,\n-                                     InvertibleRealLinearOperator m,\n-                                     RealVector b, RealVector x0,\n-                                     final boolean inPlace)\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solve(RealLinearOperator a,\n+                            InvertibleRealLinearOperator m, RealVector b)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        return solveInPlace(a, m, b, x);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. The solution is computed in-place (initial guess is modified).\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution.\n+     * @return A reference to {@code x0} (shallow copy) updated with the\n+     * solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public abstract RealVector solveInPlace(RealLinearOperator a,\n+                                            InvertibleRealLinearOperator m,\n+                                            RealVector b, RealVector x0)\n         throws NullArgumentException, NonSquareLinearOperatorException,\n         DimensionMismatchException, MaxCountExceededException;\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector solve(final RealLinearOperator a, final RealVector b,\n-                            final RealVector x0, final boolean inPlace)\n-        throws NullArgumentException, NonSquareLinearOperatorException,\n-        DimensionMismatchException, MaxCountExceededException {\n-        checkParameters(a, b, x0, inPlace);\n-        return solve(a, null, b, x0, inPlace);\n+    public RealVector solveInPlace(final RealLinearOperator a,\n+                                   final RealVector b, final RealVector x0)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        return solveInPlace(a, null, b, x0);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n         solver = new ConjugateGradient(10, 0., false);\n         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n         final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());\n-        solver.solve(a, b, x, false);\n+        solver.solve(a, b, x);\n     }\n \n     @Test(expected = DimensionMismatchException.class)\n         solver = new ConjugateGradient(10, 0., false);\n         final ArrayRealVector b = new ArrayRealVector(2);\n         final ArrayRealVector x = new ArrayRealVector(3);\n-        solver.solve(a, b, x, false);\n+        solver.solve(a, b, x);\n     }\n \n     @Test(expected = DimensionMismatchException.class)\n         solver = new ConjugateGradient(10, 0., false);\n         final ArrayRealVector b = new ArrayRealVector(3);\n         final ArrayRealVector x = new ArrayRealVector(2);\n-        solver.solve(a, b, x, false);\n+        solver.solve(a, b, x);\n     }\n \n     @Test(expected = NonPositiveDefiniteLinearOperatorException.class)\n         b.setEntry(0, -1.);\n         b.setEntry(1, -1.);\n         final ArrayRealVector x = new ArrayRealVector(2);\n-        solver.solve(a, b, x, false);\n+        solver.solve(a, b, x);\n     }\n \n     @Test\n         for (int j = 0; j < n; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            final RealVector x = solver.solve(a, b, null, false);\n+            final RealVector x = solver.solve(a, b);\n             for (int i = 0; i < n; i++) {\n                 final double actual = x.getEntry(i);\n                 final double expected = ainv.getEntry(i, j);\n             b.setEntry(j, 1.);\n             final RealVector x0 = new ArrayRealVector(n);\n             x0.set(1.);\n-            final RealVector x = solver.solve(a, b, x0, true);\n+            final RealVector x = solver.solveInPlace(a, b, x0);\n             Assert.assertSame(\"x should be a reference to x0\", x0, x);\n             for (int i = 0; i < n; i++) {\n                 final double actual = x.getEntry(i);\n             b.setEntry(j, 1.);\n             final RealVector x0 = new ArrayRealVector(n);\n             x0.set(1.);\n-            final RealVector x = solver.solve(a, b, x0, false);\n+            final RealVector x = solver.solve(a, b, x0);\n             Assert.assertNotSame(\"x should not be a reference to x0\", x0, x);\n             for (int i = 0; i < n; i++) {\n                 final double actual = x.getEntry(i);\n             b.set(0.);\n             b.setEntry(j, 1.);\n \n-            final RealVector x = solver.solve(a, b, null, false);\n+            final RealVector x = solver.solve(a, b);\n             final RealVector y = a.operate(x);\n             for (int i = 0; i < n; i++) {\n                 final double actual = b.getEntry(i) - y.getEntry(i);\n         final PreconditionedIterativeLinearSolver solver;\n         solver = new ConjugateGradient(10, 0d, false);\n         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n-        solver.solve(a, m, b, null, false);\n+        solver.solve(a, m, b);\n     }\n \n     @Test(expected = DimensionMismatchException.class)\n         final PreconditionedIterativeLinearSolver solver;\n         solver = new ConjugateGradient(10, 0d, false);\n         final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n-        solver.solve(a, m, b, null, false);\n+        solver.solve(a, m, b);\n     }\n \n     @Test(expected = NonPositiveDefiniteLinearOperatorException.class)\n         final ArrayRealVector b = new ArrayRealVector(2);\n         b.setEntry(0, -1d);\n         b.setEntry(1, -1d);\n-        solver.solve(a, m, b, null, false);\n+        solver.solve(a, m, b);\n     }\n \n     @Test\n         for (int j = 0; j < n; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            final RealVector x = solver.solve(a, m, b, null, false);\n+            final RealVector x = solver.solve(a, m, b);\n             for (int i = 0; i < n; i++) {\n                 final double actual = x.getEntry(i);\n                 final double expected = ainv.getEntry(i, j);\n         for (int j = 0; j < n; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            final RealVector x = solver.solve(a, m, b, null, false);\n+            final RealVector x = solver.solve(a, m, b);\n             final RealVector y = a.operate(x);\n             double rnorm = 0.;\n             for (int i = 0; i < n; i++) {\n         for (int j = 0; j < 1; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            final RealVector px = pcg.solve(a, m, b, null, false);\n-            final RealVector x = cg.solve(a, b, null, false);\n+            final RealVector px = pcg.solve(a, m, b);\n+            final RealVector x = cg.solve(a, b);\n             final int npcg = pcg.getIterationManager().getIterations();\n             final int ncg = cg.getIterationManager().getIterations();\n             msg = String.format(pattern, npcg, ncg);\n         for (int j = 0; j < n; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            solver.solve(a, b, null, false);\n+            solver.solve(a, b);\n             String msg = String.format(\"column %d (initialization)\", j);\n             Assert.assertEquals(msg, 1, count[0]);\n             msg = String.format(\"column %d (iterations started)\", j);", "timestamp": 1317496140, "metainfo": ""}