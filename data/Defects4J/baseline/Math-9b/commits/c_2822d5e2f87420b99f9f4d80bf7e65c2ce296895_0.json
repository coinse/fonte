{"sha": "2822d5e2f87420b99f9f4d80bf7e65c2ce296895", "log": "Javadoc fixes  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n      *\n      * Always returns {@code false}.\n      *\n-     * @see {@link PascalDistribution#getSupportUpperBound() getSupportUpperBound()}\n+     * @see PascalDistribution#getSupportUpperBound() getSupportUpperBound()\n      */\n     @Override\n     public boolean isSupportUpperBoundInclusive() {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractSimpleBoundsScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractSimpleBoundsScalarOptimizer.java\n      * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker} and\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      *\n-     * @see BaseAbstractScalarOptimizer#BaseAbstractScalarOptimizer().\n+     * @see BaseAbstractScalarOptimizer#BaseAbstractScalarOptimizer()\n      */\n     protected BaseAbstractSimpleBoundsScalarOptimizer() {}\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapter.java\n     }\n \n     /** Map an array from unbounded to bounded.\n-     * @param x unbounded value\n+     * @param point unbounded value\n      * @return bounded value\n      */\n     public double[] unboundedToBounded(double[] point) {\n \n     }\n \n-    /** Map an array from bounded to unbounded.\n-     * @param y bounded value\n+    /** \n+     * Map an array from bounded to unbounded.\n+     * @param point bounded value\n      * @return unbounded value\n      */\n     public double[] boundedToUnbounded(double[] point) {\n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n      * <code>Double.NaN</code> if the array is empty.\n      *\n      * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n-     * the denominator).  Use {@link #populationVariance()} for the non-bias-corrected\n+     * the denominator).  Use {@link #populationVariance(double[])} for the non-bias-corrected\n      * population variance.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * is empty.\n      *\n      * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n-     * the denominator).  Use {@link #populationVariance()} for the non-bias-corrected\n+     * the denominator).  Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected\n      * population variance.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * <code>Double.NaN</code> if the designated subarray is empty.\n      *\n      * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n-     * the denominator).  Use {@link #populationVariance()} for the non-bias-corrected\n+     * the denominator).  Use {@link #populationVariance(double[], double, int, int)} for the non-bias-corrected\n      * population variance.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * is empty.\n      *\n      * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n-     * the denominator).  Use {@link #populationVariance()} for the non-bias-corrected\n+     * the denominator).  Use {@link #populationVariance(double[], double)} for the non-bias-corrected\n      * population variance.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for", "timestamp": 1322359867, "metainfo": ""}