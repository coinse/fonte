{"sha": "a3200e5d80add4a81f716bf5ba8155ef378de18a", "log": "Fixed k-means++ to add several strategies to deal with empty clusters that may appear during iterations JIRA: MATH-429  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/ConvergenceException.java\n+++ b/src/main/java/org/apache/commons/math/exception/ConvergenceException.java\n  * Error thrown when a numerical computation can not be performed because the\n  * numerical result failed to converge to a finite value.\n  *\n- * @since 3.0\n+ * @since 2.2\n  * @version $Revision$ $Date$\n  */\n public class ConvergenceException extends MathIllegalStateException {\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n  * Base class for all exceptions that signal a mismatch between the\n  * current state and the user's expectations.\n  *\n- * @since 3.0\n+ * @since 2.2\n  * @version $Revision$ $Date$\n  */\n public class MathIllegalStateException extends IllegalStateException {\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n     DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n     DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n+    EMPTY_CLUSTER_IN_K_MEANS(\"empty cluster in k-means\"),\n     EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"), /* keep */\n     EMPTY_SELECTED_COLUMN_INDEX_ARRAY(\"empty selected column index array\"),\n     EMPTY_SELECTED_ROW_INDEX_ARRAY(\"empty selected row index array\"),\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n import java.util.List;\n import java.util.Random;\n \n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+\n /**\n  * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.\n  * @param <T> type of the points to cluster\n  */\n public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n \n+    /** Strategies to use for replacing an empty cluster. */\n+    public static enum EmptyClusterStrategy {\n+\n+        /** Split the cluster with largest distance variance. */\n+        LARGEST_VARIANCE,\n+\n+        /** Split the cluster with largest number of points. */\n+        LARGEST_POINTS_NUMBER,\n+\n+        /** Create a cluster around the point farthest from its centroid. */\n+        FARTHEST_POINT,\n+\n+        /** Generate an error. */\n+        ERROR\n+\n+    }\n+\n     /** Random generator for choosing initial centers. */\n     private final Random random;\n \n+    /** Selected strategy for empty clusters. */\n+    private final EmptyClusterStrategy emptyStrategy;\n+\n+    /** Build a clusterer.\n+     * <p>\n+     * The default strategy for handling empty clusters that may appear during\n+     * algorithm iterations is to split the cluster with largest distance variance.\n+     * </p>\n+     * @param random random generator to use for choosing initial centers\n+     */\n+    public KMeansPlusPlusClusterer(final Random random) {\n+        this(random, EmptyClusterStrategy.LARGEST_VARIANCE);\n+    }\n+\n     /** Build a clusterer.\n      * @param random random generator to use for choosing initial centers\n-     */\n-    public KMeansPlusPlusClusterer(final Random random) {\n-        this.random = random;\n+     * @param emptyStrategy strategy to use for handling empty clusters that\n+     * may appear during algorithm iterations\n+     * @since 2.2\n+     */\n+    public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy emptyStrategy) {\n+        this.random        = random;\n+        this.emptyStrategy = emptyStrategy;\n     }\n \n     /**\n             boolean clusteringChanged = false;\n             List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n             for (final Cluster<T> cluster : clusters) {\n-                final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n-                if (!newCenter.equals(cluster.getCenter())) {\n+                final T newCenter;\n+                if (cluster.getPoints().isEmpty()) {\n+                    switch (emptyStrategy) {\n+                        case LARGEST_VARIANCE :\n+                            newCenter = getPointFromLargestVarianceCluster(clusters);\n+                            break;\n+                        case LARGEST_POINTS_NUMBER :\n+                            newCenter = getPointFromLargestNumberCluster(clusters);\n+                            break;\n+                        case FARTHEST_POINT :\n+                            newCenter = getFarthestPoint(clusters);\n+                            break;\n+                        default :\n+                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+                    }\n                     clusteringChanged = true;\n+                } else {\n+                    newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n+                    if (!newCenter.equals(cluster.getCenter())) {\n+                        clusteringChanged = true;\n+                    }\n                 }\n                 newClusters.add(new Cluster<T>(newCenter));\n             }\n     }\n \n     /**\n+     * Get a random point from the {@link Cluster} with the largest distance variance.\n+     *\n+     * @param <T> type of the points to cluster\n+     * @param clusters the {@link Cluster}s to search\n+     * @return a random point from the selected cluster\n+     */\n+    private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters) {\n+\n+        double maxVariance = Double.NEGATIVE_INFINITY;\n+        Cluster<T> selected = null;\n+        for (final Cluster<T> cluster : clusters) {\n+            if (!cluster.getPoints().isEmpty()) {\n+\n+                // compute the distance variance of the current cluster\n+                final T center = cluster.getCenter();\n+                final Variance stat = new Variance();\n+                for (final T point : cluster.getPoints()) {\n+                    stat.increment(point.distanceFrom(center));\n+                }\n+                final double variance = stat.getResult();\n+\n+                // select the cluster with the largest variance\n+                if (variance > maxVariance) {\n+                    maxVariance = variance;\n+                    selected = cluster;\n+                }\n+\n+            }\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selected == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        // extract a random point from the cluster\n+        final List<T> selectedPoints = selected.getPoints();\n+        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n+\n+    }\n+\n+    /**\n+     * Get a random point from the {@link Cluster} with the largest number of points\n+     *\n+     * @param <T> type of the points to cluster\n+     * @param clusters the {@link Cluster}s to search\n+     * @return a random point from the selected cluster\n+     */\n+    private T getPointFromLargestNumberCluster(final Collection<Cluster<T>> clusters) {\n+\n+        int maxNumber = 0;\n+        Cluster<T> selected = null;\n+        for (final Cluster<T> cluster : clusters) {\n+\n+            // get the number of points of the current cluster\n+            final int number = cluster.getPoints().size();\n+\n+            // select the cluster with the largest number of points\n+            if (number > maxNumber) {\n+                maxNumber = number;\n+                selected = cluster;\n+            }\n+\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selected == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        // extract a random point from the cluster\n+        final List<T> selectedPoints = selected.getPoints();\n+        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n+\n+    }\n+\n+    /**\n+     * Get the point farthest to its cluster center\n+     *\n+     * @param <T> type of the points to cluster\n+     * @param clusters the {@link Cluster}s to search\n+     * @return point farthest to its cluster center\n+     */\n+    private T getFarthestPoint(final Collection<Cluster<T>> clusters) {\n+\n+        double maxDistance = Double.NEGATIVE_INFINITY;\n+        Cluster<T> selectedCluster = null;\n+        int selectedPoint = -1;\n+        for (final Cluster<T> cluster : clusters) {\n+\n+            // get the farthest point\n+            final T center = cluster.getCenter();\n+            final List<T> points = cluster.getPoints();\n+            for (int i = 0; i < points.size(); ++i) {\n+                final double distance = points.get(i).distanceFrom(center);\n+                if (distance > maxDistance) {\n+                    maxDistance     = distance;\n+                    selectedCluster = cluster;\n+                    selectedPoint   = i;\n+                }\n+            }\n+\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selectedCluster == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        return selectedCluster.getPoints().remove(selectedPoint);\n+\n+    }\n+\n+    /**\n      * Returns the nearest {@link Cluster} to the given point\n      *\n      * @param <T> type of the points to cluster\n--- a/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n import java.util.List;\n import java.util.Random;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n public class KMeansPlusPlusClustererTest {\n \n     }\n \n+    @Test\n+    public void testCertainSpace() {\n+        KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = {\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE,\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER,\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT\n+        };\n+        for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) {\n+            KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =\n+                new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l), strategy);\n+            int numberOfVariables = 27;\n+            // initialise testvalues\n+            int position1 = 1;\n+            int position2 = position1 + numberOfVariables;\n+            int position3 = position2 + numberOfVariables;\n+            int position4 = position3 + numberOfVariables;\n+            // testvalues will be multiplied\n+            int multiplier = 1000000;\n+\n+            EuclideanIntegerPoint[] breakingPoints = new EuclideanIntegerPoint[numberOfVariables];\n+            // define the space which will break the cluster algorithm\n+            for (int i = 0; i < numberOfVariables; i++) {\n+                int points[] = { position1, position2, position3, position4 };\n+                // multiply the values\n+                for (int j = 0; j < points.length; j++) {\n+                    points[j] = points[j] * multiplier;\n+                }\n+                EuclideanIntegerPoint euclideanIntegerPoint = new EuclideanIntegerPoint(points);\n+                breakingPoints[i] = euclideanIntegerPoint;\n+                position1 = position1 + numberOfVariables;\n+                position2 = position2 + numberOfVariables;\n+                position3 = position3 + numberOfVariables;\n+                position4 = position4 + numberOfVariables;\n+            }\n+\n+            for (int n = 2; n < 27; ++n) {\n+                List<Cluster<EuclideanIntegerPoint>> clusters =\n+                    transformer.cluster(Arrays.asList(breakingPoints), n, 100);\n+                Assert.assertEquals(n, clusters.size());\n+                int sum = 0;\n+                for (Cluster<EuclideanIntegerPoint> cluster : clusters) {\n+                    sum += cluster.getPoints().size();\n+                }\n+                Assert.assertEquals(numberOfVariables, sum);\n+            }\n+        }\n+\n+    }\n+\n }", "timestamp": 1287862279, "metainfo": ""}