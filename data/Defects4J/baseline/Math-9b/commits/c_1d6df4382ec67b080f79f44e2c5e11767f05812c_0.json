{"sha": "1d6df4382ec67b080f79f44e2c5e11767f05812c", "log": "completely rewrote estimation package documentation with downloadable example and explanation diagrams  ", "commit": "\n--- /dev/null\n+++ b/src/site/resources/userguide/TrajectoryDeterminationProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.commons.math.estimation.EstimationException;\n+import org.apache.commons.math.estimation.EstimatedParameter;\n+import org.apache.commons.math.estimation.EstimationProblem;\n+import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;\n+import org.apache.commons.math.estimation.SimpleEstimationProblem;\n+import org.apache.commons.math.estimation.WeightedMeasurement;\n+\n+public class TrajectoryDeterminationProblem extends SimpleEstimationProblem {\n+\n+    public static void main(String[] args) {\n+        try {\n+            TrajectoryDeterminationProblem problem =\n+              new TrajectoryDeterminationProblem(0.0, 100.0, 800.0, 1.0, 0.0);\n+\n+            double[][] distances = {\n+                    {   0.0, 806.5849 }, {  20.0, 796.8148 }, {  40.0, 791.0833 }, {  60.0, 789.6712 },\n+                    {  80.0, 793.1334 }, { 100.0, 797.7248 }, { 120.0, 803.2785 }, { 140.0, 813.4939 },\n+                    { 160.0, 826.9295 }, { 180.0, 844.0640 }, { 200.0, 863.3829 }, { 220.0, 883.3143 },\n+                    { 240.0, 908.6867 }, { 260.0, 934.8561 }, { 280.0, 964.0730 }, { 300.0, 992.1033 },\n+                    { 320.0, 1023.998 }, { 340.0, 1057.439 }, { 360.0, 1091.912 }, { 380.0, 1125.968 },\n+                    { 400.0, 1162.789 }, { 420.0, 1201.517 }, { 440.0, 1239.176 }, { 460.0, 1279.347 } };\n+            for (int i = 0; i < distances.length; ++i) {\n+                problem.addDistanceMeasurement(1.0,  distances[i][0], distances[i][1]);\n+            };\n+\n+            double[][] angles = {\n+                    { 10.0, 1.415423 }, { 30.0, 1.352643 }, { 50.0, 1.289290 }, { 70.0, 1.225249 },\n+                    { 90.0, 1.161203 }, {110.0, 1.098538 }, {130.0, 1.036263 }, {150.0, 0.976052 },\n+                    {170.0, 0.917921 }, {190.0, 0.861830 }, {210.0, 0.808237 }, {230.0, 0.757043 },\n+                    {250.0, 0.708650 }, {270.0, 0.662949 }, {290.0, 0.619903 }, {310.0, 0.579160 },\n+                    {330.0, 0.541033 }, {350.0, 0.505590 }, {370.0, 0.471746 }, {390.0, 0.440155 },\n+                    {410.0, 0.410522 }, {430.0, 0.382701 }, {450.0, 0.356957 }, {470.0, 0.332400 } };\n+            for (int i = 0; i < angles.length; ++i) {\n+                problem.addAngularMeasurement(3.0e7, angles[i][0], angles[i][1]);\n+            };\n+\n+            LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+            estimator.estimate(problem);\n+            System.out.println(\"initial position: \" + problem.getX0() + \" \" + problem.getY0());\n+            System.out.println(\"velocity: \" + problem.getVx0() + \" \" + problem.getVy0());\n+\n+        } catch (EstimationException ee) {\n+          System.err.println(ee.getMessage());\n+        }\n+    }\n+\n+    public TrajectoryDeterminationProblem(double t0,\n+                                          double  x0Guess, double  y0Guess,\n+                                          double vx0Guess, double vy0Guess) {\n+        this.t0 = t0;\n+         x0 = new EstimatedParameter( \"x0\",  x0Guess);\n+         y0 = new EstimatedParameter( \"y0\",  y0Guess);\n+        vx0 = new EstimatedParameter(\"vx0\", vx0Guess);\n+        vy0 = new EstimatedParameter(\"vy0\", vy0Guess);\n+\n+        // inform the base class about the parameters\n+        addParameter(x0);\n+        addParameter(y0);\n+        addParameter(vx0);\n+        addParameter(vy0);\n+\n+    }\n+\n+    public double getX0() {\n+        return x0.getEstimate();\n+    }\n+\n+    public double getY0() {\n+        return y0.getEstimate();\n+    }\n+\n+    public double getVx0() {\n+        return vx0.getEstimate();\n+    }\n+\n+    public double getVy0() {\n+        return vy0.getEstimate();\n+    }\n+\n+    public void addAngularMeasurement(double wi, double ti, double ai) {\n+        // let the base class handle the measurement\n+        addMeasurement(new AngularMeasurement(wi, ti, ai));\n+    }\n+\n+    public void addDistanceMeasurement(double wi, double ti, double di) {\n+        // let the base class handle the measurement\n+        addMeasurement(new DistanceMeasurement(wi, ti, di));\n+    }\n+\n+    public double x(double t) {\n+        return x0.getEstimate() + (t - t0) * vx0.getEstimate();\n+    }\n+\n+    public double y(double t) {\n+        return y0.getEstimate() + (t - t0) * vy0.getEstimate();\n+    }\n+\n+    private class AngularMeasurement extends WeightedMeasurement {\n+\n+        public AngularMeasurement(double weight, double t, double angle) {\n+            super(weight, angle);\n+            this.t = t;\n+        }\n+\n+        public double getTheoreticalValue() {\n+            return Math.atan2(y(t), x(t));\n+        }\n+\n+        public double getPartial(EstimatedParameter parameter) {\n+            double xt = x(t);\n+            double yt = y(t);\n+            double r  = Math.sqrt(xt * xt + yt * yt);\n+            double u  = yt / (r + xt);\n+            double c  = 2 * u / (1 + u * u);\n+            if (parameter == x0) {\n+                return -c;\n+            } else if (parameter == vx0) {\n+                return -c * t;\n+            } else if (parameter == y0) {\n+                return c * xt / yt;\n+            } else {\n+                return c * t * xt / yt;\n+            }\n+        }\n+\n+        private final double t;\n+        private static final long serialVersionUID = -5990040582592763282L;\n+\n+    }\n+\n+    private class DistanceMeasurement extends WeightedMeasurement {\n+\n+        public DistanceMeasurement(double weight, double t, double angle) {\n+            super(weight, angle);\n+            this.t = t;\n+        }\n+\n+        public double getTheoreticalValue() {\n+            double xt = x(t);\n+            double yt = y(t);\n+            return Math.sqrt(xt * xt + yt * yt);\n+        }\n+\n+        public double getPartial(EstimatedParameter parameter) {\n+            double xt = x(t);\n+            double yt = y(t);\n+            double r  = Math.sqrt(xt * xt + yt * yt);\n+            if (parameter == x0) {\n+                return xt / r;\n+            } else if (parameter == vx0) {\n+                return xt * t / r;\n+            } else if (parameter == y0) {\n+                return yt / r;\n+            } else {\n+                return yt * t / r;\n+            }\n+        }\n+\n+        private final double t;\n+        private static final long serialVersionUID = 3257286197740459503L;\n+\n+    }\n+\n+    private double t0;\n+    private EstimatedParameter x0;\n+    private EstimatedParameter y0;\n+    private EstimatedParameter vx0;\n+    private EstimatedParameter vy0;\n+\n+}", "timestamp": 1202234946, "metainfo": ""}