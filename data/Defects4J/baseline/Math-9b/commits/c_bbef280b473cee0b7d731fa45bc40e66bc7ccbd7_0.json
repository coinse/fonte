{"sha": "bbef280b473cee0b7d731fa45bc40e66bc7ccbd7", "log": "improved array structure in Romberg integrator since the integrator uses only two rows at a time, we allocate only two arrays and reuse them  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n \n-        int i = 1, j, m = maximalIterationCount + 1;\n-        // Array structure here can be improved for better space\n-        // efficiency because only the lower triangle is used.\n-        double r, t[][] = new double[m][m], s, olds;\n+        final int m = maximalIterationCount + 1;\n+        double previousRow[] = new double[m];\n+        double currentRow[]  = new double[m];\n \n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n \n         TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n-        t[0][0] = qtrap.stage(f, min, max, 0);\n-        olds = t[0][0];\n-        while (i <= maximalIterationCount) {\n-            t[i][0] = qtrap.stage(f, min, max, i);\n-            for (j = 1; j <= i; j++) {\n+        currentRow[0] = qtrap.stage(f, min, max, 0);\n+        double olds = currentRow[0];\n+        for (int i = 1; i <= maximalIterationCount; ++i) {\n+\n+            // switch rows\n+            final double[] tmpRow = previousRow;\n+            previousRow = currentRow;\n+            currentRow = tmpRow;\n+\n+            currentRow[0] = qtrap.stage(f, min, max, i);\n+            for (int j = 1; j <= i; j++) {\n                 // Richardson extrapolation coefficient\n-                r = (1L << (2 * j)) -1;\n-                t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;\n+                final double r = (1L << (2 * j)) - 1;\n+                final double tIJm1 = currentRow[j - 1];\n+                currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r;\n             }\n-            s = t[i][i];\n+            final double s = currentRow[i];\n             if (i >= minimalIterationCount) {\n-                final double delta = Math.abs(s - olds);\n-                final double rLimit =\n-                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n+                final double delta  = Math.abs(s - olds);\n+                final double rLimit = relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n                 }\n             }\n             olds = s;\n-            i++;\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }", "timestamp": 1255449411, "metainfo": ""}