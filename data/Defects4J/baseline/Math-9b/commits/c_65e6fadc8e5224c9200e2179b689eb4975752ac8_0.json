{"sha": "65e6fadc8e5224c9200e2179b689eb4975752ac8", "log": "MATH-483 Add FastMath special test case code TODO - enable fail when bugs have been fixed  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n  */\n package org.apache.commons.math.util;\n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n import org.apache.commons.math.dfp.Dfp;\n import org.apache.commons.math.dfp.DfpField;\n import org.apache.commons.math.dfp.DfpMath;\n \n     private static final double MAX_ERROR_ULP = 0.51;\n     private static final int NUMBER_OF_TRIALS = 1000;\n+\n+    // Values which often need special handling\n+    private static final double [] DOUBLE_SPECIAL_VALUES = {\n+        -0.0, +0.0,                                         // 1,2\n+        Double.NaN,                                         // 3\n+        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5\n+        Double.MIN_VALUE, Double.MAX_VALUE,                 // 6,7\n+        -Double.MIN_VALUE, -Double.MAX_VALUE,               // 8,9\n+    };\n+\n+    private static final float [] FLOAT_SPECIAL_VALUES = {\n+        -0.0f, +0.0f,                                       // 1,2\n+        Float.NaN,                                          // 3\n+        Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,   // 4,5\n+        Float.MIN_VALUE, Float.MAX_VALUE,                   // 6,7\n+        -Float.MIN_VALUE, -Float.MAX_VALUE,                 // 8,9\n+    };\n \n     private DfpField field;\n     private RandomGenerator generator;\n \n     }\n \n+    private static void reportError(String message) {\n+        final boolean fatal = false; // TODO set true once all bugs have been fixed\n+        if (fatal) {\n+            Assert.fail(message);\n+        } else {\n+            System.out.println(message);\n+        }\n+    }\n+    \n+    private static abstract class SpecialComparer {\n+        abstract void compareSpecials(Method mathMethod, Method fastMethod) throws Exception;\n+        void check(Method mathMethod, float f, Object expected, Object actual, int entry){\n+            if (!expected.equals(actual)){\n+                reportError(mathMethod.getName()+\"(float \"+f+\") expected \"+expected+\" actual \"+actual+ \" entry \"+entry);\n+            }            \n+        }\n+        void check(Method mathMethod, double d, Object expected, Object actual, int entry){\n+            if (!expected.equals(actual)){\n+                reportError(mathMethod.getName()+\"(float \"+d+\") expected \"+expected+\" actual \"+actual+ \" entry \"+entry);\n+            }            \n+        }\n+    }\n+\n+    private static class CompareFloatSpecials extends SpecialComparer {\n+        @Override\n+        public void compareSpecials(Method mathMethod, Method fastMethod) throws Exception {\n+            int entry = 0;\n+            for(float f : FLOAT_SPECIAL_VALUES) {\n+                entry++;\n+                Object expected = mathMethod.invoke(mathMethod, new Object[]{f});\n+                Object actual = fastMethod.invoke(mathMethod, new Object[]{f});\n+                check(mathMethod, f, expected, actual, entry);\n+            }\n+        }\n+    }\n+    \n+    private static class CompareDoubleSpecials extends SpecialComparer {\n+        @Override\n+        public void compareSpecials(Method mathMethod, Method fastMethod) throws Exception {\n+            int entry = 0;\n+            for(double d : DOUBLE_SPECIAL_VALUES) {\n+                entry++;\n+                Object expected = mathMethod.invoke(mathMethod, new Object[]{d});\n+                Object actual = fastMethod.invoke(mathMethod, new Object[]{d});\n+                check(mathMethod, d, expected, actual, entry);\n+            }\n+        }\n+    }\n+\n+    private void testSpecialCases(Class<?> type, SpecialComparer comparer) throws Exception {\n+        Class<?> param[] = new Class<?> [] {type}; \n+        Method math[] = StrictMath.class.getDeclaredMethods();\n+        for(Method mathMethod : math) {\n+            Type ret = mathMethod.getGenericReturnType();\n+            if (ret.equals(type)){\n+                Type []params = mathMethod.getGenericParameterTypes();\n+                if (params.length ==1 && params[0].equals(type)) {\n+                    Method fastMethod = null;\n+                    String name = mathMethod.getName();\n+                    try {\n+                        fastMethod = FastMath.class.getDeclaredMethod(name, param);\n+                        comparer.compareSpecials(mathMethod, fastMethod);\n+                    } catch (NoSuchMethodException e) {\n+                        System.out.println(\"Cannot find FastMath method corresponding to: \"+mathMethod);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testFloatSpecialCases() throws Exception {\n+        testSpecialCases(float.class, new CompareFloatSpecials());\n+    }\n+\n+    @Test\n+    public void testDoubleSpecialCases() throws Exception {\n+        testSpecialCases(double.class, new CompareDoubleSpecials());\n+    }\n+\n     @Ignore\n     @Test\n     public void testPerformance() {\n                 x += FastMath.expm1(-i / 100000.0);\n             time = System.currentTimeMillis() - time;\n             System.out.println(\"FastMath.expm1 \" + time + \"\\t\" + x);\n+\n         }\n     }\n ", "timestamp": 1295463938, "metainfo": ""}