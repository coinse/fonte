{"sha": "9d552d480d2ac9c70aa7164b7e7931e7c2017c87", "log": "Fix findbugs warning, use strict comparison for negative values.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n  * @since 3.1\n  */\n class SchurTransformer {\n+    /** Maximum allowed iterations for convergence of the transformation. */\n+    private static final int MAX_ITERATIONS = 100;\n+\n     /** P matrix. */\n     private final double matrixP[][];\n     /** T matrix. */\n     private RealMatrix cachedT;\n     /** Cached value of PT. */\n     private RealMatrix cachedPt;\n-\n-    /** Maximum allowed iterations for convergence of the transformation. */\n-    private final int maxIterations = 100;\n \n     /** Epsilon criteria taken from JAMA code (originally was 2^-52). */\n     private final double epsilon = Precision.EPSILON;\n                 computeShift(l, idx, iteration, shift);\n \n                 // stop transformation after too many iterations\n-                if (++iteration > maxIterations) {\n+                if (++iteration > MAX_ITERATIONS) {\n                     throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n-                                                        maxIterations);\n+                                                        MAX_ITERATIONS);\n                 }\n \n                 // Look for two consecutive small sub-diagonal elements\n                 break;\n             }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n-            if (Precision.compareTo(p, 0.0, epsilon) < 0) {\n+            if (p < 0.0) {\n                 s = -s;\n             }\n             if (!Precision.equals(s, 0.0, epsilon)) {", "timestamp": 1344175887, "metainfo": ""}