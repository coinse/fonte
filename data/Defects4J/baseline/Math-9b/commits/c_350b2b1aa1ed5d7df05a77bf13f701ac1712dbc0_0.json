{"sha": "350b2b1aa1ed5d7df05a77bf13f701ac1712dbc0", "log": "MATH-804 Parameterized \"CurveFitter\" with the type of the fitting function. Updated subclasses \"PolynomialFitter\", \"HarmonicFitter\", \"GaussianFitter\" accordingly.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/CurveFitter.java\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n \n /** Fitter for parametric univariate real functions y = f(x).\n- * <p>When a univariate real function y = f(x) does depend on some\n+ * <br/>\n+ * When a univariate real function y = f(x) does depend on some\n  * unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>,\n  * this class can be used to find these parameters. It does this\n  * by <em>fitting</em> the curve so it remains very close to a set of\n  * y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting\n  * is done by finding the parameters values that minimizes the objective\n  * function &sum;(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is\n- * really a least squares problem.</p>\n+ * really a least squares problem.\n+ *\n+ * @param <T> Function to use for the fit.\n+ *\n  * @version $Id$\n  * @since 2.0\n  */\n-public class CurveFitter {\n+public class CurveFitter<T extends ParametricUnivariateFunction> {\n     /** Optimizer to use for the fitting. */\n     private final DifferentiableMultivariateVectorOptimizer optimizer;\n     /** Observed points. */\n      * @throws org.apache.commons.math3.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      */\n-    public double[] fit(final ParametricUnivariateFunction f, final double[] initialGuess) {\n+    public double[] fit(T f, final double[] initialGuess) {\n         return fit(Integer.MAX_VALUE, f, initialGuess);\n     }\n \n      * if the start point dimension is wrong.\n      * @since 3.0\n      */\n-    public double[] fit(int maxEval, final ParametricUnivariateFunction f,\n+    public double[] fit(int maxEval, T f,\n                         final double[] initialGuess) {\n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/GaussianFitter.java\n import java.util.Comparator;\n \n import org.apache.commons.math3.analysis.function.Gaussian;\n-import org.apache.commons.math3.analysis.ParametricUnivariateFunction;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n  * @since 2.2\n  * @version $Id$\n  */\n-public class GaussianFitter extends CurveFitter {\n+public class GaussianFitter extends CurveFitter<Gaussian.Parametric> {\n     /**\n      * Constructs an instance using the specified optimizer.\n      *\n      * @since 3.0\n      */\n     public double[] fit(double[] initialGuess) {\n-        final ParametricUnivariateFunction f = new ParametricUnivariateFunction() {\n-                private final ParametricUnivariateFunction g = new Gaussian.Parametric();\n-\n+        final Gaussian.Parametric f = new Gaussian.Parametric() {\n                 public double value(double x, double ... p) {\n                     double v = Double.POSITIVE_INFINITY;\n                     try {\n-                        v = g.value(x, p);\n+                        v = super.value(x, p);\n                     } catch (NotStrictlyPositiveException e) {\n                         // Do nothing.\n                     }\n                                    Double.POSITIVE_INFINITY,\n                                    Double.POSITIVE_INFINITY };\n                     try {\n-                        v = g.gradient(x, p);\n+                        v = super.gradient(x, p);\n                     } catch (NotStrictlyPositiveException e) {\n                         // Do nothing.\n                     }\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n  * @version $Id$\n  * @since 2.0\n  */\n-public class HarmonicFitter extends CurveFitter {\n+public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n     /**\n      * Simple constructor.\n      * @param optimizer Optimizer to use for the fitting.\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n \n-/** This class implements a curve fitting specialized for polynomials.\n- * <p>Polynomial fitting is a very simple case of curve fitting. The\n- * estimated coefficients are the polynomial coefficients. They are\n- * searched by a least square estimator.</p>\n+/**\n+ * Polynomial fitting is a very simple case of {@link CurveFitter curve fitting}.\n+ * The estimated coefficients are the polynomial coefficients (see the\n+ * {@link #fit(double[]) fit} method).\n+ *\n  * @version $Id$\n  * @since 2.0\n- *\n- * @deprecated Since 3.1 (to be removed in 4.0, see <a href=\"https://issues.apache.org/jira/browse/MATH-800\">MATH-800</a>).\n- * Please use {@link CurveFitter} directly, by passing an instance of\n- * {@link org.apache.commons.math3.analysis.polynomials.PolynomialFunction.Parametric PolynomialFunction.Parametric}\n- * as an argument to the\n- * {@link CurveFitter#fit(int,org.apache.commons.math3.analysis.ParametricUnivariateFunction,double[]) fit}\n- * method.\n  */\n-public class PolynomialFitter extends CurveFitter {\n-    /** Polynomial degree. */\n+public class PolynomialFitter extends CurveFitter<PolynomialFunction.Parametric> {\n+    /** Polynomial degree.\n+     * @deprecated\n+     */\n     private final int degree;\n \n     /**\n      *\n      * @param degree Maximal degree of the polynomial.\n      * @param optimizer Optimizer to use for the fitting.\n+     * @deprecated Since 3.1 (to be removed in 4.0). Please use\n+     * {@link #PolynomialFitter(DifferentiableMultivariateVectorOptimizer)} instead.\n      */\n     public PolynomialFitter(int degree, final DifferentiableMultivariateVectorOptimizer optimizer) {\n         super(optimizer);\n         this.degree = degree;\n+    }\n+\n+    /**\n+     * Simple constructor.\n+     *\n+     * @param optimizer Optimizer to use for the fitting.\n+     */\n+    public PolynomialFitter(DifferentiableMultivariateVectorOptimizer optimizer) {\n+        super(optimizer);\n+        degree = -1; // To avoid compilation error until the instance variable is removed.\n     }\n \n     /**\n      * @return the coefficients of the polynomial that best fits the observed points.\n      * @throws org.apache.commons.math3.exception.ConvergenceException\n      * if the algorithm failed to converge.\n+     * @deprecated Since 3.1 (to be removed in 4.0). Please use {@link #fit(double[])} instead.\n      */\n     public double[] fit() {\n         return fit(new PolynomialFunction.Parametric(), new double[degree + 1]);\n     }\n+\n+    /**\n+     * Get the coefficients of the polynomial fitting the weighted data points.\n+     * The degree of the fitting polynomial is {@code guess.length - 1}.\n+     *\n+     * @param guess First guess for the coefficients. They must be sorted in\n+     * increasing order of the polynomial's degree.\n+     * @return the coefficients of the polynomial that best fits the observed points.\n+     * @throws org.apache.commons.math3.exception.ConvergenceException\n+     * if the algorithm failed to converge.\n+     */\n+    public double[] fit(double[] guess) {\n+        return fit(new PolynomialFunction.Parametric(), guess);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n         rng.reSeed(64925784252L);\n \n         final LevenbergMarquardtOptimizer optim = new LevenbergMarquardtOptimizer();\n-        final CurveFitter fitter = new CurveFitter(optim);\n+        final PolynomialFitter fitter = new PolynomialFitter(optim);\n         final double[] coeff = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2\n         final PolynomialFunction f = new PolynomialFunction(coeff);\n \n         }\n \n         // Start fit from initial guesses that are far from the optimal values.\n-        final double[] best = fitter.fit(new PolynomialFunction.Parametric(),\n-                                         new double[] { -1e-20, 3e15, -5e25 });\n+        final double[] best = fitter.fit(new double[] { -1e-20, 3e15, -5e25 });\n \n         TestUtils.assertEquals(\"best != coeff\", coeff, best, 1e-12);\n     }\n         for (int degree = 1; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n+            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n             for (int i = 0; i <= degree; ++i) {\n                 fitter.addObservedPoint(1.0, i, p.value(i));\n             }\n \n             final double[] init = new double[degree + 1];\n-            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(Integer.MAX_VALUE,\n-                                                                          new PolynomialFunction.Parametric(),\n-                                                                          init));\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n         for (int degree = 0; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n+            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 fitter.addObservedPoint(1.0, x,\n                                         p.value(x) + 0.1 * randomizer.nextGaussian());\n             }\n \n             final double[] init = new double[degree + 1];\n-            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(Integer.MAX_VALUE,\n-                                                                          new PolynomialFunction.Parametric(),\n-                                                                          init));\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n         for (int degree = 0; degree < 10; ++degree) {\n             PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n \n-            CurveFitter fitter = new CurveFitter(optimizer);\n+            PolynomialFitter fitter = new PolynomialFitter(optimizer);\n \n             // reusing the same point over and over again does not bring\n             // information, the problem cannot be solved in this case for\n \n             try {\n                 final double[] init = new double[degree + 1];\n-                fitter.fit(Integer.MAX_VALUE,\n-                           new PolynomialFunction.Parametric(),\n-                           init);\n+                fitter.fit(init);\n                 Assert.assertTrue(solvable || (degree == 0));\n             } catch(ConvergenceException e) {\n                 Assert.assertTrue((! solvable) && (degree > 0));", "timestamp": 1339341177, "metainfo": ""}