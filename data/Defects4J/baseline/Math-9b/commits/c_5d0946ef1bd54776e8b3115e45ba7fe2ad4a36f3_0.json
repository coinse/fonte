{"sha": "5d0946ef1bd54776e8b3115e45ba7fe2ad4a36f3", "log": "MATH-613 Linear combination of vectors.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n         return this;\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector combine(double a, double b, double[] y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector combine(double a, double b, RealVector y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector combineToSelf(double a, double b, double[] y) {\n+        return combineToSelf(a, b, new ArrayRealVector(y, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector combineToSelf(double a, double b, RealVector y) {\n+        checkVectorDimensions(y);\n+        for (int i = 0; i < getDimension(); i++) {\n+            final double xi = getEntry(i);\n+            final double yi = y.getEntry(i);\n+            setEntry(i, a * xi + b * yi);\n+        }\n+        return this;\n+    }\n+\n     /** An entry in the vector. */\n     protected class EntryImpl extends Entry {\n \n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n         }\n         return MathUtils.hash(data);\n     }\n+\n+    /**\n+     * Returns the linear combination of {@code this} and {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n+     * {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public ArrayRealVector combine(double a, double b, ArrayRealVector y) {\n+        return (ArrayRealVector) copy().combineToSelf(a, b, y.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector combineToSelf(double a, double b, double[] y) {\n+        checkVectorDimensions(y.length);\n+        for (int i = 0; i < this.data.length; i++) {\n+            data[i] = a * data[i] + b * y[i];\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public ArrayRealVector combineToSelf(double a, double b, ArrayRealVector y) {\n+        combineToSelf(a, b, y.data);\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector combineToSelf(double a, double b, RealVector y) {\n+        if (y instanceof ArrayRealVector) {\n+            return combineToSelf(a, b, ((ArrayRealVector) y).data);\n+        } else {\n+            checkVectorDimensions(y);\n+            for (int i = 0; i < this.data.length; i++) {\n+                data[i] = a * data[i] + b * y.getEntry(i);\n+            }\n+            return this;\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n      * none are {@code NaN}, {@code false} otherwise.\n      */\n     boolean isInfinite();\n+\n+    /**\n+     * Returns the linear combination of {@code this} and {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n+     * {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    RealVector combine(double a, double b, double[] y);\n+\n+    /**\n+     * Returns the linear combination of {@code this} and {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n+     * {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    RealVector combine(double a, double b, RealVector y);\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    RealVector combineToSelf(double a, double b, double[] y);\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    RealVector combineToSelf(double a, double b, RealVector y);\n }\n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n import org.junit.Test;\n import org.junit.Assert;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.RealVector.Entry;\n import java.util.Iterator;\n import java.util.Random;\n         for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {\n             Assert.assertEquals(onlyOne[1], e.getValue(), 0);\n         }\n-        \n+\n     }\n \n     @Test\n         Assert.assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm(), 0);\n     }\n \n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombinePrecondition() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final TestVectorImpl x = new TestVectorImpl(aux);\n+        aux = new double[] { 6d, 7d };\n+        final TestVectorImpl y = new TestVectorImpl(aux);\n+        x.combine(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombine() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new TestVectorImpl(new double[dim]);\n+        final RealVector y = new TestVectorImpl(new double[dim]);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        final RealVector z = x.combine(a, b, y);\n+        Assert.assertTrue(z != x);\n+        final double[] actual = z.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\", expected[i],\n+                                actual[i], delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombineToSelfPrecondition() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final TestVectorImpl x = new TestVectorImpl(aux);\n+        aux = new double[] { 6d, 7d };\n+        final TestVectorImpl y = new TestVectorImpl(aux);\n+        x.combineToSelf(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineToSelf() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new TestVectorImpl(new double[dim]);\n+        final RealVector y = new TestVectorImpl(new double[dim]);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        Assert.assertSame(x, x.combineToSelf(a, b, y));\n+        final double[] actual = x.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\", expected[i],\n+                                actual[i], delta);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n \n import java.io.Serializable;\n import java.util.Iterator;\n-import org.junit.Assert;\n-import org.junit.Test;\n+import java.util.Random;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.MathArithmeticException;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.function.Abs;\n import org.apache.commons.math.analysis.function.Acos;\n import org.apache.commons.math.analysis.function.Asin;\n import org.apache.commons.math.analysis.function.Atan;\n import org.apache.commons.math.analysis.function.Cbrt;\n+import org.apache.commons.math.analysis.function.Ceil;\n+import org.apache.commons.math.analysis.function.Cos;\n import org.apache.commons.math.analysis.function.Cosh;\n-import org.apache.commons.math.analysis.function.Cos;\n import org.apache.commons.math.analysis.function.Exp;\n import org.apache.commons.math.analysis.function.Expm1;\n+import org.apache.commons.math.analysis.function.Floor;\n import org.apache.commons.math.analysis.function.Inverse;\n+import org.apache.commons.math.analysis.function.Log;\n import org.apache.commons.math.analysis.function.Log10;\n import org.apache.commons.math.analysis.function.Log1p;\n-import org.apache.commons.math.analysis.function.Log;\n-import org.apache.commons.math.analysis.function.Sinh;\n-import org.apache.commons.math.analysis.function.Sin;\n-import org.apache.commons.math.analysis.function.Sqrt;\n-import org.apache.commons.math.analysis.function.Tanh;\n-import org.apache.commons.math.analysis.function.Tan;\n-import org.apache.commons.math.analysis.function.Floor;\n-import org.apache.commons.math.analysis.function.Ceil;\n+import org.apache.commons.math.analysis.function.Power;\n import org.apache.commons.math.analysis.function.Rint;\n import org.apache.commons.math.analysis.function.Signum;\n+import org.apache.commons.math.analysis.function.Sin;\n+import org.apache.commons.math.analysis.function.Sinh;\n+import org.apache.commons.math.analysis.function.Sqrt;\n+import org.apache.commons.math.analysis.function.Tan;\n+import org.apache.commons.math.analysis.function.Tanh;\n import org.apache.commons.math.analysis.function.Ulp;\n-import org.apache.commons.math.analysis.function.Power;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test cases for the {@link ArrayRealVector} class.\n             throw unsupported();\n         }\n \n+        public RealVector combine(double a, double b, double[] y) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector combine(double a, double b, RealVector y) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector combineToSelf(double a, double b, double[] y) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector combineToSelf(double a, double b, RealVector y) {\n+            throw unsupported();\n+        }\n     }\n \n     @Test\n         Assert.assertEquals(6, uv.getEntry(2, 1), tol);\n     }\n \n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombinePreconditionArray() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        final double[] y = new double[] { 6d, 7d };\n+        x.combine(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineArray() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final double[] y = new double[dim];\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y[i] = yi;\n+            expected[i] = a * xi + b * yi;\n+        }\n+        final double[] actual = x.combine(a, b, y).getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombinePreconditionSameType() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        aux = new double[] { 6d, 7d };\n+        final RealVector y = new ArrayRealVector(aux, false);\n+        x.combine(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineSameType() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final RealVector y = new ArrayRealVector(dim);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        final double[] actual = x.combine(a, b, y).getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombinePreconditionMixedType() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        aux = new double[] { 6d, 7d };\n+        final RealVector y = new OpenMapRealVector(aux);\n+        x.combine(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineMixedTypes() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final RealVector y = new OpenMapRealVector(dim, 0d);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        final double[] actual = x.combine(a, b, y).getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombineToSelfPreconditionArray() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        final double[] y = new double[] { 6d, 7d };\n+        x.combineToSelf(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineToSelfArray() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final double[] y = new double[dim];\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y[i] = yi;\n+            expected[i] = a * xi + b * yi;\n+        }\n+        Assert.assertSame(x, x.combineToSelf(a, b, y));\n+        final double[] actual = x.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombineToSelfPreconditionSameType() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        aux = new double[] { 6d, 7d };\n+        final RealVector y = new ArrayRealVector(aux, false);\n+        x.combineToSelf(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineToSelfSameType() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final RealVector y = new ArrayRealVector(dim);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        Assert.assertSame(x, x.combineToSelf(a, b, y));\n+        final double[] actual = x.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombineToSelfPreconditionMixedType() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final RealVector x = new ArrayRealVector(aux, false);\n+        aux = new double[] { 6d, 7d };\n+        final RealVector y = new OpenMapRealVector(aux);\n+        x.combineToSelf(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineToSelfMixedTypes() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new ArrayRealVector(dim);\n+        final RealVector y = new OpenMapRealVector(dim, 0d);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        Assert.assertSame(x, x.combineToSelf(a, b, y));\n+        final double[] actual = x.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n+                                expected[i],\n+                                actual[i],\n+                                delta);\n+        }\n+    }\n+\n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {", "timestamp": 1311809205, "metainfo": ""}