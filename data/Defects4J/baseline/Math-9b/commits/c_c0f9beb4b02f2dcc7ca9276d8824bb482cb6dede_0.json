{"sha": "c0f9beb4b02f2dcc7ca9276d8824bb482cb6dede", "log": "Adds the following two capabilities to RandomData: Generating random permutations of integers, Generating random samples (returned as Object arrays) from Collections. Tests validate expected sample distribtution using chi-square tests  PR: Issue 20303 Obtained from: Bugzilla Submitted by: Phil Steitz Reviewed by: Tim O'Brien   ", "commit": "\n--- a/src/java/org/apache/commons/math/RandomData.java\n+++ b/src/java/org/apache/commons/math/RandomData.java\n  */\n \n package org.apache.commons.math;\n+import java.util.Collection;\n \n /**\n  * Random data generation utilities\n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/05/18 00:58:51 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/29 19:45:35 $\n  */\n public interface RandomData {      \n     /**\n     public double nextExponential(double mean);   \n     \n     /**\n-     * Generates a uniformly distributed random value from the opem interval\n+     * Generates a uniformly distributed random value from the open interval\n      * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded)\n      * <strong>Definition</strong>: \n      * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm>\n      * @exception IllegalArgumentException thrown if\n      * <code>lower</code> is not strictly less than <code>upper</code>.\n      */\n-    public double nextUniform(double lower, double upper);   \n+    public double nextUniform(double lower, double upper);\n+    \n+    /**\n+     * Generates an integer array of length <code>k</code> whose entries\n+     * are selected randomly, without repetition, from the integers\n+     * {0, ... , n-1} -- i.e., generated arrays represent permutations\n+     * of <code>n</code> taken <code>k</code> at a time. <p>\n+     *\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> k must be less than or equal to n </li>\n+     * <li> n must be positive (i.e. greater than 0) </li>\n+     * </ul>\n+     * \n+     * @param n domain of the permutation\n+     * @param k size of the permutation\n+     * @return random k-permutation of n \n+     */\n+    public int[] nextPermutation(int n, int k);\n+    \n+    /**\n+     * Returns an array of <code>k</code> objects selected randomly\n+     * from the Collection <code>c</code>. Sampling from <code>c</code>\n+     * is without replacement; but if <code>c</code> contains identical\n+     * objects, the sample may include repeats.  If all elements of <code>\n+     * c</code> are distinct, the resulting object array represents a \n+     * <a href=http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000>\n+     * Simple Random Sample</a> of size\n+     * <code>k</code> from the elements of <code>c</code>.<p>   \n+     *\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> k must be less than or equal to the size of c </li>\n+     * <li> c must not be empty </li>\n+     * </ul>\n+     * \n+     * @param c collection to be sampled\n+     * @param k size of the sample\n+     * @return random sample of k elements from c \n+     */\n+    public Object[] nextSample(Collection c, int k);\n }\n--- a/src/java/org/apache/commons/math/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/RandomDataImpl.java\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.util.Random;\n+import java.util.Collection;\n \n /**\n  * Implements the <code>RandomData</code> interface using \n  *</p>\n  * \n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/05/18 00:58:51 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/29 19:45:35 $\n  */\n public class RandomDataImpl implements RandomData{\n     \n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n-                (\"incorrect bounds for rendomInt\");\n+                (\"upper bound must be > lower bound\");\n         }\n         Random rand = getRan();\n         return lower + (int)(Math.random() * (upper-lower+1));\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n-                (\"upper bound must be >= lower bound\");\n+                (\"upper bound must be > lower bound\");\n         }\n         Random rand = getRan();\n         return lower + (long)(rand.nextDouble() * (upper-lower+1));\n     public int nextSecureInt(int lower, int upper) {\n           if (lower >= upper) {\n               throw new IllegalArgumentException\n-                (\"lower bound must be <= upper bound\");\n+                (\"lower bound must be < upper bound\");\n           }\n           SecureRandom sec = getSecRan();\n           return lower + (int)(sec.nextDouble() * (upper-lower+1));\n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n-            (\"lower bound must be <= upper bound\");\n+            (\"lower bound must be < upper bound\");\n         }\n         SecureRandom sec = getSecRan();\n         return lower + (long)(sec.nextDouble() * (upper-lower+1));\n         throws NoSuchAlgorithmException,NoSuchProviderException {\n         secRand = SecureRandom.getInstance(algorithm,provider);\n     }\n+    \n+    /**\n+     * Uses a 2-cycle permutation shuffle, as described\n+     * <a href=http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html>\n+     * here</a>\n+     *  \n+     */\n+    public int[] nextPermutation(int n, int k) {\n+        if (k > n) {\n+            throw new IllegalArgumentException\n+                (\"permutation k exceeds n\");\n+        }       \n+        if (k == 0) {\n+            throw new IllegalArgumentException\n+                (\"permutation k must be > 0\");\n+        }\n+        \n+        int[] index = getNatural(n);\n+        shuffle(index,n-k);\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = index[n-i-1];\n+        }\n+  \n+        return result;\n+    }\n+    \n+    /**\n+     * Uses a 2-cycle permutation shuffle to generate a random\n+     * permutation of <code>c.size()</code> and then returns the\n+     * elements whose indexes correspond to the elements of the\n+     * generated permutation.  This technique is described, and \n+     * proven to generate random samples, \n+     * <a href=http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html>\n+     * here</a>\n+     */ \n+    public Object[] nextSample(Collection c, int k) {\n+        int len = c.size();\n+        if (k > len) {\n+            throw new IllegalArgumentException\n+                (\"sample size exceeds collection size\");\n+        }\n+        if (k == 0) {\n+            throw new IllegalArgumentException\n+                (\"sample size must be > 0\");\n+        }\n+            \n+       Object[] objects = c.toArray();\n+       int[] index = nextPermutation(len,k);\n+       Object[] result = new Object[k];\n+       for (int i = 0; i < k; i ++) {\n+           result[i] = objects[index[i]];\n+       }  \n+       return result;\n+    }\n+    \n+    //------------------------Private methods----------------------------------\n+    \n+    /** \n+     * Uses a 2-cycle permutation shuffle to randomly re-order the last\n+     * end elements of list\n+     * \n+     * @param list list to be shuffled\n+     * @end element past which shuffling begins\n+     */\n+    private void shuffle(int[] list, int end) {\n+        int target = 0;\n+        for (int i = list.length-1 ; i >= end; i--) {\n+            if (i == 0) {\n+                target = 0; \n+            } else {\n+                target = nextInt(0,i);\n+            }\n+            int temp = list[target];\n+            list[target] = list[i];\n+            list[i] = temp;\n+        }      \n+    }\n+    \n+    /**\n+     * Returns an array representing n\n+     *\n+     * @param n the natural number to represent\n+     * @return array with entries = elements of n\n+     */\n+    private int[] getNatural(int n) {\n+        int[] natural = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            natural[i] = i;\n+        }\n+        return natural;\n+    }\n         \n }\n--- a/src/test/org/apache/commons/math/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/RandomDataTest.java\n import junit.framework.AssertionFailedError;\n import java.security.NoSuchProviderException;\n import java.security.NoSuchAlgorithmException;\n+import java.util.Collection;\n+import java.util.HashSet;\n /**\n  * Test cases for the RandomData class.\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.2 $ $Date: 2003/05/22 15:31:38 $\n+ * @version $Revision: 1.3 $ $Date: 2003/05/29 19:45:35 $\n  */\n \n public final class RandomDataTest extends TestCase {\n             ;\n         }      \n     }\n+    \n+    /** tests for nextSample() sampling from Collection */\n+    public void testNextSample() {\n+       Object[][] c = {{\"0\",\"1\"},{\"0\",\"2\"},{\"0\",\"3\"},{\"0\",\"4\"},{\"1\",\"2\"},\n+                        {\"1\",\"3\"},{\"1\",\"4\"},{\"2\",\"3\"},{\"2\",\"4\"},{\"3\",\"4\"}};\n+       double[] observed = {0,0,0,0,0,0,0,0,0,0};\n+       double[] expected = {100,100,100,100,100,100,100,100,100,100};\n+       \n+       HashSet cPop = new HashSet();  //{0,1,2,3,4}\n+       for (int i = 0; i < 5; i++) {\n+           cPop.add(Integer.toString(i));\n+       }\n+       \n+       Object[] sets = new Object[10]; // 2-sets from 5\n+       for (int i = 0; i < 10; i ++) {\n+           HashSet hs = new HashSet();\n+           hs.add(c[i][0]);\n+           hs.add(c[i][1]);\n+           sets[i] = hs;\n+       }\n+       \n+       for (int i = 0; i < 1000; i ++) {\n+           Object[] cSamp = randomData.nextSample(cPop,2);\n+           observed[findSample(sets,cSamp)]++;\n+       }\n+       \n+        /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001\n+         * Change to 21.67 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 27.88);  \n+       \n+       // Make sure sample of size = size of collection returns same collection\n+       HashSet hs = new HashSet();\n+       hs.add(\"one\");\n+       Object[] one = randomData.nextSample(hs,1);\n+       String oneString = (String) one[0];\n+       if ((one.length != 1) || !oneString.equals(\"one\")){\n+           fail(\"bad sample for set size = 1, sample size = 1\");\n+       }\n+       \n+       // Make sure we fail for sample size > collection size\n+       try {\n+           one = randomData.nextSample(hs,2);\n+           fail(\"sample size > set size, expecting IllegalArgumentException\");\n+       } catch (IllegalArgumentException ex) {\n+           ;\n+       }\n+       \n+       // Make sure we fail for empty collection\n+       try {\n+           hs = new HashSet();\n+           one = randomData.nextSample(hs,0);\n+           fail(\"n = k = 0, expecting IllegalArgumentException\");\n+       } catch (IllegalArgumentException ex) {\n+           ;\n+       }\n+    }\n+    \n+    private int findSample(Object[] u, Object[] samp) {\n+        int result = -1;\n+        for (int i = 0; i < u.length; i++) {\n+            HashSet set = (HashSet) u[i];\n+            HashSet sampSet = new HashSet();\n+            for (int j = 0; j < samp.length; j++) {\n+                sampSet.add(samp[j]);\n+            }\n+            if (set.equals(sampSet)) {                 \n+               return i;\n+           }\n+        }\n+        fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+        return -1;\n+    }\n+    \n+    /** tests for nextPermutation */\n+    public void testNextPermutation() {\n+         int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};\n+         double[] observed = {0,0,0,0,0,0,};\n+         double[] expected = {100,100,100,100,100,100};\n+         \n+         for (int i = 0; i < 600; i++) {\n+             int[] perm = randomData.nextPermutation(3,3);\n+             observed[findPerm(p,perm)]++;\n+         }  \n+         \n+        /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001\n+         * Change to 15.09 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 20.52); \n+         \n+         // Check size = 1 boundary case\n+         int[] perm = randomData.nextPermutation(1,1);\n+         if ((perm.length != 1) || (perm[0] != 0)){\n+           fail(\"bad permutation for n = 1, sample k = 1\");\n+           \n+        // Make sure we fail for k size > n \n+        try {\n+           perm = randomData.nextPermutation(2,3);\n+           fail(\"permutation k > n, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+           ;\n+        }\n+           \n+        // Make sure we fail for n = 0\n+        try {\n+           perm = randomData.nextPermutation(0,0);\n+           fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+           ;\n+        }\n+           \n+        \n+       }\n+         \n+    }\n+    \n+    private int findPerm(int[][] p, int[] samp) {\n+        int result = -1;\n+        for (int i = 0; i < p.length; i++) {\n+            boolean good = true;\n+            for (int j = 0; j < samp.length; j++) {\n+                if (samp[j] != p[i][j]) {\n+                    good = false;\n+                }\n+            }\n+            if (good)  {\n+                return i;\n+            }\n+        }        \n+        fail(\"permutation not found\");\n+        return -1;\n+    }\n+                \n+                       \n+            \n+        \n+    \n }\n ", "timestamp": 1054237535, "metainfo": ""}