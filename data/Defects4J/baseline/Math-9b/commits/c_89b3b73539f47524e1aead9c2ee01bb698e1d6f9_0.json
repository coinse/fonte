{"sha": "89b3b73539f47524e1aead9c2ee01bb698e1d6f9", "log": "Added partial derivatives computation for 3D vectors and rotations.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/RotationDS.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math3.Field;\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * This class is a re-implementation of {@link Rotation} using {@link DerivativeStructure}.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ *\n+ * @version $Id$\n+ * @see Vector3DDSDS\n+ * @see RotationOrder\n+ * @since 3.2\n+ */\n+\n+public class RotationDS implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 20130215l;\n+\n+    /** Scalar coordinate of the quaternion. */\n+    private final DerivativeStructure q0;\n+\n+    /** First coordinate of the vectorial part of the quaternion. */\n+    private final DerivativeStructure q1;\n+\n+    /** Second coordinate of the vectorial part of the quaternion. */\n+    private final DerivativeStructure q2;\n+\n+    /** Third coordinate of the vectorial part of the quaternion. */\n+    private final DerivativeStructure q3;\n+\n+    /** Build a rotation from the quaternion coordinates.\n+     * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+     * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+     * the constructor can normalize it in a preprocessing step.</p>\n+     * <p>Note that some conventions put the scalar part of the quaternion\n+     * as the 4<sup>th</sup> component and the vector part as the first three\n+     * components. This is <em>not</em> our convention. We put the scalar part\n+     * as the first component.</p>\n+     * @param q0 scalar part of the quaternion\n+     * @param q1 first coordinate of the vectorial part of the quaternion\n+     * @param q2 second coordinate of the vectorial part of the quaternion\n+     * @param q3 third coordinate of the vectorial part of the quaternion\n+     * @param needsNormalization if true, the coordinates are considered\n+     * not to be normalized, a normalization preprocessing step is performed\n+     * before using them\n+     */\n+    public RotationDS(final DerivativeStructure q0, final DerivativeStructure q1,\n+                      final DerivativeStructure q2, final DerivativeStructure q3,\n+                      final boolean needsNormalization) {\n+\n+        if (needsNormalization) {\n+            // normalization preprocessing\n+            final DerivativeStructure inv =\n+                    q0.multiply(q0).add(q1.multiply(q1)).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().reciprocal();\n+            this.q0 = inv.multiply(q0);\n+            this.q1 = inv.multiply(q1);\n+            this.q2 = inv.multiply(q2);\n+            this.q3 = inv.multiply(q3);\n+        } else {\n+            this.q0 = q0;\n+            this.q1 = q1;\n+            this.q2 = q2;\n+            this.q3 = q3;\n+        }\n+\n+    }\n+\n+    /** Build a rotation from an axis and an angle.\n+     * <p>We use the convention that angles are oriented according to\n+     * the effect of the rotation on vectors around the axis. That means\n+     * that if (i, j, k) is a direct frame and if we first provide +k as\n+     * the axis and &pi;/2 as the angle to this constructor, and then\n+     * {@link #applyTo(Vector3DDS) apply} the instance to +i, we will get\n+     * +j.</p>\n+     * <p>Another way to represent our convention is to say that a rotation\n+     * of angle &theta; about the unit vector (x, y, z) is the same as the\n+     * rotation build from quaternion components { cos(-&theta;/2),\n+     * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n+     * Note the minus sign on the angle!</p>\n+     * <p>On the one hand this convention is consistent with a vectorial\n+     * perspective (moving vectors in fixed frames), on the other hand it\n+     * is different from conventions with a frame perspective (fixed vectors\n+     * viewed from different frames) like the ones used for example in spacecraft\n+     * attitude community or in the graphics community.</p>\n+     * @param axis axis around which to rotate\n+     * @param angle rotation angle.\n+     * @exception MathIllegalArgumentException if the axis norm is zero\n+     */\n+    public RotationDS(final Vector3DDS axis, final DerivativeStructure angle)\n+        throws MathIllegalArgumentException {\n+\n+        final DerivativeStructure norm = axis.getNorm();\n+        if (norm.getValue() == 0) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n+        }\n+\n+        final DerivativeStructure halfAngle = angle.multiply(-0.5);\n+        final DerivativeStructure coeff = halfAngle.sin().divide(norm);\n+\n+        q0 = halfAngle.cos();\n+        q1 = coeff.multiply(axis.getX());\n+        q2 = coeff.multiply(axis.getY());\n+        q3 = coeff.multiply(axis.getZ());\n+\n+    }\n+\n+    /** Build a rotation from a 3X3 matrix.\n+\n+     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+     * (which are matrices for which m.m<sup>T</sup> = I) with real\n+     * coefficients. The module of the determinant of unit matrices is\n+     * 1, among the orthogonal 3X3 matrices, only the ones having a\n+     * positive determinant (+1) are rotation matrices.</p>\n+\n+     * <p>When a rotation is defined by a matrix with truncated values\n+     * (typically when it is extracted from a technical sheet where only\n+     * four to five significant digits are available), the matrix is not\n+     * orthogonal anymore. This constructor handles this case\n+     * transparently by using a copy of the given matrix and applying a\n+     * correction to the copy in order to perfect its orthogonality. If\n+     * the Frobenius norm of the correction needed is above the given\n+     * threshold, then the matrix is considered to be too far from a\n+     * true rotation matrix and an exception is thrown.<p>\n+\n+     * @param m rotation matrix\n+     * @param threshold convergence threshold for the iterative\n+     * orthogonality correction (convergence is reached when the\n+     * difference between two steps of the Frobenius norm of the\n+     * correction is below this threshold)\n+\n+     * @exception NotARotationMatrixException if the matrix is not a 3X3\n+     * matrix, or if it cannot be transformed into an orthogonal matrix\n+     * with the given threshold, or if the determinant of the resulting\n+     * orthogonal matrix is negative\n+\n+     */\n+    public RotationDS(final DerivativeStructure[][] m, final double threshold)\n+        throws NotARotationMatrixException {\n+\n+        // dimension check\n+        if ((m.length != 3) || (m[0].length != 3) ||\n+                (m[1].length != 3) || (m[2].length != 3)) {\n+            throw new NotARotationMatrixException(\n+                                                  LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n+                                                  m.length, m[0].length);\n+        }\n+\n+        // compute a \"close\" orthogonal matrix\n+        final DerivativeStructure[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+        // check the sign of the determinant\n+        final DerivativeStructure d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\n+        final DerivativeStructure d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\n+        final DerivativeStructure d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\n+        final DerivativeStructure det =\n+                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\n+        if (det.getValue() < 0.0) {\n+            throw new NotARotationMatrixException(\n+                                                  LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n+                                                  det);\n+        }\n+\n+        final DerivativeStructure[] quat = mat2quat(ort);\n+        q0 = quat[0];\n+        q1 = quat[1];\n+        q2 = quat[2];\n+        q3 = quat[3];\n+\n+    }\n+\n+    /** Build the rotation that transforms a pair of vector into another pair.\n+\n+     * <p>Except for possible scale factors, if the instance were applied to\n+     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+     * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+     * not the same as the angular separation between v<sub>1</sub> and\n+     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+     * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+     * v<sub>2</sub>) plane.</p>\n+\n+     * @param u1 first vector of the origin pair\n+     * @param u2 second vector of the origin pair\n+     * @param v1 desired image of u1 by the rotation\n+     * @param v2 desired image of u2 by the rotation\n+     * @exception MathArithmeticException if the norm of one of the vectors is zero,\n+     * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n+     */\n+    public RotationDS(Vector3DDS u1, Vector3DDS u2, Vector3DDS v1, Vector3DDS v2)\n+        throws MathArithmeticException {\n+\n+        // build orthonormalized base from u1, u2\n+        // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+        final Vector3DDS u3 = u1.crossProduct(u2).normalize();\n+        u2 = u3.crossProduct(u1).normalize();\n+        u1 = u1.normalize();\n+\n+        // build an orthonormalized base from v1, v2\n+        // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+        final Vector3DDS v3 = v1.crossProduct(v2).normalize();\n+        v2 = v3.crossProduct(v1).normalize();\n+        v1 = v1.normalize();\n+\n+        // buid a matrix transforming the first base into the second one\n+        final DerivativeStructure[][] m = new DerivativeStructure[][] {\n+            {\n+                MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n+                MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n+                MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n+            },\n+            {\n+                MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n+                MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n+                MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n+            },\n+            {\n+                MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n+                MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n+                MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n+            }\n+        };\n+\n+        DerivativeStructure[] quat = mat2quat(m);\n+        q0 = quat[0];\n+        q1 = quat[1];\n+        q2 = quat[2];\n+        q3 = quat[3];\n+\n+    }\n+\n+    /** Build one of the rotations that transform one vector into another one.\n+\n+     * <p>Except for a possible scale factor, if the instance were\n+     * applied to the vector u it will produce the vector v. There is an\n+     * infinite number of such rotations, this constructor choose the\n+     * one with the smallest associated angle (i.e. the one whose axis\n+     * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+     * arbitrary rotation axis is chosen.</p>\n+\n+     * @param u origin vector\n+     * @param v desired image of u by the rotation\n+     * @exception MathArithmeticException if the norm of one of the vectors is zero\n+     */\n+    public RotationDS(final Vector3DDS u, final Vector3DDS v) throws MathArithmeticException {\n+\n+        final DerivativeStructure normProduct = u.getNorm().multiply(v.getNorm());\n+        if (normProduct.getValue() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+        }\n+\n+        final DerivativeStructure dot = u.dotProduct(v);\n+\n+        if (dot.getValue() < ((2.0e-15 - 1.0) * normProduct.getValue())) {\n+            // special case u = -v: we select a PI angle rotation around\n+            // an arbitrary vector orthogonal to u\n+            final Vector3DDS w = u.orthogonal();\n+            q0 = normProduct.getField().getZero();\n+            q1 = w.getX().negate();\n+            q2 = w.getY().negate();\n+            q3 = w.getZ().negate();\n+        } else {\n+            // general case: (u, v) defines a plane, we select\n+            // the shortest possible rotation: axis orthogonal to this plane\n+            q0 = dot.divide(normProduct).add(1.0).multiply(0.5).sqrt();\n+            final DerivativeStructure coeff = q0.multiply(normProduct).multiply(2.0).reciprocal();\n+            final Vector3DDS q = v.crossProduct(u);\n+            q1 = coeff.multiply(q.getX());\n+            q2 = coeff.multiply(q.getY());\n+            q3 = coeff.multiply(q.getZ());\n+        }\n+\n+    }\n+\n+    /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+     * <p>Cardan rotations are three successive rotations around the\n+     * canonical axes X, Y and Z, each axis being used once. There are\n+     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+     * rotations are three successive rotations around the canonical\n+     * axes X, Y and Z, the first and last rotations being around the\n+     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+     * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+     * <p>Beware that many people routinely use the term Euler angles even\n+     * for what really are Cardan angles (this confusion is especially\n+     * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+     * are often wrongly tagged as Euler angles).</p>\n+\n+     * @param order order of rotations to use\n+     * @param alpha1 angle of the first elementary rotation\n+     * @param alpha2 angle of the second elementary rotation\n+     * @param alpha3 angle of the third elementary rotation\n+     */\n+    public RotationDS(final RotationOrder order, final DerivativeStructure alpha1,\n+                      final DerivativeStructure alpha2, final DerivativeStructure alpha3) {\n+        final int p = alpha1.getFreeParameters();\n+        final int o  = alpha1.getOrder();\n+        final RotationDS r1 =\n+                new RotationDS(new Vector3DDS(new DerivativeStructure(p, o, order.getA1().getX()),\n+                                              new DerivativeStructure(p, o, order.getA1().getY()),\n+                                              new DerivativeStructure(p, o, order.getA1().getZ())),\n+                                              alpha1);\n+        final RotationDS r2 =\n+                new RotationDS(new Vector3DDS(new DerivativeStructure(p, o, order.getA2().getX()),\n+                                              new DerivativeStructure(p, o, order.getA2().getY()),\n+                                              new DerivativeStructure(p, o, order.getA2().getZ())),\n+                                              alpha2);\n+        final RotationDS r3 =\n+                new RotationDS(new Vector3DDS(new DerivativeStructure(p, o, order.getA3().getX()),\n+                                              new DerivativeStructure(p, o, order.getA3().getY()),\n+                                              new DerivativeStructure(p, o, order.getA3().getZ())),\n+                                              alpha3);\n+        final RotationDS composed = r1.applyTo(r2.applyTo(r3));\n+        q0 = composed.q0;\n+        q1 = composed.q1;\n+        q2 = composed.q2;\n+        q3 = composed.q3;\n+    }\n+\n+    /** Convert an orthogonal rotation matrix to a quaternion.\n+     * @param ort orthogonal rotation matrix\n+     * @return quaternion corresponding to the matrix\n+     */\n+    private static DerivativeStructure[] mat2quat(final DerivativeStructure[][] ort) {\n+\n+        final DerivativeStructure[] quat = new DerivativeStructure[4];\n+\n+        // There are different ways to compute the quaternions elements\n+        // from the matrix. They all involve computing one element from\n+        // the diagonal of the matrix, and computing the three other ones\n+        // using a formula involving a division by the first element,\n+        // which unfortunately can be zero. Since the norm of the\n+        // quaternion is 1, we know at least one element has an absolute\n+        // value greater or equal to 0.5, so it is always possible to\n+        // select the right formula and avoid division by zero and even\n+        // numerical inaccuracy. Checking the elements in turn and using\n+        // the first one greater than 0.45 is safe (this leads to a simple\n+        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+        DerivativeStructure s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\n+        if (s.getValue() > -0.19) {\n+            // compute q0 and deduce q1, q2 and q3\n+            quat[0] = s.add(1.0).sqrt().multiply(0.5);\n+            DerivativeStructure inv = quat[0].reciprocal().multiply(0.25);\n+            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n+            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n+            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n+        } else {\n+            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\n+            if (s.getValue() > -0.19) {\n+                // compute q1 and deduce q0, q2 and q3\n+                quat[1] = s.add(1.0).sqrt().multiply(0.5);\n+                DerivativeStructure inv = quat[1].reciprocal().multiply(0.25);\n+                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\n+                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\n+                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\n+            } else {\n+                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\n+                if (s.getValue() > -0.19) {\n+                    // compute q2 and deduce q0, q1 and q3\n+                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\n+                    DerivativeStructure inv = quat[2].reciprocal().multiply(0.25);\n+                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\n+                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\n+                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\n+                } else {\n+                    // compute q3 and deduce q0, q1 and q2\n+                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\n+                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\n+                    DerivativeStructure inv = quat[3].reciprocal().multiply(0.25);\n+                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\n+                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\n+                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\n+                }\n+            }\n+        }\n+\n+        return quat;\n+\n+    }\n+\n+    /** Revert a rotation.\n+     * Build a rotation which reverse the effect of another\n+     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n+     * instance is not changed.\n+     * @return a new rotation whose effect is the reverse of the effect\n+     * of the instance\n+     */\n+    public RotationDS revert() {\n+        return new RotationDS(q0.negate(), q1, q2, q3, false);\n+    }\n+\n+    /** Get the scalar coordinate of the quaternion.\n+     * @return scalar coordinate of the quaternion\n+     */\n+    public DerivativeStructure getQ0() {\n+        return q0;\n+    }\n+\n+    /** Get the first coordinate of the vectorial part of the quaternion.\n+     * @return first coordinate of the vectorial part of the quaternion\n+     */\n+    public DerivativeStructure getQ1() {\n+        return q1;\n+    }\n+\n+    /** Get the second coordinate of the vectorial part of the quaternion.\n+     * @return second coordinate of the vectorial part of the quaternion\n+     */\n+    public DerivativeStructure getQ2() {\n+        return q2;\n+    }\n+\n+    /** Get the third coordinate of the vectorial part of the quaternion.\n+     * @return third coordinate of the vectorial part of the quaternion\n+     */\n+    public DerivativeStructure getQ3() {\n+        return q3;\n+    }\n+\n+    /** Get the normalized axis of the rotation.\n+     * @return normalized axis of the rotation\n+     * @see #Rotation(Vector3DDS, DerivativeStructure)\n+     */\n+    public Vector3DDS getAxis() {\n+        final DerivativeStructure squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n+        if (squaredSine.getValue() == 0) {\n+            final Field<DerivativeStructure> field = squaredSine.getField();\n+            return new Vector3DDS(field.getOne(), field.getZero(), field.getZero());\n+        } else if (q0.getValue() < 0) {\n+            DerivativeStructure inverse = squaredSine.sqrt().reciprocal();\n+            return new Vector3DDS(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n+        }\n+        final DerivativeStructure inverse = squaredSine.sqrt().reciprocal().negate();\n+        return new Vector3DDS(q1.multiply(inverse), q2.multiply(inverse), q3.multiply(inverse));\n+    }\n+\n+    /** Get the angle of the rotation.\n+     * @return angle of the rotation (between 0 and &pi;)\n+     * @see #Rotation(Vector3DDS, DerivativeStructure)\n+     */\n+    public DerivativeStructure getAngle() {\n+        if ((q0.getValue() < -0.1) || (q0.getValue() > 0.1)) {\n+            return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);\n+        } else if (q0.getValue() < 0) {\n+            return q0.negate().acos().multiply(2);\n+        }\n+        return q0.acos().multiply(2);\n+    }\n+\n+    /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+     * <p>The equations show that each rotation can be defined by two\n+     * different values of the Cardan or Euler angles set. For example\n+     * if Cardan angles are used, the rotation defined by the angles\n+     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+     * the following arbitrary choices:</p>\n+     * <ul>\n+     *   <li>for Cardan angles, the chosen set is the one for which the\n+     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n+     *   positive),</li>\n+     *   <li>for Euler angles, the chosen set is the one for which the\n+     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n+     * </ul>\n+\n+     * <p>Cardan and Euler angle have a very disappointing drawback: all\n+     * of them have singularities. This means that if the instance is\n+     * too close to the singularities corresponding to the given\n+     * rotation order, it will be impossible to retrieve the angles. For\n+     * Cardan angles, this is often called gimbal lock. There is\n+     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n+     * with Cardan and Euler representation (but not a problem with the\n+     * rotation itself, which is perfectly well defined). For Cardan\n+     * angles, singularities occur when the second angle is close to\n+     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+     * second angle is close to 0 or &pi;, this implies that the identity\n+     * rotation is always singular for Euler angles!</p>\n+\n+     * @param order rotation order to use\n+     * @return an array of three angles, in the order specified by the set\n+     * @exception CardanEulerSingularityException if the rotation is\n+     * singular with respect to the angles set specified\n+     */\n+    public DerivativeStructure[] getAngles(final RotationOrder order)\n+        throws CardanEulerSingularityException {\n+\n+        if (order == RotationOrder.XYZ) {\n+\n+            // r (+K) coordinates are :\n+            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+            // (-r) (+I) coordinates are :\n+            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+            Vector3DDS v1 = applyTo(vector(0, 0, 1));\n+            final Vector3DDS v2 = applyInverseTo(vector(1, 0, 0));\n+            if  ((v2.getZ().getValue() < -0.9999999999) || (v2.getZ().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getY().negate(), v1.getZ()),\n+                v2.getZ().asin(),\n+                DerivativeStructure.atan2(v2.getY().negate(), v2.getX())\n+            };\n+\n+        } else if (order == RotationOrder.XZY) {\n+\n+            // r (+J) coordinates are :\n+            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+            // (-r) (+I) coordinates are :\n+            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+            final Vector3DDS v1 = applyTo(vector(0, 1, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getY().getValue() < -0.9999999999) || (v2.getY().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getZ(), v1.getY()),\n+                v2.getY().asin().negate(),\n+                DerivativeStructure.atan2(v2.getZ(), v2.getX())\n+            };\n+\n+        } else if (order == RotationOrder.YXZ) {\n+\n+            // r (+K) coordinates are :\n+            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+            final Vector3DDS v1 = applyTo(vector(0, 0, 1));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getZ().getValue() < -0.9999999999) || (v2.getZ().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getX(), v1.getZ()),\n+                v2.getZ().asin().negate(),\n+                DerivativeStructure.atan2(v2.getX(), v2.getY())\n+            };\n+\n+        } else if (order == RotationOrder.YZX) {\n+\n+            // r (+I) coordinates are :\n+            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+            final Vector3DDS v1 = applyTo(vector(1, 0, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getX().getValue() < -0.9999999999) || (v2.getX().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getZ().negate(), v1.getX()),\n+                v2.getX().asin(),\n+                DerivativeStructure.atan2(v2.getZ().negate(), v2.getY())\n+            };\n+\n+        } else if (order == RotationOrder.ZXY) {\n+\n+            // r (+J) coordinates are :\n+            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+            final Vector3DDS v1 = applyTo(vector(0, 1, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getY().getValue() < -0.9999999999) || (v2.getY().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getX().negate(), v1.getY()),\n+                v2.getY().asin(),\n+                DerivativeStructure.atan2(v2.getX().negate(), v2.getZ())\n+            };\n+\n+        } else if (order == RotationOrder.ZYX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+            final Vector3DDS v1 = applyTo(vector(1, 0, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getX().getValue() < -0.9999999999) || (v2.getX().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(true);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getY(), v1.getX()),\n+                v2.getX().asin().negate(),\n+                DerivativeStructure.atan2(v2.getY(), v2.getZ())\n+            };\n+\n+        } else if (order == RotationOrder.XYX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+            // (-r) (+I) coordinates are :\n+            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+            // and we can choose to have theta in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(1, 0, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getX().getValue() < -0.9999999999) || (v2.getX().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getY(), v1.getZ().negate()),\n+                v2.getX().acos(),\n+                DerivativeStructure.atan2(v2.getY(), v2.getZ())\n+            };\n+\n+        } else if (order == RotationOrder.XZX) {\n+\n+            // r (+I) coordinates are :\n+            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+            // (-r) (+I) coordinates are :\n+            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+            // and we can choose to have psi in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(1, 0, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(1, 0, 0));\n+            if ((v2.getX().getValue() < -0.9999999999) || (v2.getX().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getZ(), v1.getY()),\n+                v2.getX().acos(),\n+                DerivativeStructure.atan2(v2.getZ(), v2.getY().negate())\n+            };\n+\n+        } else if (order == RotationOrder.YXY) {\n+\n+            // r (+J) coordinates are :\n+            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+            // (-r) (+J) coordinates are :\n+            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+            // and we can choose to have phi in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(0, 1, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getY().getValue() < -0.9999999999) || (v2.getY().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getX(), v1.getZ()),\n+                v2.getY().acos(),\n+                DerivativeStructure.atan2(v2.getX(), v2.getZ().negate())\n+            };\n+\n+        } else if (order == RotationOrder.YZY) {\n+\n+            // r (+J) coordinates are :\n+            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+            // (-r) (+J) coordinates are :\n+            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+            // and we can choose to have psi in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(0, 1, 0));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 1, 0));\n+            if ((v2.getY().getValue() < -0.9999999999) || (v2.getY().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getZ(), v1.getX().negate()),\n+                v2.getY().acos(),\n+                DerivativeStructure.atan2(v2.getZ(), v2.getX())\n+            };\n+\n+        } else if (order == RotationOrder.ZXZ) {\n+\n+            // r (+K) coordinates are :\n+            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+            // (-r) (+K) coordinates are :\n+            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+            // and we can choose to have phi in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(0, 0, 1));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getZ().getValue() < -0.9999999999) || (v2.getZ().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getX(), v1.getY().negate()),\n+                v2.getZ().acos(),\n+                DerivativeStructure.atan2(v2.getX(), v2.getY())\n+            };\n+\n+        } else { // last possibility is ZYZ\n+\n+            // r (+K) coordinates are :\n+            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+            // (-r) (+K) coordinates are :\n+            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+            // and we can choose to have theta in the interval [0 ; PI]\n+            final Vector3DDS v1 = applyTo(vector(0, 0, 1));\n+            final Vector3DDS v2 = applyInverseTo(vector(0, 0, 1));\n+            if ((v2.getZ().getValue() < -0.9999999999) || (v2.getZ().getValue() > 0.9999999999)) {\n+                throw new CardanEulerSingularityException(false);\n+            }\n+            return new DerivativeStructure[] {\n+                DerivativeStructure.atan2(v1.getY(), v1.getX()),\n+                v2.getZ().acos(),\n+                DerivativeStructure.atan2(v2.getY(), v2.getX().negate())\n+            };\n+\n+        }\n+\n+    }\n+\n+    /** Create a constant vector with appropriate derivation parameters.\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @return a constant vector\n+     */\n+    private Vector3DDS vector(final double x, final double y, final double z) {\n+        final int parameters = q0.getFreeParameters();\n+        final int order      = q0.getOrder();\n+        return new Vector3DDS(new DerivativeStructure(parameters, order, x),\n+                              new DerivativeStructure(parameters, order, y),\n+                              new DerivativeStructure(parameters, order, z));\n+    }\n+\n+    /** Get the 3X3 matrix corresponding to the instance\n+     * @return the matrix corresponding to the instance\n+     */\n+    public DerivativeStructure[][] getMatrix() {\n+\n+        // products\n+        final DerivativeStructure q0q0  = q0.multiply(q0);\n+        final DerivativeStructure q0q1  = q0.multiply(q1);\n+        final DerivativeStructure q0q2  = q0.multiply(q2);\n+        final DerivativeStructure q0q3  = q0.multiply(q3);\n+        final DerivativeStructure q1q1  = q1.multiply(q1);\n+        final DerivativeStructure q1q2  = q1.multiply(q2);\n+        final DerivativeStructure q1q3  = q1.multiply(q3);\n+        final DerivativeStructure q2q2  = q2.multiply(q2);\n+        final DerivativeStructure q2q3  = q2.multiply(q3);\n+        final DerivativeStructure q3q3  = q3.multiply(q3);\n+\n+        // create the matrix\n+        final DerivativeStructure[][] m = new DerivativeStructure[3][];\n+        m[0] = new DerivativeStructure[3];\n+        m[1] = new DerivativeStructure[3];\n+        m[2] = new DerivativeStructure[3];\n+\n+        m [0][0] = q0q0.add(q1q1).multiply(2).subtract(1);\n+        m [1][0] = q1q2.subtract(q0q3).multiply(2);\n+        m [2][0] = q1q3.add(q0q2).multiply(2);\n+\n+        m [0][1] = q1q2.add(q0q3).multiply(2);\n+        m [1][1] = q0q0.add(q2q2).multiply(2).subtract(1);\n+        m [2][1] = q2q3.subtract(q0q1).multiply(2);\n+\n+        m [0][2] = q1q3.subtract(q0q2).multiply(2);\n+        m [1][2] = q2q3.add(q0q1).multiply(2);\n+        m [2][2] = q0q0.add(q3q3).multiply(2).subtract(1);\n+\n+        return m;\n+\n+    }\n+\n+    /** Apply the rotation to a vector.\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public Vector3DDS applyTo(final Vector3DDS u) {\n+\n+        final DerivativeStructure x = u.getX();\n+        final DerivativeStructure y = u.getY();\n+        final DerivativeStructure z = u.getZ();\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        return new Vector3DDS(q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                              q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                              q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the rotation to a vector.\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public Vector3DDS applyTo(final Vector3D u) {\n+\n+        final double x = u.getX();\n+        final double y = u.getY();\n+        final double z = u.getZ();\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        return new Vector3DDS(q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                              q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                              q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to (it can be the same\n+     * array as in)\n+     */\n+    public void applyTo(final DerivativeStructure[] in, final DerivativeStructure[] out) {\n+\n+        final DerivativeStructure x = in[0];\n+        final DerivativeStructure y = in[1];\n+        final DerivativeStructure z = in[2];\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        out[0] = q0.multiply(x.multiply(q0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = q0.multiply(y.multiply(q0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = q0.multiply(z.multiply(q0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to\n+     */\n+    public void applyTo(final double[] in, final DerivativeStructure[] out) {\n+\n+        final double x = in[0];\n+        final double y = in[1];\n+        final double z = in[2];\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+\n+        out[0] = q0.multiply(q0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = q0.multiply(q0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = q0.multiply(q0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply a rotation to a vector.\n+     * @param r rotation to apply\n+     * @param u vector to apply the rotation to\n+     * @return a new vector which is the image of u by the rotation\n+     */\n+    public static Vector3DDS applyTo(final Rotation r, final Vector3DDS u) {\n+\n+        final DerivativeStructure x = u.getX();\n+        final DerivativeStructure y = u.getY();\n+        final DerivativeStructure z = u.getZ();\n+\n+        final DerivativeStructure s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n+\n+        return new Vector3DDS(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n+                              y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n+                              z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector.\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public Vector3DDS applyInverseTo(final Vector3DDS u) {\n+\n+        final DerivativeStructure x = u.getX();\n+        final DerivativeStructure y = u.getY();\n+        final DerivativeStructure z = u.getZ();\n+\n+        final DerivativeStructure s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final DerivativeStructure m0 = q0.negate();\n+\n+        return new Vector3DDS(m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                              m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                              m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector.\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public Vector3DDS applyInverseTo(final Vector3D u) {\n+\n+        final double x = u.getX();\n+        final double y = u.getY();\n+        final double z = u.getZ();\n+\n+        final DerivativeStructure s  = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final DerivativeStructure m0 = q0.negate();\n+\n+        return new Vector3DDS(m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x),\n+                              m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y),\n+                              m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to (it can be the same\n+     * array as in)\n+     */\n+    public void applyInverseTo(final DerivativeStructure[] in, final DerivativeStructure[] out) {\n+\n+        final DerivativeStructure x = in[0];\n+        final DerivativeStructure y = in[1];\n+        final DerivativeStructure z = in[2];\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final DerivativeStructure m0 = q0.negate();\n+\n+        out[0] = m0.multiply(x.multiply(m0).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = m0.multiply(y.multiply(m0).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = m0.multiply(z.multiply(m0).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the inverse of the rotation to a vector stored in an array.\n+     * @param in an array with three items which stores vector to rotate\n+     * @param out an array with three items to put result to\n+     */\n+    public void applyInverseTo(final double[] in, final DerivativeStructure[] out) {\n+\n+        final double x = in[0];\n+        final double y = in[1];\n+        final double z = in[2];\n+\n+        final DerivativeStructure s = q1.multiply(x).add(q2.multiply(y)).add(q3.multiply(z));\n+        final DerivativeStructure m0 = q0.negate();\n+\n+        out[0] = m0.multiply(m0.multiply(x).subtract(q2.multiply(z).subtract(q3.multiply(y)))).add(s.multiply(q1)).multiply(2).subtract(x);\n+        out[1] = m0.multiply(m0.multiply(y).subtract(q3.multiply(x).subtract(q1.multiply(z)))).add(s.multiply(q2)).multiply(2).subtract(y);\n+        out[2] = m0.multiply(m0.multiply(z).subtract(q1.multiply(y).subtract(q2.multiply(x)))).add(s.multiply(q3)).multiply(2).subtract(z);\n+\n+    }\n+\n+    /** Apply the inverse of a rotation to a vector.\n+     * @param r rotation to apply\n+     * @param u vector to apply the inverse of the rotation to\n+     * @return a new vector which such that u is its image by the rotation\n+     */\n+    public static Vector3DDS applyInverseTo(final Rotation r, final Vector3DDS u) {\n+\n+        final DerivativeStructure x = u.getX();\n+        final DerivativeStructure y = u.getY();\n+        final DerivativeStructure z = u.getZ();\n+\n+        final DerivativeStructure s  = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n+        final double m0 = -r.getQ0();\n+\n+        return new Vector3DDS(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x),\n+                              y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y),\n+                              z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n+\n+    }\n+\n+    /** Apply the instance to another rotation.\n+     * Applying the instance to a rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+     * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public RotationDS applyTo(final RotationDS r) {\n+        return new RotationDS(r.q0.multiply(q0).subtract(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))),\n+                              r.q1.multiply(q0).add(r.q0.multiply(q1)).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))),\n+                              r.q2.multiply(q0).add(r.q0.multiply(q2)).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))),\n+                              r.q3.multiply(q0).add(r.q0.multiply(q3)).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))),\n+                              false);\n+    }\n+\n+    /** Apply the instance to another rotation.\n+     * Applying the instance to a rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+     * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public RotationDS applyTo(final Rotation r) {\n+        return new RotationDS(q0.multiply(r.getQ0()).subtract(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))),\n+                              q0.multiply(r.getQ1()).add(q1.multiply(r.getQ0())).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))),\n+                              q0.multiply(r.getQ2()).add(q2.multiply(r.getQ0())).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))),\n+                              q0.multiply(r.getQ3()).add(q3.multiply(r.getQ0())).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))),\n+                              false);\n+    }\n+\n+    /** Apply a rotation to another rotation.\n+     * Applying a rotation to another rotation is computing the composition\n+     * in an order compliant with the following rule : let u be any\n+     * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n+     * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n+     * where comp = applyTo(rOuter, rInner).\n+     * @param r1 rotation to apply\n+     * @param rInner rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the instance\n+     */\n+    public static RotationDS applyTo(final Rotation r1, final RotationDS rInner) {\n+        return new RotationDS(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n+                              rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n+                              rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n+                              rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))),\n+                              false);\n+    }\n+\n+    /** Apply the inverse of the instance to another rotation.\n+     * Applying the inverse of the instance to a rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+     * let w be the inverse image of v by the instance\n+     * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public RotationDS applyInverseTo(final RotationDS r) {\n+        return new RotationDS(r.q0.multiply(q0).add(r.q1.multiply(q1).add(r.q2.multiply(q2)).add(r.q3.multiply(q3))).negate(),\n+                              r.q0.multiply(q1).add(r.q2.multiply(q3).subtract(r.q3.multiply(q2))).subtract(r.q1.multiply(q0)),\n+                              r.q0.multiply(q2).add(r.q3.multiply(q1).subtract(r.q1.multiply(q3))).subtract(r.q2.multiply(q0)),\n+                              r.q0.multiply(q3).add(r.q1.multiply(q2).subtract(r.q2.multiply(q1))).subtract(r.q3.multiply(q0)),\n+                              false);\n+    }\n+\n+    /** Apply the inverse of the instance to another rotation.\n+     * Applying the inverse of the instance to a rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+     * let w be the inverse image of v by the instance\n+     * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(r).\n+     * @param r rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public RotationDS applyInverseTo(final Rotation r) {\n+        return new RotationDS(q0.multiply(r.getQ0()).add(q1.multiply(r.getQ1()).add(q2.multiply(r.getQ2())).add(q3.multiply(r.getQ3()))).negate(),\n+                              q1.multiply(r.getQ0()).add(q3.multiply(r.getQ2()).subtract(q2.multiply(r.getQ3()))).subtract(q0.multiply(r.getQ1())),\n+                              q2.multiply(r.getQ0()).add(q1.multiply(r.getQ3()).subtract(q3.multiply(r.getQ1()))).subtract(q0.multiply(r.getQ2())),\n+                              q3.multiply(r.getQ0()).add(q2.multiply(r.getQ1()).subtract(q1.multiply(r.getQ2()))).subtract(q0.multiply(r.getQ3())),\n+                              false);\n+    }\n+\n+    /** Apply the inverse of a rotation to another rotation.\n+     * Applying the inverse of a rotation to another rotation is computing\n+     * the composition in an order compliant with the following rule :\n+     * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n+     * let w be the inverse image of v by rOuter\n+     * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+     * comp = applyInverseTo(rOuter, rInner).\n+     * @param rOuter rotation to apply the rotation to\n+     * @param rInner rotation to apply the rotation to\n+     * @return a new rotation which is the composition of r by the inverse\n+     * of the instance\n+     */\n+    public static RotationDS applyInverseTo(final Rotation rOuter, final RotationDS rInner) {\n+        return new RotationDS(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n+                              rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n+                              rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n+                              rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())),\n+                              false);\n+    }\n+\n+    /** Perfect orthogonality on a 3X3 matrix.\n+     * @param m initial matrix (not exactly orthogonal)\n+     * @param threshold convergence threshold for the iterative\n+     * orthogonality correction (convergence is reached when the\n+     * difference between two steps of the Frobenius norm of the\n+     * correction is below this threshold)\n+     * @return an orthogonal matrix close to m\n+     * @exception NotARotationMatrixException if the matrix cannot be\n+     * orthogonalized with the given threshold after 10 iterations\n+     */\n+    private DerivativeStructure[][] orthogonalizeMatrix(final DerivativeStructure[][] m,\n+                                                        final double threshold)\n+        throws NotARotationMatrixException {\n+\n+        DerivativeStructure x00 = m[0][0];\n+        DerivativeStructure x01 = m[0][1];\n+        DerivativeStructure x02 = m[0][2];\n+        DerivativeStructure x10 = m[1][0];\n+        DerivativeStructure x11 = m[1][1];\n+        DerivativeStructure x12 = m[1][2];\n+        DerivativeStructure x20 = m[2][0];\n+        DerivativeStructure x21 = m[2][1];\n+        DerivativeStructure x22 = m[2][2];\n+        double fn = 0;\n+        double fn1;\n+\n+        final DerivativeStructure[][] o = new DerivativeStructure[3][3];\n+\n+        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+        int i = 0;\n+        while (++i < 11) {\n+\n+            // Mt.Xn\n+            final DerivativeStructure mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\n+            final DerivativeStructure mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\n+            final DerivativeStructure mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\n+            final DerivativeStructure mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\n+            final DerivativeStructure mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\n+            final DerivativeStructure mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\n+            final DerivativeStructure mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\n+            final DerivativeStructure mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\n+            final DerivativeStructure mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\n+\n+            // Xn+1\n+            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\n+            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\n+            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\n+            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\n+            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\n+            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\n+            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\n+            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\n+            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\n+\n+            // correction on each elements\n+            final double corr00 = o[0][0].getValue() - m[0][0].getValue();\n+            final double corr01 = o[0][1].getValue() - m[0][1].getValue();\n+            final double corr02 = o[0][2].getValue() - m[0][2].getValue();\n+            final double corr10 = o[1][0].getValue() - m[1][0].getValue();\n+            final double corr11 = o[1][1].getValue() - m[1][1].getValue();\n+            final double corr12 = o[1][2].getValue() - m[1][2].getValue();\n+            final double corr20 = o[2][0].getValue() - m[2][0].getValue();\n+            final double corr21 = o[2][1].getValue() - m[2][1].getValue();\n+            final double corr22 = o[2][2].getValue() - m[2][2].getValue();\n+\n+            // Frobenius norm of the correction\n+            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n+                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n+                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+            // convergence test\n+            if (FastMath.abs(fn1 - fn) <= threshold) {\n+                return o;\n+            }\n+\n+            // prepare next iteration\n+            x00 = o[0][0];\n+            x01 = o[0][1];\n+            x02 = o[0][2];\n+            x10 = o[1][0];\n+            x11 = o[1][1];\n+            x12 = o[1][2];\n+            x20 = o[2][0];\n+            x21 = o[2][1];\n+            x22 = o[2][2];\n+            fn  = fn1;\n+\n+        }\n+\n+        // the algorithm did not converge after 10 iterations\n+        throw new NotARotationMatrixException(LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n+                                              i - 1);\n+\n+    }\n+\n+    /** Compute the <i>distance</i> between two rotations.\n+     * <p>The <i>distance</i> is intended here as a way to check if two\n+     * rotations are almost similar (i.e. they transform vectors the same way)\n+     * or very different. It is mathematically defined as the angle of\n+     * the rotation r that prepended to one of the rotations gives the other\n+     * one:</p>\n+     * <pre>\n+     *        r<sub>1</sub>(r) = r<sub>2</sub>\n+     * </pre>\n+     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+     * reached for some v. The distance is equal to 0 if and only if the two\n+     * rotations are identical.</p>\n+     * <p>Comparing two rotations should always be done using this value rather\n+     * than for example comparing the components of the quaternions. It is much\n+     * more stable, and has a geometric meaning. Also comparing quaternions\n+     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+     * their components are different (they are exact opposites).</p>\n+     * @param r1 first rotation\n+     * @param r2 second rotation\n+     * @return <i>distance</i> between r1 and r2\n+     */\n+    public static DerivativeStructure distance(final RotationDS r1, final RotationDS r2) {\n+        return r1.applyInverseTo(r2).getAngle();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DDS.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.io.Serializable;\n+import java.text.NumberFormat;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * This class is a re-implementation of {@link Vector3D} using {@link DerivativeStructure}.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class Vector3DDS implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20130214L;\n+\n+    /** Abscissa. */\n+    private final DerivativeStructure x;\n+\n+    /** Ordinate. */\n+    private final DerivativeStructure y;\n+\n+    /** Height. */\n+    private final DerivativeStructure z;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @see #getX()\n+     * @see #getY()\n+     * @see #getZ()\n+     */\n+    public Vector3DDS(final DerivativeStructure x,\n+                      final DerivativeStructure y,\n+                      final DerivativeStructure z) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param v coordinates array\n+     * @exception DimensionMismatchException if array does not have 3 elements\n+     * @see #toArray()\n+     */\n+    public Vector3DDS(final DerivativeStructure[] v) throws DimensionMismatchException {\n+        if (v.length != 3) {\n+            throw new DimensionMismatchException(v.length, 3);\n+        }\n+        this.x = v[0];\n+        this.y = v[1];\n+        this.z = v[2];\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its azimuthal coordinates\n+     * @param alpha azimuth (&alpha;) around Z\n+     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+     * @see #getAlpha()\n+     * @see #getDelta()\n+     */\n+    public Vector3DDS(final DerivativeStructure alpha, final DerivativeStructure delta) {\n+        DerivativeStructure cosDelta = delta.cos();\n+        this.x = alpha.cos().multiply(cosDelta);\n+        this.y = alpha.sin().multiply(cosDelta);\n+        this.z = delta.sin();\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a, final Vector3DDS u) {\n+        this.x = a.multiply(u.x);\n+        this.y = a.multiply(u.y);\n+        this.z = a.multiply(u.z);\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a, final Vector3D u) {\n+        this.x = a.multiply(u.getX());\n+        this.y = a.multiply(u.getY());\n+        this.z = a.multiply(u.getZ());\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector3DDS(final double a, final Vector3DDS u) {\n+        this.x = u.x.multiply(a);\n+        this.y = u.y.multiply(a);\n+        this.z = u.z.multiply(a);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3DDS u1,\n+                      final DerivativeStructure a2, final Vector3DDS u2) {\n+        this.x = a1.multiply(u1.x).add(a2.multiply(u2.x));\n+        this.y = a1.multiply(u1.y).add(a2.multiply(u2.y));\n+        this.z = a1.multiply(u1.z).add(a2.multiply(u2.z));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3D u1,\n+                      final DerivativeStructure a2, final Vector3D u2) {\n+        this.x = a1.multiply(u1.getX()).add(a2.multiply(u2.getX()));\n+        this.y = a1.multiply(u1.getY()).add(a2.multiply(u2.getY()));\n+        this.z = a1.multiply(u1.getZ()).add(a2.multiply(u2.getZ()));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector3DDS(final double a1, final Vector3DDS u1,\n+                      final double a2, final Vector3DDS u2) {\n+        this.x = u1.x.multiply(a1).add(u2.x.multiply(a2));\n+        this.y = u1.y.multiply(a1).add(u2.y.multiply(a2));\n+        this.z = u1.z.multiply(a1).add(u2.z.multiply(a2));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3DDS u1,\n+                      final DerivativeStructure a2, final Vector3DDS u2,\n+                      final DerivativeStructure a3, final Vector3DDS u3) {\n+        this.x = a1.multiply(u1.x).add(a2.multiply(u2.x)).add(a3.multiply(u3.x));\n+        this.y = a1.multiply(u1.y).add(a2.multiply(u2.y)).add(a3.multiply(u3.y));\n+        this.z = a1.multiply(u1.z).add(a2.multiply(u2.z)).add(a3.multiply(u3.z));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3D u1,\n+                      final DerivativeStructure a2, final Vector3D u2,\n+                      final DerivativeStructure a3, final Vector3D u3) {\n+        this.x = a1.multiply(u1.getX()).add(a2.multiply(u2.getX())).add(a3.multiply(u3.getX()));\n+        this.y = a1.multiply(u1.getY()).add(a2.multiply(u2.getY())).add(a3.multiply(u3.getY()));\n+        this.z = a1.multiply(u1.getZ()).add(a2.multiply(u2.getZ())).add(a3.multiply(u3.getZ()));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector3DDS(final double a1, final Vector3DDS u1,\n+                      final double a2, final Vector3DDS u2,\n+                      final double a3, final Vector3DDS u3) {\n+        this.x = u1.x.multiply(a1).add(u2.x.multiply(a2)).add(u3.x.multiply(a3));\n+        this.y = u1.y.multiply(a1).add(u2.y.multiply(a2)).add(u3.y.multiply(a3));\n+        this.z = u1.z.multiply(a1).add(u2.z.multiply(a2)).add(u3.z.multiply(a3));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3DDS u1,\n+                      final DerivativeStructure a2, final Vector3DDS u2,\n+                      final DerivativeStructure a3, final Vector3DDS u3,\n+                      final DerivativeStructure a4, final Vector3DDS u4) {\n+        this.x = a1.multiply(u1.x).add(a2.multiply(u2.x)).add(a3.multiply(u3.x)).add(a4.multiply(u4.x));\n+        this.y = a1.multiply(u1.y).add(a2.multiply(u2.y)).add(a3.multiply(u3.y)).add(a4.multiply(u4.y));\n+        this.z = a1.multiply(u1.z).add(a2.multiply(u2.z)).add(a3.multiply(u3.z)).add(a4.multiply(u4.z));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector3DDS(final DerivativeStructure a1, final Vector3D u1,\n+                      final DerivativeStructure a2, final Vector3D u2,\n+                      final DerivativeStructure a3, final Vector3D u3,\n+                      final DerivativeStructure a4, final Vector3D u4) {\n+        this.x = a1.multiply(u1.getX()).add(a2.multiply(u2.getX())).add(a3.multiply(u3.getX())).add(a4.multiply(u4.getX()));\n+        this.y = a1.multiply(u1.getY()).add(a2.multiply(u2.getY())).add(a3.multiply(u3.getY())).add(a4.multiply(u4.getY()));\n+        this.z = a1.multiply(u1.getZ()).add(a2.multiply(u2.getZ())).add(a3.multiply(u3.getZ())).add(a4.multiply(u4.getZ()));\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector3DDS(final double a1, final Vector3DDS u1,\n+                      final double a2, final Vector3DDS u2,\n+                      final double a3, final Vector3DDS u3,\n+                      final double a4, final Vector3DDS u4) {\n+        this.x = u1.x.multiply(a1).add(u2.x.multiply(a2)).add(u3.x.multiply(a3)).add(u4.x.multiply(a4));\n+        this.y = u1.y.multiply(a1).add(u2.y.multiply(a2)).add(u3.y.multiply(a3)).add(u4.y.multiply(a4));\n+        this.z = u1.z.multiply(a1).add(u2.z.multiply(a2)).add(u3.z.multiply(a3)).add(u4.z.multiply(a4));\n+    }\n+\n+    /** Get the abscissa of the vector.\n+     * @return abscissa of the vector\n+     * @see #Vector3D(DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     */\n+    public DerivativeStructure getX() {\n+        return x;\n+    }\n+\n+    /** Get the ordinate of the vector.\n+     * @return ordinate of the vector\n+     * @see #Vector3D(DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     */\n+    public DerivativeStructure getY() {\n+        return y;\n+    }\n+\n+    /** Get the height of the vector.\n+     * @return height of the vector\n+     * @see #Vector3D(DerivativeStructure, DerivativeStructure, DerivativeStructure)\n+     */\n+    public DerivativeStructure getZ() {\n+        return z;\n+    }\n+\n+    /** Get the vector coordinates as a dimension 3 array.\n+     * @return vector coordinates\n+     * @see #Vector3D(DerivativeStructure[])\n+     */\n+    public DerivativeStructure[] toArray() {\n+        return new DerivativeStructure[] { x, y, z };\n+    }\n+\n+    /** Convert to a constant vector without derivatives.\n+     * @return a constant vector\n+     */\n+    public Vector3D toVector3D() {\n+        return new Vector3D(x.getValue(), y.getValue(), z.getValue());\n+    }\n+\n+    /** Get the L<sub>1</sub> norm for the vector.\n+     * @return L<sub>1</sub> norm for the vector\n+     */\n+    public DerivativeStructure getNorm1() {\n+        return x.abs().add(y.abs()).add(z.abs());\n+    }\n+\n+    /** Get the L<sub>2</sub> norm for the vector.\n+     * @return Euclidean norm for the vector\n+     */\n+    public DerivativeStructure getNorm() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n+        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\n+    }\n+\n+    /** Get the square of the norm for the vector.\n+     * @return square of the Euclidean norm for the vector\n+     */\n+    public DerivativeStructure getNormSq() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n+        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\n+    }\n+\n+    /** Get the L<sub>&infin;</sub> norm for the vector.\n+     * @return L<sub>&infin;</sub> norm for the vector\n+     */\n+    public DerivativeStructure getNormInf() {\n+        final DerivativeStructure xAbs = x.abs();\n+        final DerivativeStructure yAbs = y.abs();\n+        final DerivativeStructure zAbs = z.abs();\n+        if (xAbs.getValue() <= yAbs.getValue()) {\n+            if (yAbs.getValue() <= zAbs.getValue()) {\n+                return zAbs;\n+            } else {\n+                return yAbs;\n+            }\n+        } else {\n+            if (xAbs.getValue() <= zAbs.getValue()) {\n+                return zAbs;\n+            } else {\n+                return xAbs;\n+            }\n+        }\n+    }\n+\n+    /** Get the azimuth of the vector.\n+     * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+     * @see #Vector3D(DerivativeStructure, DerivativeStructure)\n+     */\n+    public DerivativeStructure getAlpha() {\n+        return DerivativeStructure.atan2(y, x);\n+    }\n+\n+    /** Get the elevation of the vector.\n+     * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+     * @see #Vector3D(DerivativeStructure, DerivativeStructure)\n+     */\n+    public DerivativeStructure getDelta() {\n+        return z.divide(getNorm()).asin();\n+    }\n+\n+    /** Add a vector to the instance.\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final Vector3DDS v) {\n+        return new Vector3DDS(x.add(v.x), y.add(v.y), z.add(v.z));\n+    }\n+\n+    /** Add a vector to the instance.\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final Vector3D v) {\n+        return new Vector3DDS(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final DerivativeStructure factor, final Vector3DDS v) {\n+        return new Vector3DDS(x.add(factor.multiply(v.x)),\n+                              y.add(factor.multiply(v.y)),\n+                              z.add(factor.multiply(v.z)));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final DerivativeStructure factor, final Vector3D v) {\n+        return new Vector3DDS(x.add(factor.multiply(v.getX())),\n+                              y.add(factor.multiply(v.getY())),\n+                              z.add(factor.multiply(v.getZ())));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final double factor, final Vector3DDS v) {\n+        return new Vector3DDS(x.add(v.x.multiply(factor)),\n+                              y.add(v.y.multiply(factor)),\n+                              z.add(v.z.multiply(factor)));\n+    }\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    public Vector3DDS add(final double factor, final Vector3D v) {\n+        return new Vector3DDS(x.add(factor * v.getX()),\n+                              y.add(factor * v.getY()),\n+                              z.add(factor * v.getZ()));\n+    }\n+\n+    /** Subtract a vector from the instance.\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final Vector3DDS v) {\n+        return new Vector3DDS(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));\n+    }\n+\n+    /** Subtract a vector from the instance.\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final Vector3D v) {\n+        return new Vector3DDS(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final DerivativeStructure factor, final Vector3DDS v) {\n+        return new Vector3DDS(x.subtract(factor.multiply(v.x)),\n+                              y.subtract(factor.multiply(v.y)),\n+                              z.subtract(factor.multiply(v.z)));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final DerivativeStructure factor, final Vector3D v) {\n+        return new Vector3DDS(x.subtract(factor.multiply(v.getX())),\n+                              y.subtract(factor.multiply(v.getY())),\n+                              z.subtract(factor.multiply(v.getZ())));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final double factor, final Vector3DDS v) {\n+        return new Vector3DDS(x.subtract(v.x.multiply(factor)),\n+                              y.subtract(v.y.multiply(factor)),\n+                              z.subtract(v.z.multiply(factor)));\n+    }\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    public Vector3DDS subtract(final double factor, final Vector3D v) {\n+        return new Vector3DDS(x.subtract(factor * v.getX()),\n+                              y.subtract(factor * v.getY()),\n+                              z.subtract(factor * v.getZ()));\n+    }\n+\n+    /** Get a normalized vector aligned with the instance.\n+     * @return a new normalized vector\n+     * @exception MathArithmeticException if the norm is zero\n+     */\n+    public Vector3DDS normalize() throws MathArithmeticException {\n+        final DerivativeStructure s = getNorm();\n+        if (s.getValue() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+        }\n+        return scalarMultiply(s.reciprocal());\n+    }\n+\n+    /** Get a vector orthogonal to the instance.\n+     * <p>There are an infinite number of normalized vectors orthogonal\n+     * to the instance. This method picks up one of them almost\n+     * arbitrarily. It is useful when one needs to compute a reference\n+     * frame with one of the axes in a predefined direction. The\n+     * following example shows how to build a frame having the k axis\n+     * aligned with the known vector u :\n+     * <pre><code>\n+     *   Vector3D k = u.normalize();\n+     *   Vector3D i = k.orthogonal();\n+     *   Vector3D j = Vector3D.crossProduct(k, i);\n+     * </code></pre></p>\n+     * @return a new normalized vector orthogonal to the instance\n+     * @exception MathArithmeticException if the norm of the instance is null\n+     */\n+    public Vector3DDS orthogonal() throws MathArithmeticException {\n+\n+        final double threshold = 0.6 * getNorm().getValue();\n+        if (threshold == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        if (FastMath.abs(x.getValue()) <= threshold) {\n+            final DerivativeStructure inverse  = y.multiply(y).add(z.multiply(z)).sqrt().reciprocal();\n+            return new Vector3DDS(inverse.getField().getZero(), inverse.multiply(z), inverse.multiply(y).negate());\n+        } else if (FastMath.abs(y.getValue()) <= threshold) {\n+            final DerivativeStructure inverse  = x.multiply(x).add(z.multiply(z)).sqrt().reciprocal();\n+            return new Vector3DDS(inverse.multiply(z).negate(), inverse.getField().getZero(), inverse.multiply(x));\n+        } else {\n+            final DerivativeStructure inverse  = x.multiply(x).add(y.multiply(y)).sqrt().reciprocal();\n+            return new Vector3DDS(inverse.multiply(y), inverse.multiply(x).negate(), inverse.getField().getZero());\n+        }\n+\n+    }\n+\n+    /** Compute the angular separation between two vectors.\n+     * <p>This method computes the angular separation between two\n+     * vectors using the dot product for well separated vectors and the\n+     * cross product for almost aligned vectors. This allows to have a\n+     * good accuracy in all cases, even for vectors very close to each\n+     * other.</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return angular separation between v1 and v2\n+     * @exception MathArithmeticException if either vector has a null norm\n+     */\n+    public static DerivativeStructure angle(Vector3DDS v1, Vector3DDS v2) throws MathArithmeticException {\n+\n+        final DerivativeStructure normProduct = v1.getNorm().multiply(v2.getNorm());\n+        if (normProduct.getValue() == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        final DerivativeStructure dot = v1.dotProduct(v2);\n+        final double threshold = normProduct.getValue() * 0.9999;\n+        if ((dot.getValue() < -threshold) || (dot.getValue() > threshold)) {\n+            // the vectors are almost aligned, compute using the sine\n+            Vector3DDS v3 = crossProduct(v1, v2);\n+            if (dot.getValue() >= 0) {\n+                return v3.getNorm().divide(normProduct).asin();\n+            }\n+            return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n+        }\n+\n+        // the vectors are sufficiently separated to use the cosine\n+        return dot.divide(normProduct).acos();\n+\n+    }\n+\n+    /** Get the opposite of the instance.\n+     * @return a new vector which is opposite to the instance\n+     */\n+    public Vector3DDS negate() {\n+        return new Vector3DDS(x.negate(), y.negate(), z.negate());\n+    }\n+\n+    /** Multiply the instance by a scalar.\n+     * @param a scalar\n+     * @return a new vector\n+     */\n+    public Vector3DDS scalarMultiply(final DerivativeStructure a) {\n+        return new Vector3DDS(x.multiply(a), y.multiply(a), z.multiply(a));\n+    }\n+\n+    /** Multiply the instance by a scalar.\n+     * @param a scalar\n+     * @return a new vector\n+     */\n+    public Vector3DDS scalarMultiply(final double a) {\n+        return new Vector3DDS(x.multiply(a), y.multiply(a), z.multiply(a));\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(x.getValue()) || Double.isNaN(y.getValue()) || Double.isNaN(z.getValue());\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+        return !isNaN() && (Double.isInfinite(x.getValue()) || Double.isInfinite(y.getValue()) || Double.isInfinite(z.getValue()));\n+    }\n+\n+    /**\n+     * Test for the equality of two 3D vectors.\n+     * <p>\n+     * If all coordinates of two 3D vectors are exactly the same, and none are\n+     * <code>DerivativeStructure.NaN</code>, the two 3D vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * 3D vector are equal to <code>DerivativeStructure.NaN</code>, the 3D vector is equal to\n+     * {@link #NaN}.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     *\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof Vector3DDS) {\n+            final Vector3DDS rhs = (Vector3DDS)other;\n+            if (rhs.isNaN()) {\n+                return this.isNaN();\n+            }\n+\n+            return MathArrays.equals(x.getAllDerivatives(), rhs.x.getAllDerivatives()) &&\n+                   MathArrays.equals(y.getAllDerivatives(), rhs.y.getAllDerivatives()) &&\n+                   MathArrays.equals(z.getAllDerivatives(), rhs.z.getAllDerivatives());\n+\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get a hashCode for the 3D vector.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 409;\n+        }\n+        return 311 * (107 * x.hashCode() + 83 * y.hashCode() +  z.hashCode());\n+    }\n+\n+    /** Compute the dot-product of the instance and another vector.\n+     * <p>\n+     * The implementation uses specific multiplication and addition\n+     * algorithms to preserve accuracy and reduce cancellation effects.\n+     * It should be very accurate even for nearly orthogonal vectors.\n+     * </p>\n+     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n+     * @param v second vector\n+     * @return the dot product this.v\n+     */\n+    public DerivativeStructure dotProduct(final Vector3DDS v) {\n+        return MathArrays.linearCombination(x, v.x, y, v.y, z, v.z);\n+    }\n+\n+    /** Compute the dot-product of the instance and another vector.\n+     * <p>\n+     * The implementation uses specific multiplication and addition\n+     * algorithms to preserve accuracy and reduce cancellation effects.\n+     * It should be very accurate even for nearly orthogonal vectors.\n+     * </p>\n+     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n+     * @param v second vector\n+     * @return the dot product this.v\n+     */\n+    public DerivativeStructure dotProduct(final Vector3D v) {\n+        return MathArrays.linearCombination(v.getX(), x, v.getY(), y, v.getZ(), z);\n+    }\n+\n+    /** Compute the cross-product of the instance with another vector.\n+     * @param v other vector\n+     * @return the cross product this ^ v as a new Vector3D\n+     */\n+    public Vector3DDS crossProduct(final Vector3DDS v) {\n+        return new Vector3DDS(MathArrays.linearCombination(y, v.z, z.negate(), v.y),\n+                              MathArrays.linearCombination(z, v.x, x.negate(), v.z),\n+                              MathArrays.linearCombination(x, v.y, y.negate(), v.x));\n+    }\n+\n+    /** Compute the cross-product of the instance with another vector.\n+     * @param v other vector\n+     * @return the cross product this ^ v as a new Vector3D\n+     */\n+    public Vector3DDS crossProduct(final Vector3D v) {\n+        return new Vector3DDS(MathArrays.linearCombination(v.getZ(), y, v.getY(), z.negate()),\n+                              MathArrays.linearCombination(v.getX(), z, v.getZ(), x.negate()),\n+                              MathArrays.linearCombination(v.getY(), x, v.getX(), y.negate()));\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>1</sub> norm\n+     */\n+    public DerivativeStructure distance1(final Vector3DDS v) {\n+        final DerivativeStructure dx = v.x.subtract(x).abs();\n+        final DerivativeStructure dy = v.y.subtract(y).abs();\n+        final DerivativeStructure dz = v.z.subtract(z).abs();\n+        return dx.add(dy).add(dz);\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>1</sub> norm\n+     */\n+    public DerivativeStructure distance1(final Vector3D v) {\n+        final DerivativeStructure dx = x.subtract(v.getX()).abs();\n+        final DerivativeStructure dy = y.subtract(v.getY()).abs();\n+        final DerivativeStructure dz = z.subtract(v.getZ()).abs();\n+        return dx.add(dy).add(dz);\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>2</sub> norm\n+     */\n+    public DerivativeStructure distance(final Vector3DDS v) {\n+        final DerivativeStructure dx = v.x.subtract(x);\n+        final DerivativeStructure dy = v.y.subtract(y);\n+        final DerivativeStructure dz = v.z.subtract(z);\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>2</sub> norm\n+     */\n+    public DerivativeStructure distance(final Vector3D v) {\n+        final DerivativeStructure dx = x.subtract(v.getX());\n+        final DerivativeStructure dy = y.subtract(v.getY());\n+        final DerivativeStructure dz = z.subtract(v.getZ());\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\n+     */\n+    public DerivativeStructure distanceInf(final Vector3DDS v) {\n+        final DerivativeStructure dx = v.x.subtract(x).abs();\n+        final DerivativeStructure dy = v.y.subtract(y).abs();\n+        final DerivativeStructure dz = v.z.subtract(z).abs();\n+        if (dx.getValue() <= dy.getValue()) {\n+            if (dy.getValue() <= dz.getValue()) {\n+                return dz;\n+            } else {\n+                return dy;\n+            }\n+        } else {\n+            if (dx.getValue() <= dz.getValue()) {\n+                return dz;\n+            } else {\n+                return dx;\n+            }\n+        }\n+    }\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\n+     */\n+    public DerivativeStructure distanceInf(final Vector3D v) {\n+        final DerivativeStructure dx = x.subtract(v.getX()).abs();\n+        final DerivativeStructure dy = y.subtract(v.getY()).abs();\n+        final DerivativeStructure dz = z.subtract(v.getZ()).abs();\n+        if (dx.getValue() <= dy.getValue()) {\n+            if (dy.getValue() <= dz.getValue()) {\n+                return dz;\n+            } else {\n+                return dy;\n+            }\n+        } else {\n+            if (dx.getValue() <= dz.getValue()) {\n+                return dz;\n+            } else {\n+                return dx;\n+            }\n+        }\n+    }\n+\n+    /** Compute the square of the distance between the instance and another vector.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the square of the distance between the instance and p\n+     */\n+    public DerivativeStructure distanceSq(final Vector3DDS v) {\n+        final DerivativeStructure dx = v.x.subtract(x);\n+        final DerivativeStructure dy = v.y.subtract(y);\n+        final DerivativeStructure dz = v.z.subtract(z);\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+    }\n+\n+    /** Compute the square of the distance between the instance and another vector.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the square of the distance between the instance and p\n+     */\n+    public DerivativeStructure distanceSq(final Vector3D v) {\n+        final DerivativeStructure dx = x.subtract(v.getX());\n+        final DerivativeStructure dy = y.subtract(v.getY());\n+        final DerivativeStructure dz = z.subtract(v.getZ());\n+        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the dot product v1.v2\n+     */\n+    public static DerivativeStructure dotProduct(Vector3DDS v1, Vector3DDS v2) {\n+        return v1.dotProduct(v2);\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the dot product v1.v2\n+     */\n+    public static DerivativeStructure dotProduct(Vector3DDS v1, Vector3D v2) {\n+        return v1.dotProduct(v2);\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the dot product v1.v2\n+     */\n+    public static DerivativeStructure dotProduct(Vector3D v1, Vector3DDS v2) {\n+        return v2.dotProduct(v1);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static Vector3DDS crossProduct(final Vector3DDS v1, final Vector3DDS v2) {\n+        return v1.crossProduct(v2);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static Vector3DDS crossProduct(final Vector3DDS v1, final Vector3D v2) {\n+        return v1.crossProduct(v2);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static Vector3DDS crossProduct(final Vector3D v1, final Vector3DDS v2) {\n+        return v2.crossProduct(v1).negate();\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static DerivativeStructure distance1(Vector3DDS v1, Vector3DDS v2) {\n+        return v1.distance1(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static DerivativeStructure distance1(Vector3DDS v1, Vector3D v2) {\n+        return v1.distance1(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static DerivativeStructure distance1(Vector3D v1, Vector3DDS v2) {\n+        return v2.distance1(v1);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static DerivativeStructure distance(Vector3DDS v1, Vector3DDS v2) {\n+        return v1.distance(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static DerivativeStructure distance(Vector3DDS v1, Vector3D v2) {\n+        return v1.distance(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static DerivativeStructure distance(Vector3D v1, Vector3DDS v2) {\n+        return v2.distance(v1);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static DerivativeStructure distanceInf(Vector3DDS v1, Vector3DDS v2) {\n+        return v1.distanceInf(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static DerivativeStructure distanceInf(Vector3DDS v1, Vector3D v2) {\n+        return v1.distanceInf(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static DerivativeStructure distanceInf(Vector3D v1, Vector3DDS v2) {\n+        return v2.distanceInf(v1);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static DerivativeStructure distanceSq(Vector3DDS v1, Vector3DDS v2) {\n+        return v1.distanceSq(v2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static DerivativeStructure distanceSq(Vector3DDS v1, Vector3D v2) {\n+        return v1.distanceSq(v2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static DerivativeStructure distanceSq(Vector3D v1, Vector3DDS v2) {\n+        return v2.distanceSq(v1);\n+    }\n+\n+    /** Get a string representation of this vector.\n+     * @return a string representation of this vector\n+     */\n+    @Override\n+    public String toString() {\n+        return Vector3DFormat.getInstance().format(toVector3D());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(final NumberFormat format) {\n+        return new Vector3DFormat(format).format(toVector3D());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/RotationDSTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class RotationDSTest {\n+\n+    @Test\n+    public void testIdentity() {\n+\n+        RotationDS r = createRotation(1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(-1, 0, 0, 0, false);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+        r = createRotation(42, 0, 0, 0, true);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));\n+        checkAngle(r.getAngle(), 0);\n+\n+    }\n+\n+    @Test\n+    public void testAxisAngle() throws MathIllegalArgumentException {\n+\n+        RotationDS r = new RotationDS(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3));\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));\n+        double s = 1 / FastMath.sqrt(3);\n+        checkVector(r.getAxis(), createVector(s, s, s));\n+        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);\n+\n+        try {\n+            new RotationDS(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException e) {\n+        }\n+\n+        r = new RotationDS(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 0, -1));\n+        checkAngle(r.getAngle(), 0.5 * FastMath.PI);\n+\n+        r = new RotationDS(createAxis(0, 1, 0), createAngle(FastMath.PI));\n+        checkVector(r.getAxis(), createVector(0, 1, 0));\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0));\n+\n+    }\n+\n+    @Test\n+    public void testRevert() {\n+        double a = 0.001;\n+        double b = 0.36;\n+        double c = 0.48;\n+        double d = 0.8;\n+        RotationDS r = createRotation(a, b, c, d, true);\n+        double a2 = a * a;\n+        double b2 = b * b;\n+        double c2 = c * c;\n+        double d2 = d * d;\n+        double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2);\n+        Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        RotationDS reverted = r.revert();\n+        RotationDS rrT = r.applyTo(reverted);\n+        checkRotationDS(rrT, 1, 0, 0, 0);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        RotationDS rTr = reverted.applyTo(r);\n+        checkRotationDS(rTr, 1, 0, 0, 0);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);\n+        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);\n+        Assert.assertEquals(r.getAngle().getValue(), reverted.getAngle().getValue(), 1.0e-15);\n+        Assert.assertEquals(-1, Vector3DDS.dotProduct(r.getAxis(), reverted.getAxis()).getValue(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testVectorOnePair() throws MathArithmeticException {\n+\n+        Vector3DDS u = createVector(3, 2, 1);\n+        Vector3DDS v = createVector(-4, 2, 2);\n+        RotationDS r = new RotationDS(u, v);\n+        checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n+\n+        checkAngle(new RotationDS(u, u.negate()).getAngle(), FastMath.PI);\n+\n+        try {\n+            new RotationDS(u, createVector(0, 0, 0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testVectorTwoPairs() throws MathArithmeticException {\n+\n+        Vector3DDS u1 = createVector(3, 0, 0);\n+        Vector3DDS u2 = createVector(0, 5, 0);\n+        Vector3DDS v1 = createVector(0, 0, 2);\n+        Vector3DDS v2 = createVector(-2, 0, 2);\n+        RotationDS r = new RotationDS(u1, u2, v1, v2);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0));\n+\n+        r = new RotationDS(u1, u2, u1.negate(), u2.negate());\n+        Vector3DDS axis = r.getAxis();\n+        if (Vector3DDS.dotProduct(axis, createVector(0, 0, 1)).getValue() > 0) {\n+            checkVector(axis, createVector(0, 0, 1));\n+        } else {\n+            checkVector(axis, createVector(0, 0, -1));\n+        }\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        double sqrt = FastMath.sqrt(2) / 2;\n+        r = new RotationDS(createVector(1, 0, 0),  createVector(0, 1, 0),\n+                           createVector(0.5, 0.5,  sqrt),\n+                           createVector(0.5, 0.5, -sqrt));\n+        checkRotationDS(r, sqrt, 0.5, 0.5, 0);\n+\n+        r = new RotationDS(u1, u2, u1, Vector3DDS.crossProduct(u1, u2));\n+        checkRotationDS(r, sqrt, -sqrt, 0, 0);\n+\n+        checkRotationDS(new RotationDS(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+        try {\n+            new RotationDS(u1, u2, createVector(0, 0, 0), v2);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException e) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMatrix()\n+            throws NotARotationMatrixException {\n+\n+        try {\n+            createRotation(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.445888,  0.797184, -0.407040 },\n+                {  0.821760, -0.184320,  0.539200 },\n+                { -0.354816,  0.574912,  0.737280 }\n+            }, 1.0e-7);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            createRotation(new double[][] {\n+                {  0.4,  0.8, -0.4 },\n+                { -0.4,  0.6,  0.7 },\n+                {  0.8, -0.2,  0.5 }\n+            }, 1.0e-15);\n+            Assert.fail(\"Expecting NotARotationMatrixException\");\n+        } catch (NotARotationMatrixException nrme) {\n+            // expected behavior\n+        }\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.445888,  0.797184, -0.407040 },\n+            { -0.354816,  0.574912,  0.737280 },\n+            {  0.821760, -0.184320,  0.539200 }\n+        }, 1.0e-10),\n+        0.8, 0.288, 0.384, 0.36);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            {  0.539200,  0.737280,  0.407040 },\n+            {  0.184320, -0.574912,  0.797184 },\n+            {  0.821760, -0.354816, -0.445888 }\n+        }, 1.0e-10),\n+        0.36, 0.8, 0.288, 0.384);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.445888,  0.797184, -0.407040 },\n+            {  0.354816,  0.574912,  0.737280 },\n+            {  0.821760,  0.184320, -0.539200 }\n+        }, 1.0e-10),\n+        0.384, 0.36, 0.8, 0.288);\n+\n+        checkRotationDS(createRotation(new double[][] {\n+            { -0.539200,  0.737280,  0.407040 },\n+            { -0.184320, -0.574912,  0.797184 },\n+            {  0.821760,  0.354816,  0.445888 }\n+        }, 1.0e-10),\n+        0.288, 0.384, 0.36, 0.8);\n+\n+        double[][] m1 = { { 0.0, 1.0, 0.0 },\n+            { 0.0, 0.0, 1.0 },\n+            { 1.0, 0.0, 0.0 } };\n+        RotationDS r = createRotation(m1, 1.0e-7);\n+        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));\n+        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));\n+        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));\n+\n+        double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+            { 0.48293,  0.78164, -0.39474 },\n+            { 0.27296,  0.29396,  0.91602 } };\n+        r = createRotation(m2, 1.0e-12);\n+\n+        DerivativeStructure[][] m3 = r.getMatrix();\n+        double d00 = m2[0][0] - m3[0][0].getValue();\n+        double d01 = m2[0][1] - m3[0][1].getValue();\n+        double d02 = m2[0][2] - m3[0][2].getValue();\n+        double d10 = m2[1][0] - m3[1][0].getValue();\n+        double d11 = m2[1][1] - m3[1][1].getValue();\n+        double d12 = m2[1][2] - m3[1][2].getValue();\n+        double d20 = m2[2][0] - m3[2][0].getValue();\n+        double d21 = m2[2][1] - m3[2][1].getValue();\n+        double d22 = m2[2][2] - m3[2][2].getValue();\n+\n+        Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);\n+        Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+        Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);\n+        Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);\n+\n+        for (int i = 0; i < 3; ++i) {\n+            for (int j = 0; j < 3; ++j) {\n+                double m3tm3 = m3[i][0].getValue() * m3[j][0].getValue() +\n+                               m3[i][1].getValue() * m3[j][1].getValue() +\n+                               m3[i][2].getValue() * m3[j][2].getValue();\n+                if (i == j) {\n+                    Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n+                } else {\n+                    Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n+                }\n+            }\n+        }\n+\n+        checkVector(r.applyTo(createVector(1, 0, 0)),\n+                    new Vector3DDS(m3[0][0], m3[1][0], m3[2][0]));\n+        checkVector(r.applyTo(createVector(0, 1, 0)),\n+                    new Vector3DDS(m3[0][1], m3[1][1], m3[2][1]));\n+        checkVector(r.applyTo(createVector(0, 0, 1)),\n+                    new Vector3DDS(m3[0][2], m3[1][2], m3[2][2]));\n+\n+        double[][] m4 = { { 1.0,  0.0,  0.0 },\n+            { 0.0, -1.0,  0.0 },\n+            { 0.0,  0.0, -1.0 } };\n+        r = createRotation(m4, 1.0e-7);\n+        checkAngle(r.getAngle(), FastMath.PI);\n+\n+        try {\n+            double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 } };\n+            r = createRotation(m5, 1.0e-7);\n+            Assert.fail(\"got \" + r + \", should have caught an exception\");\n+        } catch (NotARotationMatrixException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAngles()\n+            throws CardanEulerSingularityException {\n+\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+                for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+                        RotationDS r = new RotationDS(CardanOrders[i],\n+                                                      new DerivativeStructure(3, 1, 0, alpha1),\n+                                                      new DerivativeStructure(3, 1, 1, alpha2),\n+                                                      new DerivativeStructure(3, 1, 2, alpha3));\n+                        DerivativeStructure[] angles = r.getAngles(CardanOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+                for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+                    for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+                        RotationDS r = new RotationDS(EulerOrders[i],\n+                                                      new DerivativeStructure(3, 1, 0, alpha1),\n+                                                      new DerivativeStructure(3, 1, 1, alpha2),\n+                                                      new DerivativeStructure(3, 1, 2, alpha3));\n+                        DerivativeStructure[] angles = r.getAngles(EulerOrders[i]);\n+                        checkAngle(angles[0], alpha1);\n+                        checkAngle(angles[1], alpha2);\n+                        checkAngle(angles[2], alpha3);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSingularities() {\n+\n+        RotationOrder[] CardanOrders = {\n+            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+        };\n+\n+        double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };\n+        for (int i = 0; i < CardanOrders.length; ++i) {\n+            for (int j = 0; j < singularCardanAngle.length; ++j) {\n+                RotationDS r = new RotationDS(CardanOrders[i],\n+                                              new DerivativeStructure(3, 1, 0, 0.1),\n+                                              new DerivativeStructure(3, 1, 1, singularCardanAngle[j]),\n+                                              new DerivativeStructure(3, 1, 2, 0.3));\n+                try {\n+                    r.getAngles(CardanOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+        RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+        };\n+\n+        double[] singularEulerAngle = { 0, FastMath.PI };\n+        for (int i = 0; i < EulerOrders.length; ++i) {\n+            for (int j = 0; j < singularEulerAngle.length; ++j) {\n+                RotationDS r = new RotationDS(EulerOrders[i],\n+                                              new DerivativeStructure(3, 1, 0, 0.1),\n+                                              new DerivativeStructure(3, 1, 1, singularEulerAngle[j]),\n+                                              new DerivativeStructure(3, 1, 2, 0.3));\n+                try {\n+                    r.getAngles(EulerOrders[i]);\n+                    Assert.fail(\"an exception should have been caught\");\n+                } catch (CardanEulerSingularityException cese) {\n+                    // expected behavior\n+                }\n+            }\n+        }\n+\n+\n+    }\n+\n+    @Test\n+    public void testQuaternion() throws MathIllegalArgumentException {\n+\n+        RotationDS r1 = new RotationDS(createVector(2, -3, 5), createAngle(1.7));\n+        double n = 23.5;\n+        RotationDS r2 = new RotationDS(r1.getQ0().multiply(n), r1.getQ1().multiply(n),\n+                                       r1.getQ2().multiply(n), r1.getQ3().multiply(n),\n+                                       true);\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3DDS u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(u), r1.applyTo(u));\n+                }\n+            }\n+        }\n+\n+        r1 = createRotation(0.288,  0.384,  0.36,  0.8, false);\n+        checkRotationDS(r1,\n+                        -r1.getQ0().getValue(), -r1.getQ1().getValue(),\n+                        -r1.getQ2().getValue(), -r1.getQ3().getValue());\n+\n+    }\n+\n+    @Test\n+    public void testCompose() throws MathIllegalArgumentException {\n+\n+        RotationDS r1       = new RotationDS(createVector(2, -3, 5), createAngle(1.7));\n+        RotationDS r2       = new RotationDS(createVector(-1, 3, 2), createAngle(0.3));\n+        RotationDS r3       = r2.applyTo(r1);\n+        RotationDS r3Double = r2.applyTo(new Rotation(r1.getQ0().getValue(),\n+                                                      r1.getQ1().getValue(),\n+                                                      r1.getQ2().getValue(),\n+                                                      r1.getQ3().getValue(),\n+                                                      false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3DDS u = createVector(x, y, z);\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testComposeInverse() throws MathIllegalArgumentException {\n+\n+        RotationDS r1 = new RotationDS(createVector(2, -3, 5), createAngle(1.7));\n+        RotationDS r2 = new RotationDS(createVector(-1, 3, 2), createAngle(0.3));\n+        RotationDS r3 = r2.applyInverseTo(r1);\n+        RotationDS r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getValue(),\n+                                                             r1.getQ1().getValue(),\n+                                                             r1.getQ2().getValue(),\n+                                                             r1.getQ3().getValue(),\n+                                                             false));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3DDS u = createVector(x, y, z);\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleVectors() throws MathIllegalArgumentException {\n+\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit = g.nextVector();\n+            RotationDS r = new RotationDS(createVector(unit[0], unit[1], unit[2]),\n+                                          createAngle(random.nextDouble()));\n+\n+            for (double x = -0.9; x < 0.9; x += 0.2) {\n+                for (double y = -0.9; y < 0.9; y += 0.2) {\n+                    for (double z = -0.9; z < 0.9; z += 0.2) {\n+                        Vector3DDS uds   = createVector(x, y, z);\n+                        Vector3DDS ruds  = r.applyTo(uds);\n+                        Vector3DDS rIuds = r.applyInverseTo(uds);\n+                        Vector3D   u     = new Vector3D(x, y, z);\n+                        Vector3DDS ru    = r.applyTo(u);\n+                        Vector3DDS rIu   = r.applyInverseTo(u);\n+                        DerivativeStructure[] ruArray = new DerivativeStructure[3];\n+                        r.applyTo(new double[] { x, y, z}, ruArray);\n+                        DerivativeStructure[] rIuArray = new DerivativeStructure[3];\n+                        r.applyInverseTo(new double[] { x, y, z}, rIuArray);\n+                        checkVector(ruds, ru);\n+                        checkVector(ruds, new Vector3DDS(ruArray));\n+                        checkVector(rIuds, rIu);\n+                        checkVector(rIuds, new Vector3DDS(rIuArray));\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDoubleRotations() throws MathIllegalArgumentException {\n+\n+        Well1024a random = new Well1024a(0x180b41cfeeffaf67l);\n+        UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random);\n+        for (int i = 0; i < 10; ++i) {\n+            double[] unit1 = g.nextVector();\n+            Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]),\n+                                      random.nextDouble());\n+            RotationDS r1Prime = new RotationDS(new DerivativeStructure(4, 1, 0, r1.getQ0()),\n+                                                new DerivativeStructure(4, 1, 1, r1.getQ1()),\n+                                                new DerivativeStructure(4, 1, 2, r1.getQ2()),\n+                                                new DerivativeStructure(4, 1, 3, r1.getQ3()),\n+                                                false);\n+            double[] unit2 = g.nextVector();\n+            RotationDS r2 = new RotationDS(createVector(unit2[0], unit2[1], unit2[2]),\n+                                           createAngle(random.nextDouble()));\n+\n+            RotationDS rA = RotationDS.applyTo(r1, r2);\n+            RotationDS rB = r1Prime.applyTo(r2);\n+            RotationDS rC = RotationDS.applyInverseTo(r1, r2);\n+            RotationDS rD = r1Prime.applyInverseTo(r2);\n+\n+            for (double x = -0.9; x < 0.9; x += 0.2) {\n+                for (double y = -0.9; y < 0.9; y += 0.2) {\n+                    for (double z = -0.9; z < 0.9; z += 0.2) {\n+\n+                        Vector3DDS uds   = createVector(x, y, z);\n+                        checkVector(r1Prime.applyTo(uds), RotationDS.applyTo(r1, uds));\n+                        checkVector(r1Prime.applyInverseTo(uds), RotationDS.applyInverseTo(r1, uds));\n+                        checkVector(rA.applyTo(uds), rB.applyTo(uds));\n+                        checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds));\n+                        checkVector(rC.applyTo(uds), rD.applyTo(uds));\n+                        checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds));\n+\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testDerivatives() {\n+\n+        double eps      = 5.0e-16;\n+        double kx       = 2;\n+        double ky       = -3;\n+        double kz       = 5;\n+        double n2       = kx * kx + ky * ky + kz * kz;\n+        double n        = FastMath.sqrt(n2);\n+        double theta    = 1.7;\n+        double cosTheta = FastMath.cos(theta);\n+        double sinTheta = FastMath.sin(theta);\n+        RotationDS r    = new RotationDS(createAxis(kx, ky, kz), createAngle(theta));\n+        Vector3D a      = new Vector3D(kx / n, ky / n, kz / n);\n+\n+        // Jacobian of the normalized rotation axis a with respect to the Cartesian vector k\n+        RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] {\n+            { (ky * ky + kz * kz) / ( n * n2),            -kx * ky / ( n * n2),            -kx * kz / ( n * n2) },\n+            {            -kx * ky / ( n * n2), (kx * kx + kz * kz) / ( n * n2),            -ky * kz / ( n * n2) },\n+            {            -kx * kz / ( n * n2),            -ky * kz / ( n * n2), (kx * kx + ky * ky) / ( n * n2) }\n+        });\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3D   u = new Vector3D(x, y, z);\n+                    Vector3DDS v = r.applyTo(createVector(x, y, z));\n+\n+                    // explicit formula for rotation of vector u around axis a with angle theta\n+                    double dot     = Vector3D.dotProduct(u, a);\n+                    Vector3D cross = Vector3D.crossProduct(a, u);\n+                    double c1      = 1 - cosTheta;\n+                    double c2      = c1 * dot;\n+                    Vector3D rt    = new Vector3D(cosTheta, u, c2, a, sinTheta, cross);\n+                    Assert.assertEquals(rt.getX(), v.getX().getValue(), eps);\n+                    Assert.assertEquals(rt.getY(), v.getY().getValue(), eps);\n+                    Assert.assertEquals(rt.getZ(), v.getZ().getValue(), eps);\n+\n+                    // Jacobian of the image v = r(u) with respect to rotation axis a\n+                    // (analytical differentiation of the explicit formula)\n+                    RealMatrix dvda = MatrixUtils.createRealMatrix(new double[][] {\n+                        { c1 * x * a.getX() + c2,           c1 * y * a.getX() + sinTheta * z, c1 * z * a.getX() - sinTheta * y },\n+                        { c1 * x * a.getY() - sinTheta * z, c1 * y * a.getY() + c2,           c1 * z * a.getY() + sinTheta * x },\n+                        { c1 * x * a.getZ() + sinTheta * y, c1 * y * a.getZ() - sinTheta * x, c1 * z * a.getZ() + c2           }\n+                    });\n+\n+                    // compose Jacobians\n+                    RealMatrix dvdk = dvda.multiply(dadk);\n+\n+                    // derivatives with respect to un-normalized axis\n+                    Assert.assertEquals(dvdk.getEntry(0, 0), v.getX().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(0, 1), v.getX().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(0, 2), v.getX().getPartialDerivative(0, 0, 1, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 0), v.getY().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 1), v.getY().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(1, 2), v.getY().getPartialDerivative(0, 0, 1, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 0), v.getZ().getPartialDerivative(1, 0, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 1), v.getZ().getPartialDerivative(0, 1, 0, 0), eps);\n+                    Assert.assertEquals(dvdk.getEntry(2, 2), v.getZ().getPartialDerivative(0, 0, 1, 0), eps);\n+\n+                    // derivative with respect to rotation angle\n+                    // (analytical differentiation of the explicit formula)\n+                    Vector3D dvdTheta =\n+                            new Vector3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);\n+                    Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps);\n+                    Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps);\n+                    Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps);\n+\n+                }\n+            }\n+        }\n+     }\n+\n+    @Test\n+    public void testArray() throws MathIllegalArgumentException {\n+\n+        RotationDS r = new RotationDS(createAxis(2, -3, 5), createAngle(1.7));\n+\n+        for (double x = -0.9; x < 0.9; x += 0.2) {\n+            for (double y = -0.9; y < 0.9; y += 0.2) {\n+                for (double z = -0.9; z < 0.9; z += 0.2) {\n+                    Vector3DDS u = createVector(x, y, z);\n+                    Vector3DDS v = r.applyTo(u);\n+                    DerivativeStructure[] out = new DerivativeStructure[3];\n+                    r.applyTo(new DerivativeStructure[] { u.getX(), u.getY(), u.getZ() }, out);\n+                    Assert.assertEquals(v.getX().getValue(), out[0].getValue(), 1.0e-10);\n+                    Assert.assertEquals(v.getY().getValue(), out[1].getValue(), 1.0e-10);\n+                    Assert.assertEquals(v.getZ().getValue(), out[2].getValue(), 1.0e-10);\n+                    r.applyInverseTo(out, out);\n+                    Assert.assertEquals(u.getX().getValue(), out[0].getValue(), 1.0e-10);\n+                    Assert.assertEquals(u.getY().getValue(), out[1].getValue(), 1.0e-10);\n+                    Assert.assertEquals(u.getZ().getValue(), out[2].getValue(), 1.0e-10);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testApplyInverseTo() throws MathIllegalArgumentException {\n+\n+        DerivativeStructure[] in      = new DerivativeStructure[3];\n+        DerivativeStructure[] out     = new DerivativeStructure[3];\n+        DerivativeStructure[] rebuilt = new DerivativeStructure[3];\n+        RotationDS r = new RotationDS(createVector(2, -3, 5), createAngle(1.7));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                Vector3DDS u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                r.applyInverseTo(r.applyTo(u));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+                in[0] = u.getX();\n+                in[1] = u.getY();\n+                in[2] = u.getZ();\n+                r.applyTo(in, out);\n+                r.applyInverseTo(out, rebuilt);\n+                Assert.assertEquals(in[0].getValue(), rebuilt[0].getValue(), 1.0e-12);\n+                Assert.assertEquals(in[1].getValue(), rebuilt[1].getValue(), 1.0e-12);\n+                Assert.assertEquals(in[2].getValue(), rebuilt[2].getValue(), 1.0e-12);\n+            }\n+        }\n+\n+        r = createRotation(1, 0, 0, 0, false);\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                Vector3DDS u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+        r = new RotationDS(createVector(0, 0, 1), createAngle(FastMath.PI));\n+        for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+            for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+                Vector3DDS u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(lambda) * FastMath.cos(phi),\n+                                          FastMath.sin(phi));\n+                checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+                checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testIssue639() throws MathArithmeticException{\n+        Vector3DDS u1 = createVector(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -3822921525525679.0 / 4294967296.0);\n+        Vector3DDS u2 =createVector( -5712344449280879.0 /    2097152.0,\n+                                   -2275058564560979.0 /    1048576.0,\n+                                   4423475992255071.0 /      65536.0);\n+        RotationDS rot = new RotationDS(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1));\n+        Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getValue(), 1.0e-15);\n+        Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getValue(), 1.0e-15);\n+        Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getValue(), 1.0e-15);\n+        Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getValue(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testIssue801() throws MathArithmeticException {\n+        Vector3DDS u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0);\n+        Vector3DDS u2 = createVector(0.0, 0.0, 1.0);\n+\n+        Vector3DDS v1 = createVector(0.9999999999999999, 0.0, 0.0);\n+        Vector3DDS v2 = createVector(0.0, 0.0, -1.0);\n+\n+        RotationDS quat = new RotationDS(u1, u2, v1, v2);\n+        double q2 = quat.getQ0().getValue() * quat.getQ0().getValue() +\n+                    quat.getQ1().getValue() * quat.getQ1().getValue() +\n+                    quat.getQ2().getValue() * quat.getQ2().getValue() +\n+                    quat.getQ3().getValue() * quat.getQ3().getValue();\n+        Assert.assertEquals(1.0, q2, 1.0e-14);\n+        Assert.assertEquals(0.0, Vector3DDS.angle(v1, quat.applyTo(u1)).getValue(), 1.0e-14);\n+        Assert.assertEquals(0.0, Vector3DDS.angle(v2, quat.applyTo(u2)).getValue(), 1.0e-14);\n+\n+    }\n+\n+    private void checkAngle(DerivativeStructure a1, double a2) {\n+        Assert.assertEquals(a1.getValue(), MathUtils.normalizeAngle(a2, a1.getValue()), 1.0e-10);\n+    }\n+\n+    private void checkRotationDS(RotationDS r, double q0, double q1, double q2, double q3) {\n+        RotationDS rPrime = createRotation(q0, q1, q2, q3, false);\n+        Assert.assertEquals(0, RotationDS.distance(r, rPrime).getValue(), 1.0e-12);\n+    }\n+\n+    private RotationDS createRotation(double q0, double q1, double q2, double q3,\n+                                      boolean needsNormalization) {\n+        return new RotationDS(new DerivativeStructure(4, 1, 0, q0),\n+                              new DerivativeStructure(4, 1, 1, q1),\n+                              new DerivativeStructure(4, 1, 2, q2),\n+                              new DerivativeStructure(4, 1, 3, q3),\n+                              needsNormalization);\n+    }\n+\n+    private RotationDS createRotation(double[][] m, double threshold) {\n+        DerivativeStructure[][] mds = new DerivativeStructure[m.length][m[0].length];\n+        int index = 0;\n+        for (int i = 0; i < m.length; ++i) {\n+            for (int j = 0; j < m[i].length; ++j) {\n+                mds[i][j] = new DerivativeStructure(4, 1, index, m[i][j]);\n+                index = (index + 1) % 4;\n+            }\n+        }\n+        return new RotationDS(mds, threshold);\n+    }\n+\n+    private Vector3DDS createVector(double x, double y, double z) {\n+        return new Vector3DDS(new DerivativeStructure(4, 1, x),\n+                              new DerivativeStructure(4, 1, y),\n+                              new DerivativeStructure(4, 1, z));\n+    }\n+\n+    private Vector3DDS createAxis(double x, double y, double z) {\n+        return new Vector3DDS(new DerivativeStructure(4, 1, 0, x),\n+                              new DerivativeStructure(4, 1, 1, y),\n+                              new DerivativeStructure(4, 1, 2, z));\n+    }\n+\n+    private DerivativeStructure createAngle(double alpha) {\n+        return new DerivativeStructure(4, 1, 3, alpha);\n+    }\n+\n+    private void checkVector(Vector3DDS u, Vector3DDS v) {\n+        Assert.assertEquals(u.getX().getValue(), v.getX().getValue(), 1.0e-12);\n+        Assert.assertEquals(u.getY().getValue(), v.getY().getValue(), 1.0e-12);\n+        Assert.assertEquals(u.getZ().getValue(), v.getZ().getValue(), 1.0e-12);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3DDSTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.geometry.euclidean.threed;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.random.Well1024a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class Vector3DDSTest {\n+    @Test\n+    public void testConstructors() throws DimensionMismatchException {\n+        double cosAlpha = 1 / 2.0;\n+        double sinAlpha = FastMath.sqrt(3) / 2.0;\n+        double cosDelta = FastMath.sqrt(2) / 2.0;\n+        double sinDelta = -FastMath.sqrt(2) / 2.0;\n+        Vector3DDS u = new Vector3DDS(2,\n+                                      new Vector3DDS(new DerivativeStructure(2, 1, 0,  FastMath.PI / 3),\n+                                                     new DerivativeStructure(2, 1, 1, -FastMath.PI / 4)));\n+        checkVector(u, 2 * cosAlpha * cosDelta, 2 * sinAlpha * cosDelta, 2 * sinDelta);\n+        Assert.assertEquals(-2 * sinAlpha * cosDelta, u.getX().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(+2 * cosAlpha * cosDelta, u.getY().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(0,                        u.getZ().getPartialDerivative(1, 0), 1.0e-12);\n+        Assert.assertEquals(-2 * cosAlpha * sinDelta, u.getX().getPartialDerivative(0, 1), 1.0e-12);\n+        Assert.assertEquals(-2 * sinAlpha * sinDelta, u.getY().getPartialDerivative(0, 1), 1.0e-12);\n+        Assert.assertEquals(2 * cosDelta,             u.getZ().getPartialDerivative(0, 1), 1.0e-12);\n+\n+        checkVector(new Vector3DDS(2, createVector(1, 0,  0, 3)),\n+                                   2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4)),\n+                                   2, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0)),\n+                                   2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0);\n+\n+        checkVector(new Vector3DDS(2, createVector(1, 0,  0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 0, 3, -1, 0, 0, 0, -1, 0, 0, 0, -1);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 0, 3, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, -1, -1);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);\n+\n+        checkVector(new Vector3DDS(2, createVector(1, 0, 0, 3),\n+                                   5, createVector(0, 1, 0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 5, 3, 4, 0, 0, 0, 4, 0, 0, 0, 4);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, 1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 5, 3, 4, 0, 0, 1, 0, 4, 0, 1, 0, 0, 4, -1);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, 1,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 5, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1);\n+\n+        checkVector(new Vector3DDS(2, createVector(1, 0, 0, 3),\n+                                   5, createVector(0, 1, 0, 3),\n+                                   5, createVector(0, -1, 0, 3),\n+                                   -3, createVector(0, 0, -1, 3)),\n+                                   2, 0, 3, 9, 0, 0, 0, 9, 0, 0, 0, 9);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   createVector(1, 0,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, 1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   createVector(0, -1,  0, 4),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   createVector(0, 0, -1, 4)),\n+                                   2, 0, 3, 9, 0, 0, 1, 0, 9, 0, 0, 0, 0, 9, -1);\n+        checkVector(new Vector3DDS(new DerivativeStructure(4, 1, 3,  2.0),\n+                                   new Vector3D(1, 0,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, 1,  0),\n+                                   new DerivativeStructure(4, 1, 3,  5.0),\n+                                   new Vector3D(0, -1,  0),\n+                                   new DerivativeStructure(4, 1, 3, -3.0),\n+                                   new Vector3D(0, 0, -1)),\n+                                   2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1);\n+\n+        checkVector(new Vector3DDS(new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 2,  2),\n+            new DerivativeStructure(3, 1, 1,  5),\n+            new DerivativeStructure(3, 1, 0, -3)\n+        }),\n+        2, 5, -3, 0, 0, 1, 0, 1, 0, 1, 0, 0);\n+\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        Vector3DDS u1 = createVector(1, 2, 3, 3);\n+        Vector3DDS v  = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3);\n+        Assert.assertTrue(u1.equals(u1));\n+        Assert.assertTrue(u1.equals(new Vector3DDS(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                   new DerivativeStructure(3, 1, 1, 2.0),\n+                                                   new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new Vector3DDS(new DerivativeStructure(3, 1, 1.0),\n+                                                    new DerivativeStructure(3, 1, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new Vector3DDS(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                    new DerivativeStructure(3, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 2, 3.0))));\n+        Assert.assertFalse(u1.equals(new Vector3DDS(new DerivativeStructure(3, 1, 0, 1.0),\n+                                                    new DerivativeStructure(3, 1, 1, 2.0),\n+                                                    new DerivativeStructure(3, 1, 3.0))));\n+        Assert.assertFalse(u1.equals(v));\n+        Assert.assertFalse(u1.equals(u1.toVector3D()));\n+        Assert.assertTrue(createVector(0, Double.NaN, 0, 3).equals(createVector(0, 0, Double.NaN, 3)));\n+    }\n+\n+    @Test\n+    public void testHash() {\n+        Assert.assertEquals(createVector(0, Double.NaN, 0, 3).hashCode(), createVector(0, 0, Double.NaN, 3).hashCode());\n+        Vector3DDS u = createVector(1, 2, 3, 3);\n+        Vector3DDS v = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3);\n+        Assert.assertTrue(u.hashCode() != v.hashCode());\n+    }\n+\n+    @Test\n+    public void testInfinite() {\n+        Assert.assertTrue(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isInfinite());\n+        Assert.assertTrue(createVector(1, Double.NEGATIVE_INFINITY, 1, 3).isInfinite());\n+        Assert.assertTrue(createVector(Double.NEGATIVE_INFINITY, 1, 1, 3).isInfinite());\n+        Assert.assertFalse(createVector(1, 1, 2, 3).isInfinite());\n+        Assert.assertFalse(createVector(1, Double.NaN, Double.NEGATIVE_INFINITY, 3).isInfinite());\n+    }\n+\n+    @Test\n+    public void testNaN() {\n+        Assert.assertTrue(createVector(1, 1, Double.NaN, 3).isNaN());\n+        Assert.assertTrue(createVector(1, Double.NaN, 1, 3).isNaN());\n+        Assert.assertTrue(createVector(Double.NaN, 1, 1, 3).isNaN());\n+        Assert.assertFalse(createVector(1, 1, 2, 3).isNaN());\n+        Assert.assertFalse(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isNaN());\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        Assert.assertEquals(\"{3; 2; 1}\", createVector(3, 2, 1, 3).toString());\n+        NumberFormat format = new DecimalFormat(\"0.000\", new DecimalFormatSymbols(Locale.US));\n+        Assert.assertEquals(\"{3.000; 2.000; 1.000}\", createVector(3, 2, 1, 3).toString(format));\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testWrongDimension() throws DimensionMismatchException {\n+        new Vector3DDS(new DerivativeStructure[] {\n+            new DerivativeStructure(3, 1, 0, 2),\n+            new DerivativeStructure(3, 1, 0, 5)\n+        });\n+    }\n+\n+    @Test\n+    public void testCoordinates() {\n+        Vector3DDS v = createVector(1, 2, 3, 3);\n+        Assert.assertTrue(FastMath.abs(v.getX().getValue() - 1) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getY().getValue() - 2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getZ().getValue() - 3) < 1.0e-12);\n+        DerivativeStructure[] coordinates = v.toArray();\n+        Assert.assertTrue(FastMath.abs(coordinates[0].getValue() - 1) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(coordinates[1].getValue() - 2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(coordinates[2].getValue() - 3) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testNorm1() {\n+        Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNorm1().getValue(), 0);\n+        Assert.assertEquals( 6.0, createVector(1, -2, 3, 3).getNorm1().getValue(), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNorm() {\n+        double r = FastMath.sqrt(14);\n+        Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNorm().getValue(), 0);\n+        Assert.assertEquals(r, createVector(1, 2, 3, 3).getNorm().getValue(), 1.0e-12);\n+        Assert.assertEquals( 1.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 2.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 3.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNormSq() {\n+        Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNormSq().getValue(), 0);\n+        Assert.assertEquals(14, createVector(1, 2, 3, 3).getNormSq().getValue(), 1.0e-12);\n+        Assert.assertEquals( 2, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 4, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 6, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testNormInf() {\n+        Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 3.0, createVector(1, -2, 3, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(2, -1, 3, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 1.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(1, -3, 2, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(2, -3, 1, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals(-1.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(3, -1, 2, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 1.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+        Assert.assertEquals( 3.0, createVector(3, -2, 1, 3).getNormInf().getValue(), 0);\n+        Assert.assertEquals( 1.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0);\n+        Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0);\n+    }\n+\n+    @Test\n+    public void testDistance1() {\n+        Vector3DDS v1 = createVector(1, -2, 3, 3);\n+        Vector3DDS v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.distance1(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getValue(), 0);\n+        DerivativeStructure distance = Vector3DDS.distance1(v1, v2);\n+        Assert.assertEquals(12.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distance1(v1, new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(12.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distance1(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(12.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNorm1().getValue(), Vector3DDS.distance1(v1, v2).getValue(), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistance() {\n+        Vector3DDS v1 = createVector(1, -2, 3, 3);\n+        Vector3DDS v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.distance(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getValue(), 0);\n+        DerivativeStructure distance = Vector3DDS.distance(v1, v2);\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getValue(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distance(v1, new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getValue(), 1.0e-12);\n+        Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distance(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(FastMath.sqrt(50), distance.getValue(), 1.0e-12);\n+        Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNorm().getValue(), Vector3DDS.distance(v1, v2).getValue(), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistanceSq() {\n+        Vector3DDS v1 = createVector(1, -2, 3, 3);\n+        Vector3DDS v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.distanceSq(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getValue(), 0);\n+        DerivativeStructure distanceSq = Vector3DDS.distanceSq(v1, v2);\n+        Assert.assertEquals(50.0, distanceSq.getValue(), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distanceSq = Vector3DDS.distanceSq(v1, new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(50.0, distanceSq.getValue(), 1.0e-12);\n+        Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distanceSq = Vector3DDS.distanceSq(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(50.0, distanceSq.getValue(), 1.0e-12);\n+        Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(Vector3DDS.distance(v1, v2).multiply(Vector3DDS.distance(v1, v2)).getValue(),\n+                            Vector3DDS.distanceSq(v1, v2).getValue(), 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testDistanceInf() {\n+        Vector3DDS v1 = createVector(1, -2, 3, 3);\n+        Vector3DDS v2 = createVector(-4, 2, 0, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.distanceInf(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getValue(), 0);\n+        DerivativeStructure distance = Vector3DDS.distanceInf(v1, v2);\n+        Assert.assertEquals(5.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distanceInf(v1, new Vector3D(-4, 2, 0));\n+        Assert.assertEquals(5.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        distance = Vector3DDS.distanceInf(new Vector3D(-4, 2, 0), v1);\n+        Assert.assertEquals(5.0, distance.getValue(), 1.0e-12);\n+        Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNormInf().getValue(), Vector3DDS.distanceInf(v1, v2).getValue(), 1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector( 1, -2, 3, 3),\n+                                                   createVector(-4,  2, 0, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector( 1, 3, -2, 3),\n+                                                   createVector(-4, 0,  2, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(-2,  1, 3, 3),\n+                                                   createVector( 2, -4, 0, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(-2, 3,  1, 3),\n+                                                   createVector( 2, 0, -4, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(3, -2,  1, 3),\n+                                                   createVector(0,  2, -4, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(3,  1, -2, 3),\n+                                                   createVector(0, -4,  2, 3)).getValue(),\n+                            1.0e-12);\n+\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector( 1, -2, 3, 3),\n+                                                   new Vector3D(-4,  2, 0)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector( 1, 3, -2, 3),\n+                                                   new Vector3D(-4, 0,  2)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(-2,  1, 3, 3),\n+                                                   new Vector3D( 2, -4, 0)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(-2, 3,  1, 3),\n+                                                   new Vector3D( 2, 0, -4)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(3, -2,  1, 3),\n+                                                   new Vector3D(0,  2, -4)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(5.0,\n+                            Vector3DDS.distanceInf(createVector(3,  1, -2, 3),\n+                                                   new Vector3D(0, -4,  2)).getValue(),\n+                            1.0e-12);\n+\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        Vector3DDS v1 = createVector(1, 2, 3, 3);\n+        Vector3DDS v2 = createVector(-3, -2, -1, 3);\n+        v1 = v1.subtract(v2);\n+        checkVector(v1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+\n+        checkVector(v2.subtract(v1), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(new Vector3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(3, v1), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(3, new Vector3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Vector3D(4, 4, 4)),\n+                    -15, -14, -13, 1, 0, -4, 0, 1, -4, 0, 0, -3);\n+\n+        checkVector(createVector(1, 2, 3, 4).subtract(new DerivativeStructure(4, 1, 3, 5.0),\n+                                                      createVector(3, -2, 1, 4)),\n+                    -14, 12, -2,\n+                     -4,  0,  0, -3,\n+                      0, -4,  0,  2,\n+                      0,  0, -4, -1);\n+\n+    }\n+\n+    @Test\n+    public void testAdd() {\n+        Vector3DDS v1 = createVector(1, 2, 3, 3);\n+        Vector3DDS v2 = createVector(-3, -2, -1, 3);\n+        v1 = v1.add(v2);\n+        checkVector(v1, -2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2);\n+\n+        checkVector(v2.add(v1), -5, -2, 1, 3, 0, 0, 0, 3, 0, 0, 0, 3);\n+        checkVector(v2.add(new Vector3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.add(3, v1), -9, -2, 5, 7, 0, 0, 0, 7, 0, 0, 0, 7);\n+        checkVector(v2.add(3, new Vector3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1);\n+        checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Vector3D(-2, 0, 2)),\n+                    -9, -2, 5, 1, 0, -2, 0, 1, 0, 0, 0, 3);\n+\n+        checkVector(createVector(1, 2, 3, 4).add(new DerivativeStructure(4, 1, 3, 5.0),\n+                                                 createVector(3, -2, 1, 4)),\n+                    16, -8,  8,\n+                     6,  0,  0,  3,\n+                     0,  6,  0, -2,\n+                     0,  0,  6,  1);\n+\n+    }\n+\n+    @Test\n+    public void testScalarProduct() {\n+        Vector3DDS v = createVector(1, 2, 3, 3);\n+        v = v.scalarMultiply(3);\n+        checkVector(v, 3, 6, 9);\n+\n+        checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);\n+    }\n+\n+    @Test\n+    public void testVectorialProducts() {\n+        Vector3DDS v1 = createVector(2, 1, -4, 3);\n+        Vector3DDS v2 = createVector(3, 1, -1, 3);\n+\n+        Assert.assertTrue(FastMath.abs(Vector3DDS.dotProduct(v1, v2).getValue() - 11) < 1.0e-12);\n+\n+        Vector3DDS v3 = Vector3DDS.crossProduct(v1, v2);\n+        checkVector(v3, 3, -10, -1);\n+\n+        Assert.assertTrue(FastMath.abs(Vector3DDS.dotProduct(v1, v3).getValue()) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(Vector3DDS.dotProduct(v2, v3).getValue()) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testCrossProductCancellation() {\n+        Vector3DDS v1 = createVector(9070467121.0, 4535233560.0, 1, 3);\n+        Vector3DDS v2 = createVector(9070467123.0, 4535233561.0, 1, 3);\n+        checkVector(Vector3DDS.crossProduct(v1, v2), -1, 2, 1);\n+\n+        double scale    = FastMath.scalb(1.0, 100);\n+        Vector3DDS big1   = new Vector3DDS(scale, v1);\n+        Vector3DDS small2 = new Vector3DDS(1 / scale, v2);\n+        checkVector(Vector3DDS.crossProduct(big1, small2), -1, 2, 1);\n+\n+    }\n+\n+    @Test\n+    public void testAngular() {\n+        Assert.assertEquals(0,           createVector(1, 0, 0, 3).getAlpha().getValue(), 1.0e-10);\n+        Assert.assertEquals(0,           createVector(1, 0, 0, 3).getDelta().getValue(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, createVector(0, 1, 0, 3).getAlpha().getValue(), 1.0e-10);\n+        Assert.assertEquals(0,           createVector(0, 1, 0, 3).getDelta().getValue(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, createVector(0, 0, 1, 3).getDelta().getValue(), 1.0e-10);\n+      \n+        Vector3DDS u = createVector(-1, 1, -1, 3);\n+        Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha().getValue(), 1.0e-10);\n+        Assert.assertEquals(-1.0 / FastMath.sqrt(3), u.getDelta().sin().getValue(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testAngularSeparation() throws MathArithmeticException {\n+        Vector3DDS v1 = createVector(2, -1, 4, 3);\n+\n+        Vector3DDS  k = v1.normalize();\n+        Vector3DDS  i = k.orthogonal();\n+        Vector3DDS v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));\n+\n+        Assert.assertTrue(FastMath.abs(Vector3DDS.angle(v1, v2).getValue() - 1.2) < 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testNormalize() throws MathArithmeticException {\n+        Assert.assertEquals(1.0, createVector(5, -4, 2, 3).normalize().getNorm().getValue(), 1.0e-12);\n+        try {\n+            createVector(0, 0, 0, 3).normalize();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testNegate() {\n+        checkVector(createVector(0.1, 2.5, 1.3, 3).negate(),\n+                    -0.1, -2.5, -1.3, -1, 0, 0, 0, -1, 0, 0, 0, -1);\n+    }\n+\n+    @Test\n+    public void testOrthogonal() throws MathArithmeticException {\n+        Vector3DDS v1 = createVector(0.1, 2.5, 1.3, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.dotProduct(v1, v1.orthogonal()).getValue(), 1.0e-12);\n+        Vector3DDS v2 = createVector(2.3, -0.003, 7.6, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.dotProduct(v2, v2.orthogonal()).getValue(), 1.0e-12);\n+        Vector3DDS v3 = createVector(-1.7, 1.4, 0.2, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.dotProduct(v3, v3.orthogonal()).getValue(), 1.0e-12);\n+        Vector3DDS v4 = createVector(4.2, 0.1, -1.8, 3);\n+        Assert.assertEquals(0.0, Vector3DDS.dotProduct(v4, v4.orthogonal()).getValue(), 1.0e-12);\n+        try {\n+            createVector(0, 0, 0, 3).orthogonal();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAngle() throws MathArithmeticException {\n+        Assert.assertEquals(0.22572612855273393616,\n+                            Vector3DDS.angle(createVector(1, 2, 3, 3), createVector(4, 5, 6, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(7.98595620686106654517199e-8,\n+                            Vector3DDS.angle(createVector(1, 2, 3, 3), createVector(2, 4, 6.000001, 3)).getValue(),\n+                            1.0e-12);\n+        Assert.assertEquals(3.14159257373023116985197793156,\n+                            Vector3DDS.angle(createVector(1, 2, 3, 3), createVector(-2, -4, -6.000001, 3)).getValue(),\n+                            1.0e-12);\n+        try {\n+            Vector3DDS.angle(createVector(0, 0, 0, 3), createVector(1, 0, 0, 3));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAccurateDotProduct() {\n+        // the following two vectors are nearly but not exactly orthogonal\n+        // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of 0.0, instead of the correct -1.855129...\n+        Vector3DDS u1 = createVector(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -7645843051051357.0 / 8589934592.0, 3);\n+        Vector3DDS u2 = createVector(-5712344449280879.0 /    2097152.0,\n+                                   -4550117129121957.0 /    2097152.0,\n+                                    8846951984510141.0 /     131072.0, 3);\n+        DerivativeStructure sNaive = u1.getX().multiply(u2.getX()).add(u1.getY().multiply(u2.getY())).add(u1.getZ().multiply(u2.getZ()));\n+        DerivativeStructure sAccurate = u1.dotProduct(u2);\n+        Assert.assertEquals(0.0, sNaive.getValue(), 1.0e-30);\n+        Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate.getValue(), 1.0e-16);\n+    }\n+\n+    @Test\n+    public void testDotProduct() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(553267312521321234l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = 10000 * random.nextDouble();\n+            double uy = 10000 * random.nextDouble();\n+            double uz = 10000 * random.nextDouble();\n+            double vx = 10000 * random.nextDouble();\n+            double vy = 10000 * random.nextDouble();\n+            double vz = 10000 * random.nextDouble();\n+            double sNaive = ux * vx + uy * vy + uz * vz;\n+\n+            Vector3DDS uds = createVector(ux, uy, uz, 3);\n+            Vector3DDS vds = createVector(vx, vy, vz, 3);\n+            Vector3D v = new Vector3D(vx, vy, vz);\n+\n+            DerivativeStructure sAccurate = Vector3DDS.dotProduct(uds, vds);\n+            Assert.assertEquals(sNaive, sAccurate.getValue(), 2.5e-16 * sNaive);\n+            Assert.assertEquals(ux + vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(uy + vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(uz + vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n+\n+            sAccurate = Vector3DDS.dotProduct(uds, v);\n+            Assert.assertEquals(sNaive, sAccurate.getValue(), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n+\n+            sAccurate = Vector3DDS.dotProduct(v, uds);\n+            Assert.assertEquals(sNaive, sAccurate.getValue(), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive);\n+            Assert.assertEquals(vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testAccurateCrossProduct() {\n+        // the vectors u1 and u2 are nearly but not exactly anti-parallel\n+        // (7.31e-16 degrees from 180 degrees) naive cross product (i.e.\n+        // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of   [0.0009765, -0.0001220, -0.0039062],\n+        // instead of the correct [0.0006913, -0.0001254, -0.0007909]\n+        final Vector3DDS u1 = createVector(-1321008684645961.0 /   268435456.0,\n+                                         -5774608829631843.0 /   268435456.0,\n+                                         -7645843051051357.0 /  8589934592.0, 3);\n+        final Vector3DDS u2 = createVector( 1796571811118507.0 /  2147483648.0,\n+                                          7853468008299307.0 /  2147483648.0,\n+                                          2599586637357461.0 / 17179869184.0, 3);\n+        final Vector3DDS u3 = createVector(12753243807587107.0 / 18446744073709551616.0, \n+                                         -2313766922703915.0 / 18446744073709551616.0, \n+                                          -227970081415313.0 /   288230376151711744.0, 3);\n+        Vector3DDS cNaive = new Vector3DDS(u1.getY().multiply(u2.getZ()).subtract(u1.getZ().multiply(u2.getY())),\n+                                       u1.getZ().multiply(u2.getX()).subtract(u1.getX().multiply(u2.getZ())),\n+                                       u1.getX().multiply(u2.getY()).subtract(u1.getY().multiply(u2.getX())));\n+        Vector3DDS cAccurate = u1.crossProduct(u2);\n+        Assert.assertTrue(u3.distance(cNaive).getValue() > 2.9 * u3.getNorm().getValue());\n+        Assert.assertEquals(0.0, u3.distance(cAccurate).getValue(), 1.0e-30 * cAccurate.getNorm().getValue());\n+    }\n+\n+    @Test\n+    public void testCrossProduct() {\n+        // we compare accurate versus naive cross product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(885362227452043214l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = random.nextDouble();\n+            double uy = random.nextDouble();\n+            double uz = random.nextDouble();\n+            double vx = random.nextDouble();\n+            double vy = random.nextDouble();\n+            double vz = random.nextDouble();\n+            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);\n+\n+            Vector3DDS uds = createVector(ux, uy, uz, 3);\n+            Vector3DDS vds = createVector(vx, vy, vz, 3);\n+            Vector3D v = new Vector3D(vx, vy, vz);\n+\n+            checkVector(Vector3DDS.crossProduct(uds, vds),\n+                        cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n+                        0, vz - uz, uy - vy,\n+                        uz - vz, 0, vx - ux,\n+                        vy - uy, ux - vx, 0);\n+\n+            checkVector(Vector3DDS.crossProduct(uds, v),\n+                        cNaive.getX(), cNaive.getY(), cNaive.getZ(),\n+                          0,  vz, -vy,\n+                        -vz,   0,  vx,\n+                         vy, -vx,   0);\n+\n+            checkVector(Vector3DDS.crossProduct(v, uds),\n+                        -cNaive.getX(), -cNaive.getY(), -cNaive.getZ(),\n+                          0, -vz,  vy,\n+                         vz,   0, -vx,\n+                        -vy,  vx,   0);\n+\n+        }\n+    }\n+\n+    private Vector3DDS createVector(double x, double y, double z, int params) {\n+        return new Vector3DDS(new DerivativeStructure(params, 1, 0, x),\n+                              new DerivativeStructure(params, 1, 1, y),\n+                              new DerivativeStructure(params, 1, 2, z));\n+    }\n+\n+    private void checkVector(Vector3DDS v, double x, double y, double z) {\n+        Assert.assertEquals(x, v.getX().getValue(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getValue(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getValue(), 1.0e-12);\n+    }\n+\n+    private void checkVector(Vector3DDS v, double x, double y, double z,\n+                             double dxdx, double dxdy, double dxdz,\n+                             double dydx, double dydy, double dydz,\n+                             double dzdx, double dzdy, double dzdz) {\n+        Assert.assertEquals(x, v.getX().getValue(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getValue(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getValue(), 1.0e-12);\n+        Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1), 1.0e-12);\n+    }\n+\n+    private void checkVector(Vector3DDS v, double x, double y, double z,\n+                             double dxdx, double dxdy, double dxdz, double dxdt,\n+                             double dydx, double dydy, double dydz, double dydt,\n+                             double dzdx, double dzdy, double dzdz, double dzdt) {\n+        Assert.assertEquals(x, v.getX().getValue(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY().getValue(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ().getValue(), 1.0e-12);\n+        Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dxdt, v.getX().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dydt, v.getY().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+        Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0, 0), 1.0e-12);\n+        Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1, 0), 1.0e-12);\n+        Assert.assertEquals(dzdt, v.getZ().getPartialDerivative(0, 0, 0, 1), 1.0e-12);\n+    }\n+\n+}", "timestamp": 1361195901, "metainfo": ""}