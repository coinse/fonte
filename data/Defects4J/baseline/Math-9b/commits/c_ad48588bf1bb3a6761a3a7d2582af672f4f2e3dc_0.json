{"sha": "ad48588bf1bb3a6761a3a7d2582af672f4f2e3dc", "log": "Fixed two errors in simplex solver when entries are close together or when variables are not restricted to non-negative.  Jira: MATH-434  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n \n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n \n  * @since 2.0\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n-\n-    /** Default amount of error to accept in floating point comparisons. */\n+    \n+    /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n-\n-    /** Amount of error to accept in floating point comparisons. */\n+     \n+    /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n+    /** Amount of error to accept in floating point comparisons (as ulps). */\n+    protected final int maxUlps;\n+\n     /**\n      * Build a simplex solver with default settings.\n      */\n     public SimplexSolver() {\n-        this(DEFAULT_EPSILON);\n+        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n     }\n \n     /**\n      * Build a simplex solver with a specified accepted amount of error\n-     * @param epsilon the amount of error to accept in floating point comparisons\n-     */\n-    public SimplexSolver(final double epsilon) {\n+     * @param epsilon the amount of error to accept for algorithm convergence\n+     * @param maxUlps amount of error to accept in floating point comparisons \n+     */\n+    public SimplexSolver(final double epsilon, final int maxUlps) {\n         this.epsilon = epsilon;\n+        this.maxUlps = maxUlps;\n     }\n \n     /**\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, minValue, getEpsilon(entry)) < 0) {\n+                minValue = entry;\n                 minPos = i;\n             }\n         }\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            \n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 final double ratio = rhs / entry;\n-                if (MathUtils.equals(ratio, minRatio, epsilon)) {\n+                final int cmp = MathUtils.compareTo(ratio, minRatio, getEpsilon(ratio));\n+                if (cmp == 0) {\n                     minRatioPositions.add(i);\n-                } else if (ratio < minRatio) {\n+                } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n                     minRatioPositions.add(i);\n           for (Integer row : minRatioPositions) {\n             for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n               int column = i + tableau.getArtificialVariableOffset();\n-              if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) &&\n+              final double entry = tableau.getEntry(row, column);\n+              if (MathUtils.equals(entry, 1d, getEpsilon(entry)) &&\n                   row.equals(tableau.getBasicRow(column))) {\n                 return row;\n               }\n         }\n \n         // if W is not zero then we have no feasible solution\n-        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n             throw new NoFeasibleSolutionException();\n         }\n     }\n     @Override\n     public RealPointValuePair doOptimize() throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n+            new SimplexTableau(function, linearConstraints, goal, nonNegative, \n+                               epsilon, maxUlps);\n \n         solvePhase1(tableau);\n         tableau.dropPhase1Objective();\n         return tableau.getSolution();\n     }\n \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     /** Column label for negative vars. */\n     private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1369660067587938365L;\n \n     /** Number of artificial variables. */\n     private int numArtificialVariables;\n \n+    /** Amount of error to accept when checking for optimality. */\n+    private final double epsilon;\n+\n     /** Amount of error to accept in floating point comparisons. */\n-    private final double epsilon;\n+    private final int maxUlps;\n \n     /**\n      * Build a tableau for a linear problem.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n-     * @param epsilon amount of error to accept in floating point comparisons\n+     * @param epsilon amount of error to accept when checking for optimality\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n+        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n+    }\n+    \n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @param epsilon amount of error to accept when checking for optimality\n+     * @param maxUlps amount of error to accept in floating point comparisons \n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative,\n+                   final double epsilon,\n+                   final int maxUlps) {\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n+        this.maxUlps                = maxUlps;\n         this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                       (restrictToNonNegative ? 0 : 1);\n         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n-                getInvertedCoeffiecientSum(objectiveCoefficients));\n+                getInvertedCoefficientSum(objectiveCoefficients));\n         }\n \n         // initialize the constraint rows\n             // x-\n             if (!restrictToNonNegative) {\n                 matrix.setEntry(row, getSlackVariableOffset() - 1,\n-                    getInvertedCoeffiecientSum(constraint.getCoefficients()));\n+                    getInvertedCoefficientSum(constraint.getCoefficients()));\n             }\n \n             // RHS\n      * @param coefficients coefficients to sum\n      * @return the -1 times the sum of all coefficients in the given array.\n      */\n-    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n         double sum = 0;\n         for (double coefficient : coefficients.getData()) {\n             sum -= coefficient;\n     protected Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = 0; i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            final double entry = getEntry(i, col);\n+            if (MathUtils.equals(entry, 1d, getEpsilon(entry)) && (row == null)) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+            } else if (!MathUtils.equals(entry, 0d, getEpsilon(entry))) {\n                 return null;\n             }\n         }\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n-          if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\n-            columnsToDrop.add(i);\n-          }\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n+                columnsToDrop.add(i);\n+            }\n         }\n \n         // non-basic artificial variables\n      */\n     boolean isOptimal() {\n         for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {\n                 return false;\n             }\n         }\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n-              coefficients[i] = 0;\n+              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n               coefficients[i] =\n                  (numSlackVariables      == rhs.numSlackVariables) &&\n                  (numArtificialVariables == rhs.numArtificialVariables) &&\n                  (epsilon                == rhs.epsilon) &&\n+                 (maxUlps                == rhs.maxUlps) &&\n                  f.equals(rhs.f) &&\n                  constraints.equals(rhs.constraints) &&\n                  tableau.equals(rhs.tableau);\n                numSlackVariables ^\n                numArtificialVariables ^\n                Double.valueOf(epsilon).hashCode() ^\n+               maxUlps ^\n                f.hashCode() ^\n                constraints.hashCode() ^\n                tableau.hashCode();\n         ois.defaultReadObject();\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n     }\n-\n+    \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }    \n }\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n import org.junit.Test;\n \n public class SimplexSolverTest {\n \n+    @Test\n+    public void test434NegativeVariable() throws OptimizationException\n+    {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d);\n+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5));\n+        constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10));\n+\n+        double epsilon = 1e-6;\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+\n+        Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);\n+        Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);\n+        Assert.assertEquals(-10.0, solution.getValue(), epsilon);\n+\n+    }\n+\n+    @Test(expected = NoFeasibleSolutionException.class)\n+    public void test434UnfeasibleSolution() throws OptimizationException\n+    {\n+        double epsilon = 1e-6;\n+\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0);\n+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0));\n+        constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        // allowing only non-negative values, no feasible solution shall be found\n+        solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+    }\n+\n+    @Test\n+    public void test434PivotRowSelection() throws OptimizationException\n+    {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0);\n+\n+        double epsilon = 1e-6;\n+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1));\n+        constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));\n+\n+        SimplexSolver solver = new SimplexSolver();\n+        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        \n+        Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);\n+        Assert.assertEquals(0.0050, solution.getValue(), epsilon);\n+    }\n+\n+    @Test\n+    public void test434PivotRowSelection2() throws OptimizationException\n+    {\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);\n+\n+        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d));\n+        constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));\n+        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));\n+\n+        double epsilon = 1e-7;\n+        SimplexSolver simplex = new SimplexSolver();\n+        RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);\n+        \n+        Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);\n+        Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);        \n+        Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);\n+        Assert.assertEquals(1.0d, solution.getValue(), epsilon);\n+    }\n+    \n     @Test\n     public void testMath272() throws OptimizationException {\n         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);", "timestamp": 1302376847, "metainfo": ""}