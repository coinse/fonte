{"sha": "06941303608fe910b65022681b904dfe57bef09f", "log": "fixed javadoc warnings  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n * <p>\n * Supports nesting, emulating JDK 1.4 behavior if necessary.</p>\n * <p>\n-* Adapted from {@link org.apache.commons.collections.FunctorException}.</p>\n+* Adapted from <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/FunctorException.html\"/>.</p>\n * \n * @version $Revision$ $Date$\n */\n--- a/src/java/org/apache/commons/math/fraction/AbstractFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/AbstractFormat.java\n      * @param position On input: an alignment field, if desired. On output: the\n      *            offsets of the alignment field\n      * @return a reference to the appended buffer\n-     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n+     * @see #format(Object, StringBuffer, FieldPosition)\n      */\n     @Override\n     public StringBuffer format(final double value,\n      * @param position On input: an alignment field, if desired. On output: the\n      *            offsets of the alignment field\n      * @return a reference to the appended buffer\n-     * @see {@link #format(Object, StringBuffer, FieldPosition)}\n+     * @see #format(Object, StringBuffer, FieldPosition)\n      */\n     @Override\n     public StringBuffer format(final long value,\n--- a/src/java/org/apache/commons/math/linear/DenseFieldMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseFieldMatrix.java\n      *\n      * @exception IllegalArgumentException if <code>blockData</code> shape is\n      * inconsistent with block layout\n-     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     * @see #DenseFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n     public DenseFieldMatrix(final T[][] rawData)\n         throws IllegalArgumentException {\n      * @exception IllegalArgumentException if <code>blockData</code> shape is\n      * inconsistent with block layout\n      * @see #createBlocksLayout(Field, int, int)\n-     * @see #toBlocksLayout(T[][])\n-     * @see #DenseFieldMatrix(T[][])\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #DenseFieldMatrix(FieldElement[][])\n      */\n     public DenseFieldMatrix(final int rows, final int columns,\n                             final T[][] blockData, final boolean copyArray)\n      * <p>\n      * This method creates an array in blocks layout from an input array in raw layout.\n      * It can be used to provide the array argument of the {@link\n-     * DenseFieldMatrix#DenseFieldMatrix(int, int, T[][], boolean)} constructor.\n+     * DenseFieldMatrix#DenseFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n      * </p>\n      * @param <T> the type of the field elements\n      * @param rawData data array in raw layout\n      * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n      *  (not all rows have the same length)\n      * @see #createBlocksLayout(Field, int, int)\n-     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     * @see #DenseFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n     public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n         throws IllegalArgumentException {\n      * Create a data array in blocks layout.\n      * <p>\n      * This method can be used to create the array argument of the {@link\n-     * DenseFieldMatrix#DenseFieldMatrix(int, int, T[][], boolean)} constructor.\n+     * DenseFieldMatrix#DenseFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n      * </p>\n      * @param <T> the type of the field elements\n      * @param field field to which the elements belong\n      * @param rows  the number of rows in the new matrix\n      * @param columns  the number of columns in the new matrix\n      * @return a new data array in blocks layout\n-     * @see #toBlocksLayout(T[][])\n-     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #DenseFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n     public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field,\n                                                                        final int rows, final int columns) {\n--- a/src/java/org/apache/commons/math/linear/FieldMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrixImpl.java\n      * Create a new FieldMatrix<T> using the input array as the underlying\n      * data array.\n      * <p>The input array is copied, not referenced. This constructor has\n-     * the same effect as calling {@link #FieldMatrixImpl(T[][], boolean)}\n+     * the same effect as calling {@link #FieldMatrixImpl(FieldElement[][], boolean)}\n      * with the second argument set to <code>true</code>.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>d</code> is null\n-     * @see #FieldMatrixImpl(T[][], boolean)\n+     * @see #FieldMatrixImpl(FieldElement[][], boolean)\n      */\n     public FieldMatrixImpl(final T[][] d)\n         throws IllegalArgumentException, NullPointerException {\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>d</code> is null\n-     * @see #FieldMatrixImpl(T[][])\n+     * @see #FieldMatrixImpl(FieldElement[][])\n      */\n     public FieldMatrixImpl(final T[][] d, final boolean copyArray)\n         throws IllegalArgumentException, NullPointerException {\n--- a/src/java/org/apache/commons/math/linear/FieldVector.java\n+++ b/src/java/org/apache/commons/math/linear/FieldVector.java\n      * @param v vector containing the values to set.\n      * @exception MatrixIndexException if the index is\n      * inconsistent with vector size\n-     * @see #setSubVector(int, T[])\n+     * @see #setSubVector(int, FieldElement[])\n      */\n     void setSubVector(int index, FieldVector<T> v)\n         throws MatrixIndexException;\n--- a/src/java/org/apache/commons/math/linear/FieldVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/FieldVectorImpl.java\n      * <p>Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #FieldVectorImpl(FieldVectorImpl, FieldVectorImpl)} constructor\n-     * or one of the <code>append</code> methods ({@link #append(double)}, {@link\n-     * #append(T[])}, {@link #append(FieldVectorImpl)}) to gather data\n+     * or one of the <code>append</code> methods ({@link #append(FieldElement[])},\n+     * {@link #add(FieldVector)}, {@link #append(FieldVectorImpl)}) to gather data\n      * into this vector.</p>\n      * @param field field to which the elements belong\n      */\n      * it will be referenced\n      * @throws IllegalArgumentException if <code>d</code> is empty\n      * @throws NullPointerException if <code>d</code> is null\n-     * @see #FieldVectorImpl(T[])\n+     * @see #FieldVectorImpl(FieldElement[])\n      */\n     public FieldVectorImpl(T[] d, boolean copyArray)\n         throws NullPointerException, IllegalArgumentException {\n--- a/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n      * Build a 0-length vector.\n      * <p>Zero-length vectors may be used to initialize construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n-     * #SparseFieldVector(SparseFieldVector<T>, int)} constructor\n-     * or one of the <code>append</code> method ({@link #append(Field<T>)}, {@link\n-     * #append(Field<T>[])}, {@link #append(FieldVector)}) to gather data\n-     * into this vector.</p>\n+     * #SparseFieldVector(SparseFieldVector, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(FieldElement)},\n+     * {@link #append(FieldElement[])}, {@link #append(FieldVector)},\n+     * {@link #append(SparseFieldVector)}) to gather data into this vector.</p>\n      * @param field field to which the elements belong\n      */\n     public SparseFieldVector(Field<T> field) {\n         return res;\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n     public FieldVector<T> append(SparseFieldVector<T> v) {\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension());\n         OpenIntToFieldHashMap<T>.Iterator iter = v.entries.iterator();\n--- a/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n     /** Get the number of evaluations of the objective function.\n      * <p>\n      * The number of evaluation correspond to the last call to the\n-     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n+     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method. It is 0 if\n+     * the method has not been called yet.\n      * </p>\n      * @return number of evaluations of the objective function\n      */\n     /** Get the number of evaluations of the objective function jacobian .\n      * <p>\n      * The number of evaluation correspond to the last call to the\n-     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n+     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method. It is 0 if\n+     * the method has not been called yet.\n      * </p>\n      * @return number of evaluations of the objective function jacobian\n      */\n--- a/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n      * @param weights weights to apply to the residuals\n      * @exception IllegalArgumentException if the observations vector and the weights\n      * vector dimensions don't match (objective function dimension is checked only when\n-     * the {@link #objective} method is called)\n+     * the {@link #value(double[])} method is called)\n      */\n     public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations, final double[] weights)\n      * @param scale scaling matrix\n      * @exception IllegalArgumentException if the observations vector and the scale\n      * matrix dimensions don't match (objective function dimension is checked only when\n-     * the {@link #objective} method is called)\n+     * the {@link #value(double[])} method is called)\n      */\n     public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations, final RealMatrix scale)\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /** \n     }\n \n     /** Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n+     * optimize}.\n      * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n-     * double[]) optimize} method returns the best point only. This\n+     * restarts. The {@link #optimize(DifferentiableMultivariateRealFunction,\n+     * GoalType, double[]) optimize} method returns the best point only. This\n      * method returns all the points found at the end of each starts,\n      * including the best one already returned by the {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n-     * method.\n+     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n+     * optimize} method.\n      * </p>\n      * <p>\n      * The returned array as one element for each start as specified\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * elements will be null if the {@link #optimize(DifferentiableMultivariateRealFunction,\n      * GoalType, double[]) optimize} method did throw a {@link\n      * ConvergenceException ConvergenceException}). This also means that\n      * if the first element is non null, it is the best point found across\n      * all starts.</p>\n      * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateRealFunction,\n      * GoalType, double[]) optimize} has not been called\n      */\n     public RealPointValuePair[] getOptima() throws IllegalStateException {\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /** \n     }\n \n     /** Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize}.\n      * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n-     * double[]) optimize} method returns the best point only. This\n-     * method returns all the points found at the end of each starts,\n-     * including the best one already returned by the {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n-     * method.\n+     * restarts. The {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method returns the\n+     * best point only. This method returns all the points found at the\n+     * end of each starts, including the best one already returned by the {@link\n+     * #optimize(DifferentiableMultivariateVectorialFunction, double[],\n+     * double[], double[]) optimize} method.\n      * </p>\n      * <p>\n      * The returned array as one element for each start as specified\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} method did throw a {@link\n+     * elements will be null if the {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method did throw a {@link\n      * ConvergenceException ConvergenceException}). This also means that\n      * if the first element is non null, it is the best point found across\n      * all starts.</p>\n      * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} has not been called\n+     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} has not been called\n      */\n     public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n--- a/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.random.RandomGenerator;\n \n     }\n \n     /** Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n      * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n-     * double[]) optimize} method returns the best point only. This\n+     * restarts. The {@link #optimize(UnivariateRealFunction, GoalType,\n+     * double, double) optimize} method returns the best point only. This\n      * method returns all the points found at the end of each starts,\n      * including the best one already returned by the {@link\n-     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n      * method.\n      * </p>\n      * <p>\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} method did throw a {@link\n+     * elements will be null if the {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} method did throw a {@link\n      * ConvergenceException ConvergenceException}). This also means that\n      * if the first element is non null, it is the best point found across\n      * all starts.</p>\n      * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n-     * GoalType, double[]) optimize} has not been called\n+     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} has not been called\n      */\n     public double[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n--- a/src/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n \n package org.apache.commons.math.optimization;\n \n-/** This interface specifies how to check if an {@link VectorialOptimizer optimization\n- * algorithm} has converged.\n+/** This interface specifies how to check if a {@link\n+ * DifferentiableMultivariateVectorialOptimizer optimization algorithm} has converged.\n  *\n  * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n  * user should provide a class implementing this interface to allow the optimization\n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n      * and the maximal number of evaluation is set to\n-     * {@link AbstractLinearOptimizer#DEFAULT_MAX_ITERATIONS}.\n+     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_ITERATIONS}.\n      * @param useLU if true, the normal equations will be solved using LU\n      * decomposition, otherwise they will be solved using QR decomposition\n      */\n--- a/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n-     * and the maximal number of evaluation is set to\n-     * {@link AbstractLinearOptimizer#DEFAULT_MAX_EVALUATIONS}.\n+     * and the maximal number of iterations is set to\n+     * {@link AbstractScalarDifferentiableOptimizer#DEFAULT_MAX_ITERATIONS}.\n      * @param updateFormula formula to use for updating the &beta; parameter,\n-     * must be one of {@link UpdateFormula#FLETCHER_REEVES} or {@link\n-     * UpdateFormula#POLAK_RIBIERE}\n+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n+     * ConjugateGradientFormula#POLAK_RIBIERE}\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) {\n         this.updateFormula = updateFormula;\n--- a/src/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n import java.io.Serializable;\n import java.util.Collection;\n \n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n     /** Get the number of iterations realized by the algorithm.\n      * <p>\n      * The number of evaluations corresponds to the last call to the\n-     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * {@link #optimize(LinearObjectiveFunction, Collection, GoalType, boolean) optimize}\n      * method. It is 0 if the method has not been called yet.\n      * </p>\n      * @return number of iterations\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n \n /**\n  * A Default NumberTransformer for java.lang.Numbers and Numeric Strings. This \n- * provides some simple conversion capabilities to turn any java/lang.Number \n+ * provides some simple conversion capabilities to turn any java.lang.Number \n  * into a primitive double or to turn a String representation of a Number into \n  * a double.\n  *\n      * @return a double primitive representation of the Object o.\n      * @throws org.apache.commons.math.MathException If it cannot successfully \n      * be transformed or is null.\n-     * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n+     * @see <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/Transformer.html\"/>\n      */\n     public double transform(Object o) throws MathException{\n ", "timestamp": 1243869055, "metainfo": ""}