{"sha": "1161903b77703b1a6487d2f768703011ef58dcad", "log": "Set up a named Wrapper inner class to map state plus jacobians into compound state for ODE integration with added variational equations  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n             checkDimension(k, dYdP[0]);\n         }\n \n+        // set up initial state, including partial derivatives\n         // the compound state z contains the raw state y and its derivatives\n         // with respect to initial state y0 and to parameters p\n         //    y[i]         is stored in z[i]\n         //    dy[i]/dy0[j] is stored in z[n + i * n + j]\n         //    dy[i]/dp[j]  is stored in z[n * (n + 1) + i * k + j]\n-        final int q = n * (1 + n + k);\n-\n-        // set up initial state, including partial derivatives\n-        final double[] z = new double[q];\n+        final double[] z = new double[n * (1 + n + k)];\n         System.arraycopy(y0, 0, z, 0, n);\n         for (int i = 0; i < n; ++i) {\n \n         }\n \n         // integrate the compound state variational equations\n-        final double stopTime = integrator.integrate(new FirstOrderDifferentialEquations() {\n-\n-            /** Current state. */\n-            private final double[]   y    = new double[n];\n-\n-            /** Time derivative of the current state. */\n-            private final double[]   yDot = new double[n];\n-\n-            /** Derivatives of yDot with respect to state. */\n-            private final double[][] dFdY = new double[n][n];\n-\n-            /** Derivatives of yDot with respect to parameters. */\n-            private final double[][] dFdP = new double[n][k];\n-\n-            /** {@inheritDoc} */\n-            public int getDimension() {\n-                return q;\n-            }\n-\n-            /** {@inheritDoc} */\n-            public void computeDerivatives(final double t, final double[] z, final double[] zDot)\n-                throws DerivativeException {\n-\n-                // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n-                System.arraycopy(z,    0, y,    0, n);\n-                ode.computeDerivatives(t, y, yDot);\n-                ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n-\n-                // state part of the compound equations\n-                System.arraycopy(yDot, 0, zDot, 0, n);\n-\n-                // variational equations: from d[dy/dt]/dy0 to d[dy/dy0]/dt\n-                for (int i = 0; i < n; ++i) {\n-                    final double[] dFdYi = dFdY[i];\n-                    for (int j = 0; j < n; ++j) {\n-                        double s = 0;\n-                        final int startIndex = n + j;\n-                        int zIndex = startIndex;\n-                        for (int l = 0; l < n; ++l) {\n-                            s += dFdYi[l] * z[zIndex];\n-                            zIndex += n;\n-                        }\n-                        zDot[startIndex + i * n] = s;\n-                    }\n-                }\n-\n-                // variational equations: from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dp]/dt\n-                for (int i = 0; i < n; ++i) {\n-                    final double[] dFdYi = dFdY[i];\n-                    final double[] dFdPi = dFdP[i];\n-                    for (int j = 0; j < k; ++j) {\n-                        double s = dFdPi[j];\n-                        final int startIndex = n * (n + 1) + j;\n-                        int zIndex = startIndex;\n-                        for (int l = 0; l < n; ++l) {\n-                            s += dFdYi[l] * z[zIndex];\n-                            zIndex += k;\n-                        }\n-                        zDot[startIndex + i * k] = s;\n-                    }\n-                }\n-\n-            }\n-\n-        }, t0, z, t, z);\n+        final double stopTime = integrator.integrate(new MappingWrapper(ode), t0, z, t, z);\n \n         // dispatch the final compound state into the state and partial derivatives arrays\n         System.arraycopy(z, 0, y, 0, n);\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"dimension mismatch {0} != {1}\", arrayDimension, expected);\n         }\n+    }\n+\n+    /** Wrapper class used to map state and jacobians into compound state. */\n+    private static class MappingWrapper implements  FirstOrderDifferentialEquations {\n+\n+        /** Underlying ODE with jacobians. */\n+        private final ParameterizedODEWithJacobians ode;\n+\n+        /** Current state. */\n+        private final double[]   y;\n+\n+        /** Time derivative of the current state. */\n+        private final double[]   yDot;\n+\n+        /** Derivatives of yDot with respect to state. */\n+        private final double[][] dFdY;\n+\n+        /** Derivatives of yDot with respect to parameters. */\n+        private final double[][] dFdP;\n+\n+        /** Simple constructor.\n+         * @param ode underlying ODE with jacobians\n+         */\n+        public MappingWrapper(final ParameterizedODEWithJacobians ode) {\n+\n+            this.ode = ode;\n+\n+            final int n = ode.getDimension();\n+            final int k = ode.getParametersDimension();\n+            y    = new double[n];\n+            yDot = new double[n];\n+            dFdY = new double[n][n];\n+            dFdP = new double[n][k];\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            final int n = y.length;\n+            final int k = dFdP[0].length;\n+            return n * (1 + n + k);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(final double t, final double[] z, final double[] zDot)\n+            throws DerivativeException {\n+\n+            final int n = y.length;\n+            final int k = dFdP[0].length;\n+\n+            // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n+            System.arraycopy(z,    0, y,    0, n);\n+            ode.computeDerivatives(t, y, yDot);\n+            ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n+\n+            // state part of the compound equations\n+            System.arraycopy(yDot, 0, zDot, 0, n);\n+\n+            // variational equations: from d[dy/dt]/dy0 to d[dy/dy0]/dt\n+            for (int i = 0; i < n; ++i) {\n+                final double[] dFdYi = dFdY[i];\n+                for (int j = 0; j < n; ++j) {\n+                    double s = 0;\n+                    final int startIndex = n + j;\n+                    int zIndex = startIndex;\n+                    for (int l = 0; l < n; ++l) {\n+                        s += dFdYi[l] * z[zIndex];\n+                        zIndex += n;\n+                    }\n+                    zDot[startIndex + i * n] = s;\n+                }\n+            }\n+\n+            // variational equations: from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dp]/dt\n+            for (int i = 0; i < n; ++i) {\n+                final double[] dFdYi = dFdY[i];\n+                final double[] dFdPi = dFdP[i];\n+                for (int j = 0; j < k; ++j) {\n+                    double s = dFdPi[j];\n+                    final int startIndex = n * (n + 1) + j;\n+                    int zIndex = startIndex;\n+                    for (int l = 0; l < n; ++l) {\n+                        s += dFdYi[l] * z[zIndex];\n+                        zIndex += k;\n+                    }\n+                    zDot[startIndex + i * k] = s;\n+                }\n+            }\n+\n+        }\n+\n     }\n \n     /** Wrapper class to compute jacobians by finite differences for ODE which do not compute them themselves. */\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n             double dy0  = y0[1] - cy;\n             return new double[][] {\n                 {  oSin, oCos, -sin * dx0 - cos * dy0 - t * ( oCos * dx0 - oSin * dy0) },\n-                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0)}\n+                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0) }\n             };\n         }\n ", "timestamp": 1267901667, "metainfo": ""}