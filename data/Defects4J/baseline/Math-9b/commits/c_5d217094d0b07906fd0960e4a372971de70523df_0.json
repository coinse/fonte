{"sha": "5d217094d0b07906fd0960e4a372971de70523df", "log": "Change the default value for those UnivariateStatistics that have a conventional value on the empty set. JIRA: MATH-373    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n         final double[] values,\n         final int begin,\n         final int length) {\n-\n-        if (values == null) {\n-            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n-        }\n-\n-        if (begin < 0) {\n-            throw new NotPositiveException(LocalizedFormats.START_POSITION, begin);\n-        }\n-\n-        if (length < 0) {\n-            throw new NotPositiveException(LocalizedFormats.LENGTH, length);\n-        }\n-\n-        if (begin + length > values.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END);\n-        }\n-\n-        if (length == 0) {\n-            return false;\n-        }\n-\n-        return true;\n+    \treturn test(values, begin, length, false);\n+    }\n+    \n+    /**\n+     * This method is used by <code>evaluate(double[], int, int)</code> methods\n+     * to verify that the input parameters designate a subarray of positive length.\n+     * <p>\n+     * <ul>\n+     * <li>returns <code>true</code> iff the parameters designate a subarray of\n+     * non-negative length</li>\n+     * <li>throws <code>IllegalArgumentException</code> if the array is null or\n+     * or the indices are invalid</li>\n+     * <li>returns <code>false</li> if the array is non-null, but\n+     * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n+     * @return true if the parameters are valid\n+     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @since 3.0\n+     */\n+    protected boolean test(final double[] values, final int begin, final int length, final boolean allowEmpty){\n+\n+    \tif (values == null) {\n+    \t\tthrow new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+    \t}\n+\n+    \tif (begin < 0) {\n+    \t\tthrow new NotPositiveException(LocalizedFormats.START_POSITION, begin);\n+    \t}\n+\n+    \tif (length < 0) {\n+    \t\tthrow new NotPositiveException(LocalizedFormats.LENGTH, length);\n+    \t}\n+\n+    \tif (begin + length > values.length) {\n+    \t\tthrow MathRuntimeException.createIllegalArgumentException(\n+    \t\t\t\tLocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END);\n+    \t}\n+\n+    \tif (length == 0 && !allowEmpty) {\n+    \t\treturn false;\n+    \t}\n+\n+    \treturn true;\n \n     }\n \n         final double[] weights,\n         final int begin,\n         final int length) {\n+    \treturn test(values, weights, begin, length, false);\n+    }\n+    \n+    /**\n+     * This method is used by <code>evaluate(double[], double[], int, int)</code> methods\n+     * to verify that the begin and length parameters designate a subarray of positive length\n+     * and the weights are all non-negative, non-NaN, finite, and not all zero.\n+     * <p>\n+     * <ul>\n+     * <li>returns <code>true</code> iff the parameters designate a subarray of\n+     * non-negative length and the weights array contains legitimate values.</li>\n+     * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li></ul>\n+     * </li>\n+     * <li>returns <code>false</li> if the array is non-null, but\n+     * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @param allowEmpty if <code>true</code> than allow zero length arrays to pass\n+     * @return true if the parameters are valid \n+     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @since 3.0\n+     */\n+    protected boolean test(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty){\n \n         if (weights == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n                     LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n         }\n \n-        return test(values, begin, length);\n+        return test(values, begin, length, allowEmpty);\n     }\n }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n /**\n  * Returns the product of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 1 is returned.\n+ *  If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n      */\n     public Product() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 1;\n     }\n \n     /**\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n-            value *= d;\n-        }\n+        value *= d;\n         n++;\n     }\n \n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 1;\n         n = 0;\n     }\n \n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= values[i];\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= FastMath.pow(values[i], weights[i]);\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n /**\n   * Returns the sum of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned. \n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n      */\n     public Sum() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n-            value += d;\n-        }\n+        value += d;\n         n++;\n     }\n \n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n     /**\n      * The sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i];\n \n     /**\n      * The weighted sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if any of the following are true:\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i] * weights[i];\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n /**\n  * Returns the sum of the natural logs for this collection of values.\n  * <p>\n- * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n+ * Uses {@link org.apache.commons.Math.util.FastMath#log(double)} to compute the logs.  Therefore,\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n  * <li>If all values are non-negative and less than\n      */\n     @Override\n     public double getResult() {\n-        if (n > 0) {\n-            return value;\n-        } else {\n-            return Double.NaN;\n-        }\n+        return value;\n     }\n \n     /**\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the natural logs of the values or Double.NaN if\n+     * @return the sum of the natural logs of the values or 0 if\n      * length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sumLog = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumLog = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumLog += FastMath.log(values[i]);\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n /**\n  * Returns the sum of the squares of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned.\n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n      */\n     public SumOfSquares() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d * d;\n-        } else {\n-            value += d * d;\n-        }\n+        value += d * d;\n         n++;\n     }\n \n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @return the sum of the squares of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         double sumSq = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumSq = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumSq += values[i] * values[i];\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n \n         // test empty\n         x = new double[] {};\n-        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);\n-        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);\n+        TestUtils.assertEquals(0, StatUtils.sumSq(x), tolerance);\n+        TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), tolerance);\n \n         // test one\n         x = new double[] {two};\n \n         // test empty\n         x = new double[] {};\n-        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);\n-        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);\n+        TestUtils.assertEquals(1, StatUtils.product(x), tolerance);\n+        TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), tolerance);\n \n         // test one\n         x = new double[] {two};\n \n         // test empty\n         x = new double[] {};\n-        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);\n-        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);\n+        TestUtils.assertEquals(0, StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), tolerance);\n \n         // test one\n         x = new double[] {two};\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n             }\n         }\n         assertTrue(testStatistic.test(singletonArray, 0, 1));\n+        assertTrue(testStatistic.test(singletonArray, 0, 0, true));\n     }\n \n     public void testTestNegative() {\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n         statistic.clear();\n \n         // Cleared\n-        assertTrue(Double.isNaN(statistic.getResult()));\n+        checkClearValue(statistic);\n         assertEquals(0, statistic.getN());\n \n     }\n \n+    protected void checkClearValue(StorelessUnivariateStatistic statistic){\n+    \tassertTrue(Double.isNaN(statistic.getResult()));\n+    }\n+    \n     public void testSerialization() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n \n         statistic.clear();\n \n-        assertTrue(Double.isNaN(statistic.getResult()));\n+        checkClearValue(statistic);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n  */\n package org.apache.commons.math.stat.descriptive.summary;\n \n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n \n \n     public void testSpecialValues() {\n         Product product = new Product();\n-        assertTrue(Double.isNaN(product.getResult()));\n+        assertEquals(1, product.getResult(), 0);\n         product.increment(1);\n         assertEquals(1, product.getResult(), 0);\n         product.increment(Double.POSITIVE_INFINITY);\n         assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());\n         assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n+    \n+    protected void checkClearValue(StorelessUnivariateStatistic statistic){\n+    \tassertEquals(1, statistic.getResult(), 0);\n+    }\n+    \n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n  */\n package org.apache.commons.math.stat.descriptive.summary;\n \n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n \n     public void testSpecialValues() {\n         SumOfLogs sum = new SumOfLogs();\n         // empty\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        assertEquals(0, sum.getResult(), 0);\n \n         // finite data\n         sum.increment(1d);\n \n         // clear\n         sum.clear();\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        assertEquals(0, sum.getResult(), 0);\n \n         // positive infinity by itself\n         sum.increment(Double.POSITIVE_INFINITY);\n         sum.increment(-2d);\n         assertTrue(Double.isNaN(sum.getResult()));\n     }\n+    \n+    protected void checkClearValue(StorelessUnivariateStatistic statistic){\n+    \tassertEquals(0, statistic.getResult(), 0);\n+    }\n+    \n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n  */\n package org.apache.commons.math.stat.descriptive.summary;\n \n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n \n \n     public void testSpecialValues() {\n         SumOfSquares sumSq = new SumOfSquares();\n-        assertTrue(Double.isNaN(sumSq.getResult()));\n+        assertEquals(0, sumSq.getResult(), 0);\n         sumSq.increment(2d);\n         assertEquals(4d, sumSq.getResult(), 0);\n         sumSq.increment(Double.POSITIVE_INFINITY);\n         sumSq.increment(1);\n         assertTrue(Double.isNaN(sumSq.getResult()));\n     }\n+    \n+    protected void checkClearValue(StorelessUnivariateStatistic statistic){\n+    \tassertEquals(0, statistic.getResult(), 0);\n+    }\n+    \n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n  */\n package org.apache.commons.math.stat.descriptive.summary;\n \n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n \n \n     public void testSpecialValues() {\n         Sum sum = new Sum();\n-        assertTrue(Double.isNaN(sum.getResult()));\n+        assertEquals(0, sum.getResult(), 0);\n         sum.increment(1);\n         assertEquals(1, sum.getResult(), 0);\n         sum.increment(Double.POSITIVE_INFINITY);\n         assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n         assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n+    \n+    protected void checkClearValue(StorelessUnivariateStatistic statistic){\n+    \tassertEquals(0, statistic.getResult(), 0);\n+    }\n+    \n \n }", "timestamp": 1283402951, "metainfo": ""}