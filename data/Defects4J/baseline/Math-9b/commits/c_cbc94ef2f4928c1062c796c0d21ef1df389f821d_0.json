{"sha": "cbc94ef2f4928c1062c796c0d21ef1df389f821d", "log": "Implementation of the SYMMLQ iterative linear solver, based on Pr. Saunders FORTRAN impl.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.util.ExceptionContext;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.IterationManager;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>\n+ * Implementation of the SYMMLQ iterative linear solver proposed by <a\n+ * href=\"#PAIG1975\">Paige and Saunders (1975)</a>. This implementation is\n+ * largely based on the FORTRAN code by Pr. Michael A. Saunders, available <a\n+ * href=\"http://www.stanford.edu/group/SOL/software/symmlq/f77/\">here</a>.\n+ * </p>\n+ * <p>\n+ * SYMMLQ is designed to solve the system of linear equations A &middot; x = b\n+ * where A is an n &times; n self-adjoint linear operator (defined as a\n+ * {@link RealLinearOperator}), and b is a given vector. The operator A is not\n+ * required to be positive definite. If A is known to be definite, the method of\n+ * conjugate gradients might be preferred, since it will require about the same\n+ * number of iterations as SYMMLQ but slightly less work per iteration.\n+ * </p>\n+ * <p>\n+ * SYMMLQ is designed to solve the system (A - shift &middot; I) &middot; x = b,\n+ * where shift is a specified scalar value. If shift and b are suitably chosen,\n+ * the computed vector x may approximate an (unnormalized) eigenvector of A, as\n+ * in the methods of inverse iteration and/or Rayleigh-quotient iteration.\n+ * Again, the linear operator (A - shift &middot; I) need not be positive\n+ * definite (but <em>must</em> be self-adjoint). The work per iteration is very\n+ * slightly less if shift = 0.\n+ * </p>\n+ * <h3>Peconditioning</h3>\n+ * <p>\n+ * Preconditioning may reduce the number of iterations required. The solver is\n+ * provided with a positive definite preconditioner M = C &middot; C<sup>T</sup>\n+ * that is known to approximate (A - shift &middot; I) in some sense, while\n+ * systems of the form M &middot; y = x can be solved efficiently. Then SYMMLQ\n+ * will implicitly solve the system of equations P &middot; (A - shift &middot;\n+ * I) &middot; P<sup>T</sup> &middot; xhat = P &middot; b, i.e. Ahat &middot;\n+ * xhat = bhat, where P = C<sup>-1</sup>, Ahat = P &middot; (A - shift &middot;\n+ * I) &middot; P<sup>T</sup>, bhat = P &middot; b, and return the solution x =\n+ * P<sup>T</sup> &middot; xhat. The associated residual is rhat = bhat - Ahat\n+ * &middot; xhat = P &middot; [b - (A - shift &middot; I) &middot; x] = P\n+ * &middot; r.\n+ * </p>\n+ * <h3><a id=\"stopcrit\">Default stopping criterion</a></h3>\n+ * <p>\n+ * A default stopping criterion is implemented. The iterations stop when || rhat\n+ * || &le; &delta; || Ahat || || xhat ||, where xhat is the current estimate of\n+ * the solution of the transformed system, rhat the current estimate of the\n+ * corresponding residual, and &delta; a user-specified tolerance.\n+ * </p>\n+ * <h3>Iteration count</h3>\n+ * <p>\n+ * In the present context, an iteration should be understood as one evaluation\n+ * of the matrix-vector product A &middot; x. The initialization phase therefore\n+ * counts as one iteration. If the user requires checks on the symmetry of A,\n+ * this entails one further matrix-vector product by iteration. This further\n+ * product is <em>not</em> accounted for in the iteration count. In other words,\n+ * the number of iterations required to reach convergence will be identical,\n+ * whether checks have been required or not.\n+ * </p>\n+ * <p>\n+ * The present definition of the iteration count differs from that adopted in\n+ * the original FOTRAN code, where the initialization phase was <em>not</em>\n+ * taken into account.\n+ * </p>\n+ * <h3><a id=\"context\">Exception context</a></h3>\n+ * <p>\n+ * Besides standard {@link DimensionMismatchException}, this class might throw\n+ * {@link NonSelfAdjointOperatorException} if the linear operator or the\n+ * preconditioner are not symmetric. In this case, the {@link ExceptionContext}\n+ * provides more information\n+ * <ul>\n+ * <li>key {@code \"operator\"} points to the offending linear operator, say L,</li>\n+ * <li>key {@code \"vector1\"} points to the first offending vector, say x,\n+ * <li>key {@code \"vector2\"} points to the second offending vector, say y, such\n+ * that x<sup>T</sup> &middot; L &middot; y &ne; y<sup>T</sup> &middot; L\n+ * &middot; x (within a certain accuracy).</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * {@link NonPositiveDefiniteOperatorException} might also be thrown in case the\n+ * preconditioner is not positive definite. The relevant keys to the\n+ * {@link ExceptionContext} are\n+ * <ul>\n+ * <li>key {@code \"operator\"}, which points to the offending linear operator,\n+ * say L,</li>\n+ * <li>key {@code \"vector\"}, which points to the offending vector, say x, such\n+ * that x<sup>T</sup> &middot; L &middot; x < 0.</li>\n+ * </ul>\n+ * </p>\n+ * <h3>References</h3>\n+ * <dl>\n+ * <dt><a id=\"PAIG1975\">Paige and Saunders (1975)</a></dt>\n+ * <dd>C. C. Paige and M. A. Saunders, <a\n+ * href=\"http://www.stanford.edu/group/SOL/software/symmlq/PS75.pdf\"><em>\n+ * Solution of Sparse Indefinite Systems of Linear Equations</em></a>, SIAM\n+ * Journal on Numerical Analysis 12(4): 617-629, 1975</dd>\n+ * </dl>\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class SymmLQ\n+    extends PreconditionedIterativeLinearSolver {\n+\n+    /*\n+     * IMPLEMENTATION NOTES\n+     * --------------------\n+     * The implementation follows as closely as possible the notations of Paige\n+     * and Saunders (1975). Attention must be paid to the fact that some\n+     * quantities which are relevant to iteration k can only be computed in\n+     * iteration (k+1). Therefore, minute attention must be paid to the index of\n+     * each state variable of this algorithm.\n+     *\n+     * 1. Preconditioning\n+     *    ---------------\n+     * The Lanczos iterations associated with Ahat and bhat read\n+     *   beta[1] = |P . b|\n+     *   v[1] = P.b / beta[1]\n+     *   beta[k+1] * v[k+1] = Ahat * v[k] - alpha[k] * v[k] - beta[k] * v[k-1]\n+     *                      = P * (A - shift * I) * P' * v[k] - alpha[k] * v[k]\n+     *                        - beta[k] * v[k-1]\n+     * Multiplying both sides by P', we get\n+     *   beta[k+1] * (P' * v)[k+1] = M^(-1) * (A - shift * I) * (P' * v)[k]\n+     *                               - alpha[k] * (P' * v)[k]\n+     *                               - beta[k] * (P' * v[k-1]),\n+     * and\n+     *   alpha[k+1] = v[k+1]' * Ahat * v[k+1]\n+     *              = v[k+1]' * P * (A - shift * I) * P' * v[k+1]\n+     *              = (P' * v)[k+1]' * (A - shift * I) * (P' * v)[k+1].\n+     *\n+     * In other words, the Lanczos iterations are unchanged, except for the fact\n+     * that we really compute (P' * v) instead of v. It can easily be checked\n+     * that all other formulas are unchanged. It must be noted that P is never\n+     * explicitly used, only matrix-vector products involving M^(-1) are\n+     * invoked.\n+     *\n+     * 2. Accounting for the shift parameter\n+     *    ----------------------------------\n+     * Is trivial: each time A.operate(x) is invoked, one must subtract shift * x\n+     * to the result.\n+     *\n+     * 3. Accounting for the goodb flag\n+     *    -----------------------------\n+     * When goodb is set to true, the component of xL along b is computed\n+     * separately. From Page and Saunders (1975), equation (5.9), we have\n+     *   wbar[k+1] = s[k] * wbar[k] - c[k] * v[k+1],\n+     *   wbar[1] = v[1].\n+     * Introducing wbar2[k] = wbar[k] - s[1] * ... * s[k-1] * v[1], it can\n+     * easily be verified by induction that what follows the same recursive\n+     * relation\n+     *   wbar2[k+1] = s[k] * wbar2[k] - c[k] * v[k+1],\n+     *   wbar2[1] = 0,\n+     * and we then have\n+     *   w[k] = c[k] * wbar2[k] + s[k] * v[k+1]\n+     *          + s[1] * ... * s[k-1] * c[k] * v[1].\n+     * Introducing w2[k] = w[k] - s[1] * ... * s[k-1] * c[k] * v[1], we find,\n+     * from (5.10)\n+     *   xL[k] = zeta[1] * w[1] + ... + zeta[k] * w[k]\n+     *         = zeta[1] * w2[1] + ... + zeta[k] * w2[k]\n+     *           + (s[1] * c[2] * zeta[2] + ...\n+     *           + s[1] * ... * s[k-1] * c[k] * zeta[k]) * v[1]\n+     *         = xL2[k] + bstep[k] * v[1],\n+     * where xL2[k] is defined by\n+     *   xL2[0] = 0,\n+     *   xL2[k+1] = xL2[k] + zeta[k+1] * w2[k+1],\n+     * and bstep is defined by\n+     *   bstep[1] = 0,\n+     *   bstep[k] = bstep[k-1] + s[1] * ... * s[k-1] * c[k] * zeta[k].\n+     * We also have, from (5.11)\n+     *   xC[k] = xL[k-1] + zbar[k] * wbar[k]\n+     *         = xL2[k-1] + zbar[k] * wbar2[k]\n+     *           + (bstep[k-1] + s[1] * ... * s[k-1] * zbar[k]) * v[1].\n+     */\n+\n+    /**\n+     * <p>\n+     * A simple container holding the non-final variables used in the\n+     * iterations. Making the current state of the solver visible from the\n+     * outside is necessary, because during the iterations, {@code x} does not\n+     * <em>exactly</em> hold the current estimate of the solution. Indeed,\n+     * {@code x} needs in general to be moved from the LQ point to the CG point.\n+     * Besides, additional upudates must be carried out in case {@code goodb} is\n+     * set to {@code true}.\n+     * </p>\n+     * <p>\n+     * In all subsequent comments, the description of the state variables refer\n+     * to their value after a call to {@link #update()}. In these comments, k is\n+     * the current number of evaluations of matrix-vector products.\n+     * </p>\n+     */\n+    private class State {\n+\n+        /** Reference to the linear operator. */\n+        private final RealLinearOperator a;\n+\n+        /** Reference to the right-hand side vector. */\n+        private final RealVector b;\n+\n+        /** The value of beta[k+1]. */\n+        private double beta;\n+\n+        /** The value of beta[1]. */\n+        private double beta1;\n+\n+        /** The value of bstep[k-1]. */\n+        private double bstep;\n+\n+        /** The estimate of the norm of P * rC[k]. */\n+        private double cgnorm;\n+\n+        /** The value of dbar[k+1] = -beta[k+1] * c[k-1]. */\n+        private double dbar;\n+\n+        /**\n+         * The value of gamma[k] * zeta[k]. Was called {@code rhs1} in the\n+         * initial code.\n+         */\n+        private double gammaZeta;\n+\n+        /** The value of gbar[k]. */\n+        private double gbar;\n+\n+        /** The value of max(|alpha[1]|, gamma[1], ..., gamma[k-1]). */\n+        private double gmax;\n+\n+        /** The value of min(|alpha[1]|, gamma[1], ..., gamma[k-1]). */\n+        private double gmin;\n+\n+        /** Copy of the {@code goodb} parameter. */\n+        private final boolean goodb;\n+\n+        /** {@code true} if the default convergence criterion is verified. */\n+        private boolean hasConverged;\n+\n+        /** The estimate of the norm of P * rL[k-1]. */\n+        private double lqnorm;\n+\n+        /** Reference to the preconditioner. */\n+        private final InvertibleRealLinearOperator m;\n+\n+        /**\n+         * The value of (-eps[k+1] * zeta[k-1]). Was called {@code rhs2} in the\n+         * initial code.\n+         */\n+        private double minusEpsZeta;\n+\n+        /** The value of M^(-1) * b. */\n+        private final RealVector mSolveB;\n+\n+        /** The value of beta[k]. */\n+        private double oldb;\n+\n+        /** The value of beta[k] * M * P' * v[k]. */\n+        private RealVector r1;\n+\n+        /** The value of beta[k+1] * M * P' * v[k+1]. */\n+        private RealVector r2;\n+\n+        /** Copy of the {@code shift} parameter. */\n+        private final double shift;\n+\n+        /** The value of s[1] * ... * s[k-1]. */\n+        private double snprod;\n+\n+        /**\n+         * An estimate of the square of the norm of A * V[k], based on Paige and\n+         * Saunders (1975), equation (3.3).\n+         */\n+        private double tnorm;\n+\n+        /**\n+         * The value of P' * wbar[k] or P' * (wbar[k] - s[1] * ... * s[k-1] *\n+         * v[1]) if {@code goodb} is {@code true}. Was called {@code w} in the\n+         * initial code.\n+         */\n+        private RealVector wbar;\n+\n+        /**\n+         * A reference to the vector to be updated with the solution. Contains\n+         * the value of xL[k-1] if {@code goodb} is {@code false}, (xL[k-1] -\n+         * bstep[k-1] * v[1]) otherwise.\n+         */\n+        private final RealVector x;\n+\n+        /** The value of beta[k+1] * P' * v[k+1]. */\n+        private RealVector y;\n+\n+        /** The value of zeta[1]^2 + ... + zeta[k-1]^2. */\n+        private double ynorm2;\n+\n+        /**\n+         * Creates and inits to k = 1 a new instance of this class.\n+         *\n+         * @param a Linear operator A of the system.\n+         * @param m Preconditioner (can be {@code null}).\n+         * @param b Right-hand side vector.\n+         * @param x Vector to be updated with the solution. {@code x} should not\n+         * be considered as an initial guess, as it is set to 0 in the\n+         * initialization phase.\n+         * @param goodb Usually {@code false}, except if {@code x} is expected\n+         * to contain a large multiple of {@code b}.\n+         * @param shift The amount to be subtracted to all diagonal elements of\n+         * A.\n+         */\n+        public State(final RealLinearOperator a,\n+                     final InvertibleRealLinearOperator m, final RealVector b,\n+                     final RealVector x, final boolean goodb, final double shift) {\n+            this.a = a;\n+            this.m = m;\n+            this.b = b;\n+            this.x = x;\n+            this.goodb = goodb;\n+            this.shift = shift;\n+            this.mSolveB = m == null ? b : m.solve(b);\n+            this.hasConverged = false;\n+            init();\n+        }\n+\n+        /**\n+         * Move to the CG point if it seems better. In this version of SYMMLQ,\n+         * the convergence tests involve only cgnorm, so we're unlikely to stop\n+         * at an LQ point, except if the iteration limit interferes.\n+         *\n+         * @param xRefined Vector to be updated with the refined value of x.\n+         */\n+        public void refine(final RealVector xRefined) {\n+            final int n = this.x.getDimension();\n+            if (lqnorm < cgnorm) {\n+                if (!goodb) {\n+                    xRefined.setSubVector(0, this.x);\n+                } else {\n+                    final double step = bstep / beta1;\n+                    for (int i = 0; i < n; i++) {\n+                        final double bi = mSolveB.getEntry(i);\n+                        final double xi = this.x.getEntry(i);\n+                        xRefined.setEntry(i, xi + step * bi);\n+                    }\n+                }\n+            } else {\n+                final double anorm = FastMath.sqrt(tnorm);\n+                final double diag = gbar == 0. ? anorm * MACH_PREC : gbar;\n+                final double zbar = gammaZeta / diag;\n+                final double step = (bstep + snprod * zbar) / beta1;\n+                // ynorm = FastMath.sqrt(ynorm2 + zbar * zbar);\n+                if (!goodb) {\n+                    for (int i = 0; i < n; i++) {\n+                        final double xi = this.x.getEntry(i);\n+                        final double wi = wbar.getEntry(i);\n+                        xRefined.setEntry(i, xi + zbar * wi);\n+                    }\n+                } else {\n+                    for (int i = 0; i < n; i++) {\n+                        final double xi = this.x.getEntry(i);\n+                        final double wi = wbar.getEntry(i);\n+                        final double bi = mSolveB.getEntry(i);\n+                        xRefined.setEntry(i, xi + zbar * wi + step * bi);\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Performs the initial phase of the SYMMLQ algorithm. On return, the\n+         * value of the state variables of {@code this} object correspond to k =\n+         * 1.\n+         */\n+        private void init() {\n+            this.x.set(0.);\n+            /*\n+             * Set up y for the first Lanczos vector. y and beta1 will be zero\n+             * if b = 0.\n+             */\n+            this.r1 = this.b.copy();\n+            this.y = this.m == null ? this.b.copy() : this.m.solve(this.r1);\n+            if ((this.m != null) && check) {\n+                checkSymmetry(this.m, this.r1, this.y, this.m.solve(this.y));\n+            }\n+\n+            this.beta1 = this.r1.dotProduct(this.y);\n+            if (this.beta1 < 0.) {\n+                throwNPDLOException(this.m, this.y);\n+            }\n+            if (this.beta1 == 0.) {\n+                /* If b = 0 exactly, stop with x = 0. */\n+                return;\n+            }\n+            this.beta1 = FastMath.sqrt(this.beta1);\n+            /* At this point\n+             *   r1 = b,\n+             *   y = M^(-1) * b,\n+             *   beta1 = beta[1].\n+             */\n+            final RealVector v = this.y.mapMultiply(1. / this.beta1);\n+            this.y = this.a.operate(v);\n+            if (check) {\n+                checkSymmetry(this.a, v, this.y, this.a.operate(this.y));\n+            }\n+            /*\n+             * Set up y for the second Lanczos vector. y and beta will be zero\n+             * or very small if b is an eigenvector.\n+             */\n+            daxpy(-this.shift, v, this.y);\n+            final double alpha = v.dotProduct(this.y);\n+            daxpy(-alpha / this.beta1, this.r1, this.y);\n+            /*\n+             * At this point\n+             *   alpha = alpha[1]\n+             *   y     = beta[2] * M * P' * v[2]\n+             */\n+            /* Make sure r2 will be orthogonal to the first v. */\n+            final double vty = v.dotProduct(this.y);\n+            final double vtv = v.dotProduct(v);\n+            daxpy(-vty / vtv, v, this.y);\n+            this.r2 = this.y.copy();\n+            if (this.m != null) {\n+                this.y = this.m.solve(this.r2);\n+            }\n+            this.oldb = this.beta1;\n+            this.beta = this.r2.dotProduct(this.y);\n+            if (this.beta < 0.) {\n+                throwNPDLOException(this.m, this.y);\n+            }\n+            this.beta = FastMath.sqrt(this.beta);\n+            /*\n+             * At this point\n+             *   oldb = beta[1]\n+             *   beta = beta[2]\n+             *   y  = beta[2] * P' * v[2]\n+             *   r2 = beta[2] * M * P' * v[2]\n+             */\n+            this.cgnorm = this.beta1;\n+            this.gbar = alpha;\n+            this.dbar = this.beta;\n+            this.gammaZeta = this.beta1;\n+            this.minusEpsZeta = 0.;\n+            this.bstep = 0.;\n+            this.snprod = 1.;\n+            this.tnorm = alpha * alpha + this.beta * this.beta;\n+            this.ynorm2 = 0.;\n+            this.gmax = FastMath.abs(alpha) + MACH_PREC;\n+            this.gmin = this.gmax;\n+\n+            if (this.goodb) {\n+                this.wbar = new ArrayRealVector(this.a.getRowDimension());\n+                this.wbar.set(0.);\n+            } else {\n+                this.wbar = v;\n+            }\n+            updateNorms();\n+        }\n+\n+        /**\n+         * Performs the next iteration of the algorithm. The iteration count\n+         * should be incremented prior to calling this method. On return, the\n+         * value of the state variables of {@code this} object correspond to the\n+         * current iteration count {@code k}.\n+         */\n+        private void update() {\n+            final RealVector v = y.mapMultiply(1. / beta);\n+            y = a.operate(v);\n+            daxpbypz(-shift, v, -beta / oldb, r1, y);\n+            final double alpha = v.dotProduct(y);\n+            /*\n+             * At this point\n+             *   v     = P' * v[k],\n+             *   y     = (A - shift * I) * P' * v[k] - beta[k] * M * P' * v[k-1],\n+             *   alpha = v'[k] * P * (A - shift * I) * P' * v[k]\n+             *           - beta[k] * v[k]' * P * M * P' * v[k-1]\n+             *         = v'[k] * P * (A - shift * I) * P' * v[k]\n+             *           - beta[k] * v[k]' * v[k-1]\n+             *         = alpha[k].\n+             */\n+            daxpy(-alpha / beta, r2, y);\n+            /*\n+             * At this point\n+             *   y = (A - shift * I) * P' * v[k] - alpha[k] * M * P' * v[k]\n+             *       - beta[k] * M * P' * v[k-1]\n+             *     = M * P' * (P * (A - shift * I) * P' * v[k] -alpha[k] * v[k]\n+             *       - beta[k] * v[k-1])\n+             *     = beta[k+1] * M * P' * v[k+1],\n+             * from Paige and Saunders (1975), equation (3.2).\n+             *\n+             * WATCH-IT: the two following line work only because y is no longer\n+             * updated up to the end of the present iteration, and is\n+             * reinitialized at the beginning of the next iteration.\n+             */\n+            r1 = r2;\n+            r2 = y;\n+            if (m != null) {\n+                y = m.solve(r2);\n+            }\n+            oldb = beta;\n+            beta = r2.dotProduct(y);\n+            if (beta < 0.) {\n+                throwNPDLOException(m, y);\n+            }\n+            beta = FastMath.sqrt(beta);\n+            /*\n+             * At this point\n+             *   r1 = beta[k] * M * P' * v[k],\n+             *   r2 = beta[k+1] * M * P' * v[k+1],\n+             *   y  = beta[k+1] * P' * v[k+1],\n+             *   oldb = beta[k],\n+             *   beta = beta[k+1].\n+             */\n+            tnorm += alpha * alpha + oldb * oldb + beta * beta;\n+            /*\n+             * Compute the next plane rotation for Q. See Paige and Saunders\n+             * (1975), equation (5.6), with\n+             *   gamma = gamma[k-1],\n+             *   c     = c[k-1],\n+             *   s     = s[k-1].\n+             */\n+            final double gamma = FastMath.sqrt(gbar * gbar + oldb * oldb);\n+            final double c = gbar / gamma;\n+            final double s = oldb / gamma;\n+            /*\n+             * The relations\n+             *   gbar[k] = s[k-1] * (-c[k-2] * beta[k]) - c[k-1] * alpha[k]\n+             *           = s[k-1] * dbar[k] - c[k-1] * alpha[k],\n+             *   delta[k] = c[k-1] * dbar[k] + s[k-1] * alpha[k],\n+             * are not stated in Paige and Saunders (1975), but can be retrieved\n+             * by expanding the (k, k-1) and (k, k) coefficients of the matrix in\n+             * equation (5.5).\n+             */\n+            final double deltak = c * dbar + s * alpha;\n+            gbar = s * dbar - c * alpha;\n+            final double eps = s * beta;\n+            dbar = -c * beta;\n+            final double zeta = gammaZeta / gamma;\n+            /*\n+             * At this point\n+             *   gbar   = gbar[k]\n+             *   deltak = delta[k]\n+             *   eps    = eps[k+1]\n+             *   dbar   = dbar[k+1]\n+             *   zeta   = zeta[k-1]\n+             */\n+            final double zetaC = zeta * c;\n+            final double zetaS = zeta * s;\n+            final int n = x.getDimension();\n+            for (int i = 0; i < n; i++) {\n+                final double xi = x.getEntry(i);\n+                final double vi = v.getEntry(i);\n+                final double wi = wbar.getEntry(i);\n+                x.setEntry(i, xi + wi * zetaC + vi * zetaS);\n+                wbar.setEntry(i, wi * s - vi * c);\n+            }\n+            /*\n+             * At this point\n+             *   x = xL[k-1],\n+             *   ptwbar = P' wbar[k],\n+             * see Paige and Saunders (1975), equations (5.9) and (5.10).\n+             */\n+            bstep += snprod * c * zeta;\n+            snprod *= s;\n+            gmax = FastMath.max(gmax, gamma);\n+            gmin = FastMath.min(gmin, gamma);\n+            ynorm2 += zeta * zeta;\n+            gammaZeta = minusEpsZeta - deltak * zeta;\n+            minusEpsZeta = -eps * zeta;\n+            /*\n+             * At this point\n+             *   snprod       = s[1] * ... * s[k-1],\n+             *   gmax         = max(|alpha[1]|, gamma[1], ..., gamma[k-1]),\n+             *   gmin         = min(|alpha[1]|, gamma[1], ..., gamma[k-1]),\n+             *   ynorm2       = zeta[1]^2 + ... + zeta[k-1]^2,\n+             *   gammaZeta    = gamma[k] * zeta[k],\n+             *   minusEpsZeta = -eps[k+1] * zeta[k-1].\n+             * The relation for gammaZeta can be retrieved from Paige and\n+             * Saunders (1975), equation (5.4a), last line of the vector\n+             * gbar[k] * zbar[k] = -eps[k] * zeta[k-2] - delta[k] * zeta[k-1].\n+             */\n+            updateNorms();\n+        }\n+\n+        /**\n+         * Computes the norms of the residuals, and checks for convergence.\n+         * Updates {@link #lqnorm} and {@link #cgnorm}.\n+         */\n+        private void updateNorms() {\n+            final double anorm = FastMath.sqrt(tnorm);\n+            final double ynorm = FastMath.sqrt(ynorm2);\n+            final double epsa = anorm * MACH_PREC;\n+            final double epsx = anorm * ynorm * MACH_PREC;\n+            final double epsr = anorm * ynorm * delta;\n+            final double diag = gbar == 0. ? epsa : gbar;\n+            lqnorm = FastMath.sqrt(gammaZeta * gammaZeta +\n+                                   minusEpsZeta * minusEpsZeta);\n+            final double qrnorm = snprod * beta1;\n+            cgnorm = qrnorm * beta / FastMath.abs(diag);\n+\n+            /*\n+             * Estimate cond(A). In this version we look at the diagonals of L\n+             * in the factorization of the tridiagonal matrix, T = L * Q.\n+             * Sometimes, T[k] can be misleadingly ill-conditioned when T[k+1]\n+             * is not, so we must be careful not to overestimate acond.\n+             */\n+            final double acond;\n+            if (lqnorm <= cgnorm) {\n+                acond = gmax / gmin;\n+            } else {\n+                acond = gmax / FastMath.min(gmin, FastMath.abs(diag));\n+            }\n+            if (acond * MACH_PREC >= 0.1) {\n+                throw new IllConditionedOperatorException(acond);\n+            }\n+            if (beta1 <= epsx) {\n+                /*\n+                 * x has converged to an eigenvector of A corresponding to the\n+                 * eigenvalue shift.\n+                 */\n+                throw new SingularOperatorException();\n+            }\n+            hasConverged = (cgnorm <= epsx) || (cgnorm <= epsr);\n+        }\n+    }\n+\n+    /** The cubic root of {@link #MACH_PREC}. */\n+    private static final double CBRT_MACH_PREC;\n+\n+    /** The machine precision. */\n+    private static final double MACH_PREC;\n+\n+    /** Key for the exception context. */\n+    private static final String OPERATOR = \"operator\";\n+\n+    /** Key for the exception context. */\n+    private static final String THRESHOLD = \"threshold\";\n+\n+    /** Key for the exception context. */\n+    private static final String VECTOR = \"vector\";\n+\n+    /** Key for the exception context. */\n+    private static final String VECTOR1 = \"vector1\";\n+\n+    /** Key for the exception context. */\n+    private static final String VECTOR2 = \"vector2\";\n+\n+    /** {@code true} if symmetry of matrix and conditioner must be checked. */\n+    private final boolean check;\n+\n+    /**\n+     * The value of the custom tolerance &delta; for the default stopping\n+     * criterion.\n+     */\n+    private final double delta;\n+\n+    /**\n+     * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n+     * stopping criterion</a>.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param check {@code true} if self-adjointedness of both matrix and\n+     * preconditioner should be checked. This entails an extra matrix-vector\n+     * product at each iteration.\n+     */\n+    public SymmLQ(final int maxIterations, final double delta,\n+                  final boolean check) {\n+        super(maxIterations);\n+        this.delta = delta;\n+        this.check = check;\n+    }\n+\n+    /**\n+     * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n+     * stopping criterion</a> and custom iteration manager.\n+     *\n+     * @param manager Custom iteration manager.\n+     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param check {@code true} if self-adjointedness of both matrix and\n+     * preconditioner should be checked. This entails an extra matrix-vector\n+     * product at each iteration.\n+     */\n+    public SymmLQ(final IterationManager manager, final double delta,\n+                  final boolean check) {\n+        super(manager);\n+        this.delta = delta;\n+        this.check = check;\n+    }\n+\n+    static {\n+        MACH_PREC = Math.ulp(1.);\n+        CBRT_MACH_PREC = Math.cbrt(MACH_PREC);\n+    }\n+\n+    /**\n+     * Performs a symmetry check on the specified linear operator, and throws an\n+     * exception in case this check fails. Given a linear operator L, and a\n+     * vector x, this method checks that x' L y = y' L x (within a given\n+     * accuracy), where y = L x.\n+     *\n+     * @param l The linear operator L.\n+     * @param x The candidate vector x.\n+     * @param y The candidate vector y = L x.\n+     * @param z The vector z = L y.\n+     * @throws NonSelfAdjointOperatorException when the test fails.\n+     */\n+    private static void checkSymmetry(final RealLinearOperator l,\n+                                      final RealVector x, final RealVector y,\n+                                      final RealVector z)\n+        throws NonSelfAdjointOperatorException {\n+        final double s = y.dotProduct(y);\n+        final double t = x.dotProduct(z);\n+        final double epsa = (s + MACH_PREC) * CBRT_MACH_PREC;\n+        if (FastMath.abs(s - t) > epsa) {\n+            final NonSelfAdjointOperatorException e;\n+            e = new NonSelfAdjointOperatorException();\n+            final ExceptionContext context = e.getContext();\n+            context.setValue(OPERATOR, l);\n+            context.setValue(VECTOR1, x);\n+            context.setValue(VECTOR2, y);\n+            context.setValue(THRESHOLD, Double.valueOf(epsa));\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * A BLAS-like function, for the operation z &larr; a &middot; x + b\n+     * &middot; y + z. This is for internal use only: no dimension checks are\n+     * provided.\n+     *\n+     * @param a The scalar by which {@code x} is to be multiplied.\n+     * @param x The first vector to be added to {@code z}.\n+     * @param b The scalar by which {@code y} is to be multiplied.\n+     * @param y The second vector to be added to {@code z}.\n+     * @param z The vector to be incremented.\n+     */\n+    private static void daxpbypz(final double a, final RealVector x,\n+                                 final double b, final RealVector y,\n+                                 final RealVector z) {\n+        final int n = z.getDimension();\n+        for (int i = 0; i < n; i++) {\n+            final double zi;\n+            zi = a * x.getEntry(i) + b * y.getEntry(i) + z.getEntry(i);\n+            z.setEntry(i, zi);\n+        }\n+    }\n+\n+    /**\n+     * A clone of the BLAS {@code DAXPY} function, which carries out the\n+     * operation y &larr; a &middot; x + y. This is for internal use only: no\n+     * dimension checks are provided.\n+     *\n+     * @param a The scalar by which {@code x} is to be multiplied.\n+     * @param x The vector to be added to {@code y}.\n+     * @param y The vector to be incremented.\n+     */\n+    private static void daxpy(final double a, final RealVector x,\n+                              final RealVector y) {\n+        final int n = x.getDimension();\n+        for (int i = 0; i < n; i++) {\n+            y.setEntry(i, a * x.getEntry(i) + y.getEntry(i));\n+        }\n+    }\n+\n+    /**\n+     * Throws a new {@link NonPositiveDefiniteOperatorException} with\n+     * appropriate context.\n+     *\n+     * @param l The offending linear operator.\n+     * @param v The offending vector.\n+     * @throws NonPositiveDefiniteOperatorException in any circumstances.\n+     */\n+    private static void throwNPDLOException(final RealLinearOperator l,\n+                                            final RealVector v)\n+        throws NonPositiveDefiniteOperatorException {\n+        final NonPositiveDefiniteOperatorException e;\n+        e = new NonPositiveDefiniteOperatorException();\n+        final ExceptionContext context = e.getContext();\n+        context.setValue(OPERATOR, l);\n+        context.setValue(VECTOR, v);\n+        throw e;\n+    }\n+\n+    /**\n+     * Returns {@code true} if symmetry of the matrix, and symmetry as well as\n+     * positive definiteness of the preconditioner should be checked.\n+     *\n+     * @return {@code true} if the tests are to be performed.\n+     */\n+    public final boolean getCheck() {\n+        return check;\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a,\n+                            final InvertibleRealLinearOperator m,\n+                            final RealVector b)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        return solveInPlace(a, m, b, x, false, 0.);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system (A - shift\n+     * &middot; I) &middot; x = b.\n+     * <p>\n+     * If the solution x is expected to contain a large multiple of {@code b}\n+     * (as in Rayleigh-quotient iteration), then better precision may be\n+     * achieved with {@code goodb} set to {@code true}; this however requires an\n+     * extra call to the preconditioner.\n+     * </p>\n+     * <p>\n+     * {@code shift} should be zero if the system A &middot; x = b is to be\n+     * solved. Otherwise, it could be an approximation to an eigenvalue of A,\n+     * such as the Rayleigh quotient b<sup>T</sup> &middot; A &middot; b /\n+     * (b<sup>T</sup> &middot; b) corresponding to the vector b. If b is\n+     * sufficiently like an eigenvector corresponding to an eigenvalue near\n+     * shift, then the computed x may have very large components. When\n+     * normalized, x may be closer to an eigenvector than b.\n+     * </p>\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param goodb Usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}.\n+     * @param shift The amount to be subtracted to all diagonal elements of A.\n+     * @return A reference to {@code x} (shallow copy).\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m} or {@code b} have\n+     * dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solve(final RealLinearOperator a,\n+                            final InvertibleRealLinearOperator m,\n+                            final RealVector b, final boolean goodb,\n+                            final double shift)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        return solveInPlace(a, m, b, x, goodb, shift);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x Not meaningful in this implementation. Should not be considered\n+     * as an initial guess.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a,\n+                            final InvertibleRealLinearOperator m,\n+                            final RealVector b, final RealVector x)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n+        MathUtils.checkNotNull(x);\n+        return solveInPlace(a, m, b, x.copy(), false, 0.);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} has dimensions\n+     * inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} is not self-adjoint.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a, final RealVector b)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        IllConditionedOperatorException, MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        x.set(0.);\n+        return solveInPlace(a, null, b, x, false, 0.);\n+    }\n+\n+    /**\n+     * Returns the solution to the system (A - shift &middot; I) &middot; x = b.\n+     * <p>\n+     * If the solution x is expected to contain a large multiple of {@code b}\n+     * (as in Rayleigh-quotient iteration), then better precision may be\n+     * achieved with {@code goodb} set to {@code true}.\n+     * </p>\n+     * <p>\n+     * {@code shift} should be zero if the system A &middot; x = b is to be\n+     * solved. Otherwise, it could be an approximation to an eigenvalue of A,\n+     * such as the Rayleigh quotient b<sup>T</sup> &middot; A &middot; b /\n+     * (b<sup>T</sup> &middot; b) corresponding to the vector b. If b is\n+     * sufficiently like an eigenvector corresponding to an eigenvalue near\n+     * shift, then the computed x may have very large components. When\n+     * normalized, x may be closer to an eigenvector than b.\n+     * </p>\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param goodb Usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}.\n+     * @param shift The amount to be subtracted to all diagonal elements of A.\n+     * @return a reference to {@code x}.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} has dimensions\n+     * inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} is not self-adjoint.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solve(final RealLinearOperator a, final RealVector b,\n+                            final boolean goodb, final double shift)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        IllConditionedOperatorException, MaxCountExceededException {\n+        MathUtils.checkNotNull(a);\n+        final RealVector x = new ArrayRealVector(a.getColumnDimension());\n+        return solveInPlace(a, null, b, x, goodb, shift);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x Not meaningful in this implementation. Should not be considered\n+     * as an initial guess.\n+     * @return A new vector containing the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} or {@code x} have\n+     * dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} is not self-adjoint.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a, final RealVector b,\n+                            final RealVector x)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        IllConditionedOperatorException, MaxCountExceededException {\n+        MathUtils.checkNotNull(x);\n+        return solveInPlace(a, null, b, x.copy(), false, 0.);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. The solution is computed in-place.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x Vector to be updated with the solution. {@code x} should not be\n+     * considered as an initial guess, as it is set to 0 in the initialization\n+     * phase.\n+     * @return A reference to {@code x} (shallow copy) updated with the\n+     * solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solveInPlace(final RealLinearOperator a,\n+                                   final InvertibleRealLinearOperator m,\n+                                   final RealVector b, final RealVector x)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n+        return solveInPlace(a, m, b, x, false, 0.);\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system (A - shift\n+     * &middot; I) &middot; x = b. The solution is computed in-place.\n+     * <p>\n+     * If the solution x is expected to contain a large multiple of {@code b}\n+     * (as in Rayleigh-quotient iteration), then better precision may be\n+     * achieved with {@code goodb} set to {@code true}; this however requires an\n+     * extra call to the preconditioner.\n+     * </p>\n+     * <p>\n+     * {@code shift} should be zero if the system A &middot; x = b is to be\n+     * solved. Otherwise, it could be an approximation to an eigenvalue of A,\n+     * such as the Rayleigh quotient b<sup>T</sup> &middot; A &middot; b /\n+     * (b<sup>T</sup> &middot; b) corresponding to the vector b. If b is\n+     * sufficiently like an eigenvector corresponding to an eigenvalue near\n+     * shift, then the computed x may have very large components. When\n+     * normalized, x may be closer to an eigenvector than b.\n+     * </p>\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x Vector to be updated with the solution. {@code x} should not be\n+     * considered as an initial guess, as it is set to 0 in the initialization\n+     * phase.\n+     * @param goodb Usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}.\n+     * @param shift The amount to be subtracted to all diagonal elements of A.\n+     * @return A reference to {@code x} (shallow copy).\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    public RealVector solveInPlace(final RealLinearOperator a,\n+                                   final InvertibleRealLinearOperator m,\n+                                   final RealVector b, final RealVector x,\n+                                   final boolean goodb, final double shift)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n+        checkParameters(a, m, b, x);\n+\n+        final IterationManager manager = getIterationManager();\n+        /* Initialization counts as an iteration. */\n+        manager.resetIterationCount();\n+        manager.incrementIterationCount();\n+\n+        final State state = new State(a, m, b, x, goodb, shift);\n+        final IterativeLinearSolverEvent event = createEvent(state);\n+        if (state.beta1 == 0.) {\n+            /* If b = 0 exactly, stop with x = 0. */\n+            manager.fireTerminationEvent(event);\n+            return x;\n+        }\n+        /* Cause termination if beta is essentially zero. */\n+        final boolean earlyStop;\n+        earlyStop = (state.beta < MACH_PREC) || (state.hasConverged);\n+        manager.fireInitializationEvent(event);\n+        if (!earlyStop) {\n+            do {\n+                manager.incrementIterationCount();\n+                manager.fireIterationStartedEvent(event);\n+                state.update();\n+                manager.fireIterationPerformedEvent(event);\n+            } while (!state.hasConverged);\n+        }\n+        state.refine(x);\n+        /*\n+         * The following two lines are a hack because state.x is now refined,\n+         * so further calls to state.refine() (via event.getSolution()) should\n+         * *not* return an altered value of state.x.\n+         */\n+        state.bstep = 0.;\n+        state.gammaZeta = 0.;\n+        manager.fireTerminationEvent(event);\n+        return x;\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. The solution is computed in-place.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x Vector to be updated with the solution. {@code x} should not be\n+     * considered as an initial guess, as it is set to 0 in the initialization\n+     * phase.\n+     * @return A reference to {@code x} (shallow copy) updated with the\n+     * solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n+     * square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n+     * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom {@link MaxCountExceededCallback callback} has been set at\n+     * construction.\n+     */\n+    @Override\n+    public RealVector solveInPlace(final RealLinearOperator a,\n+                                   final RealVector b, final RealVector x)\n+        throws NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, NonSelfAdjointOperatorException,\n+        IllConditionedOperatorException, MaxCountExceededException {\n+        return solveInPlace(a, null, b, x, false, 0.);\n+    }\n+\n+    /**\n+     * Creates the event to be fired during the solution process. Unmodifiable\n+     * views of the RHS vector, and the current estimate of the solution are\n+     * returned by the created event.\n+     *\n+     * @param state Reference to the current state of this algorithm.\n+     * @return The newly created event.\n+     */\n+    private IterativeLinearSolverEvent createEvent(final State state) {\n+        final RealVector bb = RealVector.unmodifiableRealVector(state.b);\n+\n+        final IterativeLinearSolverEvent event;\n+        event = new IterativeLinearSolverEvent(this) {\n+\n+            @Override\n+            public RealVector getRightHandSideVector() {\n+                return bb;\n+            }\n+\n+            @Override\n+            public RealVector getSolution() {\n+                final int n = state.x.getDimension();\n+                final RealVector x = new ArrayRealVector(n);\n+                state.refine(x);\n+                return x;\n+            }\n+        };\n+        return event;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.IterationEvent;\n+import org.apache.commons.math.util.IterationListener;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SymmLQTest {\n+\n+    public void saundersTest(final int n, final boolean goodb,\n+                             final boolean precon, final double shift,\n+                             final double pertbn) {\n+        final RealLinearOperator a = new RealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                if (x.getDimension() != n) {\n+                    throw new DimensionMismatchException(x.getDimension(), n);\n+                }\n+                final double[] y = new double[n];\n+                for (int i = 0; i < n; i++) {\n+                    y[i] = (i + 1) * 1.1 / n * x.getEntry(i);\n+                }\n+                return new ArrayRealVector(y, false);\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return n;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return n;\n+            }\n+        };\n+        final double shiftm = shift;\n+        final double pertm = FastMath.abs(pertbn);\n+        final InvertibleRealLinearOperator m;\n+        if (precon) {\n+            m = new InvertibleRealLinearOperator() {\n+\n+                @Override\n+                public RealVector operate(final RealVector x) {\n+                    if (x.getDimension() != n) {\n+                        throw new DimensionMismatchException(x.getDimension(),\n+                                                             n);\n+                    }\n+                    final double[] y = new double[n];\n+                    for (int i = 0; i < n; i++) {\n+                        double d = (i + 1) * 1.1 / n;\n+                        d = FastMath.abs(d - shiftm);\n+                        if (i % 10 == 0) {\n+                            d += pertm;\n+                        }\n+                        y[i] = d * x.getEntry(i);\n+                    }\n+                    return new ArrayRealVector(y, false);\n+                }\n+\n+                @Override\n+                public int getRowDimension() {\n+                    return n;\n+                }\n+\n+                @Override\n+                public int getColumnDimension() {\n+                    return n;\n+                }\n+\n+                @Override\n+                public RealVector solve(final RealVector b) {\n+                    if (b.getDimension() != n) {\n+                        throw new DimensionMismatchException(b.getDimension(),\n+                                                             n);\n+                    }\n+                    final double[] x = new double[n];\n+                    for (int i = 0; i < n; i++) {\n+                        double d = (i + 1) * 1.1 / n;\n+                        d = FastMath.abs(d - shiftm);\n+                        if (i % 10 == 0) {\n+                            d += pertm;\n+                        }\n+                        x[i] = b.getEntry(i) / d;\n+                    }\n+                    return new ArrayRealVector(x, false);\n+                }\n+            };\n+        } else {\n+            m = null;\n+        }\n+        final RealVector xtrue = new ArrayRealVector(n);\n+        for (int i = 0; i < n; i++) {\n+            xtrue.setEntry(i, n - i);\n+        }\n+        final RealVector b = a.operate(xtrue);\n+        b.combineToSelf(1.0, -shift, xtrue);\n+        final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true);\n+        final RealVector x = solver.solve(a, m, b, goodb, shift);\n+        final RealVector y = a.operate(x);\n+        final RealVector r1 = new ArrayRealVector(n);\n+        for (int i = 0; i < n; i++) {\n+            final double bi = b.getEntry(i);\n+            final double yi = y.getEntry(i);\n+            final double xi = x.getEntry(i);\n+            r1.setEntry(i, bi - yi + shift * xi);\n+        }\n+        final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm();\n+        final double etol = 1E-5;\n+        Assert.assertTrue(\"enorm=\"\n+                                  + enorm\n+                                  + \", \"\n+                                  + solver.getIterationManager()\n+                                      .getIterations(),\n+                          enorm <= etol);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders1() {\n+        saundersTest(1, false, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders2() {\n+        saundersTest(2, false, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders3() {\n+        saundersTest(1, false, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders4() {\n+        saundersTest(2, false, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders5() {\n+        saundersTest(5, false, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders6() {\n+        saundersTest(5, false, true, 0.25, 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders7() {\n+        saundersTest(50, false, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders8() {\n+        saundersTest(50, false, false, 0.25, 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders9() {\n+        saundersTest(50, false, true, 0., 0.10);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders10() {\n+        saundersTest(50, false, true, 0.25, 0.10);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders11() {\n+        saundersTest(1, true, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders12() {\n+        saundersTest(2, true, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders13() {\n+        saundersTest(1, true, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders14() {\n+        saundersTest(2, true, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders15() {\n+        saundersTest(5, true, true, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders16() {\n+        saundersTest(5, true, true, 0.25, 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders17() {\n+        saundersTest(50, true, false, 0., 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders18() {\n+        saundersTest(50, true, false, 0.25, 0.);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders19() {\n+        saundersTest(50, true, true, 0., 0.10);\n+    }\n+\n+    @Test\n+    public void testSolveSaunders20() {\n+        saundersTest(50, true, true, 0.25, 0.10);\n+    }\n+\n+    @Test(expected = NonSquareOperatorException.class)\n+    public void testNonSquareOperator() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());\n+        solver.solve(a, b, x);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testDimensionMismatchRightHandSide() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(2);\n+        solver.solve(a, b);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testDimensionMismatchSolution() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(3);\n+        final ArrayRealVector x = new ArrayRealVector(2);\n+        solver.solve(a, b, x);\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedSolution() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x = solver.solve(a, b);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d]\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedInPlaceSolutionWithInitialGuess() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x0 = new ArrayRealVector(n);\n+            x0.set(1.);\n+            final RealVector x = solver.solveInPlace(a, b, x0);\n+            Assert.assertSame(\"x should be a reference to x0\", x0, x);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d)\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedSolutionWithInitialGuess() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new SymmLQ(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x0 = new ArrayRealVector(n);\n+            x0.set(1.);\n+            final RealVector x = solver.solve(a, b, x0);\n+            Assert.assertNotSame(\"x should not be a reference to x0\", x0, x);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d]\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+                Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = NonSquareOperatorException.class)\n+    public void testNonSquarePreconditioner() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        solver.solve(a, m, b);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testMismatchedOperatorDimensions() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0d, false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        solver.solve(a, m, b);\n+    }\n+\n+    @Test(expected = NonPositiveDefiniteOperatorException.class)\n+    public void testNonPositiveDefinitePreconditioner() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        a.setEntry(0, 0, 1d);\n+        a.setEntry(0, 1, 2d);\n+        a.setEntry(1, 0, 3d);\n+        a.setEntry(1, 1, 4d);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                final ArrayRealVector y = new ArrayRealVector(2);\n+                y.setEntry(0, -x.getEntry(0));\n+                y.setEntry(1, -x.getEntry(1));\n+                return y;\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                final ArrayRealVector x = new ArrayRealVector(2);\n+                x.setEntry(0, -b.getEntry(0));\n+                x.setEntry(1, -b.getEntry(1));\n+                return x;\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new SymmLQ(10, 0d, true);\n+        final ArrayRealVector b = new ArrayRealVector(2);\n+        b.setEntry(0, -1d);\n+        b.setEntry(1, -1d);\n+        solver.solve(a, m, b);\n+    }\n+\n+    @Test\n+    public void testPreconditionedSolution() {\n+        final int n = 8;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new SymmLQ(maxIterations, 1E-15, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x = solver.solve(a, m, b);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String.format(\"coefficient (%d, %d)\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPreconditionedSolution2() {\n+        final int n = 100;\n+        final int maxIterations = 100000;\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n);\n+        double daux = 1.;\n+        for (int i = 0; i < n; i++) {\n+            a.setEntry(i, i, daux);\n+            daux *= 1.2;\n+            for (int j = i + 1; j < n; j++) {\n+                if (i == j) {\n+                } else {\n+                    final double value = 1.0;\n+                    a.setEntry(i, j, value);\n+                    a.setEntry(j, i, value);\n+                }\n+            }\n+        }\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver prec;\n+        final IterativeLinearSolver unprec;\n+        prec = new SymmLQ(maxIterations, 1E-15, true);\n+        unprec = new SymmLQ(maxIterations, 1E-15, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        final String pattern = \"preconditioned SymmLQ (%d iterations) should\"\n+                               + \" have been faster than unpreconditioned (%d iterations)\";\n+        String msg;\n+        for (int j = 0; j < 1; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector px = prec.solve(a, m, b);\n+            final RealVector x = unprec.solve(a, b);\n+            final int npcg = prec.getIterationManager().getIterations();\n+            final int ncg = unprec.getIterationManager().getIterations();\n+            msg = String.format(pattern, npcg, ncg);\n+            Assert.assertTrue(msg, npcg < ncg);\n+            for (int i = 0; i < n; i++) {\n+                msg = String.format(\"row %d, column %d\", i, j);\n+                final double expected = x.getEntry(i);\n+                final double actual = px.getEntry(i);\n+                final double delta = 5E-5 * Math.abs(expected);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEventManagement() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        final int[] count = new int[] {\n+            0, 0, 0, 0\n+        };\n+        final IterationListener listener = new IterationListener() {\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                count[0] = 1;\n+                count[1] = 0;\n+                count[2] = 0;\n+                count[3] = 0;\n+\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                ++count[2];\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                ++count[1];\n+\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                ++count[3];\n+            }\n+        };\n+        solver = new SymmLQ(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, b);\n+            String msg = String.format(\"column %d (initialization)\", j);\n+            Assert.assertEquals(msg, 1, count[0]);\n+            msg = String.format(\"column %d (iterations started)\", j);\n+            Assert.assertEquals(msg, solver.getIterationManager()\n+                .getIterations() - 1, count[1]);\n+            msg = String.format(\"column %d (iterations performed)\", j);\n+            Assert.assertEquals(msg, solver.getIterationManager()\n+                .getIterations() - 1, count[2]);\n+            msg = String.format(\"column %d (finalization)\", j);\n+            Assert.assertEquals(msg, 1, count[3]);\n+        }\n+    }\n+\n+    @Test(expected = NonSelfAdjointOperatorException.class)\n+    public void testNonSelfAdjointOperator() {\n+        final RealLinearOperator a;\n+        a = new Array2DRowRealMatrix(new double[][] {\n+            {\n+                1., 2., 3.\n+            }, {\n+                2., 4., 5.\n+            }, {\n+                2.999, 5., 6.\n+            }\n+        });\n+        final RealVector b;\n+        b = new ArrayRealVector(new double[] {\n+            1., 1., 1.\n+        });\n+        new SymmLQ(100, 1., true).solve(a, b);\n+    }\n+\n+    @Test(expected = NonSelfAdjointOperatorException.class)\n+    public void testNonSelfAdjointPreconditioner() {\n+        final RealLinearOperator a = new Array2DRowRealMatrix(new double[][] {\n+            {\n+                1., 2., 3.\n+            }, {\n+                2., 4., 5.\n+            }, {\n+                3., 5., 6.\n+            }\n+        });\n+        final Array2DRowRealMatrix mMat;\n+        mMat = new Array2DRowRealMatrix(new double[][] {\n+            {\n+                1., 0., 1.\n+            }, {\n+                0., 1., 0.\n+            }, {\n+                0., 0., 1.\n+            }\n+        });\n+        final DecompositionSolver mSolver;\n+        mSolver = new LUDecomposition(mMat).getSolver();\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                return mMat.operate(x);\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return mMat.getRowDimension();\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return mMat.getColumnDimension();\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                return mSolver.solve(b);\n+            }\n+        };\n+        final RealVector b = new ArrayRealVector(new double[] {\n+            1., 1., 1.\n+        });\n+        new SymmLQ(100, 1., true).solve(a, m, b);\n+    }\n+}", "timestamp": 1319265391, "metainfo": ""}