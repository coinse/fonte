{"sha": "f604a9e3a49c08396379e2cd3ec0f11002a0cd71", "log": "Removed tabs and trailing spaces.  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n             Assert.assertEquals(m[i],n[i]);\n         }\n     }\n-    \n+\n     /**\n      * Computes the sum of squared deviations of <values> from <target>\n      * @param values array of deviates\n      * @param target value to compute deviations from\n-     * \n+     *\n      * @return sum of squared deviations\n      */\n     public static double sumSquareDev(double[] values, double target) {\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n \n /**\n  * Testcase for the \"microsphere projection\" interpolator.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class MicrosphereInterpolatorTest {\n     /**\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n         assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n         assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testDivideReal() {\n         Complex x = new Complex(2d, 3d);\n         Complex y = new Complex(2d, 0d);\n         assertEquals(new Complex(1d, 1.5), x.divide(y));\n-        \n-    }\n-    \n+\n+    }\n+\n     public void testDivideImaginary() {\n         Complex x = new Complex(2d, 3d);\n         Complex y = new Complex(0d, 2d);\n         assertTrue(Double.isNaN(z.getReal()));\n         assertTrue(Double.isNaN(z.getImaginary()));\n     }\n-    \n+\n     public void testDivideZero() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.ZERO);\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n /**\n  * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest.\n  * See class javadoc for IntegerDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep\n  *          2009) $\n  */\n \n     /**\n      * Constructor for BinomialDistributionTest.\n-     * \n+     *\n      * @param name\n      */\n     public BinomialDistributionTest(String name) {\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n                 }\n                 x -= dx;\n             }\n- \n+\n             mean *= 10.0;\n         }\n     }\n-    \n+\n     /**\n      * JIRA: MATH-282\n      */\n         dist.setMean(6986);\n         checkProbability(dist, 6950);\n     }\n-    \n+\n     private void checkProbability(PoissonDistribution dist, double x) throws Exception {\n         double p = dist.cumulativeProbability(x);\n         assertFalse(\"NaN cumulative probability returned for mean = \" +\n             dist.setMean(mean);\n             double p = 0.1;\n             double dp = p;\n-            while (p < .99) { \n+            while (p < .99) {\n                 double ret = Double.NaN;\n                 try {\n                     ret = dist.inverseCumulativeProbability(p);\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n                 MUTATION_RATE,\n                 new TournamentSelection(TOURNAMENT_ARITY)\n         );\n-        \n+\n         assertEquals(0, ga.getGenerationsEvolved());\n \n         // initial population\n \n         assertTrue(bestFinal.compareTo(bestInitial) > 0);\n         assertEquals(NUM_GENERATIONS, ga.getGenerationsEvolved());\n- \n+\n     }\n \n \n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n import java.util.Random;\n \n /**\n- * \n+ *\n  */\n public class AbstractRealVectorTest extends TestCase {\n     private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n \n         @Override\n         public double[] getData() { return values; }\n-        \n+\n         @Override\n         public AbstractRealVector copy() {\n             return new TestVectorImpl(values.clone());\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n \n         double[] mainTridiagonal = {\n               7484.860960227216, 18405.28129035345, 13855.225609560746,\n-             10016.708722343366, 559.8117399576674, 6750.190788301587, \n+             10016.708722343366, 559.8117399576674, 6750.190788301587,\n                 71.21428769782159\n         };\n         double[] secondaryTridiagonal = {\n-             -4175.088570476366,1975.7955858241994,5193.178422374075, \n+             -4175.088570476366,1975.7955858241994,5193.178422374075,\n               1995.286659169179,75.34535882933804,-234.0808002076056\n         };\n \n      */\n     public void testZeroDivide() {\n         RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {\n-                { 0.0, 1.0, -1.0 }, \n-                { 1.0, 1.0, 0.0 }, \n-                { -1.0,0.0, 1.0 }        \n+                { 0.0, 1.0, -1.0 },\n+                { 1.0, 1.0, 0.0 },\n+                { -1.0,0.0, 1.0 }\n         });\n         EigenDecomposition ed = new EigenDecompositionImpl(indefinite, MathUtils.SAFE_MIN);\n         checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);\n         }\n     }\n \n-    \n+\n     /**\n      * Returns true iff there is an entry within tolerance of value in\n      * searchArray.\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n                                });\n         DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n-            { 11, 12 }, { 21, 22 } \n+            { 11, 12 }, { 21, 22 }\n         });\n         RealMatrix xMatrix = solver.solve(b);\n         Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15);\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n         final FirstOrderIntegratorWithJacobians extInt =\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.addStepHandler(new StepHandlerWithJacobians() {\n-            \n+\n             public void reset() {\n             }\n-            \n+\n             public boolean requiresDenseOutput() {\n                 return false;\n             }\n-            \n+\n             public void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast)\n                 throws DerivativeException {\n                 double     t     = interpolator.getCurrentTime();\n             dFdP[1][0] = -omega;\n             dFdP[1][1] = 0;\n             dFdP[1][2] = y[0] - cx;\n- \n+\n         }\n \n         public double[] exactY(double t) {\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n             if (doubles.length >= 2) {\n                 gradientVector[1] = 1;\n             }\n-            return gradientVector; \n+            return gradientVector;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n             fail(\"wrong exception caught\");\n         }\n     }\n-    \n+\n     /**\n      * MATH-298\n      */\n         double[] expectedGeneratorUpperBounds = {4d/13d, 7d/13d, 9d/13d, 11d/13d, 1};\n         double tol = 10E-12;\n         TestUtils.assertEquals(expectedBinUpperBounds, dist.getUpperBounds(), tol);\n-        TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol);  \n+        TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol);\n     }\n \n     private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n         }\n \n     }\n-    /* TODO: re-enable when MATH-282 is resolved \n+    /* TODO: re-enable when MATH-282 is resolved\n     public void testNextPoissonConsistency() throws Exception {\n         // Small integral means\n         for (int i = 1; i < 100; i++) {\n         for (int i = 1; i < 10; i++) {\n             checkNextPoissonConsistency(randomData.nextUniform(1, 1000));\n         }\n-        // large means \n+        // large means\n         // TODO: When MATH-282 is resolved, s/3000/10000 below\n         for (int i = 1; i < 10; i++) {\n             checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));\n         }\n     }\n     */\n-    \n-    /** \n+\n+    /**\n      * Verifies that nextPoisson(mean) generates an empirical distribution of values\n      * consistent with PoissonDistributionImpl by generating 1000 values, computing a\n      * grouped frequency distribution of the observed values and comparing this distribution\n     public void checkNextPoissonConsistency(double mean) throws Exception {\n         // Generate sample values\n         int sampleSize = 1000;        // Number of deviates to generate\n-        int minExpectedCount = 7;     // Minimum size of expected bin count \n-        long maxObservedValue = 0;   \n-        double alpha = 0.001;         // Probability of false failure         \n+        int minExpectedCount = 7;     // Minimum size of expected bin count\n+        long maxObservedValue = 0;\n+        double alpha = 0.001;         // Probability of false failure\n         Frequency frequency = new Frequency();\n         for (int i = 0; i < sampleSize; i++) {\n             long value = randomData.nextPoisson(mean);\n             }\n             frequency.addValue(value);\n         }\n-        \n-        /*\n-         *  Set up bins for chi-square test.  \n+\n+        /*\n+         *  Set up bins for chi-square test.\n          *  Ensure expected counts are all at least minExpectedCount.\n          *  Start with upper and lower tail bins.\n          *  Lower bin = [0, lower); Upper bin = [upper, +inf).\n         while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n             upper--;\n         }\n-        \n+\n         // Set bin width for interior bins.  For poisson, only need to look at end bins.\n         int binWidth = 1;\n         boolean widthSufficient = false;\n             widthSufficient = Math.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n             binWidth++;\n         }\n-       \n+\n         /*\n          *  Determine interior bin bounds.  Bins are\n-         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... , \n+         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... ,\n          *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)\n-         *  \n+         *\n          */\n         List<Integer> binBounds = new ArrayList<Integer>();\n         binBounds.add(lower);\n         }\n         binBounds.add(bound);\n         binBounds.add(upper);\n-        \n+\n         // Compute observed and expected bin counts\n-        final int binCount = binBounds.size() + 1; \n+        final int binCount = binBounds.size() + 1;\n         long[] observed = new long[binCount];\n         double[] expected = new double[binCount];\n-        \n+\n         // Bottom bin\n         observed[0] = 0;\n         for (int i = 0; i < lower; i++) {\n             observed[0] += frequency.getCount(i);\n         }\n         expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n-        \n+\n         // Top bin\n         observed[binCount - 1] = 0;\n         for (int i = upper; i <= maxObservedValue; i++) {\n             observed[binCount - 1] += frequency.getCount(i);\n         }\n         expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n-        \n+\n         // Interior bins\n         for (int i = 1; i < binCount - 1; i++) {\n             observed[i] = 0;\n             expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -\n                 poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;\n         }\n-        \n+\n         // Use chisquare test to verify that generated values are poisson(mean)-distributed\n         ChiSquareTest chiSquareTest = new ChiSquareTestImpl();\n         try {\n             msgBuffer.append(alpha);\n             msgBuffer.append(\".\");\n             fail(msgBuffer.toString());\n-        }  \n+        }\n     }\n \n     /** test dispersion and failute modes for nextHex() */\n \n         }\n     }\n-    \n+\n     // Disable until we have equals\n     //public void testSerial() {\n     //    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n     //}\n-    \n+\n     private int findPerm(int[][] p, int[] samp) {\n         for (int i = 0; i < p.length; i++) {\n             boolean good = true;\n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n         expected = -expected;\n         assertEquals(expected, actual, 1.0e-5);\n     }\n-    \n+\n     /**\n      * MATH-301\n      */\n         for (int i = 1; i < 200; i++) {\n             double result = Erf.erf(i);\n             assertFalse(Double.isNaN(result));\n-            assertTrue(result > 0 && result <= 1);  \n+            assertTrue(result > 0 && result <= 1);\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n         assertTrue(cluster3Found);\n \n     }\n-    \n+\n     /**\n      * JIRA: MATH-305\n-     * \n+     *\n      * Two points, one cluster, one iteration\n      */\n     @Test\n         assertTrue(clusters.get(0).getPoints().contains(pt1));\n         assertTrue(clusters.get(0).getPoints().contains(pt2));\n \n-    } \n+    }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n         TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),\n                 weightedStatistic.evaluate(values, weights, 0, values.length),\n                 10E-14);\n-        \n+\n         // Check consistency of weighted evaluation methods\n         assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),\n-                weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);       \n+                weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n         final double upsideSemiVariance = sv.evaluate(values);\n         assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),\n                 upsideSemiVariance, 1E-14);\n-        \n+\n         // Verify that upper + lower semivariance against the mean sum to variance\n         assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);\n     }\n         double upper = sv.evaluate(values, target);\n         assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);\n     }\n-    \n+\n     public void testNoVariance() {\n         final double[] values = {100d, 100d, 100d, 100d};\n         SemiVariance sv = new SemiVariance();\n         assertEquals(0, sv.evaluate(values), 10E-12);\n         assertEquals(0, sv.evaluate(values, 100d), 10E-12);\n-        assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12); \n+        assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n             // expected\n         }\n     }\n-    \n+\n     public void testGcdConsistency() {\n         int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         } catch (ArithmeticException expected) {\n             // expected\n         }\n-        \n+\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Long.MIN_VALUE, 1<<20);", "timestamp": 1268841836, "metainfo": ""}