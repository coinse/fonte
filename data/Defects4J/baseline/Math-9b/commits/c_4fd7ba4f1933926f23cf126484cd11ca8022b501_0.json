{"sha": "4fd7ba4f1933926f23cf126484cd11ca8022b501", "log": "Changes the Univariate implementations to use the UnivariateStatistic package. Slims down StatUtils by removing some of the higher moments. Reimplmenets ListUnivariate to work with NumberTransformers, turning into a Mixed Object List Univariate.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n  * <http://www.apache.org/>.\n  */\n package org.apache.commons.math.stat;\n+\n import java.util.Arrays;\n \n+import org.apache.commons.math.stat.univariate.rank.Percentile;\n+\n /**\n- * Provides univariate measures for an array of doubles.  \n- * \n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ * Provides univariate measures for an array of doubles. \n+ * @version $Revision: 1.9 $ $Date: 2003/07/09 21:45:23 $\n  */\n-public abstract class AbstractStoreUnivariate implements StoreUnivariate {\n+public abstract class AbstractStoreUnivariate\n+    extends AbstractUnivariate\n+    implements StoreUnivariate {\n \n+    /** Percentile */\n+    protected Percentile percentile = new Percentile(50);\n+        \n     /**\n-     * Returns the skewness of this collection of values\n-     * @see org.apache.commons.math.stat.StoreUnivariate#getSkewness()\n+     * Create an AbstractStoreUnivariate\n      */\n-    public double getSkewness() {\n-        // Initialize the skewness\n-        double skewness = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = getMean();\n-        double stdDev = getStandardDeviation();\n-\n-        // Sum the cubes of the distance from the mean divided by the \n-        // standard deviation\n-        double accum = 0.0;\n-        for (int i = 0; i < getN(); i++) {\n-            accum += Math.pow((getElement(i) - mean) / stdDev, 3.0);\n-        }\n-\n-        // Get N\n-        double n = getN();\n-\n-        // Calculate skewness\n-        skewness = (n / ((n - 1) * (n - 2))) * accum;\n-\n-        return skewness;\n+    public AbstractStoreUnivariate() {\n+        super();\n     }\n \n     /**\n-     * Returns the kurtosis for this collection of values\n-     * @see org.apache.commons.math.stat.StoreUnivariate#getKurtosis()\n+     * Create an AbstractStoreUnivariate with a specific Window\n+     * @param window WindowSIze for stat calculation\n      */\n-    public double getKurtosis() {\n-        // Initialize the kurtosis\n-        double kurtosis = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = getMean();\n-        double stdDev = getStandardDeviation();\n-\n-        // Sum the ^4 of the distance from the mean divided by the \n-        // standard deviation\n-        double accum = 0.0;\n-        for (int i = 0; i < getN(); i++) {\n-            accum += Math.pow((getElement(i) - mean) / stdDev, 4.0);\n-        }\n-\n-        // Get N\n-        double n = getN();\n-\n-        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n-        // Calculate kurtosis\n-        kurtosis = (coefficientOne * accum) - termTwo;\n-\n-        return kurtosis;\n+    public AbstractStoreUnivariate(int window) {\n+        super(window);\n     }\n \n     /**\n-     * Returns the type or class of kurtosis that this collection of \n-     * values exhibits\n-     * @see org.apache.commons.math.stat.StoreUnivariate#getKurtosisClass()\n-     */\n-    public int getKurtosisClass() {\n-\n-        int kClass = StoreUnivariate.MESOKURTIC;\n-\n-        double kurtosis = getKurtosis();\n-        if (kurtosis > 0) {\n-            kClass = StoreUnivariate.LEPTOKURTIC;\n-        } else if (kurtosis < 0) {\n-            kClass = StoreUnivariate.PLATYKURTIC;\n-        }\n-\n-        return (kClass);\n-\n-    }\n-\n-    /**\n-     * Returns the mean for this collection of values\n-     * @see org.apache.commons.math.stat.Univariate#getMean()\n-     */\n-    public double getMean() {\n-        double arithMean = getSum() / getN();\n-        return arithMean;\n-    }\n-\n-    /**\n-     * Returns the geometric mean for this collection of values\n-     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-     */\n-    public double getGeometricMean() {\n-        double gMean = Double.NaN;\n-\n-        if (getN() > 0) {\n-            double sumLog = 0.0;\n-            for (int i = 0; i < getN(); i++) {\n-                sumLog += Math.log(getElement(i));\n-            }\n-            gMean = Math.exp(sumLog / (double)getN() );\n-        }\n-\n-        return gMean;\n-    }\n-\n-    /**\n-     * Returns the variance for this collection of values\n-     * @see org.apache.commons.math.stat.Univariate#getVariance()\n-     */\n-    public double getVariance() {\n-        // Initialize variance\n-        double variance = Double.NaN;\n-\n-        if (getN() == 1) {\n-            // If this is a single value\n-            variance = 0;\n-        } else if (getN() > 1) {\n-            // Get the mean\n-            double mean = getMean();\n-\n-            // Calculate the sum of the squares of the distance between each \n-            // value and the mean\n-            double accum = 0.0;\n-            for (int i = 0; i < getN(); i++) {\n-                accum += Math.pow((getElement(i) - mean), 2.0);\n-            }\n-\n-            // Divide the accumulator by N - Hmmm... unbiased or biased?\n-            variance = accum / (getN() - 1);\n-        }\n-\n-        return variance;\n-    }\n-\n-    /**\n-     * Returns the standard deviation for this collection of values\n-     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-     */\n-    public double getStandardDeviation() {\n-        double stdDev = Double.NaN;\n-        if (getN() != 0) {\n-            stdDev = Math.sqrt(getVariance());\n-        }\n-        return (stdDev);\n-    }\n-\n-    /**\n-     * Returns the maximum value contained herein.\n-     * @see org.apache.commons.math.stat.Univariate#getMax()\n-     */\n-    public double getMax() {\n-\n-        // Initialize maximum to NaN\n-        double max = Double.NaN;\n-\n-        for (int i = 0; i < getN(); i++) {\n-            if (i == 0) {\n-                max = getElement(i);\n-            } else {\n-                if (getElement(i) > max) {\n-                    max = getElement(i);\n-                }\n-            }\n-        }\n-\n-        return max;\n-    }\n-\n-    /**\n-     * Returns the minimum value contained herein\n-     * @see org.apache.commons.math.stat.Univariate#getMin()\n-     */\n-    public double getMin() {\n-        // Initialize minimum to NaN\n-        double min = Double.NaN;\n-\n-        for (int i = 0; i < getN(); i++) {\n-            if (i == 0) {\n-                min = getElement(i);\n-            } else {\n-                if (getElement(i) < min) {\n-                    min = getElement(i);\n-                }\n-            }\n-        }\n-\n-        return min;\n-    }\n-\n-    /**\n-     * Returns the sum of all values contained herein\n-     * @see org.apache.commons.math.stat.Univariate#getSum()\n-     */\n-    public double getSum() {\n-        double accum = 0.0;\n-        for (int i = 0; i < getN(); i++) {\n-            accum += getElement(i);\n-        }\n-        return accum;\n-    }\n-\n-    /**\n-     * Returns the sun of the squares of all values contained herein\n-     * @see org.apache.commons.math.stat.Univariate#getSumsq()\n-     */\n-    public double getSumsq() {\n-        double accum = 0.0;\n-        for (int i = 0; i < getN(); i++) {\n-            accum += Math.pow(getElement(i), 2.0);\n-        }\n-        return accum;\n-    }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.StoreUnivariate#getSortedValues()\n-     *\n-     */\n-    public double[] getSortedValues() {\n-        double[] values = getValues();\n-        Arrays.sort(values);\n-        return values;\n-    }\n-\n-    /**\n-     * Returns an estimate for the pth percentile of the stored values\n      * @see org.apache.commons.math.stat.StoreUnivariate#getPercentile(double)\n      */\n     public double getPercentile(double p) {\n-        if ((p > 100) || (p <= 0)) {\n-            throw new IllegalArgumentException(\"invalid percentile value\");\n-        }\n-        double n = (double) getN();\n-        if (n == 0) {\n-            return Double.NaN;\n-        }\n-        if (n == 1) {\n-            return getElement(0); // always return single value for n = 1\n-        }\n-        double pos = p * (n + 1) / 100;\n-        double fpos = Math.floor(pos);\n-        int intPos = (int) fpos;\n-        double d = pos - fpos;\n-        double[] sorted = getSortedValues();\n-        if (pos < 1) {\n-            return sorted[0];\n-        }\n-        if (pos > n) {\n-            return sorted[getN() - 1];\n-        }\n-        double lower = sorted[intPos - 1];\n-        double upper = sorted[intPos];\n-        return lower + d * (upper - lower);\n+        percentile.setPercentile(p);\n+        return percentile.evaluate(this.getValues(), this.start(), this.size());\n     }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat2.AbstractStoreUnivariate#getSortedValues()\n+     */\n+    public double[] getSortedValues() {\n+        double[] sort = getValues();\n+        Arrays.sort(sort);\n+        return sort;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+     */\n+    public abstract void addValue(double value);\n+\n+    /**\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getValues()\n+     */\n+    public abstract double[] getValues();\n+\n+\n+    /**\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getElement(int)\n+     */\n+    public abstract double getElement(int index);\n+\n+\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/AbstractUnivariate.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import org.apache.commons.math.stat.univariate.moment.FourthMoment;\n+import org.apache.commons.math.stat.univariate.moment.GeometricMean;\n+import org.apache.commons.math.stat.univariate.moment.Kurtosis;\n+import org.apache.commons.math.stat.univariate.moment.Mean;\n+import org.apache.commons.math.stat.univariate.moment.Skewness;\n+import org.apache.commons.math.stat.univariate.moment.Variance;\n+import org.apache.commons.math.stat.univariate.rank.Max;\n+import org.apache.commons.math.stat.univariate.rank.Min;\n+import org.apache.commons.math.stat.univariate.summary.Sum;\n+import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n+import org.apache.commons.math.stat.univariate.summary.SumOfSquares;\n+\n+/**\n+ * Provides univariate measures for an array of doubles.\n+ * @version $Revision: 1.1 $ $Date: 2003/07/09 21:45:23 $  \n+ */\n+public abstract class AbstractUnivariate implements Univariate {\n+\n+    /** hold the window size **/\n+    protected int windowSize = Univariate.INFINITE_WINDOW;\n+\n+    /** count of values that have been added */\n+    protected int n = 0;\n+\n+    /** FourthMoment is used in calculating mean, variance,skew and kurtosis */\n+    protected FourthMoment moment = null;\n+    \n+    /** sum of values that have been added */\n+    protected Sum sum = null;\n+\n+    /** sum of the square of each value that has been added */\n+    protected SumOfSquares sumsq = null;\n+\n+    /** min of values that have been added */\n+    protected Min min = null;\n+\n+    /** max of values that have been added */\n+    protected Max max = null;\n+\n+    /** sumLog of values that have been added */\n+    protected SumOfLogs sumLog = null;\n+\n+    /** geoMean of values that have been added */\n+    protected GeometricMean geoMean = null;\n+\n+    /** mean of values that have been added */\n+    protected Mean mean = null;\n+\n+    /** variance of values that have been added */\n+    protected Variance variance = null;\n+\n+    /** skewness of values that have been added */\n+    protected Skewness skewness = null;\n+\n+    /** kurtosis of values that have been added */\n+    protected Kurtosis kurtosis = null;\n+\n+    /**\n+     * Construct an AbstractUnivariate\n+     */\n+    public AbstractUnivariate() {\n+        super();\n+        \n+        sum = new Sum();\n+        sumsq = new SumOfSquares();\n+        min = new Min();\n+        max = new Max();\n+        sumLog = new SumOfLogs();\n+        geoMean = new GeometricMean();\n+\n+        moment = new FourthMoment();\n+        mean = new Mean(moment);\n+        variance = new Variance(moment);\n+        skewness = new Skewness(moment);\n+        kurtosis = new Kurtosis(moment);\n+    }\n+\n+    /**\n+     * Construct an AbstractUnivariate with a window\n+     * @param window The Window Size\n+     */\n+    public AbstractUnivariate(int window) {\n+        this();\n+        setWindowSize(window);\n+    }\n+\n+    /**\n+     * Returns the internalValues array.\n+     * @return the array\n+     */\n+    protected abstract double[] internalValues();\n+\n+    /**\n+     * Returns the start index of the array\n+     * @return start index\n+     */\n+    protected abstract int start();\n+\n+    /**\n+     * Returns the size of the array appropriate for doing calculations.\n+     * @return Usually this is just numElements.\n+     */\n+    protected abstract int size();\n+\n+    /**\n+     * If windowSize is set to Infinite, \n+     * statistics are calculated using the following \n+     * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n+     * recursive strategy\n+     * </a>.\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+     */\n+    public abstract void addValue(double value);\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getN()\n+     */\n+    public int getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getSum()\n+     */\n+    public double getSum() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return sum.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return sum.getResult();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getSumsq()\n+     */\n+    public double getSumsq() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return sumsq.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return sumsq.getResult();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getMean()\n+     */\n+    public double getMean() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return mean.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return mean.getResult();\n+    }\n+\n+    /**\n+     * Returns the standard deviation for this collection of values\n+     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() > 0) {\n+            if (getN() > 1) {\n+                stdDev = Math.sqrt(getVariance());\n+            } else {\n+                stdDev = 0.0;\n+            }\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the variance of the values that have been added via West's\n+     * algorithm as described by\n+     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n+     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+     * vol. 22 no. 9, pp. 526-531.</a>.\n+     *\n+     * @return The variance of a set of values.  \n+     *         Double.NaN is returned for an empty \n+     *         set of values and 0.0 is returned for \n+     *         a &lt;= 1 value set.\n+     */\n+    public double getVariance() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return variance.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return variance.getResult();\n+    }\n+\n+    /**\n+     * Returns the skewness of the values that have been added as described by\n+     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">\n+     * Equation (6) for k-Statistics</a>.\n+     * @return The skew of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a \n+     *         &lt;= 2 value set.\n+     */\n+    public double getSkewness() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return skewness.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return skewness.getResult();\n+    }\n+\n+    /**\n+     * Returns the kurtosis of the values that have been added as described by\n+     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">\n+     * Equation (7) for k-Statistics</a>.\n+     *\n+     * @return The kurtosis of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 3 \n+     *         value set.\n+     */\n+    public double getKurtosis() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return kurtosis.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return kurtosis.getResult();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getKurtosisClass()\n+     */\n+    public int getKurtosisClass() {\n+        int kClass = Univariate.MESOKURTIC;\n+\n+        double kurtosis = getKurtosis();\n+        if (kurtosis > 0) {\n+            kClass = Univariate.LEPTOKURTIC;\n+        } else if (kurtosis < 0) {\n+            kClass = Univariate.PLATYKURTIC;\n+        }\n+        return (kClass);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getMax()\n+     */\n+    public double getMax() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return max.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return max.getResult();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getMin()\n+     */\n+    public double getMin() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return min.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return min.getResult();\n+    }\n+\n+    /**\n+    * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+    */\n+    public double getGeometricMean() {\n+        double[] v = internalValues();\n+        if (v != null) {\n+            return geoMean.evaluate(v, this.start(), this.size());\n+        }\n+\n+        return geoMean.getResult();\n+    }\n+\n+    /**\n+     * Generates a text report displaying\n+     * univariate statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     */\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"UnivariateImpl:\\n\");\n+        outBuffer.append(\"n: \" + n + \"\\n\");\n+        outBuffer.append(\"min: \" + min + \"\\n\");\n+        outBuffer.append(\"max: \" + max + \"\\n\");\n+        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n+        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.Univariate#clear()\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        min.clear();\n+        max.clear();\n+        sum.clear();\n+        sumLog.clear();\n+        sumsq.clear();\n+        geoMean.clear();\n+        \n+        moment.clear();\n+        mean.clear();\n+        variance.clear();\n+        skewness.clear();\n+        kurtosis.clear();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     */\n+    public void setWindowSize(int windowSize) {\n+        clear();\n+        this.windowSize = windowSize;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n package org.apache.commons.math.stat;\n \n import java.util.List;\n-import org.apache.commons.beanutils.PropertyUtils;\n+\n+import org.apache.commons.math.util.BeanTransformer;\n \n /**\n  * This implementation of StoreUnivariate uses commons-beanutils to gather\n  * univariate statistics for a List of Java Beans by property.  This \n  * implementation uses beanutils' PropertyUtils to get a simple, nested,\n  * indexed, mapped, or combined property from an element of a List.\n- *\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ * @version $Revision: 1.3 $ $Date: 2003/07/09 21:45:23 $\n  */\n public class BeanListUnivariateImpl extends ListUnivariateImpl {\n \n+    /**\n+     * propertyName of the property to get from the bean\n+     */\n     private String propertyName;\n \n+    /**\n+     * Construct a BeanListUnivariate with specified\n+     * backing list\n+     * @param list Backing List\n+     */\n     public BeanListUnivariateImpl(List list) {\n-        super( list );\n+        super(list);\n     }\n \n+    /**\n+     * Construct a BeanListUnivariate with specified\n+     * backing list and propertyName\n+     * @param list Backing List\n+     * @param propertyName Bean propertyName\n+     */\n     public BeanListUnivariateImpl(List list, String propertyName) {\n-        super( list );\n-        setPropertyName( propertyName );\n+        super(list);\n+        setPropertyName(propertyName);\n+        this.transformer = new BeanTransformer(propertyName);\n     }\n \n+    /**\n+     * @return propertyName\n+     */\n     public String getPropertyName() {\n         return propertyName;\n     }\n \n+    /**\n+     * @param propertyName Name of Property\n+     */\n     public void setPropertyName(String propertyName) {\n-        System.out.println( \"Set prop name; \" + propertyName );\n+        System.out.println(\"Set prop name; \" + propertyName);\n         this.propertyName = propertyName;\n+        this.transformer = new BeanTransformer(propertyName);\n     }\n \n-\n-    /* (non-Javadoc)\n+   /**\n      * @see org.apache.commons.math.Univariate#addValue(double)\n      */\n     public void addValue(double v) {\n-        String msg = \"The BeanListUnivariateImpl does not accept values \" +\n-            \"through the addValue method.  Because elements of this list \" +\n-            \"are JavaBeans, one must be sure to set the 'propertyName' \" +\n-            \"property and add new Beans to the underlying list via the \" +\n-            \"addBean(Object bean) method\";\n-        throw new UnsupportedOperationException( msg );\n+        String msg =\n+            \"The BeanListUnivariateImpl does not accept values \"\n+                + \"through the addValue method.  Because elements of this list \"\n+                + \"are JavaBeans, one must be sure to set the 'propertyName' \"\n+                + \"property and add new Beans to the underlying list via the \"\n+                + \"addBean(Object bean) method\";\n+        throw new UnsupportedOperationException(msg);\n     }\n \n     /**\n         list.add(bean);\n     }\n \n-    /**\n-     * Reads the property of an element in the list.\n-     *\n-     * @param index The location of the value in the internal List\n-     * @return A Number object representing the value at a given \n-     *         index\n-     */\n-    protected Number getInternalIndex(int index) {\n-\n-        try {\n-            Number n = (Number) PropertyUtils.getProperty( list.get( index ), \n-                                                           propertyName );\n-\n-            return n;\n-        } catch( Exception e ) {\n-            // TODO: We could use a better strategy for error handling\n-            // here.\n-\n-            // This is a somewhat foolish design decision, but until\n-            // we figure out what needs to be done, let's return NaN\n-            return new Double(Double.NaN);\n-        }\n-\n-\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n  * Maintains a frequency distribution. <br>\n  * Accepts int, long or string values, converting\n  * all to Strings and maintaining frequency counts.\n- *\n+ * \n+ * @version $Revision: 1.4 $ $Date: 2003/07/09 21:45:23 $\n  */\n public class Frequency {\n     /** name for this frequency distribution. */\n--- a/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n package org.apache.commons.math.stat;\n \n import java.util.List;\n+import org.apache.commons.math.util.DefaultTransformer;\n+import org.apache.commons.math.util.NumberTransformer;\n \n /**\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ * @version $Revision: 1.3 $ $Date: 2003/07/09 21:45:23 $\n  */\n-public class ListUnivariateImpl extends AbstractStoreUnivariate {\n-\n-    // Holds the value of the windowSize, initial windowSize is the constant\n-    // Univariate.INFINITE_WINDOW\n-    private int windowSize = Univariate.INFINITE_WINDOW;\n-\n-    // Holds a reference to a list - GENERICs are going to make\n-    // out lives easier here as we could only accept List<Number>\n-    List list;\n-\n+public class ListUnivariateImpl\n+    extends AbstractStoreUnivariate\n+    implements StoreUnivariate {\n+\n+    /**\n+     * Holds a reference to a list - GENERICs are going to make\n+     * out lives easier here as we could only accept List<Number>\n+     */\n+    protected List list;\n+\n+    /** Number Transformer maps Objects to Number for us. */\n+    protected NumberTransformer transformer;\n+\n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this Univariate\n+     */\n     public ListUnivariateImpl(List list) {\n+        super();\n         this.list = list;\n-    }\n-\n-    /* (non-Javadoc)\n+        transformer = new DefaultTransformer();\n+    }\n+    \n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this Univariate\n+     */\n+    public ListUnivariateImpl(List list, NumberTransformer transformer) {\n+        super();\n+        this.list = list;\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n      * @see org.apache.commons.math.StoreUnivariate#getValues()\n      */\n     public double[] getValues() {\n \n-        int startIndex = 0;\n-        int endIndex = list.size() - 1;\n-        \n+        int length = list.size();\n \n         // If the window size is not INFINITE_WINDOW AND\n         // the current list is larger that the window size, we need to\n         // take into account only the last n elements of the list\n         // as definied by windowSize\n-        if (windowSize != Univariate.INFINITE_WINDOW &&\n-            windowSize < list.size()) {\n-            startIndex = (list.size() - 1) - windowSize;\n+\n+        if (windowSize != Univariate.INFINITE_WINDOW\n+            && windowSize < list.size()) {\n+            length = list.size() - Math.max(0, list.size() - windowSize);\n         }\n \n         // Create an array to hold all values\n-        double[] copiedArray = new double[list.size() - startIndex];\n-\n-        for( int i = startIndex; i <= endIndex; i++ ) {\n-            Number n = (Number) getInternalIndex( i );\n-            copiedArray[i] = n.doubleValue();\n-            i++;\n-        }\n-\n+        double[] copiedArray = new double[length];\n+\n+        for (int i = 0; i < copiedArray.length; i++) {\n+            copiedArray[i] = getElement(i);\n+        }\n         return copiedArray;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n      */\n     public double getElement(int index) {\n \n         double value = Double.NaN;\n-        if (windowSize != Univariate.INFINITE_WINDOW &&\n-            windowSize < list.size()) {\n-\n-            int calcIndex = (list.size() - windowSize) + index;\n-\n-            Number n = (Number) getInternalIndex(calcIndex);\n-            value = n.doubleValue();\n-        } else {\n-            Number n = (Number) getInternalIndex(index);\n-            value = n.doubleValue();\n-        }\n+\n+        int calcIndex = index;\n+\n+        if (windowSize != Univariate.INFINITE_WINDOW\n+            && windowSize < list.size()) {\n+            calcIndex = (list.size() - windowSize) + index;\n+        }\n+\n+        try {\n+            value = transformer.transform(list.get(calcIndex));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n         return value;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#getN()\n      */\n     public int getN() {\n-        int N = 0;\n+        int n = 0;\n \n         if (windowSize != Univariate.INFINITE_WINDOW) {\n             if (list.size() > windowSize) {\n-                N = windowSize;\n+                n = windowSize;\n             } else {\n-                N = list.size();\n+                n = list.size();\n             }\n         } else {\n-            N = list.size();\n-        }\n-        return N;\n-    }\n-\n-    /* (non-Javadoc)\n+            n = list.size();\n+        }\n+        return n;\n+    }\n+\n+    /**\n      * @see org.apache.commons.math.Univariate#addValue(double)\n      */\n     public void addValue(double v) {\n         list.add(new Double(v));\n     }\n-\n-    /* (non-Javadoc)\n+    \n+    /**\n+     * Adds an object to this list. \n+     * @param o Object to add to the list\n+     */\n+    public void addObject(Object o) {\n+        list.add(o);\n+    }\n+\n+    /**\n      * @see org.apache.commons.math.Univariate#clear()\n      */\n     public void clear() {\n+        super.clear();\n         list.clear();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n-     */\n-    public int getWindowSize() {\n-        return windowSize;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-     */\n-    public void setWindowSize(int windowSize) {\n-        this.windowSize = windowSize;\n-    }\n-\n-    /**\n-     * This function exists to support the function of classes which \n-     * extend the ListUnivariateImpl.\n-     *\n-     * @param index The location of the value in the internal List\n-     * @return A Number object representing the value at a given \n-     *         index\n-     */\n-    protected Number getInternalIndex(int index) {\n-\n-        Number n = (Number) list.get( index );\n-        return n;\n-\n-    }\n-}\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#internalValues()\n+     */\n+    protected double[] internalValues() {\n+        return getValues();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#start()\n+     */\n+    protected int start() {\n+        return 0;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#size()\n+     */\n+    protected int size() {\n+        return getN();\n+    }\n+    /**\n+     * @return\n+     */\n+    public NumberTransformer getTransformer() {\n+        return transformer;\n+    }\n+\n+    /**\n+     * @param transformer\n+     */\n+    public void setTransformer(NumberTransformer transformer) {\n+        this.transformer = transformer;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  * identified in the javadoc for each method, Double.NaN.\n+ * @version $Revision: 1.14 $ $Date: 2003/07/09 21:45:23 $\n  */\n public class StatUtils {\n \n             sumLog += Math.log(values[i]);\n         }\n         return sumLog;\n-    }\n-\n-    /**\n-     * Returns the geometric mean for this collection of values\n-     * @param values Is a double[] containing the values\n-     * @return the geometric mean or Double.NaN if the array is empty or\n-     * any of the values are &lt;= 0.\n-     */\n-    public static double geometricMean(double[] values) {\n-        return geometricMean(values, 0, values.length);\n-    }\n-\n-    /**\n-     * Returns the geometric mean for this collection of values\n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the geometric mean or Double.NaN if the array is empty or\n-     * any of the values are &lt;= 0.\n-     */\n-    public static double geometricMean(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-        return Math.exp(sumLog(values, begin, length) / (double) length );\n     }\n \n     /**\n     public static double mean(double[] values, int begin, int length) {\n         testInput(values, begin, length);\n         return sum(values, begin, length) / ((double) length);\n-    }\n-\n-    /**\n-     *      \n-     * @param values Is a double[] containing the values\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n-     */\n-    public static double standardDeviation(double[] values) {\n-        return standardDeviation(values, 0, values.length);\n-    }\n-\n-    /**\n-     *      \n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the result, Double.NaN if no values for an empty array \n-     * or 0.0 for a single value set.  \n-     */\n-    public static double standardDeviation(\n-        double[] values,\n-        int begin,\n-        int length) {\n-        testInput(values, begin, length);\n-        double stdDev = Double.NaN;\n-        if (values.length != 0) {\n-            stdDev = Math.sqrt(variance(values, begin, length));\n-        }\n-        return (stdDev);\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns the skewness of a collection of values.  Skewness is a \n-     * measure of the assymetry of a given distribution. \n-     * @param values Is a double[] containing the values\n-     * @return the skewness of the values or Double.NaN if the array is empty\n-     */\n-    public static double skewness(double[] values) {\n-        return skewness(values, 0, values.length);\n-    }\n-        /**\n-     * Returns the skewness of a collection of values.  Skewness is a \n-     * measure of the assymetry of a given distribution. \n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the skewness of the values or Double.NaN if the array is empty\n-     */\n-    public static double skewness(double[] values, int begin, int length) {\n-\n-        testInput(values, begin, length);\n-\n-        // Initialize the skewness\n-        double skewness = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = mean(values, begin, length);\n-\n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - mean), 2.0);\n-            accum2 += (values[i] - mean);\n-        }\n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Calculate the skew as the sum the cubes of the distance \n-        // from the mean divided by the standard deviation.\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - mean) / stdDev, 3.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        // Calculate skewness\n-        skewness = (n / ((n - 1) * (n - 2))) * accum3;\n-\n-        return skewness;\n-    }\n-\n-    /**\n-     * Returns the kurtosis for this collection of values. Kurtosis is a \n-     * measure of the \"peakedness\" of a distribution.\n-     * @param values Is a double[] containing the values\n-     * @return the kurtosis of the values or Double.NaN if the array is empty\n-     */\n-    public static double kurtosis(double[] values) {\n-        return kurtosis(values, 0, values.length);\n-    }\n-    \n-    /**\n-     * Returns the kurtosis for this collection of values. Kurtosis is a \n-     * measure of the \"peakedness\" of a distribution.\n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     * @return the kurtosis of the values or Double.NaN if the array is empty\n-     */\n-    public static double kurtosis(double[] values, int begin, int length) {\n-        testInput(values, begin, length);\n-\n-        // Initialize the kurtosis\n-        double kurtosis = Double.NaN;\n-\n-        // Get the mean and the standard deviation\n-        double mean = mean(values, begin, length);\n-\n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - mean), 2.0);\n-            accum2 += (values[i] - mean);\n-        }\n-        \n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Sum the ^4 of the distance from the mean divided by the \n-        // standard deviation\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - mean) / stdDev, 4.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n-        \n-        // Calculate kurtosis\n-        kurtosis = (coefficientOne * accum3) - termTwo;\n-\n-        return kurtosis;\n-    }\n-    \n-    /**\n      * Returns the maximum of the available values\n      * @param values Is a double[] containing the values\n      * @return the maximum of the values or Double.NaN if the array is empty\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariate.java\n  * Univariate provides additional percentile functionality \n  * such as.  This additional functionality comes with \n  * a price of increased storage costs.\n- * \n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ * @version $Revision: 1.7 $ $Date: 2003/07/09 21:45:23 $\n  */\n public interface StoreUnivariate extends Univariate {\n-\n-    /**\n-     * A LEPTOKURTIC set has a positive kurtosis (a high peak) \n-     */\n-    public static int LEPTOKURTIC = 1;\n-\n-    /**\n-     * A MESOKURTIC set has a kurtosis of 0 - it is a normal distribution\n-     */\n-    public static int MESOKURTIC = 0;\n-\n-    /**\n-     * A PLATYKURTIC set has a negative kurtosis (a flat \"peak\")\n-     */\n-    public static int PLATYKURTIC = -1;\n-\n-    /** \n-     * Returns the skewness of a given distribution.  Skewness is a \n-     * measure of the assymetry of a given distribution. \n-     * \n-     * @return The skewness of this distribution\n-     */\n-    double getSkewness();\n-\n-    /** \n-     * Kurtosis is a measure of the \"peakedness\" of a distribution\n-     * \n-     * @return the mode\n-     */\n-    double getKurtosis();\n-\n-    /**\n-     * Returns the Kurtosis \"classification\" a distribution can be \n-     * leptokurtic (high peak), platykurtic (flat peak), \n-     * or mesokurtic (zero kurtosis).  \n-     * \n-     * @return A static constant defined in this interface, \n-     *         StoredDeviation.LEPTOKURITC, StoredDeviation.PLATYKURTIC, or \n-     *         StoredDeviation.MESOKURTIC\n-     */\n-    int getKurtosisClass();\n \n     /**\n      * Returns the current set of values in an array of double primitives.  \n--- a/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n import org.apache.commons.math.util.ContractableDoubleArray;\n \n /**\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ * @version $Revision: 1.4 $ $Date: 2003/07/09 21:45:23 $\n  */\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n-    // Use an internal double array\n-    ContractableDoubleArray eDA;\n+    /** A contractable double array is used.  memory is reclaimed when \n+     * the storage of the array becomes too empty.\n+     */\n+    protected ContractableDoubleArray eDA;\n \n-    // Store the windowSize\n-    private int windowSize = Univariate.INFINITE_WINDOW;\n-\n+    /**\n+     * Construct a StoreUnivariateImpl\n+     */\n     public StoreUnivariateImpl() {\n-        // A contractable double array is used.  memory is reclaimed when\n-        // the storage of the array becomes too empty.\n         eDA = new ContractableDoubleArray();\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.StoreUnivariate#getValues()\n      */\n     public double[] getValues() {\n \n-        double[] copiedArray = new double[ eDA.getNumElements() ];\n-        System.arraycopy( eDA.getElements(), 0, \n-                          copiedArray, 0, eDA.getNumElements());\n+        double[] copiedArray = new double[eDA.getNumElements()];\n+        System.arraycopy(\n+            eDA.getElements(),\n+            0,\n+            copiedArray,\n+            0,\n+            eDA.getNumElements());\n         return copiedArray;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n      */\n     public double getElement(int index) {\n         return eDA.getElement(index);\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#getN()\n      */\n     public int getN() {\n         return eDA.getNumElements();\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#addValue(double)\n      */\n     public synchronized void addValue(double v) {\n-        if( windowSize != Univariate.INFINITE_WINDOW ) {\n-            if( getN() == windowSize ) {\n-                eDA.addElementRolling( v );\n-            } else if( getN() < windowSize ) {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            if (getN() == windowSize) {\n+                eDA.addElementRolling(v);\n+            } else if (getN() < windowSize) {\n                 eDA.addElement(v);\n             } else {\n-                String msg = \"A window Univariate had more element than \" +\n-\t\t\t\t\t\"the windowSize.  This is an inconsistent state.\";\n-                throw new RuntimeException( msg );\n+                String msg =\n+                    \"A window Univariate had more element than \"\n+                        + \"the windowSize.  This is an inconsistent state.\";\n+                throw new RuntimeException(msg);\n             }\n         } else {\n             eDA.addElement(v);\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#clear()\n      */\n     public synchronized void clear() {\n+        super.clear();\n         eDA.clear();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n-     */\n-    public int getWindowSize() {\n-        return windowSize;\n-    }\n-\n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#setWindowSize(int)\n      */\n     public synchronized void setWindowSize(int windowSize) {\n         // We need to check to see if we need to discard elements\n         // from the front of the array.  If the windowSize is less than \n         // the current number of elements.\n-        if( windowSize < eDA.getNumElements() ) {\n-            eDA.discardFrontElements( eDA.getNumElements() - windowSize);\n+        if (windowSize < eDA.getNumElements()) {\n+            eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n         }\n     }\n-}\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#internalValues()\n+     */\n+    protected double[] internalValues() {\n+        return eDA.getValues();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#start()\n+     */\n+    protected int start() {\n+        return eDA.start();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#size()\n+     */\n+    protected int size() {\n+        return eDA.getNumElements();\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/TestStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/TestStatistic.java\n /**\n  * A collection of commonly used test statistics and statistical tests.\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/07/07 23:19:20 $\n- * \n+ * @version $Revision: 1.4 $ $Date: 2003/07/09 21:45:23 $ \n  */\n public interface TestStatistic {\n     \n--- a/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n+++ b/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n /**\n  * Implements test statistics defined in the TestStatistic interface.\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/07/07 23:19:20 $\n- * \n+ * @version $Revision: 1.4 $ $Date: 2003/07/09 21:45:23 $\n  */\n public class TestStatisticImpl implements TestStatistic {\n     \n--- a/src/java/org/apache/commons/math/stat/Univariate.java\n+++ b/src/java/org/apache/commons/math/stat/Univariate.java\n  * reported statistics will be based on these values<p>\n  * The default windowSize is \"infinite\" -- i.e., all values added are included\n  * in all computations.\n- *\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.7 $ $Date: 2003/07/07 23:25:13 $\n- * \n+ * @version $Revision: 1.8 $ $Date: 2003/07/09 21:45:23 $\n */\n public interface Univariate {\n+    /**\n+     * A LEPTOKURTIC set has a positive kurtosis (a high peak) \n+     */\n+    public static int LEPTOKURTIC = 1;\n+    /**\n+     * A MESOKURTIC set has a kurtosis of 0 - it is a normal distribution\n+     */\n+    public static int MESOKURTIC = 0;\n+    /**\n+     * A PLATYKURTIC set has a negative kurtosis (a flat \"peak\")\n+     */\n+    public static int PLATYKURTIC = -1;\n \n     /**\n      * Adds the value to the set of numbers\n     void addValue(double v);\n \n     /** \n-     * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n      * arithmetic mean </a> of the available values \n      * @return The mean or Double.NaN if no values have been added.\n      */\n     double getMean();\n \n     /** \n-     * Returns the <a href=http://www.xycoon.com/geometric_mean.htm>\n+     * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n      * geometric mean </a> of the available values\n      * @return The geometricMean, Double.NaN if no values have been added, \n      * or if the productof the available values is less than or equal to 0.\n      */\n     double getKurtosis();\n \n+    /**\n+     * Returns the Kurtosis \"classification\" a distribution can be \n+     * leptokurtic (high peak), platykurtic (flat peak), \n+     * or mesokurtic (zero kurtosis).  \n+     * \n+     * @return A static constant defined in this interface, \n+     *         StoredDeviation.LEPTOKURITC, StoredDeviation.PLATYKURTIC, or \n+     *         StoredDeviation.MESOKURTIC\n+     */\n+    int getKurtosisClass();\n+    \n     /** \n      * Returns the maximum of the available values\n      * @return The max or Double.NaN if no values have been added.\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n package org.apache.commons.math.stat;\n \n import java.io.Serializable;\n-\n-import org.apache.commons.math.util.DoubleArray;\n import org.apache.commons.math.util.FixedDoubleArray;\n \n /**\n  * Integers, floats and longs can be added, but they will be converted\n  * to doubles by addValue().\n  *\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @author Brent Worden\n- * @version $Revision: 1.17 $ $Date: 2003/07/07 23:25:13 $\n- *\n+ * @version $Revision: 1.18 $ $Date: 2003/07/09 21:45:23 $\n */\n-public class UnivariateImpl implements Univariate, Serializable {\n+public class UnivariateImpl\n+    extends AbstractUnivariate\n+    implements Univariate, Serializable {\n \n-    /** hold the window size **/\n-    private int windowSize = Univariate.INFINITE_WINDOW;\n-\n-    /** Just in case the windowSize is not infinite, we need to\n-     *  keep an array to remember values 0 to N\n-     */\n-    private DoubleArray doubleArray;\n-\n-    /** count of values that have been added */\n-    private int n = 0;\n-\n-    /** sum of values that have been added */\n-    private double sum = Double.NaN;\n-\n-    /** sum of the square of each value that has been added */\n-    private double sumsq = Double.NaN;\n-\n-    /** min of values that have been added */\n-    private double min = Double.NaN;\n-\n-    /** max of values that have been added */\n-    private double max = Double.NaN;\n-\n-    /** sumLog of values that have been added */\n-    private double sumLog = Double.NaN;\n-\n-    /** mean of values that have been added */\n-    private double mean = Double.NaN;\n-\n-    /** second moment of values that have been added */\n-    private double m2 = Double.NaN;\n-\n-    /** third moment of values that have been added */\n-    private double m3 = Double.NaN;\n-\n-    /** fourth moment of values that have been added */\n-    private double m4 = Double.NaN;\n-\n-    /** variance of values that have been added */\n-    private double variance = Double.NaN;\n-\n-    /** skewness of values that have been added */\n-    private double skewness = Double.NaN;\n-\n-    /** kurtosis of values that have been added */\n-    private double kurtosis = Double.NaN;\n+    /** fixed storage */\n+    private FixedDoubleArray storage = null;\n \n     /** Creates new univariate with an infinite window */\n     public UnivariateImpl() {\n+        super();\n     }\n \n-    /** Creates a new univariate with a fixed window **/\n+    /** \n+     * Creates a new univariate with a fixed window \n+     * @param window Window Size\n+     */\n     public UnivariateImpl(int window) {\n-        setWindowSize(window);\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getN()\n-     */\n-    public int getN() {\n-        return n;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getSum()\n-     */\n-    public double getSum() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.sum(doubleArray.getElements());\n-        }\n-\n-        return sum;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getSumsq()\n-     */\n-    public double getSumsq() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.sumSq(doubleArray.getElements());\n-        }\n-\n-        return sumsq;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getMean()\n-     */\n-    public double getMean() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.mean(doubleArray.getElements());\n-        }\n-\n-        return mean;\n+        super(window);\n+        storage = new FixedDoubleArray(window);\n     }\n \n     /**\n-     * Returns the standard deviation for this collection of values\n-     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-     */\n-    public double getStandardDeviation() {\n-        double stdDev = Double.NaN;\n-        if (getN() != 0) {\n-            stdDev = Math.sqrt(getVariance());\n-        }\n-        return (stdDev);\n-    }\n-\n-    /**\n-     * Returns the variance of the values that have been added via West's\n-     * algorithm as described by\n-     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n-     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n-     * vol. 22 no. 9, pp. 526-531.</a>.\n-     *\n-     * @return The variance of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n-     */\n-    public double getVariance() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            variance = StatUtils.variance(doubleArray.getElements());\n-        }\n-        return variance;\n-    }\n-\n-    /**\n-     * Returns the skewness of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n-     *\n-     * @return The skew of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n-     */\n-    public double getSkewness() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.skewness(doubleArray.getElements());\n-        }\n-        return skewness;\n-    }\n-\n-    /**\n-     * Returns the kurtosis of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n-     *\n-     * @return The kurtosis of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n-     */\n-    public double getKurtosis() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.kurtosis(doubleArray.getElements());\n-        }\n-        return kurtosis;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getMax()\n-     */\n-    public double getMax() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.max(doubleArray.getElements());\n-        }\n-        return max;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.stat.Univariate#getMin()\n-     */\n-    public double getMin() {\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.min(doubleArray.getElements());\n-        }\n-        return min;\n-    }\n-\n-    /* (non-Javadoc)\n-    * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-    */\n-    public double getGeometricMean() {\n-\n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n-            return StatUtils.geometricMean(doubleArray.getElements());\n-        }\n-\n-        if (n == 0) {\n-            return Double.NaN;\n-        } else {\n-            return Math.exp(sumLog / (double) n);\n-        }\n-    }\n-\n-    /* If windowSize is set to Infinite, moments are calculated using the following \n+     *  If windowSize is set to Infinite, moments \n+     *  are calculated using the following \n      * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n      * recursive strategy\n      * </a>.\n      */\n     public void addValue(double value) {\n \n-        if (windowSize != Univariate.INFINITE_WINDOW) {\n+        if (storage != null) {\n             /* then all getters deligate to StatUtils\n              * and this clause simply adds/rolls a value in the storage array \n              */\n-            if (windowSize == n) {\n-                doubleArray.addElementRolling(value);\n+            if (getWindowSize() == n) {\n+                storage.addElementRolling(value);\n             } else {\n                 n++;\n-                doubleArray.addElement(value);\n+                storage.addElement(value);\n             }\n \n         } else {\n              * is no need to discard the influence of any single item.\n              */\n             n++;\n-\n-            if (n <= 1) {\n-                /* if n <= 1, initialize the sumLog, min, max, mean, variance and pre-variance */\n-                sumLog = 0.0;\n-                sum = min = max = mean = value;\n-                sumsq = value * value;\n-                variance = m2 = 0.0;\n-                skewness = kurtosis = 0.0;\n-                m2 = m3 = m4 = 0.0;\n-            } else {\n-                /* otherwise calc these values */\n-                sumLog += Math.log(value);\n-                sum += value;\n-                sumsq += value * value;\n-                min = Math.min(min, value);\n-                max = Math.max(max, value);\n-\n-                double dev = value - mean;\n-                double v = dev / ((double) n);\n-                double v2 = v * v;\n-\n-                double n0 = (double) n;\n-                double n1 = (double) (n - 1);\n-                double n2 = (double) (n - 2);\n-                double n3 = (double) (n - 3);\n-\n-                m4 =\n-                    m4\n-                        - (4.0 * v * m3)\n-                        + (6.0 * v2 * m2)\n-                        + ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n-\n-                m3 = m3 - (3.0 * v * m2) + (n0 * n1 * n2 * v2 * v);\n-\n-                m2 += n1 * dev * v;\n-\n-                mean += v;\n-\n-                variance = (n <= 1) ? 0.0 : m2 / n1;\n-\n-                skewness =\n-                    (n <= 2 || variance < 10E-20)\n-                        ? 0.0\n-                        : (n0 * m3) / (n1 * n2 * Math.sqrt(variance) * variance);\n-\n-                kurtosis =\n-                    (n <= 3 || variance < 10E-20)\n-                        ? 0.0\n-                        : (n0 * (n0 + 1) * m4 - 3 * m2 * m2 * n1)\n-                            / (n1 * n2 * n3 * variance * variance);\n-            }\n+            min.increment(value);\n+            max.increment(value);\n+            sum.increment(value);\n+            sumsq.increment(value);\n+            sumLog.increment(value);\n+            geoMean.increment(value);\n+            \n+            moment.increment(value);\n+            //mean.increment(value);\n+            //variance.increment(value);\n+            //skewness.increment(value);\n+            //kurtosis.increment(value);\n         }\n     }\n \n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n         outBuffer.append(\"UnivariateImpl:\\n\");\n-        outBuffer.append(\"n: \" + n + \"\\n\");\n-        outBuffer.append(\"min: \" + min + \"\\n\");\n-        outBuffer.append(\"max: \" + max + \"\\n\");\n+        outBuffer.append(\"n: \" + getN() + \"\\n\");\n+        outBuffer.append(\"min: \" + getMin() + \"\\n\");\n+        outBuffer.append(\"max: \" + getMax() + \"\\n\");\n         outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n         outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n         outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n         return outBuffer.toString();\n     }\n \n-    /* (non-Javadoc)\n+    /**\n      * @see org.apache.commons.math.Univariate#clear()\n      */\n     public void clear() {\n-        this.n = 0;\n-        this.min = this.max = Double.NaN;\n-        this.sumLog = this.mean = Double.NaN;\n-        this.variance = this.skewness = this.kurtosis = Double.NaN;\n-        this.m2 = this.m3 = this.m4 = Double.NaN;\n-        if (doubleArray != null)\n-            doubleArray = new FixedDoubleArray(windowSize);\n+        super.clear();\n+        if (getWindowSize() != INFINITE_WINDOW) {\n+            storage = new FixedDoubleArray(getWindowSize());\n+        }\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#internalValues()\n      */\n-    public int getWindowSize() {\n-        return windowSize;\n+    protected double[] internalValues() {\n+        return storage == null ? null : storage.getValues();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#start()\n      */\n-    public void setWindowSize(int windowSize) {\n-        clear();\n-        this.windowSize = windowSize;\n-        doubleArray = new FixedDoubleArray(windowSize);\n+    protected int start() {\n+        return storage.start();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.AbstractUnivariate#size()\n+     */\n+    protected int size() {\n+        return storage.getNumElements();\n     }\n \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/MixedListUnivariateImplTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math.util.NumberTransformer;\n+import org.apache.commons.math.util.TransformerMap;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Univariate} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2003/07/09 21:45:24 $\n+ */\n+\n+public final class MixedListUnivariateImplTest extends TestCase {\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double skewness = 0;\n+    private double kurtosis = 0.5;\n+    private int kClass = StoreUnivariate.LEPTOKURTIC;\n+    private double tolerance = 10E-15;\n+\n+    private TransformerMap transformers = new TransformerMap();\n+    \n+    public MixedListUnivariateImplTest(String name) {\n+        super(name);\n+        transformers = new TransformerMap();\n+\n+        transformers.putTransformer(Foo.class, new NumberTransformer() {\n+            public double transform(Object o) {\n+                return Double.parseDouble(((Foo) o).heresFoo());\n+            }\n+        });\n+\n+        transformers.putTransformer(Bar.class, new NumberTransformer() {\n+            public double transform(Object o) {\n+                return Double.parseDouble(((Bar) o).heresBar());\n+            }\n+\n+        });\n+\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);\n+        suite.setName(\"Mixed List Tests\");\n+        return suite;\n+    }\n+\n+    /** test stats */\n+    public void testStats() {\n+        List externalList = new ArrayList();\n+\n+        StoreUnivariate u = new ListUnivariateImpl(externalList,transformers);\n+\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\", n, u.getN(), tolerance);\n+        assertEquals(\"sum\", sum, u.getSum(), tolerance);\n+        assertEquals(\"sumsq\", sumSq, u.getSumsq(), tolerance);\n+        assertEquals(\"var\", var, u.getVariance(), tolerance);\n+        assertEquals(\"std\", std, u.getStandardDeviation(), tolerance);\n+        assertEquals(\"mean\", mean, u.getMean(), tolerance);\n+        assertEquals(\"min\", min, u.getMin(), tolerance);\n+        assertEquals(\"max\", max, u.getMax(), tolerance);\n+        u.clear();\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+    }\n+\n+    public void testN0andN1Conditions() throws Exception {\n+        List list = new ArrayList();\n+\n+        StoreUnivariate u = new ListUnivariateImpl(new ArrayList(),transformers);\n+\n+        assertTrue(\n+            \"Mean of n = 0 set should be NaN\",\n+            Double.isNaN(u.getMean()));\n+        assertTrue(\n+            \"Standard Deviation of n = 0 set should be NaN\",\n+            Double.isNaN(u.getStandardDeviation()));\n+        assertTrue(\n+            \"Variance of n = 0 set should be NaN\",\n+            Double.isNaN(u.getVariance()));\n+\n+        u.addValue(one);\n+\n+        assertTrue(\n+            \"Mean of n = 1 set should be value of single item n1, instead it is \" + u.getMean() ,\n+            u.getMean() == one);\n+            \n+        assertTrue(\n+            \"StdDev of n = 1 set should be zero, instead it is: \"\n+                + u.getStandardDeviation(),\n+            u.getStandardDeviation() == 0);\n+        assertTrue(\n+            \"Variance of n = 1 set should be zero\",\n+            u.getVariance() == 0);\n+    }\n+\n+    public void testSkewAndKurtosis() {\n+        ListUnivariateImpl u =\n+            new ListUnivariateImpl(new ArrayList(), transformers);\n+\n+        u.addObject(\"12.5\");\n+        u.addObject(new Integer(12));\n+        u.addObject(\"11.8\");\n+        u.addObject(\"14.2\");\n+        u.addObject(new Foo());\n+        u.addObject(\"14.5\");\n+        u.addObject(new Long(21));\n+        u.addObject(\"8.2\");\n+        u.addObject(\"10.3\");\n+        u.addObject(\"11.3\");\n+        u.addObject(new Float(14.1));\n+        u.addObject(\"9.9\");\n+        u.addObject(\"12.2\");\n+        u.addObject(new Bar());\n+        u.addObject(\"12.1\");\n+        u.addObject(\"11\");\n+        u.addObject(new Double(19.8));\n+        u.addObject(\"11\");\n+        u.addObject(\"10\");\n+        u.addObject(\"8.8\");\n+        u.addObject(\"9\");\n+        u.addObject(\"12.3\");\n+\n+\n+        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        u.setWindowSize(10);\n+\n+        u.addValue(1.0);\n+        u.addValue(2.0);\n+        u.addValue(3.0);\n+        u.addValue(4.0);\n+\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            2.213364,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+        // Now test rolling - UnivariateImpl should discount the contribution\n+        // of a discarded element\n+        for (int i = 0; i < 10; i++) {\n+            u.addValue(i + 2);\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            5.755931,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+    }\n+\n+    public final class Foo {\n+        public String heresFoo() {\n+            return \"14.9\";\n+        }\n+    }\n+\n+    public final class Bar {\n+        public String heresBar() {\n+            return \"12.0\";\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n \n /**\n  * Test cases for the {@link StatUtils} class.\n- * @version $Revision: 1.5 $ $Date: 2003/07/07 23:25:14 $\n+ * @version $Revision: 1.6 $ $Date: 2003/07/09 21:45:24 $\n  */\n \n public final class StatUtilsTest extends TestCase {\n         assertEquals(\"sum\", sum, StatUtils.sum(values), tolerance);\n         assertEquals(\"sumsq\", sumSq, StatUtils.sumSq(values), tolerance);\n         assertEquals(\"var\", var, StatUtils.variance(values), tolerance);\n-        assertEquals(\n-            \"std\",\n-            std,\n-            StatUtils.standardDeviation(values),\n-            tolerance);\n         assertEquals(\"mean\", mean, StatUtils.mean(values), tolerance);\n         assertEquals(\"min\", min, StatUtils.min(values), tolerance);\n         assertEquals(\"max\", max, StatUtils.max(values), tolerance);\n             \"Mean of n = 0 set should be NaN\",\n             Double.isNaN(StatUtils.mean(values)));\n         assertTrue(\n-            \"Standard Deviation of n = 0 set should be NaN\",\n-            Double.isNaN(StatUtils.standardDeviation(values)));\n-        assertTrue(\n             \"Variance of n = 0 set should be NaN\",\n             Double.isNaN(StatUtils.variance(values)));\n \n         assertTrue(\n             \"Mean of n = 1 set should be value of single item n1\",\n             StatUtils.mean(values) == one);\n-        assertTrue(\n-            \"StdDev of n = 1 set should be zero, instead it is: \"\n-                + StatUtils.standardDeviation(values),\n-            StatUtils.standardDeviation(values) == 0);\n         assertTrue(\n             \"Variance of n = 1 set should be zero\",\n             StatUtils.variance(values) == 0);\n \n         assertEquals(\"mean\", 12.40455, StatUtils.mean(values), 0.0001);\n         assertEquals(\"variance\", 10.00236, StatUtils.variance(values), 0.0001);\n-        assertEquals(\"skewness\", 1.437424, StatUtils.skewness(values), 0.0001);\n-        assertEquals(\"kurtosis\", 2.37719, StatUtils.kurtosis(values), 0.0001);\n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n             24.0,\n             StatUtils.product(values),\n             Double.MIN_VALUE);\n-        assertEquals(\n-            \"Geometric mean not expected\",\n-            2.213364,\n-            StatUtils.geometricMean(values),\n-            0.00001);\n     }\n \n     public void testArrayIndexConditions() throws Exception {\n--- a/src/test/org/apache/commons/math/stat/UnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/UnivariateImplTest.java\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author Tim Obrien\n- * @version $Revision: 1.5 $ $Date: 2003/07/07 23:19:19 $\n+ * @version $Revision: 1.6 $ $Date: 2003/07/09 21:45:24 $\n  */\n \n public final class UnivariateImplTest extends TestCase {\n \t\tu.addValue(one);\n \t\tassertTrue(\"mean should be one (n = 1)\", \n \t\t\tu.getMean() == one);\n-\t\tassertTrue(\"geometric should be one (n = 1)\", \n+\t\tassertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(), \n \t\t\tu.getGeometricMean() == one);\n \t\tassertTrue(\"Std should be zero (n = 1)\", \n \t\t\tu.getStandardDeviation() == 0.0);\n--- a/src/test/org/apache/commons/math/stat/univariate/InteractionTest.java\n+++ b/src/test/org/apache/commons/math/stat/univariate/InteractionTest.java\n             k.increment(testArray[i]);\n         }\n         \n-        assertEquals(mean,m.getValue(),tolerance);\n-        assertEquals(var,v.getValue(),tolerance);\n-        assertEquals(skew ,s.getValue(),tolerance);\n-        assertEquals(kurt,k.getValue(),tolerance);\n+        assertEquals(mean,m.getResult(),tolerance);\n+        assertEquals(var,v.getResult(),tolerance);\n+        assertEquals(skew ,s.getResult(),tolerance);\n+        assertEquals(kurt,k.getResult(),tolerance);\n \n     }\n ", "timestamp": 1057787193, "metainfo": ""}