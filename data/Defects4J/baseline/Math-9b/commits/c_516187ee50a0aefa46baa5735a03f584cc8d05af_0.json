{"sha": "516187ee50a0aefa46baa5735a03f584cc8d05af", "log": "added the two methods getCurrentStepStart and getCurrentStepsize to interface FirstOrderIntegrator allowing ODE problems to retrieve the current step start and size during integration for each step trial (i.e. even before the step is accepted)  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n \n     switchesHandler = new SwitchingFunctionsHandler();\n \n+    resetInternalState();\n+\n   }\n \n   /** Build an integrator with the given stepsize bounds.\n     handler = DummyStepHandler.getInstance();\n \n     switchesHandler = new SwitchingFunctionsHandler();\n+\n+    resetInternalState();\n \n   }\n \n                                   double t, double[] y)\n     throws DerivativeException, IntegratorException;\n \n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  public double getCurrentStepsize() {\n+    return stepSize;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  protected void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Math.sqrt(minStep * maxStep);\n+  }\n+\n   /** Get the minimal step.\n    * @return minimal step\n    */\n   /** Switching functions handler. */\n   protected SwitchingFunctionsHandler switchesHandler;\n \n+  /** Current step start time. */\n+  protected double stepStart;\n+\n+  /** Current stepsize. */\n+  protected double stepSize;\n+\n }\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n                                    double maxCheckInterval,\n                                    double convergence);\n \n-  /** Integrate the differential equations up to the given time\n+  /** Integrate the differential equations up to the given time.\n+   * <p>This method solves an Initial Value Problem (IVP).</p>\n+   * <p>Since this method stores some internal state variables made\n+   * available in its public interface during integration ({@link\n+   * #getCurrentStepsize()}), it is <em>not</em> thread-safe.</p>\n    * @param equations differential equations to integrate\n    * @param t0 initial time\n    * @param y0 initial value of the state vector at t0\n    * @param t target time for the integration\n-   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * (can be set to a value smaller than <code>t0</code> for backward integration)\n    * @param y placeholder where to put the state vector at each successful\n    *  step (and hence at the end of integration), can be the same object as y0\n    * @throws IntegratorException if the integrator cannot perform integration\n                          double t, double[] y)\n     throws DerivativeException, IntegratorException;\n \n+  /** Get the current value of the step start time t<sub>i</sub>.\n+   * <p>This method can be called during integration (typically by\n+   * the object implementing the {@link FirstOrderDifferentialEquations\n+   * differential equations} problem) if the value of the current step that\n+   * is attempted is needed.</p>\n+   * <p>The result is undefined if the method is called outside of\n+   * calls to {@link #integrate}</p>\n+   * @return current value of the step start time t<sub>i</sub>\n+   */\n+  public double getCurrentStepStart();\n+\n+  /** Get the current value of the integration stepsize.\n+   * <p>This method can be called during integration (typically by\n+   * the object implementing the {@link FirstOrderDifferentialEquations\n+   * differential equations} problem) if the value of the current stepsize\n+   * that is tried is needed.</p>\n+   * <p>The result is undefined if the method is called outside of\n+   * calls to {@link #integrate}</p>\n+   * @return current value of the stepsize\n+   */\n+  public double getCurrentStepsize();\n+\n }\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n     }\n     interpolator.storeTime(t0);\n \n-    double  currentT         = t0;\n+    stepStart = t0;\n     double  hNew             = 0;\n     double  maxError         = Double.MAX_VALUE;\n     boolean previousRejected = false;\n     costPerTimeUnit[0] = 0;\n     while (! lastStep) {\n \n-      double h;\n       double error;\n       boolean reject = false;\n \n \n         // first evaluation, at the beginning of the step\n         if (! firstStepAlreadyComputed) {\n-          equations.computeDerivatives(currentT, y, yDot0);\n+          equations.computeDerivatives(stepStart, y, yDot0);\n         }\n \n         if (firstTime) {\n \n           hNew = initializeStep(equations, forward,\n                                 2 * targetIter + 1, scale,\n-                                currentT, y, yDot0, yTmp, yTmpDot);\n+                                stepStart, y, yDot0, yTmp, yTmpDot);\n \n           if (! forward) {\n             hNew = -hNew;\n \n       }\n \n-      h = hNew;\n+      stepSize = hNew;\n \n       // step adjustment near bounds\n-      if ((forward && (currentT + h > t))\n-          || ((! forward) && (currentT + h < t))) {\n-        h = t - currentT;\n-      }\n-      double nextT = currentT + h;\n+      if ((forward && (stepStart + stepSize > t))\n+          || ((! forward) && (stepStart + stepSize < t))) {\n+        stepSize = t - stepStart;\n+      }\n+      double nextT = stepStart + stepSize;\n       lastStep = forward ? (nextT >= t) : (nextT <= t);\n \n       // iterate over several substep sizes\n         ++k;\n \n         // modified midpoint integration with the current substep\n-        if ( ! tryStep(equations, currentT, y, h, k, scale, fk[k],\n+        if ( ! tryStep(equations, stepStart, y, stepSize, k, scale, fk[k],\n                        (k == 0) ? yMidDots[0] : diagonal[k-1],\n                        (k == 0) ? y1 : y1Diag[k-1],\n                        yTmp)) {\n \n           // the stability check failed, we reduce the global step\n-          hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n           reject = true;\n           loop   = false;\n \n \n             if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n               // error is too big, we reduce the global step\n-              hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));\n               reject = true;\n               loop   = false;\n             } else {\n               double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n               double pow = Math.pow(stepControl3, exp);\n               fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n-              optimalStep[k]     = Math.abs(filterStep(h * fac, true));\n+              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));\n               costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n \n               // check convergence\n         }\n \n         // derivative at end of step\n-        equations.computeDerivatives(currentT + h, y1, yDot1);\n+        equations.computeDerivatives(stepStart + stepSize, y1, yDot1);\n \n         int mu = 2 * k - mudif + 3;\n \n             extrapolate(l2, j, diagonal, yMidDots[l+1]);\n           }\n           for (int i = 0; i < y0.length; ++i) {\n-            yMidDots[l+1][i] *= h;\n+            yMidDots[l+1][i] *= stepSize;\n           }\n \n           // compute centered differences to evaluate next derivatives\n           // estimate the dense output coefficients\n           GraggBulirschStoerStepInterpolator gbsInterpolator\n             = (GraggBulirschStoerStepInterpolator) interpolator;\n-          gbsInterpolator.computeCoefficients(mu, h);\n+          gbsInterpolator.computeCoefficients(mu, stepSize);\n \n           if (useInterpolationError) {\n             // use the interpolation error to limit stepsize\n             double interpError = gbsInterpolator.estimateError(scale);\n-            hInt = Math.abs(h / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n-                                         0.01));\n+            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                                0.01));\n             if (interpError > 10.0) {\n               hNew = hInt;\n               reject = true;\n \n           // Switching functions handling\n           if (!reject) {\n-            interpolator.storeTime(currentT + h);\n+            interpolator.storeTime(stepStart + stepSize);\n             if (switchesHandler.evaluateStep(interpolator)) {\n               reject = true;\n-              hNew = Math.abs(switchesHandler.getEventTime() - currentT);\n+              hNew = Math.abs(switchesHandler.getEventTime() - stepStart);\n             }\n           }\n \n       if (! reject) {\n \n         // store end of step state\n-        currentT += h;\n+        stepStart += stepSize;\n         System.arraycopy(y1, 0, y, 0, y0.length);\n \n-        switchesHandler.stepAccepted(currentT, y);\n+        switchesHandler.stepAccepted(stepStart, y);\n         if (switchesHandler.stop()) {\n           lastStep = true;\n         }\n \n         // provide the step data to the step handler\n-        interpolator.storeTime(currentT);\n+        interpolator.storeTime(stepStart);\n         handler.handleStep(interpolator, lastStep);\n \n-        if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+        if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n           // some switching function has triggered changes that\n           // invalidate the derivatives, we need to recompute them\n           firstStepAlreadyComputed = false;\n           // after a rejected step neither order nor stepsize\n           // should increase\n           targetIter = Math.min(optimalIter, k);\n-          hNew = Math.min(Math.abs(h), optimalStep[targetIter]);\n+          hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]);\n         } else {\n           // stepsize control\n           if (optimalIter <= k) {\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n     }\n     interpolator.storeTime(t0);\n \n-    double  currentT  = t0;\n+    stepStart  = t0;\n     double  hNew      = 0;\n     boolean firstTime = true;\n     boolean lastStep;\n \n       interpolator.shift();\n \n-      double h     = 0;\n       double error = 0;\n       for (boolean loop = true; loop;) {\n \n         if (firstTime || !fsal) {\n           // first stage\n-          equations.computeDerivatives(currentT, y, yDotK[0]);\n+          equations.computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n             }\n           }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n-                                currentT, y, yDotK[0], yTmp, yDotK[1]);\n+                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n \n-        h = hNew;\n+        stepSize = hNew;\n \n         // step adjustment near bounds\n-        if ((forward && (currentT + h > t))\n-            || ((! forward) && (currentT + h < t))) {\n-          h = t - currentT;\n+        if ((forward && (stepStart + stepSize > t))\n+            || ((! forward) && (stepStart + stepSize < t))) {\n+          stepSize = t - stepStart;\n         }\n \n         // next stages\n             for (int l = 1; l < k; ++l) {\n               sum += a[k-1][l] * yDotK[l][j];\n             }\n-            yTmp[j] = y[j] + h * sum;\n+            yTmp[j] = y[j] + stepSize * sum;\n           }\n \n-          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n \n         }\n \n           for (int l = 1; l < stages; ++l) {\n             sum    += b[l] * yDotK[l][j];\n           }\n-          yTmp[j] = y[j] + h * sum;\n+          yTmp[j] = y[j] + stepSize * sum;\n         }\n \n         // estimate the error at the end of the step\n-        error = estimateError(yDotK, y, yTmp, h);\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n         if (error <= 1.0) {\n \n           // Switching functions handling\n-          interpolator.storeTime(currentT + h);\n+          interpolator.storeTime(stepStart + stepSize);\n           if (switchesHandler.evaluateStep(interpolator)) {\n             // reject the step to match exactly the next switch time\n-            hNew = switchesHandler.getEventTime() - currentT;\n+            hNew = switchesHandler.getEventTime() - stepStart;\n           } else {\n             // accept the step\n             loop = false;\n           double factor = Math.min(maxGrowth,\n                                    Math.max(minReduction,\n                                             safety * Math.pow(error, exp)));\n-          hNew = filterStep(h * factor, false);\n+          hNew = filterStep(stepSize * factor, false);\n         }\n \n       }\n \n       // the step has been accepted\n-      currentT += h;\n+      stepStart += stepSize;\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      switchesHandler.stepAccepted(currentT, y);\n+      switchesHandler.stepAccepted(stepStart, y);\n       if (switchesHandler.stop()) {\n         lastStep = true;\n       } else {\n-        lastStep = forward ? (currentT >= t) : (currentT <= t);\n+        lastStep = forward ? (stepStart >= t) : (stepStart <= t);\n       }\n \n       // provide the step data to the step handler\n-      interpolator.storeTime(currentT);\n+      interpolator.storeTime(stepStart);\n       handler.handleStep(interpolator, lastStep);\n \n       if (fsal) {\n         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n       }\n \n-      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+      if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n         // some switching function has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n-        equations.computeDerivatives(currentT, y, yDotK[0]);\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n       }\n \n       if (! lastStep) {\n         double  factor     = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n-        double  scaledH    = h * factor;\n-        double  nextT      = currentT + scaledH;\n+        double  scaledH    = stepSize * factor;\n+        double  nextT      = stepStart + scaledH;\n         boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n         hNew = filterStep(scaledH, nextIsLast);\n       }\n \n     } while (! lastStep);\n+\n+    resetInternalState();\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n     this.step       = step;\n     handler         = DummyStepHandler.getInstance();\n     switchesHandler = new SwitchingFunctionsHandler();\n+    resetInternalState();\n   }\n \n   /** Get the name of the method.\n     interpolator.storeTime(t0);\n \n     // recompute the step\n-    double  currentT  = t0;\n     long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));\n-    double  h         = (t - t0) / nbStep;\n     boolean firstTime = true;\n     boolean lastStep  = false;\n+    stepStart = t0;\n+    stepSize  = (t - t0) / nbStep;\n     handler.reset();\n     for (long i = 0; ! lastStep; ++i) {\n \n \n         if (firstTime || !fsal) {\n           // first stage\n-          equations.computeDerivatives(currentT, y, yDotK[0]);\n+          equations.computeDerivatives(stepStart, y, yDotK[0]);\n           firstTime = false;\n         }\n \n             for (int l = 1; l < k; ++l) {\n               sum += a[k-1][l] * yDotK[l][j];\n             }\n-            yTmp[j] = y[j] + h * sum;\n+            yTmp[j] = y[j] + stepSize * sum;\n           }\n \n-          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n \n         }\n \n           for (int l = 1; l < stages; ++l) {\n             sum    += b[l] * yDotK[l][j];\n           }\n-          yTmp[j] = y[j] + h * sum;\n+          yTmp[j] = y[j] + stepSize * sum;\n         }\n \n         // Switching functions handling\n-        interpolator.storeTime(currentT + h);\n+        interpolator.storeTime(stepStart + stepSize);\n         if (switchesHandler.evaluateStep(interpolator)) {\n           needUpdate = true;\n-          h = switchesHandler.getEventTime() - currentT;\n+          stepSize = switchesHandler.getEventTime() - stepStart;\n         } else {\n           loop = false;\n         }\n       }\n \n       // the step has been accepted\n-      currentT += h;\n+      stepStart += stepSize;\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      switchesHandler.stepAccepted(currentT, y);\n+      switchesHandler.stepAccepted(stepStart, y);\n       if (switchesHandler.stop()) {\n         lastStep = true;\n       } else {\n       }\n \n       // provide the step data to the step handler\n-      interpolator.storeTime(currentT);\n+      interpolator.storeTime(stepStart);\n       handler.handleStep(interpolator, lastStep);\n \n       if (fsal) {\n         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n       }\n \n-      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+      if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n         // some switching function has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n-        equations.computeDerivatives(currentT, y, yDotK[0]);\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n       }\n \n       if (needUpdate) {\n         // a switching function has changed the step\n         // we need to recompute stepsize\n-        nbStep = Math.max(1l, Math.abs(Math.round((t - currentT) / step)));\n-        h = (t - currentT) / nbStep;\n+        nbStep = Math.max(1l, Math.abs(Math.round((t - stepStart) / step)));\n+        stepSize = (t - stepStart) / nbStep;\n         i = -1;\n       }\n \n     }\n \n+    resetInternalState();\n+\n+  }\n+\n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  public double getCurrentStepsize() {\n+    return stepSize;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  private void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Double.NaN;\n   }\n \n   /** Indicator for <i>fsal</i> methods. */\n   /** Switching functions handler. */\n   protected SwitchingFunctionsHandler switchesHandler;\n \n+  /** Current step start time. */\n+  private double stepStart;\n+\n+  /** Current stepsize. */\n+  private double stepSize;\n+\n }", "timestamp": 1191171530, "metainfo": ""}