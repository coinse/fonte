{"sha": "65c7c9697457b326f149555166f0e2aae192a609", "log": "Fixed bugs in \"BrentOptimizer\". Renamed \"BrentMinimizerTest\" to \"BrentOptimizerTest\". Modified \"MultiStartUnivariateRealOptimizerTest\" because it uses \"BrentOptimizer\" as the underlying optimizer, and so was affected by the changes.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n /**\n  * Implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n- * univariate functions.\n+ * univariate functions. This implementation is an adaptation partly\n+ * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n-\n     /**\n      * Golden section.\n      */\n     public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                            final double min, final double max, final double startValue)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goalType, min, max);\n+        clearResult();\n+        return localMin(f, goalType, min, startValue, max,\n+                        getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n \n     /** {@inheritDoc} */\n     public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                            final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        clearResult();\n-        return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n+        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n     }\n \n     /**\n      * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n      * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n      * machine precision. {@code t} should be positive.\n-     * @param f the function to solve\n+     * @param f the function to solve.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n-     * @param a Lower bound of the interval\n-     * @param b Higher bound of the interval\n-     * @param eps Relative accuracy\n-     * @param t Absolute accuracy\n-     * @return the point at which the function is minimal.\n+     * or {@link GoalType#MINIMIZE}.\n+     * @param lo Lower bound of the interval.\n+     * @param mid Point inside the interval {@code [lo, hi]}.\n+     * @param hi Higher bound of the interval.\n+     * @param eps Relative accuracy.\n+     * @param t Absolute accuracy.\n+     * @return the optimum point.\n      * @throws MaxIterationsExceededException if the maximum iteration count\n      * is exceeded.\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n      */\n-    private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n-                            double a, double b, final double eps, final double t)\n+    private double localMin(UnivariateRealFunction f,\n+                            GoalType goalType,\n+                            double lo, double mid, double hi,\n+                            double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        double x = a + GOLDEN_SECTION * (b - a);\n+        if (eps <= 0) {\n+            throw new NotStrictlyPositiveException(eps);\n+        }\n+        if (t <= 0) {\n+            throw new NotStrictlyPositiveException(t);\n+        }\n+        double a, b;\n+        if (lo < hi) {\n+            a = lo;\n+            b = hi;\n+        } else {\n+            a = hi;\n+            b = lo;\n+        }\n+\n+        double x = mid;\n         double v = x;\n         double w = x;\n         double e = 0;\n         int count = 0;\n         while (count < maximalIterationCount) {\n             double m = 0.5 * (a + b);\n-            double tol = eps * Math.abs(x) + t;\n-            double t2 = 2 * tol;\n+            final double tol1 = eps * Math.abs(x) + t;\n+            final double tol2 = 2 * tol1;\n \n             // Check stopping criterion.\n-            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n+            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n                 double d = 0;\n                 double u = 0;\n \n-                if (Math.abs(e) > tol) { // Fit parabola.\n+                if (Math.abs(e) > tol1) { // Fit parabola.\n                     r = (x - w) * (fx - fv);\n                     q = (x - v) * (fx - fw);\n                     p = (x - v) * q - (x - w) * r;\n \n                     r = e;\n                     e = d;\n-                }\n-\n-                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n-                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n-                    d = p / q;\n+\n+                    if (p > q * (a - x)\n+                        && p < q * (b - x)\n+                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n+                        // Parabolic interpolation step.\n+                        d = p / q;\n+                        u = x + d;\n+\n+                        // f must not be evaluated too close to a or b.\n+                        if (u - a < tol2\n+                            || b - u < tol2) {\n+                            if (x <= m) {\n+                                d = tol1;\n+                            } else {\n+                                d = -tol1;\n+                            }\n+                        }\n+                    } else {\n+                        // Golden section step.\n+                        if (x < m) {\n+                            e = b - x;\n+                        } else {\n+                            e = a - x;\n+                        }\n+                        d = GOLDEN_SECTION * e;\n+                    }\n+                } else {\n+                    // Golden section step.\n+                    if (x < m) {\n+                        e = b - x;\n+                    } else {\n+                        e = a - x;\n+                    }\n+                    d = GOLDEN_SECTION * e;\n+                }\n+\n+                // Update by at least \"tol1\".\n+                if (Math.abs(d) < tol1) {\n+                    if (d >= 0) {\n+                        u = x + tol1;\n+                    } else {\n+                        u = x - tol1;\n+                    }\n+                } else {\n                     u = x + d;\n-\n-                    // f must not be evaluated too close to a or b.\n-                    if (((u - a) < t2) || ((b - u) < t2)) {\n-                        d = (x < m) ? tol : -tol;\n-                    }\n-                } else { // Golden section step.\n-                    e = ((x < m) ? b : a) - x;\n-                    d = GOLDEN_SECTION * e;\n-                }\n-\n-                // f must not be evaluated too close to a or b.\n-                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n+                }\n+\n                 double fu = computeObjectiveValue(f, u);\n                 if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                     } else {\n                         b = u;\n                     }\n-                    if ((fu <= fw) || (w == x)) {\n+                    if (fu <= fw\n+                        || w == x) {\n                         v = w;\n                         fv = fw;\n                         w = u;\n                         fw = fu;\n-                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n+                    } else if (fu <= fv\n+                               || v == x\n+                               || v == w) {\n                         v = u;\n                         fv = fu;\n                     }\n                 setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                 return x;\n             }\n-\n             ++count;\n         }\n-\n         throw new MaxIterationsExceededException(maximalIterationCount);\n-\n-    }\n-\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n- * Auxillary class for testing solvers.\n+ * Auxiliary class for testing solvers.\n  *\n  * @version $Revision$ $Date$\n  */\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n             assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n             assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n         }\n-        assertTrue(minimizer.getEvaluations() > 2900);\n-        assertTrue(minimizer.getEvaluations() < 3100);\n+        assertTrue(minimizer.getEvaluations() > 1500);\n+        assertTrue(minimizer.getEvaluations() < 1700);\n     }\n \n     @Test\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer();\n+        underlying.setRelativeAccuracy(1e-15);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n-        g.setSeed(4312000053l);\n+        g.setSeed(4312000053L);\n         MultiStartUnivariateRealOptimizer minimizer =\n             new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n         minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n             fail(\"wrong exception caught\");\n         }\n \n-        assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);\n-        assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);\n-        assertEquals(-0.04433426954946, minimizer.getFunctionValue(), 1.0e-13);\n+        double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+        assertEquals(-0.27195612525275803, result, 1.0e-13);\n+        assertEquals(-0.27195612525275803, minimizer.getResult(), 1.0e-13);\n+        assertEquals(-0.04433426954946637, minimizer.getFunctionValue(), 1.0e-13);\n \n         double[] optima = minimizer.getOptima();\n         double[] optimaValues = minimizer.getOptimaValues();\n             assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n         }\n \n-        assertTrue(minimizer.getEvaluations()    >= 510);\n-        assertTrue(minimizer.getEvaluations()    <= 530);\n-        assertTrue(minimizer.getIterationCount() >= 150);\n-        assertTrue(minimizer.getIterationCount() <= 170);\n-\n+        assertTrue(minimizer.getEvaluations()    >= 300);\n+        assertTrue(minimizer.getEvaluations()    <= 420);\n+        assertTrue(minimizer.getIterationCount() >= 100);\n+        assertTrue(minimizer.getIterationCount() <= 140);\n     }\n-\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.SincFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+import org.junit.Test;\n+\n+/**\n+ * @version $Revision: 811685 $ $Date: 2009-09-05 19:36:48 +0200 (Sat, 05 Sep 2009) $\n+ */\n+public final class BrentOptimizerTest {\n+\n+    @Test\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        minimizer.setMaxEvaluations(200);\n+        assertEquals(200, minimizer.getMaxEvaluations());\n+        try {\n+            minimizer.getResult();\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertTrue(minimizer.getEvaluations()    <= 100);\n+        assertTrue(minimizer.getEvaluations()    >=  30);\n+        minimizer.setMaxEvaluations(50);\n+        try {\n+            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n+            fail(\"an exception should have been thrown\");\n+        } catch (FunctionEvaluationException fee) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    @Test\n+    public void testQuinticMin() throws MathException {\n+        // The function has local minima at -0.27195613 and 0.82221643.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n+        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+\n+        // search in a large interval\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+    }\n+\n+    @Test\n+    public void testQuinticMinPythonComparison() throws MathException {\n+        // The function has local minima at -0.27195613 and 0.82221643.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        minimizer.setRelativeAccuracy(1e-12);\n+        minimizer.setAbsoluteAccuracy(1e-11);\n+\n+        double result;\n+        int nIter, nEval;\n+\n+        result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2, -0.25);\n+        nIter = minimizer.getIterationCount();\n+        nEval = minimizer.getEvaluations();\n+        // XXX Python: -0.27195612805911351 (instead of -0.2719561279558559).\n+        assertEquals(-0.2719561279558559, result, 1e-12);\n+        // XXX Python: 15 (instead of 18).\n+        assertEquals(18, nEval);\n+        // XXX Python: 11 (instead of 17).\n+        assertEquals(17, nIter);\n+\n+        result = minimizer.optimize(f, GoalType.MINIMIZE, 0.7, 0.9, 0.8);\n+        nIter = minimizer.getIterationCount();\n+        nEval = minimizer.getEvaluations();\n+        // XXX Python: 0.82221643488363705 (instead of 0.8222164326561908).\n+        assertEquals(0.8222164326561908, result, 1e-12);\n+        // XXX Python: 25 (instead of 43).\n+        assertEquals(43, nEval);\n+        // XXX Python: 21 (instead of 24).\n+        assertEquals(24, nIter);\n+    }\n+\n+    @Test\n+    public void testQuinticMax() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has a local maximum at 0.27195613.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(0.27195613, minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3), 1.0e-8);\n+        minimizer.setMaximalIterationCount(20);\n+        try {\n+            minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n+            fail(\"an exception should have been thrown\");\n+        } catch (MaxIterationsExceededException miee) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    @Test\n+    public void testMinEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealOptimizer solver = new BrentOptimizer();\n+\n+        // endpoint is minimum\n+        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);\n+        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+\n+        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);\n+        assertEquals(3 * Math.PI / 2, result, 80 * solver.getAbsoluteAccuracy());\n+    }\n+}", "timestamp": 1280146665, "metainfo": ""}