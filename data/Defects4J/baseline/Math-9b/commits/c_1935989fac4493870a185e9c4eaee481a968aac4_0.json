{"sha": "1935989fac4493870a185e9c4eaee481a968aac4", "log": "Widened the scope of tests for transform.FastCosineTransformer (MATH-677).  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.analysis.*;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.function.Sinc;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n \n /**\n  * Test case for fast cosine transformer.\n  * <p>\n- * FCT algorithm is exact, the small tolerance number is used only\n- * to account for round-off errors.\n+ * FCT algorithm is exact, the small tolerance number is used only to account\n+ * for round-off errors.\n  *\n  * @version $Id$\n  */\n-public final class FastCosineTransformerTest {\n+@RunWith(value = Parameterized.class)\n+public final class FastCosineTransformerTest\n+    extends RealTransformerAbstractTest {\n+\n+    private final boolean standard;\n+\n+    private final int[] invalidDataSize;\n+\n+    private final double[] relativeTolerance;\n+\n+    private final int[] validDataSize;\n+\n+    public FastCosineTransformerTest(final boolean standard) {\n+        this.standard = standard;\n+        this.validDataSize = new int[] {\n+            2, 3, 5, 9, 17, 33, 65, 129\n+        };\n+        this.invalidDataSize = new int[] {\n+            128\n+        };\n+        this.relativeTolerance = new double[] {\n+            1E-15, 1E-15, 1E-14, 1E-13, 1E-13, 1E-12, 1E-11, 1E-10\n+        };\n+    }\n \n     /**\n-     * Test of transformer for the ad hoc data.\n+     * Returns an array containing {@code true, false} in order to check both\n+     * standard and orthogonal DCTs.\n+     *\n+     * @return an array of parameters for this parameterized test\n      */\n+    @Parameters\n+    public static Collection<Object[]> data() {\n+        final Object[][] data = new Boolean[][] {\n+            {\n+                Boolean.TRUE\n+            }, {\n+                Boolean.FALSE\n+            }\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    @Override\n+    RealTransformer createRealTransformer() {\n+        if (standard) {\n+            return FastCosineTransformer.create();\n+        } else {\n+            return FastCosineTransformer.createOrthogonal();\n+        }\n+    }\n+\n+    @Override\n+    int getInvalidDataSize(final int i) {\n+        return invalidDataSize[i];\n+    }\n+\n+    @Override\n+    int getNumberOfInvalidDataSizes() {\n+        return invalidDataSize.length;\n+    }\n+\n+    @Override\n+    int getNumberOfValidDataSizes() {\n+        return validDataSize.length;\n+    }\n+\n+    @Override\n+    double getRelativeTolerance(final int i) {\n+        return relativeTolerance[i];\n+    }\n+\n+    @Override\n+    int getValidDataSize(final int i) {\n+        return validDataSize[i];\n+    }\n+\n+    @Override\n+    UnivariateFunction getValidFunction() {\n+        return new Sinc();\n+    }\n+\n+    @Override\n+    double getValidLowerBound() {\n+        return 0.0;\n+    }\n+\n+    @Override\n+    double getValidUpperBound() {\n+        return FastMath.PI;\n+    }\n+\n+    @Override\n+    double[] transform(final double[] x, final boolean forward) {\n+        final int n = x.length;\n+        final double[] y = new double[n];\n+        final double[] cos = new double[2 * (n - 1)];\n+        for (int i = 0; i < cos.length; i++) {\n+            cos[i] = FastMath.cos(FastMath.PI * i / (n - 1.0));\n+        }\n+        int sgn = 1;\n+        for (int j = 0; j < n; j++) {\n+            double yj = 0.5 * (x[0] + sgn * x[n - 1]);\n+            for (int i = 1; i < n - 1; i++) {\n+                yj += x[i] * cos[(i * j) % cos.length];\n+            }\n+            y[j] = yj;\n+            sgn *= -1;\n+        }\n+        final double s;\n+        if (forward) {\n+            s = standard ? 1.0 : FastMath.sqrt(2.0 / (n - 1.0));\n+        } else {\n+            s = standard ? 2.0 / (n - 1.0) : FastMath.sqrt(2.0 / (n - 1.0));\n+        }\n+        TransformUtils.scaleArray(y, s);\n+        return y;\n+    }\n+\n+    /*\n+     * Additional tests.\n+     */\n+\n+    /** Test of transformer for the ad hoc data. */\n     @Test\n     public void testAdHocData() {\n         FastCosineTransformer transformer = FastCosineTransformer.create();\n         double result[], tolerance = 1E-12;\n \n-        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };\n-        double y[] = { 172.0, -105.096569476353, 27.3137084989848,\n-                      -12.9593152353742, 8.0, -5.78585076868676,\n-                       4.68629150101524, -4.15826451958632, 4.0 };\n+        double x[] = {\n+            0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0\n+        };\n+        double y[] =\n+            {\n+                172.0, -105.096569476353, 27.3137084989848, -12.9593152353742,\n+                8.0, -5.78585076868676, 4.68629150101524, -4.15826451958632,\n+                4.0\n+            };\n \n         result = transformer.transform(x);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n-        TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));\n+        TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1)));\n \n         transformer = FastCosineTransformer.createOrthogonal();\n         result = transformer.transform(y);\n         }\n     }\n \n-    /**\n-     * Test of transformer for the sine function.\n-     */\n+    /** Test of parameters for the transformer. */\n     @Test\n-    public void testSinFunction() {\n-        UnivariateFunction f = new SinFunction();\n-        FastCosineTransformer transformer = FastCosineTransformer.create();\n-        double min, max, result[], tolerance = 1E-12; int N = 9;\n-\n-        double expected[] = { 0.0, 3.26197262739567, 0.0,\n-                             -2.17958042710327, 0.0, -0.648846697642915,\n-                              0.0, -0.433545502649478, 0.0 };\n-        min = 0.0; max = 2.0 * FastMath.PI * N / (N-1);\n-        result = transformer.transform(f, min, max, N);\n-        for (int i = 0; i < N; i++) {\n-            Assert.assertEquals(expected[i], result[i], tolerance);\n-        }\n-\n-        min = -FastMath.PI; max = FastMath.PI * (N+1) / (N-1);\n-        result = transformer.transform(f, min, max, N);\n-        for (int i = 0; i < N; i++) {\n-            Assert.assertEquals(-expected[i], result[i], tolerance);\n-        }\n-    }\n-\n-    /**\n-     * Test of parameters for the transformer.\n-     */\n-    @Test\n-    public void testParameters() throws Exception {\n+    public void testParameters()\n+        throws Exception {\n         UnivariateFunction f = new SinFunction();\n         FastCosineTransformer transformer = FastCosineTransformer.create();\n \n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 1);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert\n+                .fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n             transformer.transform(f, -1, 1, 64);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n+            Assert\n+                .fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n+\n+    /** Test of transformer for the sine function. */\n+    @Test\n+    public void testSinFunction() {\n+        UnivariateFunction f = new SinFunction();\n+        FastCosineTransformer transformer = FastCosineTransformer.create();\n+        double min, max, result[], tolerance = 1E-12;\n+        int N = 9;\n+\n+        double expected[] =\n+            {\n+                0.0, 3.26197262739567, 0.0, -2.17958042710327, 0.0,\n+                -0.648846697642915, 0.0, -0.433545502649478, 0.0\n+            };\n+        min = 0.0;\n+        max = 2.0 * FastMath.PI * N / (N - 1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            Assert.assertEquals(expected[i], result[i], tolerance);\n+        }\n+\n+        min = -FastMath.PI;\n+        max = FastMath.PI * (N + 1) / (N - 1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            Assert.assertEquals(-expected[i], result[i], tolerance);\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/transform/RealTransformerAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Abstract test for classes implementing the {@link RealTransformer} interface.\n+ * This abstract test handles the automatic generation of random data of various\n+ * sizes. For each generated data array, actual values (returned by the\n+ * transformer to be tested) are compared to expected values, returned by the\n+ * {@link #transform(double[], boolean)} (to be implemented by the user: a naive\n+ * method may be used). Methods are also provided to test that invalid parameters\n+ * throw the expected exceptions.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class RealTransformerAbstractTest {\n+\n+    /** The common seed of all random number generators used in this test. */\n+    private final static long SEED = 20110119L;\n+\n+    /**\n+     * Returns a random array of doubles. Random generator always uses the same\n+     * seed.\n+     *\n+     * @param n the size of the array to be returned\n+     * @return a random array of specified size\n+     */\n+    static double[] createRealData(final int n) {\n+        final Random random = new Random(SEED);\n+        final double[] data = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            data[i] = 2.0 * random.nextDouble() - 1.0;\n+        }\n+        return data;\n+    }\n+\n+    /**\n+     * Returns a new instance of the {@link RealTransformer} to be tested.\n+     *\n+     * @return a the transformer to be tested\n+     */\n+    abstract RealTransformer createRealTransformer();\n+\n+    /**\n+     * Returns an invalid data size. Transforms with this data size should\n+     * trigger a {@link MathIllegalArgumentException}.\n+     *\n+     * @param i the index of the invalid data size ({@code 0 <= i <}\n+     * {@link #getNumberOfInvalidDataSizes()}\n+     * @return an invalid data size\n+     */\n+    abstract int getInvalidDataSize(int i);\n+\n+    /**\n+     * Returns the total number of invalid data sizes to be tested. If data\n+     * array of any\n+     * size can be handled by the {@link RealTransformer} to be tested, this\n+     * method should return {@code 0}.\n+     *\n+     * @return the total number of invalid data sizes\n+     */\n+    abstract int getNumberOfInvalidDataSizes();\n+\n+    /**\n+     * Returns the total number of valid data sizes to be tested.\n+     *\n+     * @return the total number of valid data sizes\n+     */\n+    abstract int getNumberOfValidDataSizes();\n+\n+    /**\n+     * Returns the expected relative accuracy for data arrays of size\n+     * {@code getValidDataSize(i)}.\n+     *\n+     * @param i the index of the valid data size\n+     * @return the expected relative accuracy\n+     */\n+    abstract double getRelativeTolerance(int i);\n+\n+    /**\n+     * Returns a valid data size. This method allows for data arrays of various\n+     * sizes to be automatically tested (by allowing multiple values of the\n+     * specified index).\n+     *\n+     * @param i the index of the valid data size ({@code 0 <= i <}\n+     * {@link #getNumberOfValidDataSizes()}\n+     * @return a valid data size\n+     */\n+    abstract int getValidDataSize(int i);\n+\n+    /**\n+     * Returns a function for the accuracy check of\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * and\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}.\n+     * This function should be valid. In other words, none of the above methods\n+     * should throw an exception when passed this function.\n+     *\n+     * @return a valid function\n+     */\n+    abstract UnivariateFunction getValidFunction();\n+\n+    /**\n+     * Returns a sampling lower bound for the accuracy check of\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * and\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}.\n+     * This lower bound should be valid. In other words, none of the above\n+     * methods should throw an exception when passed this bound.\n+     *\n+     * @return a valid lower bound\n+     */\n+    abstract double getValidLowerBound();\n+\n+    /**\n+     * Returns a sampling upper bound for the accuracy check of\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * and\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}.\n+     * This upper bound should be valid. In other words, none of the above\n+     * methods should throw an exception when passed this bound.\n+     *\n+     * @return a valid bound\n+     */\n+    abstract double getValidUpperBound();\n+\n+    /**\n+     * Returns the expected transform of the specified real data array.\n+     *\n+     * @param x the real data array to be transformed\n+     * @param forward {@code true} (resp. {@code false}) if the forward (resp.\n+     * inverse) transform is to be performed\n+     * @return the expected transform\n+     */\n+    abstract double[] transform(double[] x, boolean forward);\n+\n+    /*\n+     * Check of preconditions.\n+     */\n+\n+    /**\n+     * {@link RealTransformer#transform(double[])} should throw a\n+     * {@link MathIllegalArgumentException} if data size is invalid.\n+     */\n+    @Test\n+    public void testTransformRealInvalidDataSize() {\n+        final RealTransformer transformer = createRealTransformer();\n+        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n+            final int n = getInvalidDataSize(i);\n+            try {\n+                transformer.transform(createRealData(n));\n+                Assert.fail(Integer.toString(n));\n+            } catch (MathIllegalArgumentException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link MathIllegalArgumentException} if number of samples\n+     * is invalid.\n+     */\n+    @Test\n+    public void testTransformFunctionInvalidDataSize() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n+            final int n = getInvalidDataSize(i);\n+            try {\n+                transformer.transform(f, a, b, n);\n+                Assert.fail(Integer.toString(n));\n+            } catch (MathIllegalArgumentException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link NotStrictlyPositiveException} if number of samples\n+     * is not strictly positive.\n+     */\n+    @Test\n+    public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            try {\n+                transformer.transform(f, a, b, -n);\n+                Assert.fail(Integer.toString(-n));\n+            } catch (NotStrictlyPositiveException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link NumberIsTooLargeException} if sampling bounds are\n+     * not correctly ordered.\n+     */\n+    @Test\n+    public void testTransformFunctionInvalidBounds() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            try {\n+                transformer.transform(f, b, a, n);\n+                Assert.fail(Double.toString(b) + \", \" + Double.toString(a));\n+            } catch (NumberIsTooLargeException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#inverseTransform(double[])} should throw a\n+     * {@link MathIllegalArgumentException} if data size is invalid.\n+     */\n+    @Test\n+    public void testInverseTransformRealInvalidDataSize() {\n+        final RealTransformer transformer = createRealTransformer();\n+        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n+            final int n = getInvalidDataSize(i);\n+            try {\n+                transformer.inverseTransform(createRealData(n));\n+                Assert.fail(Integer.toString(n));\n+            } catch (MathIllegalArgumentException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link MathIllegalArgumentException} if number of samples\n+     * is invalid.\n+     */\n+    @Test\n+    public void testInverseTransformFunctionInvalidDataSize() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n+            final int n = getInvalidDataSize(i);\n+            try {\n+                transformer.inverseTransform(f, a, b, n);\n+                Assert.fail(Integer.toString(n));\n+            } catch (MathIllegalArgumentException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link NotStrictlyPositiveException} if number of samples\n+     * is not strictly positive.\n+     */\n+    @Test\n+    public void\n+        testInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            try {\n+                transformer.inverseTransform(f, a, b, -n);\n+                Assert.fail(Integer.toString(-n));\n+            } catch (NotStrictlyPositiveException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n+     * should throw a {@link NumberIsTooLargeException} if sampling bounds are\n+     * not correctly ordered.\n+     */\n+    @Test\n+    public void testInverseTransformFunctionInvalidBounds() {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            try {\n+                transformer.inverseTransform(f, b, a, n);\n+                Assert.fail(Double.toString(b) + \", \" + Double.toString(a));\n+            } catch (NumberIsTooLargeException e) {\n+                // Expected: do nothing\n+            }\n+        }\n+    }\n+\n+    /*\n+     * Accuracy tests of transform of valid data.\n+     */\n+\n+    /**\n+     * Accuracy check of {@link RealTransformer#transform(double[])}. For each\n+     * valid data size returned by\n+     * {@link #getValidDataSize(int) getValidDataSize(i)},\n+     * a random data array is generated with\n+     * {@link #createRealData(int) createRealData(i)}. The actual\n+     * transform is computed and compared to the expected transform, return by\n+     * {@link #transform(double[], boolean)}. Actual and expected values should\n+     * be equal to within the relative error returned by\n+     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n+     */\n+    @Test\n+    public void testTransformReal() {\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            final double tol = getRelativeTolerance(i);\n+            doTestTransformReal(n, tol, true);\n+        }\n+    }\n+\n+    /**\n+     * Accuracy check of\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}.\n+     * For each valid data size returned by\n+     * {@link #getValidDataSize(int) getValidDataSize(i)},\n+     * the {@link UnivariateFunction} returned by {@link #getValidFunction()} is\n+     * sampled. The actual transform is computed and compared to the expected\n+     * transform, return by {@link #transform(double[], boolean)}. Actual and\n+     * expected values should be equal to within the relative error returned by\n+     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n+     */\n+    @Test\n+    public void testTransformFunction() {\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            final double tol = getRelativeTolerance(i);\n+            doTestTransformFunction(n, tol, true);\n+        }\n+    }\n+\n+    /**\n+     * Accuracy check of {@link RealTransformer#inverseTransform(double[])}. For\n+     * each valid data size returned by\n+     * {@link #getValidDataSize(int) getValidDataSize(i)},\n+     * a random data array is generated with\n+     * {@link RealTransformerAbstractTest#createRealData(int)}. The actual\n+     * transform is computed and compared to the expected transform, return by\n+     * {@link #transform(double[], boolean)}. Actual and expected values should\n+     * be equal to within the relative error returned by\n+     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n+     */\n+    @Test\n+    public void testInverseTransformReal() {\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            final double tol = getRelativeTolerance(i);\n+            doTestTransformReal(n, tol, false);\n+        }\n+    }\n+\n+    /**\n+     * Accuracy check of\n+     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}.\n+     * For each valid data size returned by\n+     * {@link #getValidDataSize(int) getValidDataSize(i)},\n+     * the {@link UnivariateFunction} returned by {@link #getValidFunction()} is\n+     * sampled. The actual transform is computed and compared to the expected\n+     * transform, return by {@link #transform(double[], boolean)}. Actual and\n+     * expected values should be equal to within the relative error returned by\n+     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n+     */\n+    @Test\n+    public void testInverseTransformFunction() {\n+        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n+            final int n = getValidDataSize(i);\n+            final double tol = getRelativeTolerance(i);\n+            doTestTransformFunction(n, tol, false);\n+        }\n+    }\n+\n+    /*\n+     * The tests per se.\n+     */\n+\n+    private void doTestTransformReal(final int n, final double tol,\n+        final boolean forward) {\n+        final RealTransformer transformer = createRealTransformer();\n+        final double[] x = createRealData(n);\n+        final double[] expected = transform(x, forward);\n+        final double[] actual;\n+        if (forward) {\n+            actual = transformer.transform(x);\n+        } else {\n+            actual = transformer.inverseTransform(x);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double delta = tol * FastMath.abs(expected[i]);\n+            Assert.assertEquals(msg, expected[i], actual[i], delta);\n+        }\n+    }\n+\n+    private void doTestTransformFunction(final int n, final double tol,\n+        final boolean forward) {\n+        final RealTransformer transformer = createRealTransformer();\n+        final UnivariateFunction f = getValidFunction();\n+        final double a = getValidLowerBound();\n+        final double b = getValidUpperBound();\n+        final double[] x = createRealData(n);\n+        for (int i = 0; i < n; i++) {\n+            final double t = a + i * (b - a) / n;\n+            x[i] = f.value(t);\n+        }\n+        final double[] expected = transform(x, forward);\n+        final double[] actual;\n+        if (forward) {\n+            actual = transformer.transform(f, a, b, n);\n+        } else {\n+            actual = transformer.inverseTransform(f, a, b, n);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double delta = tol * FastMath.abs(expected[i]);\n+            Assert.assertEquals(msg, expected[i], actual[i], delta);\n+        }\n+    }\n+}", "timestamp": 1327093469, "metainfo": ""}