{"sha": "91e6ac584320681913de4a71a4e8d9f837e099b4", "log": "Updated tests and documentation for Kalman filter.  Patch provided by Thomas Neidhart.  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n+++ b/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.MatrixDimensionMismatchException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.junit.Test;\n \n /**\n- * Test for {@link KalmanFilter}.\n+ * Tests for {@link KalmanFilter}.\n  *\n  * @version $Id$\n  */\n public class KalmanFilterTest {\n+    \n+    @Test(expected=MatrixDimensionMismatchException.class)\n+    public void testTransitionMeasurementMatrixMismatch() {\n+        \n+        // A and H matrix do not match in dimensions\n+        \n+        // A = [ 1 ]\n+        RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });\n+        // no control input\n+        RealMatrix B = null;\n+        // H = [ 1 1 ]\n+        RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d, 1d });\n+        // Q = [ 0 ]\n+        RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });\n+        // R = [ 0 ]\n+        RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });\n+\n+        ProcessModel pm\n+            = new DefaultProcessModel(A, B, Q,\n+                                      new ArrayRealVector(new double[] { 0 }), null);\n+        MeasurementModel mm = new DefaultMeasurementModel(H, R);\n+        new KalmanFilter(pm, mm);\n+        Assert.fail(\"transition and measurement matrix should not be compatible\");\n+    }\n+\n+    @Test(expected=MatrixDimensionMismatchException.class)\n+    public void testTransitionControlMatrixMismatch() {\n+        \n+        // A and B matrix do not match in dimensions\n+        \n+        // A = [ 1 ]\n+        RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });\n+        // B = [ 1 1 ]\n+        RealMatrix B = new Array2DRowRealMatrix(new double[] { 1d, 1d });\n+        // H = [ 1 ]\n+        RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });\n+        // Q = [ 0 ]\n+        RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });\n+        // R = [ 0 ]\n+        RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });\n+\n+        ProcessModel pm\n+            = new DefaultProcessModel(A, B, Q,\n+                                      new ArrayRealVector(new double[] { 0 }), null);\n+        MeasurementModel mm = new DefaultMeasurementModel(H, R);\n+        new KalmanFilter(pm, mm);\n+        Assert.fail(\"transition and control matrix should not be compatible\");\n+    }\n+    \n     @Test\n     public void testConstant() {\n+        // simulates a simple process with a constant state and no control input\n+        \n         double constantValue = 10d;\n         double measurementNoise = 0.1d;\n         double processNoise = 1e-5d;\n \n             filter.correct(z);\n \n-            // state estimate should be larger than measurement noise\n+            // state estimate shouldn't be larger than measurement noise\n             double diff = Math.abs(constantValue - filter.getStateEstimation()[0]);\n             // System.out.println(diff);\n             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);\n                                               0.02d, 1e-6) < 0);\n     }\n \n+    @Test\n+    public void testConstantAcceleration() {\n+        // simulates a vehicle, accelerating at a constant rate (0.1 m/s)\n+\n+        // discrete time interval\n+        double dt = 0.1d;\n+        // position measurement noise (meter)\n+        double measurementNoise = 10d;\n+        // acceleration noise (meter/sec^2)\n+        double accelNoise = 0.2d;\n+\n+        // A = [ 1 dt ]\n+        //     [ 0  1 ]\n+        RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } });\n+\n+        // B = [ dt^2/2 ]\n+        //     [ dt     ]\n+        RealMatrix B = new Array2DRowRealMatrix(\n+                new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } });\n+\n+        // H = [ 1 0 ]\n+        RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });\n+\n+        // x = [ 0 0 ]\n+        RealVector x = new ArrayRealVector(new double[] { 0, 0 });\n+\n+        RealMatrix tmp = new Array2DRowRealMatrix(\n+                new double[][] { { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d },\n+                                 { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } });\n+\n+        // Q = [ dt^4/4 dt^3/2 ]\n+        //     [ dt^3/2 dt^2   ]\n+        RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2));\n+\n+        // P0 = [ 1 1 ]\n+        //      [ 1 1 ]\n+        RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });\n+\n+        // R = [ measurementNoise^2 ]\n+        RealMatrix R = new Array2DRowRealMatrix(\n+                new double[] { Math.pow(measurementNoise, 2) });\n+\n+        // constant control input, increase velocity by 0.1 m/s per cycle\n+        RealVector u = new ArrayRealVector(new double[] { 0.1d });\n+\n+        ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);\n+        MeasurementModel mm = new DefaultMeasurementModel(H, R);\n+        KalmanFilter filter = new KalmanFilter(pm, mm);\n+\n+        Assert.assertEquals(1, filter.getMeasurementDimension());\n+        Assert.assertEquals(2, filter.getStateDimension());\n+\n+        assertMatrixEquals(P0.getData(), filter.getErrorCovariance());\n+\n+        // check the initial state\n+        double[] expectedInitialState = new double[] { 0.0, 0.0 };\n+        assertVectorEquals(expectedInitialState, filter.getStateEstimation());\n+\n+        RandomGenerator rand = new JDKRandomGenerator();\n+\n+        RealVector tmpPNoise = new ArrayRealVector(\n+                new double[] { Math.pow(dt, 2d) / 2d, dt });\n+\n+        RealVector mNoise = new ArrayRealVector(1);\n+\n+        // iterate 60 steps\n+        for (int i = 0; i < 60; i++) {\n+            filter.predict(u);\n+\n+            // Simulate the process\n+            RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());\n+\n+            // x = A * x + B * u + pNoise\n+            x = A.operate(x).add(B.operate(u)).add(pNoise);\n+\n+            // Simulate the measurement\n+            mNoise.setEntry(0, measurementNoise * rand.nextGaussian());\n+\n+            // z = H * x + m_noise\n+            RealVector z = H.operate(x).add(mNoise);\n+\n+            filter.correct(z);\n+\n+            // state estimate shouldn't be larger than the measurement noise\n+            double diff = Math.abs(x.getEntry(0) - filter.getStateEstimation()[0]);\n+            Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);\n+        }\n+\n+        // error covariance of the velocity should be already very low (< 0.1)\n+        Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1],\n+                                              0.1d, 1e-6) < 0);\n+    }\n+    \n     private void assertVectorEquals(double[] expected, double[] result) {\n         Assert.assertEquals(\"Wrong number of rows.\", expected.length,\n                             result.length);\n         for (int i = 0; i < expected.length; i++) {\n             Assert.assertEquals(\"Wrong value at position [\" + i + \"]\",\n-                                expected[i], result[i], 1.0e-15);\n+                                expected[i], result[i], 1.0e-6);\n         }\n     }\n \n                                 result[i].length);\n             for (int j = 0; j < expected[i].length; j++) {\n                 Assert.assertEquals(\"Wrong value at position [\" + i + \",\" + j\n-                                    + \"]\", expected[i][j], result[i][j], 1.0e-15);\n+                                    + \"]\", expected[i][j], result[i][j], 1.0e-6);\n             }\n         }\n     }", "timestamp": 1322595412, "metainfo": ""}