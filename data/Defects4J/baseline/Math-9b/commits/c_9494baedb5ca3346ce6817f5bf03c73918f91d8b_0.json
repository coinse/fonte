{"sha": "9494baedb5ca3346ce6817f5bf03c73918f91d8b", "log": "prevent too small (sometimes exactly 0) steps to occur when an event is within convergence tolerance to the step end  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n                 interpolatorTmp.shift();\n                 interpolatorTmp.storeTime(stepEnd);\n                 if (manager.evaluateStep(interpolatorTmp)) {\n-                    // reject the step to match exactly the next switch time\n-                    hNew = manager.getEventTime() - stepStart;\n+                    final double dt = manager.getEventTime() - stepStart;\n+                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                        // rejecting the step would lead to a too small next step, we accept it\n+                        loop = false;\n+                    } else {\n+                        // reject the step to match exactly the next switch time\n+                        hNew = dt;\n+                    }\n                 } else {\n                     // accept the step\n                     scaled    = correctedScaled;\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n           // discrete events handling\n           interpolator.storeTime(stepStart + stepSize);\n           if (manager.evaluateStep(interpolator)) {\n-            // reject the step to match exactly the next switch time\n-            hNew = manager.getEventTime() - stepStart;\n+              final double dt = manager.getEventTime() - stepStart;\n+              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                  // rejecting the step would lead to a too small next step, we accept it\n+                  loop = false;\n+              } else {\n+                  // reject the step to match exactly the next switch time\n+                  hNew = dt;\n+              }\n           } else {\n             // accept the step\n             loop = false;\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n           if (!reject) {\n             interpolator.storeTime(stepStart + stepSize);\n             if (eventsHandlersManager.evaluateStep(interpolator)) {\n-              reject = true;\n-              hNew = Math.abs(eventsHandlersManager.getEventTime() - stepStart);\n+                final double dt = eventsHandlersManager.getEventTime() - stepStart;\n+                if (Math.abs(dt) > Math.ulp(stepStart)) {\n+                    // reject the step to match exactly the next switch time\n+                    hNew = Math.abs(dt);\n+                    reject = true;\n+                }\n             }\n           }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n         // discrete events handling\n         interpolator.storeTime(stepStart + stepSize);\n         if (manager.evaluateStep(interpolator)) {\n-          stepSize = manager.getEventTime() - stepStart;\n+            final double dt = manager.getEventTime() - stepStart;\n+            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                // rejecting the step would lead to a too small next step, we accept it\n+                loop = false;\n+            } else {\n+                // reject the step to match exactly the next switch time\n+                stepSize = dt;\n+            }\n         } else {\n           loop = false;\n         }", "timestamp": 1244670273, "metainfo": ""}