{"sha": "6393b4fdb83412026cc950c6f1b1eaa850213e7d", "log": "Added a \"rectangular\" Cholesky decomposition for positive semidefinite matrices.  JIRA: MATH-541  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RectangularCholeskyDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate a\n+ * rectangular variation of Cholesky decomposition of a real symmetric\n+ * positive semidefinite matrix.\n+ * <p>The rectangular Cholesky decomposition of a real symmetric positive\n+ * semidefinite matrix A consists of a rectangular matrix B with the same\n+ * number of rows such that: A is almost equal to BB<sup>T</sup>, depending\n+ * on a user-defined tolerance. In a sense, this is the square root of A.</p>\n+ * <p>The difference with respect to the regular {@link CholeskyDecomposition}\n+ * is that rows/columns may be permuted (hence the rectangular shape instead\n+ * of the traditional triangular shape) and there is a threshold to ignore\n+ * small diagonal elements. This is used for example to generate {@link\n+ * CorrelatedRandomVectorGenerator correlated random n-dimensions vectors}\n+ * in a p-dimension subspace (p < n). In other words, it allows generating\n+ * random vectors from a covariance matrix that is only positive semidefinite,\n+ * and not positive definite.</p>\n+ * <p>Rectangular Cholesky decomposition is <em>not</em> suited for solving\n+ * linear systems, so it does not provide any {@link DecompositionSolver\n+ * decomposition solver}.</p>\n+ * @see CholeskyDecomposition\n+ * @see CorrelatedRandomVectorGenerator\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface RectangularCholeskyDecomposition {\n+\n+    /** Get the root of the covariance matrix.\n+     * The root is the rectangular matrix <code>B</code> such that\n+     * the covariance matrix is equal to <code>B.B<sup>T</sup></code>\n+     * @return root of the square matrix\n+     * @see #getRank()\n+     */\n+    RealMatrix getRootMatrix();\n+\n+    /** Get the rank of the symmetric positive semidefinite matrix.\n+     * The r is the number of independent rows in the symmetric positive semidefinite\n+     * matrix, it is also the number of columns of the rectangular\n+     * matrix of the decomposition.\n+     * @return r of the square matrix.\n+     * @see #getRootMatrix()\n+     */\n+    int getRank();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RectangularCholeskyDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Calculates the rectangular Cholesky decomposition of a matrix.\n+ * <p>The rectangular Cholesky decomposition of a real symmetric positive\n+ * semidefinite matrix A consists of a rectangular matrix B with the same\n+ * number of rows such that: A is almost equal to BB<sup>T</sup>, depending\n+ * on a user-defined tolerance. In a sense, this is the square root of A.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RectangularCholeskyDecompositionImpl implements RectangularCholeskyDecomposition {\n+\n+    /** Permutated Cholesky root of the symmetric positive semidefinite matrix. */\n+    private final RealMatrix root;\n+\n+    /** Rank of the symmetric positive semidefinite matrix. */\n+    private int rank;\n+\n+    /**\n+     * Decompose a symmetric positive semidefinite matrix.\n+     *\n+     * @param matrix Symmetric positive semidefinite matrix.\n+     * @param small Diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded.\n+     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n+     * positive semidefinite.\n+     */\n+    public RectangularCholeskyDecompositionImpl(RealMatrix matrix, double small)\n+        throws NonPositiveDefiniteMatrixException {\n+\n+        int order = matrix.getRowDimension();\n+        double[][] c = matrix.getData();\n+        double[][] b = new double[order][order];\n+\n+        int[] swap  = new int[order];\n+        int[] index = new int[order];\n+        for (int i = 0; i < order; ++i) {\n+            index[i] = i;\n+        }\n+\n+        int r = 0;\n+        for (boolean loop = true; loop;) {\n+\n+            // find maximal diagonal element\n+            swap[r] = r;\n+            for (int i = r + 1; i < order; ++i) {\n+                int ii  = index[i];\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n+                }\n+            }\n+\n+\n+            // swap elements\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n+            }\n+\n+            // check diagonal element\n+            int ir = index[r];\n+            if (c[ir][ir] < small) {\n+\n+                if (r == 0) {\n+                    throw new NonPositiveDefiniteMatrixException(ir, small);\n+                }\n+\n+                // check remaining diagonal elements\n+                for (int i = r; i < order; ++i) {\n+                    if (c[index[i]][index[i]] < -small) {\n+                        // there is at least one sufficiently negative diagonal element,\n+                        // the symmetric positive semidefinite matrix is wrong\n+                        throw new NonPositiveDefiniteMatrixException(i, small);\n+                    }\n+                }\n+\n+                // all remaining diagonal elements are close to zero, we consider we have\n+                // found the rank of the symmetric positive semidefinite matrix\n+                ++r;\n+                loop = false;\n+\n+            } else {\n+\n+                // transform the matrix\n+                double sqrt = FastMath.sqrt(c[ir][ir]);\n+                b[r][r] = sqrt;\n+                double inverse = 1 / sqrt;\n+                for (int i = r + 1; i < order; ++i) {\n+                    int ii = index[i];\n+                    double e = inverse * c[ii][ir];\n+                    b[i][r] = e;\n+                    c[ii][ii] -= e * e;\n+                    for (int j = r + 1; j < i; ++j) {\n+                        int ij = index[j];\n+                        double f = c[ii][ij] - e * b[j][r];\n+                        c[ii][ij] = f;\n+                        c[ij][ii] = f;\n+                    }\n+                }\n+\n+                // prepare next iteration\n+                loop = ++r < order;\n+            }\n+        }\n+\n+        // build the root matrix\n+        rank = r;\n+        root = MatrixUtils.createRealMatrix(order, r);\n+        for (int i = 0; i < order; ++i) {\n+            for (int j = 0; j < r; ++j) {\n+                root.setEntry(index[i], j, b[i][j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRootMatrix() {\n+        return root;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getRank() {\n+        return rank;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.linear.NonPositiveDefiniteMatrixException;\n-import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.linear.RectangularCholeskyDecomposition;\n+import org.apache.commons.math.linear.RectangularCholeskyDecompositionImpl;\n \n /**\n  * A {@link RandomVectorGenerator} that generates vectors with with\n     private final NormalizedRandomGenerator generator;\n     /** Storage for the normalized vector. */\n     private final double[] normalized;\n-    /** Permutated Cholesky root of the covariance matrix. */\n-    private RealMatrix root;\n-    /** Rank of the covariance matrix. */\n-    private int rank;\n+    /** Root of the covariance matrix. */\n+    private final RealMatrix root;\n \n     /**\n      * Builds a correlated random vector generator from its mean\n         }\n         this.mean = mean.clone();\n \n-        decompose(covariance, small);\n+        final RectangularCholeskyDecomposition decomposition =\n+            new RectangularCholeskyDecompositionImpl(covariance, small);\n+        root = decomposition.getRootMatrix();\n \n         this.generator = generator;\n-        normalized = new double[rank];\n+        normalized = new double[decomposition.getRank()];\n+\n     }\n \n     /**\n             mean[i] = 0;\n         }\n \n-        decompose(covariance, small);\n+        final RectangularCholeskyDecomposition decomposition =\n+            new RectangularCholeskyDecompositionImpl(covariance, small);\n+        root = decomposition.getRootMatrix();\n \n         this.generator = generator;\n-        normalized = new double[rank];\n+        normalized = new double[decomposition.getRank()];\n+\n     }\n \n     /** Get the underlying normalized components generator.\n      */\n     public NormalizedRandomGenerator getGenerator() {\n         return generator;\n+    }\n+\n+    /** Get the rank of the covariance matrix.\n+     * The rank is the number of independent rows in the covariance\n+     * matrix, it is also the number of columns of the root matrix.\n+     * @return rank of the square matrix.\n+     * @see #getRootMatrix()\n+     */\n+    public int getRank() {\n+        return normalized.length;\n     }\n \n     /** Get the root of the covariance matrix.\n         return root;\n     }\n \n-    /** Get the rank of the covariance matrix.\n-     * The rank is the number of independent rows in the covariance\n-     * matrix, it is also the number of columns of the rectangular\n-     * matrix of the decomposition.\n-     * @return rank of the square matrix.\n-     * @see #getRootMatrix()\n-     */\n-    public int getRank() {\n-        return rank;\n-    }\n-\n-    /** Decompose the original square matrix.\n-     * <p>The decomposition is based on a Choleski decomposition\n-     * where additional transforms are performed:\n-     * <ul>\n-     *   <li>the rows of the decomposed matrix are permuted</li>\n-     *   <li>columns with the too small diagonal element are discarded</li>\n-     *   <li>the matrix is permuted</li>\n-     * </ul>\n-     * This means that rather than computing M = U<sup>T</sup>.U where U\n-     * is an upper triangular matrix, this method computed M=B.B<sup>T</sup>\n-     * where B is a rectangular matrix.\n-     * @param covariance covariance matrix\n-     * @param small diagonal elements threshold under which  column are\n-     * considered to be dependent on previous ones and are discarded\n-     * @throws org.apache.commons.math.linear.NonPositiveDefiniteMatrixException\n-     * if the covariance matrix is not strictly positive definite.\n-     */\n-    private void decompose(RealMatrix covariance, double small) {\n-        int order = covariance.getRowDimension();\n-        double[][] c = covariance.getData();\n-        double[][] b = new double[order][order];\n-\n-        int[] swap  = new int[order];\n-        int[] index = new int[order];\n-        for (int i = 0; i < order; ++i) {\n-            index[i] = i;\n-        }\n-\n-        rank = 0;\n-        for (boolean loop = true; loop;) {\n-\n-            // find maximal diagonal element\n-            swap[rank] = rank;\n-            for (int i = rank + 1; i < order; ++i) {\n-                int ii  = index[i];\n-                int isi = index[swap[i]];\n-                if (c[ii][ii] > c[isi][isi]) {\n-                    swap[rank] = i;\n-                }\n-            }\n-\n-\n-            // swap elements\n-            if (swap[rank] != rank) {\n-                int tmp = index[rank];\n-                index[rank] = index[swap[rank]];\n-                index[swap[rank]] = tmp;\n-            }\n-\n-            // check diagonal element\n-            int ir = index[rank];\n-            if (c[ir][ir] < small) {\n-\n-                if (rank == 0) {\n-                    throw new NonPositiveDefiniteMatrixException(ir, small);\n-                }\n-\n-                // check remaining diagonal elements\n-                for (int i = rank; i < order; ++i) {\n-                    if (c[index[i]][index[i]] < -small) {\n-                        // there is at least one sufficiently negative diagonal element,\n-                        // the covariance matrix is wrong\n-                        throw new NonPositiveDefiniteMatrixException(i, small);\n-                    }\n-                }\n-\n-                // all remaining diagonal elements are close to zero,\n-                // we consider we have found the rank of the covariance matrix\n-                ++rank;\n-                loop = false;\n-\n-            } else {\n-\n-                // transform the matrix\n-                double sqrt = FastMath.sqrt(c[ir][ir]);\n-                b[rank][rank] = sqrt;\n-                double inverse = 1 / sqrt;\n-                for (int i = rank + 1; i < order; ++i) {\n-                    int ii = index[i];\n-                    double e = inverse * c[ii][ir];\n-                    b[i][rank] = e;\n-                    c[ii][ii] -= e * e;\n-                    for (int j = rank + 1; j < i; ++j) {\n-                        int ij = index[j];\n-                        double f = c[ii][ij] - e * b[j][rank];\n-                        c[ii][ij] = f;\n-                        c[ij][ii] = f;\n-                    }\n-                }\n-\n-                // prepare next iteration\n-                loop = ++rank < order;\n-            }\n-        }\n-\n-        // build the root matrix\n-        root = MatrixUtils.createRealMatrix(order, rank);\n-        for (int i = 0; i < order; ++i) {\n-            for (int j = 0; j < rank; ++j) {\n-                root.setEntry(index[i], j, b[i][j]);\n-            }\n-        }\n-\n-    }\n-\n     /** Generate a correlated random vector.\n      * @return a random vector as an array of double. The returned array\n      * is created at each call, the caller can do what it wants with it.\n     public double[] nextVector() {\n \n         // generate uncorrelated vector\n-        for (int i = 0; i < rank; ++i) {\n+        for (int i = 0; i < normalized.length; ++i) {\n             normalized[i] = generator.nextNormalizedDouble();\n         }\n \n         double[] correlated = new double[mean.length];\n         for (int i = 0; i < correlated.length; ++i) {\n             correlated[i] = mean[i];\n-            for (int j = 0; j < rank; ++j) {\n+            for (int j = 0; j < root.getColumnDimension(); ++j) {\n                 correlated[i] += root.getEntry(i, j) * normalized[j];\n             }\n         }\n \n         return correlated;\n+\n     }\n+\n }", "timestamp": 1303745292, "metainfo": ""}