{"sha": "1d1436557bcb21887d9b352dd0f5f3d3acb71e11", "log": "split the analysis package into several sub-packages  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n+ * Romberg Algorithm</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * Romberg integration employs k successvie refinements of the trapezoid\n+ * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n+ * is a special case of k = 2.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = -1058849527738180243L;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     */\n+    public RombergIntegrator(UnivariateRealFunction f) {\n+        super(f, 32);\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1, j, m = maximalIterationCount + 1;\n+        // Array strcture here can be improved for better space\n+        // efficiency because only the lower triangle is used.\n+        double r, t[][] = new double[m][m], s, olds;\n+\n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n+        t[0][0] = qtrap.stage(min, max, 0);\n+        olds = t[0][0];\n+        while (i <= maximalIterationCount) {\n+            t[i][0] = qtrap.stage(min, max, i);\n+            for (j = 1; j <= i; j++) {\n+                // Richardson extrapolation coefficient\n+                r = (1L << (2 * j)) -1;\n+                t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;\n+            }\n+            s = t[i][i];\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 32 bisection refinements due to higher order divider\n+        if (maximalIterationCount > 32) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 32] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n+ * Simpson's Rule</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * This implementation employs basic trapezoid rule as building blocks to\n+ * calculate the Simpson's rule of alternating 2/3 and 4/3.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 3405465123320678216L;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     */\n+    public SimpsonIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double s, olds, t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);\n+        if (minimalIterationCount == 1) {\n+            s = (4 * qtrap.stage(min, max, 1) - qtrap.stage(min, max, 0)) / 3.0;\n+            setResult(s, 1);\n+            return result;\n+        }\n+        // Simpson's rule requires at least two trapezoid stages.\n+        olds = 0;\n+        oldt = qtrap.stage(min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = qtrap.stage(min, max, i);\n+            s = (4 * t - oldt) / 3.0;\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            oldt = t;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 64] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n+ * Trapezoidal Rule</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * The function should be integrable.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 4978222553983172543L;\n+\n+    /** intermediate result */\n+    private double s;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     */\n+    public TrapezoidIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral of trapezoid rule. This function\n+     * should only be called by API <code>integrate()</code> in the package.\n+     * To save time it does not verify arguments - caller does.\n+     * <p>\n+     * The interval is divided equally into 2^n sections rather than an\n+     * arbitrary m sections because this configuration can best utilize the\n+     * alrealy computed values.</p>\n+     *\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n+     * @return the value of n-th stage integral\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     */\n+    double stage(double min, double max, int n) throws\n+        FunctionEvaluationException {\n+        \n+        long i, np;\n+        double x, spacing, sum = 0;\n+        \n+        if (n == 0) {\n+            s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n+            return s;\n+        } else {\n+            np = 1L << (n-1);           // number of new points in this stage\n+            spacing = (max - min) / np; // spacing between adjacent new points\n+            x = min + 0.5 * spacing;    // the first new point\n+            for (i = 0; i < np; i++) {\n+                sum += f.value(x);\n+                x += spacing;\n+            }\n+            // add the new sum to previously calculated result\n+            s = 0.5 * (s + sum * spacing);\n+            return s;\n+        }\n+    }\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n+        FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        oldt = stage(min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = stage(min, max, i);\n+            if (i >= minimalIterationCount) {\n+                if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {\n+                    setResult(t, i);\n+                    return result;\n+                }\n+            }\n+            oldt = t;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Verifies that the iteration limits are valid and within the range.\n+     * \n+     * @throws IllegalArgumentException if not\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw new IllegalArgumentException\n+                (\"Iteration upper limit out of [0, 64] range: \" +\n+                maximalIterationCount);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Interface for univariate real integration algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public interface UnivariateRealIntegrator {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * <p>\n+     * Usually a high iteration count indicates convergence problem. However,\n+     * the \"reasonable value\" varies widely for different cases.  Users are\n+     * advised to use the default value.</p>\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is exceeded.</p>\n+     *  \n+     * @param count maximum number of iterations\n+     */\n+    void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the implementation.</p>\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the lower limit for the number of iterations.\n+     * <p>\n+     * Minimal iteration is needed to avoid false early convergence, e.g.\n+     * the sample points happen to be zeroes of the function. Users can\n+     * use the default value or choose one that they see as appropriate.</p>\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is not met.</p>\n+     *\n+     * @param count minimum number of iterations\n+     */\n+    void setMinimalIterationCount(int count);\n+\n+    /**\n+     * Get the lower limit for the number of iterations.\n+     * \n+     * @return the actual lower limit\n+     */\n+    int getMinimalIterationCount();\n+\n+    /**\n+     * Reset the lower limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the implementation.</p>\n+     * \n+     * @see #setMinimalIterationCount(int)\n+     */\n+    void resetMinimalIterationCount();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * <p>\n+     * This is used to stop iterations.</p>\n+     * \n+     * @param accuracy the relative accuracy\n+     * @throws IllegalArgumentException if the accuracy can't be achieved\n+     * or is otherwise deemed unreasonable\n+     */\n+    void setRelativeAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     *\n+     * @return the accuracy\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * <p>\n+     * The default value is provided by the implementation.</p>\n+     *\n+     * @see #setRelativeAccuracy(double)\n+     */\n+    void resetRelativeAccuracy();\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the integrator\n+     */\n+    double integrate(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Get the result of the last run of the integrator.\n+     * \n+     * @return the last result\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    double getResult() throws IllegalStateException;\n+\n+    /**\n+     * Get the number of iterations in the last run of the integrator.\n+     * <p>\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the function is evaluated\n+     * properly, and whether another integrator is more amenable to the\n+     * problem.</p>\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    int getIterationCount() throws IllegalStateException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several generic functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public abstract class UnivariateRealIntegratorImpl implements\n+    UnivariateRealIntegrator, Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3365294665201465048L;\n+\n+    /** maximum relative error */\n+    protected double relativeAccuracy;\n+\n+    /** maximum number of iterations */\n+    protected int maximalIterationCount;\n+\n+    /** minimum number of iterations */\n+    protected int minimalIterationCount;\n+\n+    /** default maximum relative error */\n+    protected double defaultRelativeAccuracy;\n+\n+    /** default maximum number of iterations */\n+    protected int defaultMaximalIterationCount;\n+\n+    /** default minimum number of iterations */\n+    protected int defaultMinimalIterationCount;\n+\n+    /** indicates whether an integral has been computed */\n+    protected boolean resultComputed = false;\n+\n+    /** the last computed integral */\n+    protected double result;\n+\n+    /** the last iteration count */\n+    protected int iterationCount;\n+\n+    /** the integrand function */\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct an integrator with given iteration count and accuracy.\n+     * \n+     * @param f the integrand function\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the iteration\n+     * limits are not valid\n+     */\n+    protected UnivariateRealIntegratorImpl(\n+        UnivariateRealFunction f,\n+        int defaultMaximalIterationCount) throws IllegalArgumentException {\n+        \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"Function can not be null.\");\n+        }\n+\n+        this.f = f;\n+        // parameters that may depend on algorithm\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+        // parameters that are problem specific\n+        this.defaultRelativeAccuracy = 1E-6;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.defaultMinimalIterationCount = 3;\n+        this.minimalIterationCount = defaultMinimalIterationCount;\n+        \n+        verifyIterationCount();\n+    }\n+\n+    /**\n+     * Access the last computed integral.\n+     * \n+     * @return the last computed integral\n+     * @throws IllegalStateException if no integral has been computed\n+     */\n+    public double getResult() throws IllegalStateException {\n+        if (resultComputed) {\n+            return result;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /**\n+     * Access the last iteration count.\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if no integral has been computed\n+     */\n+    public int getIterationCount() throws IllegalStateException {\n+        if (resultComputed) {\n+            return iterationCount;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * \n+     * @param count maximum number of iterations\n+     */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Set the lower limit for the number of iterations.\n+     * \n+     * @param count minimum number of iterations\n+     */\n+    public void setMinimalIterationCount(int count) {\n+        minimalIterationCount = count;\n+    }\n+\n+    /**\n+     * Get the lower limit for the number of iterations.\n+     * \n+     * @return the actual lower limit\n+     */\n+    public int getMinimalIterationCount() {\n+        return minimalIterationCount;\n+    }\n+\n+    /**\n+     * Reset the lower limit for the number of iterations to the default.\n+     */\n+    public void resetMinimalIterationCount() {\n+        minimalIterationCount = defaultMinimalIterationCount;\n+    }\n+\n+    /**\n+     * Set the relative accuracy.\n+     * \n+     * @param accuracy the relative accuracy\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the integrator or is otherwise deemed unreasonable\n+     */\n+    public void setRelativeAccuracy(double accuracy) {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     *\n+     * @return the accuracy\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+    /**\n+     * Returns true if the arguments form a (strictly) increasing sequence\n+     * \n+     * @param start first number\n+     * @param mid second number\n+     * @param end third number\n+     * @return true if the arguments form an increasing sequence\n+     */\n+    protected boolean isSequence(double start, double mid, double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+\n+    /**\n+     * Verifies that the endpoints specify an interval.\n+     * \n+     * @param lower lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException if not interval\n+     */\n+    protected void verifyInterval(double lower, double upper) throws\n+        IllegalArgumentException {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"Endpoints do not specify an interval: [\" + lower +\n+                \", \" + upper + \"]\");\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the upper and lower limits of iterations are valid.\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {\n+            throw new IllegalArgumentException\n+                (\"Invalid iteration limits: min=\" + minimalIterationCount +\n+                \" max=\" + maximalIterationCount);\n+        }       \n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm;\n+\n+/**\n+ * Implements the <a href=\"\n+ * \"http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html\">\n+ * Divided Difference Algorithm</a> for interpolation of real univariate\n+ * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n+ * ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The actual code of Neville's evaluation is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 107049519551235069L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws DuplicateSampleAbscissaException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        DuplicateSampleAbscissaException {\n+\n+        /**\n+         * a[] and c[] are defined in the general formula of Newton form:\n+         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+         */\n+        double a[], c[];\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        /**\n+         * When used for interpolation, the Newton form formula becomes\n+         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\n+         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n+         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n+         * <p>\n+         * Note x[], y[], a[] have the same length but c[]'s size is one less.</p>\n+         */\n+        c = new double[x.length-1];\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = x[i];\n+        }\n+        a = computeDividedDifference(x, y);\n+\n+        PolynomialFunctionNewtonForm p;\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns a copy of the divided difference array.\n+     * <p> \n+     * The divided difference array is defined recursively by <pre>\n+     * f[x0] = f(x0)\n+     * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n+     * </pre></p>\n+     * <p>\n+     * The computational complexity is O(N^2).</p>\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a fresh copy of the divided difference array\n+     * @throws DuplicateSampleAbscissaException if any abscissas coincide\n+     */\n+    protected static double[] computeDividedDifference(double x[], double y[])\n+        throws DuplicateSampleAbscissaException {\n+\n+        int i, j, n;\n+        double divdiff[], a[], denominator;\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        divdiff = new double[n];\n+        for (i = 0; i < n; i++) {\n+            divdiff[i] = y[i];      // initialization\n+        }\n+\n+        a = new double [n];\n+        a[0] = divdiff[0];\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                denominator = x[j+i] - x[j];\n+                if (denominator == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[j], j, j+i);\n+                }\n+                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n+            }\n+            a[i] = divdiff[0];\n+        }\n+\n+        return a;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+ * Neville's Algorithm</a> for interpolation of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class NevilleInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 3003707660147873733L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        MathException {\n+\n+        PolynomialFunctionLagrangeForm p;\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+        return p;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n+ * <p>\n+ * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n+ * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n+ * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"</p>\n+ * <p>\n+ * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest\n+ * knot point and strictly less than the largest knot point is computed by finding the subinterval to which\n+ * x belongs and computing the value of the corresponding polynomial at <code>x - x[i] </code> where\n+ * <code>i</code> is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.\n+ * </p>\n+ * <p>\n+ * The interpolating polynomials satisfy: <ol>\n+ * <li>The value of the PolynomialSplineFunction at each of the input x values equals the \n+ *  corresponding y value.</li>\n+ * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials \n+ *  \"match up\" at the knot points, as do their first and second derivatives).</li>\n+ * </ol></p>\n+ * <p>\n+ * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, \n+ * <u>Numerical Analysis</u>, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ */\n+public class SplineInterpolator implements UnivariateRealInterpolator {\n+    \n+    /**\n+     * Computes an interpolating function for the data set.\n+     * @param x the arguments for the interpolation points\n+     * @param y the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) {\n+        if (x.length != y.length) {\n+            throw new IllegalArgumentException(\"Dataset arrays must have same length.\");\n+        }\n+        \n+        if (x.length < 3) {\n+            throw new IllegalArgumentException\n+                (\"At least 3 datapoints are required to compute a spline interpolant\");\n+        }\n+        \n+        // Number of intervals.  The number of data points is n + 1.\n+        int n = x.length - 1;   \n+        \n+        for (int i = 0; i < n; i++) {\n+            if (x[i]  >= x[i + 1]) {\n+                throw new IllegalArgumentException(\"Dataset x values must be strictly increasing.\");\n+            }\n+        }\n+        \n+        // Differences between knot points\n+        double h[] = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            h[i] = x[i + 1] - x[i];\n+        }\n+        \n+        double mu[] = new double[n];\n+        double z[] = new double[n + 1];\n+        mu[0] = 0d;\n+        z[0] = 0d;\n+        double g = 0;\n+        for (int i = 1; i < n; i++) {\n+            g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];\n+            mu[i] = h[i] / g;\n+            z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /\n+                    (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;\n+        }\n+       \n+        // cubic spline coefficients --  b is linear, c quadratic, d is cubic (original y's are constants)\n+        double b[] = new double[n];\n+        double c[] = new double[n + 1];\n+        double d[] = new double[n];\n+        \n+        z[n] = 0d;\n+        c[n] = 0d;\n+        \n+        for (int j = n -1; j >=0; j--) {\n+            c[j] = z[j] - mu[j] * c[j + 1];\n+            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;\n+            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);\n+        }\n+        \n+        PolynomialFunction polynomials[] = new PolynomialFunction[n];\n+        double coefficients[] = new double[4];\n+        for (int i = 0; i < n; i++) {\n+            coefficients[0] = y[i];\n+            coefficients[1] = b[i];\n+            coefficients[2] = c[i];\n+            coefficients[3] = d[i];\n+            polynomials[i] = new PolynomialFunction(coefficients);\n+        }\n+        \n+        return new PolynomialSplineFunction(x, polynomials);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Interface representing a univariate real interpolating function.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateRealInterpolator {\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolationg algorithm\n+     */\n+    public UnivariateRealFunction interpolate(double xval[], double yval[])\n+        throws MathException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Immutable representation of a real polynomial function with real coefficients.\n+ * <p>\n+ * <a href=\"http://mathworld.wolfram.com/HornersMethod.html\">Horner's Method</a>\n+ *  is used to evaluate the function.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3322454535052136809L;\n+    \n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.,  \n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Construct a polynomial with the given coefficients.  The first element\n+     * of the coefficients array is the constant term.  Higher degree\n+     * coefficients follow in sequence.  The degree of the resulting polynomial\n+     * is the length of the array minus 1. \n+     * <p>\n+     * The constructor makes a copy of the input array and assigns the copy to\n+     * the coefficients property.</p>\n+     * \n+     * @param c polynominal coefficients\n+     * @throws NullPointerException if c is null\n+     * @throws IllegalArgumentException if c is empty\n+     */\n+    public PolynomialFunction(double c[]) {\n+        super();\n+        if (c.length < 1) {\n+            throw new IllegalArgumentException(\"Polynomial coefficient array must have postive length.\");\n+        }\n+        this.coefficients = new double[c.length];\n+        System.arraycopy(c, 0, this.coefficients, 0, c.length);\n+    }\n+\n+    /**\n+     * Compute the value of the function for the given argument.\n+     * <p>\n+     *  The value returned is <br>\n+     *   <code>coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]</code>\n+     * </p>\n+     * \n+     * @param x the argument for which the function value should be computed\n+     * @return the value of the polynomial at the given point\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) {\n+       return evaluate(coefficients, x);\n+    }\n+\n+\n+    /**\n+     *  Returns the degree of the polynomial\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return coefficients.length - 1;\n+    }\n+    \n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the coefficients of\n+     * the polynomial.</p>\n+     * \n+     * @return  a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients,0, out, 0, coefficients.length);\n+        return out;\n+    }\n+    \n+    /**\n+     * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n+     * the argument.\n+     * \n+     * @param coefficients  the coefficients of the polynomial to evaluate\n+     * @param argument  the input value\n+     * @return  the value of the polynomial \n+     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NullPointerException if coefficients is null\n+     */\n+    protected static double evaluate(double[] coefficients, double argument) {\n+        int n = coefficients.length;\n+        if (n < 1) {\n+            throw new IllegalArgumentException(\"Coefficient array must have positive length for evaluation\");\n+        }\n+        double result = coefficients[n - 1];\n+        for (int j = n -2; j >=0; j--) {\n+            result = argument * result + coefficients[j];\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n+     * \n+     * @param coefficients  the coefficients of the polynomial to differentiate\n+     * @return the coefficients of the derivative or null if coefficients has length 1.\n+     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NullPointerException if coefficients is null\n+     */\n+    protected static double[] differentiate(double[] coefficients) {\n+        int n = coefficients.length;\n+        if (n < 1) {\n+            throw new IllegalArgumentException(\"Coefficient array must have positive length for differentiation\");\n+        }\n+        if (n == 1) {\n+            return new double[]{0};\n+        }\n+        double[] result = new double[n - 1];\n+        for (int i = n - 1; i  > 0; i--) {\n+            result[i - 1] = (double) i * coefficients[i];\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the derivative as a PolynomialRealFunction\n+     * \n+     * @return  the derivative polynomial\n+     */\n+    public PolynomialFunction polynomialDerivative() {\n+        return new PolynomialFunction(differentiate(coefficients));\n+    }\n+    \n+    /**\n+     * Returns the derivative as a UnivariateRealFunction\n+     * \n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return polynomialDerivative();\n+    }\n+   \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * <a href=\"http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html\">\n+ * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\n+ * Analysis</b>, ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The approximated function should be smooth enough for Lagrange polynomial\n+ * to work well. Otherwise, consider using splines instead.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3965199246151093920L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Interpolating points (abscissas) and the function values at these points.\n+     */\n+    private double x[], y[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Lagrange polynomial with the given abscissas and function\n+     * values. The order of interpolating points are not important.\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n+     * \n+     * @param x interpolating points\n+     * @param y function values at interpolating points\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    public PolynomialFunctionLagrangeForm(double x[], double y[])\n+        throws IllegalArgumentException {\n+\n+        verifyInterpolationArray(x, y);\n+        this.x = new double[x.length];\n+        this.y = new double[y.length];\n+        System.arraycopy(x, 0, this.x, 0, x.length);\n+        System.arraycopy(y, 0, this.y, 0, y.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+        try {\n+            return evaluate(x, y, z);\n+        } catch (DuplicateSampleAbscissaException e) {\n+            throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return x.length - 1;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating points array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the interpolating points array\n+     */\n+    public double[] getInterpolatingPoints() {\n+        double[] out = new double[x.length];\n+        System.arraycopy(x, 0, out, 0, x.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating values array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the interpolating values array\n+     */\n+    public double[] getInterpolatingValues() {\n+        double[] out = new double[y.length];\n+        System.arraycopy(y, 0, out, 0, y.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Lagrange polynomial using \n+     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+     * Neville's Algorithm</a>. It takes O(N^2) time.\n+     * <p>\n+     * This function is made public static so that users can call it directly\n+     * without instantiating PolynomialFunctionLagrangeForm object.</p>\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws DuplicateSampleAbscissaException if the sample has duplicate abscissas\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double x[], double y[], double z) throws\n+        DuplicateSampleAbscissaException, IllegalArgumentException {\n+\n+        int i, j, n, nearest = 0;\n+        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n+\n+        verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        c = new double[n];\n+        d = new double[n];\n+        min_dist = Double.POSITIVE_INFINITY;\n+        for (i = 0; i < n; i++) {\n+            // initialize the difference arrays\n+            c[i] = y[i];\n+            d[i] = y[i];\n+            // find out the abscissa closest to z\n+            dist = Math.abs(z - x[i]);\n+            if (dist < min_dist) {\n+                nearest = i;\n+                min_dist = dist;\n+            }\n+        }\n+\n+        // initial approximation to the function value at z\n+        value = y[nearest];\n+\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                tc = x[j] - z;\n+                td = x[i+j] - z;\n+                divider = x[j] - x[i+j];\n+                if (divider == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[i], i, i+j);\n+                }\n+                // update the difference arrays\n+                w = (c[j+1] - d[j]) / divider;\n+                c[j] = tc * w;\n+                d[j] = td * w;\n+            }\n+            // sum up the difference terms to get the final value\n+            if (nearest < 0.5*(n-i+1)) {\n+                value += c[nearest];    // fork down\n+            } else {\n+                nearest--;\n+                value += d[nearest];    // fork up\n+            }\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the coefficients of Lagrange polynomial from the\n+     * interpolation data. It takes O(N^2) time.\n+     * <p>\n+     * Note this computation can be ill-conditioned. Use with caution\n+     * and only when it is necessary.</p>\n+     *\n+     * @throws ArithmeticException if any abscissas coincide\n+     */\n+    protected void computeCoefficients() throws ArithmeticException {\n+        int i, j, n;\n+        double c[], tc[], d, t;\n+\n+        n = degree() + 1;\n+        coefficients = new double[n];\n+        for (i = 0; i < n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n+        c = new double[n+1];\n+        c[0] = 1.0;\n+        for (i = 0; i < n; i++) {\n+            for (j = i; j > 0; j--) {\n+                c[j] = c[j-1] - c[j] * x[i];\n+            }\n+            c[0] *= (-x[i]);\n+            c[i+1] = 1;\n+        }\n+\n+        tc = new double[n];\n+        for (i = 0; i < n; i++) {\n+            // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n+            d = 1;\n+            for (j = 0; j < n; j++) {\n+                if (i != j) {\n+                    d *= (x[i] - x[j]);\n+                }\n+            }\n+            if (d == 0.0) {\n+                // This happens only when two abscissas are identical.\n+                for (int k = 0; k < n; ++k) {\n+                    if ((i != k) && (x[i] == x[k])) {\n+                        throw MathRuntimeException.createArithmeticException(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+                                                                             new Object[] {\n+                                                                                 i, k, x[i]\n+                                                                             });\n+                    }\n+                }\n+            }\n+            t = y[i] / d;\n+            // Lagrange polynomial is the sum of n terms, each of which is a\n+            // polynomial of degree n-1. tc[] are the coefficients of the i-th\n+            // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n+            tc[n-1] = c[n];     // actually c[n] = 1\n+            coefficients[n-1] += t * tc[n-1];\n+            for (j = n-2; j >= 0; j--) {\n+                tc[j] = c[j+1] + tc[j+1] * x[i];\n+                coefficients[j] += t * tc[j];\n+            }\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the interpolation arrays are valid.\n+     * <p>\n+     * The interpolating points must be distinct. However it is not\n+     * verified here, it is checked in evaluate() and computeCoefficients().</p>\n+     * \n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @throws IllegalArgumentException if not valid\n+     * @see #evaluate(double[], double[], double)\n+     * @see #computeCoefficients()\n+     */\n+    public static void verifyInterpolationArray(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 2 || y.length < 2) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation requires at least two points.\");\n+        }\n+        if (x.length != y.length) {\n+            throw new IllegalArgumentException\n+                (\"Abscissa and value arrays must have the same length.\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,\n+ * ISBN 0070124477, chapter 2.\n+ * <p>\n+ * The formula of polynomial in Newton form is\n+ *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+ *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+ * Note that the length of a[] is one more than the length of c[]</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3353896576191389897L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Members of c[] are called centers of the Newton polynomial.\n+     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n+     * i.e. a[i] = coefficients[i].\n+     */\n+    private double a[], c[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Newton polynomial with the given a[] and c[]. The order of\n+     * centers are important in that if c[] shuffle, then values of a[] would\n+     * completely change, not just a permutation of old a[].\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    public PolynomialFunctionNewtonForm(double a[], double c[])\n+        throws IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+        this.a = new double[a.length];\n+        this.c = new double[c.length];\n+        System.arraycopy(a, 0, this.a, 0, a.length);\n+        System.arraycopy(c, 0, this.c, 0, c.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+       return evaluate(a, c, z);\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return c.length;\n+    }\n+\n+    /**\n+     * Returns a copy of coefficients in Newton form formula.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of coefficients in Newton form formula\n+     */\n+    public double[] getNewtonCoefficients() {\n+        double[] out = new double[a.length];\n+        System.arraycopy(a, 0, out, 0, a.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the centers array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the centers array\n+     */\n+    public double[] getCenters() {\n+        double[] out = new double[c.length];\n+        System.arraycopy(c, 0, out, 0, c.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Newton polynomial using nested multiplication. It is\n+     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n+     * Horner's Rule</a> and takes O(N) time.\n+     *\n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double a[], double c[], double z) throws\n+        FunctionEvaluationException, IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+\n+        int n = c.length;\n+        double value = a[n];\n+        for (int i = n-1; i >= 0; i--) {\n+            value = a[i] + (z - c[i]) * value;\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the normal polynomial coefficients given the Newton form.\n+     * It also uses nested multiplication but takes O(N^2) time.\n+     */\n+    protected void computeCoefficients() {\n+        int i, j, n = degree();\n+\n+        coefficients = new double[n+1];\n+        for (i = 0; i <= n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        coefficients[0] = a[n];\n+        for (i = n-1; i >= 0; i--) {\n+            for (j = n-i; j > 0; j--) {\n+                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n+            }\n+            coefficients[0] = a[i] - c[i] * coefficients[0];\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the input arrays are valid.\n+     * <p>\n+     * The centers must be distinct for interpolation purposes, but not\n+     * for general use. Thus it is not verified here.</p>\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if not valid\n+     * @see DividedDifferenceInterpolator#computeDividedDifference(double[],\n+     * double[])\n+     */\n+    protected static void verifyInputArray(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        if (a.length < 1 || c.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Input arrays must not be empty.\");\n+        }\n+        if (a.length != c.length + 1) {\n+            throw new IllegalArgumentException\n+                (\"Bad input array sizes, should have difference 1.\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ArgumentOutsideDomainException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Represents a polynomial spline function.\n+ * <p>\n+ * A <strong>polynomial spline function</strong> consists of a set of \n+ * <i>interpolating polynomials</i> and an ascending array of domain \n+ * <i>knot points</i>, determining the intervals over which the spline function\n+ * is defined by the constituent polynomials.  The polynomials are assumed to\n+ * have been computed to match the values of another function at the knot\n+ * points.  The value consistency constraints are not currently enforced by \n+ * <code>PolynomialSplineFunction</code> itself, but are assumed to hold among\n+ * the polynomials and knot points passed to the constructor.</p>\n+ * <p>\n+ * N.B.:  The polynomials in the <code>polynomials</code> property must be\n+ * centered on the knot points to compute the spline function values.  \n+ * See below.</p>\n+ * <p>\n+ * The domain of the polynomial spline function is \n+ * <code>[smallest knot, largest knot]</code>.  Attempts to evaluate the\n+ * function at values outside of this range generate IllegalArgumentExceptions.\n+ * </p>\n+ * <p>\n+ * The value of the polynomial spline function for an argument <code>x</code>\n+ * is computed as follows:\n+ * <ol>\n+ * <li>The knot array is searched to find the segment to which <code>x</code>\n+ * belongs.  If <code>x</code> is less than the smallest knot point or greater\n+ * than the largest one, an <code>IllegalArgumentException</code>\n+ * is thrown.</li>\n+ * <li> Let <code>j</code> be the index of the largest knot point that is less\n+ * than or equal to <code>x</code>.  The value returned is <br>\n+ * <code>polynomials[j](x - knot[j])</code></li></ol></p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialSplineFunction \n+    implements DifferentiableUnivariateRealFunction, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 1619940313389547244L;\n+\n+    /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n+    private double knots[];\n+\n+    /**\n+     * The polynomial functions that make up the spline.  The first element\n+     * determines the value of the spline over the first subinterval, the\n+     * second over the second, etc.   Spline function values are determined by\n+     * evaluating these functions at <code>(x - knot[i])</code> where i is the\n+     * knot segment to which x belongs.\n+     */\n+    private PolynomialFunction polynomials[] = null;\n+    \n+    /** \n+     * Number of spline segments = number of polynomials\n+     *  = number of partition points - 1 \n+     */\n+    private int n = 0;\n+    \n+\n+    /**\n+     * Construct a polynomial spline function with the given segment delimiters\n+     * and interpolating polynomials.\n+     * <p>\n+     * The constructor copies both arrays and assigns the copies to the knots\n+     * and polynomials properties, respectively.</p>\n+     * \n+     * @param knots spline segment interval delimiters\n+     * @param polynomials polynomial functions that make up the spline\n+     * @throws NullPointerException if either of the input arrays is null\n+     * @throws IllegalArgumentException if knots has length less than 2,  \n+     * <code>polynomials.length != knots.length - 1 </code>, or the knots array\n+     * is not strictly increasing.\n+     * \n+     */\n+    public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n+        if (knots.length < 2) {\n+            throw new IllegalArgumentException\n+                (\"Not enough knot values -- spline partition must have at least 2 points.\");\n+        }\n+        if (knots.length - 1 != polynomials.length) {\n+            throw new IllegalArgumentException \n+            (\"Number of polynomial interpolants must match the number of segments.\");\n+        }\n+        if (!isStrictlyIncreasing(knots)) {\n+            throw new IllegalArgumentException \n+                (\"Knot values must be strictly increasing.\");\n+        }\n+        \n+        this.n = knots.length -1;\n+        this.knots = new double[n + 1];\n+        System.arraycopy(knots, 0, this.knots, 0, n + 1);\n+        this.polynomials = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, this.polynomials, 0, n);\n+    }\n+\n+    /**\n+     * Compute the value for the function.\n+     * <p>\n+     * Throws FunctionEvaluationException if v is outside of the domain of the\n+     * function.  The domain is [smallest knot, largest knot].</p>\n+     * <p>\n+     * See {@link PolynomialSplineFunction} for details on the algorithm for\n+     * computing the value of the function.</p>\n+     * \n+     * @param v the point for which the function value should be computed\n+     * @return the value\n+     * @throws ArgumentOutsideDomainException if v is outside of the domain of\n+     * of the spline function (less than the smallest knot point or greater\n+     * than the largest knot point)\n+     */\n+    public double value(double v) throws ArgumentOutsideDomainException {\n+        if (v < knots[0] || v > knots[n]) {\n+            throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);\n+        }\n+        int i = Arrays.binarySearch(knots, v);\n+        if (i < 0) {\n+            i = -i - 2;\n+        }\n+        //This will handle the case where v is the last knot value\n+        //There are only n-1 polynomials, so if v is the last knot\n+        //then we will use the last polynomial to calculate the value.\n+        if ( i >= polynomials.length ) {\n+            i--;\n+        }\n+        return polynomials[i].value(v - knots[i]);\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a UnivariateRealFunction\n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return polynomialSplineDerivative();\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a PolynomialSplineFunction\n+     * \n+     * @return  the derivative function\n+     */\n+    public PolynomialSplineFunction polynomialSplineDerivative() {\n+        PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];\n+        for (int i = 0; i < n; i++) {\n+            derivativePolynomials[i] = polynomials[i].polynomialDerivative();\n+        }\n+        return new PolynomialSplineFunction(knots, derivativePolynomials);\n+    }\n+\n+    /**\n+     * Returns the number of spline segments = the number of polynomials \n+     * = the number of knot points - 1.\n+     * \n+     * @return the number of spline segments\n+     */\n+    public int getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating polynomials array.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy will\n+     * not affect the polynomials property.</p>\n+     * \n+     * @return the interpolating polynomials\n+     */\n+    public PolynomialFunction[] getPolynomials() {\n+        PolynomialFunction p[] = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, p, 0, n);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns an array copy of the knot points.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy\n+     * will not affect the knots property.</p>\n+     * \n+     * @return the knot points\n+     */\n+    public double[] getKnots() {\n+        double out[] = new double[n + 1];\n+        System.arraycopy(knots, 0, out, 0, n + 1);\n+        return out;  \n+    }\n+\n+    /**\n+     * Determines if the given array is ordered in a strictly increasing\n+     * fashion.\n+     * \n+     * @param x the array to examine.\n+     * @return <code>true</code> if the elements in <code>x</code> are ordered\n+     * in a stricly increasing manner.  <code>false</code>, otherwise.\n+     */\n+    private static boolean isStrictlyIncreasing(double[] x) {\n+        for (int i = 1; i < x.length; ++i) {\n+            if (x[i - 1] >= x[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n+ * bisection algorithm</a> for finding zeros of univariate real functions. \n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ * \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ */\n+public class BisectionSolver extends UnivariateRealSolverImpl {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5227509383222989438L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public BisectionSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     * \n+     */\n+    public BisectionSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+            \n+        clearResult();\n+        verifyInterval(min,max);\n+        double m;\n+        double fm;\n+        double fmin;\n+        \n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            m = UnivariateRealSolverUtils.midpoint(min, max);\n+           fmin = f.value(min);\n+           fm = f.value(m);\n+\n+            if (fm * fmin > 0.0) {\n+                // max and m bracket the root.\n+                min = m;\n+            } else {\n+                // min and m bracket the root.\n+                max = m;\n+            }\n+\n+            if (Math.abs(max - min) <= absoluteAccuracy) {\n+                m = UnivariateRealSolverUtils.midpoint(min, max);\n+                setResult(m, i);\n+                return m;\n+            }\n+            ++i;\n+        }\n+        \n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n+ * Brent algorithm</a> for  finding zeros of real univariate functions.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n+ */\n+public class BrentSolver extends UnivariateRealSolverImpl {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7694577816772532779L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public BrentSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a zero in the given interval with an initial guess.\n+     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n+     * function at the three points have the same sign (note that it is\n+     * allowed to have endpoints with the same sign if the initial point has\n+     * opposite sign function-wise).</p>\n+     * \n+     * @param f function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param initial the start value to use (must be set to min if no\n+     * initial point is known).\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException the maximum iteration count\n+     * is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     *  the function\n+     * @throws IllegalArgumentException if initial is not between min and max\n+     * (even if it <em>is</em> a root)\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        if (((initial - min) * (max -initial)) < 0) {\n+            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n+                      \" interval.\" + \"  Initial: \" + initial +\n+                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n+        }\n+\n+        // return the initial guess if it is good enough\n+        double yInitial = f.value(initial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n+        }\n+\n+        // return the first endpoint if it is good enough\n+        double yMin = f.value(min);\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(yMin, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if min and initial bracket the root\n+        if (yInitial * yMin < 0) {\n+            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        }\n+\n+        // return the second endpoint if it is good enough\n+        double yMax = f.value(max);\n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(yMax, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if initial and max bracket the root\n+        if (yInitial * yMax < 0) {\n+            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        }\n+\n+        // full Brent algorithm starting with provided initial guess\n+        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+\n+    }\n+    \n+    /**\n+     * Find a zero in the given interval.\n+     * <p>\n+     * Requires that the values of the function at the endpoints have opposite\n+     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n+     * the case.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        \n+        double ret = Double.NaN;\n+        \n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        \n+        // Verify bracketing\n+        double sign = yMin * yMax;\n+        if (sign > 0) {\n+            // check if either value is close to a zero\n+            if (Math.abs(yMin) <= functionValueAccuracy) {\n+                setResult(min, 0);\n+                ret = min;\n+            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n+                setResult(max, 0);\n+                ret = max;\n+            } else {\n+                // neither value is close to zero and min and max do not bracket root.\n+                throw new IllegalArgumentException\n+                (\"Function values at endpoints do not have different signs.\" +\n+                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n+                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            }\n+        } else if (sign < 0){\n+            // solve using only the first endpoint as initial guess\n+            ret = solve(f, min, yMin, max, yMax, min, yMin);\n+        } else {\n+            // either min or max is a root\n+            if (yMin == 0.0) {\n+                ret = min;\n+            } else {\n+                ret = max;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+        \n+    /**\n+     * Find a zero starting search according to the three provided points.\n+     * @param f the function to solve\n+     * @param x0 old approximation for the root\n+     * @param y0 function value at the approximation for the root\n+     * @param x1 last calculated approximation for the root\n+     * @param y1 function value at the last calculated approximation\n+     * for the root\n+     * @param x2 bracket point (must be set to x0 if no bracket point is\n+     * known, this will force starting with linear interpolation)\n+     * @param y2 function value at the bracket point.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function \n+     */\n+    private double solve(final UnivariateRealFunction f,\n+                         double x0, double y0,\n+                         double x1, double y1,\n+                         double x2, double y2)\n+    throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        double delta = x1 - x0;\n+        double oldDelta = delta;\n+\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                // use the bracket point if is better than last approximation\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                // Avoid division by very small values. Assume\n+                // the iteration has converged (the problem may\n+                // still be ill conditioned)\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double dx = (x2 - x1);\n+            double tolerance =\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n+            if (Math.abs(dx) <= tolerance) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            if ((Math.abs(oldDelta) < tolerance) ||\n+                    (Math.abs(y0) <= Math.abs(y1))) {\n+                // Force bisection.\n+                delta = 0.5 * dx;\n+                oldDelta = delta;\n+            } else {\n+                double r3 = y1 / y0;\n+                double p;\n+                double p1;\n+                // the equality test (x0 == x2) is intentional,\n+                // it is part of the original Brent's method,\n+                // it should NOT be replaced by proximity test\n+                if (x0 == x2) {\n+                    // Linear interpolation.\n+                    p = dx * r3;\n+                    p1 = 1.0 - r3;\n+                } else {\n+                    // Inverse quadratic interpolation.\n+                    double r1 = y0 / y2;\n+                    double r2 = y1 / y2;\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+                }\n+                if (p > 0.0) {\n+                    p1 = -p1;\n+                } else {\n+                    p = -p;\n+                }\n+                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n+                        p >= Math.abs(0.5 * oldDelta * p1)) {\n+                    // Inverse quadratic interpolation gives a value\n+                    // in the wrong direction, or progress is slow.\n+                    // Fall back to bisection.\n+                    delta = 0.5 * dx;\n+                    oldDelta = delta;\n+                } else {\n+                    oldDelta = delta;\n+                    delta = p / p1;\n+                }\n+            }\n+            // Save old X1, Y1 \n+            x0 = x1;\n+            y0 = y1;\n+            // Compute new X1, Y1\n+            if (Math.abs(delta) > tolerance) {\n+                x1 = x1 + delta;\n+            } else if (dx > 0.0) {\n+                x1 = x1 + 0.5 * tolerance;\n+            } else if (dx <= 0.0) {\n+                x1 = x1 - 0.5 * tolerance;\n+            }\n+            y1 = f.value(x1);\n+            if ((y1 > 0) == (y2 > 0)) {\n+                x2 = x0;\n+                y2 = y0;\n+                delta = x1 - x0;\n+                oldDelta = delta;\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n+ * Laguerre's Method</a> for root finding of real coefficient polynomials.\n+ * For reference, see <b>A First Course in Numerical Analysis</b>,\n+ * ISBN 048641454X, chapter 8.\n+ * <p>\n+ * Laguerre's method is global in the sense that it can start with any initial\n+ * approximation and be able to solve all roots from that point.</p>\n+ *\n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ * @since 1.2\n+ */\n+public class LaguerreSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = -3775334783473775723L;\n+\n+    /** polynomial function to solve.\n+     * @deprecated as of 2.0 the function is not stored anymore in the instance\n+     */\n+    @Deprecated\n+    private PolynomialFunction p;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     *\n+     * @param f function to solve\n+     * @throws IllegalArgumentException if function is not polynomial\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public LaguerreSolver(UnivariateRealFunction f) throws\n+        IllegalArgumentException {\n+        super(f, 100, 1E-6);\n+        if (f instanceof PolynomialFunction) {\n+            p = (PolynomialFunction) f;\n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+        }\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public LaguerreSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /**\n+     * Returns a copy of the polynomial function.\n+     * \n+     * @return a fresh copy of the polynomial function\n+     * @deprecated as of 2.0 the function is not stored anymore within the instance.\n+     */\n+    @Deprecated\n+    public PolynomialFunction getPolynomialFunction() {\n+        return new PolynomialFunction(p.getCoefficients());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f function to solve (must be polynomial)\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Despite the bracketing condition, the root returned by solve(Complex[],\n+     * Complex) may not be a real zero inside [min, max]. For example,\n+     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n+     * another initial value, or, as we did here, call solveAll() to obtain\n+     * all roots and pick up the one that we're looking for.</p>\n+     *\n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+\n+        // check function type\n+        if (!(f instanceof PolynomialFunction)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+        }\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        double coefficients[] = ((PolynomialFunction) f).getCoefficients();\n+        Complex c[] = new Complex[coefficients.length];\n+        for (int i = 0; i < coefficients.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        Complex initial = new Complex(0.5 * (min + max), 0.0);\n+        Complex z = solve(c, initial);\n+        if (isRootOK(min, max, z)) {\n+            setResult(z.getReal(), iterationCount);\n+            return result;\n+        }\n+\n+        // solve all roots and select the one we're seeking\n+        Complex[] root = solveAll(c, initial);\n+        for (int i = 0; i < root.length; i++) {\n+            if (isRootOK(min, max, root[i])) {\n+                setResult(root[i].getReal(), iterationCount);\n+                return result;\n+            }\n+        }\n+\n+        // should never happen\n+        throw new ConvergenceException();\n+    }\n+\n+    /**\n+     * Returns true iff the given complex root is actually a real zero\n+     * in the given interval, within the solver tolerance level.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param z the complex root\n+     * @return true iff z is the sought-after real zero\n+     */\n+    protected boolean isRootOK(double min, double max, Complex z) {\n+        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n+        return (isSequence(min, z.getReal(), max)) &&\n+               (Math.abs(z.getImaginary()) <= tolerance ||\n+                z.abs() <= functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(double coefficients[], double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        Complex c[] = new Complex[coefficients.length];\n+        Complex z = new Complex(initial, 0.0);\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        return solveAll(c, z);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        int iterationCount = 0;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n+        for (int i = 0; i <= n; i++) {\n+            c[i] = coefficients[i];\n+        }\n+\n+        // solve individual root successively\n+        Complex root[] = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            Complex subarray[] = new Complex[n-i+1];\n+            System.arraycopy(c, 0, subarray, 0, subarray.length);\n+            root[i] = solve(subarray, initial);\n+            // polynomial deflation using synthetic division\n+            Complex newc = c[n-i];\n+            Complex oldc = null;\n+            for (int j = n-i-1; j >= 0; j--) {\n+                oldc = c[j];\n+                c[j] = newc;\n+                newc = oldc.add(newc.multiply(root[i]));\n+            }\n+            iterationCount += this.iterationCount;\n+        }\n+\n+        resultComputed = true;\n+        this.iterationCount = iterationCount;\n+        return root;\n+    }\n+\n+    /**\n+     * Find a complex root for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex solve(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        Complex N = new Complex((double)n, 0.0);\n+        Complex N1 = new Complex((double)(n-1), 0.0);\n+\n+        int i = 1;\n+        Complex pv = null;\n+        Complex dv = null;\n+        Complex d2v = null;\n+        Complex G = null;\n+        Complex G2 = null;\n+        Complex H = null;\n+        Complex delta = null;\n+        Complex denominator = null;\n+        Complex z = initial;\n+        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        while (i <= maximalIterationCount) {\n+            // Compute pv (polynomial value), dv (derivative value), and\n+            // d2v (second derivative value) simultaneously.\n+            pv = coefficients[n];\n+            dv = Complex.ZERO;\n+            d2v = Complex.ZERO;\n+            for (int j = n-1; j >= 0; j--) {\n+                d2v = dv.add(z.multiply(d2v));\n+                dv = pv.add(z.multiply(dv));\n+                pv = coefficients[j].add(z.multiply(pv));\n+            }\n+            d2v = d2v.multiply(new Complex(2.0, 0.0));\n+\n+            // check for convergence\n+            double tolerance = Math.max(relativeAccuracy * z.abs(),\n+                                        absoluteAccuracy);\n+            if ((z.subtract(oldz)).abs() <= tolerance) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+            if (pv.abs() <= functionValueAccuracy) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+\n+            // now pv != 0, calculate the new approximation\n+            G = dv.divide(pv);\n+            G2 = G.multiply(G);\n+            H = G2.subtract(d2v.divide(pv));\n+            delta = N1.multiply((N.multiply(H)).subtract(G2));\n+            // choose a denominator larger in magnitude\n+            Complex deltaSqrt = delta.sqrt();\n+            Complex dplus = G.add(deltaSqrt);\n+            Complex dminus = G.subtract(deltaSqrt);\n+            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+            // Perturb z if denominator is zero, for instance,\n+            // p(x) = x^3 + 1, z = 0.\n+            if (denominator.equals(new Complex(0.0, 0.0))) {\n+                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n+                oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY);\n+            } else {\n+                oldz = z;\n+                z = z.subtract(N.divide(denominator));\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * Muller's Method</a> for root finding of real univariate functions. For\n+ * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n+ * chapter 3.\n+ * <p>\n+ * Muller's method applies to both real and complex functions, but here we\n+ * restrict ourselves to real functions. Methods solve() and solve2() find\n+ * real zeros, using different ways to bypass complex arithmetics.</p>\n+ *\n+ * @version $Revision: 729291 $ $Date: 2008-12-24 11:47:53 +0100 (mer., 24 d\u00e9c. 2008) $\n+ * @since 1.2\n+ */\n+public class MullerSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 7768903775784754323L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public MullerSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public MullerSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Original Muller's method would have function evaluation at complex point.\n+     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n+     * condition is one way to go: by requiring bracketing in every iteration,\n+     * the newly computed approximation is guaranteed to be real.</p>\n+     * <p>\n+     * Normally Muller's method converges quadratically in the vicinity of a\n+     * zero, however it may be very slow in regions far away from zeros. For\n+     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n+     * bisection as a safety backup if it performs very poorly.</p>\n+     * <p>\n+     * The formulas here use divided differences directly.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // [x0, x2] is the bracketing interval in each iteration\n+        // x1 is the last approximation and an interpolation point in (x0, x2)\n+        // x is the new root approximation and new x1 for next round\n+        // d01, d12, d012 are divided differences\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x2 = max; y2 = f.value(x2);\n+        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // Muller's method employs quadratic interpolation through\n+            // x0, x1, x2 and x is the zero of the interpolating parabola.\n+            // Due to bracketing condition, this parabola must have two\n+            // real roots and we choose one in [x0, x2] to be x.\n+            d01 = (y1 - y0) / (x1 - x0);\n+            d12 = (y2 - y1) / (x2 - x1);\n+            d012 = (d12 - d01) / (x2 - x0);\n+            c1 = d01 + (x1 - x0) * d012;\n+            delta = c1 * c1 - 4 * y1 * d012;\n+            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n+            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            // xplus and xminus are two roots of parabola and at least\n+            // one of them should lie in (x0, x2)\n+            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // Bisect if convergence is too slow. Bisection would waste\n+            // our calculation of x, hopefully it won't happen often.\n+            // the real number equality test x == x1 is intentional and\n+            // completes the proximity tests above it\n+            boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\n+                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\n+                             (x == x1);\n+            // prepare the new bracketing interval for next iteration\n+            if (!bisect) {\n+                x0 = x < x1 ? x0 : x1;\n+                y0 = x < x1 ? y0 : y1;\n+                x2 = x > x1 ? x2 : x1;\n+                y2 = x > x1 ? y2 : y1;\n+                x1 = x; y1 = y;\n+                oldx = x;\n+            } else {\n+                double xm = 0.5 * (x0 + x2);\n+                double ym = f.value(xm);\n+                if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n+                    x2 = xm; y2 = ym;\n+                } else {\n+                    x0 = xm; y0 = ym;\n+                }\n+                x1 = 0.5 * (x0 + x2);\n+                y1 = f.value(x1);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.</p>\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     * @deprecated replaced by {@link #solve2(UnivariateRealFunction, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n+    public double solve2(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve2(f, min, max);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.</p>\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve2(final UnivariateRealFunction f,\n+                         final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // x2 is the last root approximation\n+        // x is the new approximation and new x2 for next round\n+        // x0 < x1 < x2 does not hold here\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double q, A, B, C, delta, denominator, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x1 = max; y1 = f.value(x1);\n+        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y1 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // quadratic interpolation through x0, x1, x2\n+            q = (x2 - x1) / (x1 - x0);\n+            A = q * (y2 - (1 + q) * y1 + q * y0);\n+            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            C = (1 + q) * y2;\n+            delta = B * B - 4 * A * C;\n+            if (delta >= 0.0) {\n+                // choose a denominator larger in magnitude\n+                double dplus = B + Math.sqrt(delta);\n+                double dminus = B - Math.sqrt(delta);\n+                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n+            } else {\n+                // take the modulus of (B +/- Math.sqrt(delta))\n+                denominator = Math.sqrt(B * B - delta);\n+            }\n+            if (denominator != 0) {\n+                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n+                // perturb x if it exactly coincides with x1 or x2\n+                // the equality tests here are intentional\n+                while (x == x1 || x == x2) {\n+                    x += absoluteAccuracy;\n+                }\n+            } else {\n+                // extremely rare case, get a random number to skip it\n+                x = min + Math.random() * (max - min);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the next iteration\n+            x0 = x1; y0 = y1;\n+            x1 = x2; y1 = y2;\n+            x2 = x; y2 = y;\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n+ * Newton's Method</a> for finding zeros of real univariate functions. \n+ * <p> \n+ * The function should be continuous but not necessarily smooth.</p>\n+ *\n+ * @version $Revision: 729291 $ $Date: 2008-12-24 11:47:53 +0100 (mer., 24 d\u00e9c. 2008) $\n+ */\n+public class NewtonSolver extends UnivariateRealSolverImpl {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7579593514004764309L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public NewtonSolver(DifferentiableUnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public NewtonSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException  {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, startValue);\n+    }\n+\n+    /**\n+     * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if min is not less than max\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, UnivariateRealSolverUtils.midpoint(min, max));\n+    }\n+\n+    /**\n+     * Find a zero near the value <code>startValue</code>.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval (ignored).\n+     * @param max the upper bound for the interval (ignored).\n+     * @param startValue the start value to use.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if startValue is not between min and max or\n+     * if function is not a {@link DifferentiableUnivariateRealFunction} instance\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        try {\n+\n+            final UnivariateRealFunction derivative =\n+                ((DifferentiableUnivariateRealFunction) f).derivative();\n+            clearResult();\n+            verifySequence(min, startValue, max);\n+\n+            double x0 = startValue;\n+            double x1;\n+\n+            int i = 0;\n+            while (i < maximalIterationCount) {\n+\n+                x1 = x0 - (f.value(x0) / derivative.value(x0));\n+                if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n+                    setResult(x1, i);\n+                    return x1;\n+                }\n+\n+                x0 = x1;\n+                ++i;\n+            }\n+\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n+        } catch (ClassCastException cce) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\",\n+                                                                      null);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RiddersMethod.html\">\n+ * Ridders' Method</a> for root finding of real univariate functions. For\n+ * reference, see C. Ridders, <i>A new algorithm for computing a single root\n+ * of a real continuous function </i>, IEEE Transactions on Circuits and\n+ * Systems, 26 (1979), 979 - 980.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ * @since 1.2\n+ */\n+public class RiddersSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = -1556464494585337088L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public RiddersSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public RiddersSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a root in the given interval.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // [x1, x2] is the bracketing interval in each iteration\n+        // x3 is the midpoint of [x1, x2]\n+        // x is the new root approximation and an endpoint of the new interval\n+        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n+\n+        x1 = min; y1 = f.value(x1);\n+        x2 = max; y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y1 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // calculate the new root approximation\n+            x3 = 0.5 * (x1 + x2);\n+            y3 = f.value(x3);\n+            if (Math.abs(y3) <= functionValueAccuracy) {\n+                setResult(x3, i);\n+                return result;\n+            }\n+            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n+            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n+                         (x3 - x1) / Math.sqrt(delta);\n+            x = x3 - correction;                // correction != 0\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the new interval for next iteration\n+            // Ridders' method guarantees x1 < x < x2\n+            if (correction > 0.0) {             // x1 < x < x3\n+                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n+                    x2 = x; y2 = y;\n+                } else {\n+                    x1 = x; x2 = x3;\n+                    y1 = y; y2 = y3;\n+                }\n+            } else {                            // x3 < x < x2\n+                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n+                    x1 = x; y1 = y;\n+                } else {\n+                    x1 = x3; x2 = x;\n+                    y1 = y3; y2 = y;\n+                }\n+            }\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Implements a modified version of the \n+ * <a href=\"http://mathworld.wolfram.com/SecantMethod.html\">secant method</a>\n+ * for approximating a zero of a real univariate function.  \n+ * <p>\n+ * The algorithm is modified to maintain bracketing of a root by successive\n+ * approximations. Because of forced bracketing, convergence may be slower than\n+ * the unrestricted secant algorithm. However, this implementation should in\n+ * general outperform the \n+ * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n+ * regula falsi method.</a></p>\n+ * <p>\n+ * The function is assumed to be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ */\n+public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 2477470651270304246L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public SecantSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public SecantSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a zero in the given interval.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use (ignored)\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+    \n+    /**\n+     * Find a zero in the given interval.\n+     * @param f the function to solve\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        \n+        // Index 0 is the old approximation for the root.\n+        // Index 1 is the last calculated approximation  for the root.\n+        // Index 2 is a bracket for the root with respect to x0.\n+        // OldDelta is the length of the bracketing interval of the last\n+        // iteration.\n+        double x0 = min;\n+        double x1 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        \n+        // Verify bracketing\n+        if (y0 * y1 >= 0) {\n+            throw new IllegalArgumentException\n+            (\"Function values at endpoints do not have different signs.\" +\n+                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n+                    \"  Values: [\" + y0 + \",\" + y1 + \"]\");       \n+        }\n+        \n+        double x2 = x0;\n+        double y2 = y0;\n+        double oldDelta = x2 - x1;\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            if (Math.abs(oldDelta) <\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double delta;\n+            if (Math.abs(y1) > Math.abs(y0)) {\n+                // Function value increased in last iteration. Force bisection.\n+                delta = 0.5 * oldDelta;\n+            } else {\n+                delta = (x0 - x1) / (1 - y0 / y1);\n+                if (delta / oldDelta > 1) {\n+                    // New approximation falls outside bracket.\n+                    // Fall back to bisection.\n+                    delta = 0.5 * oldDelta;\n+                }\n+            }\n+            x0 = x1;\n+            y0 = y1;\n+            x1 = x1 + delta;\n+            y1 = f.value(x1);\n+            if ((y1 > 0) == (y2 > 0)) {\n+                // New bracket is (x0,x1).                    \n+                x2 = x0;\n+                y2 = y0;\n+            }\n+            oldDelta = x2 - x1;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * <p>\n+ * Implementations will search for only one zero in the given interval.</p>\n+ *  \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (Sun, 07 Dec 2008) $\n+ */\n+public interface UnivariateRealSolver {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * <p>\n+     * Usually a high iteration count indicates convergence problems. However,\n+     * the \"reasonable value\" varies widely for different solvers.  Users are\n+     * advised to use the default value supplied by the solver.</p>\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is exceeded.</p>\n+     *  \n+     * @param count maximum number of iterations\n+     */\n+    void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the solver implementation.</p>\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the absolute accuracy.\n+     * <p>\n+     * The default is usually choosen so that roots in the interval\n+     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n+     * expected absolute value of your roots is of much smaller magnitude, set\n+     * this to a smaller value.</p>\n+     * <p>\n+     * Solvers are advised to do a plausibility check with the relative\n+     * accuracy, but clients should not rely on this.</p>\n+     *  \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    void setAbsoluteAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     * \n+     * @return the accuracy\n+     */\n+    double getAbsoluteAccuracy();\n+\n+    /**\n+     * Reset the absolute accuracy to the default.\n+     * <p>\n+     * The default value is provided by the solver implementation.</p>\n+     */\n+    void resetAbsoluteAccuracy();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * <p>\n+     * This is used to stop iterations if the absolute accuracy can't be\n+     * achieved due to large values or short mantissa length.</p>\n+     * <p>\n+     * If this should be the primary criterion for convergence rather then a\n+     * safety measure, set the absolute accuracy to a ridiculously small value,\n+     * like 1E-1000.</p>\n+     * \n+     * @param accuracy the relative accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    void setRelativeAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    void resetRelativeAccuracy();\n+\n+    /**\n+     * Set the function value accuracy.\n+     * <p>\n+     * This is used to determine when an evaluated function value or some other\n+     * value which is used as divisor is zero.</p>\n+     * <p>\n+     * This is a safety guard and it shouldn't be necessary to change this in\n+     * general.</p>\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    void setFunctionValueAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual function value accuracy.\n+     * @return the accuracy\n+     */\n+    double getFunctionValueAccuracy();\n+\n+    /**\n+     * Reset the actual function accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    void resetFunctionValueAccuracy();\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n+    double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max)\n+        throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n+    double solve(double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Get the result of the last run of the solver.\n+     * \n+     * @return the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Get the result of the last run of the solver.\n+     * \n+     * @return the value of the function at the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getFunctionValue();\n+\n+    /**\n+     * Get the number of iterations in the last run of the solver.\n+     * <p>\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the function is evaluated\n+     * properly, and whether another solver is more amenable to the\n+     * problem.</p>\n+     * \n+     * @return the last iteration count.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    int getIterationCount();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Abstract factory class used to create {@link UnivariateRealSolver} instances.\n+ * <p>\n+ * Solvers implementing the following algorithms are supported:\n+ * <ul>\n+ * <li>Bisection</li>\n+ * <li>Brent's method</li>\n+ * <li>Secant method</li>\n+ * </ul>\n+ * Concrete factories extending this class also specify a default solver, instances of which\n+ * are returned by <code>newDefaultSolver()</code>.</p>\n+ * <p>\n+ * Common usage:<pre>\n+ * SolverFactory factory = UnivariateRealSolverFactory.newInstance();</p>\n+ *\n+ * // create a Brent solver to use\n+ * BrentSolver solver = factory.newBrentSolver();\n+ * </pre>\n+ *\n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ */\n+public abstract class UnivariateRealSolverFactory {\n+    /**\n+     * Default constructor.\n+     */\n+    protected UnivariateRealSolverFactory() {\n+    }\n+\n+    /**\n+     * Create a new factory.\n+     * @return a new factory.\n+     */\n+    public static UnivariateRealSolverFactory newInstance() {\n+        return new UnivariateRealSolverFactoryImpl();\n+    }\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * actual solver returned is determined by the underlying factory.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newDefaultSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the bisection method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newBisectionSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the Brent method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newBrentSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of Newton's Method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newNewtonSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the secant method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newSecantSolver();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * A concrete {@link  UnivariateRealSolverFactory}.  This is the default solver factory\n+ * used by commons-math.\n+ * <p>\n+ * The default solver returned by this factory is a {@link BrentSolver}.</p>\n+ *\n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ */\n+public class UnivariateRealSolverFactoryImpl extends UnivariateRealSolverFactory {\n+        \n+    /**\n+     * Default constructor.\n+     */\n+    public UnivariateRealSolverFactoryImpl() {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newDefaultSolver() {\n+        return newBrentSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newBisectionSolver() {\n+        return new BisectionSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newBrentSolver() {\n+        return new BrentSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newNewtonSolver() {\n+        return new NewtonSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newSecantSolver() {\n+        return new SecantSolver();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *  \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (Sun, 07 Dec 2008) $\n+ */\n+public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver,\n+    Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 1112491292565386596L;\n+    \n+    /** Maximum absolute error. */\n+    protected double absoluteAccuracy;\n+\n+    /** Maximum relative error. */\n+    protected double relativeAccuracy;\n+\n+    /** Maximum error of function. */\n+    protected double functionValueAccuracy;\n+\n+    /** Maximum number of iterations. */\n+    protected int maximalIterationCount;\n+\n+    /** Default maximum absolute error. */\n+    protected double defaultAbsoluteAccuracy;\n+\n+    /** Default maximum relative error. */\n+    protected double defaultRelativeAccuracy;\n+\n+    /** Default maximum error of function. */\n+    protected double defaultFunctionValueAccuracy;\n+\n+    /** Default maximum number of iterations. */\n+    protected int defaultMaximalIterationCount;\n+\n+    /** Indicates where a root has been computed. */\n+    protected boolean resultComputed = false;\n+\n+    /** The last computed root. */\n+    protected double result;\n+\n+    /** Value of the function at the last computed result. */\n+    protected double functionValue;\n+\n+    // Mainly for test framework.\n+    /** The last iteration count. */\n+    protected int iterationCount;\n+\n+    /** The function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method. */\n+    @Deprecated\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param f the function to solve.\n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    protected UnivariateRealSolverImpl(\n+        UnivariateRealFunction f,\n+        int defaultMaximalIterationCount,\n+        double defaultAbsoluteAccuracy) {\n+        \n+        if (f == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\",\n+                                                                      null);\n+        }\n+        this.f = f;\n+\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1E-14;\n+        this.defaultFunctionValueAccuracy = 1E-15;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected UnivariateRealSolverImpl(int defaultMaximalIterationCount,\n+                                       double defaultAbsoluteAccuracy) {\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1E-14;\n+        this.defaultFunctionValueAccuracy = 1E-15;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Access the last computed root.\n+     * \n+     * @return the last computed root\n+     * @throws IllegalStateException if no root has been computed\n+     */\n+    public double getResult() {\n+        if (resultComputed) {\n+            return result;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /**\n+     * Access the value of the function at the last computed result.\n+     * \n+     * @return the function value at the last result.\n+     * @throws IllegalStateException if no value has been computed.\n+     */\n+    public double getFunctionValue() {\n+        if (resultComputed) {\n+            return functionValue;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /**\n+     * Access the last iteration count.\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if no root has been computed\n+     *  \n+     */\n+    public int getIterationCount() {\n+        if (resultComputed) {\n+            return iterationCount;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param x the result to set\n+     * @param fx the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double x, double fx, int iterationCount) {\n+        this.result = x;\n+        this.functionValue = fx;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+    /**\n+     * Set the absolute accuracy.\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setAbsoluteAccuracy(double accuracy) {\n+        absoluteAccuracy = accuracy;\n+    }\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     * \n+     * @return the accuracy\n+     */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /**\n+     * Reset the absolute accuracy to the default.\n+     */\n+    public void resetAbsoluteAccuracy() {\n+        absoluteAccuracy = defaultAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * \n+     * @param count maximum number of iterations\n+     */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Set the relative accuracy.\n+     * \n+     * @param accuracy the relative accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setRelativeAccuracy(double accuracy) {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+    /**\n+     * Set the function value accuracy.\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setFunctionValueAccuracy(double accuracy) {\n+        functionValueAccuracy = accuracy;\n+    }\n+\n+    /**\n+     * Get the actual function value accuracy.\n+     * @return the accuracy\n+     */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /**\n+     * Reset the actual function accuracy to the default.\n+     */\n+    public void resetFunctionValueAccuracy() {\n+        functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+    \n+    \n+    /**\n+     * Returns true iff the function takes opposite signs at the endpoints.\n+     * \n+     * @param lower  the lower endpoint \n+     * @param upper  the upper endpoint\n+     * @param f the function\n+     * @return true if f(lower) * f(upper) < 0\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected boolean isBracketing(double lower, double upper, \n+            UnivariateRealFunction f) throws FunctionEvaluationException {\n+        double f1 = f.value(lower);\n+        double f2 = f.value(upper);\n+        return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n+    }\n+    \n+    /**\n+     * Returns true if the arguments form a (strictly) increasing sequence\n+     * \n+     * @param start  first number\n+     * @param mid   second number\n+     * @param end  third number\n+     * @return true if the arguments form an increasing sequence\n+     */\n+    protected boolean isSequence(double start, double mid, double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval, \n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifyInterval(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"Endpoints do not specify an interval: [\" + lower + \n+                        \",\" + upper + \"]\");\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that <code>lower < initial < upper</code>\n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param initial initial value\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifySequence(double lower, double initial, double upper) {\n+        if (!isSequence(lower, initial, upper)) {\n+            throw new IllegalArgumentException\n+                (\"Invalid interval, initial value parameters:  lower=\" + \n+                   lower + \" initial=\" + initial + \" upper=\" + upper);\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval and the function takes\n+     * opposite signs at the enpoints, throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @param f function\n+     * @throws IllegalArgumentException\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected void verifyBracketing(double lower, double upper, \n+            UnivariateRealFunction f) throws FunctionEvaluationException {\n+        \n+        verifyInterval(lower, upper);\n+        if (!isBracketing(lower, upper, f)) {\n+            throw new IllegalArgumentException\n+            (\"Function values at endpoints do not have different signs.\" +\n+                    \"  Endpoints: [\" + lower + \",\" + upper + \"]\" + \n+                    \"  Values: [\" + f.value(lower) + \",\" + f.value(upper) + \"]\");       \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Utility routines for {@link UnivariateRealSolver} objects.\n+ * \n+ * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (dim., 07 d\u00e9c. 2008) $\n+ */\n+public class UnivariateRealSolverUtils {\n+    /**\n+     * Default constructor.\n+     */\n+    private UnivariateRealSolverUtils() {\n+        super();\n+    }\n+    \n+    /** Cached solver factory */\n+    private static UnivariateRealSolverFactory factory = null;\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function.\n+     * @param x0 the lower bound for the interval.\n+     * @param x1 the upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws ConvergenceException if the iteration count was exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function\n+     * @throws IllegalArgumentException if f is null or the endpoints do not\n+     * specify a valid interval\n+     */\n+    public static double solve(UnivariateRealFunction f, double x0, double x1)\n+    throws ConvergenceException, FunctionEvaluationException {\n+        setup(f);\n+        return factory.newDefaultSolver().solve(f, x0, x1);\n+    }\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function\n+     * @param x0 the lower bound for the interval\n+     * @param x1 the upper bound for the interval\n+     * @param absoluteAccuracy the accuracy to be used by the solver\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if f is null, the endpoints do not \n+     * specify a valid interval, or the absoluteAccuracy is not valid for the\n+     * default solver\n+     */\n+    public static double solve(UnivariateRealFunction f, double x0, double x1,\n+            double absoluteAccuracy) throws ConvergenceException, \n+            FunctionEvaluationException {    \n+       \n+        setup(f);\n+        UnivariateRealSolver solver = factory.newDefaultSolver();\n+        solver.setAbsoluteAccuracy(absoluteAccuracy);\n+        return solver.solve(f, x0, x1);\n+    }\n+\n+    /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code></li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n+     * -- ConvergenceException </li>\n+     * </ul></p>\n+     * <p>\n+     * <strong>Note: </strong> this method can take \n+     * <code>Integer.MAX_VALUE</code> iterations to throw a \n+     * <code>ConvergenceException.</code>  Unless you are confident that there\n+     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n+     * near <code>initial,</code> it is better to use \n+     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n+     * explicitly specifying the maximum number of iterations.</p>\n+     *\n+     * @param function the function\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @return a two element array holding {a, b}\n+     * @throws ConvergenceException if a root can not be bracketted\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n+     */\n+    public static double[] bracket(UnivariateRealFunction function, \n+            double initial, double lowerBound, double upperBound) \n+    throws ConvergenceException, FunctionEvaluationException {\n+        return bracket( function, initial, lowerBound, upperBound,\n+            Integer.MAX_VALUE ) ;\n+    }\n+\n+     /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code> </li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> maximumIterations</code> iterations elapse \n+     * -- ConvergenceException </li></ul></p>\n+     * \n+     * @param function the function\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @param maximumIterations maximum number of iterations to perform\n+     * @return a two element array holding {a, b}.\n+     * @throws ConvergenceException if the algorithm fails to find a and b\n+     * satisfying the desired conditions\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n+     */\n+    public static double[] bracket(UnivariateRealFunction function,\n+            double initial, double lowerBound, double upperBound, \n+            int maximumIterations) throws ConvergenceException, \n+            FunctionEvaluationException {\n+        \n+        if (function == null) {\n+            throw new IllegalArgumentException (\"function is null.\");\n+        }\n+        if (maximumIterations <= 0)  {\n+            throw new IllegalArgumentException\n+            (\"bad value for maximumIterations: \" + maximumIterations);\n+        }\n+        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n+            throw new IllegalArgumentException\n+            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n+              \" initial=\" + initial + \" upperBound=\" + upperBound);\n+        }\n+        double a = initial;\n+        double b = initial;\n+        double fa;\n+        double fb;\n+        int numIterations = 0 ;\n+    \n+        do {\n+            a = Math.max(a - 1.0, lowerBound);\n+            b = Math.min(b + 1.0, upperBound);\n+            fa = function.value(a);\n+            \n+            fb = function.value(b);\n+            numIterations++ ;\n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n+                ((a > lowerBound) || (b < upperBound)));\n+   \n+        if (fa * fb >= 0.0 ) {\n+            throw new ConvergenceException\n+            (\"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n+             new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),\n+                            Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),\n+                            Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });\n+        }\n+        \n+        return new double[]{a, b};\n+    }\n+\n+    /**\n+     * Compute the midpoint of two values.\n+     * \n+     * @param a first value.\n+     * @param b second value.\n+     * @return the midpoint. \n+     */\n+    public static double midpoint(double a, double b) {\n+        return (a + b) * .5;\n+    }\n+    \n+    /**\n+     * Checks to see if f is null, throwing IllegalArgumentException if so.\n+     * Also initializes factory if factory is null.\n+     * \n+     * @param f  input function\n+     * @throws IllegalArgumentException if f is null\n+     */\n+    private static void setup(UnivariateRealFunction f) {\n+       \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"function can not be null.\");    \n+        }\n+        \n+        if (factory == null) {\n+            factory = UnivariateRealSolverFactory.newInstance();\n+        }       \n+    }\n+}\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealSolverUtils;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n \n /**\n  * Base class for continuous distributions.  Default implementations are\n--- a/src/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/java/org/apache/commons/math/ode/events/EventState.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.analysis.BrentSolver;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n ", "timestamp": 1232284042, "metainfo": ""}