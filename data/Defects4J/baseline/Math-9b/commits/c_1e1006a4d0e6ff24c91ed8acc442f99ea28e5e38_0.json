{"sha": "1e1006a4d0e6ff24c91ed8acc442f99ea28e5e38", "log": "Modified to extend AbstractContinuousDistribution. Changed to throw IllegalArgumentException instead of returning NaN for inverseCumulativeProbability argument not in [0,1].   ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n /**\n  * The default implementation of {@link ExponentialDistribution}\n  * \n- * @version $Revision: 1.16 $ $Date: 2004/06/02 00:15:16 $\n+ * @version $Revision: 1.17 $ $Date: 2004/06/06 16:38:05 $\n  */\n-public class ExponentialDistributionImpl\n-    implements ExponentialDistribution, Serializable  {\n+public class ExponentialDistributionImpl extends AbstractContinuousDistribution\n+    implements ExponentialDistribution, Serializable {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = 2401296428283614780L;\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      * @throws MathException if the inverse cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1.\n      */\n-    public double inverseCumulativeProbability(double p) throws MathException{\n+    public double inverseCumulativeProbability(double p) throws MathException {\n         double ret;\n         \n         if (p < 0.0 || p > 1.0) {\n-            ret = Double.NaN;\n+            throw new IllegalArgumentException\n+                (\"probability argument must be between 0 and 1 (inclusive)\");\n         } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n     }\n     \n     /**\n-     * For this disbution, X, this method returns P(x0 &lt; X &lt; x1).\n-     * @param x0 the lower bound\n-     * @param x1 the upper bound\n-     * @return the cumulative probability. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n-    public double cumulativeProbability(double x0, double x1) throws MathException{\n-        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+    \n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: exponential is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        if (p < .5) {\n+            // use mean\n+            return getMean();\n+        } else {\n+            // use max\n+            return Double.MAX_VALUE;\n+        }\n+    }\n+    \n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n+        // TODO: try to improve on this estimate\n+        // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n+        if (p < .5) {\n+            // use 1/2 mean\n+            return getMean() * .5;\n+        } else {\n+            // use mean\n+            return getMean();\n+        }\n     }\n }", "timestamp": 1086539885, "metainfo": ""}