{"sha": "9ca7fb78ef078e05e164cab0ad742c6ae49374ae", "log": "fixed some NaN appearing in eigenvectors when null pivots occurred in dstqds or dqds algorithms this is a partial fix for MATH-297 but not a complete one as for example computing the eigendecomposition if identity leads to three times the same vector ... JIRA: MATH-297  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n         for (int i = 0; i < nM1; ++i) {\n             final double di   = d[i];\n             final double li   = l[i];\n+            final double ldi  = li * di;\n             final double diP1 = di + si;\n-            final double liP1 = li * di / diP1;\n+            final double liP1 = ldi / diP1;\n             work[sixI]        = si;\n             work[sixI + 1]    = diP1;\n             work[sixI + 2]    = liP1;\n             si = li * liP1 * si - lambda;\n             sixI += 6;\n+        }\n+        if (Double.isNaN(si)) {\n+            // one of the pivot was null, use a slower but safer version of dstqds\n+            si = -lambda;\n+            sixI = 0;\n+            for (int i = 0; i < nM1; ++i) {\n+                final double di   = d[i];\n+                final double li   = l[i];\n+                final double ldi  = li * di;\n+                double diP1 = di + si;\n+                if (Math.abs(diP1) < minPivot) {\n+                    diP1 = -minPivot;\n+                }\n+                final double liP1 = ldi / diP1;\n+                work[sixI]        = si;\n+                work[sixI + 1]    = diP1;\n+                work[sixI + 2]    = liP1;\n+                si = li * ((liP1 == 0) ? li * di : liP1 * si) - lambda;\n+                sixI += 6;\n+            }\n         }\n         work[6 * nM1 + 1] = d[nM1] + si;\n         work[6 * nM1]     = si;\n             pi = pi * t - lambda;\n             sixI -= 6;\n         }\n+        if (Double.isNaN(pi)) {\n+            // one of the pivot was null, use a slower but safer version of dqds\n+            pi = d[nM1] - lambda;\n+            sixI = 6 * (nM1 - 1);\n+            for (int i = nM1 - 1; i >= 0; --i) {\n+                final double di   = d[i];\n+                final double li   = l[i];\n+                double diP1 = di * li * li + pi;\n+                if (Math.abs(diP1) < minPivot) {\n+                    diP1 = -minPivot;\n+                }\n+                final double t    = di / diP1;\n+                work[sixI +  9]   = pi;\n+                work[sixI + 10]   = diP1;\n+                work[sixI +  5]   = li * t;\n+                pi = ((t == 0) ? di : pi * t) - lambda;\n+                sixI -= 6;\n+            }\n+        }\n         work[3] = pi;\n         work[4] = pi;\n     }", "timestamp": 1259529710, "metainfo": ""}