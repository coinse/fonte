{"sha": "8520b3253853057e9cc0eb1eec7d797b99657635", "log": "Improved javadoc, simplified implemenentation.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n \n /**\n- * FirstMoment.java\n+ * Computes the first moment (arithmetic mean).  Uses the definitional formula:\n+ * <p>\n+ * mean = sum(x_i) / n\n+ * <p>\n+ * where <code>n</code> is the number of observations.\n+ * <p>\n+ * To limit numeric errors, the value of the statistic is computed using the\n+ * following recursive updating algorithm:\n+ * <p>\n+ * <ol>\n+ * <li>Initialize <code>m = </code> the first value</li>\n+ * <li>For each additional value, update using <br>\n+ *   <code>m = m + (new value - m) / (number of observations)</code></li>\n+ * </ol>\n  *\n- * The FirstMoment (arithmentic mean) is calculated using the following\n- * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n- * recursive strategy\n- * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.15 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.16 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class FirstMoment extends AbstractStorelessUnivariateStatistic implements Serializable{\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = -803343206421984070L; \n     \n-    /** count of values that have been added */\n+    /** Count of values that have been added */\n     protected long n = 0;\n \n-    /** first moment of values that have been added */\n+    /** First moment of values that have been added */\n     protected double m1 = Double.NaN;\n-\n+    \n+    /** \n+     * Deviation of most recently added value from previous first moment.\n+     * Retained to prevent repeated computation in higher order moments.\n+     */\n+    protected double dev = Double.NaN;\n+    \n     /**\n-     * temporary internal state made available for\n-     * higher order moments\n+     * Deviation of most recently added value from previous first moment,\n+     * normalized by previous sample size.  Retained to prevent repeated\n+     * computation in higher order moments\n      */\n-    protected double dev = 0.0;\n-\n-    /**\n-     * temporary internal state made available for\n-     * higher order moments\n-     */\n-    protected double v = 0.0;\n-\n-    /**\n-     * temporary internal state made available for\n-     * higher order moments\n-     */\n-    protected double n0 = 0.0;\n+    protected double nDev = Double.NaN;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public void increment(final double d) {\n-        if (n < 1) {\n+        if (n == 0) {\n             m1 = 0.0;\n         }\n-\n         n++;\n+        double n0 = (double) n;\n         dev = d - m1;\n-        n0 = (double) n;\n-        v = dev / n0;\n-\n-        m1 += v;\n+        nDev = dev / n0;\n+        m1 += nDev;\n     }\n \n     /**\n     public void clear() {\n         m1 = Double.NaN;\n         n = 0;\n-        dev = 0.0;\n-        v = 0.0;\n-        n0 = 0.0;\n+        dev = Double.NaN;\n+        nDev = Double.NaN;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n import java.io.Serializable;\n \n /**\n- * The FourthMoment is calculated using the following\n- * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n- * recursive strategy\n- * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.17 $ $Date: 2004/06/23 16:26:15 $\n+ * Computes a statistic related to the Fourth Central Moment.  Specifically,\n+ * what is computed is the sum of \n+ * <p>\n+ * (x_i - xbar) ^ 4,\n+ * <p>\n+ * where the x_i are the \n+ * sample observations and xbar is the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> m2 = previous value of {@link ThirdMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value - 4 * (dev/n) * m3 + 6 * (dev/n)^2 * m2 + <br>\n+ * [n^2 - 3 * (n-1)] * dev^4 * (n-1) / n^3\n+ * \n+ * @version $Revision: 1.18 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class FourthMoment extends ThirdMoment implements Serializable{\n \n         \n     /** fourth moment of values that have been added */\n     protected double m4 = Double.NaN;\n-\n-    /** temporary internal state made available for higher order moments */\n-    protected double prevM3 = 0.0;\n-\n-    /** temporary internal state made available for higher order moments */\n-    protected double n3 = 0.0;\n-\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n             m1 = 0.0;\n         }\n \n-        /* retain previous m3 */\n-        prevM3 = m3;\n+        double prevM3 = m3;\n+        double prevM2 = m2;\n+        \n+        super.increment(d);\n+        \n+        double n0 = (double) n;\n \n-        /* increment m1, m2 and m3 (and prevM2, _n0, _n1, _n2, _v, _v2) */\n-        super.increment(d);\n-\n-        n3 = (double) (n - 3);\n-\n-        m4 = m4 - (4.0 * v * prevM3) + (6.0 * v2 * prevM2) +\n-            ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n+        m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +\n+            ((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);\n     }\n \n     /**\n     public void clear() {\n         super.clear();\n         m4 = Double.NaN;\n-        prevM3 = 0.0;\n-        n3 = 0.0;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n  *  Note that this statistic is undefined for n < 4.  <code>Double.Nan</code> is returned when\n  *  there is not sufficient data to compute the statistic.\n  *\n- * @version $Revision: 1.22 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.23 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n         double kurtosis = Double.NaN;\n         if (moment.getN() > 3) {\n             double variance = moment.m2 / (double) (moment.n - 1);\n-                \n                 if (moment.n <= 3 || variance < 10E-20) {\n                     kurtosis = 0.0;\n                 } else {\n+                    double n = (double) moment.n;\n                     kurtosis =\n-                        (moment.n0 * (moment.n0 + 1) * moment.m4 -\n-                                3 * moment.m2 * moment.m2 * moment.n1) /\n-                                (moment.n1 * moment.n2 * moment.n3 * variance * variance);\n+                        (n * (n + 1) * moment.m4 -\n+                                3 * moment.m2 * moment.m2 * (n - 1)) /\n+                                ((n - 1) * (n -2) * (n -3) * variance * variance);\n                 }\n         }\n         return kurtosis;\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n import java.io.Serializable;\n \n /**\n- * The SecondMoment is calculated using the following\n- * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n- * recursive strategy\n- * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.16 $ $Date: 2004/06/23 16:26:15 $\n+ * Computes a statistic related to the Second Central Moment.  Specifically,\n+ * what is computed is the sum of squared deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value + dev^2 * (n -1) / n.\n+ * \n+ * @version $Revision: 1.17 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class SecondMoment extends FirstMoment implements Serializable {\n \n     /** second moment of values that have been added */\n     protected double m2 = Double.NaN;\n \n-    /** temporary internal state made availabel for higher order moments */\n-    protected double n1 = 0.0;\n-\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n         if (n < 1) {\n             m1 = m2 = 0.0;\n         }\n-\n-        /* increment m1 and _n0, _dev,  _v) */\n         super.increment(d);\n-\n-        n1 = n0 - 1;\n-\n-        /* increment and return m2 */\n-        m2 += n1 * dev * v;\n-\n+        m2 += ((double) n - 1) * dev * nDev;\n     }\n \n     /**\n     public void clear() {\n         super.clear();\n         m2 = Double.NaN;\n-        n1 = 0.0;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n  *  <p>\n  *  skewness = [n / (n -1) (n - 2)] sum[(x_i - mean)^3] / std^3\n  *  <p>\n- *  where n is the number of values, mean is the {@link Mean} and std is the {@link StandardDeviation}\n+ *  where n is the number of values, mean is the {@link Mean} and std is the \n+ * {@link StandardDeviation}\n  *\n- * @version $Revision: 1.21 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.22 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = 7101857578996691352L;    \n     \n-    /** */\n+    /** Third moment on which this statistic is based */\n     protected ThirdMoment moment = null;\n \n-    /** */\n+     /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.\n+    */\n     protected boolean incMoment = true;\n-\n-    /** */\n-    protected double skewness = Double.NaN;\n-\n-    /** */\n-    private long n = 0;\n \n     /**\n      * Constructs a Skewness\n      * @return the skewness of the available values.\n      */\n     public double getResult() {\n-        if (n < moment.n) {\n-            if (moment.n <= 0) {\n-                skewness = Double.NaN;\n-            }\n-\n-            double variance =\n-                (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n-\n-            if (moment.n <= 2 || variance < 10E-20) {\n-                skewness = 0.0;\n-            } else {\n-                skewness = (moment.n0 * moment.m3) /\n-                    (moment.n1 * moment.n2 * Math.sqrt(variance) * variance);\n-            }\n-            n = moment.n;\n+        \n+        if (moment.n < 3) {\n+            return Double.NaN;\n+        }\n+        double variance = moment.m2 / (double) (moment.n - 1);\n+        double skewness = Double.NaN;\n+        if (variance < 10E-20) {\n+            skewness = 0.0;\n+        } else {\n+            double n0 = (double) moment.getN();\n+            skewness = (n0 * moment.m3) /\n+            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n         }\n         return skewness;\n     }\n         if (incMoment) {\n             moment.clear();\n         }\n-        skewness = Double.NaN;\n-        n = 0;\n     }\n-\n-    /*UnvariateStatistic Approach */\n-\n-    /** */\n-    Mean mean = new Mean();\n \n     /**\n      * Returns the Skewness of the values array.\n         double skew = Double.NaN;\n \n         if (test(values, begin, length)) {\n-\n+            Mean mean = new Mean();\n             if (length <= 2) {\n                 skew = 0.0;\n             } else {\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n import java.io.Serializable;\n \n /**\n- * The ThirdMoment (arithmentic mean) is calculated using the following\n- * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n- * recursive strategy\n- * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.16 $ $Date: 2004/06/23 16:26:14 $\n+ * Computes a statistic related to the Third Central Moment.  Specifically,\n+ * what is computed is the sum of cubed deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value - 3 * (dev/n) * m2 + (n-1) * (n -2) * (dev^3/n^2)\n+ * \n+ * @version $Revision: 1.17 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class ThirdMoment extends SecondMoment implements Serializable {\n \n     /** third moment of values that have been added */\n     protected double m3 = Double.NaN;\n \n-    /** temporary internal state made availabel for higher order moments */\n-    protected double v2 = 0.0;\n+     /**\n+     * Square of deviation of most recently added value from previous first \n+     * moment, normalized by previous sample size.  Retained to prevent \n+     * repeated computation in higher order moments.  nDevSq = nDev * nDev.\n+     */\n+    protected double nDevSq = Double.NaN;\n \n-    /** temporary internal state made availabel for higher order moments */\n-    protected double n2 = 0.0;\n-\n-    /** temporary internal state made availabel for higher order moments */\n-    protected double prevM2 = 0.0;\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n     public void increment(final double d) {\n         if (n < 1) {\n             m3 = m2 = m1 = 0.0;\n-        }\n-\n-        /* retain a reference to the last m2*/\n-        prevM2 = m2;\n-\n-        /* increment m1 and m2 (and _n0, _n1, _v) */\n+        }  \n+       \n+        double prevM2 = m2;\n         super.increment(d);\n-\n-        v2 = v * v;\n-        n2 = (double) (n - 2);\n-\n-        m3 = m3 - (3.0 * v * prevM2) + (n0 * n1 * n2 * v2 * v);\n-\n+        nDevSq = nDev * nDev;\n+        double n0 = (double) n;\n+        m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;\n     }\n \n     /**\n     public void clear() {\n         super.clear();\n         m3 = Double.NaN;\n-        v2 = 0.0;\n-        n2 = 0.0;\n-        prevM2 = 0.0;\n+        nDevSq = Double.NaN;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  * Chan, T. F. andJ. G. Lewis 1979, <i>Communications of the ACM</i>,\n  * vol. 22 no. 9, pp. 526-531.</a>.\n  *\n- * @version $Revision: 1.21 $ $Date: 2004/06/26 23:33:27 $\n+ * @version $Revision: 1.22 $ $Date: 2004/06/27 19:37:51 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n             } else if (moment.n == 1) {\n                 return 0d;\n             } else {\n-                return moment.m2 / (moment.n0 - 1);\n+                return moment.m2 / ((double) moment.n - 1d);\n             }\n     }\n ", "timestamp": 1088365071, "metainfo": ""}