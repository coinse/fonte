{"sha": "cdb23146e05fad4e688d1cbfc1cc7a44e316930a", "log": "Factored out some redundant code.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.linear.BlockRealMatrix;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optimization.PointVectorValuePair;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public abstract class AbstractLeastSquaresOptimizerAbstractTest {\n+\n+    public abstract AbstractLeastSquaresOptimizer createOptimizer();\n+\n+    @Test\n+    public void testTrivial() {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+        try {\n+            optimizer.guessParametersErrors();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NumberIsTooSmallException ee) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testQRColumnsPermutation() {\n+\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n+                              new double[] { 4.0, 6.0, 1.0 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n+        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testNoDependency() {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 2, 0, 0, 0, 0, 0 },\n+                { 0, 2, 0, 0, 0, 0 },\n+                { 0, 0, 2, 0, 0, 0 },\n+                { 0, 0, 0, 2, 0, 0 },\n+                { 0, 0, 0, 0, 2, 0 },\n+                { 0, 0, 0, 0, 0, 2 }\n+        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        for (int i = 0; i < problem.target.length; ++i) {\n+            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    @Test\n+    public void testOneSet() {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1,  0, 0 },\n+                { -1,  1, 0 },\n+                {  0, -1, 1 }\n+        }, new double[] { 1, 1, 1});\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testTwoSets() {\n+        double epsilon = 1.0e-7;\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  2,  1,   0,  4,       0, 0 },\n+                { -4, -2,   3, -7,       0, 0 },\n+                {  4,  1,  -2,  8,       0, 0 },\n+                {  0, -3, -12, -1,       0, 0 },\n+                {  0,  0,   0,  0, epsilon, 1 },\n+                {  0,  0,   0,  0,       1, 1 }\n+        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+    }\n+\n+    @Test(expected=ConvergenceException.class)\n+    public void testNonInvertible() throws Exception {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1, 2, -3 },\n+                {  2, 1,  3 },\n+                { -3, 0, -9 }\n+        }, new double[] { 1, 1, 1 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+    }\n+\n+    @Test\n+    public void testIllConditioned() {\n+        LinearProblem problem1 = new LinearProblem(new double[][] {\n+                { 10.0, 7.0,  8.0,  7.0 },\n+                {  7.0, 5.0,  6.0,  5.0 },\n+                {  8.0, 6.0, 10.0,  9.0 },\n+                {  7.0, 5.0,  9.0, 10.0 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum1 =\n+            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+\n+        LinearProblem problem2 = new LinearProblem(new double[][] {\n+                { 10.00, 7.00, 8.10, 7.20 },\n+                {  7.08, 5.04, 6.00, 5.00 },\n+                {  8.00, 5.98, 9.89, 9.00 },\n+                {  6.99, 4.99, 9.00, 9.98 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        PointVectorValuePair optimum2 =\n+            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+    }\n+\n+    @Test\n+    public void testMoreEstimatedParametersSimple() {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 3.0, 2.0,  0.0, 0.0 },\n+                { 0.0, 1.0, -1.0, 1.0 },\n+                { 2.0, 0.0,  1.0, 0.0 }\n+        }, new double[] { 7.0, 3.0, 5.0 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n+                new double[] { 7, 6, 5, 4 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testMoreEstimatedParametersUnsorted() {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n+                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n+                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n+                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n+                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n+       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 2, 2, 2, 2, 2, 2 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n+        Assert.assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n+        Assert.assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n+        Assert.assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testRedundantEquations() {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 5.0 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n+                               new double[] { 1, 1 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n+        Assert.assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testInconsistentEquations() {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 4.0 });\n+\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        Assert.assertTrue(optimizer.getRMS() > 0.1);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testInconsistentSizes1() {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+\n+        optimizer.optimize(100, problem, problem.target,\n+                           new double[] { 1 },\n+                           new double[] { 0, 0 });\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testInconsistentSizes2() {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+\n+        optimizer.optimize(100, problem, new double[] { 1 },\n+                           new double[] { 1 },\n+                           new double[] { 0, 0 });\n+    }\n+\n+    @Test\n+    public void testCircleFitting() {\n+        CircleVectorial circle = new CircleVectorial();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+        Assert.assertTrue(optimizer.getEvaluations() < 10);\n+        Assert.assertTrue(optimizer.getJacobianEvaluations() < 10);\n+        double rms = optimizer.getRMS();\n+        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-6);\n+        Assert.assertEquals(96.07590211815305, center.x,      1.0e-6);\n+        Assert.assertEquals(48.13516790438953, center.y,      1.0e-6);\n+        double[][] cov = optimizer.getCovariances();\n+        Assert.assertEquals(1.839, cov[0][0], 0.001);\n+        Assert.assertEquals(0.731, cov[0][1], 0.001);\n+        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        Assert.assertEquals(0.786, cov[1][1], 0.001);\n+        double[] errors = optimizer.guessParametersErrors();\n+        Assert.assertEquals(1.384, errors[0], 0.001);\n+        Assert.assertEquals(0.905, errors[1], 0.001);\n+\n+        // add perfect measurements and check errors are reduced\n+        double  r = circle.getRadius(center);\n+        for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {\n+            circle.addPoint(center.x + r * FastMath.cos(d), center.y + r * FastMath.sin(d));\n+        }\n+        double[] target = new double[circle.getN()];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[circle.getN()];\n+        Arrays.fill(weights, 2.0);\n+        optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 });\n+        cov = optimizer.getCovariances();\n+        Assert.assertEquals(0.0016, cov[0][0], 0.001);\n+        Assert.assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n+        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        Assert.assertEquals(0.0016, cov[1][1], 0.001);\n+        errors = optimizer.guessParametersErrors();\n+        Assert.assertEquals(0.004, errors[0], 0.001);\n+        Assert.assertEquals(0.004, errors[1], 0.001);\n+    }\n+\n+    @Test\n+    public void testCircleFittingBadInit() {\n+        CircleVectorial circle = new CircleVectorial();\n+        double[][] points = circlePoints;\n+        double[] target = new double[points.length];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[points.length];\n+        Arrays.fill(weights, 2.0);\n+        for (int i = 0; i < points.length; ++i) {\n+            circle.addPoint(points[i][0], points[i][1]);\n+        }\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        Assert.assertTrue(optimizer.getEvaluations() < 25);\n+        Assert.assertTrue(optimizer.getJacobianEvaluations() < 20);\n+        Assert.assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n+        Assert.assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n+        Assert.assertEquals(-0.151738,  center.x,      1.0e-6);\n+        Assert.assertEquals( 0.2075001, center.y,      1.0e-6);\n+    }\n+\n+    @Test\n+    public void testCircleFittingGoodInit() {\n+        CircleVectorial circle = new CircleVectorial();\n+        double[][] points = circlePoints;\n+        double[] target = new double[points.length];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[points.length];\n+        Arrays.fill(weights, 2.0);\n+        for (int i = 0; i < points.length; ++i) {\n+            circle.addPoint(points[i][0], points[i][1]);\n+        }\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        PointVectorValuePair optimum =\n+            optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n+        Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n+        Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n+        Assert.assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n+    }\n+\n+    private final double[][] circlePoints = new double[][] {\n+        {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+        {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+        {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+        {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+        { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+        { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+        {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+        {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+        {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+        {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+        {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+        { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+        { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+        {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+        {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+        {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+        {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+        {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+        { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+        { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+        { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+        {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+        {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+        {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+        {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+        {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+        { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+        { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+        {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+    };\n+\n+    static class LinearProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n+\n+        private static final long serialVersionUID = 703247177355019415L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new BlockRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[] value(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizerTest.java\n \n package org.apache.commons.math3.optimization.general;\n \n-import java.awt.geom.Point2D;\n-import java.io.Serializable;\n-import java.util.Arrays;\n-\n-\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.linear.BlockRealMatrix;\n-import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.optimization.SimpleVectorValueChecker;\n-import org.apache.commons.math3.optimization.PointVectorValuePair;\n-import org.apache.commons.math3.util.FastMath;\n-import org.junit.Assert;\n import org.junit.Test;\n \n /**\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class GaussNewtonOptimizerTest {\n+public class GaussNewtonOptimizerTest\n+    extends AbstractLeastSquaresOptimizerAbstractTest {\n \n-    @Test\n-    public void testTrivial() {\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n+    @Override\n+    public AbstractLeastSquaresOptimizer createOptimizer() {\n+        return new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n     }\n \n-    @Test\n-    public void testColumnsPermutation() {\n-\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n-                              new double[] { 4.0, 6.0, 1.0 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n-        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n-\n+    @Override\n+    @Test(expected = ConvergenceException.class)\n+    public void testMoreEstimatedParametersSimple() {\n+        /*\n+         * Exception is expected with this optimizer\n+         */\n+        super.testMoreEstimatedParametersSimple();\n     }\n \n-    @Test\n-    public void testNoDependency() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 2, 0, 0, 0, 0, 0 },\n-                { 0, 2, 0, 0, 0, 0 },\n-                { 0, 0, 2, 0, 0, 0 },\n-                { 0, 0, 0, 2, 0, 0 },\n-                { 0, 0, 0, 0, 2, 0 },\n-                { 0, 0, 0, 0, 0, 2 }\n-        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n-                               new double[] { 0, 0, 0, 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        for (int i = 0; i < problem.target.length; ++i) {\n-            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n-        }\n-    }\n-\n-    @Test\n-    public void testOneSet() {\n-\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                {  1,  0, 0 },\n-                { -1,  1, 0 },\n-                {  0, -1, 1 }\n-        }, new double[] { 1, 1, 1});\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-\n-    }\n-\n-    @Test\n-    public void testTwoSets() {\n-        double epsilon = 1.0e-7;\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                {  2,  1,   0,  4,       0, 0 },\n-                { -4, -2,   3, -7,       0, 0 },\n-                {  4,  1,  -2,  8,       0, 0 },\n-                {  0, -3, -12, -1,       0, 0 },\n-                {  0,  0,   0,  0, epsilon, 1 },\n-                {  0,  0,   0,  0,       1, 1 }\n-        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n-                               new double[] { 0, 0, 0, 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n-        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n-        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n-        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-\n-    }\n-\n+    @Override\n     @Test(expected=ConvergenceException.class)\n-    public void testNonInversible() throws Exception {\n-\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                {  1, 2, -3 },\n-                {  2, 1,  3 },\n-                { -3, 0, -9 }\n-        }, new double[] { 1, 1, 1 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-    }\n-\n-    @Test\n-    public void testIllConditioned() {\n-        LinearProblem problem1 = new LinearProblem(new double[][] {\n-                { 10.0, 7.0,  8.0,  7.0 },\n-                {  7.0, 5.0,  6.0,  5.0 },\n-                {  8.0, 6.0, 10.0,  9.0 },\n-                {  7.0, 5.0,  9.0, 10.0 }\n-        }, new double[] { 32, 23, 33, 31 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum1 =\n-            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n-                               new double[] { 0, 1, 2, 3 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n-\n-        LinearProblem problem2 = new LinearProblem(new double[][] {\n-                { 10.00, 7.00, 8.10, 7.20 },\n-                {  7.08, 5.04, 6.00, 5.00 },\n-                {  8.00, 5.98, 9.89, 9.00 },\n-                {  6.99, 4.99, 9.00, 9.98 }\n-        }, new double[] { 32, 23, 33, 31 });\n-        PointVectorValuePair optimum2 =\n-            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n-                               new double[] { 0, 1, 2, 3 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n-        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n-        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n-        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n-\n-    }\n-\n-    @Test(expected=ConvergenceException.class)\n-    public void testMoreEstimatedParametersSimple() throws Exception {\n-\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 3.0, 2.0,  0.0, 0.0 },\n-                { 0.0, 1.0, -1.0, 1.0 },\n-                { 2.0, 0.0,  1.0, 0.0 }\n-        }, new double[] { 7.0, 3.0, 5.0 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n-                           new double[] { 7, 6, 5, 4 });\n-    }\n-\n-    @Test(expected=ConvergenceException.class)\n-    public void testMoreEstimatedParametersUnsorted() throws Exception {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n-                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n-                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n-                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n-                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n-        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n-                           new double[] { 2, 2, 2, 2, 2, 2 });\n-    }\n-\n-    @Test\n-    public void testRedundantEquations() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 1.0,  1.0 },\n-                { 1.0, -1.0 },\n-                { 1.0,  3.0 }\n-        }, new double[] { 3.0, 1.0, 5.0 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n-                               new double[] { 1, 1 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n-        Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n-    }\n-\n-    @Test\n-    public void testInconsistentEquations() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 1.0,  1.0 },\n-                { 1.0, -1.0 },\n-                { 1.0,  3.0 }\n-        }, new double[] { 3.0, 1.0, 4.0 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n-        Assert.assertTrue(optimizer.getRMS() > 0.1);\n-\n-    }\n-\n-    @Test(expected=DimensionMismatchException.class)\n-    public void testInconsistentSizes1() {\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n-\n-        optimizer.optimize(100, problem, problem.target,\n-                           new double[] { 1 },\n-                           new double[] { 0, 0 });\n-    }\n-\n-    @Test(expected=DimensionMismatchException.class)\n-    public void testInconsistentSizes2() {\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n-\n-        optimizer.optimize(100, problem, new double[] { 1 },\n-                           new double[] { 1 },\n-                           new double[] { 0, 0 });\n+    public void testMoreEstimatedParametersUnsorted() {\n+        /*\n+         * Exception is expected with this optimizer\n+         */\n+        super.testMoreEstimatedParametersUnsorted();\n     }\n \n     @Test(expected=TooManyEvaluationsException.class)\n                            new double[] { 98.680, 47.345 });\n     }\n \n-    @Test\n-    public void testCircleFitting() {\n-        CircleVectorial circle = new CircleVectorial();\n-        circle.addPoint( 30.0,  68.0);\n-        circle.addPoint( 50.0,  -6.0);\n-        circle.addPoint(110.0, -20.0);\n-        circle.addPoint( 35.0,  15.0);\n-        circle.addPoint( 45.0,  97.0);\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-13, 1.0e-13));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n-                               new double[] { 1, 1, 1, 1, 1 },\n-                               new double[] { 98.680, 47.345 });\n-        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n-        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        Assert.assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);\n-        Assert.assertEquals(96.07590209601095, center.x, 1.0e-10);\n-        Assert.assertEquals(48.135167894714,   center.y, 1.0e-10);\n-    }\n-\n+    @Override\n     @Test(expected=ConvergenceException.class)\n     public void testCircleFittingBadInit() {\n-        CircleVectorial circle = new CircleVectorial();\n-        double[][] points = circlePoints;\n-        double[] target = new double[points.length];\n-        Arrays.fill(target, 0.0);\n-        double[] weights = new double[points.length];\n-        Arrays.fill(weights, 2.0);\n-        for (int i = 0; i < points.length; ++i) {\n-            circle.addPoint(points[i][0], points[i][1]);\n-        }\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n+        /*\n+         * This test does not converge with this optimizer\n+         */\n+        super.testCircleFittingBadInit();\n     }\n-\n-    @Test\n-    public void testCircleFittingGoodInit() {\n-        CircleVectorial circle = new CircleVectorial();\n-        double[][] points = circlePoints;\n-        double[] target = new double[points.length];\n-        Arrays.fill(target, 0.0);\n-        double[] weights = new double[points.length];\n-        Arrays.fill(weights, 2.0);\n-        for (int i = 0; i < points.length; ++i) {\n-            circle.addPoint(points[i][0], points[i][1]);\n-        }\n-\n-        GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n-        Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n-        Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n-        Assert.assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n-    }\n-\n-    private static class LinearProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n-\n-        private static final long serialVersionUID = -8804268799379350190L;\n-        final RealMatrix factors;\n-        final double[] target;\n-        public LinearProblem(double[][] factors, double[] target) {\n-            this.factors = new BlockRealMatrix(factors);\n-            this.target  = target;\n-        }\n-\n-        public double[] value(double[] variables) {\n-            return factors.operate(variables);\n-        }\n-\n-        public MultivariateMatrixFunction jacobian() {\n-            return new MultivariateMatrixFunction() {\n-                public double[][] value(double[] point) {\n-                    return factors.getData();\n-                }\n-            };\n-        }\n-    }\n-\n-    private final double[][] circlePoints = new double[][] {\n-        {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n-        {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n-        {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n-        {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n-        { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n-        { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n-        {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n-        {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n-        {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n-        {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n-        {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n-        { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n-        { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n-        {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n-        {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n-        {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n-        {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n-        {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n-        { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n-        { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n-        { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n-        {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n-        {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n-        {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n-        {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n-        {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n-        { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n-        { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n-        {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n-    };\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n import java.awt.geom.Point2D;\n import java.io.Serializable;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n \n-\n+import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n-import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.linear.BlockRealMatrix;\n-import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.SingularMatrixException;\n-import org.apache.commons.math3.optimization.SimpleVectorValueChecker;\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n+import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Precision;\n-import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class LevenbergMarquardtOptimizerTest {\n-\n-    @Test\n-    public void testTrivial() {\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        try {\n-            optimizer.guessParametersErrors();\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (NumberIsTooSmallException ee) {\n-            // expected behavior\n-        }\n-        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testQRColumnsPermutation() {\n-\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n-                              new double[] { 4.0, 6.0, 1.0 });\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);\n-        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testNoDependency() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 2, 0, 0, 0, 0, 0 },\n-                { 0, 2, 0, 0, 0, 0 },\n-                { 0, 0, 2, 0, 0, 0 },\n-                { 0, 0, 0, 2, 0, 0 },\n-                { 0, 0, 0, 0, 2, 0 },\n-                { 0, 0, 0, 0, 0, 2 }\n-        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n-                               new double[] { 0, 0, 0, 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        for (int i = 0; i < problem.target.length; ++i) {\n-            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n-        }\n-    }\n-\n-    @Test\n-    public void testOneSet() {\n-\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                {  1,  0, 0 },\n-                { -1,  1, 0 },\n-                {  0, -1, 1 }\n-        }, new double[] { 1, 1, 1});\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testTwoSets() {\n-        double epsilon = 1.0e-7;\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                {  2,  1,   0,  4,       0, 0 },\n-                { -4, -2,   3, -7,       0, 0 },\n-                {  4,  1,  -2,  8,       0, 0 },\n-                {  0, -3, -12, -1,       0, 0 },\n-                {  0,  0,   0,  0, epsilon, 1 },\n-                {  0,  0,   0,  0,       1, 1 }\n-        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n-                               new double[] { 0, 0, 0, 0, 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n-        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n-        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n-        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-    }\n-\n+public class LevenbergMarquardtOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest {\n+\n+    @Override\n+    public AbstractLeastSquaresOptimizer createOptimizer() {\n+        return new LevenbergMarquardtOptimizer();\n+    }\n+\n+    @Override\n     @Test(expected=SingularMatrixException.class)\n     public void testNonInvertible() {\n+        /*\n+         * Overrides the method from parent class, since the default singularity\n+         * threshold (1e-14) does not trigger the expected exception.\n+         */\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n                 {  2, 1,  3 },\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n \n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(100, problem, problem.target,\n-                             new double[] { 1, 1, 1 },\n-                             new double[] { 0, 0, 0 });\n+        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n \n-        // The default singularity threshold (1e-14) does not trigger the\n-        // expected exception.\n         double[][] cov = optimizer.getCovariances(1.5e-14);\n-    }\n-\n-    @Test\n-    public void testIllConditioned() {\n-        LinearProblem problem1 = new LinearProblem(new double[][] {\n-                { 10.0, 7.0,  8.0,  7.0 },\n-                {  7.0, 5.0,  6.0,  5.0 },\n-                {  8.0, 6.0, 10.0,  9.0 },\n-                {  7.0, 5.0,  9.0, 10.0 }\n-        }, new double[] { 32, 23, 33, 31 });\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum1 =\n-            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n-                               new double[] { 0, 1, 2, 3 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n-\n-        LinearProblem problem2 = new LinearProblem(new double[][] {\n-                { 10.00, 7.00, 8.10, 7.20 },\n-                {  7.08, 5.04, 6.00, 5.00 },\n-                {  8.00, 5.98, 9.89, 9.00 },\n-                {  6.99, 4.99, 9.00, 9.98 }\n-        }, new double[] { 32, 23, 33, 31 });\n-        PointVectorValuePair optimum2 =\n-            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n-                               new double[] { 0, 1, 2, 3 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n-        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n-        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n-        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n-    }\n-\n-    @Test\n-    public void testMoreEstimatedParametersSimple() {\n-\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 3.0, 2.0,  0.0, 0.0 },\n-                { 0.0, 1.0, -1.0, 1.0 },\n-                { 2.0, 0.0,  1.0, 0.0 }\n-        }, new double[] { 7.0, 3.0, 5.0 });\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n-                new double[] { 7, 6, 5, 4 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testMoreEstimatedParametersUnsorted() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n-                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n-                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n-                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n-                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n-       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n-                               new double[] { 2, 2, 2, 2, 2, 2 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n-        Assert.assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n-        Assert.assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n-        Assert.assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testRedundantEquations() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 1.0,  1.0 },\n-                { 1.0, -1.0 },\n-                { 1.0,  3.0 }\n-        }, new double[] { 3.0, 1.0, 5.0 });\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n-                               new double[] { 1, 1 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n-        Assert.assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n-    }\n-\n-    @Test\n-    public void testInconsistentEquations() {\n-        LinearProblem problem = new LinearProblem(new double[][] {\n-                { 1.0,  1.0 },\n-                { 1.0, -1.0 },\n-                { 1.0,  3.0 }\n-        }, new double[] { 3.0, 1.0, 4.0 });\n-\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n-        Assert.assertTrue(optimizer.getRMS() > 0.1);\n-    }\n-\n-    @Test\n-    public void testInconsistentSizes() {\n-        LinearProblem problem =\n-            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n-        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n-        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n-        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n-\n-        try {\n-            optimizer.optimize(100, problem, problem.target,\n-                               new double[] { 1 },\n-                               new double[] { 0, 0 });\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (DimensionMismatchException oe) {\n-            // expected behavior\n-        }\n-\n-        try {\n-            optimizer.optimize(100, problem, new double[] { 1 },\n-                               new double[] { 1 },\n-                               new double[] { 0, 0 });\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (DimensionMismatchException oe) {\n-            // expected behavior\n-        }\n     }\n \n     @Test\n         } catch (TooManyEvaluationsException ee) {\n             Assert.assertTrue(shouldFail);\n         }\n-    }\n-\n-    @Test\n-    public void testCircleFitting() {\n-        CircleVectorial circle = new CircleVectorial();\n-        circle.addPoint( 30.0,  68.0);\n-        circle.addPoint( 50.0,  -6.0);\n-        circle.addPoint(110.0, -20.0);\n-        circle.addPoint( 35.0,  15.0);\n-        circle.addPoint( 45.0,  97.0);\n-        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n-                               new double[] { 98.680, 47.345 });\n-        Assert.assertTrue(optimizer.getEvaluations() < 10);\n-        Assert.assertTrue(optimizer.getJacobianEvaluations() < 10);\n-        double rms = optimizer.getRMS();\n-        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);\n-        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n-        Assert.assertEquals(96.07590211815305, center.x,      1.0e-10);\n-        Assert.assertEquals(48.13516790438953, center.y,      1.0e-10);\n-        double[][] cov = optimizer.getCovariances();\n-        Assert.assertEquals(1.839, cov[0][0], 0.001);\n-        Assert.assertEquals(0.731, cov[0][1], 0.001);\n-        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n-        Assert.assertEquals(0.786, cov[1][1], 0.001);\n-        double[] errors = optimizer.guessParametersErrors();\n-        Assert.assertEquals(1.384, errors[0], 0.001);\n-        Assert.assertEquals(0.905, errors[1], 0.001);\n-\n-        // add perfect measurements and check errors are reduced\n-        double  r = circle.getRadius(center);\n-        for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {\n-            circle.addPoint(center.x + r * FastMath.cos(d), center.y + r * FastMath.sin(d));\n-        }\n-        double[] target = new double[circle.getN()];\n-        Arrays.fill(target, 0.0);\n-        double[] weights = new double[circle.getN()];\n-        Arrays.fill(weights, 2.0);\n-        optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 });\n-        cov = optimizer.getCovariances();\n-        Assert.assertEquals(0.0016, cov[0][0], 0.001);\n-        Assert.assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n-        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n-        Assert.assertEquals(0.0016, cov[1][1], 0.001);\n-        errors = optimizer.guessParametersErrors();\n-        Assert.assertEquals(0.004, errors[0], 0.001);\n-        Assert.assertEquals(0.004, errors[1], 0.001);\n-    }\n-\n-    @Test\n-    public void testCircleFittingBadInit() {\n-        CircleVectorial circle = new CircleVectorial();\n-        double[][] points = new double[][] {\n-                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n-                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n-                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n-                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n-                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n-                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n-                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n-                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n-                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n-                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n-                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n-                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n-                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n-                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n-                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n-                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n-                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n-                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n-                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n-                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n-                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n-                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n-                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n-                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n-                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n-                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n-                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n-                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n-                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n-        };\n-        double[] target = new double[points.length];\n-        Arrays.fill(target, 0.0);\n-        double[] weights = new double[points.length];\n-        Arrays.fill(weights, 2.0);\n-        for (int i = 0; i < points.length; ++i) {\n-            circle.addPoint(points[i][0], points[i][1]);\n-        }\n-        LevenbergMarquardtOptimizer optimizer\n-            = new LevenbergMarquardtOptimizer(new SimpleVectorValueChecker(1.0e-8, 1.0e-8));\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n-        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        Assert.assertTrue(optimizer.getEvaluations() < 25);\n-        Assert.assertTrue(optimizer.getJacobianEvaluations() < 20);\n-        Assert.assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n-        Assert.assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n-        Assert.assertEquals(-0.151738,  center.x,      1.0e-6);\n-        Assert.assertEquals( 0.2075001, center.y,      1.0e-6);\n     }\n \n     @Test\n \n         final LevenbergMarquardtOptimizer optimizer\n             = new LevenbergMarquardtOptimizer();\n-        \n+\n         final PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, dataPoints[1], weights,\n                                new double[] { 10, 900, 80, 27, 225 });\n-        \n+\n         final double chi2 = optimizer.getChiSquare();\n         final double[] solution = optimum.getPoint();\n         final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 };\n         Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]);\n     }\n \n-    private static class LinearProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n-\n-        private static final long serialVersionUID = 703247177355019415L;\n-        final RealMatrix factors;\n-        final double[] target;\n-        public LinearProblem(double[][] factors, double[] target) {\n-            this.factors = new BlockRealMatrix(factors);\n-            this.target  = target;\n-        }\n-\n-        public double[] value(double[] variables) {\n-            return factors.operate(variables);\n-        }\n-\n-        public MultivariateMatrixFunction jacobian() {\n-            return new MultivariateMatrixFunction() {\n-                public double[][] value(double[] point) {\n-                    return factors.getData();\n-                }\n-            };\n-        }\n-    }\n-\n     private static class QuadraticProblem implements DifferentiableMultivariateVectorFunction, Serializable {\n \n         private static final long serialVersionUID = 7072187082052755854L;\n             for (int i = 0; i < jacobian.length; ++i) {\n                 final double t = time.get(i);\n                 jacobian[i][0] = 1;\n-                \n+\n                 final double p3 =  params[3];\n                 final double p4 =  params[4];\n                 final double tOp3 = t / p3;", "timestamp": 1335784062, "metainfo": ""}