{"sha": "11b1b60440bfbf6b58d7b4dfa270b4a2aad19c9e", "log": "MATH-494 FastMath atan2 does not agree with StrictMath for special cases Add doubleHighPart() method to better handle splitting high absolute values Add getSign() utility method  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n                                             1.2599210498948732,\n                                             1.5874010519681994 };\n \n+    /*\n+     *  There are 52 bits in the mantissa of a double.\n+     *  For additional precision, the code splits double numbers into two parts,\n+     *  by clearing the low order 30 bits if possible, and then performs the arithmetic\n+     *  on each half separately.\n+     */\n+\n     /**\n      * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n-     */\n-    private static final double HEX_40000000 = 1073741824.0;\n+     * Equivalent to 2^30.\n+     */\n+    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n+    \n+    /** Mask used to clear low order 30 bits */\n+    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;\n \n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n      * Private Constructor\n      */\n     private FastMath() {\n+    }\n+\n+    // Generic helper methods\n+    \n+    /**\n+     * Get the sign information (works even for 0).\n+     * \n+     * @param d the value to check\n+     * \n+     * @return +1.0 or -1.0, never 0.0\n+     */\n+    private static double getSign(double d){ // TODO perhaps move to MathUtils?\n+        long l = Double.doubleToLongBits(d);\n+        return l < 0 ? -1.0 : 1.0;\n+    }\n+\n+    /**\n+     * Get the high order bits from the mantissa.\n+     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n+     * \n+     * @param d the value to split\n+     * @return the high order part of the mantissa\n+     */\n+    private static double doubleHighPart(double d) {\n+        if (d > -MathUtils.SAFE_MIN && d < MathUtils.SAFE_MIN){\n+            return d; // These are un-normalised - don't try to convert\n+        }\n+        long xl = Double.doubleToLongBits(d);\n+        xl = xl & MASK_30BITS; // Drop low order bits\n+        return Double.longBitsToDouble(xl);\n     }\n \n     /** Compute the square root of a number.\n      * @param xa number from which arctangent is requested\n      * @param xb extra bits for x (may be 0.0)\n      * @param leftPlane if true, result angle must be put in the left half plane\n-     * @return atan(xa + xb) (or angle shifted by &pi; if leftPlane is true)\n+     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n      */\n     private static double atan(double xa, double xb, boolean leftPlane) {\n         boolean negate = false;\n         int idx;\n \n         if (xa == 0.0) { // Matches +/- 0.0; return correct sign\n-            return xa;\n+            return leftPlane ? getSign(xa) * Math.PI : xa;\n         }\n \n         if (xa < 0) {\n \n             if (invx == 0.0) { // X is infinite\n                 if (x > 0) {\n-                    return 0.0;\n+                    return y; // return +/- 0.0\n                 } else {\n-                    return Math.PI;\n+                    return getSign(y) * Math.PI;\n                 }\n-            }\n-\n-            if (result != result) { // y must be infinite\n-                return x/y;\n             }\n \n             if (x < 0.0 || invx < 0.0) {\n             }\n         }\n \n+        // y cannot now be zero\n+\n         if (y == Double.POSITIVE_INFINITY) {\n             if (x == Double.POSITIVE_INFINITY) {\n                 return Math.PI/4.0;\n             }\n         }\n \n+        // Neither y nor x can be infinite or NAN here\n+\n         if (x == 0) {\n             if (y > 0.0 || 1/y > 0.0) {\n                 return Math.PI/2.0;\n             }\n         }\n \n-        if (x > 8e298 || x < -8e298) { // This would cause split of x to fail\n-            x *= 9.31322574615478515625E-10;\n-            y *= 9.31322574615478515625E-10;\n-        }\n-\n-        // Split y\n-        double temp = x * HEX_40000000;\n-        final double xa = x + temp - temp;\n+        // Compute ratio r = y/x\n+        final double r = y/x;\n+        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n+            return atan(r, 0, x < 0);\n+        }\n+\n+        double ra = doubleHighPart(r);\n+        double rb = r - ra;\n+\n+        // Split x\n+        final double xa = doubleHighPart(x);\n         final double xb = x - xa;\n \n-        // Compute ratio r = x/y\n-        final double r = y/x;\n-        temp = r * HEX_40000000;\n-        double ra = r + temp - temp;\n-        double rb = r - ra;\n-\n         rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n \n-        temp = ra + rb;\n+        double temp = ra + rb;\n         rb = -(temp - ra - rb);\n         ra = temp;\n+\n+        if (ra == 0 && (y < 0)) { // Fix up the sign so atan works correctly\n+            ra = -0.0;\n+        }\n \n         // Call atan\n         double result = atan(ra, rb, x < 0);\n \n         double result = xb * factb + xb * facta + xa * factb + xa * facta;\n         if (result == 0) {\n-            result = result * x; // ensure correct sign\n+            result = result * x; // ensure correct sign if calculation underflows\n         }\n         return result;\n     }", "timestamp": 1295727580, "metainfo": ""}