{"sha": "4d81fcce23fdaaa728fba7f118c3e1ce716954c0", "log": "MATH-689 Moved \"pow\" (integer arguments) to \"ArithmeticUtils\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n \n /**\n  * Representation of a rational number without any overflow. This class is\n      */\n     public BigFraction pow(final long exponent) {\n         if (exponent < 0) {\n-            return new BigFraction(MathUtils.pow(denominator, -exponent),\n-                                   MathUtils.pow(numerator,   -exponent));\n-        }\n-        return new BigFraction(MathUtils.pow(numerator,   exponent),\n-                               MathUtils.pow(denominator, exponent));\n+            return new BigFraction(ArithmeticUtils.pow(denominator, -exponent),\n+                                   ArithmeticUtils.pow(numerator,   -exponent));\n+        }\n+        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n+                               ArithmeticUtils.pow(denominator, exponent));\n     }\n \n     /**\n     public BigFraction pow(final BigInteger exponent) {\n         if (exponent.compareTo(BigInteger.ZERO) < 0) {\n             final BigInteger eNeg = exponent.negate();\n-            return new BigFraction(MathUtils.pow(denominator, eNeg),\n-                                   MathUtils.pow(numerator,   eNeg));\n-        }\n-        return new BigFraction(MathUtils.pow(numerator,   exponent),\n-                               MathUtils.pow(denominator, exponent));\n+            return new BigFraction(ArithmeticUtils.pow(denominator, eNeg),\n+                                   ArithmeticUtils.pow(numerator,   eNeg));\n+        }\n+        return new BigFraction(ArithmeticUtils.pow(numerator,   exponent),\n+                               ArithmeticUtils.pow(denominator, exponent));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/ArithmeticUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/ArithmeticUtils.java\n  */\n package org.apache.commons.math.util;\n \n+import java.math.BigInteger;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalNumberException;\n import org.apache.commons.math.exception.NotPositiveException;\n     }\n \n     /**\n+     * Raise an int to an int power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static int pow(final int k, int e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        int result = 1;\n+        int k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Raise an int to a long power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static int pow(final int k, long e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        int result = 1;\n+        int k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Raise a long to an int power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static long pow(final long k, int e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        long result = 1l;\n+        long k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Raise a long to a long power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static long pow(final long k, long e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        long result = 1l;\n+        long k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Raise a BigInteger to an int power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, int e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        return k.pow(e);\n+    }\n+\n+    /**\n+     * Raise a BigInteger to a long power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, long e) {\n+        if (e < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        BigInteger result = BigInteger.ONE;\n+        BigInteger k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result = result.multiply(k2p);\n+            }\n+            k2p = k2p.multiply(k2p);\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise a BigInteger to a BigInteger power.\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n+     * @return k<sup>e</sup>\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, BigInteger e) {\n+        if (e.compareTo(BigInteger.ZERO) < 0) {\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n+        }\n+\n+        BigInteger result = BigInteger.ONE;\n+        BigInteger k2p    = k;\n+        while (!BigInteger.ZERO.equals(e)) {\n+            if (e.testBit(0)) {\n+                result = result.multiply(k2p);\n+            }\n+            k2p = k2p.multiply(k2p);\n+            e = e.shiftRight(1);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n      * Add two long integers, checking for overflow.\n      *\n      * @param a Addend.\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n package org.apache.commons.math.util;\n \n-import java.math.BigInteger;\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n-import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n     }\n \n     /**\n-     * Raise an int to an int power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static int pow(final int k, int e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        int result = 1;\n-        int k2p    = k;\n-        while (e != 0) {\n-            if ((e & 0x1) != 0) {\n-                result *= k2p;\n-            }\n-            k2p *= k2p;\n-            e = e >> 1;\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Raise an int to a long power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static int pow(final int k, long e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        int result = 1;\n-        int k2p    = k;\n-        while (e != 0) {\n-            if ((e & 0x1) != 0) {\n-                result *= k2p;\n-            }\n-            k2p *= k2p;\n-            e = e >> 1;\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Raise a long to an int power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static long pow(final long k, int e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        long result = 1l;\n-        long k2p    = k;\n-        while (e != 0) {\n-            if ((e & 0x1) != 0) {\n-                result *= k2p;\n-            }\n-            k2p *= k2p;\n-            e = e >> 1;\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Raise a long to a long power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static long pow(final long k, long e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        long result = 1l;\n-        long k2p    = k;\n-        while (e != 0) {\n-            if ((e & 0x1) != 0) {\n-                result *= k2p;\n-            }\n-            k2p *= k2p;\n-            e = e >> 1;\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Raise a BigInteger to an int power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static BigInteger pow(final BigInteger k, int e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        return k.pow(e);\n-    }\n-\n-    /**\n-     * Raise a BigInteger to a long power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static BigInteger pow(final BigInteger k, long e) {\n-        if (e < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        BigInteger result = BigInteger.ONE;\n-        BigInteger k2p    = k;\n-        while (e != 0) {\n-            if ((e & 0x1) != 0) {\n-                result = result.multiply(k2p);\n-            }\n-            k2p = k2p.multiply(k2p);\n-            e = e >> 1;\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    /**\n-     * Raise a BigInteger to a BigInteger power.\n-     *\n-     * @param k Number to raise.\n-     * @param e Exponent (must be positive or zero).\n-     * @return k<sup>e</sup>\n-     * @throws NotPositiveException if {@code e < 0}.\n-     */\n-    public static BigInteger pow(final BigInteger k, BigInteger e) {\n-        if (e.compareTo(BigInteger.ZERO) < 0) {\n-            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n-        }\n-\n-        BigInteger result = BigInteger.ONE;\n-        BigInteger k2p    = k;\n-        while (!BigInteger.ZERO.equals(e)) {\n-            if (e.testBit(0)) {\n-                result = result.multiply(k2p);\n-            }\n-            k2p = k2p.multiply(k2p);\n-            e = e.shiftRight(1);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n      * Check that the argument is a real number.\n      *\n      * @param x Argument.\n--- a/src/test/java/org/apache/commons/math/util/ArithmeticUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ArithmeticUtilsTest.java\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.math.BigInteger;\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n         testSubAndCheckLongFailure(min, 1L);\n     }\n \n+    @Test\n+    public void testPow() {\n+\n+        Assert.assertEquals(1801088541, ArithmeticUtils.pow(21, 7));\n+        Assert.assertEquals(1, ArithmeticUtils.pow(21, 0));\n+        try {\n+            ArithmeticUtils.pow(21, -7);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        Assert.assertEquals(1801088541, ArithmeticUtils.pow(21, 7l));\n+        Assert.assertEquals(1, ArithmeticUtils.pow(21, 0l));\n+        try {\n+            ArithmeticUtils.pow(21, -7l);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        Assert.assertEquals(1801088541l, ArithmeticUtils.pow(21l, 7));\n+        Assert.assertEquals(1l, ArithmeticUtils.pow(21l, 0));\n+        try {\n+            ArithmeticUtils.pow(21l, -7);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        Assert.assertEquals(1801088541l, ArithmeticUtils.pow(21l, 7l));\n+        Assert.assertEquals(1l, ArithmeticUtils.pow(21l, 0l));\n+        try {\n+            ArithmeticUtils.pow(21l, -7l);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        BigInteger twentyOne = BigInteger.valueOf(21l);\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, 7));\n+        Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, 0));\n+        try {\n+            ArithmeticUtils.pow(twentyOne, -7);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, 7l));\n+        Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, 0l));\n+        try {\n+            ArithmeticUtils.pow(twentyOne, -7l);\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(7l)));\n+        Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, BigInteger.ZERO));\n+        try {\n+            ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(-7l));\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        BigInteger bigOne =\n+            new BigInteger(\"1543786922199448028351389769265814882661837148\" +\n+                           \"4763915343722775611762713982220306372888519211\" +\n+                           \"560905579993523402015636025177602059044911261\");\n+        Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, 103));\n+        Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, 103l));\n+        Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n+\n+    }\n+\n     /**\n      * Exact (caching) recursive implementation to test against\n      */\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n  * governing permissions and limitations under the License.\n  */\n package org.apache.commons.math.util;\n-\n-import java.math.BigInteger;\n-\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathArithmeticException;\n     }\n \n     @Test\n-    public void testPow() {\n-\n-        Assert.assertEquals(1801088541, MathUtils.pow(21, 7));\n-        Assert.assertEquals(1, MathUtils.pow(21, 0));\n-        try {\n-            MathUtils.pow(21, -7);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        Assert.assertEquals(1801088541, MathUtils.pow(21, 7l));\n-        Assert.assertEquals(1, MathUtils.pow(21, 0l));\n-        try {\n-            MathUtils.pow(21, -7l);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7));\n-        Assert.assertEquals(1l, MathUtils.pow(21l, 0));\n-        try {\n-            MathUtils.pow(21l, -7);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7l));\n-        Assert.assertEquals(1l, MathUtils.pow(21l, 0l));\n-        try {\n-            MathUtils.pow(21l, -7l);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        BigInteger twentyOne = BigInteger.valueOf(21l);\n-        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));\n-        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));\n-        try {\n-            MathUtils.pow(twentyOne, -7);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));\n-        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));\n-        try {\n-            MathUtils.pow(twentyOne, -7l);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));\n-        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));\n-        try {\n-            MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException e) {\n-            // expected behavior\n-        }\n-\n-        BigInteger bigOne =\n-            new BigInteger(\"1543786922199448028351389769265814882661837148\" +\n-                           \"4763915343722775611762713982220306372888519211\" +\n-                           \"560905579993523402015636025177602059044911261\");\n-        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103));\n-        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));\n-        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n-\n-    }\n-\n-    @Test\n     public void testCheckFinite() {\n         try {\n             MathUtils.checkFinite(Double.POSITIVE_INFINITY);", "timestamp": 1322232534, "metainfo": ""}