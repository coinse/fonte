{"sha": "b4af1eccf206ecbeacdc774930461c6a03678810", "log": "Javadoc Made sure that exceptions are documented in both javadoc and method signatures.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomData.java\n package org.apache.commons.math.random;\n import java.util.Collection;\n \n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+\n /**\n  * Random data generation utilities.\n  * @version $Id$\n  */\n public interface RandomData {\n     /**\n-     * Generates a random string of hex characters of length\n-     * <code>len</code>.\n+     * Generates a random string of hex characters of length {@code len}.\n      * <p>\n      * The generated string will be random, but not cryptographically\n      * secure. To generate cryptographically secure strings, use\n-     * <code>nextSecureHexString</code></p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n+     * {@link #nextSecureHexString(int)}.\n+     * </p>\n      *\n      * @param len the length of the string to be generated\n-     * @return random string of hex characters of length <code>len</code>\n-     */\n-    String nextHexString(int len);\n-\n-    /**\n-     * Generates a uniformly distributed random integer between\n-     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * @return a random string of hex characters of length {@code len}\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}\n+     */\n+    String nextHexString(int len) throws NotStrictlyPositiveException;\n+\n+    /**\n+     * Generates a uniformly distributed random integer between {@code lower}\n+     * and {@code upper} (endpoints included).\n      * <p>\n      * The generated integer will be random, but not cryptographically secure.\n      * To generate cryptographically secure integer sequences, use\n-     * <code>nextSecureInt</code>.</p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n+     * {@link #nextSecureInt(int, int)}.\n+     * </p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @return a random integer greater than or equal to <code>lower</code>\n-     * and less than or equal to <code>upper</code>.\n-     */\n-    int nextInt(int lower, int upper);\n+     * @return a random integer greater than or equal to {@code lower}\n+     * and less than or equal to {@code upper}\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     */\n+    int nextInt(int lower, int upper) throws NumberIsTooLargeException;\n \n     /**\n      * Generates a uniformly distributed random long integer between\n-     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * {@code lower} and {@code upper} (endpoints included).\n      * <p>\n      * The generated long integer values will be random, but not\n-     * cryptographically secure.\n-     * To generate cryptographically secure sequences of longs, use\n-     * <code>nextSecureLong</code></p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n+     * cryptographically secure. To generate cryptographically secure sequences\n+     * of longs, use {@link #nextSecureLong(long, long)}.\n+     * </p>\n+     *\n+     * @param lower lower bound for generated long integer\n+     * @param upper upper bound for generated long integer\n+     * @return a random long integer greater than or equal to {@code lower} and\n+     * less than or equal to {@code upper}\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    long nextLong(long lower, long upper) throws NumberIsTooLargeException;\n+\n+    /**\n+     * Generates a random string of hex characters from a secure random\n+     * sequence.\n+     * <p>\n+     * If cryptographic security is not required, use\n+     * {@link #nextHexString(int)}.\n+     * </p>\n+     *\n+     * @param len the length of the string to be generated\n+     * @return a random string of hex characters of length {@code len}\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}\n+     */\n+    String nextSecureHexString(int len) throws NotStrictlyPositiveException;\n+\n+    /**\n+     * Generates a uniformly distributed random integer between {@code lower}\n+     * and {@code upper} (endpoints included) from a secure random sequence.\n+     * <p>\n+     * Sequences of integers generated using this method will be\n+     * cryptographically secure. If cryptographic security is not required,\n+     * {@link #nextInt(int, int)} should be used instead of this method.</p>\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @return a random integer greater than or equal to <code>lower</code>\n-     * and less than or equal to <code>upper</code>.\n-     */\n-    long nextLong(long lower, long upper);\n-\n-    /**\n-     * Generates a random string of hex characters from a secure random\n+     * @return a random integer greater than or equal to {@code lower} and less\n+     * than or equal to {@code upper}.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    int nextSecureInt(int lower, int upper) throws NumberIsTooLargeException;\n+\n+    /**\n+     * Generates a uniformly distributed random long integer between\n+     * {@code lower} and {@code upper} (endpoints included) from a secure random\n      * sequence.\n      * <p>\n-     * If cryptographic security is not required,\n-     * use <code>nextHexString()</code>.</p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n-     * @param len length of return string\n-     * @return the random hex string\n-     */\n-    String nextSecureHexString(int len);\n-\n-    /**\n-     * Generates a uniformly distributed random integer between\n-     * <code>lower</code> and <code>upper</code> (endpoints included)\n-     * from a secure random sequence.\n-     * <p>\n-     * Sequences of integers generated using this method will be\n+     * Sequences of long values generated using this method will be\n      * cryptographically secure. If cryptographic security is not required,\n-     * <code>nextInt</code> should be used instead of this method.</p>\n+     * {@link #nextLong(long, long)} should be used instead of this method.</p>\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n      * Secure Random Sequence</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n      *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @return a random integer greater than or equal to <code>lower</code>\n-     * and less than or equal to <code>upper</code>.\n-     */\n-    int nextSecureInt(int lower, int upper);\n-\n-    /**\n-     * Generates a random long integer between <code>lower</code>\n-     * and <code>upper</code> (endpoints included).\n-     * <p>\n-     * Sequences of long values generated using this method will be\n-     * cryptographically secure. If cryptographic security is not required,\n-     * <code>nextLong</code> should be used instead of this method.</p>\n-     * <p>\n-     * <strong>Definition</strong>:\n-     * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n-     * Secure Random Sequence</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n-     *\n-     * @param lower lower bound for generated integer\n-     * @param upper upper bound for generated integer\n-     * @return a long integer greater than or equal to <code>lower</code>\n-     * and less than or equal to <code>upper</code>.\n-     */\n-    long nextSecureLong(long lower, long upper);\n-\n-    /**\n-     * Generates a random value from the Poisson distribution with\n-     * the given mean.\n+     * @return a random long integer greater than or equal to {@code lower} and\n+     * less than or equal to {@code upper}.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    long nextSecureLong(long lower, long upper)\n+            throws NumberIsTooLargeException;\n+\n+    /**\n+     * Generates a random value from the Poisson distribution with the given\n+     * mean.\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm\">\n      * Poisson Distribution</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified mean <i>must</i> be positive (otherwise an\n-     *     IllegalArgumentException is thrown.)</li>\n-     * </ul></p>\n-     * @param mean Mean of the distribution\n-     * @return poisson deviate with the specified mean\n-     */\n-    long nextPoisson(double mean);\n-\n-    /**\n-     * Generates a random value from the\n-     * Normal (or Gaussian) distribution with the given mean\n-     * and standard deviation.\n+     *\n+     * @param mean the mean of the Poisson distribution\n+     * @return a random value following the specified Poisson distribution\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     */\n+    long nextPoisson(double mean) throws NotStrictlyPositiveException;\n+\n+    /**\n+     * Generates a random value from the Normal (or Gaussian) distribution with\n+     * specified mean and standard deviation.\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm\">\n      * Normal Distribution</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>: <ul>\n-     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n-     * @param mu Mean of the distribution\n-     * @param sigma Standard deviation of the distribution\n-     * @return random value from Gaussian distribution with mean = mu,\n-     * standard deviation = sigma\n-     */\n-    double nextGaussian(double mu, double sigma);\n+     *\n+     * @param mu the mean of the distribution\n+     * @param sigma the standard deviation of the distribution\n+     * @return a random value following the specified Gaussian distribution\n+     * @throws NotStrictlyPositiveException if {@code sigma <= 0}.\n+     */\n+    double nextGaussian(double mu, double sigma)\n+            throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a random value from the exponential distribution\n-     * with expected value = <code>mean</code>.\n+     * with specified mean.\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm\">\n      * Exponential Distribution</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>: <ul>\n-     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException\n-     *     is thrown.)</li>\n-     * </ul></p>\n-     * @param mean Mean of the distribution\n-     * @return random value from exponential distribution\n-     */\n-    double nextExponential(double mean);\n+     *\n+     * @param mean the mean of the distribution\n+     * @return a random value following the specified exponential distribution\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     */\n+    double nextExponential(double mean) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a uniformly distributed random value from the open interval\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm\">\n-     * Uniform Distribution</a> <code>lower</code> and\n-     * <code>upper - lower</code> are the\n+     * Uniform Distribution</a> {@code lower} and {@code upper - lower} are the\n      * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm\">\n      * location and scale parameters</a>, respectively.</p>\n      *\n-     * @param lower lower endpoint of the interval of support\n-     * @param upper upper endpoint of the interval of support\n-     * @return uniformly distributed random value between lower\n-     * and upper (exclusive)\n-     */\n-    double nextUniform(double lower, double upper);\n+     * @param lower the exclusive lower bound of the support\n+     * @param upper the exclusive upper bound of the support\n+     * @return a uniformly distributed random value between lower and upper\n+     * (exclusive)\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     */\n+    double nextUniform(double lower, double upper)\n+            throws NumberIsTooLargeException;\n \n     /**\n      * Generates a uniformly distributed random value from the interval\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm\">\n-     * Uniform Distribution</a> <code>lower</code> and\n-     * <code>upper - lower</code> are the\n+     * Uniform Distribution</a> {@code lower} and {@code upper - lower} are the\n      * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm\">\n      * location and scale parameters</a>, respectively.</p>\n      *\n-     * @param lower lower endpoint of the interval of support\n-     * @param upper upper endpoint of the interval of support\n-     * @param lowerInclusive {@code true} if the lower bound is included in the\n-     * interval\n+     * @param lower the lower bound of the support\n+     * @param upper the exclusive upper bound of the support\n+     * @param lowerInclusive {@code true} if the lower bound is inclusive\n      * @return uniformly distributed random value in the {@code (lower, upper)}\n      * interval, if {@code lowerInclusive} is {@code false}, or in the\n      * {@code [lower, upper)} interval, if {@code lowerInclusive} is {@code true}\n-     */\n-    double nextUniform(double lower, double upper, boolean lowerInclusive);\n-\n-    /**\n-     * Generates an integer array of length <code>k</code> whose entries\n-     * are selected randomly, without repetition, from the integers <code>\n-     * 0 through n-1</code> (inclusive).\n-     * <p>\n-     * Generated arrays represent permutations\n-     * of <code>n</code> taken <code>k</code> at a time.</p>\n-     * <p>\n-     * <strong>Preconditions:</strong><ul>\n-     * <li> <code>k <= n</code></li>\n-     * <li> <code>n > 0</code> </li>\n-     * </ul>\n-     * If the preconditions are not met, an IllegalArgumentException is\n-     * thrown.</p>\n-     *\n-     * @param n domain of the permutation\n-     * @param k size of the permutation\n-     * @return random k-permutation of n\n-     */\n-    int[] nextPermutation(int n, int k);\n-\n-    /**\n-     * Returns an array of <code>k</code> objects selected randomly\n-     * from the Collection <code>c</code>.\n-     * <p>\n-     * Sampling from <code>c</code>\n-     * is without replacement; but if <code>c</code> contains identical\n-     * objects, the sample may include repeats.  If all elements of <code>\n-     * c</code> are distinct, the resulting object array represents a\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     */\n+    double nextUniform(double lower, double upper, boolean lowerInclusive)\n+            throws NumberIsTooLargeException;\n+\n+    /**\n+     * Generates an integer array of length {@code k} whose entries are selected\n+     * randomly, without repetition, from the integers {@code 0, ..., n - 1}\n+     * (inclusive).\n+     * <p>\n+     * Generated arrays represent permutations of {@code n} taken {@code k} at a\n+     * time.</p>\n+     *\n+     * @param n the domain of the permutation\n+     * @param k the size of the permutation\n+     * @return a random {@code k}-permutation of {@code n}, as an array of\n+     * integers\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n+     */\n+    int[] nextPermutation(int n, int k)\n+            throws NumberIsTooLargeException, NotStrictlyPositiveException;\n+\n+    /**\n+     * Returns an array of {@code k} objects selected randomly from the\n+     * Collection {@code c}.\n+     * <p>\n+     * Sampling from {@code c} is without replacement; but if {@code c} contains\n+     * identical objects, the sample may include repeats.  If all elements of\n+     * {@code c} are distinct, the resulting object array represents a\n      * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000\">\n-     * Simple Random Sample</a> of size\n-     * <code>k</code> from the elements of <code>c</code>.</p>\n-     * <p>\n-     * <strong>Preconditions:</strong><ul>\n-     * <li> k must be less than or equal to the size of c </li>\n-     * <li> c must not be empty </li>\n-     * </ul>\n-     * If the preconditions are not met, an IllegalArgumentException is\n-     * thrown.</p>\n-     *\n-     * @param c collection to be sampled\n-     * @param k size of the sample\n-     * @return random sample of k elements from c\n-     */\n-    Object[] nextSample(Collection<?> c, int k);\n+     * Simple Random Sample</a> of size {@code k} from the elements of\n+     * {@code c}.</p>\n+     *\n+     * @param c the collection to be sampled\n+     * @param k the size of the sample\n+     * @return a random sample of {@code k} elements from {@code c}\n+     * @throws NumberIsTooLargeException if {@code k > c.size()}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n+     */\n+    Object[] nextSample(Collection<?> c, int k)\n+            throws NumberIsTooLargeException, NotStrictlyPositiveException;\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n      * <strong>Algorithm Description:</strong> hex strings are generated using a\n      * 2-step process.\n      * <ol>\n-     * <li>\n-     * len/2+1 binary bytes are generated using the underlying Random</li>\n-     * <li>\n-     * Each binary byte is translated into 2 hex digits</li>\n+     * <li>{@code len / 2 + 1} binary bytes are generated using the underlying\n+     * Random</li>\n+     * <li>Each binary byte is translated into 2 hex digits</li>\n      * </ol>\n      * </p>\n      *\n-     * @param len\n-     *            the desired string length.\n+     * @param len the desired string length.\n      * @return the random string.\n      * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n-    public String nextHexString(int len) {\n+    public String nextHexString(int len) throws NotStrictlyPositiveException {\n         if (len <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n         return outBuffer.toString().substring(0, len);\n     }\n \n-    /**\n-     * Generate a random int value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.\n-     *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return the random integer.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n-     */\n-    public int nextInt(int lower, int upper) {\n+    /** {@inheritDoc} */\n+    public int nextInt(int lower, int upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n         double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (int)FastMath.floor(scaled);\n-    }\n-\n-    /**\n-     * Generate a random long value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.\n-     *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return the random integer.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n-     */\n+        return (int) FastMath.floor(scaled);\n+    }\n+\n+    /** {@inheritDoc} */\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n      * Each byte of the binary digest is converted to 2 hex digits.</li>\n      * </ol>\n      * </p>\n-     *\n-     * @param len\n-     *            the length of the generated string\n-     * @return the random string\n-     * @throws NotStrictlyPositiveException if {@code len <= 0}.\n-     */\n-    public String nextSecureHexString(int len) {\n+     */\n+    public String nextSecureHexString(int len) throws NotStrictlyPositiveException {\n         if (len <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n             alg.update(randomBytes);\n \n             // Compute hash -- will create 20-byte binary hash\n-            byte hash[] = alg.digest();\n+            byte[] hash = alg.digest();\n \n             // Loop over the hash, converting each byte to 2 hex digits\n             for (int i = 0; i < hash.length; i++) {\n         return outBuffer.toString().substring(0, len);\n     }\n \n-    /**\n-     * Generate a random int value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n-     * a secure random number generator.\n-     *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return the random integer.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n-     */\n+    /**  {@inheritDoc} */\n     public int nextSecureInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n         return (int)FastMath.floor(scaled);\n     }\n \n-    /**\n-     * Generate a random long value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n-     * a secure random number generator.\n-     *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return the random integer.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n-     */\n-    public long nextSecureLong(long lower, long upper) {\n+    /** {@inheritDoc} */\n+    public long nextSecureLong(long lower, long upper)\n+        throws NumberIsTooLargeException {\n+\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n      * <li> For large means, uses the rejection algorithm described in <br/>\n      * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n      * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n-     *\n-     * @param mean mean of the Poisson distribution.\n-     * @return the random Poisson value.\n-     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n-     */\n-    public long nextPoisson(double mean) {\n+     */\n+    public long nextPoisson(double mean) throws NotStrictlyPositiveException {\n         if (mean <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n         }\n     }\n \n-    /**\n-     * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n-     * the given mean, <code>mu</code> and the given standard deviation,\n-     * <code>sigma</code>.\n-     *\n-     * @param mu\n-     *            the mean of the distribution\n-     * @param sigma\n-     *            the standard deviation of the distribution\n-     * @return the random Normal value\n-     * @throws NotStrictlyPositiveException if {@code sigma <= 0}.\n-     */\n-    public double nextGaussian(double mu, double sigma) {\n+    /** {@inheritDoc} */\n+    public double nextGaussian(double mu, double sigma)\n+        throws NotStrictlyPositiveException {\n+\n         if (sigma <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n         }\n     }\n \n     /**\n-     * Returns a random value from an Exponential distribution with the given\n-     * mean.\n+     * {@inheritDoc}\n+     *\n      * <p>\n      * <strong>Algorithm Description</strong>: Uses the Algorithm SA (Ahrens)\n      * from p. 876 in:\n      * sampling from the exponential and normal distributions.\n      * Communications of the ACM, 15, 873-882.\n      * </p>\n-     *\n-     * @param mean the mean of the distribution\n-     * @return the random Exponential value\n-     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n-     */\n-    public double nextExponential(double mean) {\n+     */\n+    public double nextExponential(double mean)\n+        throws NotStrictlyPositiveException {\n+\n         if (mean <= 0.0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n \n     /**\n      * {@inheritDoc}\n+     *\n      * <p>\n      * <strong>Algorithm Description</strong>: scales the output of\n      * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n      *\n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return a uniformly distributed random value from the interval (lower, upper)\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}\n      * @throws MathIllegalArgumentException if one of the bounds is infinite or\n-     * {@code NaN}\n-     * or either bound is infinite or NaN\n-     */\n-    public double nextUniform(double lower, double upper) {\n+     * {@code NaN} or either bound is infinite or NaN\n+     */\n+    public double nextUniform(double lower, double upper)\n+        throws NumberIsTooLargeException, MathIllegalArgumentException {\n+\n         return nextUniform(lower, upper, false);\n     }\n \n     /**\n      * {@inheritDoc}\n+     *\n      * <p>\n      * <strong>Algorithm Description</strong>: if the lower bound is excluded,\n      * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,\n      * endpoints excluded).\n      * </p>\n      *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @param lowerInclusive\n-     *            whether the lower bound is included in the interval\n-     * @return a uniformly distributed random value from the interval (lower,\n-     *         upper)\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}\n      * @throws MathIllegalArgumentException if one of the bounds is infinite or\n      * {@code NaN}\n      * @since 3.0\n      */\n-    public double nextUniform(double lower, double upper, boolean lowerInclusive) {\n+    public double nextUniform(double lower, double upper,\n+        boolean lowerInclusive)\n+        throws NumberIsTooLargeException, MathIllegalArgumentException {\n+\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n     }\n \n     /**\n-     * Generates an integer array of length <code>k</code> whose entries are\n-     * selected randomly, without repetition, from the integers\n-     * <code>0 through n-1</code> (inclusive).\n-     * <p>\n-     * Generated arrays represent permutations of <code>n</code> taken\n-     * <code>k</code> at a time.\n-     * </p>\n-     * <p>\n-     * <strong>Preconditions:</strong>\n-     * <ul>\n-     * <li> <code>k <= n</code></li>\n-     * <li> <code>n > 0</code></li>\n-     * </ul>\n-     * If the preconditions are not met, an IllegalArgumentException is thrown.\n-     * </p>\n+     * {@inheritDoc}\n+     *\n      * <p>\n      * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n      * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>.\n      * </p>\n-     *\n-     * @param n\n-     *            domain of the permutation (must be positive)\n-     * @param k\n-     *            size of the permutation (must satisfy 0 < k <= n).\n-     * @return the random permutation as an int array\n-     * @throws NumberIsTooLargeException if {@code k > n}.\n-     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n      */\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n             throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                 k, n, true);\n         }\n-        if (k == 0) {\n+        if (k <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                    k);\n         }\n     }\n \n     /**\n-     * Uses a 2-cycle permutation shuffle to generate a random permutation.\n+     * {@inheritDoc}\n+     *\n+     * <p>\n      * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n      * shuffle to generate a random permutation of <code>c.size()</code> and\n      * then returns the elements whose indexes correspond to the elements of the\n      * generated permutation. This technique is described, and proven to\n-     * generate random samples, <a\n+     * generate random samples <a\n      * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>\n-     *\n-     * @param c\n-     *            Collection to sample from.\n-     * @param k\n-     *            sample size.\n-     * @return the random sample.\n-     * @throws NumberIsTooLargeException if {@code k > c.size()}.\n-     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n-     */\n-    public Object[] nextSample(Collection<?> c, int k) {\n+     * </p>\n+     */\n+    public Object[] nextSample(Collection<?> c, int k)\n+        throws NumberIsTooLargeException, NotStrictlyPositiveException {\n+\n         int len = c.size();\n         if (k > len) {\n             throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,", "timestamp": 1326438250, "metainfo": ""}