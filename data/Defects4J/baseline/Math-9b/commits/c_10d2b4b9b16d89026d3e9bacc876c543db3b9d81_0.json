{"sha": "10d2b4b9b16d89026d3e9bacc876c543db3b9d81", "log": "Rewrite StatUtils to use static instances of UnivariateStatistics. Benefits?   1.) In the future, when we establish \"Factories\" for these objects, we'll be able to plug implementations in, even under our static Utilities classes for these functions.   2.) The  user can always rely on the same result, whether using the StaticUtil, Univariate Container or direct UnivariateStatistic.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  */\n package org.apache.commons.math.stat;\n \n+import org.apache.commons.math.stat.univariate.UnivariateStatistic;\n+import org.apache.commons.math.stat.univariate.moment.Mean;\n+import org.apache.commons.math.stat.univariate.moment.Variance;\n+import org.apache.commons.math.stat.univariate.rank.Max;\n+import org.apache.commons.math.stat.univariate.rank.Min;\n+import org.apache.commons.math.stat.univariate.summary.Product;\n+import org.apache.commons.math.stat.univariate.summary.Sum;\n+import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n+import org.apache.commons.math.stat.univariate.summary.SumOfSquares;\n+\n /**\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  * identified in the javadoc for each method, Double.NaN.\n- * @version $Revision: 1.18 $ $Date: 2003/10/16 15:24:30 $\n+ * @version $Revision: 1.19 $ $Date: 2003/10/16 15:59:40 $\n  */\n public final class StatUtils {\n \n+\t/** sum */\n+\tprivate static UnivariateStatistic sum = new Sum();\n+\t\n+\t/** sumSq */\n+\tprivate static UnivariateStatistic sumSq = new SumOfSquares();\n+\t\n+\t/** prod */\n+\tprivate static UnivariateStatistic prod = new Product();\n+\t\n+\t/** sumLog */\n+\tprivate static UnivariateStatistic sumLog = new SumOfLogs();\n+\t\n+\t/** min */\n+\tprivate static UnivariateStatistic min = new Min();\t\n+\t\n+\t/** max */\n+\tprivate static UnivariateStatistic max = new Max();\t\n+\t\n+\t/** mean */\n+\tprivate static UnivariateStatistic mean = new Mean();\t\n+\t\n+\t/** variance */\n+\tprivate static UnivariateStatistic variance = new Variance();\t\n+\t\t\n     /**\n      * Private Constructor\n      */\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n     public static double sum(final double[] values) {\n-        return sum(values, 0, values.length);\n+\t\treturn sum.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        double accum = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += values[i];\n-        }\n-        return accum;\n+        return sum.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n     public static double sumSq(final double[] values) {\n-        return sumSq(values, 0, values.length);\n+\t\treturn sumSq.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        double accum = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow(values[i], 2.0);\n-        }\n-        return accum;\n+        return sumSq.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the product values or Double.NaN if the array is empty\n      */\n     public static double product(final double[] values) {\n-        return product(values, 0, values.length);\n+        return prod.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        double product = 1.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            product *= values[i];\n-        }\n-        return product;\n+        return prod.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n     public static double sumLog(final double[] values) {\n-        return sumLog(values, 0, values.length);\n+\t\treturn sumLog.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        double sumLog = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            sumLog += Math.log(values[i]);\n-        }\n-        return sumLog;\n+\t\treturn sumLog.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the mean of the values or Double.NaN if the array is empty\n      */\n     public static double mean(final double[] values) {\n-        return sum(values) / (double) values.length;\n+\t\treturn mean.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        return sum(values, begin, length) / ((double) length);\n+        return mean.evaluate(values, begin, length);\n     }\n \n     /**\n      * or 0.0 for a single value set.\n      */\n     public static double variance(final double[] values) {\n-        return variance(values, 0, values.length);\n+\t\treturn variance.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-\n-        double variance = Double.NaN;\n-        if (values.length == 1) {\n-            variance = 0;\n-        } else if (values.length > 1) {\n-            double mean = mean(values, begin, length);\n-            double accum = 0.0;\n-            double accum2 = 0.0;\n-            for (int i = begin; i < begin + length; i++) {\n-                accum += Math.pow((values[i] - mean), 2.0);\n-                accum2 += (values[i] - mean);\n-            }\n-            variance =\n-                (accum - (Math.pow(accum2, 2) / ((double) length))) /\n-                (double) (length - 1);\n-        }\n-        return variance;\n+        return variance.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n     public static double max(final double[] values) {\n-        return max(values, 0, values.length);\n+\t\treturn max.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-        testInput(values, begin, length);\n-        double max = Double.NaN;\n-        for (int i = begin; i < begin + length; i++) {\n-            if (i == 0) {\n-                max = values[i];\n-            } else {\n-                if (max < values[i]) {\n-                    max = values[i];\n-                }\n-            }\n-        }\n-        return max;\n+        return max.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n     public static double min(final double[] values) {\n-        return min(values, 0, values.length);\n+\t\treturn min.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-\n-        testInput(values, begin, length);\n-\n-        double min = Double.NaN;\n-        for (int i = begin; i < begin + length; i++) {\n-            if (i == 0) {\n-                min = values[i];\n-            } else {\n-                if (min > values[i]) {\n-                    min = values[i];\n-                }\n-            }\n-        }\n-        return min;\n-    }\n-\n-    /**\n-     * Private testInput method used by all methods to verify the content\n-     * of the array and indicies are correct.\n-     * @param values Is a double[] containing the values\n-     * @param begin processing at this point in the array\n-     * @param length processing at this point in the array\n-     */\n-    private static void testInput(\n-        final double[] values,\n-        final int begin,\n-        final int length) {\n-\n-        if (length > values.length) {\n-            throw new IllegalArgumentException(\"length > values.length\");\n-        }\n-\n-        if (begin + length > values.length) {\n-            throw new IllegalArgumentException(\n-               \"begin + length > values.length\");\n-        }\n-\n-        if (values == null) {\n-            throw new IllegalArgumentException(\"input value array is null\");\n-        }\n-    }\n-}\n+        return min.evaluate(values, begin, length);\n+    }\n+\n+}", "timestamp": 1066319980, "metainfo": ""}