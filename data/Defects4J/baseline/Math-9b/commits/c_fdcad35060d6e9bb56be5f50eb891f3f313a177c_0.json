{"sha": "fdcad35060d6e9bb56be5f50eb891f3f313a177c", "log": "Added a BigFraction class that does not overflow when big numerators or denominators are used. Jira: MATH-251  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n     }\n \n     /**\n+     * Constructs a new <code>NullPointerException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static NullPointerException createNullPointerException(final String pattern,\n+                                                                  final Object ... arguments) {\n+        return new NullPointerException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -3075660477939965216L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+   /**\n      * Constructs a new <code>ParseException</code> with specified\n      * formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"Impossible de convertir {0} en fraction apr\\u00e8s {1} it\\u00e9rations\" },\n     { \"Overflow trying to convert {0} to fraction ({1}/{2})\",\n       \"D\\u00e9passement de capacit\\u00e9 lors de la conversion de {0} en fraction ({1}/{2})\" },\n+\n+    // org.apache.commons.math.fraction.BigFraction\n+    { \"numerator is null\",\n+      \"le num\\u00e9rateur est null\" },\n+    { \"denimonator is null\",\n+      \"le d\\u00e9nominateur est null\" },\n+    { \"denominator must be different from 0\",\n+      \"le d\\u00e9nominateur doit \\u00eatre diff\\u00e9rent de 0\" },\n+    { \"cannot convert NaN value\",\n+      \"les valeurs NaN ne peuvent \\u00eatre converties\" },\n+    { \"cannot convert infinite value\",\n+      \"les valeurs infinies ne peuvent \\u00eatre converties\" },\n \n     // org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils\n     { \"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4},\" +\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/BigFraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Representation of a rational number without any overflow. This class is\n+ * immutable.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BigFraction extends Number implements Comparable<BigFraction>, Cloneable {\n+\n+    /** A fraction representing \"1\". */\n+    public static final BigFraction ONE = new BigFraction(1, 1);\n+\n+    /** A fraction representing \"0\". */\n+    public static final BigFraction ZERO = new BigFraction(0, 1);\n+\n+    /** A fraction representing \"4/5\". */\n+    public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);\n+\n+    /** A fraction representing \"1/5\". */\n+    public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);\n+\n+    /** A fraction representing \"1/2\". */\n+    public static final BigFraction ONE_HALF = new BigFraction(1, 2);\n+\n+    /** A fraction representing \"1/4\". */\n+    public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);\n+\n+    /** A fraction representing \"1/3\". */\n+    public static final BigFraction ONE_THIRD = new BigFraction(1, 3);\n+\n+    /** A fraction representing \"3/5\". */\n+    public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);\n+\n+    /** A fraction representing \"3/4\". */\n+    public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);\n+\n+    /** A fraction representing \"4/5\". */\n+    public static final BigFraction TWO_FIFTHS = new BigFraction(4, 5);\n+\n+    /** A fraction representing \"2/4\". */\n+    public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);\n+\n+    /** A fraction representing \"2/3\". */\n+    public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);\n+\n+    /** A fraction representing \"-1 / 1\". */\n+    public static final BigFraction MINUS_ONE = new BigFraction(-1, 1);\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5984892138972589598L;\n+\n+    /** <code>BigInteger</code> representation of 100. */\n+    private static final BigInteger ONE_HUNDRED_DOUBLE = BigInteger.valueOf(100);\n+\n+    /** The numerator. */\n+    private final BigInteger numerator;\n+\n+    /** The denominator. */\n+    private final BigInteger denominator;\n+\n+    /**\n+     * <p>\n+     * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n+     * Y/Z.\n+     * </p>\n+     * \n+     * <p>\n+     * Any negative signs are resolved to be on the numerator.\n+     * </p>\n+     * \n+     * @param numerator\n+     *            the numerator, for example the three in 'three sevenths'.\n+     * @param denominator\n+     *            the denominator, for example the seven in 'three sevenths'.\n+     * @return a new fraction instance, with the numerator and denominator\n+     *         reduced.\n+     * @throws ArithmeticException\n+     *             if the denominator is <code>zero</code>.\n+     */\n+    public static BigFraction getReducedFraction(final int numerator,\n+                                                 final int denominator) {\n+        if (numerator == 0) {\n+            return ZERO; // normalize zero.\n+        }\n+\n+        return new BigFraction(numerator, denominator).reduce();\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed <tt>BigInteger</tt>, ie\n+     * \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final BigInteger num) {\n+        this(num, BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as\n+     * <code>BigInteger</code>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator, must not be <code>null</code>.\n+     * @param den\n+     *            the denominator, must not be <code>null</code>.\n+     * @throws ArithmeticException\n+     *             if the denominator is <code>zero</code>.\n+     * @throws NullPointerException\n+     *             if the numerator or the denominator is <code>zero</code>.\n+     */\n+    public BigFraction(BigInteger num, BigInteger den) {\n+        if (num == null) {\n+            throw MathRuntimeException.createNullPointerException(\"numerator is null\");\n+        }\n+        if (den == null) {\n+            throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n+        }\n+        if (BigInteger.ZERO.equals(den)) {\n+            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+        }\n+        if (BigInteger.ZERO.equals(num)) {\n+            numerator   = BigInteger.ZERO;\n+            denominator = BigInteger.ONE;\n+        } else {\n+\n+            // reduce numerator and denominator by greatest common denominator\n+            final BigInteger gcd = num.gcd(den);\n+            if (BigInteger.ONE.compareTo(gcd) < 0) {\n+                num = num.divide(gcd);\n+                den = den.divide(gcd);\n+            }\n+\n+            // move sign to numerator\n+            if (BigInteger.ZERO.compareTo(den) > 0) {\n+                num = num.negate();\n+                den = den.negate();\n+            }\n+\n+            // store the values in the final fields\n+            numerator   = num;\n+            denominator = den;\n+\n+        }\n+    }\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * <p>\n+     * This constructor behaves <em>differently</em> from\n+     * {@link #BigFraction(double, double, int)}. It converts the\n+     * double value exactly, considering its internal bits representation.\n+     * This does work for all values except NaN and infinities and does\n+     * not requires any loop or convergence threshold.\n+     * </p>\n+     * <p>\n+     * Since this conversion is exact and since double numbers are sometimes\n+     * approximated, the fraction created may seem strange in some cases. For example\n+     * calling <code>new BigFraction(1.0 / 3.0)</code> does <em>not</em> create\n+     * the fraction 1/3 but the fraction 6004799503160661 / 18014398509481984\n+     * because the double number passed to the constructor is not exactly 1/3\n+     * (this number cannot be stored exactly in IEEE754).\n+     * </p>\n+     * @see #BigFraction(double, double, int)\n+     * @param value the double value to convert to a fraction.\n+     * @exception IllegalArgumentException if value is NaN or infinite\n+     */\n+    public BigFraction(final double value) throws IllegalArgumentException {\n+        if (Double.isNaN(value)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert NaN value\");\n+        }\n+        if (Double.isInfinite(value)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert infinite value\");\n+        }\n+\n+        // compute m and k such that value = m * 2^k\n+        final long bits     = Double.doubleToLongBits(value);\n+        final long sign     = bits & 0x8000000000000000L;\n+        final long exponent = bits & 0x7ff0000000000000L;\n+        long m              = bits & 0x000fffffffffffffL;\n+        if (exponent != 0) {\n+            // this was a normalized number, add the implicit most significant bit\n+            m |= 0x0010000000000000L;\n+        }\n+        if (sign != 0) {\n+            m = -m;\n+        }\n+        int k = ((int) (exponent >> 52)) - 1075;\n+        while (((m & 0x001ffffffffffffeL) != 0) && ((m & 0x1) == 0)) {\n+            m = m >> 1;\n+            ++k;\n+        }\n+\n+        if (k < 0) {\n+            numerator   = BigInteger.valueOf(m);\n+            denominator = BigInteger.ZERO.flipBit(-k);\n+        } else {\n+            numerator   = BigInteger.valueOf(m).multiply(BigInteger.ZERO.flipBit(k));\n+            denominator = BigInteger.ONE;\n+        }\n+\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum error allowed.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param epsilon\n+     *            maximum error allowed. The resulting fraction is within\n+     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxIterations\n+     *            maximum number of convergents.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     * @see #BigFraction(double)\n+     */\n+    public BigFraction(final double value, final double epsilon,\n+                       final int maxIterations)\n+        throws FractionConversionException {\n+        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and either the maximum error\n+     * allowed or the maximum number of denominator digits.\n+     * <p>\n+     * \n+     * NOTE: This constructor is called with EITHER - a valid epsilon value and\n+     * the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator\n+     * has no effect). OR - a valid maxDenominator value and the epsilon value\n+     * set to zero (that way epsilon only has effect if there is an exact match\n+     * before the maxDenominator value is reached).\n+     * </p>\n+     * <p>\n+     * \n+     * It has been done this way so that the same code can be (re)used for both\n+     * scenarios. However this could be confusing to users if it were part of\n+     * the public API and this constructor should therefore remain PRIVATE.\n+     * </p>\n+     * \n+     * See JIRA issue ticket MATH-181 for more details:\n+     * \n+     * https://issues.apache.org/jira/browse/MATH-181\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param epsilon\n+     *            maximum error allowed. The resulting fraction is within\n+     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxDenominator\n+     *            maximum denominator value allowed.\n+     * @param maxIterations\n+     *            maximum number of convergents.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     */\n+    private BigFraction(final double value, final double epsilon,\n+                        final int maxDenominator, int maxIterations)\n+        throws FractionConversionException {\n+        long overflow = Integer.MAX_VALUE;\n+        double r0 = value;\n+        long a0 = (long) Math.floor(r0);\n+        if (a0 > overflow) {\n+            throw new FractionConversionException(value, a0, 1l);\n+        }\n+\n+        // check for (almost) integer arguments, which should not go\n+        // to iterations.\n+        if (Math.abs(a0 - value) < epsilon) {\n+            numerator = BigInteger.valueOf(a0);\n+            denominator = BigInteger.ONE;\n+            return;\n+        }\n+\n+        long p0 = 1;\n+        long q0 = 0;\n+        long p1 = a0;\n+        long q1 = 1;\n+\n+        long p2 = 0;\n+        long q2 = 1;\n+\n+        int n = 0;\n+        boolean stop = false;\n+        do {\n+            ++n;\n+            final double r1 = 1.0 / (r0 - a0);\n+            final long a1 = (long) Math.floor(r1);\n+            p2 = (a1 * p1) + p0;\n+            q2 = (a1 * q1) + q0;\n+            if ((p2 > overflow) || (q2 > overflow)) {\n+                throw new FractionConversionException(value, p2, q2);\n+            }\n+\n+            final double convergent = (double) p2 / (double) q2;\n+            if ((n < maxIterations) &&\n+                (Math.abs(convergent - value) > epsilon) &&\n+                (q2 < maxDenominator)) {\n+                p0 = p1;\n+                p1 = p2;\n+                q0 = q1;\n+                q1 = q2;\n+                a0 = a1;\n+                r0 = r1;\n+            } else {\n+                stop = true;\n+            }\n+        } while (!stop);\n+\n+        if (n >= maxIterations) {\n+            throw new FractionConversionException(value, maxIterations);\n+        }\n+\n+        if (q2 < maxDenominator) {\n+            numerator   = BigInteger.valueOf(p2);\n+            denominator = BigInteger.valueOf(q2);\n+        } else {\n+            numerator   = BigInteger.valueOf(p1);\n+            denominator = BigInteger.valueOf(q1);\n+        }\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum denominator.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param maxDenominator\n+     *            The maximum allowed value for denominator.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     */\n+    public BigFraction(final double value, final int maxDenominator)\n+        throws FractionConversionException {\n+        this(value, 0, maxDenominator, 100);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed <tt>int</tt>, ie\n+     * \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final int num) {\n+        this(BigInteger.valueOf(num), BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as simple\n+     * <tt>int</tt>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     * @param den\n+     *            the denominator.\n+     */\n+    public BigFraction(final int num, final int den) {\n+        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed long, ie \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final long num) {\n+        this(BigInteger.valueOf(num), BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as simple\n+     * <tt>long</tt>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     * @param den\n+     *            the denominator.\n+     */\n+    public BigFraction(final long num, final long den) {\n+        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the absolute value of this {@link BigFraction}.\n+     * </p>\n+     * \n+     * @return the absolute value as a {@link BigFraction}.\n+     */\n+    public BigFraction abs() {\n+        return (BigInteger.ZERO.compareTo(numerator) <= 0) ? this : negate();\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed {@link BigInteger},\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the {@link BigInteger} to add, must'nt be <code>null</code>.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigInteger} is <code>null</code>.\n+     */\n+    public BigFraction add(final BigInteger bg) {\n+        return add(new BigFraction(bg, BigInteger.ONE));\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the {@link BigFraction} to add, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigFraction} is <code>null</code>.\n+     */\n+    public BigFraction add(final BigFraction fraction) {\n+        if (ZERO.equals(fraction)) {\n+            return this;\n+        }\n+\n+        BigInteger num = null;\n+        BigInteger den = null;\n+\n+        if (denominator.equals(fraction.denominator)) {\n+            num = numerator.add(fraction.numerator);\n+            den = denominator;\n+        } else {\n+            num = (numerator.multiply(fraction.denominator)).add((fraction.numerator).multiply(denominator));\n+            den = denominator.multiply(fraction.denominator);\n+        }\n+        return new BigFraction(num, den);\n+\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed <tt>integer</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>integer</tt> to add.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction add(final int i) {\n+        return add(new BigFraction(i, 1));\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed <tt>long</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to add.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction add(final long l) {\n+        return add(new BigFraction(l, 1L));\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code>. This calculates the\n+     * fraction as the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @throws ArithmeticException\n+     *             if the exact quotient does not have a terminating decimal\n+     *             expansion.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue() {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator));\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code> following the passed\n+     * rounding mode. This calculates the fraction as the numerator divided by\n+     * denominator.\n+     * </p>\n+     * \n+     * @param roundingMode\n+     *            rounding mode to apply. see {@link BigDecimal} constants.\n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @throws IllegalArgumentException\n+     *             if <tt>roundingMode</tt> does not represent a valid rounding\n+     *             mode.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue(final int roundingMode) {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator), roundingMode);\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code> following the passed scale\n+     * and rounding mode. This calculates the fraction as the numerator divided\n+     * by denominator.\n+     * </p>\n+     * \n+     * @param scale\n+     *            scale of the <code>BigDecimal</code> quotient to be returned.\n+     *            see {@link BigDecimal} for more information.\n+     * @param roundingMode\n+     *            rounding mode to apply. see {@link BigDecimal} constants.\n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue(final int scale, final int roundingMode) {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator), scale, roundingMode);\n+    }\n+\n+    /**\n+     * <p>\n+     * Clones this object. The result {@link BigFraction} isn't reduced and is\n+     * exactly the same as the original.\n+     * </p>\n+     * \n+     * @return an exact copy of this {@link BigFraction}.\n+     * @see java.lang.Object#clone()\n+     */\n+    @Override\n+    public BigFraction clone() {\n+        // don't need to clone numerator and denominator because the object is\n+        // immutable\n+        BigFraction clone = null;\n+\n+        try {\n+            clone = (BigFraction) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return clone;\n+    }\n+\n+    /**\n+     * <p>\n+     * Compares this object to another based on size.\n+     * </p>\n+     * \n+     * @param object\n+     *            the object to compare to, must not be <code>null</code>.\n+     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n+     *         than <tt>object</tt>, 0 if they are equal.\n+     * @see java.lang.Comparable#compareTo(java.lang.Object)\n+     */\n+    public int compareTo(final BigFraction object) {\n+        BigInteger nOd = numerator.multiply(object.denominator);\n+        BigInteger dOn = denominator.multiply(object.numerator);\n+        return nOd.compareTo(dOn);\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <code>BigInteger</code>,\n+     * ie \"this * 1 / bg\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the <code>BigInteger</code> to divide by, must not be\n+     *            <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the <code>BigInteger</code> is <code>null</code>.\n+     */\n+    public BigFraction divide(final BigInteger bg) {\n+        return divide(new BigFraction(bg, BigInteger.ONE));\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the fraction to divide by, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     * @throws ArithmeticException\n+     *             if the fraction to divide by is zero.\n+     */\n+    public BigFraction divide(final BigFraction fraction) {\n+        if (BigInteger.ZERO.equals(fraction.numerator)) {\n+            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+        }\n+\n+        return multiply(fraction.reciprocal());\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <tt>int</tt>, ie\n+     * \"this * 1 / i\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>int</tt> to divide by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction divide(final int i) {\n+        return divide(new BigFraction(i, 1));\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <tt>long</tt>, ie\n+     * \"this * 1 / l\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to divide by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction divide(final long l) {\n+        return divide(new BigFraction(l, 1L));\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <tt>double</tt>\n+     * @see java.lang.Number#doubleValue()\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return numerator.doubleValue() / denominator.doubleValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Test for the equality of two fractions. If the lowest term numerator and\n+     * denominators are the same for both fractions, the two fractions are\n+     * considered to be equal.\n+     * </p>\n+     * \n+     * @param other\n+     *            fraction to test for equality to this fraction, can be\n+     *            <code>null</code>.\n+     * @return true if two fractions are equal, false if object is\n+     *         <code>null</code>, not an instance of {@link BigFraction}, or not\n+     *         equal to this fraction instance.\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    @Override\n+    public boolean equals(final Object other) {\n+        boolean ret = false;\n+\n+        if (this == other) {\n+            ret = true;\n+        } else if (other instanceof BigFraction) {\n+            BigFraction rhs = ((BigFraction) other).reduce();\n+            BigFraction thisOne = this.reduce();\n+            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <tt>float</tt>.\n+     * @see java.lang.Number#floatValue()\n+     */\n+    @Override\n+    public float floatValue() {\n+        return numerator.floatValue() / denominator.floatValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <code>BigInteger</code>.\n+     * </p>\n+     * \n+     * @return the denominator as a <code>BigInteger</code>.\n+     */\n+    public BigInteger getDenominator() {\n+        return denominator;\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <tt>int</tt>.\n+     * </p>\n+     * \n+     * @return the denominator as a <tt>int</tt>.\n+     */\n+    public int getDenominatorAsInt() {\n+        return denominator.intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <tt>long</tt>.\n+     * </p>\n+     * \n+     * @return the denominator as a <tt>long</tt>.\n+     */\n+    public long getDenominatorAsLong() {\n+        return denominator.longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <code>BigInteger</code>.\n+     * </p>\n+     * \n+     * @return the numerator as a <code>BigInteger</code>.\n+     */\n+    public BigInteger getNumerator() {\n+        return numerator;\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <tt>int</tt>.\n+     * </p>\n+     * \n+     * @return the numerator as a <tt>int</tt>.\n+     */\n+    public int getNumeratorAsInt() {\n+        return numerator.intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <tt>long</tt>.\n+     * </p>\n+     * \n+     * @return the numerator as a <tt>long</tt>.\n+     */\n+    public long getNumeratorAsLong() {\n+        return numerator.longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a hashCode for the fraction.\n+     * </p>\n+     * \n+     * @return a hash code value for this object.\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 37 * (37 * 17 + numerator.hashCode()) + denominator.hashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n+     * of the fraction.\n+     * </p>\n+     * \n+     * @return the whole number fraction part.\n+     * @see java.lang.Number#intValue()\n+     */\n+    @Override\n+    public int intValue() {\n+        return numerator.divide(denominator).intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n+     * of the fraction.\n+     * </p>\n+     * \n+     * @return the whole number fraction part.\n+     * @see java.lang.Number#longValue()\n+     */\n+    @Override\n+    public long longValue() {\n+        return numerator.divide(denominator).longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiplies the value of this fraction by the passed\n+     * <code>BigInteger</code>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the <code>BigInteger</code> to multiply by.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the bg is <code>null</code>.\n+     */\n+    public BigFraction multiply(final BigInteger bg) {\n+        return new BigFraction(bg.multiply(numerator), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiplies the value of this fraction by another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the fraction to multiply by, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     */\n+    public BigFraction multiply(final BigFraction fraction) {\n+        BigFraction ret = ZERO;\n+\n+        if (getNumeratorAsInt() != 0 && fraction.getNumeratorAsInt() != 0) {\n+            ret = new BigFraction(numerator.multiply(fraction.numerator), denominator.multiply(fraction.denominator));\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiply the value of this fraction by the passed <tt>int</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>int</tt> to multiply by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction multiply(final int i) {\n+        return multiply(new BigFraction(i, 1));\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiply the value of this fraction by the passed <tt>long</tt>,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to multiply by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction multiply(final long l) {\n+        return multiply(new BigFraction(l, 1L));\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the additive inverse of this fraction, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @return the negation of this fraction.\n+     */\n+    public BigFraction negate() {\n+        return new BigFraction(numerator.negate(), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n+     * fraction as the numerator divided by denominator multiplied by 100.\n+     * </p>\n+     * \n+     * @return the fraction percentage as a <tt>double</tt>.\n+     */\n+    public double percentageValue() {\n+        return (numerator.divide(denominator)).multiply(ONE_HUNDRED_DOUBLE).doubleValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <code>BigFraction</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n+     */\n+    public BigFraction pow(final BigInteger exponent) {\n+        BigFraction ret = this;\n+        if (!BigInteger.ONE.equals(exponent)) {\n+            ret = ONE;\n+            if (!BigInteger.ZERO.equals(exponent)) {\n+                for (BigInteger bg = BigInteger.ONE; bg.compareTo(exponent) < 0; bg = bg.add(BigInteger.ONE)) {\n+                    ret = ret.multiply(this);\n+                }\n+            }\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <code>BigFraction</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt>.\n+     */\n+    public double pow(final BigFraction exponent) {\n+        return Math.pow(numerator.doubleValue(), exponent.doubleValue()) / Math.pow(denominator.doubleValue(), exponent.doubleValue());\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <tt>integer</tt> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigInteger</code> is to be\n+     *            raised.\n+     * @return <tt>this<sup>exponent</sup></tt>.\n+     */\n+    public BigFraction pow(final int exponent) {\n+        return pow(BigInteger.valueOf(exponent));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <code>BigFraction</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n+     */\n+    public BigFraction pow(final long exponent) {\n+        return pow(BigInteger.valueOf(exponent));\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the multiplicative inverse of this fraction.\n+     * </p>\n+     * \n+     * @return the reciprocal fraction.\n+     */\n+    public BigFraction reciprocal() {\n+        return new BigFraction(denominator, numerator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Reduce this <code>BigFraction</code> to its lowest terms.\n+     * </p>\n+     * \n+     * @return the reduced <code>BigFraction</code>. It doesn't change anything if\n+     *         the fraction can be reduced.\n+     */\n+    public BigFraction reduce() {\n+        final BigInteger gcd = numerator.gcd(denominator);\n+        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an {@link BigInteger} from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the {@link BigInteger} to subtract, must'nt be\n+     *            <code>null</code>.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigInteger} is <code>null</code>.\n+     */\n+    public BigFraction subtract(final BigInteger bg) {\n+        return subtract(new BigFraction(bg, BigInteger.valueOf(1)));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of another fraction from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the {@link BigFraction} to subtract, must not be\n+     *            <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     */\n+    public BigFraction subtract(final BigFraction fraction) {\n+        BigFraction ret = null;\n+\n+        if (ZERO.equals(fraction)) {\n+            ret = clone();\n+        } else {\n+            BigInteger num = null;\n+            BigInteger den = null;\n+\n+            if (denominator.equals(fraction.denominator)) {\n+                num = numerator.subtract(fraction.numerator);\n+                den = denominator;\n+            } else {\n+                num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n+                den = denominator.multiply(fraction.denominator);\n+            }\n+            ret = new BigFraction(num, den);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an <tt>integer</tt> from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>integer</tt> to subtract.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction subtract(final int i) {\n+        return subtract(new BigFraction(i, 1));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an <tt>integer</tt> from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to subtract.\n+     * @return a <code>BigFraction</code> instance with the resulting values, or\n+     *         this object if the <tt>long</tt> is zero.\n+     */\n+    public BigFraction subtract(final long l) {\n+        return subtract(new BigFraction(l, 1L));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the <code>String</code> representing this fraction, ie\n+     * \"num / dem\" or just \"num\" if the denominator is one.\n+     * </p>\n+     * \n+     * @return a string representation of the fraction.\n+     * @see java.lang.Object#toString()\n+     */\n+    @Override\n+    public String toString() {\n+        String str = null;\n+        if (BigInteger.ONE.equals(denominator)) {\n+            str = numerator.toString();\n+        } else if (BigInteger.ZERO.equals(numerator)) {\n+            str = \"0\";\n+        } else {\n+            str = numerator + \" / \" + denominator;\n+        }\n+        return str;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/fraction/BigFractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+import junit.framework.TestCase;\n+\n+public class BigFractionTest extends TestCase {\n+\n+    private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumeratorAsInt());\n+        assertEquals(expectedDenominator, actual.getDenominatorAsInt());\n+    }\n+\n+    private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumeratorAsLong());\n+        assertEquals(expectedDenominator, actual.getDenominatorAsLong());\n+    }\n+\n+    public void testConstructor() {\n+        assertFraction(0, 1, new BigFraction(0, 1));\n+        assertFraction(0, 1, new BigFraction(0l, 2l));\n+        assertFraction(0, 1, new BigFraction(0, -1));\n+        assertFraction(1, 2, new BigFraction(1, 2));\n+        assertFraction(1, 2, new BigFraction(2, 4));\n+        assertFraction(-1, 2, new BigFraction(-1, 2));\n+        assertFraction(-1, 2, new BigFraction(1, -2));\n+        assertFraction(-1, 2, new BigFraction(-2, 4));\n+        assertFraction(-1, 2, new BigFraction(2, -4));\n+        assertFraction(11, 1, new BigFraction(11));\n+        assertFraction(11, 1, new BigFraction(11l));\n+        assertFraction(11, 1, new BigFraction(new BigInteger(\"11\")));\n+\n+        try {\n+            assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100));\n+            assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));\n+            assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));\n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+        assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);\n+        assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);\n+        assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);\n+        assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));\n+        assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));\n+        try {\n+            new BigFraction(null, BigInteger.ONE);\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(BigInteger.ONE, null);\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(BigInteger.ONE, BigInteger.ZERO);\n+        } catch (ArithmeticException npe) {\n+            // expected\n+        }\n+        try {\n+            new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);\n+        } catch (FractionConversionException fce) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGoldenRatio() {\n+        try {\n+            // the golden ratio is notoriously a difficult number for continuous\n+            // fraction\n+            new BigFraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConvergenceException ce) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    // MATH-179\n+    public void testDoubleConstructor() throws ConvergenceException {\n+        assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));\n+        assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));\n+        assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100));\n+        assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100));\n+        assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100));\n+        assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100));\n+        assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100));\n+        assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100));\n+        assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100));\n+        assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100));\n+        assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100));\n+        assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100));\n+        assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100));\n+        assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100));\n+        assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100));\n+        assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100));\n+        assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100));\n+        assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100));\n+        assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100));\n+        assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100));\n+        assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100));\n+        assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100));\n+        assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100));\n+        assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100));\n+        assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100));\n+        assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100));\n+        assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100));\n+        assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100));\n+        assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100));\n+        assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100));\n+        assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100));\n+        assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100));\n+        assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100));\n+        assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100));\n+        assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100));\n+        assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100));\n+        assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100));\n+        assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100));\n+        assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100));\n+        assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100));\n+        assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100));\n+    }\n+\n+    // MATH-181\n+    public void testDigitLimitConstructor() throws ConvergenceException {\n+        assertFraction(2, 5, new BigFraction(0.4, 9));\n+        assertFraction(2, 5, new BigFraction(0.4, 99));\n+        assertFraction(2, 5, new BigFraction(0.4, 999));\n+\n+        assertFraction(3, 5, new BigFraction(0.6152, 9));\n+        assertFraction(8, 13, new BigFraction(0.6152, 99));\n+        assertFraction(510, 829, new BigFraction(0.6152, 999));\n+        assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n+    }\n+\n+    public void testEpsilonLimitConstructor() throws ConvergenceException {\n+        assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));\n+\n+        assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100));\n+        assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100));\n+        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100));\n+        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100));\n+        assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100));\n+        assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));\n+    }\n+\n+    public void testCompareTo() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+        BigFraction third = new BigFraction(1, 2);\n+\n+        assertEquals(0, first.compareTo(first));\n+        assertEquals(0, first.compareTo(third));\n+        assertEquals(1, first.compareTo(second));\n+        assertEquals(-1, second.compareTo(first));\n+\n+        // these two values are different approximations of PI\n+        // the first  one is approximately PI - 3.07e-18\n+        // the second one is approximately PI + 1.936e-17\n+        BigFraction pi1 = new BigFraction(1068966896, 340262731);\n+        BigFraction pi2 = new BigFraction( 411557987, 131002976);\n+        assertEquals(-1, pi1.compareTo(pi2));\n+        assertEquals( 1, pi2.compareTo(pi1));\n+        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n+\n+    }\n+\n+    public void testDoubleValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+\n+        assertEquals(0.5, first.doubleValue(), 0.0);\n+        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+\n+    public void testFloatValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(1, 3);\n+\n+        assertEquals(0.5f, first.floatValue(), 0.0f);\n+        assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+\n+    public void testIntValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(3, 2);\n+\n+        assertEquals(0, first.intValue());\n+        assertEquals(1, second.intValue());\n+    }\n+\n+    public void testLongValue() {\n+        BigFraction first = new BigFraction(1, 2);\n+        BigFraction second = new BigFraction(3, 2);\n+\n+        assertEquals(0L, first.longValue());\n+        assertEquals(1L, second.longValue());\n+    }\n+\n+    public void testConstructorDouble() {\n+        assertFraction(1, 2, new BigFraction(0.5));\n+        assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));\n+        assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0));\n+        assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0));\n+        assertFraction(-1, 2, new BigFraction(-0.5));\n+        assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0));\n+        assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0));\n+        assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0));\n+        for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {\n+            try {\n+                new BigFraction(v);\n+                fail(\"expected exception\");\n+            } catch (IllegalArgumentException iae) {\n+                // expected\n+            }\n+        }\n+        assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());\n+        assertEquals(1l, new BigFraction(Double.MIN_NORMAL).getNumeratorAsLong());\n+        assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());\n+    }\n+\n+    public void testAbs() {\n+        BigFraction a = new BigFraction(10, 21);\n+        BigFraction b = new BigFraction(-10, 21);\n+        BigFraction c = new BigFraction(10, -21);\n+\n+        assertFraction(10, 21, a.abs());\n+        assertFraction(10, 21, b.abs());\n+        assertFraction(10, 21, c.abs());\n+    }\n+\n+    public void testReciprocal() {\n+        BigFraction f = null;\n+\n+        f = new BigFraction(50, 75);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumeratorAsInt());\n+        assertEquals(2, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(4, 3);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumeratorAsInt());\n+        assertEquals(4, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(-15, 47);\n+        f = f.reciprocal();\n+        assertEquals(-47, f.getNumeratorAsInt());\n+        assertEquals(15, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(0, 3);\n+        try {\n+            f = f.reciprocal();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+\n+        // large values\n+        f = new BigFraction(Integer.MAX_VALUE, 1);\n+        f = f.reciprocal();\n+        assertEquals(1, f.getNumeratorAsInt());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+    }\n+\n+    public void testNegate() {\n+        BigFraction f = null;\n+\n+        f = new BigFraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-2, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f = new BigFraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(2, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        // large values\n+        f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testAdd() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 1, a.add(a));\n+        assertFraction(7, 6, a.add(b));\n+        assertFraction(7, 6, b.add(a));\n+        assertFraction(4, 3, b.add(b));\n+\n+        BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        BigFraction f2 = BigFraction.ONE;\n+        BigFraction f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(-1, 13 * 13 * 2 * 2);\n+        f2 = new BigFraction(-2, 13 * 17 * 2);\n+        f = f1.add(f2);\n+        assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());\n+        assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());\n+\n+        try {\n+            f.add((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = new BigFraction(1, 32768 * 3);\n+        f2 = new BigFraction(1, 59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumeratorAsInt());\n+        assertEquals(1934917632, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, 3);\n+        f2 = new BigFraction(1, 3);\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(BigInteger.ONE);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(BigInteger.ZERO);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(1);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(0);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);\n+        f = f1.add(1l);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f.add(0l);\n+        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testDivide() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 1, a.divide(a));\n+        assertFraction(3, 4, a.divide(b));\n+        assertFraction(4, 3, b.divide(a));\n+        assertFraction(1, 1, b.divide(b));\n+\n+        BigFraction f1 = new BigFraction(3, 5);\n+        BigFraction f2 = BigFraction.ZERO;\n+        try {\n+            f1.divide(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+        }\n+\n+        f1 = new BigFraction(0, 5);\n+        f2 = new BigFraction(2, 7);\n+        BigFraction f = f1.divide(f2);\n+        assertSame(BigFraction.ZERO, f);\n+\n+        f1 = new BigFraction(2, 7);\n+        f2 = BigFraction.ONE;\n+        f = f1.divide(f2);\n+        assertEquals(2, f.getNumeratorAsInt());\n+        assertEquals(7, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f1);\n+        assertEquals(1, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = new BigFraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        try {\n+            f.divide((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide(Integer.MIN_VALUE);\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.divide((long) Integer.MIN_VALUE);\n+        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());\n+        assertEquals(1, f.getNumeratorAsInt());\n+\n+    }\n+\n+    public void testMultiply() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(1, 4, a.multiply(a));\n+        assertFraction(1, 3, a.multiply(b));\n+        assertFraction(1, 3, b.multiply(a));\n+        assertFraction(4, 9, b.multiply(b));\n+\n+        BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);\n+        BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        BigFraction f = f1.multiply(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f2.multiply(Integer.MAX_VALUE);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        f = f2.multiply((long) Integer.MAX_VALUE);\n+        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+        try {\n+            f.multiply((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+    }\n+\n+    public void testSubtract() {\n+        BigFraction a = new BigFraction(1, 2);\n+        BigFraction b = new BigFraction(2, 3);\n+\n+        assertFraction(0, 1, a.subtract(a));\n+        assertFraction(-1, 6, a.subtract(b));\n+        assertFraction(1, 6, b.subtract(a));\n+        assertFraction(0, 1, b.subtract(b));\n+\n+        BigFraction f = new BigFraction(1, 1);\n+        try {\n+            f.subtract((BigFraction) null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+\n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        BigFraction f1 = new BigFraction(1, 32768 * 3);\n+        BigFraction f2 = new BigFraction(1, 59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumeratorAsInt());\n+        assertEquals(1934917632, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MIN_VALUE, 3);\n+        f2 = new BigFraction(1, 3).negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());\n+        assertEquals(3, f.getDenominatorAsInt());\n+\n+        f1 = new BigFraction(Integer.MAX_VALUE, 1);\n+        f2 = BigFraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());\n+        assertEquals(1, f.getDenominatorAsInt());\n+\n+    }\n+\n+    public void testBigDecimalValue() {\n+        assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());\n+        assertEquals(new BigDecimal(\"0.0003\"), new BigFraction(3, 10000).bigDecimalValue());\n+        assertEquals(new BigDecimal(\"0\"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));\n+        assertEquals(new BigDecimal(\"0.333\"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        BigFraction zero = new BigFraction(0, 1);\n+        BigFraction nullFraction = null;\n+        assertTrue(zero.equals(zero));\n+        assertFalse(zero.equals(nullFraction));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n+        BigFraction zero2 = new BigFraction(0, 2);\n+        assertTrue(zero.equals(zero2));\n+        assertEquals(zero.hashCode(), zero2.hashCode());\n+        BigFraction one = new BigFraction(1, 1);\n+        assertFalse((one.equals(zero) || zero.equals(one)));\n+        assertTrue(one.equals(BigFraction.ONE));\n+    }\n+\n+    public void testGetReducedFraction() {\n+        BigFraction threeFourths = new BigFraction(3, 4);\n+        assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));\n+        assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));\n+        try {\n+            BigFraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);\n+        assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);\n+    }\n+}", "timestamp": 1238264651, "metainfo": ""}