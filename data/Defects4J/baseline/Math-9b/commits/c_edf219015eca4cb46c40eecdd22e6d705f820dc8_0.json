{"sha": "edf219015eca4cb46c40eecdd22e6d705f820dc8", "log": "Provided a factory pattern for the integrators  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegratorFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.discovery.tools.DiscoverClass;\n+\n+/**\n+ * Abstract factory class used to create {@link FirstOrderIntegrator} instances.\n+ * <p>\n+ * Integrators implementing the following fixed stepsize algorithms are supported:\n+ * <ul>\n+ * <li>Euler</li>\n+ * <li>midpoint</li>\n+ * <li>classical Runge-Kutta</li>\n+ * <li>Gill</li>\n+ * <li>3/8</li>\n+ * </ul>\n+ * Concrete factories extending this class also specify a default fixed stepsize integrator,\n+ * instances of which are returned by <code>newDefaultFixedStepsizeIntegrator</code>.\n+ * <p>\n+ * <p>\n+ * Integrators implementing the following adaptive stepsize algorithms are supported:\n+ * <ul>\n+ * <li>Higham-Hall</li>\n+ * <li>Dormand-Prince 5(4)</li>\n+ * <li>Dormand-Pince 8(5,3)</li>\n+ * <li>Gragg-Bulirsch-Stoer</li>\n+ * </ul>\n+ * Concrete factories extending this class also specify default adaptive stepsize integrators,\n+ * instances of which are returned by the two <code>newDefaultAdaptiveStepsizeIntegrator</code>\n+ * methods.\n+ * <p>\n+ * Common usage:<pre>\n+ * FirstOrderIntegratorFactory factory = FirstOrderIntegratorFactory.newInstance();\n+ *\n+ * // create a Dormand-Prince 8(5,3) integrator to use with some step control parameters\n+ * AdaptiveStepsizeIntegrator integrator =\n+ *   factory.newDormandPrince853Integrator(minStep, maxStep,\n+ *                                         scalAbsoluteTolerance,\n+ *                                         scalRelativeTolerance);\n+ * </pre>\n+ *\n+ * <a href=\"http://jakarta.apache.org/commons/discovery/\">Jakarta Commons Discovery</a>\n+ * is used to determine the concrete factory returned by \n+ * <code>FirstOrderIntegratorFactory.newInstance().</code>  The default is\n+ * {@link FirstOrderIntegratorFactoryImpl}\n+ *\n+ * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ */\n+public abstract class FirstOrderIntegratorFactory {\n+\n+    /**\n+     * Default constructor.\n+     */\n+    protected FirstOrderIntegratorFactory() {\n+    }\n+\n+    /**\n+     * Create a new factory.\n+     * @return a new factory\n+     */\n+    public static FirstOrderIntegratorFactory newInstance() {\n+        FirstOrderIntegratorFactory factory = null;\n+        try {\n+            DiscoverClass dc = new DiscoverClass();\n+            factory = (FirstOrderIntegratorFactory) dc.newInstance(\n+                FirstOrderIntegratorFactory.class,\n+                \"org.apache.commons.math.analysis.FirstOrderIntegratorFactoryImpl\");\n+        } catch(Throwable t) {\n+            return new FirstOrderIntegratorFactoryImpl();\n+        }\n+        return factory;\n+    }\n+    \n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * The actual integrator returned is determined by the underlying factory.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step);\n+    \n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The actual integrator returned is determined by the underlying factory.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(\n+            double minStep, double maxStep,\n+            double scalAbsoluteTolerance,\n+            double scalRelativeTolerance);\n+    \n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The actual integrator returned is determined by the underlying factory.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(\n+            double minStep, double maxStep,\n+            double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance);\n+    \n+    /**\n+     * Create a new {@link FirstOrderIntegrator}.\n+     * The integrator is an implementation of the Euler method.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newEulerIntegrator(double step);\n+\n+    /**\n+     * Create a new {@link FirstOrderIntegrator}.\n+     * The integrator is an implementation of the midpoint method.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newMidpointIntegrator(double step);\n+\n+    /**\n+     * Create a new {@link FirstOrderIntegrator}.\n+     * The integrator is an implementation of the classical Runge-Kutta method.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step);\n+\n+    /**\n+     * Create a new {@link FirstOrderIntegrator}.\n+     * The integrator is an implementation of the Gill method.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newGillIntegrator(double step);\n+\n+    /**\n+     * Create a new {@link FirstOrderIntegrator}.\n+     * The integrator is an implementation of the 3/8 method.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public abstract FirstOrderIntegrator newThreeEighthesIntegrator(double step);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Higham-Hall method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newHighamHall54Integrator(\n+            double minStep, double maxStep,\n+            double scalAbsoluteTolerance,\n+            double scalRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Higham-Hall method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newHighamHall54Integrator(\n+            double minStep, double maxStep,\n+            double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Dormand-Prince 5(4) method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDormandPrince54Integrator(\n+            double minStep, double maxStep,\n+            double scalAbsoluteTolerance,\n+            double scalRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Dormand-Prince 5(4) method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDormandPrince54Integrator(\n+            double minStep, double maxStep,\n+            double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Dormand-Prince 8(5,3) method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDormandPrince853Integrator(\n+            double minStep, double maxStep,\n+            double scalAbsoluteTolerance,\n+            double scalRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Dormand-Prince 8(5,3) method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newDormandPrince853Integrator(\n+            double minStep, double maxStep,\n+            double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Gragg-Burlisch-Stoer method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(\n+            double minStep, double maxStep,\n+            double scalAbsoluteTolerance,\n+            double scalRelativeTolerance);\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * The integrator is an implementation of the Gragg-Burlisch-Stoer method.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public abstract AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(\n+            double minStep, double maxStep,\n+            double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegratorFactoryImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * integrators.\n+ *  \n+ * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ */\n+public class FirstOrderIntegratorFactoryImpl extends\n+        FirstOrderIntegratorFactory {\n+\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link ClassicalRungeKuttaIntegrator\n+     * classical Runge-Kutta} integrator by default.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step) {\n+        return newClassicalRungeKuttaIntegrator(step);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince853Integrator\n+     * Dormand-Prince 8(5,3)} integrator by default.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(\n+            double minStep, double maxStep, double scalAbsoluteTolerance,\n+            double scalRelativeTolerance) {\n+        return newDormandPrince853Integrator(minStep, maxStep,\n+                scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince853Integrator\n+     * Dormand-Prince 8(5,3)} integrator by default.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(\n+            double minStep, double maxStep, double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance) {\n+        return newDormandPrince853Integrator(minStep, maxStep,\n+                vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link EulerIntegrator Euler} integrator.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public FirstOrderIntegrator newEulerIntegrator(double step) {\n+        return new EulerIntegrator(step);\n+    }\n+\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link MidpointIntegrator midpoint} integrator.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public FirstOrderIntegrator newMidpointIntegrator(double step) {\n+        return new MidpointIntegrator(step);\n+    }\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link ClassicalRungeKuttaIntegrator\n+     * classical Runge-Kutta} integrator.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+\n+    public FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step) {\n+        return new ClassicalRungeKuttaIntegrator(step);\n+    }\n+\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link GillIntegrator Gill} integrator.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public FirstOrderIntegrator newGillIntegrator(double step) {\n+        return new GillIntegrator(step);\n+    }\n+\n+    /**\n+     * Create a new fixed stepsize {@link FirstOrderIntegrator}.\n+     * This factory buid a {@link ThreeEighthesIntegrator 3/8} integrator.\n+     * @param step the fixed stepsize.\n+     * @return the new fixed step integrator\n+     */\n+    public FirstOrderIntegrator newThreeEighthesIntegrator(double step) {\n+        return new ThreeEighthesIntegrator(step);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link HighamHall54Integrator Higham-Hall} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newHighamHall54Integrator(double minStep,\n+            double maxStep, double scalAbsoluteTolerance,\n+            double scalRelativeTolerance) {\n+        return new HighamHall54Integrator(minStep, maxStep,\n+                scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link HighamHall54Integrator Higham-Hall} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newHighamHall54Integrator(double minStep,\n+            double maxStep, double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance) {\n+        return new HighamHall54Integrator(minStep, maxStep,\n+                vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince54Integrator\n+     * Dormand-Prince 5(4)} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(\n+            double minStep, double maxStep, double scalAbsoluteTolerance,\n+            double scalRelativeTolerance) {\n+        return new DormandPrince54Integrator(minStep, maxStep,\n+                scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince54Integrator\n+     * Dormand-Prince 5(4)} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(double minStep,\n+            double maxStep, double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance) {\n+        return new DormandPrince54Integrator(minStep, maxStep,\n+                vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince853Integrator\n+     * Dormand-Prince 8(5,3)} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDormandPrince853Integrator(\n+            double minStep, double maxStep, double scalAbsoluteTolerance,\n+            double scalRelativeTolerance) {\n+        return new DormandPrince853Integrator(minStep, maxStep,\n+                scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link DormandPrince853Integrator\n+     * Dormand-Prince 8(5,3)} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newDormandPrince853Integrator(\n+            double minStep, double maxStep, double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance) {\n+        return new DormandPrince853Integrator(minStep, maxStep,\n+                vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link GraggBulirschStoerIntegrator\n+     * Gragg-Bulirsch-Stoer} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(\n+            double minStep, double maxStep, double scalAbsoluteTolerance,\n+            double scalRelativeTolerance) {\n+        return new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Create a new {@link AdaptiveStepsizeIntegrator}.\n+     * This factory buid a {@link GraggBulirschStoerIntegrator\n+     * Gragg-Bulirsch-Stoer} integrator.\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @return the new adaptive stepsize integrator\n+     */\n+    public AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(\n+            double minStep, double maxStep, double[] vecAbsoluteTolerance,\n+            double[] vecRelativeTolerance) {\n+        return new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n   public void testDimensionCheck() {\n     try  {\n       TestProblem1 pb = new TestProblem1();\n-      GraggBulirschStoerIntegrator integrator =\n-        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      FirstOrderIntegratorFactory factory =\n+          FirstOrderIntegratorFactory.newInstance();\n+      AdaptiveStepsizeIntegrator integrator =\n+        factory.newGraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n       integrator.integrate(pb,\n                            0.0, new double[pb.getDimension()+10],\n                            1.0, new double[pb.getDimension()+10]);", "timestamp": 1174837364, "metainfo": ""}