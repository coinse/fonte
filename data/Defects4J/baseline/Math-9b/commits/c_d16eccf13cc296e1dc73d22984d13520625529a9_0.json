{"sha": "d16eccf13cc296e1dc73d22984d13520625529a9", "log": "added FastMath.scalb(double, int) and FastMath.scalb(float, int) deprecated MathUtils.scalb(double, int) JIRA: MATH-498  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n             return Float.POSITIVE_INFINITY;\n         }\n         return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n+    }\n+\n+    /**\n+     * Multiply a double number by a power of 2.\n+     * @param d number to multiply\n+     * @param n power of 2\n+     * @return d &times; 2<sup>n</sup>\n+     */\n+    public static double scalb(final double d, final int n) {\n+\n+        // first simple and fast handling when 2^n can be represented using normal numbers\n+        if ((n > -1023) && (n < 1024)) {\n+            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n+        }\n+\n+        // handle special cases\n+        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n+            return d;\n+        }\n+\n+        // decompose d\n+        final long bits = Double.doubleToLongBits(d);\n+        final long sign = bits & 0x8000000000000000L;\n+        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n+        long mantissa   = bits & 0x000fffffffffffffL;\n+\n+        // compute scaled exponent\n+        int scaledExponent = exponent + n;\n+\n+        if (n < 0) {\n+            // we are really in the case n <= -1023\n+            if (scaledExponent > 0) {\n+                // both the input and the result are normal numbers, we only adjust the exponent\n+                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n+            } else if (scaledExponent > -53) {\n+                // the input is a normal number and the result is a subnormal number\n+\n+                // recover the hidden mantissa bit\n+                mantissa = mantissa | (1L << 52);\n+\n+                // scales down complete mantissa, hence losing least significant bits\n+                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n+                mantissa = mantissa >>> (1 - scaledExponent);\n+                if (mostSignificantLostBit != 0) {\n+                    // we need to add 1 bit to round up the result\n+                    mantissa++;\n+                }\n+                return Double.longBitsToDouble(sign | mantissa);\n+\n+            } else {\n+                // no need to compute the mantissa, the number scales down to 0\n+                return (sign == 0L) ? 0.0 : -0.0;\n+            }\n+        } else {\n+            // we are really in the case n >= 1024\n+            if (exponent == 0) {\n+\n+                // the input number is subnormal, normalize it\n+                while ((mantissa >>> 52) != 1) {\n+                    mantissa = mantissa << 1;\n+                    --scaledExponent;\n+                }\n+                ++scaledExponent;\n+                mantissa = mantissa & 0x000fffffffffffffL;\n+\n+                if (scaledExponent < 2047) {\n+                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n+                } else {\n+                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+                }\n+\n+            } else if (scaledExponent < 2047) {\n+                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n+            } else {\n+                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Multiply a float number by a power of 2.\n+     * @param f number to multiply\n+     * @param n power of 2\n+     * @return f &times; 2<sup>n</sup>\n+     */\n+    public static float scalb(final float f, final int n) {\n+\n+        // first simple and fast handling when 2^n can be represented using normal numbers\n+        if ((n > -127) && (n < 128)) {\n+            return f * Float.intBitsToFloat((n + 127) << 23);\n+        }\n+\n+        // handle special cases\n+        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n+            return f;\n+        }\n+\n+        // decompose f\n+        final int bits = Float.floatToIntBits(f);\n+        final int sign = bits & 0x80000000;\n+        int  exponent  = (bits >>> 23) & 0xff;\n+        int mantissa   = bits & 0x007fffff;\n+\n+        // compute scaled exponent\n+        int scaledExponent = exponent + n;\n+\n+        if (n < 0) {\n+            // we are really in the case n <= -127\n+            if (scaledExponent > 0) {\n+                // both the input and the result are normal numbers, we only adjust the exponent\n+                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n+            } else if (scaledExponent > -24) {\n+                // the input is a normal number and the result is a subnormal number\n+\n+                // recover the hidden mantissa bit\n+                mantissa = mantissa | (1 << 23);\n+\n+                // scales down complete mantissa, hence losing least significant bits\n+                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n+                mantissa = mantissa >>> (1 - scaledExponent);\n+                if (mostSignificantLostBit != 0) {\n+                    // we need to add 1 bit to round up the result\n+                    mantissa++;\n+                }\n+                return Float.intBitsToFloat(sign | mantissa);\n+\n+            } else {\n+                // no need to compute the mantissa, the number scales down to 0\n+                return (sign == 0) ? 0.0f : -0.0f;\n+            }\n+        } else {\n+            // we are really in the case n >= 128\n+            if (exponent == 0) {\n+\n+                // the input number is subnormal, normalize it\n+                while ((mantissa >>> 23) != 1) {\n+                    mantissa = mantissa << 1;\n+                    --scaledExponent;\n+                }\n+                ++scaledExponent;\n+                mantissa = mantissa & 0x007fffff;\n+\n+                if (scaledExponent < 255) {\n+                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n+                } else {\n+                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n+                }\n+\n+            } else if (scaledExponent < 255) {\n+                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n+            } else {\n+                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n+            }\n+        }\n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * <p>If {@code d} is 0 or NaN or Infinite, it is returned unchanged.</p>\n      *\n      * @param d base number\n-     * @param scaleFactor power of two by which d sould be multiplied\n+     * @param scaleFactor power of two by which d should be multiplied\n      * @return d &times; 2<sup>scaleFactor</sup>\n      * @since 2.0\n-     */\n+     * @deprecated as of 2.2, replaced by {@link FastMath#scalb(double, int)}\n+     */\n+    @Deprecated\n     public static double scalb(final double d, final int scaleFactor) {\n-\n-        // handling of some important special cases\n-        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n-            return d;\n-        }\n-\n-        // split the double in raw components\n-        final long bits     = Double.doubleToLongBits(d);\n-        final long exponent = bits & 0x7ff0000000000000L;\n-        final long rest     = bits & 0x800fffffffffffffL;\n-\n-        // shift the exponent\n-        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n-        return Double.longBitsToDouble(newBits);\n-\n+        return FastMath.scalb(d, scaleFactor);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n         Assert.assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);\n     }\n \n+    @Test\n+    public void testDoubleScalbSpecialCases() {\n+        Assert.assertEquals(2.5269841324701218E-175,  FastMath.scalb(2.2250738585072014E-308, 442), 0D);\n+        Assert.assertEquals(1.307993905256674E297,    FastMath.scalb(1.1102230246251565E-16, 1040), 0D);\n+        Assert.assertEquals(7.2520887996488946E-217,  FastMath.scalb(Double.MIN_VALUE,        356), 0D);\n+        Assert.assertEquals(8.98846567431158E307,     FastMath.scalb(Double.MIN_VALUE,       2097), 0D);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.MIN_VALUE,       2098), 0D);\n+        Assert.assertEquals(1.1125369292536007E-308,  FastMath.scalb(2.225073858507201E-308,   -1), 0D);\n+        Assert.assertEquals(1.0E-323,                 FastMath.scalb(Double.MAX_VALUE,      -2097), 0D);\n+        Assert.assertEquals(Double.MIN_VALUE,         FastMath.scalb(Double.MAX_VALUE,      -2098), 0D);\n+        Assert.assertEquals(0,                        FastMath.scalb(Double.MAX_VALUE,      -2099), 0D);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.POSITIVE_INFINITY, -1000000), 0D);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1078), 0D);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16,  1079), 0D);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2047), 0D);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2048), 0D);\n+    }\n+\n+    @Test\n+    public void testFloatScalbSpecialCases() {\n+        Assert.assertEquals(0f,                       FastMath.scalb(Float.MIN_VALUE,  -30), 0F);\n+        Assert.assertEquals(2 * Float.MIN_VALUE,      FastMath.scalb(Float.MIN_VALUE,    1), 0F);\n+        Assert.assertEquals(7.555786e22f,             FastMath.scalb(Float.MAX_VALUE,  -52), 0F);\n+        Assert.assertEquals(1.7014118e38f,            FastMath.scalb(Float.MIN_VALUE,  276), 0F);\n+        Assert.assertEquals(Float.POSITIVE_INFINITY,  FastMath.scalb(Float.MIN_VALUE,  277), 0F);\n+        Assert.assertEquals(5.8774718e-39f,           FastMath.scalb(1.1754944e-38f,    -1), 0F);\n+        Assert.assertEquals(2 * Float.MIN_VALUE,      FastMath.scalb(Float.MAX_VALUE, -276), 0F);\n+        Assert.assertEquals(Float.MIN_VALUE,          FastMath.scalb(Float.MAX_VALUE, -277), 0F);\n+        Assert.assertEquals(0,                        FastMath.scalb(Float.MAX_VALUE, -278), 0F);\n+        Assert.assertEquals(Float.POSITIVE_INFINITY,  FastMath.scalb(Float.POSITIVE_INFINITY, -1000000), 0F);\n+        Assert.assertEquals(-3.13994498e38f,          FastMath.scalb(-1.1e-7f,         151), 0F);\n+        Assert.assertEquals(Float.NEGATIVE_INFINITY,  FastMath.scalb(-1.1e-7f,         152), 0F);\n+    }\n+\n     private static void reportError(String message) {\n         final boolean fatal = false;\n         if (fatal) {\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         }\n     }\n \n-    public void testScalb() {\n-        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n-        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);\n-        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);\n-        assertEquals(FastMath.PI, MathUtils.scalb(FastMath.PI, 0), 1.0e-15);\n-        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));\n-        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));\n-        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));\n-    }\n-\n     public void testNormalizeAngle() {\n         for (double a = -15.0; a <= 15.0; a += 0.1) {\n             for (double b = -15.0; b <= 15.0; b += 0.2) {", "timestamp": 1295821328, "metainfo": ""}