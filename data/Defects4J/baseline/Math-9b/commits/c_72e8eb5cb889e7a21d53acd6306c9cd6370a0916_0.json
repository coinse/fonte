{"sha": "72e8eb5cb889e7a21d53acd6306c9cd6370a0916", "log": "The ODE integrators now support several step handlers at once, instead of just one. This is more consistent with event handlers management. The setStepHandler method has therefore been replaced by addStephandler, the getStepHandler method has been replaced by getStepHandlers which returns a Collection and a clearStepHandlers method has been added.   ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n \n package org.apache.commons.math.ode;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n \n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.events.EventHandler;\n-import org.apache.commons.math.ode.sampling.DummyStepHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n /**\n     private final String name;\n \n     /** Step handler. */\n-    protected StepHandler handler;\n+    protected Collection<StepHandler> stepHandlers;\n \n     /** Current step start time. */\n     protected double stepStart;\n      */\n     public AbstractIntegrator(final String name) {\n         this.name = name;\n-        handler = DummyStepHandler.getInstance();\n+        stepHandlers = new ArrayList<StepHandler>();\n         stepStart = Double.NaN;\n         stepSize  = Double.NaN;\n         eventsHandlersManager = new CombinedEventsManager();\n     }\n \n     /** {@inheritDoc} */\n-    public void setStepHandler(final StepHandler handler) {\n-        this.handler = handler;\n+    public void addStepHandler(final StepHandler handler) {\n+        stepHandlers.add(handler);\n     }\n \n     /** {@inheritDoc} */\n-    public StepHandler getStepHandler() {\n-        return handler;\n+    public Collection<StepHandler> getStepHandlers() {\n+        return Collections.unmodifiableCollection(stepHandlers);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearStepHandlers() {\n+        stepHandlers.clear();\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public Collection<EventHandler> getEventsHandlers() {\n+    public Collection<EventHandler> getEventHandlers() {\n         return eventsHandlersManager.getEventsHandlers();\n     }\n \n     /** {@inheritDoc} */\n-    public void clearEventsHandlers() {\n+    public void clearEventHandlers() {\n         eventsHandlersManager.clearEventsHandlers();\n+    }\n+\n+    /** Check if one of the step handlers requires dense output.\n+     * @return true if one of the step handlers requires dense output\n+     */\n+    protected boolean requiresDenseOutput() {\n+        for (StepHandler handler : stepHandlers) {\n+            if (handler.requiresDenseOutput()) {\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n    */\n   public String getName();\n \n-  /** Set the step handler for this integrator.\n-   * The handler will be called by the integrator for each accepted\n-   * step.\n+  /** Add a step handler to this integrator.\n+   * <p>The handler will be called by the integrator for each accepted\n+   * step.</p>\n    * @param handler handler for the accepted steps\n+   * @see #getStepHandlers()\n+   * @see #clearStepHandlers()\n+   * @since 2.0\n    */\n-  public void setStepHandler (StepHandler handler);\n+  public void addStepHandler (StepHandler handler);\n \n-  /** Get the step handler for this integrator.\n-   * @return the step handler for this integrator\n+  /** Get all the step handlers that have been added to the integrator.\n+   * @return an unmodifiable collection of the added events handlers\n+   * @see #addStepHandler(StepHandler)\n+   * @see #clearStepHandlers()\n+   * @since 2.0\n    */\n-  public StepHandler getStepHandler();\n+  public Collection<StepHandler> getStepHandlers();\n+\n+  /** Remove all the step handlers that have been added to the integrator.\n+   * @see #addStepHandler(StepHandler)\n+   * @see #getStepHandlers()\n+   * @since 2.0\n+   */\n+  public void clearStepHandlers();\n \n   /** Add an event handler to the integrator.\n    * @param handler event handler\n    * @param convergence convergence threshold in the event time search\n    * @param maxIterationCount upper limit of the iteration count in\n    * the event time search\n-   * @see #getEventsHandlers()\n-   * @see #clearEventsHandlers()\n+   * @see #getEventHandlers()\n+   * @see #clearEventHandlers()\n    */\n   public void addEventHandler(EventHandler handler, double maxCheckInterval,\n                               double convergence, int maxIterationCount);\n \n-  /** Get all the events handlers that have been added to the integrator.\n+  /** Get all the event handlers that have been added to the integrator.\n    * @return an unmodifiable collection of the added events handlers\n    * @see #addEventHandler(EventHandler, double, double, int)\n-   * @see #clearEventsHandlers()\n+   * @see #clearEventHandlers()\n    */\n-  public Collection<EventHandler> getEventsHandlers();\n+  public Collection<EventHandler> getEventHandlers();\n \n-  /** Remove all the events handlers that have been added to the integrator.\n+  /** Remove all the event handlers that have been added to the integrator.\n    * @see #addEventHandler(EventHandler, double, double, int)\n-   * @see #getEventsHandlers()\n+   * @see #getEventHandlers()\n    */\n-  public void clearEventsHandlers();\n+  public void clearEventHandlers();\n \n   /** Integrate the differential equations up to the given time.\n    * <p>This method solves an Initial Value Problem (IVP).</p>\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n /**\n  * This class implements the common part of all embedded Runge-Kutta\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(equations, yTmp, yDotK, forward);\n       interpolator = rki;\n     double  hNew      = 0;\n     boolean firstTime = true;\n     boolean lastStep;\n-    handler.reset();\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n     do {\n \n       interpolator.shift();\n \n       // provide the step data to the step handler\n       interpolator.storeTime(nextStep);\n-      handler.handleStep(interpolator, lastStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n       stepStart = nextStep;\n \n       if (fsal) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n                                       final double scalRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           scalAbsoluteTolerance, scalRelativeTolerance);\n-    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n                                       final double[] vecRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           vecAbsoluteTolerance, vecRelativeTolerance);\n-    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n \n   }\n \n-  /** Set the step handler for this integrator.\n-   * The handler will be called by the integrator for each accepted\n-   * step.\n-   * @param handler handler for the accepted steps\n-   */\n-  public void setStepHandler (final StepHandler handler) {\n-\n-    super.setStepHandler(handler);\n-    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+  /** {@inheritDoc} */\n+  public void addStepHandler (final StepHandler handler) {\n+\n+    super.addStepHandler(handler);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n                               final double convergence,\n                               final int maxIterationCount) {\n     super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n-    denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n     boolean newStep          = true;\n     boolean lastStep         = false;\n     boolean firstStepAlreadyComputed = false;\n-    handler.reset();\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n     costPerTimeUnit[0] = 0;\n     while (! lastStep) {\n \n \n         // provide the step data to the step handler\n         interpolator.storeTime(nextStep);\n-        handler.handleStep(interpolator, lastStep);\n+        for (StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, lastStep);\n+        }\n         stepStart = nextStep;\n \n         if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n /**\n  * This class implements the common part of all fixed step Runge-Kutta\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(equations, yTmp, yDotK, forward);\n       interpolator = rki;\n     boolean lastStep  = false;\n     stepStart = t0;\n     stepSize  = (t - t0) / nbStep;\n-    handler.reset();\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n     for (long i = 0; ! lastStep; ++i) {\n \n       interpolator.shift();\n \n       // provide the step data to the step handler\n       interpolator.storeTime(nextStep);\n-      handler.handleStep(interpolator, lastStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n       stepStart = nextStep;\n \n       if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n--- a/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n \n   public void testBoundaries()\n     throws DerivativeException, IntegratorException {\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();\n+    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();\n     cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());\n     cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());\n     cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n     throws DerivativeException, IntegratorException {\n \n     ContinuousOutputModel cm = new ContinuousOutputModel();\n-    integ.setStepHandler(cm);\n+    integ.addStepHandler(cm);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n       ContinuousOutputModel cm1 = new ContinuousOutputModel();\n       FirstOrderIntegrator integ1 =\n           new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);\n-      integ1.setStepHandler(cm1);\n+      integ1.addStepHandler(cm1);\n       integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },\n                        0, new double[2]);\n \n       ContinuousOutputModel cm2 = new ContinuousOutputModel();\n       FirstOrderIntegrator integ2 =\n           new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);\n-      integ2.setStepHandler(cm2);\n+      integ2.addStepHandler(cm2);\n       integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },\n                        Math.PI, new double[2]);\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n \n         FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.setStepHandler(handler);\n+        integ.addStepHandler(handler);\n         EventHandler[] functions = pb.getEventsHandlers();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addEventHandler(functions[l],\n                                      Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n         }\n-        assertEquals(functions.length, integ.getEventsHandlers().size());\n+        assertEquals(functions.length, integ.getEventHandlers().size());\n         double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                           pb.getFinalTime(), new double[pb.getDimension()]);\n         if (functions.length == 0) {\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n-        integ.clearEventsHandlers();\n-        assertEquals(0, integ.getEventsHandlers().size());\n+        integ.clearEventHandlers();\n+        assertEquals(0, integ.getEventHandlers().size());\n       }\n \n     }\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.addStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n public class ClassicalRungeKuttaStepInterpolatorTest\n   extends StepInterpolatorAbstractTest {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n     ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 700000);\n     assertTrue(bos.size () < 701000);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n                                                                  vecAbsoluteTolerance,\n                                                                  vecRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                     scalRelativeTolerance);\n \n     DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.setInitialStepSize(1.7);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n       integ.setSafety(0.8);\n       integ.setMaxGrowth(5.0);\n       integ.setMinReduction(0.3);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertTrue(handler.getMaximalValueError() < 5.0e-6);\n     assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n-    integ.clearEventsHandlers();\n-    assertEquals(0, integ.getEventsHandlers().size());\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n \n   }\n \n     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.addStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new VariableHandler());\n+    integ.addStepHandler(new VariableHandler());\n     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n     assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n     DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                     scalAbsoluteTolerance,\n                                                                     scalRelativeTolerance);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 119500);\n     assertTrue(bos.size () < 120500);\n       DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n-      integ.setStepHandler(new StepHandler() {\n+      integ.addStepHandler(new StepHandler() {\n         private static final long serialVersionUID = -6768136169276197L;\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n           throws DerivativeException {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n                                                                   vecAbsoluteTolerance,\n                                                                   vecRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                                                   scalAbsoluteTolerance,\n                                                                   scalRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertTrue(handler.getMaximalValueError() < 5.0e-8);\n     assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n-    integ.clearEventsHandlers();\n-    assertEquals(0, integ.getEventsHandlers().size());\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n \n   }\n \n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n-    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.addStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new VariableHandler());\n+    integ.addStepHandler(new VariableHandler());\n     double stopTime = integ.integrate(pb,\n                                       pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n-    integ.setStepHandler(DummyStepHandler.getInstance());\n+    integ.addStepHandler(DummyStepHandler.getInstance());\n     integ.integrate(pb1,\n                     pb1.getInitialTime(), pb1.getInitialState(),\n                     pb1.getFinalTime(), new double[pb1.getDimension()]);\n     int callsWithoutDenseOutput = pb1.getCalls();\n \n-    integ.setStepHandler(new InterpolatingStepHandler());\n+    integ.addStepHandler(new InterpolatingStepHandler());\n     integ.integrate(pb2,\n                     pb2.getInitialTime(), pb2.getInitialState(),\n                     pb2.getFinalTime(), new double[pb2.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n     DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 86000);\n     assertTrue(bos.size () < 87000);\n     DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                       scalAbsoluteTolerance,\n                                                                       scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n+    integ.addStepHandler(new StepHandler() {\n         private static final long serialVersionUID = 2209212559670665268L;\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n         throws DerivativeException {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n \n         FirstOrderIntegrator integ = new EulerIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.setStepHandler(handler);\n+        integ.addStepHandler(handler);\n         EventHandler[] functions = pb.getEventsHandlers();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addEventHandler(functions[l],\n \n     FirstOrderIntegrator integ = new EulerIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     FirstOrderIntegrator integ = new EulerIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n public class EulerStepInterpolatorTest\n   extends StepInterpolatorAbstractTest {\n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     EulerIntegrator integ = new EulerIntegrator(step);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 82000);\n     assertTrue(bos.size () < 83000);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n \n         FirstOrderIntegrator integ = new GillIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.setStepHandler(handler);\n+        integ.addStepHandler(handler);\n         EventHandler[] functions = pb.getEventsHandlers();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addEventHandler(functions[l],\n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n-    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n public class GillStepInterpolatorTest\n   extends StepInterpolatorAbstractTest {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n     GillIntegrator integ = new GillIntegrator(step);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 700000);\n     assertTrue(bos.size () < 701000);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n         new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                          vecAbsoluteTolerance, vecRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n         new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                          absTolerance, relTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n   private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n     throws DerivativeException, IntegratorException {\n       TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n-      integrator.setStepHandler(handler);\n+      integrator.addStepHandler(handler);\n       integrator.integrate(pb,\n                            pb.getInitialTime(), pb.getInitialState(),\n                            pb.getFinalTime(), new double[pb.getDimension()]);\n                                                                   scalAbsoluteTolerance,\n                                                                   scalRelativeTolerance);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertTrue(handler.getMaximalValueError() < 5.0e-8);\n     assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n-    integ.clearEventsHandlers();\n-    assertEquals(0, integ.getEventsHandlers().size());\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n \n   }\n \n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                        absTolerance, relTolerance);\n-    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                        absTolerance, relTolerance);\n-    integ.setStepHandler(new VariableStepHandler());\n+    integ.addStepHandler(new VariableStepHandler());\n     double stopTime = integ.integrate(pb,\n                                       pb.getInitialTime(), pb.getInitialState(),\n                                       pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n     GraggBulirschStoerIntegrator integ =\n       new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                        absTolerance, relTolerance);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 34000);\n     assertTrue(bos.size () < 35000);\n     GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                                                           scalAbsoluteTolerance,\n                                                                           scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n+    integ.addStepHandler(new StepHandler() {\n         private static final long serialVersionUID = -5947183291381232297L;\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n         throws DerivativeException {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n                                                               vecAbsoluteTolerance,\n                                                               vecRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                                               scalAbsoluteTolerance,\n                                                               scalRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n       integ.integrate(pb,\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n                                                             scalAbsoluteTolerance,\n                                                             scalRelativeTolerance);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     EventHandler[] functions = pb.getEventsHandlers();\n     for (int l = 0; l < functions.length; ++l) {\n       integ.addEventHandler(functions[l],\n                                  Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n     }\n-    assertEquals(functions.length, integ.getEventsHandlers().size());\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertTrue(handler.getMaximalValueError() < 1.0e-7);\n     assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n-    integ.clearEventsHandlers();\n-    assertEquals(0, integ.getEventsHandlers().size());\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n \n   }\n \n           new HighamHall54Integrator(minStep, maxStep,\n                                      scalAbsoluteTolerance, scalRelativeTolerance);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-      integ.setStepHandler(handler);\n+      integ.addStepHandler(handler);\n \n       integ.addEventHandler(new EventHandler() {\n         public int eventOccurred(double t, double[] y) {\n         new HighamHall54Integrator(minStep, maxStep,\n                                    scalAbsoluteTolerance, scalRelativeTolerance);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n \n     integ.addEventHandler(new EventHandler() {\n       public int eventOccurred(double t, double[] y) {\n     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                             vecAbsoluteTolerance,\n                                                             vecRelativeTolerance);\n-    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.addStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n     HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                               scalAbsoluteTolerance,\n                                                               scalRelativeTolerance);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 158000);\n     assertTrue(bos.size () < 159000);\n     HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                               scalAbsoluteTolerance,\n                                                               scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n+    integ.addStepHandler(new StepHandler() {\n         private static final long serialVersionUID = 9111679755950880352L;\n         public void handleStep(StepInterpolator interpolator, boolean isLast)\n         throws DerivativeException {\n--- a/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n           * Math.pow(2.0, -i);\n         FirstOrderIntegrator integ = new MidpointIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.setStepHandler(handler);\n+        integ.addStepHandler(handler);\n         EventHandler[] functions = pb.getEventsHandlers();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addEventHandler(functions[l],\n \n     FirstOrderIntegrator integ = new MidpointIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     FirstOrderIntegrator integ = new MidpointIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n public class MidpointStepInterpolatorTest\n   extends StepInterpolatorAbstractTest {\n     TestProblem1 pb = new TestProblem1();\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n     MidpointIntegrator integ = new MidpointIntegrator(step);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 98000);\n     assertTrue(bos.size () < 99000);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/StepInterpolatorAbstractTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/StepInterpolatorAbstractTest.java\n                                                final TestProblemAbstract problem,\n                                                final double threshold)\n         throws DerivativeException, IntegratorException {\n-        integrator.setStepHandler(new StepHandler() {\n+        integrator.addStepHandler(new StepHandler() {\n \n             private static final long serialVersionUID = 2462564234755682953L;\n \n--- a/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n \n         FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-        integ.setStepHandler(handler);\n+        integ.addStepHandler(handler);\n         EventHandler[] functions = pb.getEventsHandlers();\n         for (int l = 0; l < functions.length; ++l) {\n           integ.addEventHandler(functions[l],\n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n-    integ.setStepHandler(handler);\n+    integ.addStepHandler(handler);\n     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n-    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.addStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n--- a/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n \n public class ThreeEighthesStepInterpolatorTest\n   extends StepInterpolatorAbstractTest {\n     TestProblem3 pb = new TestProblem3(0.9);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n     ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n     ByteArrayOutputStream bos = new ByteArrayOutputStream();\n     ObjectOutputStream    oos = new ObjectOutputStream(bos);\n-    oos.writeObject(integ.getStepHandler());\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n \n     assertTrue(bos.size () > 700000);\n     assertTrue(bos.size () < 701000);\n--- a/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n     throws DerivativeException, IntegratorException {\n     double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n-    integ.setStepHandler(new StepNormalizer(range / 10.0,\n+    integ.addStepHandler(new StepNormalizer(range / 10.0,\n                                        new FixedStepHandler() {\n                                          private boolean firstCall = true;\n                                          public void handleStep(double t,\n     throws DerivativeException, IntegratorException {\n     final double range = pb.getFinalTime() - pb.getInitialTime();\n     setLastSeen(false);\n-    integ.setStepHandler(new StepNormalizer(range / 10.5,\n+    integ.addStepHandler(new StepNormalizer(range / 10.5,\n                                        new FixedStepHandler() {\n                                          public void handleStep(double t,\n                                                                 double[] y,", "timestamp": 1215523619, "metainfo": ""}