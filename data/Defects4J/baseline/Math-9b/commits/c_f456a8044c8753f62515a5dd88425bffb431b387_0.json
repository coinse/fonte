{"sha": "f456a8044c8753f62515a5dd88425bffb431b387", "log": "Patch for bug 21516 from Brent Worden. Fixed checkstyle bugs and added maven.javadoc.links to project.properties   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n  * It will only search for one zero in the given interval.\n  * The function is supposed to be continuous but not necessarily smooth.\n  *  \n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/11 15:59:14 $\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n     /**\n                 setResult(x1, i);\n                 return result;\n             }\n-            if (Math.abs(oldDelta) < tolerance\n-                || Math.abs(y0) <= Math.abs(y1)) {\n+            if ((Math.abs(oldDelta) < tolerance) ||\n+                    (Math.abs(y0) <= Math.abs(y1))) {\n                 // Force bisection.\n                 delta = 0.5 * dx;\n                 oldDelta = delta;\n                 } else {\n                     p = -p;\n                 }\n-                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n-                    || p >= Math.abs(0.5 * oldDelta * p1)) {\n+                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n+                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                     // Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n--- a/src/java/org/apache/commons/math/analysis/CubicSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/CubicSplineFunction.java\n  * polynominal coefficents are used.\n  * Arguments outside of the domain cause an IllegalArgumentException.\n  * \n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n- *\n+ * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n  */\n public class CubicSplineFunction implements UnivariateRealFunction {\n-    // Spline segment interval delimiters.\n-    // Size is N+1 for N segments.\n+    /** Spline segment interval delimiters. Size is N+1 for N segments. */\n     private double xval[];\n-    \n-    // The spline segment's polynominal coefficients.\n-    // The first index runs over the intervals, size is N.\n-    // The second index adresses the coefficients in the segment, with\n-    // index 0 being the absolute coefficient and index 3 the coefficient\n-    // for the third power.\n-    // The coefficients are setup so that x runs from 0 to xval[i+1]-xval[i].\n+\n+    /**\n+     * The spline segment's polynominal coefficients.\n+     * The first index runs over the intervals, size is N.\n+     * The second index adresses the coefficients in the segment, with\n+     * index 0 being the absolute coefficient and index 3 the coefficient\n+     * for the third power.\n+     * The coefficients are setup so that x runs from 0 to xval[i+1]-xval[i].\n+     */\n     private double c[][];\n \n-    public CubicSplineFunction(double xval[],double c[][]) {\n+    /**\n+     * Construct a function with the given segment delimiters and polynomial\n+     * coefficients.\n+     * @param xval Spline segment interval delimiters\n+     * @param c spline segment's polynominal coefficients\n+     */\n+    public CubicSplineFunction(double xval[], double c[][]) {\n+        super();\n         // TODO: should copy the arguments here, for safety. This could be a major overhead.\n-        this.xval=xval;\n-        this.c=c;\n+        this.xval = xval;\n+        this.c = c;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+    /**\n+     * Compute the value for the function.\n+     * @param x the point for which the function value should be computed\n+     * @return the value\n+     * @throws MathException if the function couldn't be computed due to\n+     *  missing additional data or other environmental problems.\n+     * @see UnivariateRealFunction#value(double)\n      */\n     public double value(double x) throws MathException {\n-        if(x<xval[0]||x>xval[xval.length-1]) {\n+        if (x < xval[0] || x > xval[xval.length - 1]) {\n             throw new IllegalArgumentException(\"Argument outside domain\");\n         }\n-        int i=Arrays.binarySearch(xval,x);\n-        if(i<0) {\n-            i=-i-2;\n+        int i = Arrays.binarySearch(xval, x);\n+        if (i < 0) {\n+            i = -i - 2;\n         }\n-        x=x-xval[i];\n-        return ((c[i][3]*x+c[i][2])*x+c[i][1])*x+c[i][0];\n+        x = x - xval[i];\n+        return ((c[i][3] * x + c[i][2]) * x + c[i][1]) * x + c[i][0];\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealFunction#firstDerivative(double)\n+    /**\n+     * Compute the value for the first derivative of the function.\n+     * It is recommended to provide this method only if the first derivative is\n+     * analytical. Numerical derivatives may be acceptable in some cases.\n+     * An implementation should throw an UnsupportedOperationException if\n+     * this method is not implemented.\n+     * @param x the point for which the first derivative should be computed\n+     * @return the value\n+     * @throws MathException if the derivative couldn't be computed.\n+     * @see UnivariateRealFunction#firstDerivative(double)\n      */\n     public double firstDerivative(double x) throws MathException {\n-        if(x<xval[0]||x>xval[xval.length-1]) {\n+        if (x < xval[0] || x > xval[xval.length - 1]) {\n             throw new IllegalArgumentException(\"Argument outside domain\");\n         }\n-        int i=Arrays.binarySearch(xval,x);\n-        if(i<0) {\n-            i=-i-2;\n+        int i = Arrays.binarySearch(xval, x);\n+        if (i < 0) {\n+            i = -i - 2;\n         }\n-        x=x-xval[i];\n-        return (3*c[i][3]*x+2*c[i][2])*x+c[i][1];\n+        x = x - xval[i];\n+        return (3 * c[i][3] * x + 2 * c[i][2]) * x + c[i][1];\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealFunction#secondDerivative(double)\n+    /**\n+     * Compute the value for the second derivative of the function.\n+     * It is recommended to provide this method only if the second derivative is\n+     * analytical. Numerical derivatives may be acceptable in some cases.\n+     * An implementation should throw an UnsupportedOperationException if\n+     * this method is not implemented.\n+     * @param x the point for which the first derivative should be computed\n+     * @return the value\n+     * @throws MathException if the second derivative couldn't be computed.\n+     * @see UnivariateRealFunction#secondDerivative(double)\n      */\n     public double secondDerivative(double x) throws MathException {\n-        if(x<xval[0]||x>xval[xval.length-1]) {\n+        if (x < xval[0] || x > xval[xval.length - 1]) {\n             throw new IllegalArgumentException(\"Argument outside domain\");\n         }\n-        int i=Arrays.binarySearch(xval,x);\n-        if(i<0) {\n-            i=-i-2;\n+        int i = Arrays.binarySearch(xval, x);\n+        if (i < 0) {\n+            i = -i - 2;\n         }\n-        x=x-xval[i];\n-        return 6*c[i][3]*x+2*c[i][2];\n+        x = x - xval[i];\n+        return 6 * c[i][3] * x + 2 * c[i][2];\n     }\n \n }\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n  * It will only search for one zero in the given interval.\n  * The function is supposed to be continuous but not necessarily smooth.\n  *  \n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/11 15:59:14 $\n  */\n public class SecantSolver extends UnivariateRealSolverImpl {\n     /**\n                 setResult(x1, i);\n                 return result;\n             }\n-            if (Math.abs(oldDelta)\n-                < Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+            if (Math.abs(oldDelta) <\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n                 setResult(x1, i);\n                 return result;\n             }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  * that derivatives are evaluated after the value, the evaluation algorithm\n  * should throw an InvalidStateException if it can't cope with this.\n  *  \n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n  */\n public interface UnivariateRealFunction {\n-\n     /**\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      *  missing additional data or other environmental problems.\n      * @throws RuntimeException if the operation isn't supported, the argument\n      *  was outside the supported domain or any other problem.\n-     * \n      */\n     public double value(double x) throws MathException;\n \n      * @throws MathException if the derivative couldn't be computed.\n      * @throws RuntimeException if the operation isn't supported, the argument\n      *  was outside the supported domain or any other problem.\n-     * \n      */\n     public double firstDerivative(double x) throws MathException;\n \n      * @throws MathException if the second derivative couldn't be computed.\n      * @throws RuntimeException if the operation isn't supported, the argument\n      *  was outside the supported domain or any other problem.\n-     * \n      */\n     public double secondDerivative(double x) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealInterpolator.java\n import org.apache.commons.math.MathException;\n \n /**\n- *  Interface for interpolating a data set.\n+ * Interface for interpolating a data set.\n  *  \n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n  */\n public interface UnivariateRealInterpolator {\n \n      * @param xval the arguments for the interpolation points\n      * @param yval the values for the interpolation points\n      * @return a function which interpolates the data set\n-     * @throws MathException if arguments violate assumptions made by the interpolationg algorithm\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolationg algorithm\n      */\n     public UnivariateRealFunction interpolate(double xval[], double yval[])\n         throws MathException;\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n  * functions.\n  * An implementation will only search for one zero in the given interval.\n  *  \n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.4 $ $Date: 2003/07/11 15:59:14 $\n  */\n public interface UnivariateRealSolver {\n \n      * A solver may require that the interval brackets a single zero root.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @return the value where the function is zero\n+     * @return a value where the function is zero\n      * @throws MathException if the iteration count was exceeded or the\n      *  solver detects convergence problems otherwise.\n      */\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param startValue the start value to use\n-     * @return the value where the function is zero\n+     * @return a value where the function is zero\n      * @throws MathException if the iteration count was exceeded or the\n      *  solver detects convergence problems otherwise.\n      */\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * (this may be controversial, because the configuration data\n  * may also be used for the default solver used by the static\n  * solve() method). \n- * @version $Revision: 1.2 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/07/11 15:59:14 $\n  */\n public class UnivariateRealSolverFactory {\n-    protected UnivariateRealSolverFactory() {\n+    /**\n+     * Default constructor.\n+     */\n+    private UnivariateRealSolverFactory() {\n     }\n \n+    /**\n+     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * actual solver returned can be controlled by defining the\n+     * <code>org.apache.commons.math.analysis.UnivariateRealSolver</code>\n+     * property on the JVM command-line (<code>\n+     * -Dorg.apache.commons.math.analysis.UnivariateRealSolver=\n+     * <i>class name</i></code>).  The value of the property should be any,\n+     * fully qualified class name for a type that implements the\n+     * {@link UnivariateRealSolver} interface.  By default, an instance of\n+     * {@link BrentSolver} is returned.\n+     * @param f the function.\n+     * @return the new solver.\n+     * @throws MathConfigurationException if a\n+     */\n     public static UnivariateRealSolver newSolver(UnivariateRealFunction f)\n         throws MathConfigurationException {\n         String solverClassName =\n         try {\n             Class clazz = Class.forName(solverClassName);\n             Class paramClass[] = new Class[1];\n-            paramClass[0] =\n-                Class.forName(\"org.apache.commons.math.analysis.UnivariateRealFunction\");\n+            paramClass[0] = UnivariateRealFunction.class;\n             Object param[] = new Object[1];\n             param[0] = f;\n             return (UnivariateRealSolver)clazz.getConstructor(\n             throw new MathConfigurationException(e);\n         } catch (NoSuchMethodException e) {\n             throw new MathConfigurationException(\n-                \"No constructor with UnivariateRealFunction in \"\n-                    + solverClassName,\n+                \"No constructor with UnivariateRealFunction in \" +\n+                solverClassName,\n                 e);\n         }\n     }\n \n+    /**\n+     * Convience method to solve for zeros of real univariate functions.  A\n+     * default solver is created and used for solving. \n+     * @param f the function.\n+     * @param x0 the lower bound for the interval.\n+     * @param x1 the upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws MathException if the iteration count was exceeded or the\n+     *         solver detects convergence problems otherwise.\n+     */\n     public static double solve(UnivariateRealFunction f, double x0, double x1)\n         throws MathException {\n         return newSolver(f).solve(x0, x1);\n     }\n \n+    /**\n+     * Convience method to solve for zeros of real univariate functions.  A\n+     * default solver is created and used for solving. \n+     * @param f the function.\n+     * @param x0 the lower bound for the interval.\n+     * @param x1 the upper bound for the interval.\n+     * @param absoluteAccuracy the accuracy to be used by the solver.\n+     * @return a value where the function is zero.\n+     * @throws MathException if the iteration count was exceeded or the\n+     *         solver detects convergence problems otherwise.\n+     */\n     public static double solve(\n         UnivariateRealFunction f,\n         double x0,", "timestamp": 1057939154, "metainfo": ""}