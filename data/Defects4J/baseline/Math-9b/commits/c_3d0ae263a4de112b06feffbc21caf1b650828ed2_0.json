{"sha": "3d0ae263a4de112b06feffbc21caf1b650828ed2", "log": "removed unused FSAL flag for simple Runge-Kutta schemes it is used only for Runge-Kutta-Fehlberg schemes  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaIntegrator.java\n    * @param step integration step\n    */\n   public ClassicalRungeKuttaIntegrator(double step) {\n-    super(false, c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n+    super(c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n   }\n \n   /** Get the name of the method.\n--- a/src/java/org/apache/commons/math/ode/EulerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/EulerIntegrator.java\n    * @param step integration step\n    */\n   public EulerIntegrator(double step) {\n-    super(false, c, a, b, new EulerStepInterpolator(), step);\n+    super(c, a, b, new EulerStepInterpolator(), step);\n   }\n \n   /** Get the name of the method.\n--- a/src/java/org/apache/commons/math/ode/GillIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GillIntegrator.java\n    * @param step integration step\n    */\n   public GillIntegrator(double step) {\n-    super(false, c, a, b, new GillStepInterpolator(), step);\n+    super(c, a, b, new GillStepInterpolator(), step);\n   }\n \n   /** Get the name of the method.\n--- a/src/java/org/apache/commons/math/ode/MidpointIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MidpointIntegrator.java\n    * @param step integration step\n    */\n   public MidpointIntegrator(double step) {\n-    super(false, c, a, b, new MidpointStepInterpolator(), step);\n+    super(c, a, b, new MidpointStepInterpolator(), step);\n   }\n \n   /** Get the name of the method.\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n  * </pre>\n  * </p>\n \n- * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n- * methods. This means the last evaluation of the derivatives in one\n- * step is the same as the first in the next step. Then, this\n- * evaluation can be reused from one step to the next one and the cost\n- * of such a method is really s-1 evaluations despite the method still\n- * has s stages. This behaviour is true only for successful steps, if\n- * the step is rejected after the error estimation phase, no\n- * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n- * asi = bi for all i.</p>\n-\n  * @see EulerIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see GillIntegrator\n   /** Simple constructor.\n    * Build a Runge-Kutta integrator with the given\n    * step. The default step handler does nothing.\n-   * @param fsal indicate that the method is an <i>fsal</i>\n    * @param c time steps from Butcher array (without the first zero)\n    * @param a internal weights from Butcher array (without the first empty row)\n    * @param b external weights for the high order method from Butcher array\n    * @param prototype prototype of the step interpolator to use\n    * @param step integration step\n    */\n-  protected RungeKuttaIntegrator(boolean fsal,\n-                                 double[] c, double[][] a, double[] b,\n+  protected RungeKuttaIntegrator(double[] c, double[][] a, double[] b,\n                                  RungeKuttaStepInterpolator prototype,\n                                  double step) {\n-    this.fsal       = fsal;\n     this.c          = c;\n     this.a          = a;\n     this.b          = b;\n \n     // recompute the step\n     long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));\n-    boolean firstTime = true;\n     boolean lastStep  = false;\n     stepStart = t0;\n     stepSize  = (t - t0) / nbStep;\n       boolean needUpdate = false;\n       for (boolean loop = true; loop;) {\n \n-        if (firstTime || !fsal) {\n-          // first stage\n-          equations.computeDerivatives(stepStart, y, yDotK[0]);\n-          firstTime = false;\n-        }\n+        // first stage\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n       interpolator.storeTime(stepStart);\n       handler.handleStep(interpolator, lastStep);\n \n-      if (fsal) {\n-        // save the last evaluation for the next step\n-        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n-      }\n-\n       if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n         // some switching function has triggered changes that\n         // invalidate the derivatives, we need to recompute them\n     stepSize  = Double.NaN;\n   }\n \n-  /** Indicator for <i>fsal</i> methods. */\n-  private boolean fsal;\n-\n   /** Time steps from Butcher array (without the first zero). */\n   private double[] c;\n \n--- a/src/java/org/apache/commons/math/ode/ThreeEighthesIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesIntegrator.java\n    * @param step integration step\n    */\n   public ThreeEighthesIntegrator(double step) {\n-    super(false, c, a, b, new ThreeEighthesStepInterpolator(), step);\n+    super(c, a, b, new ThreeEighthesStepInterpolator(), step);\n   }\n \n   /** Get the name of the method.", "timestamp": 1194108475, "metainfo": ""}