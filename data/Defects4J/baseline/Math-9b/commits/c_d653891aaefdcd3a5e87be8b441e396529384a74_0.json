{"sha": "d653891aaefdcd3a5e87be8b441e396529384a74", "log": "removed warnings about unused return values/fields  ", "commit": "\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n    * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n    * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n    * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n-   * the following arbitrary choices. For Cardan angles, the chosen\n-   * set is the one for which the second angle is between -&pi;/2 and\n-   * &pi;/2 (i.e its cosine is positive). For Euler angles, the chosen\n-   * set is the one for which the second angle is between 0 and &pi;\n-   * (i.e its sine is positive).</p>\n+   * the following arbitrary choices:</p>\n+   * <ul>\n+   *   <li>for Cardan angles, the chosen set is the one for which the\n+   *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n+   *   positive),</li>\n+   *   <li>for Euler angles, the chosen set is the one for which the\n+   *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n+   * </ul>\n \n    * <p>Cardan and Euler angle have a very disappointing drawback: all\n    * of them have singularities. This means that if the instance is\n    * too close to the singularities corresponding to the given\n    * rotation order, it will be impossible to retrieve the angles. For\n    * Cardan angles, this is often called gimbal lock. There is\n-   * <em>nothing</em> to do to prevent this, it is an intrisic problem\n+   * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n    * with Cardan and Euler representation (but not a problem with the\n    * rotation itself, which is perfectly well defined). For Cardan\n    * angles, singularities occur when the second angle is close to\n    * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n    * second angle is close to 0 or &pi;, this implies that the identity\n-   * rotation is always singular for Euler angles!\n+   * rotation is always singular for Euler angles!</p>\n \n    * @param order rotation order to use\n    * @return an array of three angles, in the order specified by the set\n    */\n   public double[] getAngles(RotationOrder order)\n     throws CardanEulerSingularityException {\n-\n-    final double small        = 1.0e-10;\n-    final double maxThreshold = 1.0 - small;\n-    final double minThreshold = -maxThreshold;\n-\n-    double[] angles = new double[3];\n-    Vector3D v1 = null;\n-    Vector3D v2 = null;\n \n     if (order == RotationOrder.XYZ) {\n \n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusK);\n-      v2 = applyInverseTo(Vector3D.plusI);\n-      if  ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusK);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(-(v1.getY()), v1.getZ());\n-      angles[1] = Math.asin(v2.getZ());\n-      angles[2] = Math.atan2(-(v2.getY()), v2.getX());\n+      return new double[] {\n+        Math.atan2(-(v1.getY()), v1.getZ()),\n+        Math.asin(v2.getZ()),\n+        Math.atan2(-(v2.getY()), v2.getX())\n+      };\n \n     } else if (order == RotationOrder.XZY) {\n \n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusJ);\n-      v2 = applyInverseTo(Vector3D.plusI);\n-      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusJ);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n-      angles[1] = -Math.asin(v2.getY());\n-      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+      return new double[] {\n+        Math.atan2(v1.getZ(), v1.getY()),\n+       -Math.asin(v2.getY()),\n+        Math.atan2(v2.getZ(), v2.getX())\n+      };\n \n     } else if (order == RotationOrder.YXZ) {\n \n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusK);\n-      v2 = applyInverseTo(Vector3D.plusJ);\n-      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusK);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n-      angles[1] = -Math.asin(v2.getZ());\n-      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+      return new double[] {\n+        Math.atan2(v1.getX(), v1.getZ()),\n+       -Math.asin(v2.getZ()),\n+        Math.atan2(v2.getX(), v2.getY())\n+      };\n \n     } else if (order == RotationOrder.YZX) {\n \n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusI);\n-      v2 = applyInverseTo(Vector3D.plusJ);\n-      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusI);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(-(v1.getZ()), v1.getX());\n-      angles[1] = Math.asin(v2.getX());\n-      angles[2] = Math.atan2(-(v2.getZ()), v2.getY());\n+      return new double[] {\n+        Math.atan2(-(v1.getZ()), v1.getX()),\n+        Math.asin(v2.getX()),\n+        Math.atan2(-(v2.getZ()), v2.getY())\n+      };\n \n     } else if (order == RotationOrder.ZXY) {\n \n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusJ);\n-      v2 = applyInverseTo(Vector3D.plusK);\n-      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusJ);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(-(v1.getX()), v1.getY());\n-      angles[1] = Math.asin(v2.getY());\n-      angles[2] = Math.atan2(-(v2.getX()), v2.getZ());\n+      return new double[] {\n+        Math.atan2(-(v1.getX()), v1.getY()),\n+        Math.asin(v2.getY()),\n+        Math.atan2(-(v2.getX()), v2.getZ())\n+      };\n \n     } else if (order == RotationOrder.ZYX) {\n \n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      v1 = applyTo(Vector3D.plusI);\n-      v2 = applyInverseTo(Vector3D.plusK);\n-      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusI);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n-      angles[0] = Math.atan2(v1.getY(), v1.getX());\n-      angles[1] = -Math.asin(v2.getX());\n-      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+      return new double[] {\n+        Math.atan2(v1.getY(), v1.getX()),\n+       -Math.asin(v2.getX()),\n+        Math.atan2(v2.getY(), v2.getZ())\n+      };\n \n     } else if (order == RotationOrder.XYX) {\n \n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusI);\n-      v2 = applyInverseTo(Vector3D.plusI);\n-      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusI);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getY(), -v1.getZ());\n-      angles[1] = Math.acos(v2.getX());\n-      angles[2] = Math.atan2(v2.getY(), v2.getZ());\n+      return new double[] {\n+        Math.atan2(v1.getY(), -v1.getZ()),\n+        Math.acos(v2.getX()),\n+        Math.atan2(v2.getY(), v2.getZ())\n+      };\n \n     } else if (order == RotationOrder.XZX) {\n \n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusI);\n-      v2 = applyInverseTo(Vector3D.plusI);\n-      if ((v2.getX() < minThreshold) || (v2.getX() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusI);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getZ(), v1.getY());\n-      angles[1] = Math.acos(v2.getX());\n-      angles[2] = Math.atan2(v2.getZ(), -v2.getY());\n+      return new double[] {\n+        Math.atan2(v1.getZ(), v1.getY()),\n+        Math.acos(v2.getX()),\n+        Math.atan2(v2.getZ(), -v2.getY())\n+      };\n \n     } else if (order == RotationOrder.YXY) {\n \n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusJ);\n-      v2 = applyInverseTo(Vector3D.plusJ);\n-      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusJ);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getX(), v1.getZ());\n-      angles[1] = Math.acos(v2.getY());\n-      angles[2] = Math.atan2(v2.getX(), -v2.getZ());\n+      return new double[] {\n+        Math.atan2(v1.getX(), v1.getZ()),\n+        Math.acos(v2.getY()),\n+        Math.atan2(v2.getX(), -v2.getZ())\n+      };\n \n     } else if (order == RotationOrder.YZY) {\n \n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusJ);\n-      v2 = applyInverseTo(Vector3D.plusJ);\n-      if ((v2.getY() < minThreshold) || (v2.getY() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusJ);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getZ(), -v1.getX());\n-      angles[1] = Math.acos(v2.getY());\n-      angles[2] = Math.atan2(v2.getZ(), v2.getX());\n+      return new double[] {\n+        Math.atan2(v1.getZ(), -v1.getX()),\n+        Math.acos(v2.getY()),\n+        Math.atan2(v2.getZ(), v2.getX())\n+      };\n \n     } else if (order == RotationOrder.ZXZ) {\n \n       // (-r) (Vector3D.plusK) coordinates are :\n       // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusK);\n-      v2 = applyInverseTo(Vector3D.plusK);\n-      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusK);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getX(), -v1.getY());\n-      angles[1] = Math.acos(v2.getZ());\n-      angles[2] = Math.atan2(v2.getX(), v2.getY());\n+      return new double[] {\n+        Math.atan2(v1.getX(), -v1.getY()),\n+        Math.acos(v2.getZ()),\n+        Math.atan2(v2.getX(), v2.getY())\n+      };\n \n     } else { // last possibility is ZYZ\n \n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      v1 = applyTo(Vector3D.plusK);\n-      v2 = applyInverseTo(Vector3D.plusK);\n-      if ((v2.getZ() < minThreshold) || (v2.getZ() > maxThreshold)) {\n+      Vector3D v1 = applyTo(Vector3D.plusK);\n+      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n-      angles[0] = Math.atan2(v1.getY(), v1.getX());\n-      angles[1] = Math.acos(v2.getZ());\n-      angles[2] = Math.atan2(v2.getY(), -v2.getX());\n-\n-    }\n-\n-    return angles;\n+      return new double[] {\n+        Math.atan2(v1.getY(), v1.getX()),\n+        Math.acos(v2.getZ()),\n+        Math.atan2(v2.getY(), -v2.getX())\n+      };\n+\n+    }\n \n   }\n \n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n             { -4, 24, -41, }, \n             { -5, 34, 7, }, };\n \n-    final double entryTolerance = 10e-16;\n+    private static final double entryTolerance = 10e-16;\n \n-    final double normTolerance = 10e-14;\n+    private static final double normTolerance = 10e-14;\n \n     public QRDecompositionImplTest(String name) {\n         super(name);\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n             // expected\n         }\n         try {\n-            percentile = new Percentile(0);\n+            new Percentile(0);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected", "timestamp": 1187540516, "metainfo": ""}