{"sha": "0b78d9accafadffe00697c2c56706043cdba5e64", "log": "MATH-621 Added temporary constant \"INDEX_OFFSET\" to keep track of where changes are needed for converting from 1-based to 0-based indexing.    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n public class BOBYQAOptimizer\n     extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n     implements MultivariateRealOptimizer {\n+    private static final int INDEX_OFFSET = 1; // XXX to become \"0\" when all loops are 0-based.\n     private static final double ZERO = 0d;\n     private static final double ONE = 1d;\n     private static final double TWO = 2d;\n             final double deltaOne = xopt.getEntry(i);\n             xoptsq += deltaOne * deltaOne;\n         }\n-        fsave = fval.getEntry(1);\n+        fsave = fval.getEntry(INDEX_OFFSET);\n         kbase = 1;\n \n         // Complete the settings that are required for the iterative procedure.\n                 if (getEvaluations() >= 2 && getEvaluations() <= n + 1) {\n                     gopt.setEntry( nfm, (f - fbeg) / stepa);\n                     if (npt < getEvaluations() + n) {\n-                        bmat.setEntry(1, nfm, -ONE / stepa);\n+                        bmat.setEntry(INDEX_OFFSET, nfm, -ONE / stepa);\n                         bmat.setEntry( getEvaluations(), nfm, ONE / stepa);\n                         bmat.setEntry( npt + nfm, nfm, -HALF * rhosq);\n                     }\n                             xpt.setEntry(getEvaluations(), nfx, stepa);\n                         }\n                     }\n-                    bmat.setEntry(1, nfx, -(stepa + stepb) / (stepa * stepb));\n+                    bmat.setEntry(INDEX_OFFSET, nfx, -(stepa + stepb) / (stepa * stepb));\n                     bmat.setEntry( getEvaluations(), nfx, -HALF /\n                                    xpt.getEntry(getEvaluations() - n, nfx));\n-                    bmat.setEntry( getEvaluations() - n, nfx, -bmat.getEntry(1, nfx) -\n+                    bmat.setEntry( getEvaluations() - n, nfx, -bmat.getEntry(INDEX_OFFSET, nfx) -\n                                    bmat.getEntry( getEvaluations(), nfx));\n-                    zmat.setEntry(1, nfx, Math.sqrt(TWO) / (stepa * stepb));\n+                    zmat.setEntry(INDEX_OFFSET, nfx, Math.sqrt(TWO) / (stepa * stepb));\n                     zmat.setEntry( getEvaluations(), nfx, Math.sqrt(HALF) / rhosq);\n-                    zmat.setEntry( getEvaluations() - n, nfx, -zmat.getEntry(1, nfx) -\n+                    zmat.setEntry( getEvaluations() - n, nfx, -zmat.getEntry(INDEX_OFFSET, nfx) -\n                                    zmat.getEntry( getEvaluations(), nfx));\n                 }\n \n \n             } else {\n                 ih = ipt * (ipt - 1) / 2 + jpt;\n-                zmat.setEntry(1, nfx, recip);\n+                zmat.setEntry(INDEX_OFFSET, nfx, recip);\n                 zmat.setEntry( getEvaluations(), nfx, recip);\n                 zmat.setEntry(ipt + 1, nfx, -recip);\n                 zmat.setEntry( jpt + 1, nfx, -recip);\n             // Computing MIN\n             d__1 = delta;\n             d__2 = su.getEntry(j);\n-            ptsaux.setEntry(j, 1, Math.min(d__1, d__2));\n+            ptsaux.setEntry(j, INDEX_OFFSET, Math.min(d__1, d__2));\n             // Computing MAX\n             d__1 = -delta;\n             d__2 = sl.getEntry(j);\n-            ptsaux.setEntry(j, 2, Math.max(d__1, d__2));\n-            if (ptsaux.getEntry(j, 1) + ptsaux.getEntry(j, 2) < ZERO) {\n-                temp = ptsaux.getEntry(j, 1);\n-                ptsaux.setEntry(j, 1, ptsaux.getEntry(j, 2));\n-                ptsaux.setEntry(j, 2, temp);\n-            }\n-            d__2 = ptsaux.getEntry(j, 2);\n-            d__1 = ptsaux.getEntry(j, 1);\n+            ptsaux.setEntry(j, INDEX_OFFSET + 1, Math.max(d__1, d__2));\n+            if (ptsaux.getEntry(j, INDEX_OFFSET) + ptsaux.getEntry(j, INDEX_OFFSET + 1) < ZERO) {\n+                temp = ptsaux.getEntry(j, INDEX_OFFSET);\n+                ptsaux.setEntry(j, INDEX_OFFSET, ptsaux.getEntry(j, INDEX_OFFSET + 1));\n+                ptsaux.setEntry(j, INDEX_OFFSET + 1, temp);\n+            }\n+            d__2 = ptsaux.getEntry(j, INDEX_OFFSET + 1);\n+            d__1 = ptsaux.getEntry(j, INDEX_OFFSET);\n             if (Math.abs(d__2) < HALF * Math.abs(d__1)) {\n-                ptsaux.setEntry(j, 2, HALF * ptsaux.getEntry(j, 1));\n+                ptsaux.setEntry(j, INDEX_OFFSET + 1, HALF * ptsaux.getEntry(j, INDEX_OFFSET));\n             }\n             for (int i = 1; i <= ndim; i++) {\n                 bmat.setEntry(i, j, ZERO);\n         // along a coordinate direction from XOPT, and set the corresponding\n         // nonzero elements of BMAT and ZMAT.\n \n-        ptsid.setEntry(1, sfrac);\n+        ptsid.setEntry(INDEX_OFFSET, sfrac);\n         for (int j = 1; j <= n; j++) {\n             jp = j + 1;\n             jpn = jp + n;\n             ptsid.setEntry(jp, (double) j + sfrac);\n             if (jpn <= npt) {\n                 ptsid.setEntry(jpn, (double) j / (double) np + sfrac);\n-                temp = ONE / (ptsaux.getEntry(j, 1) - ptsaux.getEntry(j, 2));\n-                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, 1));\n-                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, 2));\n-                bmat.setEntry(1, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n-                final double d1 = ptsaux.getEntry(j, 1) * ptsaux.getEntry(j, 2);\n-                zmat.setEntry(1, j,  Math.sqrt(TWO) / Math.abs(d1));\n-                zmat.setEntry(jp, j, zmat.getEntry(1, j) *\n-                        ptsaux.getEntry(j, 2) * temp);\n-                zmat.setEntry(jpn, j, -zmat.getEntry(1, j) *\n-                        ptsaux.getEntry(j, 1) * temp);\n+                temp = ONE / (ptsaux.getEntry(j, INDEX_OFFSET) - ptsaux.getEntry(j, INDEX_OFFSET + 1));\n+                bmat.setEntry(jp, j, -temp + ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n+                bmat.setEntry(jpn, j, temp + ONE / ptsaux.getEntry(j, INDEX_OFFSET + 1));\n+                bmat.setEntry(INDEX_OFFSET, j, -bmat.getEntry(jp, j) - bmat.getEntry(jpn, j));\n+                final double d1 = ptsaux.getEntry(j, INDEX_OFFSET) * ptsaux.getEntry(j, INDEX_OFFSET + 1);\n+                zmat.setEntry(INDEX_OFFSET, j,  Math.sqrt(TWO) / Math.abs(d1));\n+                zmat.setEntry(jp, j, zmat.getEntry(INDEX_OFFSET, j) *\n+                        ptsaux.getEntry(j, INDEX_OFFSET + 1) * temp);\n+                zmat.setEntry(jpn, j, -zmat.getEntry(INDEX_OFFSET, j) *\n+                        ptsaux.getEntry(j, INDEX_OFFSET) * temp);\n             } else {\n-                bmat.setEntry(1, j, -ONE / ptsaux.getEntry(j, 1));\n-                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, 1));\n+                bmat.setEntry(INDEX_OFFSET, j, -ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n+                bmat.setEntry(jp, j, ONE / ptsaux.getEntry(j, INDEX_OFFSET));\n                 // Computing 2nd power\n-                final double d1 = ptsaux.getEntry(j, 1);\n+                final double d1 = ptsaux.getEntry(j, INDEX_OFFSET);\n                 bmat.setEntry(j + npt, j, -HALF * (d1 * d1));\n             }\n         }\n                 }\n                 ptsid.setEntry(k, (double) ip + (double) iq / (double) np +\n                         sfrac);\n-                temp = ONE / (ptsaux.getEntry(ip, 1) * ptsaux.getEntry(iq, 1));\n-                zmat.setEntry(1, (k - np), temp);\n+                temp = ONE / (ptsaux.getEntry(ip, INDEX_OFFSET) * ptsaux.getEntry(iq, INDEX_OFFSET));\n+                zmat.setEntry(INDEX_OFFSET, (k - np), temp);\n                 zmat.setEntry(ip + 1, k - np, -temp);\n                 zmat.setEntry(iq + 1, k - np, -temp);\n                 zmat.setEntry(k, k - np, temp);\n                 } else {\n                     ip = (int) ptsid.getEntry(k);\n                     if (ip > 0) {\n-                        sum = work2.getEntry(ip) * ptsaux.getEntry(ip, 1);\n+                        sum = work2.getEntry(ip) * ptsaux.getEntry(ip, INDEX_OFFSET);\n                     }\n                     iq = (int) ((double) np * ptsid.getEntry(k) - (double) (ip * np));\n                     if (iq > 0) {\n-                        int iw = 1;\n+                        int iw = INDEX_OFFSET;\n                         if (ip == 0) {\n-                            iw = 2;\n+                            iw = INDEX_OFFSET + 1;\n                         }\n                         sum += work2.getEntry(iq) * ptsaux.getEntry(iq, iw);\n                     }\n                 ip = (int) ptsid.getEntry(kpt);\n                 iq = (int) ((double) np * ptsid.getEntry(kpt) - (double) (ip * np));\n                 if (ip > 0) {\n-                    xp = ptsaux.getEntry(ip, 1);\n+                    xp = ptsaux.getEntry(ip, INDEX_OFFSET);\n                     xpt.setEntry(kpt, ip, xp);\n                 }\n                 if (iq > 0) {\n-                    xq = ptsaux.getEntry(iq, 1);\n+                    xq = ptsaux.getEntry(iq, INDEX_OFFSET);\n                     if (ip == 0) {\n-                        xq = ptsaux.getEntry(iq, 2);\n+                        xq = ptsaux.getEntry(iq, INDEX_OFFSET + 1);\n                     }\n                     xpt.setEntry(kpt, iq, xq);\n                 }\n                         int ihq = (iq * iq + iq) / 2;\n                         if (ip == 0) {\n                             // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(iq, 2);\n+                            final double d1 = ptsaux.getEntry(iq, INDEX_OFFSET + 1);\n                             hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d1 * d1));\n                         } else {\n                             ihp = (ip * ip + ip) / 2;\n                             // Computing 2nd power\n-                            final double d1 = ptsaux.getEntry(ip, 1);\n+                            final double d1 = ptsaux.getEntry(ip, INDEX_OFFSET);\n                             hq.setEntry(ihp, hq.getEntry(ihp) + temp * (d1 * d1));\n                             if (iq > 0) {\n                                 // Computing 2nd power\n-                                final double d2 = ptsaux.getEntry(iq, 1);\n+                                final double d2 = ptsaux.getEntry(iq, INDEX_OFFSET);\n                                 hq.setEntry(ihq, hq.getEntry(ihq) + temp * (d2 * d2));\n                                 int iw = Math.max(ihp,ihq) - Math.abs(iq - ip);\n                                 hq.setEntry(iw, hq.getEntry(iw)\n-                                            + temp * ptsaux.getEntry(ip, 1) * ptsaux.getEntry(iq, 1));\n+                                            + temp * ptsaux.getEntry(ip, INDEX_OFFSET) * ptsaux.getEntry(iq, INDEX_OFFSET));\n                             }\n                         }\n                     }\n             d__1 = zmat.getEntry(knew, j);\n             if (Math.abs(d__1) > ztest) {\n                 // Computing 2nd power\n-                d__1 = zmat.getEntry(knew, 1);\n+                d__1 = zmat.getEntry(knew, INDEX_OFFSET);\n                 // Computing 2nd power\n                 d__2 = zmat.getEntry(knew, j);\n                 temp = Math.sqrt(d__1 * d__1 + d__2 * d__2);\n-                tempa = zmat.getEntry(knew, 1) / temp;\n+                tempa = zmat.getEntry(knew, INDEX_OFFSET) / temp;\n                 tempb = zmat.getEntry(knew, j) / temp;\n                 for (int i = 1; i <= npt; i++) {\n-                    temp = tempa * zmat.getEntry(i, 1) + tempb * zmat.getEntry(i, j);\n+                    temp = tempa * zmat.getEntry(i, INDEX_OFFSET) + tempb * zmat.getEntry(i, j);\n                     zmat.setEntry(i, j, tempa * zmat.getEntry(i, j) -\n-                                  tempb * zmat.getEntry(i, 1));\n-                    zmat.setEntry(i, 1, temp);\n+                                  tempb * zmat.getEntry(i, INDEX_OFFSET));\n+                    zmat.setEntry(i, INDEX_OFFSET, temp);\n                 }\n             }\n             zmat.setEntry(knew, j, ZERO);\n         // and calculate the parameters of the updating formula.\n \n         for (int i = 1; i <= npt; i++) {\n-            work.setEntry(i, zmat.getEntry(knew, 1) * zmat.getEntry(i, 1));\n+            work.setEntry(i, zmat.getEntry(knew, INDEX_OFFSET) * zmat.getEntry(i, INDEX_OFFSET));\n         }\n         alpha = work.getEntry(knew);\n         tau = vlag.getEntry(knew);\n         // Complete the updating of ZMAT.\n \n         temp = Math.sqrt(denom);\n-        tempb = zmat.getEntry(knew, 1) / temp;\n+        tempb = zmat.getEntry(knew, INDEX_OFFSET) / temp;\n         tempa = tau / temp;\n         for (int i= 1; i <= npt; i++) {\n-            zmat.setEntry(i, 1, tempa * zmat.getEntry(i, 1) -\n+            zmat.setEntry(i, INDEX_OFFSET, tempa * zmat.getEntry(i, INDEX_OFFSET) -\n                     tempb * vlag.getEntry(i));\n         }\n \n \n         /** {@inheritDoc} */\n         public double getEntry(int index) {\n-            return super.getEntry(index - 1);\n+            return super.getEntry(index - INDEX_OFFSET);\n         }\n \n         /** {@inheritDoc} */\n         public void setEntry(int index, double value) {\n-            super.setEntry(index - 1, value);\n+            super.setEntry(index - INDEX_OFFSET, value);\n         }\n     }\n \n         }\n         /** {@inheritDoc} */\n         public double getEntry(int row, int col) {\n-            return super.getEntry(row - 1, col - 1);\n+            return super.getEntry(row - INDEX_OFFSET, col - INDEX_OFFSET);\n         }\n \n         /** {@inheritDoc} */\n         public void setEntry(int row, int col, double value) {\n-            super.setEntry(row - 1, col - 1, value);\n+            super.setEntry(row - INDEX_OFFSET, col - INDEX_OFFSET, value);\n         }\n     }\n \n     // For use in Fortran-like 1-based loops.  Calls to this offset\n     // function will be removed when all loops are converted to 0-base.\n     private static int f2jai(int j) {\n-        return j - 1;\n+        return j - INDEX_OFFSET;\n     }\n }", "timestamp": 1313226519, "metainfo": ""}