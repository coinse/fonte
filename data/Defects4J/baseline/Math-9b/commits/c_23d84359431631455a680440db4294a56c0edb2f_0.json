{"sha": "23d84359431631455a680440db4294a56c0edb2f", "log": "simplified Nordsieck transformer extended its domain to handle several layouts for multistep state  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n+++ b/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n \n import java.io.Serializable;\n import java.math.BigInteger;\n-import java.util.Arrays;\n \n import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.decomposition.FieldDecompositionSolver;\n+import org.apache.commons.math.linear.decomposition.FieldLUDecompositionImpl;\n \n /**\n  * This class transforms state history between multistep (with or without\n  * derivatives) and Nordsieck forms.\n  * <p>\n- * {@link MultistepIntegrator multistep integrators} use state history\n- * from several previous steps to compute the current state. They may also use\n- * the first derivative of current state. All states are separated by a fixed\n- * step size h from each other. Since these methods are based on polynomial\n- * interpolation, the information from the previous state may be represented\n- * in another equivalent way: using the state higher order derivatives at\n- * current step rather. This class transforms state history between these three\n- * equivalent forms.\n- * <p>\n- * <p>\n- * The supported forms for a dimension n history are:\n- * <ul>\n- *   <li>multistep without derivatives:<br/>\n- *     <pre>\n- *       y<sub>k</sub>, y<sub>k-1</sub> ... y<sub>k-(n-2), y<sub>k-(n-1)</sub>\n- *     </pre>\n- *   </li>\n- *   <li>multistep with first derivative at current step:<br/>\n- *     <pre>\n- *       y<sub>k</sub>, y'<sub>k</sub>, y<sub>k-1</sub> ... y<sub>k-(n-2)</sub>\n- *     </pre>\n- *   </li>\n- *   <li>Nordsieck:\n- *     <pre>\n- *       y<sub>k</sub>, h y'<sub>k</sub>, h<sup>2</sup>/2 y''<sub>k</sub> ... h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>\n- *     </pre>\n- *   </li>\n- * </ul> \n- * In these expressions, y<sub>k</sub> is the state at the current step. For each p,\n- * y<sub>k-p</sub> is the state at the p<sup>th</sup> previous step. y'<sub>k</sub>,\n- * y''<sub>k</sub> ... yn-1<sub>k</sub> are respectively the first, second, ...\n- * (n-1)<sup>th</sup> derivatives of the state at current step and h is the fixed\n- * step size.\n- * </p>\n- * <p>\n- * The transforms are exact for polynomials.\n+ * {@link MultistepIntegrator multistep integrators} use state and state\n+ * derivative history from several previous steps to compute the current state.\n+ * All states are separated by a fixed step size h from each other. Since these\n+ * methods are based on polynomial interpolation, the information from the\n+ * previous states may be represented in another equivalent way: using the state\n+ * higher order derivatives at current step only. This class transforms state\n+ * history between these equivalent forms.\n+ * </p>\n+ * <p>\n+ * The general multistep form for a dimension n state history at step k is\n+ * composed of q-p previous states followed by s-r previous scaled derivatives\n+ * with n = (q-p) + (s-r):\n+ * <pre>\n+ *   y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ... y<sub>k-(q-1)</sub>\n+ *   h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub>\n+ * </pre>\n+ * As an example, the {@link\n+ * org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator Adams-Bashforth}\n+ * integrator uses p=1, q=2, r=1, s=n. The {@link\n+ * org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator Adams-Moulton}\n+ * integrator uses p=1, q=2, r=0, s=n-1.\n+ * </p>\n+ * <p>\n+ * The Nordsieck form for a dimension n state history at step k is composed of the\n+ * current state followed by n-1 current scaled derivatives:\n+ * <pre>\n+ * y<sub>k</sub>\n+ * h y'<sub>k</sub>, h<sup>2</sup>/2 y''<sub>k</sub> ... h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>\n+ * </pre>\n+ * Where y'<sub>k</sub>, y''<sub>k</sub> ... yn-1<sub>k</sub> are respectively the\n+ * first, second, ... (n-1)<sup>th</sup> derivatives of the state at current step\n+ * and h is the fixed step size.\n  * </p>\n  * <p>\n  * In Nordsieck form, the state history can be converted from step size h to step\n- * size h' by rescaling each component by 1, h'/h, (h'/h)<sup>2</sup> ...\n+ * size h' by scaling each component by 1, h'/h, (h'/h)<sup>2</sup> ...\n  * (h'/h)<sup>n-1</sup>.\n+ * </p>\n+ * <p>\n+ * The transform between general multistep and Nordsieck forms is exact for\n+ * polynomials.\n  * </p>\n  * <p>\n  * Instances of this class are guaranteed to be immutable.\n public class NordsieckTransformer implements Serializable {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -2707468304560314664L;\n-\n-    /** Nordsieck to Multistep  without derivatives matrix. */\n-    private final RealMatrix matNtoMWD;\n-                                           \n-    /** Multistep without derivatives to Nordsieck matrix. */\n-    private final RealMatrix matMWDtoN;\n+    private static final long serialVersionUID = 2216907099394084076L;\n \n     /** Nordsieck to Multistep matrix. */\n-    private final RealMatrix matNtoM;\n+    private final RealMatrix nordsieckToMultistep;\n                                            \n     /** Multistep to Nordsieck matrix. */\n-    private final RealMatrix matMtoN;\n+    private final RealMatrix multistepToNordsieck;\n \n     /**\n      * Build a transformer for a specified order.\n-     * @param n dimension of the history\n-     */\n-    public NordsieckTransformer(final int n) {\n-\n-        // from Nordsieck to multistep without derivatives\n-        final BigInteger[][] bigNtoMWD = buildNordsieckToMultistepWithoutDerivatives(n);\n-        double[][] dataNtoMWD = new double[n][n];\n-        for (int i = 0; i < n; ++i) {\n-            double[]     dRow = dataNtoMWD[i];\n-            BigInteger[] bRow = bigNtoMWD[i];\n+     * <p>states considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n+     * y<sub>k-(q-1)</sub> and scaled derivatives considered are\n+     * h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub>\n+     * @param p start state index offset in multistep form\n+     * @param q end state index offset in multistep form\n+     * @param r start state derivative index offset in multistep form\n+     * @param s end state derivative index offset in multistep form\n+     */\n+    public NordsieckTransformer(final int p, final int q, final int r, final int s) {\n+\n+        // from Nordsieck to multistep\n+        final FieldMatrix<BigFraction> bigNtoM = buildNordsieckToMultistep(p, q, r, s);\n+        Convertor convertor = new Convertor();\n+        bigNtoM.walkInOptimizedOrder(convertor);\n+        nordsieckToMultistep = convertor.getConvertedMatrix();\n+\n+        // from multistep to Nordsieck\n+        final FieldDecompositionSolver<BigFraction> solver =\n+            new FieldLUDecompositionImpl<BigFraction>(bigNtoM).getSolver();\n+        final FieldMatrix<BigFraction> bigMtoN = solver.getInverse();\n+        convertor = new Convertor();\n+        bigMtoN.walkInOptimizedOrder(convertor);\n+        multistepToNordsieck = convertor.getConvertedMatrix();\n+\n+    }\n+\n+    /**\n+     * Build the transform from Nordsieck to multistep.\n+     * <p>states considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n+     * y<sub>k-(q-1)</sub> and scaled derivatives considered are\n+     * h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub>\n+     * @param p start state index offset in multistep form\n+     * @param q end state index offset in multistep form\n+     * @param r start state derivative index offset in multistep form\n+     * @param s end state derivative index offset in multistep form\n+     * @return transform from Nordsieck to multistep\n+     */\n+    public static FieldMatrix<BigFraction> buildNordsieckToMultistep(final int p, final int q,\n+                                                                     final int r, final int s) {\n+\n+        final int n = (q - p) + (s - r);\n+        final BigFraction[][] array = new BigFraction[n][n];\n+\n+        int i = 0;\n+        for (int l = p; l < q; ++l) {\n+            // handle previous state y<sub>(k-l)</sub>\n+            // the following expressions are direct applications of Taylor series\n+            // y<sub>k-1</sub>: [ 1  -1   1  -1   1 ...]\n+            // y<sub>k-2</sub>: [ 1  -2   4  -8  16 ...]\n+            // y<sub>k-3</sub>: [ 1  -3   9 -27  81 ...]\n+            // y<sub>k-4</sub>: [ 1  -4  16 -64 256 ...]\n+            final BigFraction[] row = array[i++];\n+            final BigInteger factor = BigInteger.valueOf(-l);\n+            BigInteger al = BigInteger.ONE;\n             for (int j = 0; j < n; ++j) {\n-                dRow[j] = bRow[j].doubleValue();\n+                row[j] = new BigFraction(al, BigInteger.ONE);\n+                al = al.multiply(factor);\n             }\n         }\n-        matNtoMWD = new RealMatrixImpl(dataNtoMWD, false);\n-\n-        // from multistep without derivatives to Nordsieck\n-        final BigFraction[][] bigToN = buildMultistepWithoutDerivativesToNordsieck(n);\n-        double[][] dataMWDtoN = new double[n][n];\n-        for (int i = 0; i < n; ++i) {\n-            double[]     dRow = dataMWDtoN[i];\n-            BigFraction[] bRow = bigToN[i];\n-            for (int j = 0; j < n; ++j) {\n-                dRow[j] = bRow[j].doubleValue();\n+\n+        for (int l = r; l < s; ++l) {\n+            // handle previous state scaled derivative h y'<sub>(k-l)</sub>\n+            // the following expressions are direct applications of Taylor series\n+            // h y'<sub>k-1</sub>: [ 0  1  -2   3  -4   5 ...]\n+            // h y'<sub>k-2</sub>: [ 0  1  -4   6  -8  10 ...]\n+            // h y'<sub>k-3</sub>: [ 0  1  -6   9 -12  15 ...]\n+            // h y'<sub>k-4</sub>: [ 0  1  -8  12 -16  20 ...]\n+            final BigFraction[] row = array[i++];\n+            final BigInteger factor = BigInteger.valueOf(-l);\n+            row[0] = BigFraction.ZERO;\n+            BigInteger al = BigInteger.ONE;\n+            for (int j = 1; j < n; ++j) {\n+                row[j] = new BigFraction(al.multiply(BigInteger.valueOf(j)), BigInteger.ONE);\n+                al = al.multiply(factor);\n             }\n         }\n-        matMWDtoN = new RealMatrixImpl(dataMWDtoN, false);\n-\n-        // from Nordsieck to multistep\n-        final BigInteger[][] bigNtoM = buildNordsieckToMultistep(n);\n-        double[][] dataNtoM = new double[n][n];\n-        for (int i = 0; i < n; ++i) {\n-            double[]     dRow = dataNtoM[i];\n-            BigInteger[] bRow = bigNtoM[i];\n-            for (int j = 0; j < n; ++j) {\n-                dRow[j] = bRow[j].doubleValue();\n-            }\n-        }\n-        matNtoM = new RealMatrixImpl(dataNtoM, false);\n-\n-        // from multistep to Nordsieck\n-        convertMWDtNtoMtN(bigToN);\n-        double[][] dataMtoN = new double[n][n];\n-        for (int i = 0; i < n; ++i) {\n-            double[]     dRow = dataMtoN[i];\n-            BigFraction[] bRow = bigToN[i];\n-            for (int j = 0; j < n; ++j) {\n-                dRow[j] = bRow[j].doubleValue();\n-            }\n-        }\n-        matMtoN = new RealMatrixImpl(dataMtoN, false);\n-\n-    }\n-\n-    /**\n-     * Build the transform from Nordsieck to multistep without derivatives.\n-     * @param n dimension of the history\n-     * @return transform from Nordsieck to multistep without derivatives\n-     */\n-    public static BigInteger[][] buildNordsieckToMultistepWithoutDerivatives(final int n) {\n-\n-        final BigInteger[][] array = new BigInteger[n][n];\n-\n-        // row 0: [1 0 0 0 ... 0 ]\n-        array[0][0] = BigInteger.ONE;\n-        Arrays.fill(array[0], 1, n, BigInteger.ZERO);\n-\n-        // the following expressions are direct applications of Taylor series\n-        // rows 1 to n-1: aij = (-i)^j\n-        // [ 1  -1   1  -1   1 ...]\n-        // [ 1  -2   4  -8  16 ...]\n-        // [ 1  -3   9 -27  81 ...]\n-        // [ 1  -4  16 -64 256 ...]\n-        for (int i = 1; i < n; ++i) {\n-            final BigInteger[] row  = array[i];\n-            final BigInteger factor = BigInteger.valueOf(-i);\n-            BigInteger aj = BigInteger.ONE;\n-            for (int j = 0; j < n; ++j) {\n-                row[j] = aj;\n-                aj = aj.multiply(factor);\n-            }\n-        }\n-\n-        return array;\n-\n-    }\n-\n-    /**\n-     * Build the transform from multistep without derivatives to Nordsieck.\n-     * @param n dimension of the history\n-     * @return transform from multistep without derivatives to Nordsieck\n-     */\n-    public static BigFraction[][] buildMultistepWithoutDerivativesToNordsieck(final int n) {\n-\n-        final BigInteger[][] iArray = new BigInteger[n][n];\n-\n-        // row 0: [1 0 0 0 ... 0 ]\n-        iArray[0][0] = BigInteger.ONE;\n-        Arrays.fill(iArray[0], 1, n, BigInteger.ZERO);\n-\n-        // We use recursive definitions of triangular integer series for each column.\n-        // For example column 0 of matrices of increasing dimensions are:\n-        //  1/0! for dimension 1\n-        //  1/1!,  1/1! for dimension 2\n-        //  2/2!,  3/2!,  1/2! for dimension 3\n-        //  6/3!, 11/3!,  6/3!,  1/3! for dimension 4\n-        // 24/4!, 50/4!, 35/4!, 10/4!, 1/4! for dimension 5\n-        // The numerators are the Stirling numbers of the first kind, (A008275 in\n-        // Sloane's encyclopedia http://www.research.att.com/~njas/sequences/A008275)\n-        // with a multiplicative factor of +/-1 (which we will write +/-binomial(n-1, 0)).\n-        // In the same way, column 1 is A049444 with a multiplicative factor of\n-        // +/-binomial(n-1, 1) and column 2 is A123319 with a multiplicative factor of\n-        // +/-binomial(n-1, 2). The next columns are defined by similar definitions but\n-        // are not identified in Sloane's encyclopedia.\n-        // Another interesting observation is that for each dimension k, the last column\n-        // (except the initial 0) is a copy of the first column of the dimension k-1 matrix,\n-        // possibly with an opposite sign (i.e. these columns are also linked to Stirling\n-        // numbers of the first kind).\n-        for (int i = 1; i < n; ++i) {\n-\n-            final BigInteger bigI = BigInteger.valueOf(i);\n-\n-            // row i\n-            BigInteger[] rowK   = iArray[i];\n-            BigInteger[] rowKm1 = iArray[i - 1];\n-            for (int j = 0; j < i; ++j) {\n-                rowK[j] = BigInteger.ONE;\n-            }\n-            rowK[i] = rowKm1[0];\n-\n-            // rows i-1 to 1\n-            for (int k = i - 1; k > 0; --k) {\n-\n-                // select rows\n-                rowK   = rowKm1;\n-                rowKm1 = iArray[k - 1];\n-\n-                // apply recursive defining formula\n-                for (int j = 0; j < i; ++j) {\n-                    rowK[j] = rowK[j].multiply(bigI).add(rowKm1[j]);\n-                }\n-\n-                // initialize new last column\n-                rowK[i] = rowKm1[0];\n-\n-            }\n-            rowKm1[0] = rowKm1[0].multiply(bigI);\n-\n-        }\n-\n-        // apply column specific factors\n-        final BigInteger factorial = iArray[0][0];\n-        final BigFraction[][] fArray = new BigFraction[n][n];\n-        for (int i = 0; i < n; ++i) {\n-            final BigFraction[] fRow = fArray[i];\n-            final BigInteger[]  iRow = iArray[i];\n-            BigInteger binomial = BigInteger.ONE;\n-            for (int j = 0; j < n; ++j) {\n-                fRow[j] = new BigFraction(binomial.multiply(iRow[j]), factorial);\n-                binomial = binomial.negate().multiply(BigInteger.valueOf(n - j - 1)).divide(BigInteger.valueOf(j + 1));\n-            }\n-        }\n-\n-        return fArray;\n-\n-    }\n-\n-    /**\n-     * Build the transform from Nordsieck to multistep.\n-     * @param n dimension of the history\n-     * @return transform from Nordsieck to multistep\n-     */\n-    public static BigInteger[][] buildNordsieckToMultistep(final int n) {\n-\n-        final BigInteger[][] array = new BigInteger[n][n];\n-\n-        // row 0: [1 0 0 0 ... 0 ]\n-        array[0][0] = BigInteger.ONE;\n-        Arrays.fill(array[0], 1, n, BigInteger.ZERO);\n-\n-        if (n > 1) {\n-\n-            // row 1: [0 1 0 0 ... 0 ]\n-            array[1][0] = BigInteger.ZERO;\n-            array[1][1] = BigInteger.ONE;\n-            Arrays.fill(array[1], 2, n, BigInteger.ZERO);\n-\n-            // the following expressions are direct applications of Taylor series\n-            // rows 2 to n-1: aij = (1-i)^j\n-            // [ 1  -1   1  -1   1 ...]\n-            // [ 1  -2   4  -8  16 ...]\n-            // [ 1  -3   9 -27  81 ...]\n-            // [ 1  -4  16 -64 256 ...]\n-            for (int i = 2; i < n; ++i) {\n-                final BigInteger[] row  = array[i];\n-                final BigInteger factor = BigInteger.valueOf(1 - i);\n-                BigInteger aj = BigInteger.ONE;\n-                for (int j = 0; j < n; ++j) {\n-                    row[j] = aj;\n-                    aj = aj.multiply(factor);\n-                }\n-            }\n-\n-        }\n-\n-        return array;\n-\n-    }\n-\n-    /**\n-     * Build the transform from multistep to Nordsieck.\n-     * @param n dimension of the history\n-     * @return transform from multistep to Nordsieck\n-     */\n-    public static BigFraction[][] buildMultistepToNordsieck(final int n) {\n-        final BigFraction[][] array = buildMultistepWithoutDerivativesToNordsieck(n);\n-        convertMWDtNtoMtN(array);\n-        return array;\n-    }\n-\n-    /**\n-     * Convert a transform from multistep without derivatives to Nordsieck to\n-     * multistep to Nordsieck.\n-     * @param work array, contains tansform from multistep without derivatives\n-     * to Nordsieck on input, will be overwritten with tansform from multistep\n-     * to Nordsieck on output\n-     */\n-    private static void convertMWDtNtoMtN(BigFraction[][] array) {\n-\n-        final int n = array.length;\n-        if (n == 1) {\n-            return;\n-        }\n-\n-        // the second row of the matrix without derivatives represents the linear equation:\n-        // hy' = a0 yk + a1 yk-1 + ... + a(n-1) yk-(n-1)\n-        // we solve it with respect to the oldest state yk-(n-1) and get\n-        // yk-(n-1) = -a0/a(n-1) yk + 1/a(n-1) hy' - a1/a(n-1) yk-1 - ...\n-        final BigFraction[] secondRow = array[1];\n-        final BigFraction[] solved    = new BigFraction[n];\n-        final BigFraction f = secondRow[n - 1].reciprocal().negate();\n-        solved[0] = secondRow[0].multiply(f);\n-        solved[1] = f.negate();\n-        for (int j = 2; j < n; ++j) {\n-            solved[j] = secondRow[j - 1].multiply(f);\n-        }\n-\n-        // update the matrix so it expects hy' in second element\n-        // rather than yk-(n-1) in last elements when post-multiplied\n-        for (int i = 0; i < n; ++i) {\n-            final BigFraction[] rowI = array[i];\n-            final BigFraction last = rowI[n - 1];\n-            for (int j = n - 1; j > 1; --j) {\n-                rowI[j] = rowI[j - 1].add(last.multiply(solved[j]));\n-            }\n-            rowI[1] = last.multiply(solved[1]);\n-            rowI[0] = rowI[0].add(last.multiply(solved[0]));\n+\n+        return new FieldMatrixImpl<BigFraction>(array, false);\n+\n+    }\n+\n+    /** Convertor for {@link FieldMatrix}/{@link BigFraction}. */\n+    private static class Convertor extends DefaultFieldMatrixPreservingVisitor<BigFraction> {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -1799685632320460982L;\n+\n+        /** Converted array. */\n+        private double[][] data;\n+\n+        /** Simple constructor. */\n+        public Convertor() {\n+            super(BigFraction.ZERO);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            data = new double[rows][columns];\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void visit(int row, int column, BigFraction value) {\n+            data[row][column] = value.doubleValue();\n+        }\n+\n+        /** Get the converted matrix.\n+         * @return converted matrix\n+         */\n+        RealMatrix getConvertedMatrix() {\n+            return new RealMatrixImpl(data, false);\n         }\n \n     }\n      * Transform a scalar state history from multistep form to Nordsieck form.\n      * <p>\n      * The input state history must be in multistep form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for previous state ... element n-1 for (n-2)<sup>th</sup> previous state.\n+     * y<sub>k-p</sub>, element 1 for y<sub>k-(p+1)</sub> ... element q-p-1 for\n+     * y<sub>k-(q-1)</sub>, element q-p for h y'<sub>k-r</sub>, element q-p+1\n+     * for h y'<sub>k-(r+1)</sub> ... element n-1 for h y'<sub>k-(s-1)</sub>.\n      * The output state history will be in Nordsieck form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for current state scaled second derivative ... element n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n+     * y<sub>k</sub>, element 1 for h y'<sub>k</sub>, element 2 for\n+     * h<sup>2</sup>/2 y''<sub>k</sub> ... element n-1 for\n+     * h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>.\n      * </p>\n      * @param multistepHistory scalar state history in multistep form\n      * @return scalar state history in Nordsieck form\n      */\n     public double[] multistepToNordsieck(final double[] multistepHistory) {\n-        return matMtoN.operate(multistepHistory);\n+        return multistepToNordsieck.operate(multistepHistory);\n     }\n \n     /**\n      * Transform a vectorial state history from multistep form to Nordsieck form.\n      * <p>\n      * The input state history must be in multistep form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for previous state ... row n-1 for (n-2)<sup>th</sup> previous state.\n+     * y<sub>k-p</sub>, row 1 for y<sub>k-(p+1)</sub> ... row q-p-1 for\n+     * y<sub>k-(q-1)</sub>, row q-p for h y'<sub>k-r</sub>, row q-p+1\n+     * for h y'<sub>k-(r+1)</sub> ... row n-1 for h y'<sub>k-(s-1)</sub>.\n      * The output state history will be in Nordsieck form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for current state scaled second derivative ... row n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n+     * y<sub>k</sub>, row 1 for h y'<sub>k</sub>, row 2 for\n+     * h<sup>2</sup>/2 y''<sub>k</sub> ... row n-1 for\n+     * h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>.\n      * </p>\n      * @param multistepHistory vectorial state history in multistep form\n      * @return vectorial state history in Nordsieck form\n      */\n     public RealMatrix multistepToNordsieck(final RealMatrix multistepHistory) {\n-        return matMtoN.multiply(multistepHistory);\n+        return multistepToNordsieck.multiply(multistepHistory);\n     }\n \n     /**\n      * Transform a scalar state history from Nordsieck form to multistep form.\n      * <p>\n      * The input state history must be in Nordsieck form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for current state scaled second derivative ... element n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n+     * y<sub>k</sub>, element 1 for h y'<sub>k</sub>, element 2 for\n+     * h<sup>2</sup>/2 y''<sub>k</sub> ... element n-1 for\n+     * h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>.\n      * The output state history will be in multistep form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for previous state ... element n-1 for (n-2)<sup>th</sup> previous state.\n+     * y<sub>k-p</sub>, element 1 for y<sub>k-(p+1)</sub> ... element q-p-1 for\n+     * y<sub>k-(q-1)</sub>, element q-p for h y'<sub>k-r</sub>, element q-p+1\n+     * for h y'<sub>k-(r+1)</sub> ... element n-1 for h y'<sub>k-(s-1)</sub>.\n      * </p>\n      * @param nordsieckHistory scalar state history in Nordsieck form\n      * @return scalar state history in multistep form\n      */\n     public double[] nordsieckToMultistep(final double[] nordsieckHistory) {\n-        return matNtoM.operate(nordsieckHistory);\n+        return nordsieckToMultistep.operate(nordsieckHistory);\n     }\n \n     /**\n      * Transform a vectorial state history from Nordsieck form to multistep form.\n      * <p>\n      * The input state history must be in Nordsieck form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for current state scaled second derivative ... row n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n+     * y<sub>k</sub>, row 1 for h y'<sub>k</sub>, row 2 for\n+     * h<sup>2</sup>/2 y''<sub>k</sub> ... row n-1 for\n+     * h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>.\n      * The output state history will be in multistep form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for previous state ... row n-1 for (n-2)<sup>th</sup> previous state.\n+     * y<sub>k-p</sub>, row 1 for y<sub>k-(p+1)</sub> ... row q-p-1 for\n+     * y<sub>k-(q-1)</sub>, row q-p for h y'<sub>k-r</sub>, row q-p+1\n+     * for h y'<sub>k-(r+1)</sub> ... row n-1 for h y'<sub>k-(s-1)</sub>.\n      * </p>\n      * @param nordsieckHistory vectorial state history in Nordsieck form\n      * @return vectorial state history in multistep form\n      */\n     public RealMatrix nordsieckToMultistep(final RealMatrix nordsieckHistory) {\n-        return matNtoM.multiply(nordsieckHistory);\n-    }\n-\n-    /**\n-     * Transform a scalar state history from multistep without derivatives form\n-     * to Nordsieck form.\n-     * <p>\n-     * The input state history must be in multistep without derivatives form with\n-     * element 0 for current state, element 1 for previous state ... element n-1\n-     * for (n-1)<sup>th</sup> previous state.\n-     * The output state history will be in Nordsieck form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for current state scaled second derivative ... element n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n-     * </p>\n-     * @param mwdHistory scalar state history in multistep without derivatives form\n-     * @return scalar state history in Nordsieck form\n-     */\n-    public double[] multistepWithoutDerivativesToNordsieck(final double[] mwdHistory) {\n-        return matMWDtoN.operate(mwdHistory);\n-    }\n-\n-    /**\n-     * Transform a vectorial state history from multistep without derivatives form\n-     * to Nordsieck form.\n-     * <p>\n-     * The input state history must be in multistep without derivatives form with\n-     * row 0 for current state, row 1 for previous state ... row n-1\n-     * for (n-1)<sup>th</sup> previous state.\n-     * The output state history will be in Nordsieck form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for current state scaled second derivative ... row n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n-     * </p>\n-     * @param mwdHistory vectorial state history in multistep without derivatives form\n-     * @return vectorial state history in Nordsieck form\n-     */\n-    public RealMatrix multistepWithoutDerivativesToNordsieck(final RealMatrix mwdHistory) {\n-        return matMWDtoN.multiply(mwdHistory);\n-    }\n-\n-    /**\n-     * Transform a scalar state history from Nordsieck form to multistep without\n-     * derivatives form.\n-     * <p>\n-     * The input state history must be in Nordsieck form with element 0 for\n-     * current state, element 1 for current state scaled first derivative, element\n-     * 2 for current state scaled second derivative ... element n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n-     * The output state history will be in multistep without derivatives form with\n-     * element 0 for current state, element 1 for previous state ... element n-1\n-     * for (n-1)<sup>th</sup> previous state.\n-     * </p>\n-     * @param nordsieckHistory scalar state history in Nordsieck form\n-     * @return scalar state history in multistep without derivatives form\n-     */\n-    public double[] nordsieckToMultistepWithoutDerivatives(final double[] nordsieckHistory) {\n-        return matNtoMWD.operate(nordsieckHistory);\n-    }\n-\n-    /**\n-     * Transform a vectorial state history from Nordsieck form to multistep without\n-     * derivatives form.\n-     * <p>\n-     * The input state history must be in Nordsieck form with row 0 for\n-     * current state, row 1 for current state scaled first derivative, row\n-     * 2 for current state scaled second derivative ... row n-1 for current state\n-     * scaled (n-1)<sup>th</sup> derivative.\n-     * The output state history will be in multistep without derivatives form with\n-     * row 0 for current state, row 1 for previous state ... row n-1\n-     * for (n-1)<sup>th</sup> previous state.\n-     * </p>\n-     * @param nordsieckHistory vectorial state history in Nordsieck form\n-     * @return vectorial state history in multistep without derivatives form\n-     */\n-    public RealMatrix nordsieckToMultistepWithoutDerivatives(final RealMatrix nordsieckHistory) {\n-        return matNtoMWD.multiply(nordsieckHistory);\n+        return nordsieckToMultistep.multiply(nordsieckHistory);\n     }\n \n }\n--- a/src/test/org/apache/commons/math/ode/NordsieckTransformerTest.java\n+++ b/src/test/org/apache/commons/math/ode/NordsieckTransformerTest.java\n \n package org.apache.commons.math.ode;\n \n-import java.math.BigInteger;\n import java.util.Random;\n \n import junit.framework.Test;\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n     }\n \n     public void testDimension2() {\n-        NordsieckTransformer transformer = new NordsieckTransformer(2);\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 2, 0, 0);\n         double[] nordsieckHistory = new double[] { 1.0,  2.0 };\n-        double[] mwdHistory       = new double[] { 1.0, -1.0 };\n+        double[] multistepHistory = new double[] { 1.0, -1.0 };\n+        checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+        checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+    }\n+\n+    public void testDimension2Der() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 1, 0, 1);\n+        double[] nordsieckHistory = new double[] { 1.0,  2.0 };\n         double[] multistepHistory = new double[] { 1.0,  2.0 };\n-        checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n-        checkVector(mwdHistory, transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n         checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n         checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n     }\n \n     public void testDimension3() {\n-        NordsieckTransformer transformer = new NordsieckTransformer(3);\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 3, 0, 0);\n         double[] nordsieckHistory = new double[] { 1.0,  4.0, 18.0 };\n-        double[] mwdHistory       = new double[] { 1.0, 15.0, 65.0 };\n-        double[] multistepHistory = new double[] { 1.0,  4.0, 15.0 };\n-        checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n-        checkVector(mwdHistory, transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n+        double[] multistepHistory = new double[] { 1.0, 15.0, 65.0 };\n+        checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+        checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+    }\n+\n+    public void testDimension3Der() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 2, 0, 1);\n+        double[] nordsieckHistory = new double[] { 1.0,  4.0, 18.0 };\n+        double[] multistepHistory = new double[] { 1.0, 15.0,  4.0 };\n         checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n         checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n     }\n \n     public void testDimension7() {\n-        NordsieckTransformer transformer = new NordsieckTransformer(7);\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 7, 0, 0);\n         RealMatrix nordsieckHistory =\n             new RealMatrixImpl(new double[][] {\n                                    {  1,  2,  3 },\n                                    {  2,  0,  1 },\n                                    {  1,  1,  2 }\n                                 }, false);\n-        RealMatrix mwdHistory       =\n+        RealMatrix multistepHistory =\n             new RealMatrixImpl(new double[][] {\n                                    {     1,     2,     3 },\n                                    {     4,     3,     6 },\n                                    { 10036, 15147, 29278 },\n                                    { 32449, 45608, 87951 }\n                                }, false);\n+\n+        RealMatrix m = transformer.multistepToNordsieck(multistepHistory);\n+        assertEquals(0.0, m.subtract(nordsieckHistory).getNorm(), 1.0e-11);\n+        m = transformer.nordsieckToMultistep(nordsieckHistory);\n+        assertEquals(0.0, m.subtract(multistepHistory).getNorm(), 1.0e-11);\n+\n+    }\n+\n+    public void testDimension7Der() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(0, 6, 0, 1);\n+        RealMatrix nordsieckHistory =\n+            new RealMatrixImpl(new double[][] {\n+                                   {  1,  2,  3 },\n+                                   { -2,  1,  0 },\n+                                   {  1,  1,  1 },\n+                                   {  0, -1,  1 },\n+                                   {  1, -1,  2 },\n+                                   {  2,  0,  1 },\n+                                   {  1,  1,  2 }\n+                                }, false);\n         RealMatrix multistepHistory =\n             new RealMatrixImpl(new double[][] {\n                                    {     1,     2,     3 },\n-                                   {    -2,     1,     0 },\n                                    {     4,     3,     6 },\n                                    {    25,    60,   127 },\n                                    {   340,   683,  1362 },\n                                    {  2329,  3918,  7635 },\n-                                   { 10036, 15147, 29278 }\n+                                   { 10036, 15147, 29278 },\n+                                   {    -2,     1,     0 }\n                                }, false);\n \n-        RealMatrix m = transformer.multistepWithoutDerivativesToNordsieck(mwdHistory);\n-        assertEquals(0.0, m.subtract(nordsieckHistory).getNorm(), 1.0e-11);\n-        m = transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory);\n-        assertEquals(0.0, m.subtract(mwdHistory).getNorm(), 1.0e-11);\n-        m = transformer.multistepToNordsieck(multistepHistory);\n+        RealMatrix m = transformer.multistepToNordsieck(multistepHistory);\n         assertEquals(0.0, m.subtract(nordsieckHistory).getNorm(), 1.0e-11);\n         m = transformer.nordsieckToMultistep(nordsieckHistory);\n         assertEquals(0.0, m.subtract(multistepHistory).getNorm(), 1.0e-11);\n \n     }\n \n-    public void testInverseWithoutDerivatives() {\n-        for (int n = 1; n < 20; ++n) {\n-            BigInteger[][] nTom =\n-                NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(n);\n-            BigFraction[][] mTon =\n-                NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(n);\n-            for (int i = 0; i < n; ++i) {\n-                for (int j = 0; j < n; ++j) {\n-                    BigFraction s = BigFraction.ZERO;\n-                    for (int k = 0; k < n; ++k) {\n-                        s = s.add(mTon[i][k].multiply(nTom[k][j]));\n-                    }\n-                    assertEquals((i == j) ? BigFraction.ONE : BigFraction.ZERO, s);\n-                }\n-            }\n-        }\n-    }\n-\n-    public void testInverse() {\n-        for (int n = 1; n < 20; ++n) {\n-            BigInteger[][] nTom =\n-                NordsieckTransformer.buildNordsieckToMultistep(n);\n-            BigFraction[][] mTon =\n-                NordsieckTransformer.buildMultistepToNordsieck(n);\n-            for (int i = 0; i < n; ++i) {\n-                for (int j = 0; j < n; ++j) {\n-                    BigFraction s = BigFraction.ZERO;\n-                    for (int k = 0; k < n; ++k) {\n-                        s = s.add(mTon[i][k].multiply(nTom[k][j]));\n-                    }\n-                    assertEquals((i == j) ? BigFraction.ONE : BigFraction.ZERO, s);\n-                }\n-            }\n-        }\n-    }\n-\n     public void testMatrices1() {\n         checkMatrix(1, new int[][] { { 1 } },\n-                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(1));\n-        checkMatrix(new int[][] { { 1 } },\n-                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(1));\n-        checkMatrix(1, new int[][] { { 1 } },\n-                    NordsieckTransformer.buildMultistepToNordsieck(1));\n-        checkMatrix(new int[][] { { 1 } },\n-                    NordsieckTransformer.buildNordsieckToMultistep(1));\n+                    NordsieckTransformer.buildNordsieckToMultistep(0, 1, 0, 0));\n     }\n \n     public void testMatrices2() {\n         checkMatrix(1, new int[][] { { 1, 0 }, { 1, -1 } },\n-                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(2));\n-        checkMatrix(new int[][] { { 1, 0 }, { 1, -1 } },\n-                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(2));\n-        checkMatrix(1, new int[][] { { 1, 0 }, { 0, 1 } },\n-                    NordsieckTransformer.buildMultistepToNordsieck(2));\n-        checkMatrix(new int[][] { { 1, 0 }, { 0, 1 } },\n-                    NordsieckTransformer.buildNordsieckToMultistep(2));\n+                    NordsieckTransformer.buildNordsieckToMultistep(0, 2, 0, 0));\n     }\n \n     public void testMatrices3() {\n-        checkMatrix(2, new int[][] { { 2, 0, 0 }, { 3, -4, 1 }, { 1, -2, 1 } },\n-                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(3));\n-        checkMatrix(new int[][] { { 1, 0, 0 }, { 1, -1, 1 }, { 1, -2, 4 } },\n-                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(3));\n-        checkMatrix(1, new int[][] { { 1, 0, 0 }, { 0, 1, 0 }, { -1, 1, 1} },\n-                    NordsieckTransformer.buildMultistepToNordsieck(3));\n-        checkMatrix(new int[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 1, -1, 1 } },\n-                    NordsieckTransformer.buildNordsieckToMultistep(3));\n+        checkMatrix(1, new int[][] { { 1, 0, 0 }, { 1, -1, 1 }, { 1, -2, 4 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(0, 3, 0, 0));\n     }\n \n     public void testMatrices4() {\n-        checkMatrix(6, new int[][] { { 6, 0, 0, 0 }, { 11, -18, 9, -2 }, { 6, -15, 12, -3 }, { 1, -3, 3, -1 } },\n-                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(4));\n-        checkMatrix(new int[][] { { 1, 0, 0, 0 }, { 1, -1, 1, -1 }, { 1, -2, 4, -8 }, { 1, -3, 9, -27 } },\n-                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(4));\n-        checkMatrix(4, new int[][] { { 4, 0, 0, 0 }, { 0, 4, 0, 0 }, { -7, 6, 8, -1 }, { -3, 2, 4, -1 } },\n-                    NordsieckTransformer.buildMultistepToNordsieck(4));\n-        checkMatrix(new int[][] { { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 1, -1, 1, -1 }, { 1, -2, 4, -8 } },\n-                    NordsieckTransformer.buildNordsieckToMultistep(4));\n+        checkMatrix(1, new int[][] { { 1, 0, 0, 0 }, { 1, -1, 1, -1 }, { 1, -2, 4, -8 }, { 1, -3, 9, -27 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(0, 4, 0, 0));\n     }\n \n     public void testPolynomial() {\n-        Random r = new Random(1847222905841997856l);\n-        for (int n = 2; n < 9; ++n) {\n-\n-            // build a polynomial and its derivatives\n-            double[] coeffs = new double[n + 1];\n-            for (int i = 0; i < n; ++i) {\n-                coeffs[i] = 2 * r.nextDouble() - 1.0;\n+        Random random = new Random(1847222905841997856l);\n+        for (int n = 2; n < 10; ++n) {\n+            for (int m = 0; m < 10; ++m) {\n+\n+                // choose p, q, r, s\n+                int qMinusP = 1 + random.nextInt(n);\n+                int sMinusR = n - qMinusP;\n+                int p       = random.nextInt(5) - 2; // possible values: -2, -1, 0, 1, 2\n+                int q       = p + qMinusP;\n+                int r       = random.nextInt(5) - 2; // possible values: -2, -1, 0, 1, 2\n+                int s       = r + sMinusR;\n+\n+                // build a polynomial and its derivatives\n+                double[] coeffs = new double[n + 1];\n+                for (int i = 0; i < n; ++i) {\n+                    coeffs[i] = 2.0 * random.nextDouble() - 1.0;\n+                }\n+                PolynomialFunction[] polynomials = new PolynomialFunction[n];\n+                polynomials[0] = new PolynomialFunction(coeffs);\n+                for (int i = 1; i < polynomials.length; ++i) {\n+                    polynomials[i] = (PolynomialFunction) polynomials[i - 1].derivative();\n+                }\n+\n+                double x = 0.75;\n+                double h = 0.01;\n+\n+                // build a state history in multistep form\n+                double[] multistepHistory = new double[n];\n+                for (int k = p; k < q; ++k) {\n+                    multistepHistory[k-p] = polynomials[0].value(x - k * h);\n+                }\n+                for (int k = r; k < s; ++k) {\n+                    multistepHistory[k + qMinusP - r] = h * polynomials[1].value(x - k * h);\n+                }\n+\n+                // build the same state history in Nordsieck form\n+                double[] nordsieckHistory = new double[n];\n+                double scale = 1.0;\n+                for (int i = 0; i < nordsieckHistory.length; ++i) {\n+                    nordsieckHistory[i] = scale * polynomials[i].value(x);\n+                    scale *= h / (i + 1);\n+                }\n+\n+                // check the transform is exact for these polynomials states\n+                NordsieckTransformer transformer = new NordsieckTransformer(p, q, r, s);\n+                checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+                checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+\n             }\n-            PolynomialFunction[] polynomials = new PolynomialFunction[n];\n-            polynomials[0] = new PolynomialFunction(coeffs);\n-            for (int k = 1; k < polynomials.length; ++k) {\n-                polynomials[k] = (PolynomialFunction) polynomials[k - 1].derivative();\n-            }\n-            double h = 0.01;\n-\n-            // build a state history in multistep form\n-            double[] multistepHistory = new double[n];\n-            multistepHistory[0] = polynomials[0].value(1.0);\n-            multistepHistory[1] = h * polynomials[1].value(1.0);\n-            for (int i = 2; i < multistepHistory.length; ++i) {\n-                multistepHistory[i] = polynomials[0].value(1.0 - (i - 1) * h);\n-            }\n-\n-            // build the same state history in multistep without derivatives form\n-            double[] mwdHistory = new double[n];\n-            for (int i = 0; i < multistepHistory.length; ++i) {\n-                mwdHistory[i] = polynomials[0].value(1.0 - i * h);\n-            }\n-\n-            // build the same state history in Nordsieck form\n-            double[] nordsieckHistory = new double[n];\n-            double scale = 1.0;\n-            for (int i = 0; i < nordsieckHistory.length; ++i) {\n-                nordsieckHistory[i] = scale * polynomials[i].value(1.0);\n-                scale *= h / (i + 1);\n-            }\n-\n-            // check the transform is exact for these polynomials states\n-            NordsieckTransformer transformer = new NordsieckTransformer(n);\n-            checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n-            checkVector(mwdHistory,       transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n-            checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n-            checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n-\n         }\n     }\n \n     private void checkVector(double[] reference, double[] candidate) {\n         assertEquals(reference.length, candidate.length);\n         for (int i = 0; i < reference.length; ++i) {\n-            assertEquals(reference[i], candidate[i], 1.0e-14);\n+            assertEquals(reference[i], candidate[i], 2.0e-12);\n         }\n     }\n \n-    private void checkMatrix(int[][] reference, BigInteger[][] candidate) {\n-        assertEquals(reference.length, candidate.length);\n+    private void checkMatrix(int denominator, int[][] reference, FieldMatrix<BigFraction> candidate) {\n+        assertEquals(reference.length, candidate.getRowDimension());\n         for (int i = 0; i < reference.length; ++i) {\n             int[] rRow = reference[i];\n-            BigInteger[] cRow = candidate[i];\n-            assertEquals(rRow.length, cRow.length);\n             for (int j = 0; j < rRow.length; ++j) {\n-                assertEquals(rRow[j], cRow[j].intValue());\n-            }\n-        }\n-    }\n-\n-    private void checkMatrix(int denominator, int[][] reference, BigFraction[][] candidate) {\n-        assertEquals(reference.length, candidate.length);\n-        for (int i = 0; i < reference.length; ++i) {\n-            int[] rRow = reference[i];\n-            BigFraction[] cRow = candidate[i];\n-            assertEquals(rRow.length, cRow.length);\n-            for (int j = 0; j < rRow.length; ++j) {\n-                assertEquals(new BigFraction(rRow[j], denominator), cRow[j]);\n+                assertEquals(new BigFraction(rRow[j], denominator), candidate.getEntry(i, j));\n             }\n         }\n     }", "timestamp": 1241093122, "metainfo": ""}