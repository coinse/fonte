{"sha": "3842ecf3762347198bbc933abadb73c21327ca0c", "log": "Added locale support to complex format.  Added test cases for specific locales. PR: 31325   ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n import java.text.NumberFormat;\n import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.util.Locale;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n  * can be configured.\n  *\n  * @author Apache Software Foundation\n- * @version $Revision: 1.9 $ $Date: 2004/06/23 16:26:16 $\n+ * @version $Revision: 1.10 $ $Date: 2004/09/21 04:45:55 $\n  */\n public class ComplexFormat extends Format implements Serializable {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = -6337346779577272306L;\n     \n-    /** The default complex format. */ \n-\tprivate static final ComplexFormat DEFAULT = new ComplexFormat();\n-\n     /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n     \n      * @return A formatted number in the form \"Re(c) + Im(c)i\"\n      */\n     public static String formatComplex( Complex c ) {\n-    \treturn DEFAULT.format( c );\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getInstance()} with the only customizing is the\n-     * maximum number of fraction digits, which is set to 2.  \n-     *\n-     * @return the default number format.\n-     */\n-    private static NumberFormat getDefaultNumberFormat() {\n-        NumberFormat nf = NumberFormat.getInstance();\n-        nf.setMaximumFractionDigits(2);\n-        return nf;\n+    \treturn getInstance().format( c );\n     }\n     \n     /**\n     }\n     \n     /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     * @return the default number format.\n+     */\n+    private static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 2.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n+        NumberFormat nf = NumberFormat.getInstance(locale);\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+    \n+    /**\n      * Access the imaginaryCharacter.\n      * @return the imaginaryCharacter.\n      */\n      */\n     public NumberFormat getImaginaryFormat() {\n         return imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static ComplexFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static ComplexFormat getInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new ComplexFormat(f);\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/complex/AbstractComplexFormatTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public abstract class AbstractComplexFormatTest extends TestCase {\n+ \n+\tComplexFormat complexFormat = null;\n+\tComplexFormat complexFormatJ = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+    \n+\tprotected void setUp() throws Exception {\n+\t\tcomplexFormat = ComplexFormat.getInstance(getLocale());\n+\t\tcomplexFormatJ = ComplexFormat.getInstance(getLocale());\n+        complexFormatJ.setImaginaryCharacter(\"j\");\n+\t}\n+   \n+    public void testSimpleNoDecimals() {\n+        Complex c = new Complex(1, 1);\n+        String expected = \"1 + 1i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+\tpublic void testSimpleWithDecimals() {\n+\t\tComplex c = new Complex(1.23, 1.43);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testSimpleWithDecimalsTrunc() {\n+\t\tComplex c = new Complex(1.2323, 1.4343);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testNegativeReal() {\n+\t\tComplex c = new Complex(-1.2323, 1.4343);\n+        String expected = \"-1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testNegativeImaginary() {\n+\t\tComplex c = new Complex(1.2323, -1.4343);\n+        String expected = \"1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testNegativeBoth() {\n+\t\tComplex c = new Complex(-1.2323, -1.4343);\n+        String expected = \"-1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testZeroReal() {\n+\t\tComplex c = new Complex(0.0, -1.4343);\n+        String expected = \"0 - 1\" + getDecimalCharacter() + \"43i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testZeroImaginary() {\n+\t\tComplex c = new Complex(30.233, 0);\n+        String expected = \"30\" + getDecimalCharacter() + \"23\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testDifferentImaginaryChar() {\n+\t\tComplex c = new Complex(1, 1);\n+        String expected = \"1 + 1j\";\n+        String actual = complexFormatJ.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\t\n+\tpublic void testStaticFormatComplex() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+\t\tComplex c = new Complex(232.222, -342.33);\n+        String expected = \"232\" + getDecimalCharacter() + \"22 - 342\" + getDecimalCharacter() + \"33i\";\n+        String actual = ComplexFormat.formatComplex(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+\t}\n+\n+\tpublic void testNan() {\n+\t\tComplex c = new Complex(Double.NaN, Double.NaN);\n+        String expected = \"(NaN) + (NaN)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testPositiveInfinity() {\n+\t\tComplex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        String expected = \"(Infinity) + (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testNegativeInfinity() {\n+\t\tComplex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        String expected = \"(-Infinity) - (Infinity)i\";\n+        String actual = complexFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+    \n+    public void testParseSimpleNoDecimals() {\n+        String source = \"1 + 1i\";\n+        Complex expected = new Complex(1, 1);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n+        Complex expected = new Complex(1.23, 1.43);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source = \"1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeReal() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(-1.2323, 1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeImaginary() {\n+        String source = \"1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeBoth() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroReal() {\n+        String source = \"0\" + getDecimalCharacter() + \"0 - 1\" + getDecimalCharacter() + \"4343i\";\n+        Complex expected = new Complex(0.0, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroImaginary() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323\";\n+        Complex expected = new Complex(-1.2323, 0);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseDifferentImaginaryChar() {\n+        String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343j\";\n+        Complex expected = new Complex(-1.2323, -1.4343);\n+        try {\n+            Complex actual = (Complex)complexFormatJ.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"(NaN) + (NaN)i\";\n+        Complex expected = new Complex(Double.NaN, Double.NaN);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"(Infinity) + (Infinity)i\";\n+        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testPaseNegativeInfinity() {\n+        String source = \"(-Infinity) - (Infinity)i\";\n+        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        try {\n+            Complex actual = (Complex)complexFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testGetImaginaryFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getImaginaryFormat());\n+        cf.setImaginaryFormat(nf);\n+        assertSame(nf, cf.getImaginaryFormat());\n+    }\n+    \n+    public void testSetImaginaryFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetRealFormatNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setRealFormat(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testGetRealFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        ComplexFormat cf = new ComplexFormat();\n+        \n+        assertNotSame(nf, cf.getRealFormat());\n+        cf.setRealFormat(nf);\n+        assertSame(nf, cf.getRealFormat());\n+    }\n+    \n+    public void testSetImaginaryCharacterNull() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetImaginaryCharacterEmpty() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            cf.setImaginaryCharacter(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testFormatNumber() {\n+        ComplexFormat cf = ComplexFormat.getInstance(getLocale());\n+        Double pi = new Double(Math.PI);\n+        String text = cf.format(pi);\n+        assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            ComplexFormat cf = new ComplexFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchComplexFormatTest extends AbstractComplexFormatTest {\n+    \n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}", "timestamp": 1095741955, "metainfo": ""}