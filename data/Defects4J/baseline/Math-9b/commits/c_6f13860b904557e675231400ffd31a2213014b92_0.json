{"sha": "6f13860b904557e675231400ffd31a2213014b92", "log": "Created Decimal64, a wrapper class around the primitive double type. This class implements FieldElement<Decimal64>. See MATH-756.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.util;\n+\n+import org.apache.commons.math3.Field;\n+import org.apache.commons.math3.FieldElement;\n+\n+/**\n+ * This class wraps a {@code double} value in an object. It is similar to the\n+ * standard class {@link Double}, while also implementing the\n+ * {@link FieldElement} interface.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class Decimal64 extends Number implements FieldElement<Decimal64>,\n+Comparable<Decimal64> {\n+\n+    /** The constant value of {@code 0d} as a {@code Decimal64}. */\n+    public static final Decimal64 ZERO;\n+\n+    /** The constant value of {@code 1d} as a {@code Decimal64}. */\n+    public static final Decimal64 ONE;\n+\n+    /**\n+     * The constant value of {@link Double#NEGATIVE_INFINITY} as a\n+     * {@code Decimal64}.\n+     */\n+    public static final Decimal64 NEGATIVE_INFINITY;\n+\n+    /**\n+     * The constant value of {@link Double#POSITIVE_INFINITY} as a\n+     * {@code Decimal64}.\n+     */\n+    public static final Decimal64 POSITIVE_INFINITY;\n+\n+    /** The constant value of {@link Double#NaN} as a {@code Decimal64}. */\n+    public static final Decimal64 NAN;\n+\n+    /** */\n+    private static final long serialVersionUID = 20120227L;\n+\n+    static {\n+        ZERO = new Decimal64(0d);\n+        ONE = new Decimal64(1d);\n+        NEGATIVE_INFINITY = new Decimal64(Double.NEGATIVE_INFINITY);\n+        POSITIVE_INFINITY = new Decimal64(Double.POSITIVE_INFINITY);\n+        NAN = new Decimal64(Double.NaN);\n+    }\n+\n+    /** The primitive {@code double} value of this object. */\n+    private final double value;\n+\n+    /**\n+     * Creates a new instance of this class.\n+     *\n+     * @param x the primitive {@code double} value of the object to be created\n+     */\n+    public Decimal64(final double x) {\n+        this.value = x;\n+    }\n+\n+    /*\n+     * Methods from the FieldElement interface.\n+     */\n+\n+    /** {@inheritDoc} */\n+    public Field<Decimal64> getField() {\n+        return Decimal64Field.getInstance();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.add(a).equals(new Decimal64(this.doubleValue()\n+     * + a.doubleValue()))}.\n+     */\n+    public Decimal64 add(final Decimal64 a) {\n+        return new Decimal64(this.value + a.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.subtract(a).equals(new Decimal64(this.doubleValue()\n+     * - a.doubleValue()))}.\n+     */\n+    public Decimal64 subtract(final Decimal64 a) {\n+        return new Decimal64(this.value - a.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.negate().equals(new Decimal64(-this.doubleValue()))}.\n+     */\n+    public Decimal64 negate() {\n+        return new Decimal64(-this.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.multiply(a).equals(new Decimal64(this.doubleValue()\n+     * * a.doubleValue()))}.\n+     */\n+    public Decimal64 multiply(final Decimal64 a) {\n+        return new Decimal64(this.value * a.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.multiply(n).equals(new Decimal64(n * this.doubleValue()))}.\n+     */\n+    public Decimal64 multiply(final int n) {\n+        return new Decimal64(n * this.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.divide(a).equals(new Decimal64(this.doubleValue()\n+     * / a.doubleValue()))}.\n+     *\n+     */\n+    public Decimal64 divide(final Decimal64 a) {\n+        return new Decimal64(this.value / a.value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation strictly enforces\n+     * {@code this.reciprocal().equals(new Decimal64(1.0\n+     * / this.doubleValue()))}.\n+     */\n+    public Decimal64 reciprocal() {\n+        return new Decimal64(1.0 / this.value);\n+    }\n+\n+    /*\n+     * Methods from the Number abstract class\n+     */\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation performs casting to a {@code byte}.\n+     */\n+    @Override\n+    public byte byteValue() {\n+        return (byte) value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation performs casting to a {@code short}.\n+     */\n+    @Override\n+    public short shortValue() {\n+        return (short) value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation performs casting to a {@code int}.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation performs casting to a {@code long}.\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation performs casting to a {@code float}.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return (float) value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    /*\n+     * Methods from the Comparable interface.\n+     */\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation returns the same value as\n+     * <center> {@code new Double(this.doubleValue()).compareTo(new\n+     * Double(o.doubleValue()))} </center>\n+     *\n+     * @see Double#compareTo(Double)\n+     */\n+    public int compareTo(final Decimal64 o) {\n+        return Double.compare(this.value, o.value);\n+    }\n+\n+    /*\n+     * Methods from the Object abstract class.\n+     */\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj instanceof Decimal64) {\n+            final Decimal64 that = (Decimal64) obj;\n+            return Double.doubleToLongBits(this.value) == Double\n+                    .doubleToLongBits(that.value);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The current implementation returns the same value as\n+     * {@code new Double(this.doubleValue()).hashCode()}\n+     *\n+     * @see Double#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        long v = Double.doubleToLongBits(value);\n+        return (int) (v ^ (v >>> 32));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The returned {@code String} is equal to\n+     * {@code Double.toString(this.doubleValue())}\n+     *\n+     * @see Double#toString(double)\n+     */\n+    @Override\n+    public String toString() {\n+        return Double.toString(value);\n+    }\n+\n+    /*\n+     * Methods inspired by the Double class.\n+     */\n+\n+    /**\n+     * Returns {@code true} if {@code this} double precision number is infinite\n+     * ({@link Double#POSITIVE_INFINITY} or {@link Double#NEGATIVE_INFINITY}).\n+     *\n+     * @return {@code true} if {@code this} number is infinite\n+     */\n+    public boolean isInfinite() {\n+        return Double.isInfinite(value);\n+    }\n+\n+    /**\n+     * Returns {@code true} if {@code this} double precision number is\n+     * Not-a-Number ({@code NaN}), false otherwise.\n+     *\n+     * @return {@code true} if {@code this} is {@code NaN}\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64Field.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.util;\n+\n+import org.apache.commons.math3.Field;\n+import org.apache.commons.math3.FieldElement;\n+\n+/**\n+ * The field of double precision floating-point numbers.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ * @see Decimal64\n+ */\n+public class Decimal64Field implements Field<Decimal64> {\n+\n+    /** The unique instance of this class. */\n+    private static final Decimal64Field INSTANCE = new Decimal64Field();\n+\n+    /** Default constructor. */\n+    private Decimal64Field() {\n+        // Do nothing\n+    }\n+\n+    /**\n+     * Returns the unique instance of this class.\n+     *\n+     * @return the unique instance of this class\n+     */\n+    public static final Decimal64Field getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 getZero() {\n+        return Decimal64.ZERO;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Decimal64 getOne() {\n+        return Decimal64.ONE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<Decimal64>> getRuntimeClass() {\n+        return Decimal64.class;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/util/Decimal64Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.util;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+public class Decimal64Test {\n+    public static final double X = 1.2345;\n+\n+    public static final Decimal64 PLUS_X = new Decimal64(X);\n+\n+    public static final Decimal64 MINUS_X = new Decimal64(-X);\n+\n+    public static final double Y = 6.789;\n+\n+    public static final Decimal64 PLUS_Y = new Decimal64(Y);\n+\n+    public static final Decimal64 MINUS_Y = new Decimal64(-Y);\n+\n+    public static final Decimal64 PLUS_ZERO = new Decimal64(0.0);\n+\n+    public static final Decimal64 MINUS_ZERO = new Decimal64(-0.0);\n+\n+    @Test\n+    public void testAdd() {\n+        Decimal64 expected, actual;\n+\n+        expected = new Decimal64(X + Y);\n+        actual = PLUS_X.add(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_Y.add(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64(X + (-Y));\n+        actual = PLUS_X.add(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_Y.add(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) + (-Y));\n+        actual = MINUS_X.add(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_Y.add(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.POSITIVE_INFINITY;\n+        actual = PLUS_X.add(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.add(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.add(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.add(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NEGATIVE_INFINITY;\n+        actual = PLUS_X.add(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.add(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.add(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.add(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NAN;\n+        actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.add(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.add(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.add(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.add(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.add(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.add(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.add(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        Decimal64 expected, actual;\n+\n+        expected = new Decimal64(X - Y);\n+        actual = PLUS_X.subtract(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64(X - (-Y));\n+        actual = PLUS_X.subtract(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) - Y);\n+        actual = MINUS_X.subtract(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) - (-Y));\n+        actual = MINUS_X.subtract(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NEGATIVE_INFINITY;\n+        actual = PLUS_X.subtract(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.subtract(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .subtract(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.POSITIVE_INFINITY;\n+        actual = PLUS_X.subtract(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.subtract(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .subtract(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NAN;\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .subtract(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .subtract(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.subtract(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.subtract(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.subtract(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.subtract(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.subtract(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.subtract(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.subtract(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.subtract(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.subtract(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegate() {\n+        Decimal64 expected, actual;\n+\n+        expected = MINUS_X;\n+        actual = PLUS_X.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = PLUS_X;\n+        actual = MINUS_X.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = MINUS_ZERO;\n+        actual = PLUS_ZERO.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = PLUS_ZERO;\n+        actual = MINUS_ZERO.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.POSITIVE_INFINITY;\n+        actual = Decimal64.NEGATIVE_INFINITY.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NEGATIVE_INFINITY;\n+        actual = Decimal64.POSITIVE_INFINITY.negate();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NAN;\n+        actual = Decimal64.NAN.negate();\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testMultiply() {\n+        Decimal64 expected, actual;\n+\n+        expected = new Decimal64(X * Y);\n+        actual = PLUS_X.multiply(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_Y.multiply(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64(X * (-Y));\n+        actual = PLUS_X.multiply(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_Y.multiply(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) * (-Y));\n+        actual = MINUS_X.multiply(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_Y.multiply(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.POSITIVE_INFINITY;\n+        actual = PLUS_X.multiply(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.multiply(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.multiply(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.multiply(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .multiply(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .multiply(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NEGATIVE_INFINITY;\n+        actual = PLUS_X.multiply(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.multiply(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.multiply(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.multiply(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .multiply(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .multiply(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NAN;\n+        actual = PLUS_X.multiply(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.multiply(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.multiply(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.multiply(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.multiply(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.multiply(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.multiply(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.multiply(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.multiply(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testDivide() {\n+        Decimal64 expected, actual;\n+\n+        expected = new Decimal64(X / Y);\n+        actual = PLUS_X.divide(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64(X / (-Y));\n+        actual = PLUS_X.divide(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) / Y);\n+        actual = MINUS_X.divide(PLUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64((-X) / (-Y));\n+        actual = MINUS_X.divide(MINUS_Y);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = PLUS_ZERO;\n+        actual = PLUS_X.divide(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.divide(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = MINUS_ZERO;\n+        actual = MINUS_X.divide(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.divide(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.POSITIVE_INFINITY;\n+        actual = Decimal64.POSITIVE_INFINITY.divide(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.divide(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.divide(PLUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.divide(MINUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NEGATIVE_INFINITY;\n+        actual = Decimal64.POSITIVE_INFINITY.divide(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.divide(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.divide(MINUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.divide(PLUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = Decimal64.NAN;\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .divide(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY\n+                .divide(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .divide(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY\n+                .divide(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_X.divide(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.divide(PLUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_X.divide(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.divide(MINUS_X);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.POSITIVE_INFINITY.divide(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.divide(Decimal64.POSITIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NEGATIVE_INFINITY.divide(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.divide(Decimal64.NEGATIVE_INFINITY);\n+        Assert.assertEquals(expected, actual);\n+        actual = Decimal64.NAN.divide(Decimal64.NAN);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_ZERO.divide(PLUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+        actual = PLUS_ZERO.divide(MINUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_ZERO.divide(PLUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+        actual = MINUS_ZERO.divide(MINUS_ZERO);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testReciprocal() {\n+        Decimal64 expected, actual;\n+\n+        expected = new Decimal64(1.0 / X);\n+        actual = PLUS_X.reciprocal();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = new Decimal64(1.0 / (-X));\n+        actual = MINUS_X.reciprocal();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = PLUS_ZERO;\n+        actual = Decimal64.POSITIVE_INFINITY.reciprocal();\n+        Assert.assertEquals(expected, actual);\n+\n+        expected = MINUS_ZERO;\n+        actual = Decimal64.NEGATIVE_INFINITY.reciprocal();\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testIsInfinite() {\n+        Assert.assertFalse(MINUS_X.isInfinite());\n+        Assert.assertFalse(PLUS_X.isInfinite());\n+        Assert.assertFalse(MINUS_Y.isInfinite());\n+        Assert.assertFalse(PLUS_Y.isInfinite());\n+        Assert.assertFalse(Decimal64.NAN.isInfinite());\n+\n+        Assert.assertTrue(Decimal64.NEGATIVE_INFINITY.isInfinite());\n+        Assert.assertTrue(Decimal64.POSITIVE_INFINITY.isInfinite());\n+    }\n+\n+    @Test\n+    public void testIsNaN() {\n+        Assert.assertFalse(MINUS_X.isNaN());\n+        Assert.assertFalse(PLUS_X.isNaN());\n+        Assert.assertFalse(MINUS_Y.isNaN());\n+        Assert.assertFalse(PLUS_Y.isNaN());\n+        Assert.assertFalse(Decimal64.NEGATIVE_INFINITY.isNaN());\n+        Assert.assertFalse(Decimal64.POSITIVE_INFINITY.isNaN());\n+\n+        Assert.assertTrue(Decimal64.NAN.isNaN());\n+    }\n+}", "timestamp": 1332913246, "metainfo": ""}