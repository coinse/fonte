{"sha": "8df25775a59ddd77e909a37378ee459c502ab658", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=24241 Submitted by:\tBrent Worden   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Geronimo\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Geronimo\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ * ====================================================================\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+/**\n+ * Reference:\n+ *   http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/10/30 19:42:43 $\n+ */\n+public class Complex {\n+\n+    /** The square root of -1. */    \n+    public static final Complex I = new Complex(0.0, 1.0);\n+    \n+    /** */\n+    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n+\n+    /** 1. */    \n+    public static final Complex ONE = new Complex(1.0, 0.0);\n+    \n+    /** The imaginary part. */\n+    protected double imaginary;\n+    \n+    /** The real part. */\n+    protected double real;\n+    \n+    /**\n+     * Create a complex number given the real and imaginary parts.\n+     * @param real the real part.\n+     * @param imaginary the imaginary part.\n+     */\n+    public Complex(double real, double imaginary) {\n+        super();\n+        this.real = real;\n+        this.imaginary = imaginary;\n+    }\n+\n+    /**\n+     * Return the absolute value of this complex number.\n+     * @return the absolute value.\n+     */\n+    public double abs() {\n+        if (isNaN()) {\n+            return Double.NaN;\n+        }\n+        return Math.sqrt(squareSum());       \n+    }\n+    \n+    /**\n+     * Return the sum of this complex number and the given complex number.\n+     * @param rhs the other complex number.\n+     * @return the complex number sum.\n+     */\n+    public Complex add(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return new Complex(real + rhs.getReal(),\n+            imaginary + rhs.getImaginary());\n+    }\n+    \n+    /**\n+     * Return the conjugate of this complex number.\n+     * @return the conjugate.\n+     */\n+    public Complex conjugate() {\n+        if (isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return new Complex(real, -imaginary);\n+    }\n+    \n+    /**\n+     * Return the quotient of this complex number and the given complex number.\n+     * @param rhs the other complex number.\n+     * @return the complex number quotient.\n+     */\n+    public Complex divide(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        \n+        if (Math.abs(rhs.getReal()) < Math.abs(rhs.getImaginary())) {\n+            double q = rhs.getReal() / rhs.getImaginary();\n+            double d = (rhs.getReal() * q) + rhs.getImaginary();\n+            return new Complex(((real * q) + imaginary) / d,\n+                ((imaginary * q) - real) / d);\n+        } else {\n+            double q = rhs.getImaginary() / rhs.getReal();\n+            double d = (rhs.getImaginary() * q) + rhs.getReal();\n+            return new Complex(((imaginary * q) + real) / d,\n+                (imaginary - (real * q)) / d);\n+        }\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public boolean equals(Object other) {\n+        boolean ret;\n+        \n+        if (this == other) { \n+            ret = true;\n+        } else if (other == null) {\n+            ret = false;\n+        } else {\n+            try {\n+                Complex rhs = (Complex)other;\n+                ret = (Double.doubleToRawLongBits(real) ==\n+                        Double.doubleToRawLongBits(rhs.getReal())) &&\n+                    (Double.doubleToRawLongBits(imaginary) ==\n+                        Double.doubleToRawLongBits(rhs.getImaginary())); \n+            } catch (ClassCastException ex) {\n+                // ignore exception\n+                ret = false;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the imaginary part.\n+     * @return the imaginary part.\n+     */\n+    public double getImaginary() {\n+        return imaginary;\n+    }\n+\n+    /**\n+     * Access the real part.\n+     * @return the real part.\n+     */\n+    public double getReal() {\n+        return real;\n+    }\n+    \n+    /**\n+     * Returns true if this complex number is the special Not-a-Number (NaN)\n+     * value.\n+     * @return true if the value represented by this object is NaN; false\n+     *         otherwise.\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(real) || Double.isNaN(imaginary);        \n+    }\n+    \n+    /**\n+     * Return the product of this complex number and the given complex number.\n+     * @param rhs the other complex number.\n+     * @return the complex number product.\n+     */\n+    public Complex multiply(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        \n+        double p = (real + imaginary) * (rhs.getReal() + rhs.getImaginary());\n+        double ac = real * rhs.getReal();\n+        double bd = imaginary * rhs.getImaginary();\n+        return new Complex(ac - bd, p - ac - bd);\n+    }\n+    \n+    /**\n+     * Return the additive inverse of this complex number.\n+     * @return the negation of this complex number.\n+     */\n+    public Complex negate() {\n+        if (isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return new Complex(-real, -imaginary);\n+    }\n+    \n+    /**\n+     * Return the sum of the squared terms.\n+     * @return the square sum.\n+     */\n+    private double squareSum() {\n+        return real * real + imaginary * imaginary;\n+    }\n+    \n+    /**\n+     * Return the difference between this complex number and the given complex\n+     * number.\n+     * @param rhs the other complex number.\n+     * @return the complex number difference.\n+     */\n+    public Complex subtract(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return new Complex(real - rhs.getReal(),\n+            imaginary - rhs.getImaginary());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/complex/ComplexMath.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Geronimo\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Geronimo\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ * ====================================================================\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Reference:\n+ *   http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/10/30 19:42:43 $\n+ */\n+public class ComplexMath {\n+    \n+    /**\n+     * \n+     */\n+    private ComplexMath() {\n+        super();\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex acos(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return Complex.I.negate().multiply(log(z.add(\n+            Complex.I.multiply(sqrt1z(z)))));       \n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex asin(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return Complex.I.negate().multiply(log(sqrt1z(z).add(\n+            Complex.I.multiply(z))));       \n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex atan(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return Complex.I.multiply(\n+            log(Complex.I.add(z).divide(Complex.I.subtract(z))))\n+            .multiply(new Complex(2.0, 0.0));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex cos(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(Math.cos(a) * MathUtils.cosh(b),\n+            -Math.sin(a) * MathUtils.sinh(b));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex cosh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(MathUtils.cosh(a) * Math.cos(b),\n+            MathUtils.sinh(a) * Math.sin(b));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex exp(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double b = z.getImaginary();\n+        double expA = Math.exp(z.getReal());\n+        double sinB = Math.sin(b);\n+        double cosB = Math.cos(b);\n+        return new Complex(expA * cosB, expA * sinB);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex log(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return new Complex(Math.log(z.abs()),\n+            Math.atan2(z.getImaginary(), z.getReal()));        \n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex pow(Complex y, Complex x) {\n+        return exp(x.multiply(log(y)));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex sin(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(Math.sin(a) * MathUtils.cosh(b),\n+            Math.cos(a) * MathUtils.sinh(b));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex sinh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(MathUtils.sinh(a) * Math.cos(b),\n+            MathUtils.cosh(a) * Math.sin(b));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex sqrt(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        double t = Math.sqrt((Math.abs(a) + z.abs()) / 2.0);\n+        if (a >= 0.0) {\n+            return new Complex(t, b / (2.0 * t));\n+        } else {\n+            double s = (b > 0.0 ? 1.0 : (b < 0.0 ? -1.0 : 0.0));\n+            return new Complex(Math.abs(z.getImaginary()) / (2.0 * t), s * t);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the square root of 1 - z^2.\n+     * @return the square root of 1 - z^2.\n+     */\n+    public static Complex sqrt1z(Complex z) {\n+        return sqrt(Complex.ONE.subtract(z.multiply(z)));\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex tan(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a2 = 2.0 * z.getReal();\n+        double b2 = 2.0 * z.getImaginary();\n+        double d = Math.cos(a2) + MathUtils.cosh(b2);\n+        \n+        return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / 2);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static Complex tanh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a2 = 2.0 * z.getReal();\n+        double b2 = 2.0 * z.getImaginary();\n+        double d = MathUtils.cosh(a2) + Math.cos(b2);\n+        \n+        return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / 2);\n+    }\n+}\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n  *\n- * @version $Revision: 1.6 $ $Date: 2003/10/16 15:24:30 $\n+ * @version $Revision: 1.7 $ $Date: 2003/10/30 19:42:43 $\n  */\n public final class MathUtils {\n \n         }\n         return logSum;\n     }\n+    \n+    /**\n+     * \n+     */\n+    public static double cosh(double x) {\n+        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public static double sinh(double x) {\n+        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Geronimo\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Geronimo\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ * ====================================================================\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2003/10/30 19:42:43 $\n+ */\n+public class ComplexTest extends TestCase {\n+    \n+    public void testConstructor() {\n+        Complex z = new Complex(3.0, 4.0);\n+        assertEquals(3.0, z.getReal(), 1.0e-5);\n+        assertEquals(4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testConstructorNaN() {\n+        Complex z = new Complex(3.0, Double.NaN);\n+        assertTrue(z.isNaN());\n+\n+        z = new Complex(Double.NaN, 4.0);\n+        assertTrue(z.isNaN());\n+\n+        z = new Complex(3.0, 4.0);\n+        assertFalse(z.isNaN());\n+    }\n+    \n+    public void testAbs() {\n+        Complex z = new Complex(3.0, 4.0);\n+        assertEquals(5.0, z.abs(), 1.0e-5);\n+    }\n+    \n+    public void testAdd() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.add(y);\n+        assertEquals(8.0, z.getReal(), 1.0e-5);\n+        assertEquals(10.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testAddNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.add(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testConjugate() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.conjugate();\n+        assertEquals(3.0, z.getReal(), 1.0e-5);\n+        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testConjugateNaN() {\n+        Complex z = Complex.NaN.conjugate();\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testDivide() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.divide(y);\n+        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n+        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testDivideNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.divide(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testMultiply() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.multiply(y);\n+        assertEquals(-9.0, z.getReal(), 1.0e-5);\n+        assertEquals(38.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testMultiplyNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.multiply(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testNegate() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.negate();\n+        assertEquals(-3.0, z.getReal(), 1.0e-5);\n+        assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testNegateNaN() {\n+        Complex z = Complex.NaN.negate();\n+        assertTrue(z.isNaN());\n+    }\n+    \n+    public void testSubtract() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(5.0, 6.0);\n+        Complex z = x.subtract(y);\n+        assertEquals(-2.0, z.getReal(), 1.0e-5);\n+        assertEquals(-2.0, z.getImaginary(), 1.0e-5);\n+    }\n+    \n+    public void testSubtractNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex z = x.subtract(Complex.NaN);\n+        assertTrue(z.isNaN());\n+    }\n+}", "timestamp": 1067542963, "metainfo": ""}