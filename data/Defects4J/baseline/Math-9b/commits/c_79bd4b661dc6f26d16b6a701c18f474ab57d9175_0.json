{"sha": "79bd4b661dc6f26d16b6a701c18f474ab57d9175", "log": "Coding style changes to match the rest of [math].  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.complex.ComplexUtils;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n public class LaguerreSolver extends UnivariateRealSolverImpl {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = 5287689975005870178L;\n+    private static final long serialVersionUID = 5287689975005870178L;\n \n     /** polynomial function to solve */\n     private PolynomialFunction p;\n     public double solve(double min, double max) throws ConvergenceException, \n         FunctionEvaluationException {\n \n-        Complex c[], root[], initial, z;\n-\n         // check for zeros before verifying bracketing\n         if (p.value(min) == 0.0) { return min; }\n         if (p.value(max) == 0.0) { return max; }\n         verifyBracketing(min, max, p);\n \n         double coefficients[] = p.getCoefficients();\n-        c = new Complex[coefficients.length];\n+        Complex c[] = new Complex[coefficients.length];\n         for (int i = 0; i < coefficients.length; i++) {\n             c[i] = new Complex(coefficients[i], 0.0);\n         }\n-        initial = new Complex(0.5 * (min + max), 0.0);\n-        z = solve(c, initial);\n+        Complex initial = new Complex(0.5 * (min + max), 0.0);\n+        Complex z = solve(c, initial);\n         if (isRootOK(min, max, z)) {\n             setResult(z.getReal(), iterationCount);\n             return result;\n         }\n \n         // solve all roots and select the one we're seeking\n-        root = solveAll(c, initial);\n+        Complex[] root = solveAll(c, initial);\n         for (int i = 0; i < root.length; i++) {\n             if (isRootOK(min, max, root[i])) {\n                 setResult(root[i].getReal(), iterationCount);\n     public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n         ConvergenceException, FunctionEvaluationException {\n \n-        int i, j, n, iterationCount = 0;\n-        Complex root[], c[], subarray[], oldc, newc;\n-\n-        n = coefficients.length - 1;\n+        int n = coefficients.length - 1;\n+        int iterationCount = 0;\n         if (n < 1) {\n             throw new IllegalArgumentException\n                 (\"Polynomial degree must be positive: degree=\" + n);\n         }\n-        c = new Complex[n+1];    // coefficients for deflated polynomial\n-        for (i = 0; i <= n; i++) {\n+        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n+        for (int i = 0; i <= n; i++) {\n             c[i] = coefficients[i];\n         }\n \n         // solve individual root successively\n-        root = new Complex[n];\n-        for (i = 0; i < n; i++) {\n-            subarray = new Complex[n-i+1];\n+        Complex root[] = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            Complex subarray[] = new Complex[n-i+1];\n             System.arraycopy(c, 0, subarray, 0, subarray.length);\n             root[i] = solve(subarray, initial);\n             // polynomial deflation using synthetic division\n-            newc = c[n-i];\n-            for (j = n-i-1; j >= 0; j--) {\n+            Complex newc = c[n-i];\n+            Complex oldc = null;\n+            for (int j = n-i-1; j >= 0; j--) {\n                 oldc = c[j];\n                 c[j] = newc;\n                 newc = oldc.add(newc.multiply(root[i]));\n      */\n     public Complex solve(Complex coefficients[], Complex initial) throws\n         ConvergenceException, FunctionEvaluationException {\n-\n-        Complex z = initial, oldz, pv, dv, d2v, G, G2, H, delta, denominator;\n \n         int n = coefficients.length - 1;\n         if (n < 1) {\n         Complex N1 = new Complex((double)(n-1), 0.0);\n \n         int i = 1;\n-        oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        Complex pv = null;\n+        Complex dv = null;\n+        Complex d2v = null;\n+        Complex G = null;\n+        Complex G2 = null;\n+        Complex H = null;\n+        Complex delta = null;\n+        Complex denominator = null;\n+        Complex z = initial;\n+        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n         while (i <= maximalIterationCount) {\n             // Compute pv (polynomial value), dv (derivative value), and\n             // d2v (second derivative value) simultaneously.\n             pv = coefficients[n];\n-            dv = d2v = new Complex(0.0, 0.0);\n+            dv = Complex.ZERO;\n+            d2v = Complex.ZERO;\n             for (int j = n-1; j >= 0; j--) {\n                 d2v = dv.add(z.multiply(d2v));\n                 dv = pv.add(z.multiply(dv));", "timestamp": 1135637637, "metainfo": ""}