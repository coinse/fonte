{"sha": "2682318774755c4bcca241d9e1af8cbb65df12b1", "log": "MATH-854: populated throws clause of BlockFieldMatrix.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n \n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     */\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n-        throws DimensionMismatchException, NoDataException, NullArgumentException,\n-        OutOfRangeException {\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final T[][] subMatrix, final int row,\n+                             final int column)\n+        throws DimensionMismatchException, OutOfRangeException,\n+        NoDataException, NullArgumentException, NumberIsTooSmallException {\n         if (subMatrix == null) {\n             throw new NullArgumentException();\n         }\n--- a/src/main/java/org/apache/commons/math3/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/BlockFieldMatrix.java\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathUtils;\n      * @param field Field to which the elements belong.\n      * @param rows Number of rows in the new matrix.\n      * @param columns Number of columns in the new matrix.\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if row or column dimension is not positive.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      */\n-    public BlockFieldMatrix(final Field<T> field, final int rows, final int columns) {\n+    public BlockFieldMatrix(final Field<T> field, final int rows,\n+                            final int columns)\n+        throws NotStrictlyPositiveException {\n         super(field, rows, columns);\n         this.rows    = rows;\n         this.columns = columns;\n      * <pre>matrix = new BlockFieldMatrix<T>(getField(), rawData.length, rawData[0].length,\n      *                                   toBlocksLayout(rawData), false);</pre>\n      * </p>\n+     *\n      * @param rawData Data for the new matrix, in raw layout.\n-     *\n-     * @exception DimensionMismatchException if the {@code blockData} shape is\n+     * @throws DimensionMismatchException if the {@code blockData} shape is\n      * inconsistent with block layout.\n      * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n-    public BlockFieldMatrix(final T[][] rawData) {\n+    public BlockFieldMatrix(final T[][] rawData)\n+        throws DimensionMismatchException {\n         this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n     }\n \n      * @param copyArray if true, the input array will be copied, otherwise\n      * it will be referenced\n      *\n-     * @exception DimensionMismatchException if the {@code blockData} shape is\n+     * @throws DimensionMismatchException if the {@code blockData} shape is\n      * inconsistent with block layout.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      * @see #createBlocksLayout(Field, int, int)\n      * @see #toBlocksLayout(FieldElement[][])\n      * @see #BlockFieldMatrix(FieldElement[][])\n      */\n     public BlockFieldMatrix(final int rows, final int columns,\n-                            final T[][] blockData, final boolean copyArray) {\n+                            final T[][] blockData, final boolean copyArray)\n+        throws DimensionMismatchException, NotStrictlyPositiveException {\n         super(extractField(blockData), rows, columns);\n         this.rows    = rows;\n         this.columns = columns;\n      * @see #createBlocksLayout(Field, int, int)\n      * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n-    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) {\n+    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n+        throws DimensionMismatchException {\n \n         final int rows         = rawData.length;\n         final int columns      = rawData[0].length;\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) {\n-        return new BlockFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    public FieldMatrix<T> createMatrix(final int rowDimension,\n+                                       final int columnDimension)\n+        throws NotStrictlyPositiveException {\n+        return new BlockFieldMatrix<T>(getField(), rowDimension,\n+                                       columnDimension);\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> add(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         try {\n             return add((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n     }\n \n     /**\n-     * Compute the sum of this and <code>m</code>.\n+     * Compute the sum of {@code this} and {@code m}.\n      *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * @param m matrix to be added\n+     * @return {@code this + m}\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this}\n      */\n-    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m) {\n+    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n \n         // safety check\n         checkAdditionCompatible(m);\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> subtract(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         try {\n             return subtract((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n     }\n \n     /**\n-     * Compute this minus <code>m</code>.\n+     * Compute {@code this - m}.\n      *\n-     * @param m    matrix to be subtracted\n-     * @return     this - m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * @param m matrix to be subtracted\n+     * @return {@code this - m}\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this}\n      */\n-    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m) {\n+    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m) throws MatrixDimensionMismatchException {\n         // safety check\n         checkSubtractionCompatible(m);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> multiply(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws DimensionMismatchException {\n         try {\n             return multiply((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n     }\n \n     /**\n-     * Returns the result of postmultiplying this by m.\n+     * Returns the result of postmultiplying {@code this} by {@code m}.\n      *\n-     * @param m    matrix to postmultiply by\n-     * @return     this * m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n+     * @param m matrix to postmultiply by\n+     * @return {@code this * m}\n+     * @throws DimensionMismatchException if the matrices are not compatible.\n      */\n-    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) {\n+    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m)\n+        throws DimensionMismatchException {\n \n         // safety check\n         checkMultiplicationCompatible(m);\n     /** {@inheritDoc} */\n     @Override\n     public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn,\n+                                       final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         // safety checks\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n+    public void setSubMatrix(final T[][] subMatrix, final int row,\n+                             final int column)\n+        throws DimensionMismatchException, OutOfRangeException,\n+        NoDataException, NullArgumentException, NumberIsTooSmallException {\n         // safety checks\n         MathUtils.checkNotNull(subMatrix);\n         final int refLength = subMatrix[0].length;\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> getRowMatrix(final int row) {\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), 1, columns);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowMatrix(final int row, final FieldMatrix<T> matrix) {\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         try {\n             setRowMatrix(row, (BlockFieldMatrix<T>) matrix);\n         } catch (ClassCastException cce) {\n      * @param row the row to be set\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if the\n-     * specified row index is invalid.\n      * @throws MatrixDimensionMismatchException if the matrix dimensions do\n      * not match one instance row.\n+     * @throws OutOfRangeException if the specified row index is invalid.\n      */\n-    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix) {\n+    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> getColumnMatrix(final int column) {\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws OutOfRangeException {\n         checkColumnIndex(column);\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, 1);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) {\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         try {\n             setColumnMatrix(column, (BlockFieldMatrix<T>) matrix);\n         } catch (ClassCastException cce) {\n      * @param column Column to be set.\n      * @param matrix Column matrix (must have one column and the same number of rows\n      * as the instance).\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the specified column index is invalid.\n      * @throws MatrixDimensionMismatchException if the matrix dimensions do\n      * not match one instance column.\n+     * @throws OutOfRangeException if the specified column index is invalid.\n      */\n-    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix) {\n+    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldVector<T> getRowVector(final int row) {\n+    public FieldVector<T> getRowVector(final int row)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         final T[] outData = buildArray(getField(), columns);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowVector(final int row, final FieldVector<T> vector) {\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         try {\n             setRow(row, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldVector<T> getColumnVector(final int column) {\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws OutOfRangeException {\n         checkColumnIndex(column);\n         final T[] outData = buildArray(getField(), rows);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnVector(final int column, final FieldVector<T> vector) {\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         try {\n             setColumn(column, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] getRow(final int row) {\n+    public T[] getRow(final int row) throws OutOfRangeException {\n         checkRowIndex(row);\n         final T[] out = buildArray(getField(), columns);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRow(final int row, final T[] array) {\n+    public void setRow(final int row, final T[] array)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] getColumn(final int column) {\n+    public T[] getColumn(final int column) throws OutOfRangeException {\n         checkColumnIndex(column);\n         final T[] out = buildArray(getField(), rows);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumn(final int column, final T[] array) {\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixDimensionMismatchException, OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T getEntry(final int row, final int column) {\n+    public T getEntry(final int row, final int column)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setEntry(final int row, final int column, final T value) {\n+    public void setEntry(final int row, final int column, final T value)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void addToEntry(final int row, final int column, final T increment) {\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void multiplyEntry(final int row, final int column, final T factor) {\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] operate(final T[] v) {\n+    public T[] operate(final T[] v) throws DimensionMismatchException {\n         if (v.length != columns) {\n             throw new DimensionMismatchException(v.length, columns);\n         }\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] preMultiply(final T[] v) {\n+    public T[] preMultiply(final T[] v) throws DimensionMismatchException {\n \n         if (v.length != rows) {\n             throw new DimensionMismatchException(v.length, rows);\n     @Override\n     public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n-                            final int startColumn, final int endColumn) {\n+                            final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     @Override\n     public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n-                            final int startColumn, final int endColumn) {\n+                            final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     /** {@inheritDoc} */\n     @Override\n     public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n-                                       final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                  final int startRow, final int endRow,\n+                                  final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     /** {@inheritDoc} */\n     @Override\n     public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n-                                       final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                  final int startRow, final int endRow,\n+                                  final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n--- a/src/main/java/org/apache/commons/math3/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldMatrix.java\n      * @throws NoDataException if a row or column of {@code subMatrix} is empty.\n      * @throws DimensionMismatchException if {@code subMatrix} is not\n      * rectangular (not all rows have the same length).\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @throws NullArgumentException if {@code subMatrix} is {@code null}.\n      * @since 2.0\n      */\n     void setSubMatrix(T[][] subMatrix, int row, int column)\n         throws DimensionMismatchException, OutOfRangeException,\n-        NullArgumentException, NoDataException;\n+        NoDataException, NullArgumentException, NumberIsTooSmallException;\n \n    /**\n     * Get the entries in row number {@code row}", "timestamp": 1349673387, "metainfo": ""}