{"sha": "545e47a273803b1d080b186c8cf139492f82c4fb", "log": "Merging bug fixes in r267517:r321515 from MATH_1_1 branch.  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n             if (fm * fmin > 0.0) {\n                 // max and m bracket the root.\n                 min = m;\n-                fmin = fm;\n             } else {\n                 // min and m bracket the root.\n                 max = m;\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n package org.apache.commons.math.complex;\n \n import java.io.Serializable;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Representation of a Complex number - a number which has both a \n     /** The square root of -1. A number representing \"0.0 + 1.0i\".*/    \n     public static final Complex I = new Complex(0.0, 1.0);\n     \n-    /** A complex number representing \"(Double.NaN) + (Double.NaN)i\" */\n+    /** A complex number analogous to {@link java.lang.Double#NaN} */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n \n     /** A complex number representing \"1.0 + 0.0i\" */    \n     }\n     \n     /**\n-     * Test for the equality of two Complex objects.  If both the\n-     * real and imaginary parts of two Complex numbers are exactly\n-     * the same, the two Complex objects are considered to be equal.\n+     * Test for the equality of two Complex objects.\n+     * <p>\n+     * If both the real and imaginary parts of two Complex numbers\n+     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n+     * Complex objects are considered to be equal. \n+     * <p>\n+     * All <code>NaN</code> values are considered to be equal - i.e, if either\n+     * (or both) real and imaginary parts of the complex number are equal\n+     * to Double.NaN, the complex number is equal to \n+     * <code>Complex.NaN</code>.\n      *\n      * @param other Object to test for equality to this\n      * @return true if two Complex objects are equal, false if\n             ret = true;\n         } else if (other == null) {\n             ret = false;\n-        } else {\n+        } else  {\n             try {\n                 Complex rhs = (Complex)other;\n+                if (rhs.isNaN()) {\n+                    ret = this.isNaN();\n+                } else {\n                 ret = (Double.doubleToRawLongBits(real) ==\n                         Double.doubleToRawLongBits(rhs.getReal())) &&\n                     (Double.doubleToRawLongBits(imaginary) ==\n                         Double.doubleToRawLongBits(rhs.getImaginary())); \n+                }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n         }\n-        \n+      \n         return ret;\n+    }\n+    \n+    /**\n+     * Get a hashCode for the complex number.\n+     * <p>\n+     * All NaN values have the same hash code.\n+     * \n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 7;\n+        }\n+        return 37 * (17 * MathUtils.hash(imaginary) + \n+            MathUtils.hash(real));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     /**\n      * Returns true iff <code>object</code> is a \n      * <code>RealMatrixImpl</code> instance with the same dimensions as this\n-     *  and all corresponding matrix entries are equal.\n+     * and all corresponding matrix entries are equal.  Corresponding entries\n+     * are compared using {@link java.lang.Double#doubleToLongBits(double)}\n      * \n      * @param object the object to test equality against.\n      * @return true if object equals this\n         }\n         for (int row = 0; row < nRows; row++) {\n             for (int col = 0; col < nCols; col++) {\n-                if (data[row][col] != m.getEntry(row, col)) {\n+                if (Double.doubleToLongBits(data[row][col]) != \n+                    Double.doubleToLongBits(m.getEntry(row, col))) {\n                     return false;\n                 }\n             }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n             return Double.NaN;\n         }\n         double variance = moment.m2 / (double) (moment.n - 1);\n-        double skewness = Double.NaN;\n         if (variance < 10E-20) {\n-            skewness = 0.0;\n+            return 0.0d;\n         } else {\n             double n0 = (double) moment.getN();\n-            skewness = (n0 * moment.m3) /\n+            return  (n0 * moment.m3) /\n             ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n         }\n-        return skewness;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n         if (test(values, begin, length)) {\n             max = values[begin];\n             for (int i = begin; i < begin + length; i++) {\n-                max = (max > values[i]) ? max : values[i];\n+                if (!Double.isNaN(values[i])) {\n+                    max = (max > values[i]) ? max : values[i];\n+                }\n             }\n         }\n         return max;\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n         if (test(values, begin, length)) {\n             min = values[begin];\n             for (int i = begin; i < begin + length; i++) {\n-                min = (min < values[i]) ? min : values[i];\n+                if (!Double.isNaN(values[i])) {\n+                    min = (min < values[i]) ? min : values[i];\n+                }\n             }\n         }\n         return min;\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n         if ((p > 100) || (p <= 0)) {\n             throw new IllegalArgumentException(\"invalid quantile value: \" + p);\n         }\n+        if (length == 0) {\n+            return Double.NaN;\n+        }\n+        if (length == 1) {\n+            return values[begin]; // always return single value for n = 1\n+        }\n         double n = (double) length;\n-        if (n == 0) {\n-            return Double.NaN;\n-        }\n-        if (n == 1) {\n-            return values[begin]; // always return single value for n = 1\n-        }\n         double pos = p * (n + 1) / 100;\n         double fpos = Math.floor(pos);\n         int intPos = (int) fpos;\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n     public static int subAndCheck(int x, int y) {\n         long s = (long)x - (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"overflow: add\");\n+            throw new ArithmeticException(\"overflow: subtract\");\n         }\n         return (int)s;\n     }\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n      *         zero or is greater than <code>getNumElements() - 1</code>.\n      */\n-    public double getElement(int index) {\n-        double value = Double.NaN;\n+    public synchronized double getElement(int index) {\n         if (index >= numElements) {\n             String msg =\n                 \"The index specified: \" + index +\n                 \" is larger than the current number of elements\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         } else if (index >= 0) {\n-            value = internalArray[startIndex + index];\n+            return internalArray[startIndex + index];\n         } else {\n             String msg =\n                 \"Elements cannot be retrieved from a negative array index\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         }\n-        return value;\n     }\n     \n      /**\n      *  array have no effect on this <code>ResizableArray.</code>\n      * @return the double array.\n      */\n-    public double[] getElements() {\n+    public synchronized double[] getElements() {\n         double[] elementArray = new double[numElements];\n         System.arraycopy( internalArray, startIndex, elementArray, 0,\n                 numElements);\n      * \n      * @return the length of the internal storage array.\n      */\n-    int getInternalLength() {\n+    synchronized int getInternalLength() {\n         return (internalArray.length);\n     }\n \n      *\n      * @return number of elements\n      */\n-    public int getNumElements() {\n+    public synchronized int getNumElements() {\n         return (numElements);\n     }\n     \n      * \n      * @return the internal storage array used by this object\n      */\n-    public double[] getValues() {\n+    public synchronized double[] getValues() {\n         return (internalArray);\n     }\n \n      *\n      * @return starting index\n      */\n-    public int start() {\n+    public synchronized int start() {\n         return startIndex;\n     }\n \n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n         Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n         assertFalse(x.equals(y));\n     }\n+    \n+    public void testEqualsNaN() {\n+        Complex realNaN = new Complex(Double.NaN, 0.0);\n+        Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n+        Complex complexNaN = Complex.NaN;\n+        assertTrue(realNaN.equals(imaginaryNaN));\n+        assertTrue(imaginaryNaN.equals(complexNaN));\n+        assertTrue(realNaN.equals(complexNaN));\n+    }\n+    \n+    public void testHashCode() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n+        assertFalse(x.hashCode()==y.hashCode());\n+        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n+        assertFalse(x.hashCode()==y.hashCode());\n+        Complex realNaN = new Complex(Double.NaN, 0.0);\n+        Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n+        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n+        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n+    }\n }\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n     private double skewness = 0;\n     private double kurtosis = 0.5;\n     private double tolerance = 10E-15;\n+    private double nan = Double.NaN;\n \n     public StatUtilsTest(String name) {\n         super(name);\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);\n+\n+        // test first nan is ignored\n+        x = new double[] {nan, two, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);\n+\n+        // test middle nan is ignored\n+        x = new double[] {one, nan, three};\n+        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);\n+        \n+        // test last nan is ignored\n+        x = new double[] {one, two, nan};\n+        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);\n+\n+        // test all nan returns nan\n+        x = new double[] {nan, nan, nan};\n+        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);\n     }\n     \n     public void testMin() {\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);\n+\n+        // test first nan is ignored\n+        x = new double[] {nan, two, three};\n+        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);\n+\n+        // test middle nan is ignored\n+        x = new double[] {one, nan, three};\n+        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n+        \n+        // test last nan is ignored\n+        x = new double[] {one, two, nan};\n+        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n+\n+        // test all nan returns nan\n+        x = new double[] {nan, nan, nan};\n+        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);\n     }\n     \n     public void testPercentile() {\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n         assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     \n     }\n \n+    public void testNaNs() {\n+        Max max = new Max();\n+        double nan = Double.NaN;\n+        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);     \n+        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);     \n+        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);     \n+        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     \n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n         assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     \n     }\n \n+    public void testNaNs() {\n+        Min min = new Min();\n+        double nan = Double.NaN;\n+        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);     \n+        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);     \n+        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);     \n+        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     \n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         assertEquals(big, MathUtils.addAndCheck(big, 0));\n         try {\n             int res = MathUtils.addAndCheck(big, 1);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         try {\n             int res = MathUtils.addAndCheck(bigNeg, -1);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n     }\n     \n         assertEquals(big, MathUtils.mulAndCheck(big, 1));\n         try {\n             int res = MathUtils.mulAndCheck(big, 2);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         try {\n             int res = MathUtils.mulAndCheck(bigNeg, 2);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n     }\n     \n         assertEquals(big, MathUtils.subAndCheck(big, 0));\n         try {\n             int res = MathUtils.subAndCheck(big, -1);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         try {\n             int res = MathUtils.subAndCheck(bigNeg, 1);\n+            fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testSubAndCheckErrorMessage() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        try {\n+            int res = MathUtils.subAndCheck(big, -1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            assertEquals(\"overflow: subtract\", ex.getMessage());\n+        }\n     }\n     \n     public void testBinomialCoefficient() {", "timestamp": 1129433354, "metainfo": ""}