{"sha": "5d7868b30a2f5896fc90366ff75169924b8243f1", "log": "[MATH-777] Added OrderedCrossover policy.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/genetics/OrderedCrossover.java\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Order 1 Crossover [OX1] builds offspring from <b>ordered</b> chromosomes by copying a\n+ * consecutive slice from one parent, and filling up the remaining genes from the other\n+ * parent as they appear.\n+ * <p>\n+ * This policy works by applying the following rules:\n+ * <ol>\n+ *   <li>select a random slice of consecutive genes from parent 1</li>\n+ *   <li>copy the slice to child 1 and mark out the genes in parent 2</li>\n+ *   <li>starting from the right side of the slice, copy genes from parent 2 as they\n+ *       appear to child 1 if they are not yet marked out.</li>\n+ * </ol>\n+ * </p>\n+ *\n+ * Example (random sublist from index 3 to 7, underlined):\n+ * <pre>\n+ * p1 = (8 4 7 3 6 2 5 1 9 0)   X   c1 = (0 4 7 3 6 2 5 1 8 9)\n+ *             ---------                        ---------\n+ * p2 = (0 1 2 3 4 5 6 7 8 9)   X   c2 = (8 1 2 3 4 5 6 7 9 0)\n+ * </pre>\n+ *\n+ * This policy works only on {@link AbstractListChromosome}, and therefore it\n+ * is parameterized by T. Moreover, the chromosomes must have same lengths.\n+ *\n+ * @see <a href=\"http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/Order1CrossoverOperator.aspx\"\n+ * Order 1 Crossover Operator</a>\n+ *\n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class OrderedCrossover<T> implements CrossoverPolicy {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+        if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n+        }\n+        return mate((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     *\n+     * @param first the first chromosome\n+     * @param second the second chromosome\n+     * @return the pair of new chromosomes that resulted from the crossover\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n+     */\n+    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second) {\n+        final int length = first.getLength();\n+        if (length != second.getLength()) {\n+            throw new DimensionMismatchException(second.getLength(), length);\n+        }\n+\n+        // array representations of the parents\n+        final List<T> parent1Rep = first.getRepresentation();\n+        final List<T> parent2Rep = second.getRepresentation();\n+        // and of the children\n+        final List<T> child1 = new ArrayList<T>(length);\n+        final List<T> child2 = new ArrayList<T>(length);\n+        // sets of already inserted items for quick access\n+        final Set<T> child1Set = new HashSet<T>(length);\n+        final Set<T> child2Set = new HashSet<T>(length);\n+\n+        final RandomGenerator random = GeneticAlgorithm.getRandomGenerator();\n+        // choose random points, making sure that lb < ub.\n+        int a = random.nextInt(length);\n+        int b;\n+        do {\n+            b = random.nextInt(length);\n+        } while (a == b);\n+        // determine the lower and upper bounds\n+        final int lb = FastMath.min(a, b);\n+        final int ub = FastMath.max(a, b);\n+\n+        // add the subLists that are between lb and ub\n+        child1.addAll(parent1Rep.subList(lb, ub + 1));\n+        child1Set.addAll(child1);\n+        child2.addAll(parent2Rep.subList(lb, ub + 1));\n+        child2Set.addAll(child2);\n+\n+        // iterate over every item in the parents\n+        for (int i = 1; i <= length; i++) {\n+            final int idx = (ub + i) % length;\n+\n+            // retrieve the current item in each parent\n+            final T item1 = parent1Rep.get(idx);\n+            final T item2 = parent2Rep.get(idx);\n+\n+            // if the first child already contains the item in the second parent add it\n+            if (!child1Set.contains(item2)) {\n+                child1.add(item2);\n+                child1Set.add(item2);\n+            }\n+\n+            // if the second child already contains the item in the first parent add it\n+            if (!child2Set.contains(item1)) {\n+                child2.add(item1);\n+                child2Set.add(item1);\n+            }\n+        }\n+\n+        // rotate so that the original slice is in the same place as in the parents.\n+        Collections.rotate(child1, lb);\n+        Collections.rotate(child2, lb);\n+\n+        return new ChromosomePair(first.newFixedLengthChromosome(child1),\n+                                  second.newFixedLengthChromosome(child2));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/genetics/OrderedCrossoverTest.java\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class OrderedCrossoverTest {\n+\n+    @Test\n+    public void testCrossover() {\n+        final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 };\n+        final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        final DummyListChromosome p1c = new DummyListChromosome(p1);\n+        final DummyListChromosome p2c = new DummyListChromosome(p2);\n+        \n+        final CrossoverPolicy cp = new OrderedCrossover<Integer>();\n+\n+        for (int i = 0; i < 20; i++) {\n+            final Set<Integer> parentSet1 = new HashSet<Integer>(Arrays.asList(p1));\n+            final Set<Integer> parentSet2 = new HashSet<Integer>(Arrays.asList(p2));\n+            \n+            final ChromosomePair pair = cp.crossover(p1c, p2c);\n+\n+            final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);\n+            final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);\n+\n+            Assert.assertNotSame(p1c, pair.getFirst());\n+            Assert.assertNotSame(p2c, pair.getSecond());\n+            \n+            // make sure that the children have exactly the same elements as their parents\n+            for (int j = 0; j < c1.length; j++) {\n+                Assert.assertTrue(parentSet1.contains(c1[j]));\n+                parentSet1.remove(c1[j]);\n+                Assert.assertTrue(parentSet2.contains(c2[j]));\n+                parentSet2.remove(c2[j]);\n+            }\n+        }\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testCrossoverDimensionMismatchException() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 };\n+\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new OrderedCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeFirst() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final Chromosome p2c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new OrderedCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeSecond() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p1);\n+        final Chromosome p1c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new OrderedCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+}", "timestamp": 1344197008, "metainfo": ""}