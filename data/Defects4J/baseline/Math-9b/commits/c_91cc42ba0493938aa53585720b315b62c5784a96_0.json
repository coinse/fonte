{"sha": "91cc42ba0493938aa53585720b315b62c5784a96", "log": "MATH-728 Offset by one bug. Suggested fix provided by Bruce Johnson. I've added a unit test that exercises the use of more interpolation points; two previously unexplored code paths are now being traversed.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n-                    throw new PathIsExploredException(); // XXX\n-                }\n-                interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));\n-                interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));\n+//                     throw new PathIsExploredException(); // XXX\n+                }\n+                final int iptMinus1 = ipt - 1;\n+                final int jptMinus1 = jpt - 1;\n+                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n+                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }\n \n             // Calculate the next value of F. The least function value so far and\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-                throw new PathIsExploredException(); // XXX\n+//                 throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n     private static void printMethod() {\n         //        System.out.println(caller(2));\n     }\n-}\n-\n-/**\n- * Marker for code paths that are not explored with the current unit tests.\n- * If the path becomes explored, it should just be removed from the code.\n- */\n-class PathIsExploredException extends RuntimeException {\n-    private static final long serialVersionUID = 745350979634801853L;\n-\n-    private static final String PATH_IS_EXPLORED\n-        = \"If this exception is thrown, just remove it from the code\";\n-\n-    PathIsExploredException() {\n-        super(PATH_IS_EXPLORED);\n+\n+    /**\n+     * Marker for code paths that are not explored with the current unit tests.\n+     * If the path becomes explored, it should just be removed from the code.\n+     */\n+    private static class PathIsExploredException extends RuntimeException {\n+        private static final long serialVersionUID = 745350979634801853L;\n+\n+        private static final String PATH_IS_EXPLORED\n+            = \"If this exception is thrown, just remove it from the code\";\n+\n+        PathIsExploredException() {\n+            super(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n                 1e-13, 1e-6, 2000, expected);\n     }\n \n+    // See MATH-728\n+    @Test\n+    public void testConstrainedRosenWithMoreInterpolationPoints() {\n+        final double[] startPoint = point(DIM, 0.1);\n+        final double[][] boundaries = boundaries(DIM, -1, 2);\n+        final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n+\n+        // This should have been 78 because in the code the hard limit is\n+        // said to be\n+        //   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n+        // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n+        // 65, 66, ...\n+        final int maxAdditionalPoints = 47;\n+\n+        for (int num = 1; num <= maxAdditionalPoints; num++) {\n+            doTest(new Rosen(), startPoint, boundaries,\n+                   GoalType.MINIMIZE,\n+                   1e-12, 1e-6, 2000,\n+                   num,\n+                   expected,\n+                   \"num=\" + num);\n+        }\n+    }\n+\n     /**\n      * @param func Function to optimize.\n      * @param startPoint Starting point.\n      * @param expected Expected point / value.\n      */\n     private void doTest(MultivariateFunction func,\n-            double[] startPoint,\n-            double[][] boundaries,\n-            GoalType goal,\n-            double fTol,\n-            double pointTol,\n-            int maxEvaluations,\n-            RealPointValuePair expected) {\n+                        double[] startPoint,\n+                        double[][] boundaries,\n+                        GoalType goal,\n+                        double fTol,\n+                        double pointTol,\n+                        int maxEvaluations,\n+                        RealPointValuePair expected) {\n+        doTest(func,\n+               startPoint,\n+               boundaries,\n+               goal,\n+               fTol,\n+               pointTol,\n+               maxEvaluations,\n+               0,\n+               expected,\n+               \"\");\n+    }\n+\n+    /**\n+     * @param func Function to optimize.\n+     * @param startPoint Starting point.\n+     * @param boundaries Upper / lower point limit.\n+     * @param goal Minimization or maximization.\n+     * @param fTol Tolerance relative error on the objective function.\n+     * @param pointTol Tolerance for checking that the optimum is correct.\n+     * @param maxEvaluations Maximum number of evaluations.\n+     * @param additionalInterpolationPoints Number of interpolation to used\n+     * in addition to the default (2 * dim + 1).\n+     * @param expected Expected point / value.\n+     */\n+    private void doTest(MultivariateFunction func,\n+                        double[] startPoint,\n+                        double[][] boundaries,\n+                        GoalType goal,\n+                        double fTol,\n+                        double pointTol,\n+                        int maxEvaluations,\n+                        int additionalInterpolationPoints,\n+                        RealPointValuePair expected,\n+                        String assertMsg) {\n \n         System.out.println(func.getClass().getName() + \" BEGIN\"); // XXX\n \n //        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n-        BOBYQAOptimizer optim = new BOBYQAOptimizer(2 * dim + 1);\n+        final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints;\n+        BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints);\n         RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n //        System.out.println(func.getClass().getName() + \" = \" \n //              + optim.getEvaluations() + \" f(\");\n //        for (double x: result.getPoint())  System.out.print(x + \" \");\n //        System.out.println(\") = \" +  result.getValue());\n-        Assert.assertEquals(expected.getValue(),\n-                result.getValue(), fTol);\n+        Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol);\n         for (int i = 0; i < dim; i++) {\n             Assert.assertEquals(expected.getPoint()[i],\n-                    result.getPoint()[i], pointTol);\n+                                result.getPoint()[i], pointTol);\n         }\n \n         System.out.println(func.getClass().getName() + \" END\"); // XXX", "timestamp": 1324387829, "metainfo": ""}