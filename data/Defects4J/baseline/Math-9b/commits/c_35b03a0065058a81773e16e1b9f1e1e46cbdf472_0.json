{"sha": "35b03a0065058a81773e16e1b9f1e1e46cbdf472", "log": "improved test coverage  ", "commit": "\n--- a/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n     super(name);\n   }\n \n+  public void testCostExceptions() throws ConvergenceException {\n+      CostFunction wrong =\n+          new CostFunction() {\n+            public double cost(double[] x) throws CostException {\n+                if (x[0] < 0) {\n+                    throw new CostException(\"{0}\", new Object[] { \"oops\"});\n+                } else if (x[0] > 1) {\n+                    throw new CostException(new RuntimeException(\"oops\"));\n+                } else {\n+                    return x[0] * (1 - x[0]);\n+                }\n+            }\n+      };\n+      try {\n+          new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n+                                           new double[] { -0.5 }, new double[] { 0.5 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (CostException ce) {\n+          // expected behavior\n+          assertNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+      try {\n+          new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n+                                           new double[] { 0.5 }, new double[] { 1.5 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (CostException ce) {\n+          // expected behavior\n+          assertNotNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+  }\n+\n   public void testRosenbrock()\n     throws CostException, ConvergenceException {\n \n     count = 0;\n     PointCostPair optimum =\n       new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n-                                       new double[] { -1.2,  1.0 },\n-                                       new double[] {  3.5, -2.3 });\n+                                       new double[][] {\n+                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+                                       });\n \n     assertTrue(count > 60);\n-    assertTrue(optimum.cost > 0.02);\n+    assertTrue(optimum.cost > 0.01);\n \n   }\n \n--- a/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n import org.apache.commons.math.optimization.NelderMead;\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.optimization.PointCostPair;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.NotPositiveDefiniteMatrixException;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.apache.commons.math.random.UniformRandomGenerator;\n \n import junit.framework.*;\n \n     super(name);\n   }\n \n+  public void testCostExceptions() throws ConvergenceException {\n+      CostFunction wrong =\n+          new CostFunction() {\n+            public double cost(double[] x) throws CostException {\n+                if (x[0] < 0) {\n+                    throw new CostException(\"{0}\", new Object[] { \"oops\"});\n+                } else if (x[0] > 1) {\n+                    throw new CostException(new RuntimeException(\"oops\"));\n+                } else {\n+                    return x[0] * (1 - x[0]);\n+                }\n+            }\n+      };\n+      try {\n+          new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n+                                                       new double[] { -0.5 }, new double[] { 0.5 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (CostException ce) {\n+          // expected behavior\n+          assertNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+      try {\n+          new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),\n+                                                       new double[] { 0.5 }, new double[] { 1.5 });\n+          fail(\"an exception should have been thrown\");\n+      } catch (CostException ce) {\n+          // expected behavior\n+          assertNotNull(ce.getCause());\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      } \n+  }\n+\n   public void testRosenbrock()\n-    throws CostException, ConvergenceException {\n+    throws CostException, ConvergenceException, NotPositiveDefiniteMatrixException {\n \n     CostFunction rosenbrock =\n       new CostFunction() {\n       };\n \n     count = 0;\n+    NelderMead nm = new NelderMead();\n+    try {\n+      nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                   new double[][] {\n+                     { -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 }\n+                   }, 1, 5384353l);\n+      fail(\"an exception should have been thrown\");\n+    } catch (ConvergenceException ce) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+\n+    count = 0;\n     PointCostPair optimum =\n-      new NelderMead().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n-                                 new double[] { -1.2,  1.0 },\n-                                 new double[] {  3.5, -2.3 });\n+        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                     new double[][] {\n+                       { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 }\n+                     }, 3, 1642738l);\n \n-    assertTrue(count < 50);\n-    assertEquals(0.0, optimum.cost, 6.0e-4);\n-    assertEquals(1.0, optimum.point[0], 0.05);\n-    assertEquals(1.0, optimum.point[1], 0.05);\n+    assertTrue(count < 200);\n+    assertEquals(0.0, optimum.cost, 5.0e-5);\n+    assertEquals(1.0, optimum.point[0], 0.01);\n+    assertEquals(1.0, optimum.point[1], 0.01);\n+\n+    PointCostPair[] minima = nm.getMinima();\n+    assertEquals(3, minima.length);\n+    for (int i = 1; i < minima.length; ++i) {\n+        if (minima[i] != null) {\n+            assertTrue(minima[i-1].cost <= minima[i].cost);\n+        }\n+    }\n+\n+    RandomGenerator rg = new JDKRandomGenerator();\n+    rg.setSeed(64453353l);\n+    RandomVectorGenerator rvg =\n+        new UncorrelatedRandomVectorGenerator(new double[] { 0.9, 1.1 },\n+                                              new double[] { 0.2, 0.2 },\n+                                              new UniformRandomGenerator(rg));\n+    optimum =\n+        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);\n+    assertEquals(0.0, optimum.cost, 2.0e-4);\n+    optimum =\n+        nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);\n+    assertEquals(0.0, optimum.cost, 3.0e-5);\n \n   }\n \n       };\n \n     count = 0;\n+    NelderMead nm = new NelderMead();\n     PointCostPair optimum =\n-      new NelderMead().minimizes(powell, 200, new ValueChecker(1.0e-3),\n-                                 new double[] {  3.0, -1.0, 0.0, 1.0 },\n-                                 new double[] {  4.0,  0.0, 1.0, 2.0 });\n+      nm.minimizes(powell, 200, new ValueChecker(1.0e-3),\n+                   new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                   new double[] {  4.0,  0.0, 1.0, 2.0 },\n+                   1, 1642738l);\n     assertTrue(count < 150);\n     assertEquals(0.0, optimum.cost, 6.0e-4);\n     assertEquals(0.0, optimum.point[0], 0.07);", "timestamp": 1189373940, "metainfo": ""}