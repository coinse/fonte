{"sha": "1eaea0b549f685bd416cef68faa3a137b9bb3519", "log": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals. JIRA: MATH-361  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/main/java/org/apache/commons/math/ConvergenceException.java\n  */\n package org.apache.commons.math;\n \n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n /**\n  * Error thrown when a numerical computation can not be performed because the\n  * numerical result failed to converge to a finite value.\n public class ConvergenceException extends MathException {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4883703247677159141L;\n+    private static final long serialVersionUID = -1111352570797662604L;\n \n     /**\n      * Default constructor.\n      */\n     public ConvergenceException() {\n-        super(\"Convergence failed\");\n+        super(LocalizedFormats.CONVERGENCE_FAILED);\n     }\n \n     /**\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 1.2\n+     * @deprecated as of 2.2 replaced by {@link #ConvergenceException(Localizable, Object...)}\n      */\n+    @Deprecated\n     public ConvergenceException(String pattern, Object ... arguments) {\n+        this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public ConvergenceException(Localizable pattern, Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 1.2\n+     * @deprecated as of 2.2 replaced by {@link #ConvergenceException(Throwable, Localizable, Object...)}\n      */\n+    @Deprecated\n     public ConvergenceException(Throwable cause, String pattern, Object ... arguments) {\n+        this(cause, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public ConvergenceException(Throwable cause, Localizable pattern, Object ... arguments) {\n         super(cause, pattern, arguments);\n     }\n \n--- a/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n  * limitations under the License.\n  */\n package org.apache.commons.math;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Error thrown when two dimensions differ.\n      * @param dimension2 second dimension\n      */\n     public DimensionMismatchException(final int dimension1, final int dimension2) {\n-        super(\"dimension mismatch {0} != {1}\", dimension1, dimension2);\n+        super(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, dimension1, dimension2);\n         this.dimension1 = dimension1;\n         this.dimension2 = dimension2;\n     }\n--- a/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n  * limitations under the License.\n  */\n package org.apache.commons.math;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Exception thrown when a sample contains several entries at the same abscissa.\n      * @param i2 index of another entry having the duplicate abscissa\n      */\n     public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n-        super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n+        super(LocalizedFormats.DUPLICATED_ABSCISSA,\n               abscissa, i1, i2);\n     }\n \n--- a/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n package org.apache.commons.math;\n \n import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Exception thrown when an error occurs evaluating a function.\n public class FunctionEvaluationException extends MathException  {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -4305020489115478365L;\n-\n-    /** Message for failed evaluation. */\n-    private static final String FAILED_EVALUATION_MESSAGE =\n-        \"evaluation failed for argument = {0}\";\n+    private static final long serialVersionUID = 1384427981840836868L;\n \n     /** Argument causing function evaluation failure */\n     private double[] argument;\n      * @param argument  the failing function argument\n      */\n     public FunctionEvaluationException(double argument) {\n-        super(FAILED_EVALUATION_MESSAGE, argument);\n+        super(LocalizedFormats.EVALUATION_FAILED, argument);\n         this.argument = new double[] { argument };\n     }\n \n      * @since 2.0\n      */\n     public FunctionEvaluationException(double[] argument) {\n-        super(FAILED_EVALUATION_MESSAGE, new ArrayRealVector(argument));\n+        super(LocalizedFormats.EVALUATION_FAILED, new ArrayRealVector(argument));\n         this.argument = argument.clone();\n     }\n \n      */\n     public FunctionEvaluationException(double argument,\n                                        String pattern, Object ... arguments) {\n+        this(argument, new DummyLocalizable(pattern), argument);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public FunctionEvaluationException(double argument,\n+                                       Localizable pattern, Object ... arguments) {\n         super(pattern, arguments);\n         this.argument = new double[] { argument };\n     }\n      */\n     public FunctionEvaluationException(double[] argument,\n                                        String pattern, Object ... arguments) {\n+        this(argument, new DummyLocalizable(pattern), argument);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public FunctionEvaluationException(double[] argument,\n+                                       Localizable pattern, Object ... arguments) {\n         super(pattern, arguments);\n         this.argument = argument.clone();\n     }\n     public FunctionEvaluationException(Throwable cause,\n                                        double argument, String pattern,\n                                        Object ... arguments) {\n+        this(cause, argument, new DummyLocalizable(pattern), argument);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public FunctionEvaluationException(Throwable cause,\n+                                       double argument, Localizable pattern,\n+                                       Object ... arguments) {\n         super(cause, pattern, arguments);\n         this.argument = new double[] { argument };\n     }\n      */\n     public FunctionEvaluationException(Throwable cause,\n                                        double[] argument, String pattern,\n+                                       Object ... arguments) {\n+        this(cause, argument, new DummyLocalizable(pattern), argument);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public FunctionEvaluationException(Throwable cause,\n+                                       double[] argument, Localizable pattern,\n                                        Object ... arguments) {\n         super(cause, pattern, arguments);\n         this.argument = argument.clone();\n--- a/src/main/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/main/java/org/apache/commons/math/MathConfigurationException.java\n package org.apache.commons.math;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Signals a configuration problem with any of the factory methods.\n      * @since 1.2\n      */\n     public MathConfigurationException(String pattern, Object ... arguments) {\n+        this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public MathConfigurationException(Localizable pattern, Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n      * @since 1.2\n      */\n     public MathConfigurationException(Throwable cause, String pattern, Object ... arguments) {\n+        this(cause, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public MathConfigurationException(Throwable cause, Localizable pattern, Object ... arguments) {\n         super(cause, pattern, arguments);\n     }\n \n--- a/src/main/java/org/apache/commons/math/MathException.java\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n import java.io.PrintWriter;\n import java.text.MessageFormat;\n import java.util.Locale;\n-import java.util.MissingResourceException;\n-import java.util.ResourceBundle;\n+\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n public class MathException extends Exception {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -9004610152740737812L;\n+    private static final long serialVersionUID = 7428019509644517071L;\n \n     /**\n      * Pattern used to build the message.\n      */\n-    private final String pattern;\n+    private final Localizable pattern;\n \n     /**\n      * Arguments used to build the message.\n      * detail message.\n      */\n     public MathException() {\n-        this.pattern   = null;\n-        this.arguments = new Object[0];\n+        this.pattern   = LocalizedFormats.SIMPLE_MESSAGE;\n+        this.arguments = new Object[] { \"\" };\n     }\n \n     /**\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     */\n+     * @deprecated as of 2.2 replaced by {@link #MathException(Localizable, Object...)}\n+     */\n+    @Deprecated\n     public MathException(String pattern, Object ... arguments) {\n+      this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathException(Localizable pattern, Object ... arguments) {\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      */\n     public MathException(Throwable rootCause) {\n         super(rootCause);\n-        this.pattern   = getMessage();\n-        this.arguments = new Object[0];\n+        this.pattern   = LocalizedFormats.SIMPLE_MESSAGE;\n+        this.arguments = new Object[] { (rootCause == null) ? \"\" : rootCause.getMessage() };\n     }\n \n     /**\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 1.2\n-     */\n+     * @deprecated as of 2.2 replaced by {@link #MathException(Throwable, Localizable, Object...)}\n+     */\n+    @Deprecated\n     public MathException(Throwable rootCause, String pattern, Object ... arguments) {\n+        this(rootCause, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public MathException(Throwable rootCause, Localizable pattern, Object ... arguments) {\n       super(rootCause);\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n-    /**\n-     * Translate a string to a given locale.\n-     * @param s string to translate\n-     * @param locale locale into which to translate the string\n-     * @return translated string or original string\n-     * for unsupported locales or unknown strings\n-     */\n-    private static String translate(String s, Locale locale) {\n-        try {\n-            ResourceBundle bundle =\n-                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n-            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n-                // the value of the resource is the translated string\n-                return bundle.getString(s);\n-            }\n-\n-        } catch (MissingResourceException mre) {\n-            // do nothing here\n-        }\n-\n-        // the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the string as is\n-        return s;\n-\n-    }\n-\n     /** Gets the pattern used to build the message of this throwable.\n      *\n      * @return the pattern used to build the message of this throwable\n      * @since 1.2\n-     */\n+     * @deprecated as of 2.2 replaced by {@link #getLocalizablePattern()}\n+     */\n+    @Deprecated\n     public String getPattern() {\n+        return pattern.getSourceString();\n+    }\n+\n+    /** Gets the localizable pattern used to build the message of this throwable.\n+     *\n+     * @return the localizable pattern used to build the message of this throwable\n+     * @since 2.2\n+     */\n+    public Localizable getLocalizablePattern() {\n         return pattern;\n     }\n \n      * @since 1.2\n      */\n     public String getMessage(final Locale locale) {\n-        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n+        if (pattern != null) {\n+            return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        }\n+        return \"\";\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n import java.text.ParseException;\n import java.util.ConcurrentModificationException;\n import java.util.Locale;\n-import java.util.MissingResourceException;\n import java.util.NoSuchElementException;\n-import java.util.ResourceBundle;\n+\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n * Base class for commons-math unchecked exceptions.\n public class MathRuntimeException extends RuntimeException {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -5128983364075381060L;\n+    private static final long serialVersionUID = 9058794795027570002L;\n \n     /**\n      * Pattern used to build the message.\n      */\n-    private final String pattern;\n+    private final Localizable pattern;\n \n     /**\n      * Arguments used to build the message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     */\n+     * @deprecated as of 2.2 replaced by {@link #MathRuntimeException(Localizable, Object...)}\n+     */\n+    @Deprecated\n     public MathRuntimeException(final String pattern, final Object ... arguments) {\n+        this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public MathRuntimeException(final Localizable pattern, final Object ... arguments) {\n         this.pattern   = pattern;\n         this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n      */\n     public MathRuntimeException(final Throwable rootCause) {\n         super(rootCause);\n-        this.pattern   = getMessage();\n-        this.arguments = new Object[0];\n+        this.pattern   = LocalizedFormats.SIMPLE_MESSAGE;\n+        this.arguments = new Object[] { (rootCause == null) ? \"\" : rootCause.getMessage() };\n     }\n \n     /**\n      * to be thrown.\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     */\n+     * @deprecated as of 2.2 replaced by {@link #MathRuntimeException(Throwable, Localizable, Object...)}\n+     */\n+    @Deprecated\n     public MathRuntimeException(final Throwable rootCause,\n                                 final String pattern, final Object ... arguments) {\n+        this(rootCause, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public MathRuntimeException(final Throwable rootCause,\n+                                final Localizable pattern, final Object ... arguments) {\n         super(rootCause);\n         this.pattern   = pattern;\n         this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n     /**\n-     * Translate a string to a given locale.\n-     * @param s string to translate\n-     * @param locale locale into which to translate the string\n-     * @return translated string or original string\n-     * for unsupported locales or unknown strings\n-     */\n-    private static String translate(final String s, final Locale locale) {\n-        try {\n-            ResourceBundle bundle =\n-                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n-            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n-                // the value of the resource is the translated string\n-                return bundle.getString(s);\n-            }\n-\n-        } catch (MissingResourceException mre) {\n-            // do nothing here\n-        }\n-\n-        // the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the string as is\n-        return s;\n-\n-    }\n-\n-    /**\n      * Builds a message string by from a pattern and its arguments.\n      * @param locale Locale in which the message should be translated\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @return a message string\n-     */\n-    private static String buildMessage(final Locale locale, final String pattern,\n+     * @since 2.2\n+     */\n+    private static String buildMessage(final Locale locale, final Localizable pattern,\n                                        final Object ... arguments) {\n-        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n     }\n \n     /** Gets the pattern used to build the message of this throwable.\n+    *\n+    * @return the pattern used to build the message of this throwable\n+    * @deprecated as of 2.2 replaced by {@link #getLocalizablePattern()}\n+    */\n+    @Deprecated\n+    public String getPattern() {\n+        return pattern.getSourceString();\n+    }\n+\n+    /** Gets the localizable pattern used to build the message of this throwable.\n      *\n-     * @return the pattern used to build the message of this throwable\n-     */\n-    public String getPattern() {\n+     * @return the localizable pattern used to build the message of this throwable\n+     * @since 2.2\n+     */\n+    public Localizable getLocalizablePattern() {\n         return pattern;\n     }\n \n      * @return localized message\n      */\n     public String getMessage(final Locale locale) {\n-        return buildMessage(locale, pattern, arguments);\n+        if (pattern != null) {\n+            return buildMessage(locale, pattern, arguments);\n+        }\n+        return \"\";\n     }\n \n     /** {@inheritDoc} */\n      */\n     public static ArithmeticException createArithmeticException(final String pattern,\n                                                                 final Object ... arguments) {\n+        return createArithmeticException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArithmeticException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static ArithmeticException createArithmeticException(final Localizable pattern,\n+                                                                final Object ... arguments) {\n         return new ArithmeticException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = 7705628723242533939L;\n+            private static final long serialVersionUID = 5305498554076846637L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final String pattern,\n                                                                                       final Object ... arguments) {\n+        return createArrayIndexOutOfBoundsException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArrayIndexOutOfBoundsException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final Localizable pattern,\n+                                                                                      final Object ... arguments) {\n         return new ArrayIndexOutOfBoundsException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = -3394748305449283486L;\n+            private static final long serialVersionUID = 6718518191249632175L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static EOFException createEOFException(final String pattern,\n                                                   final Object ... arguments) {\n+        return createEOFException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>EOFException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static EOFException createEOFException(final Localizable pattern,\n+                                                  final Object ... arguments) {\n         return new EOFException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = 279461544586092584L;\n+            private static final long serialVersionUID = 6067985859347601503L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n                                                                           final Object ... arguments) {\n+        return createIllegalArgumentException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalArgumentException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static IllegalArgumentException createIllegalArgumentException(final Localizable pattern,\n+                                                                          final Object ... arguments) {\n         return new IllegalArgumentException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = -6555453980658317913L;\n+            private static final long serialVersionUID = -4284649691002411505L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static IllegalStateException createIllegalStateException(final String pattern,\n                                                                     final Object ... arguments) {\n+        return createIllegalStateException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static IllegalStateException createIllegalStateException(final Localizable pattern,\n+                                                                    final Object ... arguments) {\n         return new IllegalStateException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = -95247648156277208L;\n+            private static final long serialVersionUID = 6880901520234515725L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static ConcurrentModificationException createConcurrentModificationException(final String pattern,\n                                                                                         final Object ... arguments) {\n+        return createConcurrentModificationException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ConcurrentModificationException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static ConcurrentModificationException createConcurrentModificationException(final Localizable pattern,\n+                                                                                        final Object ... arguments) {\n         return new ConcurrentModificationException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = 6134247282754009421L;\n+            private static final long serialVersionUID = -1878427236170442052L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static NoSuchElementException createNoSuchElementException(final String pattern,\n                                                                       final Object ... arguments) {\n+        return createNoSuchElementException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NoSuchElementException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static NoSuchElementException createNoSuchElementException(final Localizable pattern,\n+                                                                      final Object ... arguments) {\n         return new NoSuchElementException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = 7304273322489425799L;\n+            private static final long serialVersionUID = 1632410088350355086L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static NullPointerException createNullPointerException(final String pattern,\n                                                                   final Object ... arguments) {\n+        return createNullPointerException(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NullPointerException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static NullPointerException createNullPointerException(final Localizable pattern,\n+                                                                  final Object ... arguments) {\n         return new NullPointerException() {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = -3075660477939965216L;\n+            private static final long serialVersionUID = 451965530686593945L;\n \n             /** {@inheritDoc} */\n             @Override\n     public static ParseException createParseException(final int offset,\n                                                       final String pattern,\n                                                       final Object ... arguments) {\n+        return createParseException(offset, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ParseException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param offset offset at which error occurred\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     * @since 2.2\n+     */\n+    public static ParseException createParseException(final int offset,\n+                                                      final Localizable pattern,\n+                                                      final Object ... arguments) {\n         return new ParseException(null, offset) {\n \n             /** Serializable version identifier. */\n-            private static final long serialVersionUID = -1103502177342465975L;\n+            private static final long serialVersionUID = 8153587599409010120L;\n \n             /** {@inheritDoc} */\n             @Override\n      */\n     public static RuntimeException createInternalError(final Throwable cause) {\n \n-        final String pattern  = \"internal error, please fill a bug report at {0}\";\n         final String argument = \"https://issues.apache.org/jira/browse/MATH\";\n \n         return new RuntimeException() {\n             /** {@inheritDoc} */\n             @Override\n             public String getMessage() {\n-                return buildMessage(Locale.US, pattern, argument);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n-            public String getLocalizedMessage() {\n-                return buildMessage(Locale.getDefault(), pattern, argument);\n+                return buildMessage(Locale.US, LocalizedFormats.INTERNAL_ERROR, argument);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), LocalizedFormats.INTERNAL_ERROR, argument);\n             }\n \n         };\n--- a/src/main/java/org/apache/commons/math/MaxEvaluationsExceededException.java\n+++ b/src/main/java/org/apache/commons/math/MaxEvaluationsExceededException.java\n package org.apache.commons.math;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Error thrown when a numerical computation exceeds its allowed\n     private final int maxEvaluations;\n \n     /**\n-     * Constructs an exception with specified formatted detail message.\n-     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * Constructs an exception with a default detail message.\n      * @param maxEvaluations maximal number of evaluations allowed\n      */\n     public MaxEvaluationsExceededException(final int maxEvaluations) {\n-        super(\"Maximal number of evaluations ({0}) exceeded\", maxEvaluations);\n+        super(LocalizedFormats.MAX_EVALUATIONS_EXCEEDED, maxEvaluations);\n         this.maxEvaluations = maxEvaluations;\n     }\n \n      * @param maxEvaluations the exceeded maximal number of evaluations\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @deprecated as of 2.2 replaced by {@link #MaxEvaluationsExceededException(int, Localizable, Object...)}\n+     */\n+    @Deprecated\n+    public MaxEvaluationsExceededException(final int maxEvaluations,\n+                                          final String pattern, final Object ... arguments) {\n+        this(maxEvaluations, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxEvaluations the exceeded maximal number of evaluations\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n      */\n     public MaxEvaluationsExceededException(final int maxEvaluations,\n-                                          final String pattern, final Object ... arguments) {\n+                                           final Localizable pattern, final Object ... arguments) {\n         super(pattern, arguments);\n         this.maxEvaluations = maxEvaluations;\n     }\n--- a/src/main/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/main/java/org/apache/commons/math/MaxIterationsExceededException.java\n package org.apache.commons.math;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Error thrown when a numerical computation exceeds its allowed\n     private final int maxIterations;\n \n     /**\n-     * Constructs an exception with specified formatted detail message.\n-     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * Constructs an exception with a default detail message.\n      * @param maxIterations maximal number of iterations allowed\n      */\n     public MaxIterationsExceededException(final int maxIterations) {\n-        super(\"Maximal number of iterations ({0}) exceeded\", maxIterations);\n+        super(LocalizedFormats.MAX_ITERATIONS_EXCEEDED, maxIterations);\n         this.maxIterations = maxIterations;\n     }\n \n      * @param maxIterations the exceeded maximal number of iterations\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @deprecated as of 2.2 replaced by {@link #MaxIterationsExceededException(int, Localizable, Object...)}\n+     */\n+    @Deprecated\n+    public MaxIterationsExceededException(final int maxIterations,\n+                                          final String pattern, final Object ... arguments) {\n+        this(maxIterations, new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxIterations the exceeded maximal number of iterations\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n      */\n     public MaxIterationsExceededException(final int maxIterations,\n-                                          final String pattern, final Object ... arguments) {\n+                                           final Localizable pattern, final Object ... arguments) {\n         super(pattern, arguments);\n         this.maxIterations = maxIterations;\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n         // at most 32 bisection refinements due to higher order divider\n         if (maximalIterationCount > 32) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid iteration limits: min={0}, max={1}\",\n+                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n                     0, 32);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n         // at most 64 bisection refinements\n         if (maximalIterationCount > 64) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid iteration limits: min={0}, max={1}\",\n+                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n                     0, 64);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n         // at most 64 bisection refinements\n         if (maximalIterationCount > 64) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid iteration limits: min={0}, max={1}\",\n+                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n                     0, 64);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n import org.apache.commons.math.ConvergingAlgorithmImpl;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Provide a default implementation for several generic functions.\n         throws IllegalArgumentException {\n         super(defaultMaximalIterationCount, 1.0e-15);\n         if (f == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FUNCTION);\n         }\n \n         this.f = f;\n         if (resultComputed) {\n             return result;\n         } else {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n         }\n     }\n \n     protected void verifyIterationCount() throws IllegalArgumentException {\n         if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid iteration limits: min={0}, max={1}\",\n+                    LocalizedFormats.INVALID_ITERATIONS_LIMITS,\n                     minimalIterationCount, maximalIterationCount);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.FunctionEvaluationException;\n         final int yLen = y.length;\n \n         if (xLen == 0 || yLen == 0 || f.length == 0 || f[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xLen != f.length) {\n             throw new DimensionMismatchException(xLen, f.length);\n     public double value(double x, double y) {\n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n-                                                                      x, xval[0], xval[xval.length - 1]);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                  x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n-                                                                      y, yval[0], yval[yval.length - 1]);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                  y, yval[0], yval[yval.length - 1]);\n         }\n \n         final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n \n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       y, yval[0], yval[yval.length - 1]);\n         }\n \n      */\n     public double value(double x, double y) {\n         if (x < 0 || x > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       x, 0, 1);\n         }\n         if (y < 0 || y > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       y, 0, 1);\n         }\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n                                                           final double[][] fval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n      */\n     public LoessInterpolator(double bandwidth, int robustnessIters, double accuracy) throws MathException {\n         if (bandwidth < 0 || bandwidth > 1) {\n-            throw new MathException(\"bandwidth must be in the interval [0,1], but got {0}\",\n+            throw new MathException(LocalizedFormats.BANDWIDTH_OUT_OF_INTERVAL,\n                                     bandwidth);\n         }\n         this.bandwidth = bandwidth;\n         if (robustnessIters < 0) {\n-            throw new MathException(\"the number of robustness iterations must \" +\n-                                    \"be non-negative, but got {0}\",\n-                                    robustnessIters);\n+            throw new MathException(LocalizedFormats.NEGATIVE_ROBUSTNESS_ITERATIONS, robustnessIters);\n         }\n         this.robustnessIters = robustnessIters;\n         this.accuracy = accuracy;\n     public final double[] smooth(final double[] xval, final double[] yval, final double[] weights)\n             throws MathException {\n         if (xval.length != yval.length) {\n-            throw new MathException(\n-                    \"Loess expects the abscissa and ordinate arrays \" +\n-                    \"to be of the same size, \" +\n-                    \"but got {0} abscissae and {1} ordinatae\",\n-                    xval.length, yval.length);\n+            throw new MathException(LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS,\n+                                    xval.length, yval.length);\n         }\n \n         final int n = xval.length;\n \n         if (n == 0) {\n-            throw new MathException(\"Loess expects at least 1 point\");\n-        }\n-\n-        checkAllFiniteReal(xval, \"all abscissae must be finite real numbers, but {0}-th is {1}\");\n-        checkAllFiniteReal(yval, \"all ordinatae must be finite real numbers, but {0}-th is {1}\");\n-        checkAllFiniteReal(weights, \"all weights must be finite real numbers, but {0}-th is {1}\");\n+            throw new MathException(LocalizedFormats.LOESS_EXPECTS_AT_LEAST_ONE_POINT);\n+        }\n+\n+        checkAllFiniteReal(xval, LocalizedFormats.NON_REAL_FINITE_ABSCISSA);\n+        checkAllFiniteReal(yval, LocalizedFormats.NON_REAL_FINITE_ORDINATE);\n+        checkAllFiniteReal(weights, LocalizedFormats.NON_REAL_FINITE_WEIGHT);\n \n         checkStrictlyIncreasing(xval);\n \n         int bandwidthInPoints = (int) (bandwidth * n);\n \n         if (bandwidthInPoints < 2) {\n-            throw new MathException(\n-                    \"the bandwidth must be large enough to \" +\n-                    \"accomodate at least 2 points. There are {0} \" +\n-                    \" data points, and bandwidth must be at least {1} \" +\n-                    \" but it is only {2}\",\n-                    n, 2.0 / n, bandwidth);\n+            throw new MathException(LocalizedFormats.TOO_SMALL_BANDWIDTH,\n+                                    n, 2.0 / n, bandwidth);\n         }\n \n         final double[] res = new double[n];\n     public final double[] smooth(final double[] xval, final double[] yval)\n             throws MathException {\n         if (xval.length != yval.length) {\n-            throw new MathException(\n-                    \"Loess expects the abscissa and ordinate arrays \" +\n-                    \"to be of the same size, \" +\n-                    \"but got {0} abscissae and {1} ordinatae\",\n-                    xval.length, yval.length);\n+            throw new MathException(LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS,\n+                                    xval.length, yval.length);\n         }\n \n         final double[] unitWeights = new double[xval.length];\n      * @param pattern pattern of the error message\n      * @throws MathException if one of the values is not a finite real number\n      */\n-    private static void checkAllFiniteReal(final double[] values, final String pattern)\n+    private static void checkAllFiniteReal(final double[] values, final Localizable pattern)\n         throws MathException {\n         for (int i = 0; i < values.length; i++) {\n             final double x = values[i];\n         throws MathException {\n         for (int i = 0; i < xval.length; ++i) {\n             if (i >= 1 && xval[i - 1] >= xval[i]) {\n-                throw new MathException(\n-                        \"the abscissae array must be sorted in a strictly \" +\n-                        \"increasing order, but the {0}-th element is {1} \" +\n-                        \"whereas {2}-th is {3}\",\n-                        i - 1, xval[i - 1], i, xval[i]);\n+                throw new MathException(LocalizedFormats.OUT_OF_ORDER_ABSCISSA_ARRAY,\n+                                        i - 1, xval[i - 1], i, xval[i]);\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Interpolating function that implements the\n                                             UnitSphereRandomVectorGenerator rand)\n         throws DimensionMismatchException, IllegalArgumentException {\n         if (xval.length == 0 || xval[0] == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n \n         if (xval.length != yval.length) {\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Interpolator that implements the algorithm described in\n     public void setBrightnessExponent(final int brightnessExponent) {\n         if (brightnessExponent < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"brightness exponent should be positive or null, but got {0}\",\n+                LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT,\n                 brightnessExponent);\n         }\n         this.brightnessExponent = brightnessExponent;\n     public void setMicropshereElements(final int elements) {\n         if (microsphereElements < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"number of microsphere elements must be positive, but got {0}\",\n+                LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS,\n                 microsphereElements);\n         }\n         this.microsphereElements = elements;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n                                                           final double[][] zval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xval.length != zval.length) {\n             throw new DimensionMismatchException(xval.length, zval.length);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.fitting.PolynomialFitter;\n                                                           final double[][] fval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n     public PolynomialSplineFunction interpolate(double x[], double y[]) {\n         if (x.length != y.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\", x.length, y.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n         }\n \n         if (x.length < 3) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} points are required, got only {1}\", 3, x.length);\n+                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 3, x.length);\n         }\n \n         // Number of intervals.  The number of data points is n + 1.\n         for (int i = 0; i < n; i++) {\n             if (x[i]  >= x[i + 1]) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n+                      LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n                       i, i+1, x[i], x[i+1]);\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.DimensionMismatchException;\n \n         if (xLen == 0 || yLen == 0 || z.length == 0\n             || f.length == 0 || f[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xLen != f.length) {\n             throw new DimensionMismatchException(xLen, f.length);\n     public double value(double x, double y, double z) {\n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n-                                                                      x, xval[0], xval[xval.length - 1]);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                  x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n-                                                                      y, yval[0], yval[yval.length - 1]);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                  y, yval[0], yval[yval.length - 1]);\n         }\n         final int k = searchIndex(z, zval);\n         if (k == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n-                                                                      z, zval[0], zval[zval.length - 1]);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+                  z, zval[0], zval[zval.length - 1]);\n         }\n \n         final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n      */\n     public double value(double x, double y, double z) {\n         if (x < 0 || x > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       x, 0, 1);\n         }\n         if (y < 0 || y > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       y, 0, 1);\n         }\n         if (z < 0 || z > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                                                       z, 0, 1);\n         }\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n                                                            final double[][][] fval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Immutable representation of a real polynomial function with real coefficients.\n  */\n public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n-    /** Message for empty coefficients array. */\n-    private static final String EMPTY_ARRAY_MESSAGE =\n-        \"empty polynomials coefficients array\";\n-\n     /**\n      * Serialization identifier\n      */\n     public PolynomialFunction(double c[]) {\n         super();\n         if (c.length < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         int l = c.length;\n         while ((l > 1) && (c[l - 1] == 0)) {\n     protected static double evaluate(double[] coefficients, double argument) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         double result = coefficients[n - 1];\n         for (int j = n -2; j >=0; j--) {\n     protected static double[] differentiate(double[] coefficients) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(EMPTY_ARRAY_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         if (n == 1) {\n             return new double[]{0};\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the representation of a real polynomial function in\n         try {\n             return evaluate(x, y, z);\n         } catch (DuplicateSampleAbscissaException e) {\n-            throw new FunctionEvaluationException(e, z, e.getPattern(), e.getArguments());\n+            throw new FunctionEvaluationException(e, z, e.getLocalizablePattern(), e.getArguments());\n         }\n     }\n \n \n         if (x.length != y.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\", x.length, y.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n         }\n \n         if (x.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} points are required, got only {1}\", 2, x.length);\n+                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length);\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the representation of a real polynomial function in\n \n         if (a.length < 1 || c.length < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"empty polynomials coefficients array\");\n+                  LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         if (a.length != c.length + 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"array sizes should have difference 1 ({0} != {1} + 1)\",\n+                  LocalizedFormats.ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1,\n                   a.length, c.length);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Represents a polynomial spline function.\n     public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n         if (knots.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"spline partition must have at least {0} points, got {1}\",\n+                  LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION,\n                   2, knots.length);\n         }\n         if (knots.length - 1 != polynomials.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\",\n+                  LocalizedFormats.POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS,\n                   polynomials.length, knots.length);\n         }\n         if (!isStrictlyIncreasing(knots)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"knot values must be strictly increasing\");\n+                  LocalizedFormats.NOT_STRICTLY_INCREASING_KNOT_VALUES);\n         }\n \n         this.n = knots.length -1;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n      * @since 2.1\n      */\n     public static final int DEFAULT_MAXIMUM_ITERATIONS = 100;\n-\n-    /** Error message for non-bracketing interval. */\n-    private static final String NON_BRACKETING_MESSAGE =\n-        \"function values at endpoints do not have different signs.  \" +\n-        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\";\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7694577816772532779L;\n         clearResult();\n         if ((initial < min) || (initial > max)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+                  LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS,\n                   min, initial, max);\n         }\n \n         }\n \n         throw MathRuntimeException.createIllegalArgumentException(\n-              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+              LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);\n \n     }\n \n             } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+                        LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n  */\n public class LaguerreSolver extends UnivariateRealSolverImpl {\n \n-    /** Message for non-polynomial function. */\n-    private static final String NON_POLYNOMIAL_FUNCTION_MESSAGE =\n-        \"function is not polynomial\";\n-\n-    /** Message for non-positive degree. */\n-    private static final String NON_POSITIVE_DEGREE_MESSAGE =\n-        \"polynomial degree must be positive: degree={0}\";\n-\n     /** polynomial function to solve.\n      * @deprecated as of 2.0 the function is not stored anymore in the instance\n      */\n         if (f instanceof PolynomialFunction) {\n             p = (PolynomialFunction) f;\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(NON_POLYNOMIAL_FUNCTION_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_POLYNOMIAL);\n         }\n     }\n \n \n         // check function type\n         if (!(f instanceof PolynomialFunction)) {\n-            throw MathRuntimeException.createIllegalArgumentException(NON_POLYNOMIAL_FUNCTION_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_POLYNOMIAL);\n         }\n \n         // check for zeros before verifying bracketing\n         int iterationCount = 0;\n         if (n < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_POSITIVE_DEGREE_MESSAGE, n);\n+                  LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE, n);\n         }\n         Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n         for (int i = 0; i <= n; i++) {\n         int n = coefficients.length - 1;\n         if (n < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_POSITIVE_DEGREE_MESSAGE, n);\n+                  LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE, n);\n         }\n         Complex N  = new Complex(n,     0.0);\n         Complex N1 = new Complex(n - 1, 0.0);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n \n             throw new MaxIterationsExceededException(maximalIterationCount);\n         } catch (ClassCastException cce) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_DIFFERENTIABLE);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n         // Verify bracketing\n         if (y0 * y1 >= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"function values at endpoints do not have different signs, \" +\n-                  \"endpoints: [{0}, {1}], values: [{2}, {3}]\",\n-                  min, max, y0, y1);\n+                  LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n         }\n \n         double x2 = x0;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n                                        final double defaultAbsoluteAccuracy) {\n         super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n         if (f == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FUNCTION);\n         }\n         this.f = f;\n         this.defaultFunctionValueAccuracy = 1.0e-15;\n      */\n     protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n         }\n     }\n \n     protected void verifySequence(final double lower, final double initial, final double upper) {\n         if (!isSequence(lower, initial, upper)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+                    LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS,\n                     lower, initial, upper);\n         }\n     }\n         verifyInterval(lower, upper);\n         if (!isBracketing(lower, upper, function)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"function values at endpoints do not have different signs.  \" +\n-                    \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+                    LocalizedFormats.SAME_SIGN_AT_ENDPOINTS,\n                     lower, upper, function.value(lower), function.value(upper));\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverUtils {\n-\n-    /** Message for null function.*/\n-    private static final String NULL_FUNCTION_MESSAGE =\n-        \"function is null\";\n \n     /**\n      * Default constructor.\n             FunctionEvaluationException {\n \n         if (function == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(NULL_FUNCTION_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FUNCTION);\n         }\n         if (maximumIterations <= 0)  {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n+                  LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n         }\n         if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n+                  LocalizedFormats.INVALID_BRACKETING_PARAMETERS,\n                   lowerBound, initial, upperBound);\n         }\n         double a = initial;\n \n         if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                      LocalizedFormats.FAILED_BRACKETING,\n                       numIterations, maximumIterations, initial,\n                       lowerBound, upperBound, a, b, fa, fb);\n         }\n      */\n     private static void setup(UnivariateRealFunction f) {\n         if (f == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(NULL_FUNCTION_MESSAGE);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FUNCTION);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n \n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n \n         if (n <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"cannot compute nth root for null or negative n: {0}\",\n+                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                     n);\n         }\n \n--- a/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n                 toAppendTo, pos);\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"cannot format a {0} instance as a complex number\",\n+                  LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX,\n                   obj.getClass().getName());\n         }\n \n     public void setImaginaryCharacter(String imaginaryCharacter) {\n         if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"empty string for imaginary character\");\n+                  LocalizedFormats.EMPTY_STRING_FOR_IMAGINARY_CHARACTER);\n         }\n         this.imaginaryCharacter = imaginaryCharacter;\n     }\n     public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n         if (imaginaryFormat == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"null imaginary format\");\n+                  LocalizedFormats.NULL_IMAGINARY_FORMAT);\n         }\n         this.imaginaryFormat = imaginaryFormat;\n     }\n     public void setRealFormat(NumberFormat realFormat) {\n         if (realFormat == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"null real format\");\n+                  LocalizedFormats.NULL_REAL_FORMAT);\n         }\n         this.realFormat = realFormat;\n     }\n--- a/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n package org.apache.commons.math.complex;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Static implementations of common\n     public static Complex polar2Complex(double r, double theta) {\n         if (r < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"negative complex module {0}\", r);\n+                  LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n         }\n         return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Base class for continuous distributions.  Default implementations are\n      */\n     public double density(double x) throws MathRuntimeException {\n         throw new MathRuntimeException(new UnsupportedOperationException(),\n-                \"This distribution does not have a density function implemented\");\n+                LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION);\n     }\n \n     /**\n         throws MathException {\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         }\n \n         // by default, do simple root finding using bracketing and default solver.\n                 try {\n                     ret = cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n-                    throw new FunctionEvaluationException(ex, x, ex.getPattern(), ex.getArguments());\n+                    throw new FunctionEvaluationException(ex, x, ex.getLocalizablePattern(), ex.getArguments());\n                 }\n                 if (Double.isNaN(ret)) {\n                     throw new FunctionEvaluationException(x,\n-                        \"Cumulative probability function returned NaN for argument {0} p = {1}\", x, p);\n+                        LocalizedFormats.CUMULATIVE_PROBABILITY_RETURNED_NAN, x, p);\n                 }\n                 return ret;\n             }\n      */\n     public double[] sample(int sampleSize) throws MathException {\n         if (sampleSize <= 0) {\n-            MathRuntimeException.createIllegalArgumentException(\"Sample size must be positive\");\n+            MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, sampleSize);\n         }\n         double[] out = new double[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Base class for probability distributions.\n         throws MathException {\n         if (x0 > x1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                   x0, x1);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n public abstract class AbstractIntegerDistribution extends AbstractDistribution\n     implements IntegerDistribution, Serializable {\n \n-    /** Message for endpoints in wrong order. */\n-    private static final String WRONG_ORDER_ENDPOINTS_MESSAGE =\n-        \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\";\n-\n-    /** Message for out of range point. */\n-    private static final String OUT_OF_RANGE_POINT =\n-        \"{0} out of [{1}, {2}] range\";\n-\n-    /** Serializable version identifier */\n+   /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n \n     /**\n         throws MathException {\n         if (x0 > x1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);\n+                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1);\n         }\n         if (Math.floor(x0) < x0) {\n             return cumulativeProbability(((int) Math.floor(x0)) + 1,\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n         if (x0 > x1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);\n+                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n     public int inverseCumulativeProbability(final double p) throws MathException{\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  OUT_OF_RANGE_POINT, p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         }\n \n         // by default, do simple bisection.\n      */\n     public int[] sample(int sampleSize) throws MathException {\n         if (sampleSize <= 0) {\n-            MathRuntimeException.createIllegalArgumentException(\"Sample size must be positive\");\n+            MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, sampleSize);\n         }\n         int[] out = new int[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n         try {\n             result = cumulativeProbability(argument);\n         } catch (MathException ex) {\n-            throw new FunctionEvaluationException(ex, argument, ex.getPattern(), ex.getArguments());\n+            throw new FunctionEvaluationException(ex, argument, ex.getLocalizablePattern(), ex.getArguments());\n         }\n         if (Double.isNaN(result)) {\n             throw new FunctionEvaluationException(argument,\n-                \"Discrete cumulative probability function returned NaN for argument {0}\", argument);\n+                LocalizedFormats.DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * The default implementation of {@link BinomialDistribution}.\n     private void setNumberOfTrialsInternal(int trials) {\n         if (trials < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"number of trials must be non-negative ({0})\", trials);\n+                    LocalizedFormats.NEGATIVE_NUMBER_OF_TRIALS, trials);\n         }\n         numberOfTrials = trials;\n     }\n     private void setProbabilityOfSuccessInternal(double p) {\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                    LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         }\n         probabilityOfSuccess = p;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Default implementation of\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         } else if (p == 0) {\n             ret = Double.NEGATIVE_INFINITY;\n         } else  if (p == 1) {\n     private void setScaleInternal(double s) {\n         if (s <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"scale must be positive ({0})\", s);\n+                  LocalizedFormats.NOT_POSITIVE_SCALE, s);\n         }\n         scale = s;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * The default implementation of {@link ExponentialDistribution}.\n     private void setMeanInternal(double newMean) {\n         if (newMean <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"mean must be positive ({0})\", newMean);\n+                  LocalizedFormats.NOT_POSITIVE_MEAN, newMean);\n         }\n         this.mean = newMean;\n     }\n \n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Default implementation of\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n \n-    /** Message for non positive degrees of freddom. */\n-    private static final String NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE =\n-        \"degrees of freedom must be positive ({0})\";\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8516354193418641566L;\n \n     private void setNumeratorDegreesOfFreedomInternal(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE, degreesOfFreedom);\n+                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);\n         }\n         this.numeratorDegreesOfFreedom = degreesOfFreedom;\n     }\n     private void setDenominatorDegreesOfFreedomInternal(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE, degreesOfFreedom);\n+                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);\n         }\n         this.denominatorDegreesOfFreedom = degreesOfFreedom;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * The default implementation of {@link GammaDistribution}.\n     private void setAlphaInternal(double newAlpha) {\n         if (newAlpha <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"alpha must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_ALPHA,\n                   newAlpha);\n         }\n         this.alpha = newAlpha;\n     private void setBetaInternal(double newBeta) {\n         if (newBeta <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"beta must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_BETA,\n                   newBeta);\n         }\n         this.beta = newBeta;\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         if (numberOfSuccesses > populationSize) {\n             throw MathRuntimeException\n                     .createIllegalArgumentException(\n-                            \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+                            LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n                             numberOfSuccesses, populationSize);\n         }\n         if (sampleSize > populationSize) {\n             throw MathRuntimeException\n                     .createIllegalArgumentException(\n-                            \"sample size ({0}) must be less than or equal to population size ({1})\",\n+                            LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n                             sampleSize, populationSize);\n         }\n \n     private void setNumberOfSuccessesInternal(int num) {\n         if (num < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"number of successes must be non-negative ({0})\", num);\n+                    LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES, num);\n         }\n         numberOfSuccesses = num;\n     }\n     private void setPopulationSizeInternal(int size) {\n         if (size <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"population size must be positive ({0})\", size);\n+                    LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE, size);\n         }\n         populationSize = size;\n     }\n     private void setSampleSizeInternal(int size) {\n         if (size < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"sample size must be positive ({0})\", size);\n+                    LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, size);\n         }\n         sampleSize = size;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.special.Erf;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Default implementation of\n     private void setStandardDeviationInternal(double sd) {\n         if (sd <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"standard deviation must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION,\n                   sd);\n         }\n         standardDeviation = sd;\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     private void setNumberOfSuccessesInternal(int successes) {\n         if (successes < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"number of successes must be non-negative ({0})\",\n+                  LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES,\n                   successes);\n         }\n         numberOfSuccesses = successes;\n     private void setProbabilityOfSuccessInternal(double p) {\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         }\n         probabilityOfSuccess = p;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n                                           double p) {\n         if (p <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"the Poisson mean must be positive ({0})\", p);\n+                    LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = z;\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Default implementation of\n     private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {\n         if (newDegreesOfFreedom <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"degrees of freedom must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM,\n                   newDegreesOfFreedom);\n         }\n         this.degreesOfFreedom = newDegreesOfFreedom;\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Default implementation of\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n         } else if (p == 0) {\n             ret = 0.0;\n         } else  if (p == 1) {\n     private void setShapeInternal(double alpha) {\n         if (alpha <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"shape must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_SHAPE,\n                   alpha);\n         }\n         this.shape = alpha;\n     private void setScaleInternal(double beta) {\n         if (beta <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"scale must be positive ({0})\",\n+                  LocalizedFormats.NOT_POSITIVE_SCALE,\n                   beta);\n         }\n         this.scale = beta;\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implementation for the {@link ZipfDistribution}.\n         throws IllegalArgumentException {\n         if (n <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid number of elements {0} (must be positive)\",\n-                    n);\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, n, 0);\n         }\n         this.numberOfElements = n;\n     }\n         throws IllegalArgumentException {\n         if (s <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid exponent {0} (must be positive)\",\n+                    LocalizedFormats.NOT_POSITIVE_EXPONENT,\n                     s);\n         }\n         this.exponent = s;\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Base class for implementing estimators.\n     throws EstimationException {\n \n         if (++costEvaluations > maxCostEval) {\n-            throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n+            throw new EstimationException(LocalizedFormats.MAX_EVALUATIONS_EXCEEDED,\n                                           maxCostEval);\n         }\n \n                 new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n             return inverse.getData();\n         } catch (InvalidMatrixException ime) {\n-            throw new EstimationException(\"unable to compute covariances: singular problem\");\n+            throw new EstimationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n         }\n \n     }\n         int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\n-                    \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                     m, p);\n         }\n         double[] errors = new double[problem.getUnboundParameters().length];\n--- a/src/main/java/org/apache/commons/math/estimation/EstimationException.java\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationException.java\n package org.apache.commons.math.estimation;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This class represents exceptions thrown by the estimation solvers.\n      * @param parts to insert in the format (no translation)\n      */\n     public EstimationException(String specifier, Object ... parts) {\n+        this(new DummyLocalizable(specifier), parts);\n+    }\n+\n+    /**\n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public EstimationException(Localizable specifier, Object ... parts) {\n         super(specifier, parts);\n     }\n \n--- a/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class implements a solver for estimation problems.\n                 }\n \n             } catch(InvalidMatrixException e) {\n-                throw new EstimationException(\"unable to solve: singular problem\");\n+                throw new EstimationException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n             }\n \n \n--- a/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n \n import java.io.Serializable;\n import java.util.Arrays;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n         }\n         if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n             throw new EstimationException(\n-                    \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                    LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                     rows, cols);\n         }\n         if (norm2 > ak2) {\n--- a/src/main/java/org/apache/commons/math/fraction/AbstractFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/AbstractFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Common part shared by both {@link FractionFormat} and {@link BigFractionFormat}.\n     public void setDenominatorFormat(final NumberFormat format) {\n         if (format == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"denominator format can not be null\");\n+                LocalizedFormats.NULL_DENOMINATOR_FORMAT);\n         }\n         this.denominatorFormat = format;\n     }\n     public void setNumeratorFormat(final NumberFormat format) {\n         if (format == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"numerator format can not be null\");\n+                LocalizedFormats.NULL_NUMERATOR_FORMAT);\n         }\n         this.numeratorFormat = format;\n     }\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n \n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -5630213147331578515L;\n \n-    /** Message for zero denominator. */\n-    private static final String FORBIDDEN_ZERO_DENOMINATOR =\n-        \"denominator must be different from 0\";\n-\n     /** <code>BigInteger</code> representation of 100. */\n     private static final BigInteger ONE_HUNDRED_DOUBLE = BigInteger.valueOf(100);\n \n      */\n     public BigFraction(BigInteger num, BigInteger den) {\n         if (num == null) {\n-            throw MathRuntimeException.createNullPointerException(\"numerator is null\");\n+            throw MathRuntimeException.createNullPointerException(LocalizedFormats.NULL_NUMERATOR);\n         }\n         if (den == null) {\n-            throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n+            throw MathRuntimeException.createNullPointerException(LocalizedFormats.NULL_DENOMINATOR);\n         }\n         if (BigInteger.ZERO.equals(den)) {\n-            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n         if (BigInteger.ZERO.equals(num)) {\n             numerator   = BigInteger.ZERO;\n      */\n     public BigFraction(final double value) throws IllegalArgumentException {\n         if (Double.isNaN(value)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert NaN value\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n         }\n         if (Double.isInfinite(value)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert infinite value\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n         }\n \n         // compute m and k such that value = m * 2^k\n      */\n     public BigFraction divide(final BigInteger bg) {\n         if (BigInteger.ZERO.equals(bg)) {\n-            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n         return new BigFraction(numerator, denominator.multiply(bg));\n     }\n      */\n     public BigFraction divide(final BigFraction fraction) {\n         if (BigInteger.ZERO.equals(fraction.numerator)) {\n-            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n \n         return multiply(fraction.reciprocal());\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a BigFraction number in proper format or improper format.\n                          toAppendTo, pos);\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot format given object as a fraction number\");\n+                LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n         }\n \n         return ret;\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n \n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n \n     /** A fraction representing \"-1 / 1\". */\n     public static final Fraction MINUS_ONE = new Fraction(-1, 1);\n-\n-    /** Message for zero denominator. */\n-    private static final String ZERO_DENOMINATOR_MESSAGE =\n-        \"zero denominator in fraction {0}/{1}\";\n-\n-    /** Message for overflow. */\n-    private static final String OVERFLOW_MESSAGE =\n-        \"overflow in fraction {0}/{1}, cannot negate\";\n-\n-    /** Message for null fraction. */\n-    private static final String NULL_FRACTION =\n-        \"null fraction\";\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 3698073679419233275L;\n     public Fraction(int num, int den) {\n         if (den == 0) {\n             throw MathRuntimeException.createArithmeticException(\n-                  ZERO_DENOMINATOR_MESSAGE, num, den);\n+                  LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, num, den);\n         }\n         if (den < 0) {\n             if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                 throw MathRuntimeException.createArithmeticException(\n-                      OVERFLOW_MESSAGE, num, den);\n+                      LocalizedFormats.OVERFLOW_IN_FRACTION, num, den);\n             }\n             num = -num;\n             den = -den;\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n             throw MathRuntimeException.createArithmeticException(\n-                  OVERFLOW_MESSAGE, numerator, denominator);\n+                  LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n         }\n         return new Fraction(-numerator, denominator);\n     }\n      */\n     private Fraction addSub(Fraction fraction, boolean isAdd) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FRACTION);\n         }\n         // zero is identity for addition.\n         if (numerator == 0) {\n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n-            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                                                  w);\n         }\n         return new Fraction (w.intValue(),\n      */\n     public Fraction multiply(Fraction fraction) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FRACTION);\n         }\n         if (numerator == 0 || fraction.numerator == 0) {\n             return ZERO;\n      */\n     public Fraction divide(Fraction fraction) {\n         if (fraction == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(NULL_FRACTION);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_FRACTION);\n         }\n         if (fraction.numerator == 0) {\n             throw MathRuntimeException.createArithmeticException(\n-                    \"the fraction to divide by must not be zero: {0}/{1}\",\n+                    LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                     fraction.numerator, fraction.denominator);\n         }\n         return multiply(fraction.reciprocal());\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n             throw MathRuntimeException.createArithmeticException(\n-                  ZERO_DENOMINATOR_MESSAGE, numerator, denominator);\n+                  LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n                 throw MathRuntimeException.createArithmeticException(\n-                      OVERFLOW_MESSAGE, numerator, denominator);\n+                      LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n--- a/src/main/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionConversionException.java\n package org.apache.commons.math.fraction;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Error thrown when a double value cannot be converted to a fraction\n      * @param maxIterations maximal number of iterations allowed\n      */\n     public FractionConversionException(double value, int maxIterations) {\n-        super(\"Unable to convert {0} to fraction after {1} iterations\", value, maxIterations);\n+        super(LocalizedFormats.FAILED_FRACTION_CONVERSION, value, maxIterations);\n     }\n \n     /**\n      * @param q current denominator\n      */\n     public FractionConversionException(double value, long p, long q) {\n-        super(\"Overflow trying to convert {0} to fraction ({1}/{2})\", value, p, q);\n+        super(LocalizedFormats.FRACTION_CONVERSION_OVERFLOW, value, p, q);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a Fraction number in proper format or improper format.  The number\n                              toAppendTo, pos);\n             } catch (ConvergenceException ex) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                    \"cannot convert given object to a fraction number: {0}\",\n+                    LocalizedFormats.CANNOT_CONVERT_OBJECT_TO_FRACTION,\n                     ex.getLocalizedMessage());\n             }\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot format given object as a fraction number\");\n+                LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n         }\n \n         return ret;\n--- a/src/main/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n import java.text.ParsePosition;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a BigFraction number in proper format.  The number format for each of\n     public void setWholeFormat(final NumberFormat format) {\n         if (format == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"whole format can not be null\");\n+                LocalizedFormats.NULL_WHOLE_FORMAT);\n         }\n         this.wholeFormat = format;\n     }\n--- a/src/main/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n import java.text.ParsePosition;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     public void setWholeFormat(NumberFormat format) {\n         if (format == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"whole format can not be null\");\n+                LocalizedFormats.NULL_WHOLE_FORMAT);\n         }\n         this.wholeFormat = format;\n     }\n--- a/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n package org.apache.commons.math.geometry;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** This class represents exceptions thrown while extractiong Cardan\n  * or Euler angles from a rotation.\n      * if false it is related to EulerAngles\n      */\n     public CardanEulerSingularityException(boolean isCardan) {\n-        super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n+        super(isCardan ? LocalizedFormats.CARDAN_ANGLES_SINGULARITY : LocalizedFormats.EULER_ANGLES_SINGULARITY);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n package org.apache.commons.math.geometry;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This class represents exceptions thrown while building rotations\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n+     * @deprecated as of 2.2 replaced by {@link #NotARotationMatrixException(Localizable, Object...)}\n      */\n+    @Deprecated\n     public NotARotationMatrixException(String specifier, Object ... parts) {\n         super(specifier, parts);\n     }\n \n+    /**\n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     * @since 2.2\n+     */\n+    public NotARotationMatrixException(Localizable specifier, Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Rotation.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n \n     double norm = axis.getNorm();\n     if (norm == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\");\n+      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n     }\n \n     double halfAngle = -0.5 * angle;\n     if ((m.length != 3) || (m[0].length != 3) ||\n         (m[1].length != 3) || (m[2].length != 3)) {\n       throw new NotARotationMatrixException(\n-              \"a {0}x{1} matrix cannot be a rotation matrix\",\n+              LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n               m.length, m[0].length);\n     }\n \n                  ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n     if (det < 0.0) {\n       throw new NotARotationMatrixException(\n-              \"the closest orthogonal matrix has a negative determinant {0}\",\n+              LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n               det);\n     }\n \n   double v1v1 = Vector3D.dotProduct(v1, v1);\n   double v2v2 = Vector3D.dotProduct(v2, v2);\n   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n-    throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n+    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n   }\n \n   double u1x = u1.getX();\n \n     double normProduct = u.getNorm() * v.getNorm();\n     if (normProduct == 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n+        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n     }\n \n     double dot = Vector3D.dotProduct(u, v);\n \n     // the algorithm did not converge after 10 iterations\n     throw new NotARotationMatrixException(\n-            \"unable to orthogonalize matrix in {0} iterations\",\n+            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n             i - 1);\n   }\n \n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n   public Vector3D normalize() {\n     double s = getNorm();\n     if (s == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+      throw MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n     }\n     return scalarMultiply(1 / s);\n   }\n \n     double threshold = 0.6 * getNorm();\n     if (threshold == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM);\n     }\n \n     if ((x >= -threshold) && (x <= threshold)) {\n \n     double normProduct = v1.getNorm() * v2.getNorm();\n     if (normProduct == 0) {\n-      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM);\n     }\n \n     double dot = dotProduct(v1, v2);\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3DFormat.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a 3D vector in components list format \"{x; y; z}\".\n             return format( (Vector3D)obj, toAppendTo, pos);\n         }\n \n-        throw MathRuntimeException.createIllegalArgumentException(\"cannot format a {0} instance as a 3D vector\",\n+        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR,\n                                                                   obj.getClass().getName());\n \n     }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Basic implementation of {@link FieldMatrix} methods regardless of the underlying storage.\n     protected AbstractFieldMatrix(final Field<T> field,\n                                   final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n-        if (rowDimension <= 0 ) {\n+        if (rowDimension < 1 ) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid row dimension {0} (must be positive)\",\n-                    rowDimension);\n-        }\n-        if (columnDimension <= 0) {\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n+        }\n+        if (columnDimension < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid column dimension {0} (must be positive)\",\n-                    columnDimension);\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n         }\n         this.field = field;\n     }\n     protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n         throws IllegalArgumentException {\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         if (d[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         return d[0][0].getField();\n     }\n     protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d)\n         throws IllegalArgumentException {\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         return d[0].getField();\n     }\n         final int columnsCount = endColumn + 1 - startColumn;\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     destination.length, destination[0].length,\n                     rowsCount, columnsCount);\n         }\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     destination.length, destination[0].length,\n                     selectedRows.length, selectedColumns.length);\n         }\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         nCols, subMatrix[r].length);\n             }\n         }\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, vector.getDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     vector.getDimension(), 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, array.length, 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     array.length, 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nCols);\n         }\n \n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         v.getDimension(), nCols);\n             }\n \n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nRows);\n         }\n \n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         v.getDimension(), nRows);\n             }\n \n         checkRowIndex(startRow);\n         checkRowIndex(endRow);\n         if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n                                            startRow, endRow);\n         }\n \n         checkColumnIndex(startColumn);\n         checkColumnIndex(endColumn);\n         if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                            startColumn, endColumn);\n         }\n \n     protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\");\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\");\n+                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n+            }\n+            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n         }\n \n         for (final int row : selectedRows) {\n         if ((getRowDimension()    != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    LocalizedFormats.NOT_ADDITION_COMPATIBLE_MATRICES,\n                     getRowDimension(), getColumnDimension(),\n                     m.getRowDimension(), m.getColumnDimension());\n         }\n         if ((getRowDimension()    != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    LocalizedFormats.NOT_SUBTRACTION_COMPATIBLE_MATRICES,\n                     getRowDimension(), getColumnDimension(),\n                     m.getRowDimension(), m.getColumnDimension());\n         }\n     protected void checkMultiplicationCompatible(final FieldMatrix<T> m) {\n         if (getColumnDimension() != m.getRowDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    LocalizedFormats.NOT_MULTIPLICATION_COMPATIBLE_MATRICES,\n                     getRowDimension(), getColumnDimension(),\n                     m.getRowDimension(), m.getColumnDimension());\n         }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n      */\n     protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n-        if (rowDimension <= 0 ) {\n+        if (rowDimension < 1 ) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid row dimension {0} (must be positive)\",\n-                    rowDimension);\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n         }\n         if (columnDimension <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid column dimension {0} (must be positive)\",\n-                    columnDimension);\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n         }\n         lu = null;\n     }\n         final int columnsCount = endColumn + 1 - startColumn;\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     destination.length, destination[0].length,\n                     rowsCount, columnsCount);\n         }\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     destination.length, destination[0].length,\n                     selectedRows.length, selectedColumns.length);\n         }\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         nCols, subMatrix[r].length);\n             }\n         }\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, vector.getDimension(), 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     vector.getDimension(), 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, array.length, 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     array.length, 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nCols);\n         }\n \n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         v.getDimension(), nCols);\n             }\n \n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nRows);\n         }\n \n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         v.getDimension(), nRows);\n             }\n \n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.analysis.BinaryFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.ComposableFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class provides default basic implementations for many methods in the\n         double d = getDimension();\n         if (d != n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"vector length mismatch: got {0} but expected {1}\",\n-                  d, n);\n+                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, d, n);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implementation of FieldMatrix<T> using a {@link FieldElement}[][] array to store entries.\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7260756672015356458L;\n-\n-    /** Message for at least one row. */\n-    private static final String AT_LEAST_ONE_ROW_MESSAGE =\n-        \"matrix must have at least one row\";\n-\n-    /** Message for at least one column. */\n-    private static final String AT_LEAST_ONE_COLUMN_MESSAGE =\n-        \"matrix must have at least one column\";\n-\n-    /** Message for different rows lengths. */\n-    private static final String DIFFERENT_ROWS_LENGTHS_MESSAGE =\n-        \"some rows have length {0} while others have length {1}\";\n-\n-    /** Message for no entry at selected indices. */\n-    private static final String NO_ENTRY_MESSAGE =\n-        \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\";\n-\n-    /** Message for vector lengths mismatch. */\n-    private static final String VECTOR_LENGTHS_MISMATCH =\n-        \"vector length mismatch: got {0} but expected {1}\";\n \n     /** Entries of the matrix */\n     protected T[][] data;\n             final int nRows = d.length;\n             if (nRows == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_ROW_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_COLUMN_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n+                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n                 }\n             }\n             data = d;\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                      \"first {0} rows are not initialized yet\", row);\n+                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                      \"first {0} columns are not initialized yet\", column);\n+                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_ROW_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_COLUMN_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = buildArray(getField(), subMatrix.length, nCols);\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, subMatrix[i].length);\n+                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = data[row][column].add(increment);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = data[row][column].multiply(factor);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  VECTOR_LENGTHS_MISMATCH, v.length, nCols);\n+                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nCols);\n         }\n         final T[] out = buildArray(getField(), nRows);\n         for (int row = 0; row < nRows; row++) {\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  VECTOR_LENGTHS_MISMATCH, v.length, nRows);\n+                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nRows);\n         }\n \n         final T[] out = buildArray(getField(), nCols);\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implementation of RealMatrix using a double[][] array to store entries and\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1067294169172445528L;\n \n-    /** Message for at least one row. */\n-    private static final String AT_LEAST_ONE_ROW_MESSAGE =\n-        \"matrix must have at least one row\";\n-\n-    /** Message for at least one column. */\n-    private static final String AT_LEAST_ONE_COLUMN_MESSAGE =\n-        \"matrix must have at least one column\";\n-\n-    /** Message for different rows lengths. */\n-    private static final String DIFFERENT_ROWS_LENGTHS_MESSAGE =\n-        \"some rows have length {0} while others have length {1}\";\n-\n-    /** Message for no entry at selected indices. */\n-    private static final String NO_ENTRY_MESSAGE =\n-        \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\";\n-\n-    /** Message for vector lengths mismatch. */\n-    private static final String VECTOR_LENGTHS_MISMATCH =\n-        \"vector length mismatch: got {0} but expected {1}\";\n-\n     /** Entries of the matrix */\n     protected double data[][];\n \n             final int nRows = d.length;\n             if (nRows == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_ROW_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_COLUMN_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n+                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n                 }\n             }\n             data = d;\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                      \"first {0} rows are not initialized yet\", row);\n+                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                      \"first {0} columns are not initialized yet\", column);\n+                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_ROW_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      AT_LEAST_ONE_COLUMN_MESSAGE);\n+                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, subMatrix[i].length);\n+                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n             data[row][column] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n+                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  VECTOR_LENGTHS_MISMATCH, v.length, nCols);\n+                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nCols);\n         }\n         final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  VECTOR_LENGTHS_MISMATCH, v.length, nRows);\n+                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class implements the {@link FieldVector} interface with a {@link FieldElement} array.\n             data = d.clone();\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                      \"vector must have at least one element\");\n+                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n     }\n \n             data = copyArray ? d.clone() :  d;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                      \"vector must have at least one element\");\n+                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n     }\n \n     public ArrayFieldVector(T[] d, int pos, int size) {\n         if (d.length < pos + size) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY,\n                     pos, size, d.length);\n         }\n         field = d[0].getField();\n             field = data[0].getField();\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                      \"vector must have at least one element\");\n+                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n     }\n \n         throws IllegalArgumentException {\n         if (data.length != n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     data.length, n);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n import java.util.Iterator;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n  * @since 2.0\n  */\n public class ArrayRealVector extends AbstractRealVector implements Serializable {\n-\n-    /** Message for non fitting position and size. */\n-    private static final String NON_FITTING_POSITION_AND_SIZE_MESSAGE =\n-        \"position {0} and size {1} don't fit to the size of the input array {2}\";\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1097961340710804027L;\n             throw new NullPointerException();\n         }\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n         data = copyArray ? d.clone() :  d;\n     }\n     public ArrayRealVector(double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n+                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);\n         }\n         data = new double[size];\n         System.arraycopy(d, pos, data, 0, size);\n     public ArrayRealVector(Double[] d, int pos, int size) {\n         if (d.length < pos + size) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_FITTING_POSITION_AND_SIZE_MESSAGE, pos, size, d.length);\n+                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);\n         }\n         data = new double[size];\n         for (int i = pos; i < pos + size; i++) {\n     public RealVector unitVector() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         return mapDivide(norm);\n     }\n     public void unitize() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n         }\n         mapDivideToSelf(norm);\n     }\n         throws IllegalArgumentException {\n         if (data.length != n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     data.length, n);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n import java.math.BigDecimal;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries\n      *  positive\n      */\n     public BigMatrixImpl(int rowDimension, int columnDimension) {\n-        if (rowDimension <= 0 ) {\n+        if (rowDimension < 1 ) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid row dimension {0} (must be positive)\",\n-                    rowDimension);\n-        }\n-        if (columnDimension <= 0) {\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n+        }\n+        if (columnDimension < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid column dimension {0} (must be positive)\",\n-                    columnDimension);\n+                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n         }\n         data = new BigDecimal[rowDimension][columnDimension];\n         lu = null;\n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          \"some rows have length {0} while others have length {1}\",\n+                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                           nCols, d[r].length);\n                 }\n             }\n     public BigMatrixImpl(double[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"some rows have length {0} while others have length {1}\",\n+                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                       nCols, d[row].length);\n             }\n         }\n     public BigMatrixImpl(String[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"some rows have length {0} while others have length {1}\",\n+                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                       nCols, d[row].length);\n             }\n         }\n         MatrixUtils.checkRowIndex(this, startRow);\n         MatrixUtils.checkRowIndex(this, endRow);\n         if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n                                            startRow, endRow);\n         }\n \n         MatrixUtils.checkColumnIndex(this, startColumn);\n         MatrixUtils.checkColumnIndex(this, endColumn);\n         if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                            startColumn, endColumn);\n         }\n \n \n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\");\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\");\n+                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n+            }\n+            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n         }\n \n         final BigDecimal[][] subMatrixData =\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n \n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"some rows have length {0} while others have length {1}\",\n+                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                       nCols, subMatrix[r].length);\n             }\n         }\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} rows are not initialized yet\",\n+                        LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET,\n                         row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} columns are not initialized yet\",\n+                        LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET,\n                         column);\n             }\n             data = new BigDecimal[nRows][nCols];\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n     public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n         if (v.length != getColumnDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, getColumnDimension() );\n         }\n         final int nRows = this.getRowDimension();\n         final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nRows );\n         }\n         final int nCols = this.getColumnDimension();\n         final int nRows = this.getRowDimension();\n         if (b.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     b.length, nRows);\n         }\n         final BigMatrix bMatrix = new BigMatrixImpl(b);\n     public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n         if (b.getRowDimension() != getRowDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     b.getRowDimension(), b.getColumnDimension(), getRowDimension(), \"n\");\n         }\n         if (!isSquare()) {\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Cache-friendly implementation of FieldMatrix using a flat arrays to store\n             final int length = rawData[i].length;\n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         columns, length);\n             }\n         }\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         for (final T[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         refLength, subRow.length);\n             }\n         }\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(),\n                     1, nCols);\n         }\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(),\n                     nRows, 1);\n         }\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, array.length, 1, nCols);\n         }\n \n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     array.length, 1, nRows, 1);\n         }\n \n             return blocks[iBlock * blockColumns + jBlock][k];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blocks[iBlock * blockColumns + jBlock][k] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blockIJ[k] = blockIJ[k].add(increment);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blockIJ[k] = blockIJ[k].multiply(factor);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         if (v.length != columns) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, columns);\n         }\n         final T[] out = buildArray(getField(), rows);\n \n         if (v.length != rows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, rows);\n         }\n         final T[] out = buildArray(getField(), columns);\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n import java.util.Arrays;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Cache-friendly implementation of RealMatrix using a flat arrays to store\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                 if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            LocalizedFormats.WRONG_BLOCK_LENGTH,\n                             blockData[index].length, iHeight * blockWidth(jBlock));\n                 }\n                 if (copyArray) {\n             final int length = rawData[i].length;\n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         columns, length);\n             }\n         }\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         for (final double[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"some rows have length {0} while others have length {1}\",\n+                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                         refLength, subRow.length);\n             }\n         }\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(),\n                     1, nCols);\n         }\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     matrix.getRowDimension(), matrix.getColumnDimension(),\n                     nRows, 1);\n         }\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     1, array.length, 1, nCols);\n         }\n \n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n-                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                     array.length, 1, nRows, 1);\n         }\n \n             return blocks[iBlock * blockColumns + jBlock][k];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blocks[iBlock * blockColumns + jBlock][k] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blocks[iBlock * blockColumns + jBlock][k] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             blocks[iBlock * blockColumns + jBlock][k] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n \n         if (v.length != columns) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, columns);\n         }\n         final double[] out = new double[rows];\n \n         if (v.length != rows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, rows);\n         }\n         final double[] out = new double[columns];\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n             final int m = lTData.length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         b.length, m);\n             }\n \n                 final int m = lTData.length;\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"vector length mismatch: got {0} but expected {1}\",\n+                            LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                             b.getDimension(), m);\n                 }\n \n             final int m = lTData.length;\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                         b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n \n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n             // NOT supported\n             // see issue https://issues.apache.org/jira/browse/MATH-235\n             throw new InvalidMatrixException(\n-                    \"eigen decomposition of assymetric matrices not supported yet\");\n+                    LocalizedFormats.ASSYMETRIC_EIGEN_NOT_SUPPORTED);\n         }\n     }\n \n             final int m = realEigenvalues.length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         b.length, m);\n             }\n \n             final int m = realEigenvalues.length;\n             if (b.getDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\", b\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH, b\n                                 .getDimension(), m);\n             }\n \n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException\n                         .createIllegalArgumentException(\n-                                \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                                LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                                 b.getRowDimension(), b.getColumnDimension(), m,\n                                 \"n\");\n             }\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n             final int m = pivot.length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         b.length, m);\n             }\n             if (singular) {\n                 final int m = pivot.length;\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"vector length mismatch: got {0} but expected {1}\",\n+                            LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                             b.getDimension(), m);\n                 }\n                 if (singular) {\n             final int m = pivot.length;\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                         b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n             if (singular) {\n--- a/src/main/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/InvalidMatrixException.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Thrown when a system attempts an operation on a matrix, and\n public class InvalidMatrixException extends MathRuntimeException {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 1135533765052675495L;\n+    private static final long serialVersionUID = -2068020346562029801L;\n \n     /**\n      * Construct an exception with the given message.\n      * @since 2.0\n      */\n     public InvalidMatrixException(final String pattern, final Object ... arguments) {\n+        this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public InvalidMatrixException(final Localizable pattern, final Object ... arguments) {\n         super(pattern, arguments);\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n     /** Default bound to determine effective singularity in LU decomposition */\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n \n-    /** Message for vector length mismatch. */\n-    private static final String VECTOR_LENGTH_MISMATCH_MESSAGE =\n-        \"vector length mismatch: got {0} but expected {1}\";\n-\n     /** Entries of LU decomposition. */\n     private double lu[][];\n \n             final int m = pivot.length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        VECTOR_LENGTH_MISMATCH_MESSAGE, b.length, m);\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH, b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n                 final int m = pivot.length;\n                 if (b.getDimension() != m) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            VECTOR_LENGTH_MISMATCH_MESSAGE, b.getDimension(), m);\n+                            LocalizedFormats.VECTOR_LENGTH_MISMATCH, b.getDimension(), m);\n                 }\n                 if (singular) {\n                     throw new SingularMatrixException();\n             final int m = pivot.length;\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                         b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n             if (singular) {\n--- a/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Thrown when an operation addresses a matrix coordinate (row, col)\n public class MatrixIndexException extends MathRuntimeException {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -2382324504109300625L;\n+    private static final long serialVersionUID = 8120540015829487660L;\n \n     /**\n      * Constructs a new instance with specified formatted detail message.\n      * @param arguments format arguments\n      */\n     public MatrixIndexException(final String pattern, final Object ... arguments) {\n+      this(new DummyLocalizable(pattern), arguments);\n+    }\n+\n+    /**\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n+     */\n+    public MatrixIndexException(final Localizable pattern, final Object ... arguments) {\n       super(pattern, arguments);\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * A collection of static methods that operate on or return matrices.\n         createRowFieldMatrix(final T[] rowData) {\n         final int nCols = rowData.length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n         createColumnFieldMatrix(final T[] columnData) {\n         final int nRows = columnData.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n         for (int i = 0; i < nRows; ++i) {\n         checkRowIndex(m, startRow);\n         checkRowIndex(m, endRow);\n         if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n                                            startRow, endRow);\n         }\n \n         checkColumnIndex(m, startColumn);\n         checkColumnIndex(m, endColumn);\n         if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                            startColumn, endColumn);\n         }\n \n         throws MatrixIndexException {\n         if (selectedRows.length * selectedColumns.length == 0) {\n             if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\");\n+                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n             }\n-            throw new MatrixIndexException(\"empty selected column index array\");\n+            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n         }\n \n         for (final int row : selectedRows) {\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    LocalizedFormats.NOT_ADDITION_COMPATIBLE_MATRICES,\n                     left.getRowDimension(), left.getColumnDimension(),\n                     right.getRowDimension(), right.getColumnDimension());\n         }\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    LocalizedFormats.NOT_SUBTRACTION_COMPATIBLE_MATRICES,\n                     left.getRowDimension(), left.getColumnDimension(),\n                     right.getRowDimension(), right.getColumnDimension());\n         }\n         throws IllegalArgumentException {\n         if (left.getColumnDimension() != right.getRowDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    LocalizedFormats.NOT_MULTIPLICATION_COMPATIBLE_MATRICES,\n                     left.getRowDimension(), left.getColumnDimension(),\n                     right.getRowDimension(), right.getColumnDimension());\n         }\n--- a/src/main/java/org/apache/commons/math/linear/MatrixVisitorException.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixVisitorException.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Thrown when a visitor encounters an error while processing a matrix entry.\n      * Constructs a new instance with specified formatted detail message.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @deprecated as of 2.2 replaced by {@link #MatrixVisitorException(Localizable, Object...)}\n      */\n+    @Deprecated\n     public MatrixVisitorException(final String pattern, final Object[] arguments) {\n       super(pattern, arguments);\n     }\n \n+    /**\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.2\n+     */\n+    public MatrixVisitorException(final Localizable pattern, final Object[] arguments) {\n+      super(pattern, arguments);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n+\n \n /**\n  * Thrown when an operation defined only for square matrices is applied to non-square ones.\n      * @param columns number of columns of the faulty matrix\n      */\n     public NonSquareMatrixException(final int rows, final int columns) {\n-        super(\"a {0}x{1} matrix was provided instead of a square matrix\",\n-              rows, columns);\n+        super(LocalizedFormats.NON_SQUARE_MATRIX, rows, columns);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class represents exceptions thrown when a matrix expected to\n      * build an exception with a default message.\n      */\n     public NotPositiveDefiniteMatrixException() {\n-        super(\"not positive definite matrix\");\n+        super(LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class represents exceptions thrown when a matrix expected to\n      * build an exception with a default message.\n      */\n     public NotSymmetricMatrixException() {\n-        super(\"not symmetric matrix\");\n+        super(LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n \n     public void unitize() {\n         double norm = getNorm();\n         if (isDefaultValue(norm)) {\n-            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+            throw  MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n         }\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n import java.util.Arrays;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n             final int m = qrt[0].length;\n             if (b.length != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n+                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                         b.length, m);\n             }\n             if (!isNonSingular()) {\n             final int m = qrt[0].length;\n             if (b.getRowDimension() != m) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                         b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n             }\n             if (!isNonSingular()) {\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implementation of RealMatrix using a double[][] array to store entries and\n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n+                            LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                             nCols, d[r].length);\n                 }\n             }\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} rows are not initialized yet\",\n+                        LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET,\n                         row);\n             }\n             if (column > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n-                        \"first {0} columns are not initialized yet\",\n+                        LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET,\n                         column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            \"some rows have length {0} while others have length {1}\",\n+                            LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                             nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             data[row][column] = value;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             data[row][column] += increment;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n             data[row][column] *= factor;\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\n-                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nCols);\n         }\n         final double[] out = new double[nRows];\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     v.length, nRows);\n         }\n \n--- a/src/main/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVectorFormat.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Formats a vector in components list format \"{v0; v1; ...; vk-1}\".\n         }\n \n         throw MathRuntimeException.createIllegalArgumentException(\n-              \"cannot format a {0} instance as a real vector\",\n+              LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR,\n               obj.getClass().getName());\n \n     }\n--- a/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n+\n \n /**\n  * Thrown when a matrix is singular.\n      * Construct an exception with a default message.\n      */\n     public SingularMatrixException() {\n-        super(\"matrix is singular\");\n+        super(LocalizedFormats.SINGULAR_MATRIX);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Calculates the compact Singular Value Decomposition of a matrix.\n \n         if (dimension == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"cutoff singular value is {0}, should be at most {1}\",\n+                    LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,\n                     minSingularValue, singularValues[0]);\n         }\n \n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.OpenIntToFieldHashMap;\n \n /**\n     protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n         if (getDimension() != n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"vector length mismatch: got {0} but expected {1}\",\n+                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n                     getDimension(), n);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.events.EventState;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Base class managing common boilerplate for all integrators.\n \n         if (ode.getDimension() != y0.length) {\n             throw new IntegratorException(\n-                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n-                    \" initial state vector has dimension {1}\",\n-                    ode.getDimension(), y0.length);\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, ode.getDimension(), y0.length);\n         }\n \n         if (ode.getDimension() != y.length) {\n             throw new IntegratorException(\n-                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n-                    \" final state vector has dimension {1}\",\n-                    ode.getDimension(), y.length);\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, ode.getDimension(), y.length);\n         }\n \n         if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n             throw new IntegratorException(\n-                    \"too small integration interval: length = {0}\",\n+                    LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                     Math.abs(t - t0));\n         }\n \n--- a/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class stores all information provided by an ODE integrator\n \n       if (getInterpolatedState().length != model.getInterpolatedState().length) {\n           throw MathRuntimeException.createIllegalArgumentException(\n-                \"dimension mismatch {0} != {1}\",\n+                LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                 getInterpolatedState().length, model.getInterpolatedState().length);\n       }\n \n       if (forward ^ model.forward) {\n           throw MathRuntimeException.createIllegalArgumentException(\n-                \"propagation direction mismatch\");\n+                LocalizedFormats.PROPAGATION_DIRECTION_MISMATCH);\n       }\n \n       final StepInterpolator lastInterpolator = steps.get(index);\n       final double gap = model.getInitialTime() - current;\n       if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n         throw MathRuntimeException.createIllegalArgumentException(\n-              \"{0} wide hole between models time ranges\", Math.abs(gap));\n+              LocalizedFormats.HOLE_BETWEEN_MODELS_TIME_RANGES, Math.abs(gap));\n       }\n \n     }\n--- a/src/main/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/main/java/org/apache/commons/math/ode/DerivativeException.java\n package org.apache.commons.math.ode;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This exception is made available to users to report\n    * Build an exception by translating and formating a message\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n+   * @deprecated as of 2.2 replaced by {@link #DerivativeException(Localizable, Object...)}\n    */\n+  @Deprecated\n   public DerivativeException(final String specifier, final Object ... parts) {\n+    this(new DummyLocalizable(specifier), parts);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public DerivativeException(final Localizable specifier, final Object ... parts) {\n     super(specifier, parts);\n   }\n \n-  /** Build an instance from an underlying cause.\n+ /** Build an instance from an underlying cause.\n    * @param cause cause for the exception\n    */\n   public DerivativeException(final Throwable cause) {\n--- a/src/main/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/main/java/org/apache/commons/math/ode/IntegratorException.java\n package org.apache.commons.math.ode;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This exception is made available to users to report\n   /** Serializable version identifier */\n     private static final long serialVersionUID = -1607588949778036796L;\n \n-  /** Simple constructor.\n-   * Build an exception by translating and formating a message\n-   * @param specifier format specifier (to be translated)\n-   * @param parts to insert in the format (no translation)\n-   */\n-  public IntegratorException(final String specifier, final Object ... parts) {\n-    super(specifier, parts);\n-  }\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     * @deprecated as of 2.2 replaced by {@link #IntegratorException(Localizable, Object...)}\n+     */\n+    @Deprecated\n+    public IntegratorException(final String specifier, final Object ... parts) {\n+      super(specifier, parts);\n+    }\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public IntegratorException(final Localizable specifier, final Object ... parts) {\n+      super(specifier, parts);\n+    }\n \n   /**\n    * Create an exception with a given root cause.\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class is the base class for multistep integrators for Ordinary\n \n         if (nSteps <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"{0} method needs at least one previous point\",\n+                  LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT,\n                   name);\n         }\n \n--- a/src/main/java/org/apache/commons/math/ode/events/EventException.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventException.java\n package org.apache.commons.math.ode.events;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This exception is made available to users to report\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n+     * @deprecated as of 2.2 replaced by {@link #EventException(Localizable, Object...)}\n      */\n+     @Deprecated\n     public EventException(final String specifier, final Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     * @since 2.2\n+     */\n+    public EventException(final Localizable specifier, final Object ... parts) {\n         super(specifier, parts);\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** This class enhances a first order integrator for differential equations to\n  * compute also partial derivatives of the solution with respect to initial state\n         int arrayDimension = (array == null) ? 0 : Array.getLength(array);\n         if (arrayDimension != expected) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\", arrayDimension, expected);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, arrayDimension, expected);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This abstract class holds the common part of all adaptive\n \n       if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n           throw new IntegratorException(\n-                  \"dimensions mismatch: state vector has dimension {0},\" +\n-                  \" absolute tolerance vector has dimension {1}\",\n-                  y0.length, vecAbsoluteTolerance.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, y0.length, vecAbsoluteTolerance.length);\n       }\n \n       if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n           throw new IntegratorException(\n-                  \"dimensions mismatch: state vector has dimension {0},\" +\n-                  \" relative tolerance vector has dimension {1}\",\n-                  y0.length, vecRelativeTolerance.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, y0.length, vecRelativeTolerance.length);\n       }\n \n   }\n               filteredH = forward ? minStep : -minStep;\n           } else {\n               throw new IntegratorException(\n-                      \"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\",\n+                      LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,\n                       minStep, Math.abs(h));\n           }\n       }\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** This class converts {@link MultivariateVectorialFunction vectorial\n  * objective functions} to {@link MultivariateRealFunction scalar objective functions}\n         throws IllegalArgumentException {\n         if (observations.length != weights.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimension mismatch {0} != {1}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                     observations.length, weights.length);\n         }\n         this.function     = function;\n         throws IllegalArgumentException {\n         if (observations.length != scale.getColumnDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"dimension mismatch {0} != {1}\",\n+                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                     observations.length, scale.getColumnDimension());\n         }\n         this.function     = function;\n         // compute residuals\n         final double[] residuals = function.value(point);\n         if (residuals.length != observations.length) {\n-            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                   residuals.length, observations.length);\n         }\n         for (int i = 0; i < residuals.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Special implementation of the {@link DifferentiableMultivariateRealOptimizer} interface adding\n      */\n     public RealPointValuePair[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n         return optima.clone();\n     }\n \n         if (optima[0] == null) {\n             throw new OptimizationException(\n-                    \"none of the {0} start points lead to convergence\",\n+                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                     starts);\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer} interface adding\n      */\n     public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n         return optima.clone();\n     }\n \n         if (optima[0] == null) {\n             throw new OptimizationException(\n-                    \"none of the {0} start points lead to convergence\",\n+                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                     starts);\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n      */\n     public RealPointValuePair[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n         return optima.clone();\n     }\n \n         if (optima[0] == null) {\n             throw new OptimizationException(\n-                    \"none of the {0} start points lead to convergence\",\n+                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                     starts);\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n      */\n     public double[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n         return optima.clone();\n     }\n      */\n     public double[] getOptimaValues() throws IllegalStateException {\n         if (optimaValues == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n         }\n         return optimaValues.clone();\n     }\n \n         if (Double.isNaN(optima[0])) {\n             throw new OptimizationException(\n-                    \"none of the {0} start points lead to convergence\",\n+                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                     starts);\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/OptimizationException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/OptimizationException.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * This class represents exceptions thrown by optimizers.\n public class OptimizationException extends ConvergenceException {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -357696069587075016L;\n+    private static final long serialVersionUID = -4605887730798282127L;\n \n     /**\n      * Simple constructor.\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n+     * @deprecated as of 2.2 replaced by {@link #OptimizationException(Localizable, Object...)}\n      */\n+    @Deprecated\n     public OptimizationException(String specifier, Object ... parts) {\n+        this(new DummyLocalizable(specifier), parts);\n+    }\n+\n+    /**\n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     * @since 2.2\n+     */\n+    public OptimizationException(Localizable specifier, Object ... parts) {\n         super(specifier, parts);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n import org.apache.commons.math.optimization.RealConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class implements simplex-based direct search optimization\n  * @since 1.2\n  */\n public abstract class DirectSearchOptimizer implements MultivariateRealOptimizer {\n-\n-    /** Message for equal vertices. */\n-    private static final String EQUAL_VERTICES_MESSAGE =\n-        \"equal vertices {0} and {1} in simplex configuration\";\n-\n-    /** Message for dimension mismatch. */\n-    private static final String DIMENSION_MISMATCH_MESSAGE =\n-        \"dimension mismatch {0} != {1}\";\n \n     /** Simplex. */\n     protected RealPointValuePair[] simplex;\n             for (int j = 0; j < i + 1; ++j) {\n                 if (steps[j] == 0.0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          EQUAL_VERTICES_MESSAGE, j, j + 1);\n+                          LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, j, j + 1);\n                 }\n                 System.arraycopy(steps, 0, vertexI, 0, j + 1);\n             }\n         final int n = referenceSimplex.length - 1;\n         if (n < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"simplex must contain at least one point\");\n+                    LocalizedFormats.SIMPLEX_NEED_ONE_POINT);\n         }\n         startConfiguration = new double[n][n];\n         final double[] ref0 = referenceSimplex[0];\n             // safety checks\n             if (refI.length != n) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      DIMENSION_MISMATCH_MESSAGE, refI.length, n);\n+                      LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, refI.length, n);\n             }\n             for (int j = 0; j < i; ++j) {\n                 final double[] refJ = referenceSimplex[j];\n                 }\n                 if (allEquals) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          EQUAL_VERTICES_MESSAGE, i, j);\n+                          LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, i, j);\n                 }\n             }\n \n         final int n = startPoint.length;\n         if (n != startConfiguration.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  DIMENSION_MISMATCH_MESSAGE, n, startConfiguration.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, startConfiguration.length);\n         }\n \n         // set first vertex\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** This class guesses harmonic coefficients from a sample.\n \n         double c2 = sxy * sxz - sx2 * syz;\n         double c3 = sx2 * sy2 - sxy * sxy;\n         if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {\n-            throw new OptimizationException(\"unable to first guess the harmonic coefficients\");\n+            throw new OptimizationException(LocalizedFormats.UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS);\n         }\n         a     = Math.sqrt(c1 / c2);\n         omega = Math.sqrt(c2 / c3);\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** This class implements a curve fitting specialized for sinusoids.\n  * <p>Harmonic fitting is a very simple case of curve fitting. The\n             if (parameters == null) {\n                 final WeightedObservedPoint[] observations = fitter.getObservations();\n                 if (observations.length < 4) {\n-                    throw new OptimizationException(\"sample contains {0} observed points, at least {1} are required\",\n+                    throw new OptimizationException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                     observations.length, 4);\n                 }\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.optimization.VectorialConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Base class for implementing least squares optimizers.\n         ++jacobianEvaluations;\n         jacobian = jF.value(point);\n         if (jacobian.length != rows) {\n-            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                   jacobian.length, rows);\n         }\n         for (int i = 0; i < rows; i++) {\n         }\n         objective = function.value(point);\n         if (objective.length != rows) {\n-            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                   objective.length, rows);\n         }\n         cost = 0;\n                 new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n             return inverse.getData();\n         } catch (InvalidMatrixException ime) {\n-            throw new OptimizationException(\"unable to compute covariances: singular problem\");\n+            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n         }\n \n     }\n         throws FunctionEvaluationException, OptimizationException {\n         if (rows <= cols) {\n             throw new OptimizationException(\n-                    \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                     rows, cols);\n         }\n         double[] errors = new double[cols];\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         if (target.length != weights.length) {\n-            throw new OptimizationException(\"dimension mismatch {0} != {1}\",\n+            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                             target.length, weights.length);\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Gauss-Newton least-squares solver.\n                 }\n \n             } catch(InvalidMatrixException e) {\n-                throw new OptimizationException(\"unable to solve: singular problem\");\n+                throw new OptimizationException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n             }\n \n             // check convergence\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n \n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n                 if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n-                    throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n-                            \" no further reduction in the\" +\n-                            \" sum of squares is possible\",\n+                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                             costRelativeTolerance);\n                 } else if (delta <= 2.2204e-16 * xNorm) {\n-                    throw new OptimizationException(\"parameters relative tolerance is too small\" +\n-                            \" ({0}), no further improvement in\" +\n-                            \" the approximate solution is possible\",\n+                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                             parRelativeTolerance);\n                 } else if (maxCosine <= 2.2204e-16)  {\n-                    throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n-                            \" solution is orthogonal to the jacobian\",\n+                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                             orthoTolerance);\n                 }\n \n                     norm2 += aki * aki;\n                 }\n                 if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                    throw new OptimizationException(\n-                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                    throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                             rows, cols);\n                 }\n                 if (norm2 > ak2) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Non-linear conjugate gradient optimizer.\n                 return b;\n             }\n         }\n-        throw new OptimizationException(\"unable to bracket optimum in line search\");\n+        throw new OptimizationException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n     }\n \n     /** Default identity preconditioner. */\n--- a/src/main/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n package org.apache.commons.math.optimization.linear;\n \n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class represents exceptions thrown by optimizers when no solution\n      * Simple constructor using a default message.\n      */\n     public NoFeasibleSolutionException() {\n-        super(\"no feasible solution\");\n+        super(LocalizedFormats.NO_FEASIBLE_SOLUTION);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n package org.apache.commons.math.optimization.linear;\n \n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * This class represents exceptions thrown by optimizers when a solution\n      * Simple constructor using a default message.\n      */\n     public UnboundedSolutionException() {\n-        super(\"unbounded solution\");\n+        super(LocalizedFormats.UNBOUNDED_SOLUTION);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n      */\n     protected void checkResultComputed() throws IllegalStateException {\n         if (!resultComputed) {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Abstract class implementing the {@link  RandomGenerator} interface.\n     public int nextInt(int n) {\n         if (n <= 0 ) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound must be positive ({0})\", n);\n+                  LocalizedFormats.NOT_POSITIVE_UPPER_BOUND, n);\n         }\n         int result = (int) (nextDouble() * n);\n         return result < n ? result : n - 1;\n--- a/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /** Base class for random number generators that generates bits streams.\n \n \n         if (n < 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound must be positive ({0})\", n);\n+                  LocalizedFormats.NOT_POSITIVE_UPPER_BOUND, n);\n         }\n \n         // find bit mask for n\n--- a/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n             DataAdapter da = new StreamDataAdapter(in);\n             da.computeStats();\n             if (sampleStats.getN() == 0) {\n-                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                throw MathRuntimeException.createEOFException(LocalizedFormats.URL_CONTAINS_NO_DATA,\n                                                               url);\n             }\n             in = new BufferedReader(new InputStreamReader(url.openStream()));\n     public double getNextValue() throws IllegalStateException {\n \n         if (!loaded) {\n-            throw MathRuntimeException.createIllegalStateException(\"distribution not loaded\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.DISTRIBUTION_NOT_LOADED);\n         }\n \n         // Start with a uniformly distributed random number in (0,1)\n                }\n            }\n         }\n-        throw new MathRuntimeException(\"no bin selected\");\n+        throw new MathRuntimeException(LocalizedFormats.NO_BIN_SELECTED);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.distribution.WeibullDistributionImpl;\n import org.apache.commons.math.distribution.ZipfDistributionImpl;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     public String nextHexString(int len) {\n         if (len <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"length must be positive ({0})\", len);\n+                  LocalizedFormats.NOT_POSITIVE_LENGTH, len);\n         }\n \n         // Get a random number generator\n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                    LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                     upper, lower);\n         }\n         double r = getRan().nextDouble();\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                   upper, lower);\n         }\n         double r = getRan().nextDouble();\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"length must be positive ({0})\", len);\n+                  LocalizedFormats.NOT_POSITIVE_LENGTH, len);\n         }\n \n         // Get SecureRandom and setup Digest provider\n     public int nextSecureInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                   upper, lower);\n         }\n         SecureRandom sec = getSecRan();\n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                   upper, lower);\n         }\n         SecureRandom sec = getSecRan();\n     public long nextPoisson(double mean) {\n         if (mean <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"the Poisson mean must be positive ({0})\", mean);\n+                  LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, mean);\n         }\n \n         final RandomGenerator generator = getRan();\n     public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"standard deviation must be positive ({0})\", sigma);\n+                  LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION, sigma);\n         }\n         return sigma * getRan().nextGaussian() + mu;\n     }\n     public double nextExponential(double mean) {\n         if (mean <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"mean must be positive ({0})\", mean);\n+                  LocalizedFormats.NOT_POSITIVE_MEAN, mean);\n         }\n         final RandomGenerator generator = getRan();\n         double unif = generator.nextDouble();\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                   upper, lower);\n         }\n         final RandomGenerator generator = getRan();\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"permutation k ({0}) exceeds n ({1})\", k, n);\n+                  LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n);\n         }\n         if (k == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"permutation k ({0}) must be positive\", k);\n+                  LocalizedFormats.NOT_POSITIVE_PERMUTATION, k);\n         }\n \n         int[] index = getNatural(n);\n         int len = c.size();\n         if (k > len) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"sample size ({0}) exceeds collection size ({1})\");\n+                  LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE);\n         }\n         if (k <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"sample size must be positive ({0})\", k);\n+                  LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, k);\n         }\n \n         Object[] objects = c.toArray();\n--- a/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n import java.util.Arrays;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * A {@link RandomVectorGenerator} that generates vectors with uncorrelated\n                                            NormalizedRandomGenerator generator) {\n     if (mean.length != standardDeviation.length) {\n       throw MathRuntimeException.createIllegalArgumentException(\n-            \"dimension mismatch {0} != {1}\",\n+            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n             mean.length, standardDeviation.length);\n     }\n     this.mean              = mean.clone();\n--- a/src/main/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/main/java/org/apache/commons/math/random/ValueServer.java\n import java.net.URL;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Generates values for use in simulation applications.\n     private double getNextDigest() {\n         if ((empiricalDistribution == null) ||\n             (empiricalDistribution.getBinStats().size() == 0)) {\n-            throw MathRuntimeException.createIllegalStateException(\"digest not initialized\");\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.DIGEST_NOT_INITIALIZED);\n         }\n         return empiricalDistribution.getNextValue();\n     }\n             closeReplayFile();\n             resetReplayFile();\n             if ((str = filePointer.readLine()) == null) {\n-                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                throw MathRuntimeException.createEOFException(LocalizedFormats.URL_CONTAINS_NO_DATA,\n                                                               valuesFileURL);\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n import java.util.TreeMap;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Maintains a frequency distribution.\n             addValue((Comparable<?>) v);\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"class ({0}) does not implement Comparable\",\n+                  LocalizedFormats.CLASS_DOESNT_IMPLEMENT_COMPARABLE,\n                   v.getClass().getName());\n         }\n     }\n         } catch (ClassCastException ex) {\n             //TreeMap will throw ClassCastException if v is not comparable\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"instance of class {0} not comparable to existing values\",\n+                  LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES,\n                   v.getClass().getName());\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * StatUtils provides static methods for computing statistics based on data\n     public static double sumDifference(final double[] sample1, final double[] sample2)\n         throws IllegalArgumentException {\n         int n = sample1.length;\n-        if ((n  != sample2.length) || (n < 1)) {\n+        if (n  != sample2.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"input arrays must have the same positive length ({0} and {1})\",\n-                  n, sample2.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, sample2.length);\n+        }\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, sample2.length, 1);\n         }\n         double result = 0;\n         for (int i = 0; i < n; i++) {\n         double sum2 = 0d;\n         double diff = 0d;\n         int n = sample1.length;\n-        if (n < 2 || n != sample2.length) {\n+        if (n != sample2.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"input arrays must have the same length and at least two elements ({0} and {1})\",\n-                  n, sample2.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, sample2.length);\n+        }\n+        if (n < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n         }\n         for (int i = 0; i < n; i++) {\n             diff = sample1[i] - sample2[i];\n--- a/src/main/java/org/apache/commons/math/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/Covariance.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Computes covariances for pairs of arrays or columns of a matrix.\n         Mean mean = new Mean();\n         double result = 0d;\n         int length = xArray.length;\n-        if(length == yArray.length && length > 1) {\n+        if (length != yArray.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, length, yArray.length);\n+        } else if (length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, length, 2);\n+        } else {\n             double xMean = mean.evaluate(xArray);\n             double yMean = mean.evaluate(yArray);\n             for (int i = 0; i < length; i++) {\n                 result += (xDev * yDev - result) / (i + 1);\n             }\n         }\n-        else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-               \"arrays must have the same length and both must have at \" +\n-               \"least two elements. xArray has size {0}, yArray has {1} elements\",\n-                    length, yArray.length);\n-        }\n         return biasCorrected ? result * ((double) length / (double)(length - 1)) : result;\n     }\n \n         int nCols = matrix.getColumnDimension();\n         if (nRows < 2 || nCols < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                     nRows, nCols);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.stat.regression.SimpleRegression;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Computes Pearson's product-moment correlation coefficients for pairs of arrays\n     public PearsonsCorrelation(Covariance covariance) {\n         RealMatrix covarianceMatrix = covariance.getCovarianceMatrix();\n         if (covarianceMatrix == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"covariance matrix is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_COVARIANCE_MATRIX);\n         }\n         nObs = covariance.getN();\n         correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n      */\n     public double correlation(final double[] xArray, final double[] yArray) throws IllegalArgumentException {\n         SimpleRegression regression = new SimpleRegression();\n-        if(xArray.length == yArray.length && xArray.length > 1) {\n+        if (xArray.length != yArray.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, xArray.length, yArray.length);\n+        } else if (xArray.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n+        } else {\n             for(int i=0; i<xArray.length; i++) {\n                 regression.addData(xArray[i], yArray[i]);\n             }\n             return regression.getR();\n-        }\n-        else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n-                    xArray.length, yArray.length);\n         }\n     }\n \n         int nCols = matrix.getColumnDimension();\n         if (nRows < 2 || nCols < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                     nRows, nCols);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.ranking.NaturalRanking;\n import org.apache.commons.math.stat.ranking.RankingAlgorithm;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * <p>Spearman's rank correlation. This implementation performs a rank\n      */\n     public double correlation(final double[] xArray, final double[] yArray)\n     throws IllegalArgumentException {\n-        if (xArray.length == yArray.length && xArray.length > 1) {\n+        if (xArray.length != yArray.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, xArray.length, yArray.length);\n+        } else if (xArray.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n+        } else {\n             return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n                     rankingAlgorithm.rank(yArray));\n-        }\n-        else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n-                    xArray.length, yArray.length);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n package org.apache.commons.math.stat.descriptive;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n         }\n         return evaluate(values, 0, values.length);\n     }\n      */\n     public void incrementAll(double[] values) {\n         if (values == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n         }\n         incrementAll(values, 0, values.length);\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n package org.apache.commons.math.stat.descriptive;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Abstract base class for all implementations of the\n         final int length) {\n \n         if (values == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n         }\n \n         if (begin < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"start position cannot be negative ({0})\", begin);\n+                  LocalizedFormats.NEGATIVE_START_POSITION, begin);\n         }\n \n         if (length < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"length cannot be negative ({0})\", length);\n+                  LocalizedFormats.NEGATIVE_LENGTH, length);\n         }\n \n         if (begin + length > values.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"subarray ends after array end\");\n+                  LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END);\n         }\n \n         if (length == 0) {\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n import org.apache.commons.math.stat.descriptive.rank.Percentile;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.ResizableDoubleArray;\n \n \n     /** Name of the setQuantile method. */\n     private static final String SET_QUANTILE_METHOD_NAME = \"setQuantile\";\n \n-    /** Message for unsupported setQuantile. */\n-    private static final String UNSUPPORTED_METHOD_MESSAGE =\n-        \"percentile implementation {0} does not support {1}\";\n-\n-    /** Message for illegal accesson setquantile. */\n-    private static final String ILLEGAL_ACCESS_MESSAGE =\n-        \"cannot access {0} method in percentile implementation {1}\";\n-\n     /** hold the window size **/\n     protected int windowSize = INFINITE_WINDOW;\n \n         if (windowSize < 1) {\n             if (windowSize != INFINITE_WINDOW) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"window size must be positive ({0})\", windowSize);\n+                      LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE, windowSize);\n             }\n         }\n \n                                 new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      UNSUPPORTED_METHOD_MESSAGE,\n+                      LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD,\n                       percentileImpl.getClass().getName(), SET_QUANTILE_METHOD_NAME);\n             } catch (IllegalAccessException e2) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      ILLEGAL_ACCESS_MESSAGE,\n+                      LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD,\n                       SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName());\n             } catch (InvocationTargetException e3) {\n                 throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n                   percentileImpl.getClass().getName());\n         } catch (IllegalAccessException e2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  ILLEGAL_ACCESS_MESSAGE,\n+                  LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD,\n                   SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName());\n         } catch (InvocationTargetException e3) {\n             throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     private void checkEmpty() {\n         if (n > 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"{0} values have been added before statistic is configured\",\n+                    LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC,\n                     n);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n     private void checkEmpty() {\n         if (n > 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"{0} values have been added before statistic is configured\",\n+                    LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC,\n                     n);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n     private void checkEmpty() {\n         if (getN() > 0) {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"{0} values have been added before statistic is configured\",\n+                    LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC,\n                     getN());\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n             moment.increment(d);\n         }  else  {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"statistics constructed from external moments cannot be incremented\");\n+                    LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS);\n         }\n     }\n \n             moment.clear();\n         } else  {\n             throw MathRuntimeException.createIllegalStateException(\n-                    \"statistics constructed from external moments cannot be cleared\");\n+                    LocalizedFormats.CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/SemiVariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/SemiVariance.java\n import java.io.Serializable;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * <p>Computes the semivariance of a set of values with respect to a given cutoff value.\n     @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n          }\n         return evaluate(values, 0, values.length);\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Computes the variance of the available values.  By default, the unbiased\n     @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n         }\n         return evaluate(values, 0, values.length);\n     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Provides percentile computation.\n \n         if ((p > 100) || (p <= 0)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n+                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n         }\n         if (length == 0) {\n             return Double.NaN;\n     public void setQuantile(final double p) {\n         if (p <= 0 || p > 100) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n+                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n         }\n         quantile = p;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements Chi-Square test statistics defined in the\n         throws IllegalArgumentException {\n         if (expected.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"expected array length = {0}, must be at least 2\",\n-                  expected.length);\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, expected.length, 2);\n         }\n         if (expected.length != observed.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\", expected.length, observed.length);\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, expected.length, observed.length);\n         }\n         checkPositive(expected);\n         checkNonNegative(observed);\n             double alpha) throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0, 0.5);\n         }\n         return chiSquareTest(expected, observed) < alpha;\n     throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0.0, 0.5);\n         }\n         return chiSquareTest(counts) < alpha;\n         // Make sure lengths are same\n         if (observed1.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"observed array length = {0}, must be at least 2\",\n-                  observed1.length);\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, observed1.length, 2);\n         }\n         if (observed1.length != observed2.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\",\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                   observed1.length, observed2.length);\n         }\n \n         // Ensure neither sample is uniformly 0\n         if (countSum1 == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"observed counts are all 0 in first observed array\");\n+                  LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 1);\n         }\n         if (countSum2 == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"observed counts are all 0 in second observed array\");\n+                  LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 2);\n         }\n         // Compare and compute weight only if different\n         unequalCounts = countSum1 != countSum2;\n         for (int i = 0; i < observed1.length; i++) {\n             if (observed1[i] == 0 && observed2[i] == 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"observed counts are both zero for entry {0}\", i);\n+                      LocalizedFormats.OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY, i);\n             } else {\n                 obs1 = observed1[i];\n                 obs2 = observed2[i];\n             double alpha) throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0.0, 0.5);\n         }\n         return chiSquareTestDataSetsComparison(observed1, observed2) < alpha;\n \n         if (in.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"invalid row dimension: {0} (must be at least 2)\",\n-                  in.length);\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, in.length, 2);\n         }\n \n         if (in[0].length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"invalid column dimension: {0} (must be at least 2)\",\n-                  in[0].length);\n+                  LocalizedFormats.INSUFFICIENT_DIMENSION, in[0].length, 2);\n         }\n \n         checkRectangular(in);\n         for (int i = 1; i < in.length; i++) {\n             if (in[i].length != in[0].length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"some rows have length {0} while others have length {1}\",\n+                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                       in[i].length, in[0].length);\n             }\n         }\n         for (int i = 0; i < in.length; i++) {\n             if (in[i] <= 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"element {0} is not positive: {1}\",\n+                      LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX,\n                       i, in[i]);\n             }\n         }\n         for (int i = 0; i < in.length; i++) {\n             if (in[i] < 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"element {0} is negative: {1}\",\n+                      LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX,\n                       i, in[i]);\n             }\n         }\n             for (int j = 0; j < in[i].length; j++) {\n                 if (in[i][j] < 0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                          \"element ({0}, {1}) is negative: {2}\",\n+                          LocalizedFormats.NEGATIVE_ELEMENT_AT_2D_INDEX,\n                           i, j, in[i][j]);\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n \n /**\n         throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0, 0.5);\n         }\n         return anovaPValue(categoryData) < alpha;\n         // check if we have enough categories\n         if (categoryData.size() < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"two or more categories required, got {0}\",\n+                  LocalizedFormats.TWO_OR_MORE_CATEGORIES_REQUIRED,\n                   categoryData.size());\n         }\n \n         for (double[] array : categoryData) {\n             if (array.length <= 1) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                      \"two or more values required in each category, one has {0}\",\n+                      LocalizedFormats.TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED,\n                       array.length);\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.stat.StatUtils;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements t-test statistics defined in the {@link TTest} interface.\n  * @version $Revision$ $Date$\n  */\n public class TTestImpl implements TTest  {\n-\n-    /** Message for insufficient data. */\n-    private static final String INSUFFICIENT_DATA_MESSAGE =\n-        \"insufficient data for t statistic, needs at least 2, got {0}\";\n \n     /** Distribution used to compute inference statistics. */\n     private TDistribution distribution;\n         throws IllegalArgumentException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0.0, 0.5);\n         }\n     }\n         throws IllegalArgumentException {\n         if ((data == null) || (data.length < 2)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  INSUFFICIENT_DATA_MESSAGE,\n+                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n                   (data == null) ? 0 : data.length);\n         }\n     }\n         throws IllegalArgumentException {\n         if ((stat == null) || (stat.getN() < 2)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  INSUFFICIENT_DATA_MESSAGE,\n+                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n                   (stat == null) ? 0 : stat.getN());\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Abstract base class for implementations of MultipleLinearRegression.\n     protected void validateSampleData(double[][] x, double[] y) {\n         if ((x == null) || (y == null) || (x.length != y.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"dimension mismatch {0} != {1}\",\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                   (x == null) ? 0 : x.length,\n                   (y == null) ? 0 : y.length);\n         } else if ((x.length > 0) && (x[0].length > x.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"not enough data ({0} rows) for this many predictors ({1} predictors)\",\n+                  LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS,\n                   x.length, x[0].length);\n         }\n     }\n     protected void validateCovarianceData(double[][] x, double[][] covariance) {\n         if (x.length != covariance.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                 \"dimension mismatch {0} != {1}\", x.length, covariance.length);\n+                 LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, covariance.length);\n         }\n         if (covariance.length > 0 && covariance.length != covariance[0].length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"a {0}x{1} matrix was provided instead of a square matrix\",\n+                  LocalizedFormats.NON_SQUARE_MATRIX,\n                   covariance.length, covariance[0].length);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Estimates an ordinary least squares regression model\n         throws MathException {\n         if (alpha >= 1 || alpha <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n                   alpha, 0.0, 1.0);\n         }\n         return getSlopeStdErr() *\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n         final int n = f.length - 1;\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} is not a power of 2 plus one\",\n+                    LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE,\n                     f.length);\n         }\n         if (n == 1) {       // trivial case\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/FastFourierTransform.html\">\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n-    /** Message for not power of 2. */\n-    private static final String NOT_POWER_OF_TWO_MESSAGE =\n-        \"{0} is not a power of 2, consider padding for fix\";\n-\n-    /** Message for dimension mismatch. */\n-    private static final String DIMENSION_MISMATCH_MESSAGE =\n-        \"some dimensions don't match: {0} != {1}\";\n-\n-    /** Message for not computed roots of unity. */\n-    private static final String MISSING_ROOTS_OF_UNITY_MESSAGE =\n-        \"roots of unity have not been computed yet\";\n-\n     /** Message for out of range root index. */\n     private static final String OUT_OF_RANGE_ROOT_INDEX_MESSAGE =\n         \"out of range root of unity index {0} (must be in [{1};{2}])\";\n \n         if (n <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"number of sample is not positive: {0}\",\n+                    LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES,\n                     n);\n         }\n         verifyInterval(min, max);\n     public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n         if (!isPowerOf2(d.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    NOT_POWER_OF_TWO_MESSAGE, d.length);\n+                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, d.length);\n         }\n     }\n \n     public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n         if (!isPowerOf2(o.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    NOT_POWER_OF_TWO_MESSAGE, o.length);\n+                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, o.length);\n         }\n     }\n \n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            DIMENSION_MISMATCH_MESSAGE, 0, dimensionSize.length);\n+                            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, 0, dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        DIMENSION_MISMATCH_MESSAGE, vector.length, dimensionSize.length);\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length, dimensionSize.length);\n             }\n \n             Object lastDimension = multiDimensionalComplexArray;\n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n-                            DIMENSION_MISMATCH_MESSAGE, 0, dimensionSize.length);\n+                            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, 0, dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        DIMENSION_MISMATCH_MESSAGE, vector.length,dimensionSize.length);\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length,dimensionSize.length);\n             }\n \n             Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n       public synchronized boolean isForward() throws IllegalStateException {\n \n         if (omegaCount == 0) {\n-          throw MathRuntimeException.createIllegalStateException(\n-                  MISSING_ROOTS_OF_UNITY_MESSAGE);\n+          throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n         }\n         return isForward;\n \n \n         if (n == 0) {\n           throw MathRuntimeException.createIllegalArgumentException(\n-                  \"cannot compute 0-th root of unity, indefinite result\");\n+                  LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);\n         }\n \n         isForward = n > 0;\n         throws IllegalStateException, IllegalArgumentException {\n \n         if (omegaCount == 0) {\n-            throw MathRuntimeException.createIllegalStateException(\n-                    MISSING_ROOTS_OF_UNITY_MESSAGE);\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n         throws IllegalStateException, IllegalArgumentException {\n \n         if (omegaCount == 0) {\n-            throw MathRuntimeException.createIllegalStateException(\n-                    MISSING_ROOTS_OF_UNITY_MESSAGE);\n+            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n         }\n         if ((k < 0) || (k >= omegaCount)) {\n           throw MathRuntimeException.createIllegalArgumentException(\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n         // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} is not a power of 2\",\n+                    LocalizedFormats.NOT_POWER_OF_TWO,\n                     n);\n         }\n \n         // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0} is not a power of 2\",\n+                    LocalizedFormats.NOT_POWER_OF_TWO,\n                     n);\n         }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n         FastFourierTransformer.verifyDataSet(f);\n         if (f[0] != 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"first element is not 0: {0}\",\n+                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                     f[0]);\n         }\n         final int n = f.length;\n--- a/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n                 final double scale = Math.max(a,b);\n                 if (scale <= 0) {  // Can't scale\n                     throw new ConvergenceException(\n-                            \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                            LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                              x);\n                 }\n                 infinite = true;\n             if (infinite) {\n                // Scaling failed\n                throw new ConvergenceException(\n-                 \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                 LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                   x);\n             }\n \n \n             if (Double.isNaN(r)) {\n                 throw new ConvergenceException(\n-                  \"Continued fraction diverged to NaN for value {0}\",\n+                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                   x);\n             }\n             relativeError = Math.abs(r / c - 1.0);\n \n         if (n >= maxIterations) {\n             throw new MaxIterationsExceededException(maxIterations,\n-                \"Continued fraction convergents failed to converge for value {0}\",\n+                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                 x);\n         }\n \n--- a/src/main/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/main/java/org/apache/commons/math/util/DefaultTransformer.java\n     public double transform(Object o) throws MathException{\n \n         if (o == null) {\n-            throw new MathException(\"Conversion Exception in Transformation, Object is null\");\n+            throw new MathException(LocalizedFormats.NULL_OBJECT_TRANSFORMATION);\n         }\n \n         if (o instanceof Number) {\n             return Double.valueOf(o.toString()).doubleValue();\n         } catch (NumberFormatException e) {\n             throw new MathException(e,\n-                                    \"Conversion Exception in Transformation: {0}\", e.getMessage());\n+                                    LocalizedFormats.CANNOT_TRANSFORM_TO_DOUBLE, e.getMessage());\n         }\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/DummyLocalizable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Dummy implementation of the {@link Localizable} interface, without localization.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class DummyLocalizable implements Localizable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8843275624471387299L;\n+\n+    /** Source string. */\n+    private final String source;\n+\n+    /** Simple constructor. */\n+    public DummyLocalizable(final String source) {\n+        this.source = source;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getSourceString() {\n+        return source;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getLocalizedString(Locale locale) {\n+        return source;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString() {\n+        return source;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/Localizable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+/**\n+ * Interface for localizable strings.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public interface Localizable extends Serializable {\n+\n+    /**\n+     * Get the source (non-localized) string.\n+     * @return source string\n+     */\n+    String getSourceString();\n+\n+    /**\n+     * Get the localized string.\n+     * @param locale locale into which to get the string\n+     * @return localized string or the source string if no localized version is available\n+     */\n+    String getLocalizedString(Locale locale);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * Enumeration for localized messages formats used for exemple\n+ * in exceptions messages.\n+ * <p>\n+ * The constants in this enumeration represent the available\n+ * formats as localized strings. These formats are intended to be\n+ * localized using simple properties files, using the constant\n+ * name as the key and the property value as the message format.\n+ * The source English format is provided in the constants themselves\n+ * to serve both as a reminder for developers to understand the parameters\n+ * needed by each format, as a basis for translators to create\n+ * localized properties files, and as a default format if some\n+ * translation is missing.\n+ * </p>\n+ * @since 2.1\n+ * @version $Revision$ $Date$\n+ */\n+public enum LocalizedFormats implements Localizable {\n+\n+    // CHECKSTYLE: stop MultipleVariableDeclarations\n+\n+    ARGUMENT_OUTSIDE_DOMAIN(\"Argument {0} outside domain [{1} ; {2}]\"),\n+    ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1(\"array sizes should have difference 1 ({0} != {1} + 1)\"),\n+    ASSYMETRIC_EIGEN_NOT_SUPPORTED(\"eigen decomposition of assymetric matrices not supported yet\"),\n+    AT_LEAST_ONE_COLUMN(\"matrix must have at least one column\"),\n+    AT_LEAST_ONE_ROW(\"matrix must have at least one row\"),\n+    BANDWIDTH_OUT_OF_INTERVAL(\"bandwidth must be in the interval [0,1], but got {0}\"),\n+    BINOMIAL_INVALID_PARAMETERS_ORDER(\"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\"),\n+    BINOMIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for binomial coefficient (n,k), got n = {0}\"),\n+    CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS(\"statistics constructed from external moments cannot be cleared\"),\n+    CANNOT_COMPUTE_0TH_ROOT_OF_UNITY(\"cannot compute 0-th root of unity, indefinite result\"),\n+    CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N(\"cannot compute nth root for null or negative n: {0}\"),\n+    CANNOT_CONVERT_OBJECT_TO_FRACTION(\"cannot convert given object to a fraction number: {0}\"),\n+    CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS(\"cannot discard a negative number of elements ({0})\"),\n+    CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR(\"cannot format a {0} instance as a 3D vector\"),\n+    CANNOT_FORMAT_INSTANCE_AS_COMPLEX(\"cannot format a {0} instance as a complex number\"),\n+    CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR(\"cannot format a {0} instance as a real vector\"),\n+    CANNOT_FORMAT_OBJECT_TO_FRACTION(\"cannot format given object as a fraction number\"),\n+    CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS(\"statistics constructed from external moments cannot be incremented\"),\n+    CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR(\"cannot normalize a zero norm vector\"),\n+    CANNOT_RETRIEVE_AT_NEGATIVE_INDEX(\"elements cannot be retrieved from a negative array index {0}\"),\n+    CANNOT_SET_AT_NEGATIVE_INDEX(\"cannot set an element at a negative index {0}\"),\n+    CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY(\"cannot substitute an element from an empty array\"),\n+    CANNOT_TRANSFORM_TO_DOUBLE(\"Conversion Exception in Transformation: {0}\"),\n+    CARDAN_ANGLES_SINGULARITY(\"Cardan angles singularity\"),\n+    CLASS_DOESNT_IMPLEMENT_COMPARABLE(\"class ({0}) does not implement Comparable\"),\n+    CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT(\"the closest orthogonal matrix has a negative determinant {0}\"),\n+    COLUMN_INDEX_OUT_OF_RANGE(\"column index {0} out of allowed range [{1}, {2}]\"),\n+    CONTINUED_FRACTION_INFINITY_DIVERGENCE(\"Continued fraction convergents diverged to +/- infinity for value {0}\"),\n+    CONTINUED_FRACTION_NAN_DIVERGENCE(\"Continued fraction diverged to NaN for value {0}\"),\n+    CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR(\"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would lead to a never ending loop of expansion and contraction as a newly expanded internal storage array would immediately satisfy the criteria for contraction.\"),\n+    CONTRACTION_CRITERIA_SMALLER_THAN_ONE(\"contraction criteria smaller than one ({0}).  This would lead to a never ending loop of expansion and contraction as an internal storage array length equal to the number of elements would satisfy the contraction criteria.\"),\n+    CONVERGENCE_FAILED(\"convergence failed\"),\n+    CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Cumulative probability function returned NaN for argument {0} p = {1}\"),\n+    DIFFERENT_ROWS_LENGTHS(\"some rows have length {0} while others have length {1}\"),\n+    DIGEST_NOT_INITIALIZED(\"digest not initialized\"),\n+    DIMENSIONS_MISMATCH_2x2(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\"),\n+    DIMENSIONS_MISMATCH_SIMPLE(\"dimensions mismatch {0} != {1}\"),\n+    DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n+    DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n+    DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n+    EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"),\n+    EMPTY_SELECTED_COLUMN_INDEX_ARRAY(\"empty selected column index array\"),\n+    EMPTY_SELECTED_ROW_INDEX_ARRAY(\"empty selected row index array\"),\n+    EMPTY_STRING_FOR_IMAGINARY_CHARACTER(\"empty string for imaginary character\"),\n+    ENDPOINTS_NOT_AN_INTERVAL(\"endpoints do not specify an interval: [{0}, {1}]\"),\n+    EQUAL_VERTICES_IN_SIMPLEX(\"equal vertices {0} and {1} in simplex configuration\"),\n+    EULER_ANGLES_SINGULARITY(\"Euler angles singularity\"),\n+    EVALUATION_FAILED(\"evaluation failed for argument = {0}\"),\n+    EXPANSION_FACTOR_SMALLER_THAN_ONE(\"expansion factor smaller than one ({0})\"),\n+    FACTORIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for n!, got n = {0}\"),\n+    FAILED_BRACKETING(\"number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\"),\n+    FAILED_FRACTION_CONVERSION(\"Unable to convert {0} to fraction after {1} iterations\"),\n+    FIRST_COLUMNS_NOT_INITIALIZED_YET(\"first {0} columns are not initialized yet\"),\n+    FIRST_ELEMENT_NOT_ZERO(\"first element is not 0: {0}\"),\n+    FIRST_ROWS_NOT_INITIALIZED_YET(\"first {0} rows are not initialized yet\"),\n+    FRACTION_CONVERSION_OVERFLOW(\"Overflow trying to convert {0} to fraction ({1}/{2})\"),\n+    FUNCTION_NOT_DIFFERENTIABLE(\"function is not differentiable\"),\n+    FUNCTION_NOT_POLYNOMIAL(\"function is not polynomial\"),\n+    GCD_OVERFLOW_32_BITS(\"overflow: gcd({0}, {1}) is 2^31\"),\n+    GCD_OVERFLOW_64_BITS(\"overflow: gcd({0}, {1}) is 2^63\"),\n+    HOLE_BETWEEN_MODELS_TIME_RANGES(\"{0} wide hole between models time ranges\"),\n+    IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\"),\n+    INDEX_LARGER_THAN_MAX(\"the index specified: {0} is larger than the current maximal index {1}\"),\n+    INDEX_NOT_POSITIVE(\"index ({0}) is not positive\"),\n+    INDEX_OUT_OF_RANGE(\"index {0} out of allowed range [{1}, {2}]\"),\n+    INFINITE_ARRAY_ELEMENT(\"Array contains an infinite element, {0} at index {1}\"),\n+    INFINITE_VALUE_CONVERSION(\"cannot convert infinite value\"),\n+    INITIAL_CAPACITY_NOT_POSITIVE(\"initial capacity ({0}) is not positive\"),\n+    INITIAL_COLUMN_AFTER_FINAL_COLUMN(\"initial column {0} after final column {1}\"),\n+    INITIAL_ROW_AFTER_FINAL_ROW(\"initial row {0} after final row {1}\"),\n+    INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE(\"input data comes from unsupported datasource: {0}, supported sources: {1}, {2}\"),\n+    INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES(\"instance of class {0} not comparable to existing values\"),\n+    INSUFFICIENT_DATA_FOR_T_STATISTIC(\"insufficient data for t statistic, needs at least 2, got {0}\"),\n+    INSUFFICIENT_DIMENSION(\"insufficient dimension {0}, must be at least {1}\"),\n+    INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE(\"sample contains {0} observed points, at least {1} are required\"),\n+    INSUFFICIENT_ROWS_AND_COLUMNS(\"insufficient data: only {0} rows and {1} columns.\"),\n+    INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT(\"{0} method needs at least one previous point\"),\n+    INTERNAL_ERROR(\"internal error, please fill a bug report at {0}\"),\n+    INVALID_BRACKETING_PARAMETERS(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\"),\n+    INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\"),\n+    INVALID_ITERATIONS_LIMITS(\"invalid iteration limits: min={0}, max={1}\"),\n+    INVALID_MAX_ITERATIONS(\"bad value for maximum iterations number: {0}\"),\n+    INVALID_ROUNDING_METHOD(\"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\"),\n+    ITERATOR_EXHAUSTED(\"iterator exhausted\"),\n+    LCM_OVERFLOW_32_BITS(\"overflow: lcm({0}, {1}) is 2^31\"),\n+    LCM_OVERFLOW_64_BITS(\"overflow: lcm({0}, {1}) is 2^63\"),\n+    LOESS_EXPECTS_AT_LEAST_ONE_POINT(\"Loess expects at least 1 point\"),\n+    LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"upper bound ({0}) must be greater than lower bound ({1})\"),\n+    LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT(\"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\"),\n+    MAP_MODIFIED_WHILE_ITERATING(\"map has been modified while iterating\"),\n+    MAX_EVALUATIONS_EXCEEDED(\"maximal number of evaluations ({0}) exceeded\"),\n+    MAX_ITERATIONS_EXCEEDED(\"maximal number of iterations ({0}) exceeded\"),\n+    MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION(\"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\"),\n+    MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS(\"Loess expects the abscissa and ordinate arrays to be of the same size, but got {0} abscissae and {1} ordinatae\"),\n+    NAN_VALUE_CONVERSION(\"cannot convert NaN value\"),\n+    NEGATIVE_BRIGHTNESS_EXPONENT(\"brightness exponent should be positive or null, but got {0}\"),\n+    NEGATIVE_COMPLEX_MODULE(\"negative complex module {0}\"),\n+    NEGATIVE_ELEMENT_AT_2D_INDEX(\"element ({0}, {1}) is negative: {2}\"),\n+    NEGATIVE_ELEMENT_AT_INDEX(\"element {0} is negative: {1}\"),\n+    NEGATIVE_LENGTH(\"length cannot be negative ({0})\"),\n+    NEGATIVE_NUMBER_OF_SUCCESSES(\"number of successes must be non-negative ({0})\"),\n+    NEGATIVE_NUMBER_OF_TRIALS(\"number of trials must be non-negative ({0})\"),\n+    NEGATIVE_ROBUSTNESS_ITERATIONS(\"the number of robustness iterations must be non-negative, but got {0}\"),\n+    NEGATIVE_START_POSITION(\"start position cannot be negative ({0})\"),\n+    NON_CONVERGENT_CONTINUED_FRACTION(\"Continued fraction convergents failed to converge for value {0}\"),\n+    NON_POSITIVE_MICROSPHERE_ELEMENTS(\"number of microsphere elements must be positive, but got {0}\"),\n+    NON_POSITIVE_POLYNOMIAL_DEGREE(\"polynomial degree must be positive: degree={0}\"),\n+    NON_REAL_FINITE_ABSCISSA(\"all abscissae must be finite real numbers, but {0}-th is {1}\"),\n+    NON_REAL_FINITE_ORDINATE(\"all ordinatae must be finite real numbers, but {0}-th is {1}\"),\n+    NON_REAL_FINITE_WEIGHT(\"all weights must be finite real numbers, but {0}-th is {1}\"),\n+    NON_SQUARE_MATRIX(\"a {0}x{1} matrix was provided instead of a square matrix\"),\n+    NORMALIZE_INFINITE(\"Cannot normalize to an infinite value\"),\n+    NORMALIZE_NAN(\"Cannot normalize to NaN\"),\n+    NOT_ADDITION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not addition compatible\"),\n+    NOT_DECREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not decreasing ({2} < {3})\"),\n+    NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS(\"not enough data ({0} rows) for this many predictors ({1} predictors)\"),\n+    NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION(\"spline partition must have at least {0} points, got {1}\"),\n+    NOT_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not increasing ({2} > {3})\"),\n+    NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n+    NOT_POSITIVE_ALPHA(\"alpha must be positive ({0})\"),\n+    NOT_POSITIVE_BETA(\"beta must be positive ({0})\"),\n+    NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n+    NOT_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix\"),\n+    NOT_POSITIVE_DEGREES_OF_FREEDOM(\"degrees of freedom must be positive ({0})\"),\n+    NOT_POSITIVE_ELEMENT_AT_INDEX(\"element {0} is not positive: {1}\"),\n+    NOT_POSITIVE_EXPONENT(\"invalid exponent {0} (must be positive)\"),\n+    NOT_POSITIVE_LENGTH(\"length must be positive ({0})\"),\n+    NOT_POSITIVE_MEAN(\"mean must be positive ({0})\"),\n+    NOT_POSITIVE_NUMBER_OF_SAMPLES(\"number of sample is not positive: {0}\"),\n+    NOT_POSITIVE_PERMUTATION(\"permutation k ({0}) must be positive\"),\n+    NOT_POSITIVE_POISSON_MEAN(\"the Poisson mean must be positive ({0})\"),\n+    NOT_POSITIVE_POPULATION_SIZE(\"population size must be positive ({0})\"),\n+    NOT_POSITIVE_ROW_DIMENSION(\"invalid row dimension: {0} (must be positive)\"),\n+    NOT_POSITIVE_SAMPLE_SIZE(\"sample size must be positive ({0})\"),\n+    NOT_POSITIVE_SCALE(\"scale must be positive ({0})\"),\n+    NOT_POSITIVE_SHAPE(\"shape must be positive ({0})\"),\n+    NOT_POSITIVE_STANDARD_DEVIATION(\"standard deviation must be positive ({0})\"),\n+    NOT_POSITIVE_UPPER_BOUND(\"upper bound must be positive ({0})\"),\n+    NOT_POSITIVE_WINDOW_SIZE(\"window size must be positive ({0})\"),\n+    NOT_POWER_OF_TWO(\"{0} is not a power of 2\"),\n+    NOT_POWER_OF_TWO_CONSIDER_PADDING(\"{0} is not a power of 2, consider padding for fix\"),\n+    NOT_POWER_OF_TWO_PLUS_ONE(\"{0} is not a power of 2 plus one\"),\n+    NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not strictly decreasing ({2} <= {3})\"),\n+    NOT_STRICTLY_INCREASING_KNOT_VALUES(\"knot values must be strictly increasing\"),\n+    NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not strictly increasing ({2} >= {3})\"),\n+    NOT_SUBTRACTION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not subtraction compatible\"),\n+    NOT_SYMMETRIC_MATRIX(\"not symmetric matrix\"),\n+    NO_BIN_SELECTED(\"no bin selected\"),\n+    NO_CONVERGENCE_WITH_ANY_START_POINT(\"none of the {0} start points lead to convergence\"),\n+    NO_DATA(\"no data\"),\n+    NO_DEGREES_OF_FREEDOM(\"no degrees of freedom ({0} measurements, {1} parameters)\"),\n+    NO_DENSITY_FOR_THIS_DISTRIBUTION(\"This distribution does not have a density function implemented\"),\n+    NO_FEASIBLE_SOLUTION(\"no feasible solution\"),\n+    NO_OPTIMUM_COMPUTED_YET(\"no optimum computed yet\"),\n+    NO_RESULT_AVAILABLE(\"no result available\"),\n+    NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n+    NULL_COVARIANCE_MATRIX(\"covariance matrix is null\"),\n+    NULL_DENOMINATOR(\"denominator is null\"),\n+    NULL_DENOMINATOR_FORMAT(\"denominator format can not be null\"),\n+    NULL_FRACTION(\"null fraction\"),\n+    NULL_FUNCTION(\"function is null\"),\n+    NULL_IMAGINARY_FORMAT(\"null imaginary format\"),\n+    NULL_INPUT_ARRAY(\"input values array is null\"),\n+    NULL_NUMERATOR(\"numerator is null\"),\n+    NULL_NUMERATOR_FORMAT(\"numerator format can not be null\"),\n+    NULL_OBJECT_TRANSFORMATION(\"Conversion Exception in Transformation, Object is null\"),\n+    NULL_REAL_FORMAT(\"null real format\"),\n+    NULL_WHOLE_FORMAT(\"whole format can not be null\"),\n+    NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE(\"number of successes ({0}) must be less than or equal to population size ({1})\"),\n+    NUMERATOR_OVERFLOW_AFTER_MULTIPLY(\"overflow, numerator too large after multiply: {0}\"),\n+    N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED(\"{0} points Legendre-Gauss integrator not supported, number of points must be in the {1}-{2} range\"),\n+    OBSERVED_COUNTS_ALL_ZERO(\"observed counts are all 0 in observed array {0}\"),\n+    OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY(\"observed counts are both zero for entry {0}\"),\n+    OUT_OF_BOUNDS_QUANTILE_VALUE(\"out of bounds quantile value: {0}, must be in (0, 100]\"),\n+    OUT_OF_BOUND_SIGNIFICANCE_LEVEL(\"out of bounds significance level {0}, must be between {1} and {2}\"),\n+    OUT_OF_ORDER_ABSCISSA_ARRAY(\"the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}\"),\n+    OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n+    OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"),\n+    OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n+    PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD(\"cannot access {0} method in percentile implementation {1}\"),\n+    PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD(\"percentile implementation {0} does not support {1}\"),\n+    PERMUTATION_EXCEEDS_N(\"permutation k ({0}) exceeds n ({1})\"),\n+    POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS(\"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\"),\n+    POSITION_SIZE_MISMATCH_INPUT_ARRAY(\"position {0} and size {1} don't fit to the size of the input array {2}\"),\n+    POWER_NEGATIVE_PARAMETERS(\"cannot raise an integral value to a negative power ({0}^{1})\"),\n+    PROPAGATION_DIRECTION_MISMATCH(\"propagation direction mismatch\"),\n+    ROOTS_OF_UNITY_NOT_COMPUTED_YET(\"roots of unity have not been computed yet\"),\n+    ROTATION_MATRIX_DIMENSIONS(\"a {0}x{1} matrix cannot be a rotation matrix\"),\n+    ROW_INDEX_OUT_OF_RANGE(\"row index {0} out of allowed range [{1}, {2}]\"),\n+    SAME_SIGN_AT_ENDPOINTS(\"function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]\"),\n+    SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE(\"sample size ({0}) exceeds collection size ({1})\"),\n+    SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE(\"sample size ({0}) must be less than or equal to population size ({1})\"),\n+    SIMPLEX_NEED_ONE_POINT(\"simplex must contain at least one point\"),\n+    SIMPLE_MESSAGE(\"{0}\"),\n+    SINGULAR_MATRIX(\"matrix is singular\"),\n+    SUBARRAY_ENDS_AFTER_ARRAY_END(\"subarray ends after array end\"),\n+    TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n+    TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n+    TOO_SMALL_BANDWIDTH(\"the bandwidth must be large enough to accomodate at least 2 points. There are {0}  data points, and bandwidth must be at least {1}  but it is only {2}\"),\n+    TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n+    TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n+    TOO_SMALL_ORTHOGONALITY_TOLERANCE(\"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\"),\n+    TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE(\"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\"),\n+    TWO_OR_MORE_CATEGORIES_REQUIRED(\"two or more categories required, got {0}\"),\n+    TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED(\"two or more values required in each category, one has {0}\"),\n+    UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH(\"unable to bracket optimum in line search\"),\n+    UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM(\"unable to compute covariances: singular problem\"),\n+    UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS(\"unable to first guess the harmonic coefficients\"),\n+    UNABLE_TO_ORTHOGONOLIZE_MATRIX(\"unable to orthogonalize matrix in {0} iterations\"),\n+    UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\"),\n+    UNABLE_TO_SOLVE_SINGULAR_PROBLEM(\"unable to solve: singular problem\"),\n+    UNBOUNDED_SOLUTION(\"unbounded solution\"),\n+    UNKNOWN_MODE(\"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\"),\n+    UNPARSEABLE_3D_VECTOR(\"unparseable 3D vector: \\\"{0}\\\"\"),\n+    UNPARSEABLE_COMPLEX_NUMBER(\"unparseable complex number: \\\"{0}\\\"\"),\n+    UNPARSEABLE_FRACTION_NUMBER(\"unparseable fraction number: \\\"{0}\\\"\"),\n+    UNPARSEABLE_REAL_VECTOR(\"unparseable real vector: \\\"{0}\\\"\"),\n+    UNSUPPORTED_EXPANSION_MODE(\"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\"),\n+    URL_CONTAINS_NO_DATA(\"URL {0} contains no data\"),\n+    VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC(\"{0} values have been added before statistic is configured\"),\n+    VECTOR_LENGTH_MISMATCH(\"vector length mismatch: got {0} but expected {1}\"),\n+    VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT(\"vector must have at least one element\"),\n+    WRONG_BLOCK_LENGTH(\"wrong array shape (block length = {0}, expected {1})\"),\n+    WRONG_NUMBER_OF_POINTS(\"{0} points are required, got only {1}\"),\n+    ZERO_DENOMINATOR(\"denominator must be different from 0\"),\n+    ZERO_DENOMINATOR_IN_FRACTION(\"zero denominator in fraction {0}/{1}\"),\n+    ZERO_FRACTION_TO_DIVIDE_BY(\"the fraction to divide by must not be zero: {0}/{1}\"),\n+    ZERO_NORM(\"zero norm\"),\n+    ZERO_NORM_FOR_ROTATION_AXIS(\"zero norm for rotation axis\"),\n+    ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR(\"zero norm for rotation defining vector\");\n+\n+    // CHECKSTYLE: resume MultipleVariableDeclarations\n+\n+\n+    /** Source English format. */\n+    private final String sourceFormat;\n+\n+    /** Simple constructor.\n+     * @param sourceFormat source English format to use when no\n+     * localized version is available\n+     */\n+    private LocalizedFormats(final String sourceFormat) {\n+        this.sourceFormat = sourceFormat;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getSourceString() {\n+        return sourceFormat;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getLocalizedString(final Locale locale) {\n+        try {\n+            ResourceBundle bundle =\n+                    ResourceBundle.getBundle(\"META-INF/localization/LocalizedFormats\", locale);\n+            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated format\n+                return bundle.getString(toString());\n+            }\n+\n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // either the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the source format\n+        return sourceFormat;\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         throws IllegalArgumentException {\n         if (n < k) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n+                LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                 n, k);\n         }\n         if (n < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n+                  LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER,\n                   n);\n         }\n     }\n     public static long factorial(final int n) {\n         if (n < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"must have n >= 0 for n!, got n = {0}\",\n+                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                   n);\n         }\n         if (n > 20) {\n     public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"must have n >= 0 for n!, got n = {0}\",\n+                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                   n);\n         }\n         if (n < 21) {\n     public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"must have n >= 0 for n!, got n = {0}\",\n+                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                   n);\n         }\n         if (n < 21) {\n         if ((u == 0) || (v == 0)) {\n             if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                 throw MathRuntimeException.createArithmeticException(\n-                        \"overflow: gcd({0}, {1}) is 2^31\",\n+                        LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                         p, q);\n             }\n             return Math.abs(u) + Math.abs(v);\n         }\n         if (k == 31) {\n             throw MathRuntimeException.createArithmeticException(\n-                    \"overflow: gcd({0}, {1}) is 2^31\",\n+                    LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                     p, q);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         if ((u == 0) || (v == 0)) {\n             if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n                 throw MathRuntimeException.createArithmeticException(\n-                        \"overflow: gcd({0}, {1}) is 2^63\",\n+                        LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                         p, q);\n             }\n             return Math.abs(u) + Math.abs(v);\n         }\n         if (k == 63) {\n             throw MathRuntimeException.createArithmeticException(\n-                    \"overflow: gcd({0}, {1}) is 2^63\",\n+                    LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                     p, q);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Integer.MIN_VALUE) {\n             throw MathRuntimeException.createArithmeticException(\n-                \"overflow: lcm({0}, {1}) is 2^31\",\n+                LocalizedFormats.LCM_OVERFLOW_32_BITS,\n                 a, b);\n         }\n         return lcm;\n         long lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Long.MIN_VALUE){\n             throw MathRuntimeException.createArithmeticException(\n-                \"overflow: lcm({0}, {1}) is 2^63\",\n+                LocalizedFormats.LCM_OVERFLOW_64_BITS,\n                 a, b);\n         }\n         return lcm;\n        throws ArithmeticException, IllegalArgumentException {\n          if (Double.isInfinite(normalizedSum)) {\n              throw MathRuntimeException.createIllegalArgumentException(\n-                     \"Cannot normalize to an infinite value\");\n+                     LocalizedFormats.NORMALIZE_INFINITE);\n          }\n          if (Double.isNaN(normalizedSum)) {\n              throw MathRuntimeException.createIllegalArgumentException(\n-                     \"Cannot normalize to NaN\");\n+                     LocalizedFormats.NORMALIZE_NAN);\n          }\n          double sum = 0d;\n          final int len = values.length;\n          for (int i = 0; i < len; i++) {\n              if (Double.isInfinite(values[i])) {\n                  throw MathRuntimeException.createArithmeticException(\n-                         \"Array contains an infinite element, {0} at index {1}\", values[i], i);\n+                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n              }\n              if (!Double.isNaN(values[i])) {\n                  sum += values[i];\n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n \n         if (e.compareTo(BigInteger.ZERO) < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                 k, e);\n         }\n \n             if (dir > 0) {\n                 if (strict) {\n                     if (val[i] <= previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n+                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n                                                                                   i - 1, i, previous, val[i]);\n                     }\n                 } else {\n                     if (val[i] < previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not increasing ({2} > {3})\",\n+                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_INCREASING_NUMBER_OF_POINTS,\n                                                                                   i - 1, i, previous, val[i]);\n                     }\n                 }\n             } else {\n                 if (strict) {\n                     if (val[i] >= previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not strictly decreasing ({2} <= {3})\",\n+                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS,\n                                                                                   i - 1, i, previous, val[i]);\n                     }\n                 } else {\n                     if (val[i] > previous) {\n-                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not decreasing ({2} < {3})\",\n+                        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_DECREASING_NUMBER_OF_POINTS,\n                                                                                   i - 1, i, previous, val[i]);\n                     }\n                 }\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3646337053166149105L;\n \n-    /** Message for map modification during iteration. */\n-    private static final String CONCURRENT_MODIFICATION_MESSAGE =\n-        \"map has been modified while iterating\";\n-\n-    /** Message for exhausted iterator. */\n-    private static final String EXHAUSTED_ITERATOR_MESSAGE =\n-        \"iterator exhausted\";\n-\n     /** Load factor for the map. */\n     private static final float LOAD_FACTOR = 0.5f;\n \n         public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n             }\n             return keys[current];\n         }\n         public double value()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n             }\n             return values[current];\n         }\n             throws ConcurrentModificationException, NoSuchElementException {\n \n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n \n             // advance on step\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 next = -2;\n                 if (current < 0) {\n-                    throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                    throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n                 }\n             }\n \n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -9179080286849120720L;\n \n-    /** Message for map modification during iteration. */\n-    private static final String CONCURRENT_MODIFICATION_MESSAGE =\n-        \"map has been modified while iterating\";\n-\n-    /** Message for exhausted iterator. */\n-    private static final String EXHAUSTED_ITERATOR_MESSAGE =\n-        \"iterator exhausted\";\n-\n     /** Load factor for the map. */\n     private static final float LOAD_FACTOR = 0.5f;\n \n         public int key()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n             }\n             return keys[current];\n         }\n         public T value()\n             throws ConcurrentModificationException, NoSuchElementException {\n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n             if (current < 0) {\n-                throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n             }\n             return values[current];\n         }\n             throws ConcurrentModificationException, NoSuchElementException {\n \n             if (referenceCount != count) {\n-                throw MathRuntimeException.createConcurrentModificationException(\n-                      CONCURRENT_MODIFICATION_MESSAGE);\n+                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n             }\n \n             // advance on step\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 next = -2;\n                 if (current < 0) {\n-                    throw MathRuntimeException.createNoSuchElementException(EXHAUSTED_ITERATOR_MESSAGE);\n+                    throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n                 }\n             }\n \n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n     public synchronized double substituteMostRecentElement(double value) {\n         if (numElements < 1) {\n             throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n-                    \"cannot substitute an element from an empty array\");\n+                    LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n         }\n \n         double discarded = internalArray[startIndex + (numElements - 1)];\n \n         if (expansion <= 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"expansion factor smaller than one ({0})\",\n+                    LocalizedFormats.EXPANSION_FACTOR_SMALLER_THAN_ONE,\n                     expansion);\n         }\n     }\n     private synchronized void discardExtremeElements(int i,boolean front) {\n         if (i > numElements) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"cannot discard {0} elements from a {1} elements array\",\n+                    LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n                     i, numElements);\n        } else if (i < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n-                   \"cannot discard a negative number of elements ({0})\",\n+                   LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS,\n                    i);\n         } else {\n             // \"Subtract\" this number of discarded from numElements\n     public synchronized double getElement(int index) {\n         if (index >= numElements) {\n             throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n-                    \"the index specified: {0} is larger than the current maximal index {1}\",\n+                    LocalizedFormats.INDEX_LARGER_THAN_MAX,\n                     index, numElements - 1);\n         } else if (index >= 0) {\n             return internalArray[startIndex + index];\n         } else {\n             throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n-                    \"elements cannot be retrieved from a negative array index {0}\",\n+                    LocalizedFormats.CANNOT_RETRIEVE_AT_NEGATIVE_INDEX,\n                     index);\n         }\n     }\n     public synchronized void setElement(int index, double value) {\n         if (index < 0) {\n             throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n-                    \"cannot set an element at a negative index {0}\",\n+                    LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX,\n                     index);\n         }\n         if (index + 1 > numElements) {\n         if (expansionMode != MULTIPLICATIVE_MODE &&\n                 expansionMode != ADDITIVE_MODE) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n+                    LocalizedFormats.UNSUPPORTED_EXPANSION_MODE,\n                     expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n                     ADDITIVE_MODE, \"ADDITIVE_MODE\");\n         }\n             }\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"initial capacity ({0}) is not positive\",\n+                    LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE,\n                     initialCapacity);\n         }\n     }\n         // If index is negative thrown an error\n         if (i < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"index ({0}) is not positive\",\n+                    LocalizedFormats.INDEX_NOT_POSITIVE,\n                     i);\n         }\n \n--- a/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n \n import java.util.Locale;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n+\n /**\n  * @version $Revision$ $Date$\n  */\n     }\n \n     public void testConstructorPatternArguments(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         ConvergenceException ex = new ConvergenceException(pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorPatternArgumentsCause(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n--- a/src/test/java/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n package org.apache.commons.math;\n \n import java.util.Locale;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n \n import junit.framework.TestCase;\n \n     }\n \n     public void testConstructorPatternArguments(){\n-        String pattern = \"evaluation failed for argument = {0}\";\n+        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;\n         Object[] arguments = { Double.valueOf(0.0) };\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorArrayPatternArguments(){\n-        String pattern = \"evaluation failed for argument = {0}\";\n+        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;\n         Object[] arguments = { Double.valueOf(0.0) };\n         FunctionEvaluationException ex =\n             new FunctionEvaluationException(new double[] { 0, 1, 2 }, pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorPatternArgumentsCause(){\n-        String pattern = \"evaluation failed for argument = {0}\";\n+        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;\n         Object[] arguments = { Double.valueOf(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorArrayPatternArgumentsCause(){\n-        String pattern = \"evaluation failed for argument = {0}\";\n+        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;\n         Object[] arguments = { Double.valueOf(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         FunctionEvaluationException ex =\n             new FunctionEvaluationException(cause, new double[] { 0, 1, 2 }, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n--- a/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n \n import java.util.Locale;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n+\n /**\n  * @version $Revision$ $Date$\n  */\n     }\n \n     public void testConstructorPatternArguments(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorPatternArgumentsCause(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n--- a/src/test/java/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathExceptionTest.java\n import java.io.PrintWriter;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.DummyLocalizable;\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n /**\n  * @version $Revision$ $Date$\n  */\n     }\n \n     public void testConstructorPatternArguments(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathException ex = new MathException(pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n     }\n \n     public void testConstructorPatternArgumentsCause(){\n-        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(cause, pattern, arguments);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getPattern());\n+        assertEquals(pattern, ex.getLocalizablePattern());\n         assertEquals(arguments.length, ex.getArguments().length);\n         for (int i = 0; i < arguments.length; ++i) {\n             assertEquals(arguments[i], ex.getArguments()[i]);\n      * Tests the printStackTrace() operation.\n      */\n     public void testPrintStackTrace() {\n-        String outMsg = \"outer message\";\n-        String inMsg = \"inner message\";\n+        Localizable outMsg = new DummyLocalizable(\"outer message\");\n+        Localizable inMsg = new DummyLocalizable(\"inner message\");\n         MathException cause = new MathConfigurationException(inMsg);\n         MathException ex = new MathException(cause, outMsg);\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      * Test serialization\n      */\n     public void testSerialization() {\n-        String outMsg = \"outer message\";\n-        String inMsg = \"inner message\";\n+        Localizable outMsg = new DummyLocalizable(\"outer message\");\n+        Localizable inMsg = new DummyLocalizable(\"inner message\");\n         MathException cause = new MathConfigurationException(inMsg);\n         MathException ex = new MathException(cause, outMsg);\n         MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n         if (jdkSupportsNesting) {\n             assertEquals(stack, stack2);\n         } else {\n-            assertTrue(stack2.indexOf(inMsg) != -1);\n+            assertTrue(stack2.indexOf(inMsg.getSourceString()) != -1);\n             assertTrue(stack2.indexOf(\"MathConfigurationException\") != -1);\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n \n import java.util.Locale;\n \n+import org.apache.commons.math.util.LocalizedFormats;\n+\n import junit.framework.TestCase;\n \n /**\n     public void testComplexConstructor(){\n         MaxIterationsExceededException ex =\n             new MaxIterationsExceededException(1000000,\n-                \"Continued fraction convergents failed to converge for value {0}\",\n+                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                 1234567);\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n public class HighamHall54IntegratorTest\n   extends TestCase {\n             public void computeDerivatives(double t, double[] y, double[] dot)\n             throws DerivativeException {\n             if (t < -0.5) {\n-                throw new DerivativeException(\"{0}\", \"oops\");\n+                throw new DerivativeException(LocalizedFormats.SIMPLE_MESSAGE, \"oops\");\n             } else {\n                 throw new DerivativeException(new RuntimeException(\"oops\"));\n            }\n           double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n           double offset = t - middle;\n           if (offset > 0) {\n-            throw new EventException(\"Evaluation failed for argument = {0}\", t);\n+            throw new EventException(LocalizedFormats.EVALUATION_FAILED, t);\n           }\n           return offset;\n         }\n--- a/src/test/java/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/java/org/apache/commons/math/util/TestBean.java\n      *\n      */\n     public Double getZ() {\n-        throw new MathRuntimeException(\"?\");\n+        throw new MathRuntimeException(LocalizedFormats.SIMPLE_MESSAGE, \"?\");\n     }\n \n     /**", "timestamp": 1276729418, "metainfo": ""}