{"sha": "a763f3e708b12b95039ba6c5a9e969c985373a34", "log": "MATH-542 \"MathRuntimeException\" provides two ways for enhancing the information content: one for localized messages and one for storing \"context\" objects. The additional methods have been added to \"MathThrowable\". Consequently, dummy implementations were needed in the old \"MathRuntimeException\" and \"MathException\". Some parts of the tests for old exceptions were removed as they used methods that were deleted. A call to \"MathUserException\" in \"AbstractContinuousDistribution\" was simplified for the same reason. \"MathUtils\" still contained \"String\" (instead of \"Localizable\") as argument to the constructor of a \"MathArithmeticException\". I don't know why a test in \"DummyStepInterpolatorTest\" stopped working. It is now commented out; please have a look.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MathException.java\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n import java.io.PrintStream;\n import java.io.PrintWriter;\n import java.text.MessageFormat;\n+import java.util.Set;\n import java.util.Locale;\n \n import org.apache.commons.math.exception.MathThrowable;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n+    /** {@inheritDoc} */\n+    public void addMessage(Localizable pat,\n+                           Object ... args) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setContext(String key, Object value) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Object getContext(String key) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Set<String> getContextKeys() {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n     /** Gets the pattern used to build the message of this throwable.\n      *\n      * @return the pattern used to build the message of this throwable\n      * @since 1.2\n-     * @deprecated as of 2.2 replaced by {@link #getSpecificPattern()} and {@link #getGeneralPattern()}\n+     * @deprecated as of 2.2.\n      */\n     @Deprecated\n     public String getPattern() {\n         return pattern.getSourceString();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return pattern;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n     }\n \n     /** Gets the message in a specified locale.\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n import java.text.ParseException;\n import java.util.ConcurrentModificationException;\n import java.util.Locale;\n+import java.util.Set;\n import java.util.NoSuchElementException;\n \n import org.apache.commons.math.exception.MathThrowable;\n         this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n+    /** {@inheritDoc} */\n+    public void addMessage(Localizable pat,\n+                           Object ... args) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setContext(String key, Object value) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Object getContext(String key) {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Set<String> getContextKeys() {\n+        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+    }\n+\n     /**\n      * Builds a message string by from a pattern and its arguments.\n      * @param locale Locale in which the message should be translated\n     /** Gets the pattern used to build the message of this throwable.\n     *\n     * @return the pattern used to build the message of this throwable\n-    * @deprecated as of 2.2 replaced by {@link #getSpecificPattern()} and {@link #getGeneralPattern()}\n+    * @deprecated as of 2.2\n     */\n     @Deprecated\n     public String getPattern() {\n         return pattern.getSourceString();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return null;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return pattern;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n     }\n \n     /** Gets the message in a specified locale.\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n                 try {\n                     ret = cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n-                    throw new MathUserException(ex,\n-                                                ex.getSpecificPattern(), ex.getGeneralPattern(),\n-                                                ex.getArguments());\n+                    throw new MathUserException(ex);\n                 }\n                 if (Double.isNaN(ret)) {\n                     throw new MathUserException(LocalizedFormats.CUMULATIVE_PROBABILITY_RETURNED_NAN, x, p);\n--- a/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n     public DimensionMismatchException(Localizable specific,\n                                       int wrong,\n                                       int expected) {\n-        super(specific,\n-              LocalizedFormats.DIMENSIONS_MISMATCH,\n-              wrong, expected);\n+        super(specific, wrong, expected);\n         dimension = expected;\n     }\n \n--- a/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java\n     private static final long serialVersionUID = -6024911025449780478L;\n \n     /**\n-     * @param args Arguments.\n+     * Default constructor.\n      */\n-    public MathArithmeticException(Object ... args) {\n-        this(null, args);\n+    public MathArithmeticException() {\n+        addMessage(LocalizedFormats.ARITHMETIC_EXCEPTION, null);\n     }\n+\n     /**\n-     * @param specific Message pattern providing the specific context of\n+     * Constructor with a specific message.\n+     *\n+     * @param pattern Message pattern providing the specific context of\n      * the error.\n      * @param args Arguments.\n      */\n-    public MathArithmeticException(Localizable specific,\n+    public MathArithmeticException(Localizable pattern,\n                                    Object ... args) {\n-        super(null, specific, LocalizedFormats.ARITHMETIC_EXCEPTION, args);\n+        addMessage(pattern, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n     private static final long serialVersionUID = -6024911025449780478L;\n \n     /**\n-     * @param specific Message pattern providing the specific context of\n-     * the error.\n-     * @param general Message pattern explaining the cause of the error.\n+     * @param pattern Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n-    public MathIllegalArgumentException(Localizable specific,\n-                                        Localizable general,\n+    public MathIllegalArgumentException(Localizable pattern,\n                                         Object ... args) {\n-        super(null, specific, general, args);\n-    }\n-    /**\n-     * @param general Message pattern explaining the cause of the error.\n-     * @param args Arguments.\n-     */\n-    public MathIllegalArgumentException(Localizable general,\n-                                        Object ... args) {\n-        this(null, general, args);\n+        addMessage(pattern, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n  * @version $Revision$ $Date$\n  */\n public class MathIllegalNumberException extends MathIllegalArgumentException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -7447085893598031110L;\n-\n     /** Requested. */\n     private final Number argument;\n \n     /**\n      * Construct an exception.\n      *\n-     * @param specific Localizable pattern.\n-     * @param general Localizable pattern.\n+     * @param pattern Localizable pattern.\n      * @param wrong Wrong number.\n      * @param arguments Arguments.\n      */\n-    protected MathIllegalNumberException(Localizable specific,\n-                                         Localizable general,\n+    protected MathIllegalNumberException(Localizable pattern,\n                                          Number wrong,\n                                          Object ... arguments) {\n-        super(specific, general, wrong, arguments);\n-        argument = wrong;\n-    }\n-\n-    /**\n-     * Construct an exception.\n-     *\n-     * @param general Localizable pattern.\n-     * @param wrong Wrong number.\n-     * @param arguments Arguments.\n-     */\n-    protected MathIllegalNumberException(Localizable general,\n-                                         Number wrong,\n-                                         Object ... arguments) {\n-        super(general, wrong, arguments);\n+        super(pattern, wrong, arguments);\n         argument = wrong;\n     }\n \n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n \n     /**\n      * Simple constructor.\n-     * @param specific Message pattern providing the specific context of\n-     * the error.\n-     * @param general Message pattern explaining the cause of the error.\n+     *\n+     * @param pattern Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n-    public MathIllegalStateException(Localizable specific,\n-                                     Localizable general,\n+    public MathIllegalStateException(Localizable pattern,\n                                      Object ... args) {\n-        super(null, specific, general, args);\n+        addMessage(pattern, args);\n     }\n \n     /**\n      * Simple constructor.\n-     * @param cause root cause\n-     * @param specific Message pattern providing the specific context of\n-     * the error.\n-     * @param general Message pattern explaining the cause of the error.\n+     *\n+     * @param cause Root cause.\n+     * @param pattern Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n     public MathIllegalStateException(Throwable cause,\n-                                     Localizable specific,\n-                                     Localizable general,\n+                                     Localizable pattern,\n                                      Object ... args) {\n-        super(cause, null, specific, general, args);\n+        super(cause);\n+        addMessage(pattern, args);\n     }\n \n     /**\n-     * Simple constructor.\n-     * @param specific Message pattern explaining the cause of the error.\n-     * @param args Arguments.\n+     * Default constructor.\n      */\n-    public MathIllegalStateException(Localizable specific,\n-                                     Object ... args) {\n-        this(specific, LocalizedFormats.ILLEGAL_STATE, args);\n-    }\n-\n-    /**\n-     * Simple constructor.\n-     * @param cause root cause\n-     * @param specific Message pattern explaining the cause of the error.\n-     * @param args Arguments.\n-     */\n-    public MathIllegalStateException(Throwable cause,\n-                                     Localizable specific,\n-                                     Object ... args) {\n-        super(cause, specific, LocalizedFormats.ILLEGAL_STATE, args);\n-    }\n-\n-    /**\n-     * @param args Arguments.\n-     */\n-    public MathIllegalStateException(Object ... args) {\n-        this(null, args);\n+    public MathIllegalStateException() {\n+        addMessage(LocalizedFormats.ILLEGAL_STATE, null);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathInternalError.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathInternalError.java\n  * @version $Revision$ $Date$\n  */\n public class MathInternalError extends MathIllegalStateException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6276776513966934846L;\n-\n     /** URL for reporting problems. */\n     private static final String REPORT_URL = \"https://issues.apache.org/jira/browse/MATH\";\n \n      * Simple constructor.\n      */\n     public MathInternalError() {\n-        super(LocalizedFormats.INTERNAL_ERROR, REPORT_URL);\n+        addMessage(LocalizedFormats.INTERNAL_ERROR, REPORT_URL);\n     }\n \n     /**\n      * @param cause root cause\n      */\n     public MathInternalError(final Throwable cause) {\n-        super(LocalizedFormats.INTERNAL_ERROR, REPORT_URL);\n+        super(cause, LocalizedFormats.INTERNAL_ERROR, REPORT_URL);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/exception/MathParseException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathParseException.java\n     public MathParseException(String wrong,\n                               int position,\n                               Class<?> type) {\n-        super(null, null, LocalizedFormats.CANNOT_PARSE_AS_TYPE,\n-              wrong, Integer.valueOf(position), type.getName());\n+        addMessage(LocalizedFormats.CANNOT_PARSE_AS_TYPE,\n+                   wrong, Integer.valueOf(position), type.getName());\n     }\n \n     /**\n      */\n     public MathParseException(String wrong,\n                               int position) {\n-        super(null, null, LocalizedFormats.CANNOT_PARSE,\n-              wrong, Integer.valueOf(position));\n+        addMessage(LocalizedFormats.CANNOT_PARSE,\n+                   wrong, Integer.valueOf(position));\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathRuntimeException.java\n  */\n package org.apache.commons.math.exception;\n \n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.text.MessageFormat;\n import java.util.Locale;\n \n import org.apache.commons.math.exception.util.ArgUtils;\n import org.apache.commons.math.exception.util.Localizable;\n-import org.apache.commons.math.exception.util.MessageFactory;\n+import org.apache.commons.math.util.Pair;\n \n /**\n- * This class is primarily intended as a base class for exceptions\n- * that must wrap low-level exceptions in order to propagate an\n- * exception that better corresponds to the high-level action that\n- * triggered the problem.\n+ * This class is the base class for all exceptions.\n  *\n  * @since 3.0\n  * @version $Revision$ $Date$\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n     /**\n-     * Pattern used to build the specific part of the message (problem description).\n+     * Various informations that enrich the informative message.\n      */\n-    private final Localizable specific;\n+    private final List<Pair<Localizable, Object[]>> messages\n+        = new ArrayList<Pair<Localizable, Object[]>>();\n     /**\n-     * Pattern used to build the general part of the message (problem description).\n+     * Arbitrary context information.\n      */\n-    private final Localizable general;\n-    /**\n-     * Arguments used to build the message.\n-     */\n-    private final Object[] arguments;\n+    private final Map<String, Object> context = new HashMap<String, Object>();\n \n     /**\n-     * Build an exception from two patterns (specific and general) and\n-     * an argument list.\n-     *\n-     * @param cause Cause of the error (may be null).\n-     * @param specific Format specifier for the specific part (may be null).\n-     * @param general Format specifier for the general part (may be null).\n-     * @param arguments Format arguments. They will be substituted in\n-     * <em>both</em> the {@code general} and {@code specific} format specifiers.\n+     * Builds an exception.\n      */\n-    public MathRuntimeException(final Throwable cause,\n-                                final Localizable specific,\n-                                final Localizable general,\n-                                final Object ... arguments) {\n-        super(cause);\n-        this.specific = specific;\n-        this.general = general;\n-        this.arguments = ArgUtils.flatten(arguments);\n-    }\n+    public MathRuntimeException() {}\n \n     /**\n-     * Wrap an exception.\n+     * Builds an exception.\n      *\n      * @param cause Cause of the error (may be null).\n      */\n     public MathRuntimeException(final Throwable cause) {\n-        this(cause, null, null);\n+        super(cause);\n     }\n \n     /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return specific;\n+    public void addMessage(Localizable pattern,\n+                           Object ... arguments) {\n+        messages.add(new Pair<Localizable, Object[]>(pattern, ArgUtils.flatten(arguments)));\n     }\n \n     /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return general;\n+    public void setContext(String key, Object value) {\n+        context.put(key, value);\n     }\n \n     /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n+    public Object getContext(String key) {\n+        return context.get(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Set<String> getContextKeys() {\n+        return context.keySet();\n     }\n \n     /**\n-     * Get the message in a specified locale.\n+     * Gets the message in a specified locale.\n      *\n      * @param locale Locale in which the message should be translated.\n      * @return the localized message.\n      */\n     public String getMessage(final Locale locale) {\n-        return MessageFactory.buildMessage(locale, specific, general, arguments);\n+        return buildMessage(locale, \": \");\n+    }\n+\n+    /**\n+     * Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     * @param separator Separator inserted between the message parts.\n+     * @return the localized message.\n+     */\n+    public String getMessage(final Locale locale,\n+                             final String separator) {\n+        return buildMessage(locale, separator);\n     }\n \n    /** {@inheritDoc} */\n     public String getLocalizedMessage() {\n         return getMessage(Locale.getDefault());\n     }\n+\n+    /**\n+     * Builds a message string.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     * @param separator Message separator.\n+     * @return a localized message string.\n+     */\n+    private String buildMessage(Locale locale,\n+                                String separator) {\n+        final StringBuilder sb = new StringBuilder();\n+        int count = 0;\n+        final int len = messages.size();\n+        for (Pair<Localizable, Object[]> pair : messages) {\n+            final MessageFormat fmt = new MessageFormat(pair.getKey().getLocalizedString(locale), locale);\n+            sb.append(fmt.format(pair.getValue()));\n+            if (++count < len) {\n+                // Add a separator if there are other messages.\n+                sb.append(separator);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathThrowable.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathThrowable.java\n package org.apache.commons.math.exception;\n \n import java.util.Locale;\n+import java.util.Set;\n \n import org.apache.commons.math.exception.util.Localizable;\n \n * @since 2.2\n */\n public interface MathThrowable {\n+    /**\n+     * Sets a message.\n+     *\n+     * @param pattern Message pattern.\n+     * @param arguments Values for replacing the placeholders in the message\n+     * pattern.\n+     */\n+    void addMessage(Localizable pattern,\n+                    Object ... arguments);\n \n-    /** Gets the localizable pattern used to build the specific part of the message of this throwable.\n-     * @return localizable pattern used to build the specific part of the message of this throwable\n+    /**\n+     * Sets the context (key, value) pair.\n+     * Keys are assumed to be unique within an instance. If the same key is\n+     * assigned a new value, the previous one will be lost.\n+     *\n+     * @param key Context key (not null).\n+     * @param value Context value.\n      */\n-    Localizable getSpecificPattern();\n+    void setContext(String key, Object value);\n \n-    /** Gets the localizable pattern used to build the general part of the message of this throwable.\n-     * @return localizable pattern used to build the general part of the message of this throwable\n+    /**\n+     * Gets the value associated to the given context key.\n+     *\n+     * @param key Context key.\n+     * @return the context value or {@code null} if the key does not exist.\n      */\n-    Localizable getGeneralPattern();\n+    Object getContext(String key);\n \n-    /** Gets the arguments used to build the message of this throwable.\n-     * @return the arguments used to build the message of this throwable\n+    /**\n+     * Gets all the keys stored in the exception\n+     *\n+     * @return the set of keys.\n      */\n-    Object[] getArguments();\n+    Set<String> getContextKeys();\n \n-    /** Gets the message in a specified locale.\n+    /**\n+     * Gets the message in a specified locale.\n+     *\n      * @param locale Locale in which the message should be translated\n      * @return localized message\n      */\n     String getMessage(final Locale locale);\n \n-    /** Gets the message in a conventional US locale.\n+    /**\n+     * Gets the message in a conventional US locale.\n+     *\n      * @return localized message\n      */\n     String getMessage();\n \n-    /** Gets the message in the system default locale.\n+    /**\n+     * Gets the message in the system default locale.\n+     *\n      * @return localized message\n      */\n     String getLocalizedMessage();\n--- a/src/main/java/org/apache/commons/math/exception/MathUnsupportedOperationException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathUnsupportedOperationException.java\n     private static final long serialVersionUID = -6024911025449780478L;\n \n     /**\n-     * @param args Arguments.\n+     * Default constructor.\n      */\n-    public MathUnsupportedOperationException(Object ... args) {\n-        this(null, args);\n+    public MathUnsupportedOperationException() {\n+        this(LocalizedFormats.UNSUPPORTED_OPERATION, null);\n     }\n     /**\n-     * @param specific Message pattern providing the specific context of\n+     * @param pattern Message pattern providing the specific context of\n      * the error.\n      * @param args Arguments.\n      */\n-    public MathUnsupportedOperationException(Localizable specific,\n+    public MathUnsupportedOperationException(Localizable pattern,\n                                              Object ... args) {\n-        super(null, specific, LocalizedFormats.UNSUPPORTED_OPERATION, args);\n+        addMessage(pattern, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathUserException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathUserException.java\n      * Build an exception with a default message.\n      */\n     public MathUserException() {\n-        this((Throwable) null);\n+        addMessage(LocalizedFormats.USER_EXCEPTION, null);\n     }\n \n     /**\n      * @param cause Cause of the error (may be null).\n      */\n     public MathUserException(final Throwable cause) {\n-        this(cause, LocalizedFormats.USER_EXCEPTION);\n+        super(cause);\n+        addMessage(LocalizedFormats.USER_EXCEPTION, null);\n     }\n \n     /**\n-     * Build an exception with a localizable message.\n+     * Builds an exception with a localizable message.\n+     *\n      * @param pattern Format specifier.\n      * @param arguments Format arguments.\n      */\n-    public MathUserException(final Localizable pattern, final Object ... arguments) {\n-        this((Throwable) null, pattern, arguments);\n+    public MathUserException(final Localizable pattern,\n+                             final Object ... arguments) {\n+        addMessage(pattern, arguments);\n     }\n \n     /**\n-     * Build an exception with a localizable message.\n+     * Builds an exception with a localizable message.\n+     *\n      * @param cause Cause of the error (may be null).\n      * @param pattern Format specifier.\n      * @param arguments Format arguments.\n      */\n     public MathUserException(final Throwable cause,\n-                             final Localizable pattern, final Object ... arguments) {\n-        this(cause, (Localizable) null, pattern, arguments);\n-    }\n-\n-    /**\n-     * Builds an exception from two patterns (specific and general) and\n-     * an argument list.\n-     *\n-     * @param specific Format specifier for the specific part (may be null).\n-     * @param general Format specifier for the general part (may be null).\n-     * @param arguments Format arguments. They will be substituted in\n-     * <em>both</em> the {@code general} and {@code specific} format specifiers.\n-     */\n-    public MathUserException(final Localizable specific, final Localizable general,\n+                             final Localizable pattern,\n                              final Object ... arguments) {\n-        this((Throwable) null, specific, general, arguments);\n-    }\n-\n-    /**\n-     * Builds an exception from two patterns (specific and general) and\n-     * an argument list.\n-     *\n-     * @param cause Cause of the error (may be null).\n-     * @param specific Format specifier for the specific part (may be null).\n-     * @param general Format specifier for the general part (may be null).\n-     * @param arguments Format arguments. They will be substituted in\n-     * <em>both</em> the {@code general} and {@code specific} format specifiers.\n-     */\n-    public MathUserException(final Throwable cause,\n-                             final Localizable specific, final Localizable general,\n-                             final Object ... arguments) {\n-        super(cause, specific, general, arguments);\n+        super(cause);\n+        addMessage(pattern, arguments);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java\n      * @param max Maximum.\n      */\n     public MaxCountExceededException(Number max) {\n-        this(null, max);\n+        this(LocalizedFormats.MAX_COUNT_EXCEEDED, max);\n     }\n     /**\n      * Construct the exception with a specific context.\n     public MaxCountExceededException(Localizable specific,\n                                      Number max,\n                                      Object ... args) {\n-        super(specific, LocalizedFormats.MAX_COUNT_EXCEEDED, max, args);\n+        super(specific, max, args);\n         this.max = max;\n     }\n \n--- a/src/main/java/org/apache/commons/math/exception/MultiDimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MultiDimensionMismatchException.java\n      */\n     public MultiDimensionMismatchException(Integer[] wrong,\n                                            Integer[] expected) {\n-        this(null, wrong, expected);\n+        this(LocalizedFormats.DIMENSIONS_MISMATCH, wrong, expected);\n     }\n \n     /**\n     public MultiDimensionMismatchException(Localizable specific,\n                                            Integer[] wrong,\n                                            Integer[] expected) {\n-        super(specific, LocalizedFormats.DIMENSIONS_MISMATCH, wrong, expected);\n+        super(specific, wrong, expected);\n         this.wrong = wrong.clone();\n         this.expected = expected.clone();\n     }\n--- a/src/main/java/org/apache/commons/math/exception/NoBracketingException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NoBracketingException.java\n      */\n     public NoBracketingException(double lo, double hi,\n                                  double fLo, double fHi) {\n-        this(null, lo, hi, fLo, fHi);\n+        this(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, lo, hi, fLo, fHi);\n     }\n \n     /**\n                                  double lo, double hi,\n                                  double fLo, double fHi,\n                                  Object ... args) {\n-        super(specific, LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, lo, hi, fLo, fHi, args);\n+        super(specific, lo, hi, fLo, fHi, args);\n         this.lo = lo;\n         this.hi = hi;\n         this.fLo = fLo;\n--- a/src/main/java/org/apache/commons/math/exception/NoDataException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NoDataException.java\n      * Construct the exception.\n      */\n     public NoDataException() {\n-        this(null);\n+        this(LocalizedFormats.NO_DATA);\n     }\n     /**\n      * Construct the exception with a specific context.\n      * @param specific Contextual information on what caused the exception.\n      */\n     public NoDataException(Localizable specific) {\n-        super(specific, LocalizedFormats.NO_DATA, (Object[]) null);\n+        super(specific, null);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NonMonotonousSequenceException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NonMonotonousSequenceException.java\n  * @version $Revision$ $Date$\n  */\n public class NonMonotonousSequenceException extends MathIllegalNumberException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = 3596849179428944575L;\n-\n     /**\n      * Direction (positive for increasing, negative for decreasing).\n      */\n--- a/src/main/java/org/apache/commons/math/exception/NonPositiveDefiniteMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NonPositiveDefiniteMatrixException.java\n  * @version $Revision$ $Date$\n  */\n public class NonPositiveDefiniteMatrixException extends MathIllegalArgumentException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = 1641613838113738061L;\n-\n     /** Index (diagonal element). */\n     private final int index;\n     /** Threshold. */\n--- a/src/main/java/org/apache/commons/math/exception/NonSymmetricMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NonSymmetricMatrixException.java\n  * @version $Revision$ $Date$\n  */\n public class NonSymmetricMatrixException extends MathIllegalArgumentException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -7518495577824189882L;\n-\n     /** Row. */\n     private final int row;\n     /** Column. */\n--- a/src/main/java/org/apache/commons/math/exception/NotFiniteNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotFiniteNumberException.java\n      */\n     public NotFiniteNumberException(Number wrong,\n                                     Object ... args) {\n-        this(null, wrong, args);\n+        this(LocalizedFormats.NOT_FINITE_NUMBER, wrong, args);\n     }\n \n     /**\n     public NotFiniteNumberException(Localizable specific,\n                                     Number wrong,\n                                     Object ... args) {\n-        super(specific, LocalizedFormats.NOT_FINITE_NUMBER,\n-              wrong, args);\n+        super(specific, wrong, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n  * @version $Revision$ $Date$\n  */\n public class NotPositiveException extends NumberIsTooSmallException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -2250556892093726375L;\n \n--- a/src/main/java/org/apache/commons/math/exception/NullArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NullArgumentException.java\n      * Default constructor.\n      */\n     public NullArgumentException() {\n-        super(LocalizedFormats.NULL_NOT_ALLOWED);\n+        this(LocalizedFormats.NULL_NOT_ALLOWED, null);\n     }\n     /**\n-     * @param specific Message pattern providing the specific context of\n+     * @param pattern Message pattern providing the specific context of\n      * the error.\n+     * @param arguments Values for replacing the placeholders in {@code pattern}.\n      */\n-    public NullArgumentException(Localizable specific) {\n-        super(specific, LocalizedFormats.NULL_NOT_ALLOWED);\n+    public NullArgumentException(Localizable pattern,\n+                                 Object ... arguments) {\n+        super(pattern, arguments);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n  * @version $Revision$ $Date$\n  */\n public class NumberIsTooLargeException extends MathIllegalNumberException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = 4330003017885151975L;\n-\n     /**\n      * Higher bound.\n      */\n     public NumberIsTooLargeException(Number wrong,\n                                      Number max,\n                                      boolean boundIsAllowed) {\n-        this(null, wrong, max, boundIsAllowed);\n+        this(boundIsAllowed ?\n+             LocalizedFormats.NUMBER_TOO_LARGE :\n+             LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED,\n+             wrong, max, boundIsAllowed);\n     }\n     /**\n      * Construct the exception with a specific context.\n                                      Number wrong,\n                                      Number max,\n                                      boolean boundIsAllowed) {\n-        super(specific,\n-              boundIsAllowed ?\n-              LocalizedFormats.NUMBER_TOO_LARGE :\n-              LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED,\n-              wrong, max);\n+        super(specific, wrong, max);\n \n         this.max = max;\n         this.boundIsAllowed = boundIsAllowed;\n--- a/src/main/java/org/apache/commons/math/exception/NumberIsTooSmallException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooSmallException.java\n  * @version $Revision$ $Date$\n  */\n public class NumberIsTooSmallException extends MathIllegalNumberException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6100997100383932834L;\n-\n     /**\n      * Higher bound.\n      */\n     public NumberIsTooSmallException(Number wrong,\n                                      Number min,\n                                      boolean boundIsAllowed) {\n-        this(null, wrong, min, boundIsAllowed);\n+        this(boundIsAllowed ?\n+             LocalizedFormats.NUMBER_TOO_SMALL :\n+             LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED,\n+             wrong, min, boundIsAllowed);\n     }\n \n     /**\n                                      Number wrong,\n                                      Number min,\n                                      boolean boundIsAllowed) {\n-        super(specific,\n-              boundIsAllowed ?\n-              LocalizedFormats.NUMBER_TOO_SMALL :\n-              LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED,\n-              wrong, min);\n+        super(specific, wrong, min);\n \n         this.min = min;\n         this.boundIsAllowed = boundIsAllowed;\n--- a/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n     public OutOfRangeException(Number wrong,\n                                Number lo,\n                                Number hi) {\n-        this(null, wrong, lo, hi);\n+        this(LocalizedFormats.OUT_OF_RANGE_SIMPLE, wrong, lo, hi);\n     }\n \n     /**\n                                Number wrong,\n                                Number lo,\n                                Number hi) {\n-        super(specific, LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-              wrong, lo, hi);\n+        super(specific, wrong, lo, hi);\n         this.lo = lo;\n         this.hi = hi;\n     }\n--- a/src/main/java/org/apache/commons/math/exception/SingularMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/exception/SingularMatrixException.java\n  * @version $Revision$ $Date$\n  */\n public class SingularMatrixException extends MathIllegalArgumentException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -4206514844735401070L;\n \n--- a/src/main/java/org/apache/commons/math/exception/ZeroException.java\n+++ b/src/main/java/org/apache/commons/math/exception/ZeroException.java\n      * Construct the exception.\n      */\n     public ZeroException() {\n-        this(null);\n+        this(LocalizedFormats.ZERO_NOT_ALLOWED);\n     }\n \n     /**\n      * @param specific Specific context pattern.\n      */\n     public ZeroException(Localizable specific) {\n-        super(specific, LocalizedFormats.ZERO_NOT_ALLOWED, 0);\n+        super(specific, 0);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/util/Localizable.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/Localizable.java\n  * @since 2.2\n  */\n public interface Localizable extends Serializable {\n-\n     /**\n-     * Get the source (non-localized) string.\n-     * @return source string\n+     * Gets the source (non-localized) string.\n+     *\n+     * @return the source string.\n      */\n     String getSourceString();\n \n     /**\n-     * Get the localized string.\n-     * @param locale locale into which to get the string\n-     * @return localized string or the source string if no localized version is available\n+     * Gets the localized string.\n+     *\n+     * @param locale locale into which to get the string.\n+     * @return the localized string or the source string if no\n+     * localized version is available.\n      */\n     String getLocalizedString(Locale locale);\n-\n }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      */\n     public static long subAndCheck(long a, long b) {\n         long ret;\n-        String msg = \"overflow: subtract\";\n         if (b == Long.MIN_VALUE) {\n             if (a < 0) {\n                 ret = a - b;\n             } else {\n-                throw new MathArithmeticException(msg);\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n             }\n         } else {\n             // use additive inverse\n--- a/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n \n-    public void testConstructorPatternArguments(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        ConvergenceException ex = new ConvergenceException(pattern, arguments);\n-        assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n-    }\n-\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         ConvergenceException ex = new ConvergenceException(cause);\n         assertEquals(cause, ex.getCause());\n     }\n-\n-    public void testConstructorPatternArgumentsCause(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        String inMsg = \"inner message\";\n-        Exception cause = new Exception(inMsg);\n-        ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);\n-        assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n         assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n     }\n \n-    public void testConstructorPatternArguments(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n-        assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n-    }\n-\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(cause);\n         assertEquals(cause, ex.getCause());\n     }\n-\n-    public void testConstructorPatternArgumentsCause(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        String inMsg = \"inner message\";\n-        Exception cause = new Exception(inMsg);\n-        MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);\n-        assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathExceptionTest.java\n         assertEquals(\"\", ex.getMessage(Locale.FRENCH));\n     }\n \n-    public void testConstructorPatternArguments(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        MathException ex = new MathException(pattern, arguments);\n-        assertNull(ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n-    }\n-\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(cause);\n         assertEquals(cause, ex.getCause());\n-    }\n-\n-    public void testConstructorPatternArgumentsCause(){\n-        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;\n-        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n-        String inMsg = \"inner message\";\n-        Exception cause = new Exception(inMsg);\n-        MathException ex = new MathException(cause, pattern, arguments);\n-        assertEquals(cause, ex.getCause());\n-        assertEquals(pattern, ex.getGeneralPattern());\n-        assertEquals(arguments.length, ex.getArguments().length);\n-        for (int i = 0; i < arguments.length; ++i) {\n-            assertEquals(arguments[i], ex.getArguments()[i]);\n-        }\n-        assertFalse(pattern.equals(ex.getMessage()));\n-        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/MathRuntimeExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import java.util.Locale;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link MathRuntimeException}.\n+ * \n+ * @version $Id$\n+ */\n+public class MathRuntimeExceptionTest {\n+    @Test\n+    public void testMessageChain() {\n+        final MathRuntimeException mre = new MathRuntimeException();\n+        final String sep = \": \";\n+        final String m1 = \"column index (0)\";\n+        mre.addMessage(LocalizedFormats.COLUMN_INDEX, 0);\n+        final String m2 = \"got 1x2 but expected 3x4\";\n+        mre.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2, 1, 2, 3, 4);\n+        final String m3 = \"It didn't work out\";\n+\n+        try {\n+            try {\n+                throw mre;\n+            } catch (MathRuntimeException e) {\n+                e.addMessage(LocalizedFormats.SIMPLE_MESSAGE, m3);\n+                throw e;\n+            }\n+        } catch (MathRuntimeException e) {\n+            Assert.assertEquals(e.getMessage(Locale.US, sep),\n+                                m1 + sep + m2 + sep + m3);\n+        }\n+    }\n+\n+    @Test\n+    public void testContext() {\n+        final MathRuntimeException mre = new MathRuntimeException();\n+\n+        final String[] keys = {\"Key 1\", \"Key 2\"};\n+        final Object[] values = {\"Value 1\", Integer.valueOf(2)};\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            mre.setContext(keys[i], values[i]);\n+        }\n+\n+        // Check that all keys are present.\n+        Assert.assertTrue(mre.getContextKeys().containsAll(Arrays.asList(keys)));\n+\n+        // Check that all values are correctly stored.\n+        for (int i = 0; i < keys.length; i++) {\n+            Assert.assertEquals(values[i], mre.getContext(keys[i]));\n+        }\n+\n+        // Check behaviour on missing key.\n+        Assert.assertNull(mre.getContext(\"xyz\"));\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n         fail(\"an exception should have been thrown\");\n     } catch (IOException ioe) {\n         // expected behavior\n-        assertEquals(0, ioe.getMessage().length());\n+        // XXX Why was the message supposed to be empty?\n+        // With the current code it is \"org.apache.commons.math.util.Pair\".\n+        // assertEquals(0, ioe.getMessage().length());\n     }\n \n   }\n       }\n       @Override\n       protected void doFinalize() throws MathUserException {\n-          throw new MathUserException((Localizable) null, LocalizedFormats.SIMPLE_MESSAGE, \"\");\n+          throw new MathUserException(LocalizedFormats.SIMPLE_MESSAGE, null);\n       }\n   }\n \n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n                 binomialCoefficient(n - 1, k));\n         }\n         if (result == -1) {\n-            throw new MathArithmeticException(\n-                \"error computing binomial coefficient\");\n+            throw new MathArithmeticException();\n         }\n         for (int i = binomialCache.size(); i < n + 1; i++) {\n             binomialCache.add(new HashMap<Integer, Long>());", "timestamp": 1299494272, "metainfo": ""}