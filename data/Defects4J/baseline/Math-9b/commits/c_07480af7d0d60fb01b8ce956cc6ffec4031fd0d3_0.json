{"sha": "07480af7d0d60fb01b8ce956cc6ffec4031fd0d3", "log": "In package o.a.c.m.transform   - replaced RealTransformer.transform(double[]) and RealTransformer.inverseTransform(double[]) with RealTransformer.transform(double[], TransformType)   - replaced RealTransformer.transform(UnivariateFunction, double, double, int) and RealTransformer.inverseTransform(UnivariateFunction, double, double, int) with RealTransformer.transform(UnivariateFunction, double, double, int, TransformType).  See MATH-743  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n public class FastCosineTransformer implements RealTransformer, Serializable {\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120501L;\n+    static final long serialVersionUID = 20120211L;\n \n     /**\n      * {@code true} if the orthogonal version of the DCT should be used.\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two plus one\n      */\n-    public double[] transform(double[] f) throws MathIllegalArgumentException {\n-\n-        if (orthogonal) {\n-            final double s = FastMath.sqrt(2.0 / (f.length - 1));\n-            return TransformUtils.scaleArray(fct(f), s);\n-        }\n-        return fct(f);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n-     * @throws MathIllegalArgumentException if the number of sample points is\n-     * not a power of two plus one\n-     */\n-    public double[] transform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n-\n-        final double[] data = FunctionUtils.sample(f, min, max, n);\n-        return transform(data);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two plus one\n-     */\n-    public double[] inverseTransform(double[] f) throws\n-        MathIllegalArgumentException {\n-\n+    public double[] transform(final double[] f, final TransformType type) {\n+        if (type == TransformType.FORWARD) {\n+            if (orthogonal) {\n+                final double s = FastMath.sqrt(2.0 / (f.length - 1));\n+                return TransformUtils.scaleArray(fct(f), s);\n+            }\n+            return fct(f);\n+        }\n         final double s2 = 2.0 / (f.length - 1);\n         final double s1 = orthogonal ? FastMath.sqrt(s2) : s2;\n         return TransformUtils.scaleArray(fct(f), s1);\n     /**\n      * {@inheritDoc}\n      *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n+     * @throws org.apache.commons.math.exception.NonMonotonicSequenceException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points is negative\n      * @throws MathIllegalArgumentException if the number of sample points is\n      * not a power of two plus one\n      */\n-    public double[] inverseTransform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n+    public double[] transform(final UnivariateFunction f,\n+        final double min, final double max, final int n,\n+        final TransformType type) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n-        return inverseTransform(data);\n+        return transform(data, type);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.ArithmeticUtils;\n \n public class FastHadamardTransformer implements RealTransformer, Serializable {\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120501L;\n+    static final long serialVersionUID = 20120211L;\n \n     /**\n      * {@inheritDoc}\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public double[] transform(double[] f) throws MathIllegalArgumentException {\n-        return fht(f);\n+    public double[] transform(final double[] f, final TransformType type) {\n+        if (type == TransformType.FORWARD) {\n+            return fht(f);\n+        }\n+        return TransformUtils.scaleArray(fht(f), 1.0 / f.length);\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n+     * @throws org.apache.commons.math.exception.NonMonotonicSequenceException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points is negative\n      * @throws MathIllegalArgumentException if the number of sample points is\n      * not a power of two\n      */\n-    public double[] transform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n-\n-        return fht(FunctionUtils.sample(f, min, max, n));\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n-     */\n-    public double[] inverseTransform(double[] f)\n-        throws IllegalArgumentException {\n-\n-        return TransformUtils.scaleArray(fht(f), 1.0 / f.length);\n-   }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n-     * @throws MathIllegalArgumentException if the number of sample points is\n-     * not a power of two\n-     */\n-    public double[] inverseTransform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n-\n-        final double[] unscaled =\n-            fht(FunctionUtils.sample(f, min, max, n));\n-        return TransformUtils.scaleArray(unscaled, 1.0 / n);\n+    public double[] transform(final UnivariateFunction f,\n+        final double min, final double max, final int n,\n+        final TransformType type) {\n+\n+        return transform(FunctionUtils.sample(f, min, max, n), type);\n     }\n \n     /**\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public int[] transform(int[] f) throws MathIllegalArgumentException {\n+    public int[] transform(final int[] f) {\n         return fht(f);\n     }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n  * {@link #inverseTransform(UnivariateFunction, double, double, int)}, after\n  * sampling.\n  * </p>\n- * <p>\n- * As of version 2.0 this no longer implements Serializable.\n- * </p>\n  *\n  * @version $Id: FastSineTransformer.java 1213157 2011-12-12 07:19:23Z celestin$\n  * @since 1.2\n public class FastSineTransformer implements RealTransformer, Serializable {\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120501L;\n+    static final long serialVersionUID = 20120211L;\n \n     /**\n      * {@code true} if the orthogonal version of the DCT should be used.\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two, or the first element of the data array is not zero\n      */\n-    public double[] transform(double[] f) throws MathIllegalArgumentException {\n+    public double[] transform(final double[] f, final TransformType type) {\n         if (orthogonal) {\n             final double s = FastMath.sqrt(2.0 / f.length);\n             return TransformUtils.scaleArray(fst(f), s);\n         }\n-        return fst(f);\n+        if (type == TransformType.FORWARD) {\n+            return fst(f);\n+        }\n+        final double s = 2.0 / f.length;\n+        return TransformUtils.scaleArray(fst(f), s);\n     }\n \n     /**\n      *\n      * This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.\n      *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n+     * @throws org.apache.commons.math.exception.NonMonotonicSequenceException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points is negative\n      * @throws MathIllegalArgumentException if the number of sample points is\n      * not a power of two\n      */\n-    public double[] transform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n+    public double[] transform(final UnivariateFunction f,\n+        final double min, final double max, final int n,\n+        final TransformType type) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n         data[0] = 0.0;\n-        if (orthogonal) {\n-            final double s = FastMath.sqrt(2.0 / n);\n-            return TransformUtils.scaleArray(fst(data), s);\n-        }\n-        return fst(data);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The first element of the specified data set is required to be {@code 0}.\n-     *\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two, or the first element of the data array is not zero\n-     */\n-    public double[] inverseTransform(double[] f)\n-        throws IllegalArgumentException {\n-\n-        if (orthogonal) {\n-            return transform(f);\n-        }\n-        final double s = 2.0 / f.length;\n-        return TransformUtils.scaleArray(fst(f), s);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * This implementation enforces {@code f(x) = 0.0} at {@code x = 0.0}.\n-     *\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points is\n-     * negative\n-     * @throws MathIllegalArgumentException if the number of sample points is\n-     * not a power of two\n-     */\n-    public double[] inverseTransform(UnivariateFunction f,\n-        double min, double max, int n) throws\n-        NonMonotonicSequenceException,\n-        NotStrictlyPositiveException,\n-        MathIllegalArgumentException {\n-\n-        if (orthogonal) {\n-            return transform(f, min, max, n);\n-        }\n-\n-        final double[] data = FunctionUtils.sample(f, min, max, n);\n-        data[0] = 0.0;\n-        final double s = 2.0 / n;\n-\n-        return TransformUtils.scaleArray(fst(data), s);\n+        return transform(data, type);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n public interface RealTransformer  {\n \n     /**\n-     * Returns the forward transform of the specified real data set.\n+     * Returns the (forward, inverse) transform of the specified real data set.\n      *\n      * @param f the real data array to be transformed (signal)\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the real transformed array (spectrum)\n      */\n-    double[] transform(double[] f);\n+    double[] transform(double[] f, TransformType type);\n \n     /**\n-     * Returns the forward transform of the specified real function, sampled on\n-     * the specified interval.\n+     * Returns the (forward, inverse) transform of the specified real function,\n+     * sampled on the specified interval.\n      *\n      * @param f the function to be sampled and transformed\n      * @param min the (inclusive) lower bound for the interval\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the real transformed array\n+     * @throws org.apache.commons.math.exception.NonMonotonicSequenceException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points is negative\n      */\n-    double[] transform(UnivariateFunction f, double min, double max, int n);\n-\n-    /**\n-     * Returns the inverse transform of the specified real data set.\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the real inversely transformed array\n-     */\n-    double[] inverseTransform(double[] f);\n-\n-    /**\n-     * Returns the inverse transform of the specified real function, sampled\n-     * on the given interval.\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the (inclusive) lower bound for the interval\n-     * @param max the (exclusive) upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real inversely transformed array\n-     */\n-    double[] inverseTransform(UnivariateFunction f, double min, double max, int n);\n+    double[] transform(UnivariateFunction f,\n+            double min, double max, int n,\n+            TransformType type);\n }\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Sinc;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     }\n \n     @Override\n-    double[] transform(final double[] x, final boolean forward) {\n+    double[] transform(final double[] x, final TransformType type) {\n         final int n = x.length;\n         final double[] y = new double[n];\n         final double[] cos = new double[2 * (n - 1)];\n             sgn *= -1;\n         }\n         final double s;\n-        if (forward) {\n+        if (type == TransformType.FORWARD) {\n             s = standard ? 1.0 : FastMath.sqrt(2.0 / (n - 1.0));\n+        } else if (type == TransformType.INVERSE) {\n+            s = standard ? 2.0 / (n - 1.0) : FastMath.sqrt(2.0 / (n - 1.0));\n         } else {\n-            s = standard ? 2.0 / (n - 1.0) : FastMath.sqrt(2.0 / (n - 1.0));\n+            /*\n+             * Should never occur. This clause is a safeguard in case other\n+             * types are used to TransformType (which should not be done).\n+             */\n+            throw new MathIllegalStateException();\n         }\n         TransformUtils.scaleArray(y, s);\n         return y;\n                 4.0\n             };\n \n-        result = transformer.transform(x);\n+        result = transformer.transform(x, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform(y);\n+        result = transformer.transform(y, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n         TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1)));\n \n         transformer = FastCosineTransformer.createOrthogonal();\n-        result = transformer.transform(y);\n+        result = transformer.transform(y, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform(x);\n+        result = transformer.transform(x, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n \n         try {\n             // bad interval\n-            transformer.transform(f, 1, -1, 65);\n+            transformer.transform(f, 1, -1, 65, TransformType.FORWARD);\n             Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n-            transformer.transform(f, -1, 1, 1);\n+            transformer.transform(f, -1, 1, 1, TransformType.FORWARD);\n             Assert\n                 .fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n         }\n         try {\n             // bad samples number\n-            transformer.transform(f, -1, 1, 64);\n+            transformer.transform(f, -1, 1, 64, TransformType.FORWARD);\n             Assert\n                 .fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             };\n         min = 0.0;\n         max = 2.0 * FastMath.PI * N / (N - 1);\n-        result = transformer.transform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.FORWARD);\n         for (int i = 0; i < N; i++) {\n             Assert.assertEquals(expected[i], result[i], tolerance);\n         }\n \n         min = -FastMath.PI;\n         max = FastMath.PI * (N + 1) / (N - 1);\n-        result = transformer.transform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.FORWARD);\n         for (int i = 0; i < N; i++) {\n             Assert.assertEquals(-expected[i], result[i], tolerance);\n         }\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n \n         for (int i = 0; i < input.length; i++) {\n             for (int j = 0; j < input[0].length; j++) {\n-                System.out.println(i + \", \" + j + \", \" + input[i][j] + \", \" +\n-                        goodOutput[i][j] + \", \" + output[i][j] + \", \");\n                 Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n                              tolerance);\n                 Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n--- a/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n     @Test\n     public void testNoIntInverse() {\n         FastHadamardTransformer transformer = new FastHadamardTransformer();\n-        double[] x = transformer.inverseTransform(new double[] { 0, 1, 0, 1});\n+        double[] x = transformer.transform(new double[] { 0, 1, 0, 1}, TransformType.INVERSE);\n         Assert.assertEquals( 0.5, x[0], 0);\n         Assert.assertEquals(-0.5, x[1], 0);\n         Assert.assertEquals( 0.0, x[2], 0);\n     @Test\n     public void test3Points() {\n         try {\n-            new FastHadamardTransformer().transform(new double[3]);\n+            new FastHadamardTransformer().transform(new double[3], TransformType.FORWARD);\n             Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected\n         for (int i = 0; i < dX.length; ++i) {\n             dX[i] = x[i];\n         }\n-        double dResult[] = transformer.transform(dX);\n+        double dResult[] = transformer.transform(dX, TransformType.FORWARD);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n             Assert.assertTrue(Precision.equals(y[i], dResult[i], 1));\n         for (int i = 0; i < dY.length; ++i) {\n             dY[i] = y[i];\n         }\n-        double dResult[] = transformer.inverseTransform(dY);\n+        double dResult[] = transformer.transform(dY, TransformType.INVERSE);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n             Assert.assertTrue(Precision.equals(x[i], dResult[i], 1));\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.function.Sinc;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     }\n \n     @Override\n-    double[] transform(final double[] x, final boolean forward) {\n+    double[] transform(final double[] x, final TransformType type) {\n         final int n = x.length;\n         final double[] y = new double[n];\n         final double[] sin = new double[2 * n];\n             y[j] = yj;\n         }\n         final double s;\n-        if (forward) {\n+        if (type == TransformType.FORWARD) {\n             s = standard ? 1.0 : FastMath.sqrt(2.0 / (double) n);\n+        } else if (type == TransformType.INVERSE){\n+            s = standard ? 2.0 / n : FastMath.sqrt(2.0 / (double) n);\n         } else {\n-            s = standard ? 2.0 / n : FastMath.sqrt(2.0 / (double) n);\n+            /*\n+             * Should never occur. This clause is a safeguard in case other\n+             * types are used to TransformType (which should not be done).\n+             */\n+            throw new MathIllegalStateException();\n         }\n         TransformUtils.scaleArray(y, s);\n         return y;\n     /*\n      * Additional tests.\n      */\n-    @Test(expected = MathIllegalArgumentException.class)\n+    @Test\n     public void testTransformRealFirstElementNotZero() {\n+        final TransformType[] type = TransformType.values();\n         final double[] data = new double[] {\n             1.0, 1.0, 1.0, 1.0\n         };\n         final RealTransformer transformer = createRealTransformer();\n-        transformer.transform(data);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testInverseTransformRealFirstElementNotZero() {\n-        final double[] data = new double[] {\n-            1.0, 1.0, 1.0, 1.0\n-        };\n-        final RealTransformer transformer = createRealTransformer();\n-        transformer.inverseTransform(data);\n+        for (int j = 0; j < type.length; j++) {\n+            try {\n+                transformer.transform(data, type[j]);\n+                Assert.fail(type[j].toString());\n+            } catch (MathIllegalArgumentException e) {\n+                // Expected: do nothing\n+            }\n+        }\n     }\n \n     /*\n                        5.98642305066196, -4.0, 2.67271455167720,\n                       -1.65685424949238, 0.795649469518633 };\n \n-        result = transformer.transform(x);\n+        result = transformer.transform(x, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform(y);\n+        result = transformer.transform(y, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n         TransformUtils.scaleArray(x, FastMath.sqrt(x.length / 2.0));\n         transformer = FastSineTransformer.createOrthogonal();\n \n-        result = transformer.transform(y);\n+        result = transformer.transform(y, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform(x);\n+        result = transformer.transform(x, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n         double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n \n         min = 0.0; max = 2.0 * FastMath.PI;\n-        result = transformer.transform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.FORWARD);\n         Assert.assertEquals(N >> 1, result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n             Assert.assertEquals(0.0, result[i], tolerance);\n         }\n \n         min = -FastMath.PI; max = FastMath.PI;\n-        result = transformer.transform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.FORWARD);\n         Assert.assertEquals(-(N >> 1), result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n             Assert.assertEquals(0.0, result[i], tolerance);\n \n         try {\n             // bad interval\n-            transformer.transform(f, 1, -1, 64);\n+            transformer.transform(f, 1, -1, 64, TransformType.FORWARD);\n             Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n-            transformer.transform(f, -1, 1, 0);\n+            transformer.transform(f, -1, 1, 0, TransformType.FORWARD);\n             Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad samples number\n-            transformer.transform(f, -1, 1, 100);\n+            transformer.transform(f, -1, 1, 100, TransformType.FORWARD);\n             Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/java/org/apache/commons/math/transform/RealTransformerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/RealTransformerAbstractTest.java\n      * Returns the expected transform of the specified real data array.\n      *\n      * @param x the real data array to be transformed\n-     * @param forward {@code true} (resp. {@code false}) if the forward (resp.\n-     * inverse) transform is to be performed\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the expected transform\n      */\n-    abstract double[] transform(double[] x, boolean forward);\n+    abstract double[] transform(double[] x, TransformType type);\n \n     /*\n      * Check of preconditions.\n      */\n \n     /**\n-     * {@link RealTransformer#transform(double[])} should throw a\n+     * {@link RealTransformer#transform(double[], TransformType))} should throw a\n      * {@link MathIllegalArgumentException} if data size is invalid.\n      */\n     @Test\n     public void testTransformRealInvalidDataSize() {\n+        final TransformType[] type = TransformType.values();\n         final RealTransformer transformer = createRealTransformer();\n         for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n             final int n = getInvalidDataSize(i);\n-            try {\n-                transformer.transform(createRealData(n));\n-                Assert.fail(Integer.toString(n));\n-            } catch (MathIllegalArgumentException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+            for (int j = 0; j < type.length; j++) {\n+                try {\n+                    transformer.transform(createRealData(n), type[j]);\n+                    Assert.fail(type[j] + \", \" + n);\n+                } catch (MathIllegalArgumentException e) {\n+                    // Expected: do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}\n      * should throw a {@link MathIllegalArgumentException} if number of samples\n      * is invalid.\n      */\n     @Test\n     public void testTransformFunctionInvalidDataSize() {\n+        final TransformType[] type = TransformType.values();\n         final RealTransformer transformer = createRealTransformer();\n         final UnivariateFunction f = getValidFunction();\n         final double a = getValidLowerBound();\n         final double b = getValidUpperBound();\n         for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n             final int n = getInvalidDataSize(i);\n-            try {\n-                transformer.transform(f, a, b, n);\n-                Assert.fail(Integer.toString(n));\n-            } catch (MathIllegalArgumentException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+            for (int j = 0; j < type.length; j++) {\n+                try {\n+                    transformer.transform(f, a, b, n, type[j]);\n+                    Assert.fail(type[j] + \", \" + n);\n+                } catch (MathIllegalArgumentException e) {\n+                    // Expected: do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}\n      * should throw a {@link NotStrictlyPositiveException} if number of samples\n      * is not strictly positive.\n      */\n     @Test\n     public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final TransformType[] type = TransformType.values();\n         final RealTransformer transformer = createRealTransformer();\n         final UnivariateFunction f = getValidFunction();\n         final double a = getValidLowerBound();\n         final double b = getValidUpperBound();\n         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n             final int n = getValidDataSize(i);\n-            try {\n-                transformer.transform(f, a, b, -n);\n-                Assert.fail(Integer.toString(-n));\n-            } catch (NotStrictlyPositiveException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#transform(UnivariateFunction, double, double, int)}\n+            for (int j = 0; j < type.length; j++) {\n+                try {\n+                    transformer.transform(f, a, b, -n, type[j]);\n+                    Assert.fail(type[j] + \", \" + (-n));\n+                } catch (NotStrictlyPositiveException e) {\n+                    // Expected: do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link RealTransformer#transform(UnivariateFunction, double, double, int, TransformType)}\n      * should throw a {@link NumberIsTooLargeException} if sampling bounds are\n      * not correctly ordered.\n      */\n     @Test\n     public void testTransformFunctionInvalidBounds() {\n+        final TransformType[] type = TransformType.values();\n         final RealTransformer transformer = createRealTransformer();\n         final UnivariateFunction f = getValidFunction();\n         final double a = getValidLowerBound();\n         final double b = getValidUpperBound();\n         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n             final int n = getValidDataSize(i);\n-            try {\n-                transformer.transform(f, b, a, n);\n-                Assert.fail(Double.toString(b) + \", \" + Double.toString(a));\n-            } catch (NumberIsTooLargeException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#inverseTransform(double[])} should throw a\n-     * {@link MathIllegalArgumentException} if data size is invalid.\n-     */\n-    @Test\n-    public void testInverseTransformRealInvalidDataSize() {\n-        final RealTransformer transformer = createRealTransformer();\n-        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n-            final int n = getInvalidDataSize(i);\n-            try {\n-                transformer.inverseTransform(createRealData(n));\n-                Assert.fail(Integer.toString(n));\n-            } catch (MathIllegalArgumentException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n-     * should throw a {@link MathIllegalArgumentException} if number of samples\n-     * is invalid.\n-     */\n-    @Test\n-    public void testInverseTransformFunctionInvalidDataSize() {\n-        final RealTransformer transformer = createRealTransformer();\n-        final UnivariateFunction f = getValidFunction();\n-        final double a = getValidLowerBound();\n-        final double b = getValidUpperBound();\n-        for (int i = 0; i < getNumberOfInvalidDataSizes(); i++) {\n-            final int n = getInvalidDataSize(i);\n-            try {\n-                transformer.inverseTransform(f, a, b, n);\n-                Assert.fail(Integer.toString(n));\n-            } catch (MathIllegalArgumentException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n-     * should throw a {@link NotStrictlyPositiveException} if number of samples\n-     * is not strictly positive.\n-     */\n-    @Test\n-    public void\n-        testInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n-        final RealTransformer transformer = createRealTransformer();\n-        final UnivariateFunction f = getValidFunction();\n-        final double a = getValidLowerBound();\n-        final double b = getValidUpperBound();\n-        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n-            final int n = getValidDataSize(i);\n-            try {\n-                transformer.inverseTransform(f, a, b, -n);\n-                Assert.fail(Integer.toString(-n));\n-            } catch (NotStrictlyPositiveException e) {\n-                // Expected: do nothing\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}\n-     * should throw a {@link NumberIsTooLargeException} if sampling bounds are\n-     * not correctly ordered.\n-     */\n-    @Test\n-    public void testInverseTransformFunctionInvalidBounds() {\n-        final RealTransformer transformer = createRealTransformer();\n-        final UnivariateFunction f = getValidFunction();\n-        final double a = getValidLowerBound();\n-        final double b = getValidUpperBound();\n-        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n-            final int n = getValidDataSize(i);\n-            try {\n-                transformer.inverseTransform(f, b, a, n);\n-                Assert.fail(Double.toString(b) + \", \" + Double.toString(a));\n-            } catch (NumberIsTooLargeException e) {\n-                // Expected: do nothing\n+            for (int j = 0; j < type.length; j++) {\n+                try {\n+                    transformer.transform(f, b, a, n, type[j]);\n+                    Assert.fail(type[j] + \", \" + b + \", \" + a);\n+                } catch (NumberIsTooLargeException e) {\n+                    // Expected: do nothing\n+                }\n             }\n         }\n     }\n      */\n     @Test\n     public void testTransformReal() {\n+        final TransformType[] type = TransformType.values();\n         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n             final int n = getValidDataSize(i);\n             final double tol = getRelativeTolerance(i);\n-            doTestTransformReal(n, tol, true);\n+            for (int j = 0; j < type.length; j++) {\n+                doTestTransformReal(n, tol, type[j]);\n+            }\n         }\n     }\n \n      */\n     @Test\n     public void testTransformFunction() {\n+        final TransformType[] type = TransformType.values();\n         for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n             final int n = getValidDataSize(i);\n             final double tol = getRelativeTolerance(i);\n-            doTestTransformFunction(n, tol, true);\n-        }\n-    }\n-\n-    /**\n-     * Accuracy check of {@link RealTransformer#inverseTransform(double[])}. For\n-     * each valid data size returned by\n-     * {@link #getValidDataSize(int) getValidDataSize(i)},\n-     * a random data array is generated with\n-     * {@link RealTransformerAbstractTest#createRealData(int)}. The actual\n-     * transform is computed and compared to the expected transform, return by\n-     * {@link #transform(double[], boolean)}. Actual and expected values should\n-     * be equal to within the relative error returned by\n-     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n-     */\n-    @Test\n-    public void testInverseTransformReal() {\n-        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n-            final int n = getValidDataSize(i);\n-            final double tol = getRelativeTolerance(i);\n-            doTestTransformReal(n, tol, false);\n-        }\n-    }\n-\n-    /**\n-     * Accuracy check of\n-     * {@link RealTransformer#inverseTransform(UnivariateFunction, double, double, int)}.\n-     * For each valid data size returned by\n-     * {@link #getValidDataSize(int) getValidDataSize(i)},\n-     * the {@link UnivariateFunction} returned by {@link #getValidFunction()} is\n-     * sampled. The actual transform is computed and compared to the expected\n-     * transform, return by {@link #transform(double[], boolean)}. Actual and\n-     * expected values should be equal to within the relative error returned by\n-     * {@link #getRelativeTolerance(int) getRelativeTolerance(i)}.\n-     */\n-    @Test\n-    public void testInverseTransformFunction() {\n-        for (int i = 0; i < getNumberOfValidDataSizes(); i++) {\n-            final int n = getValidDataSize(i);\n-            final double tol = getRelativeTolerance(i);\n-            doTestTransformFunction(n, tol, false);\n+            for (int j = 0; j < type.length; j++) {\n+                doTestTransformFunction(n, tol, type[j]);\n+            }\n         }\n     }\n \n      */\n \n     private void doTestTransformReal(final int n, final double tol,\n-        final boolean forward) {\n+        final TransformType type) {\n         final RealTransformer transformer = createRealTransformer();\n         final double[] x = createRealData(n);\n-        final double[] expected = transform(x, forward);\n-        final double[] actual;\n-        if (forward) {\n-            actual = transformer.transform(x);\n-        } else {\n-            actual = transformer.inverseTransform(x);\n-        }\n+        final double[] expected = transform(x, type);\n+        final double[] actual = transformer.transform(x, type);\n         for (int i = 0; i < n; i++) {\n             final String msg = String.format(\"%d, %d\", n, i);\n             final double delta = tol * FastMath.abs(expected[i]);\n     }\n \n     private void doTestTransformFunction(final int n, final double tol,\n-        final boolean forward) {\n+        final TransformType type) {\n         final RealTransformer transformer = createRealTransformer();\n         final UnivariateFunction f = getValidFunction();\n         final double a = getValidLowerBound();\n             final double t = a + i * (b - a) / n;\n             x[i] = f.value(t);\n         }\n-        final double[] expected = transform(x, forward);\n-        final double[] actual;\n-        if (forward) {\n-            actual = transformer.transform(f, a, b, n);\n-        } else {\n-            actual = transformer.inverseTransform(f, a, b, n);\n-        }\n+        final double[] expected = transform(x, type);\n+        final double[] actual = transformer.transform(f, a, b, n, type);\n         for (int i = 0; i < n; i++) {\n             final String msg = String.format(\"%d, %d\", n, i);\n             final double delta = tol * FastMath.abs(expected[i]);", "timestamp": 1328981910, "metainfo": ""}