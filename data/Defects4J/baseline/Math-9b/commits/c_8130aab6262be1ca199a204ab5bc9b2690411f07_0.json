{"sha": "8130aab6262be1ca199a204ab5bc9b2690411f07", "log": "MATH-887  In \"LevenbergMarquardtOptimizer\", removed usage of deprecated fields and methods from its base class.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n     }\n \n     /**\n+     * Gets the square-root of the weight matrix.\n+     *\n+     * @return the square-root of the weight matrix.\n+     */\n+    public RealMatrix getWeightSquareRoot() {\n+        return weightMatrixSqrt.copy();\n+    }\n+\n+    /**\n      * Sets the cost.\n      *\n      * @param cost Cost value.\n--- a/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n+import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.util.Precision;\n import org.apache.commons.math3.util.FastMath;\n \n     private final double orthoTolerance;\n     /** Threshold for QR ranking. */\n     private final double qrRankingThreshold;\n+    /** Weighted residuals. */\n+    private double[] weightedResidual;\n+    /** Weighted Jacobian. */\n+    private double[][] weightedJacobian;\n \n     /**\n      * Build an optimizer for least squares problems with default values\n     /** {@inheritDoc} */\n     @Override\n     protected PointVectorValuePair doOptimize() {\n+        final int nR = getTarget().length; // Number of observed data.\n+        final double[] currentPoint = getStartPoint();\n+        final int nC = currentPoint.length; // Number of parameters.\n+\n         // arrays shared with the other private methods\n-        solvedCols  = FastMath.min(rows, cols);\n-        diagR       = new double[cols];\n-        jacNorm     = new double[cols];\n-        beta        = new double[cols];\n-        permutation = new int[cols];\n-        lmDir       = new double[cols];\n+        solvedCols  = FastMath.min(nR, nC);\n+        diagR       = new double[nC];\n+        jacNorm     = new double[nC];\n+        beta        = new double[nC];\n+        permutation = new int[nC];\n+        lmDir       = new double[nC];\n \n         // local point\n         double   delta   = 0;\n         double   xNorm   = 0;\n-        double[] diag    = new double[cols];\n-        double[] oldX    = new double[cols];\n-        double[] oldRes  = new double[rows];\n-        double[] oldObj  = new double[rows];\n-        double[] qtf     = new double[rows];\n-        double[] work1   = new double[cols];\n-        double[] work2   = new double[cols];\n-        double[] work3   = new double[cols];\n-\n-        // evaluate the function at the starting point and calculate its norm\n-        updateResidualsAndCost();\n-\n-        // outer loop\n+        double[] diag    = new double[nC];\n+        double[] oldX    = new double[nC];\n+        double[] oldRes  = new double[nR];\n+        double[] oldObj  = new double[nR];\n+        double[] qtf     = new double[nR];\n+        double[] work1   = new double[nC];\n+        double[] work2   = new double[nC];\n+        double[] work3   = new double[nC];\n+\n+        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n+\n+        // Evaluate the function at the starting point and calculate its norm.\n+        double[] currentObjective = computeObjectiveValue(currentPoint);\n+        double[] currentResiduals = computeResiduals(currentObjective);\n+        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n+        double currentCost = computeCost(currentResiduals);\n+\n+        // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n-        PointVectorValuePair current = new PointVectorValuePair(point, objective);\n         int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n             ++iter;\n-\n-            for (int i=0;i<rows;i++) {\n-                qtf[i]=weightedResiduals[i];\n-            }\n-\n-            // compute the Q.R. decomposition of the jacobian matrix\n-            PointVectorValuePair previous = current;\n-            updateJacobian();\n-            qrDecomposition();\n+            final PointVectorValuePair previous = current;\n+\n+            // QR decomposition of the jacobian matrix\n+            qrDecomposition(computeJacobian(currentPoint));\n+\n+            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n+            for (int i = 0; i < nR; i++) {\n+                qtf[i] = weightedResidual[i];\n+            }\n \n             // compute Qt.res\n             qTy(qtf);\n+\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n                 int pk = permutation[k];\n-                weightedResidualJacobian[k][pk] = diagR[pk];\n+                weightedJacobian[k][pk] = diagR[pk];\n             }\n \n             if (firstIteration) {\n                 // scale the point according to the norms of the columns\n                 // of the initial jacobian\n                 xNorm = 0;\n-                for (int k = 0; k < cols; ++k) {\n+                for (int k = 0; k < nC; ++k) {\n                     double dk = jacNorm[k];\n                     if (dk == 0) {\n                         dk = 1.0;\n                     }\n-                    double xk = dk * point[k];\n+                    double xk = dk * currentPoint[k];\n                     xNorm  += xk * xk;\n                     diag[k] = dk;\n                 }\n \n             // check orthogonality between function vector and jacobian columns\n             double maxCosine = 0;\n-            if (cost != 0) {\n+            if (currentCost != 0) {\n                 for (int j = 0; j < solvedCols; ++j) {\n                     int    pj = permutation[j];\n                     double s  = jacNorm[pj];\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += weightedResidualJacobian[i][pj] * qtf[i];\n+                            sum += weightedJacobian[i][pj] * qtf[i];\n                         }\n-                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost));\n+                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                     }\n                 }\n             }\n             if (maxCosine <= orthoTolerance) {\n-                // convergence has been reached\n-                updateResidualsAndCost();\n-                current = new PointVectorValuePair(point, objective);\n+                // Convergence has been reached.\n+                setCost(currentCost);\n                 return current;\n             }\n \n             // rescale if necessary\n-            for (int j = 0; j < cols; ++j) {\n+            for (int j = 0; j < nC; ++j) {\n                 diag[j] = FastMath.max(diag[j], jacNorm[j]);\n             }\n \n-            // inner loop\n+            // Inner loop.\n             for (double ratio = 0; ratio < 1.0e-4;) {\n \n                 // save the state\n                 for (int j = 0; j < solvedCols; ++j) {\n                     int pj = permutation[j];\n-                    oldX[pj] = point[pj];\n-                }\n-                double previousCost = cost;\n-                double[] tmpVec = weightedResiduals;\n-                weightedResiduals = oldRes;\n+                    oldX[pj] = currentPoint[pj];\n+                }\n+                final double previousCost = currentCost;\n+                double[] tmpVec = weightedResidual;\n+                weightedResidual = oldRes;\n                 oldRes    = tmpVec;\n-                tmpVec    = objective;\n-                objective = oldObj;\n+                tmpVec    = currentObjective;\n+                currentObjective = oldObj;\n                 oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n                 for (int j = 0; j < solvedCols; ++j) {\n                     int pj = permutation[j];\n                     lmDir[pj] = -lmDir[pj];\n-                    point[pj] = oldX[pj] + lmDir[pj];\n+                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                     double s = diag[pj] * lmDir[pj];\n                     lmNorm  += s * s;\n                 }\n                     delta = FastMath.min(delta, lmNorm);\n                 }\n \n-                // evaluate the function at x + p and calculate its norm\n-                updateResidualsAndCost();\n+                // Evaluate the function at x + p and calculate its norm.\n+                currentObjective = computeObjectiveValue(currentPoint);\n+                currentResiduals = computeResiduals(currentObjective);\n+                current = new PointVectorValuePair(currentPoint, currentObjective);\n+                currentCost = computeCost(currentResiduals);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n-                if (0.1 * cost < previousCost) {\n-                    double r = cost / previousCost;\n+                if (0.1 * currentCost < previousCost) {\n+                    double r = currentCost / previousCost;\n                     actRed = 1.0 - r * r;\n                 }\n \n                     double dirJ = lmDir[pj];\n                     work1[j] = 0;\n                     for (int i = 0; i <= j; ++i) {\n-                        work1[i] += weightedResidualJacobian[i][pj] * dirJ;\n+                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                     }\n                 }\n                 double coeff1 = 0;\n                 if (ratio <= 0.25) {\n                     double tmp =\n                         (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n-                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n+                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                             tmp = 0.1;\n                         }\n                         delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                     // successful iteration, update the norm\n                     firstIteration = false;\n                     xNorm = 0;\n-                    for (int k = 0; k < cols; ++k) {\n-                        double xK = diag[k] * point[k];\n+                    for (int k = 0; k < nC; ++k) {\n+                        double xK = diag[k] * currentPoint[k];\n                         xNorm += xK * xK;\n                     }\n                     xNorm = FastMath.sqrt(xNorm);\n-                    current = new PointVectorValuePair(point, objective);\n \n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n                         if (checker.converged(iter, previous, current)) {\n+                            setCost(currentCost);\n                             return current;\n                         }\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n-                    cost = previousCost;\n+                    currentCost = previousCost;\n                     for (int j = 0; j < solvedCols; ++j) {\n                         int pj = permutation[j];\n-                        point[pj] = oldX[pj];\n+                        currentPoint[pj] = oldX[pj];\n                     }\n-                    tmpVec    = weightedResiduals;\n-                    weightedResiduals = oldRes;\n+                    tmpVec    = weightedResidual;\n+                    weightedResidual = oldRes;\n                     oldRes    = tmpVec;\n-                    tmpVec    = objective;\n-                    objective = oldObj;\n+                    tmpVec    = currentObjective;\n+                    currentObjective = oldObj;\n                     oldObj    = tmpVec;\n+                    // Reset \"current\" to previous values.\n+                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                 }\n \n                 // Default convergence criteria.\n                      preRed <= costRelativeTolerance &&\n                      ratio <= 2.0) ||\n                     delta <= parRelativeTolerance * xNorm) {\n+                    setCost(currentCost);\n                     return current;\n                 }\n \n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n                 if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                     throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n-                            costRelativeTolerance);\n+                                                   costRelativeTolerance);\n                 } else if (delta <= 2.2204e-16 * xNorm) {\n                     throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n-                            parRelativeTolerance);\n+                                                   parRelativeTolerance);\n                 } else if (maxCosine <= 2.2204e-16)  {\n                     throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n-                            orthoTolerance);\n+                                                   orthoTolerance);\n                 }\n             }\n         }\n      * @param work3 work array\n      */\n     private void determineLMParameter(double[] qy, double delta, double[] diag,\n-            double[] work1, double[] work2, double[] work3) {\n+                                      double[] work1, double[] work2, double[] work3) {\n+        final int nC = weightedJacobian[0].length;\n \n         // compute and store in x the gauss-newton direction, if the\n         // jacobian is rank-deficient, obtain a least squares solution\n         for (int j = 0; j < rank; ++j) {\n             lmDir[permutation[j]] = qy[j];\n         }\n-        for (int j = rank; j < cols; ++j) {\n+        for (int j = rank; j < nC; ++j) {\n             lmDir[permutation[j]] = 0;\n         }\n         for (int k = rank - 1; k >= 0; --k) {\n             int pk = permutation[k];\n             double ypk = lmDir[pk] / diagR[pk];\n             for (int i = 0; i < k; ++i) {\n-                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n+                lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];\n             }\n             lmDir[pk] = ypk;\n         }\n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = 0; i < j; ++i) {\n-                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n+                    sum += weightedJacobian[i][pj] * work1[permutation[i]];\n                 }\n                 double s = (work1[pj] - sum) / diagR[pj];\n                 work1[pj] = s;\n             int pj = permutation[j];\n             double sum = 0;\n             for (int i = 0; i <= j; ++i) {\n-                sum += weightedResidualJacobian[i][pj] * qy[i];\n+                sum += weightedJacobian[i][pj] * qy[i];\n             }\n             sum /= diag[pj];\n             sum2 += sum * sum;\n                 work1[pj] /= work2[j];\n                 double tmp = work1[pj];\n                 for (int i = j + 1; i < solvedCols; ++i) {\n-                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n+                    work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;\n                 }\n             }\n             sum2 = 0;\n      * @param work work array\n      */\n     private void determineLMDirection(double[] qy, double[] diag,\n-            double[] lmDiag, double[] work) {\n+                                      double[] lmDiag, double[] work) {\n \n         // copy R and Qty to preserve input and initialize s\n         //  in particular, save the diagonal elements of R in lmDir\n         for (int j = 0; j < solvedCols; ++j) {\n             int pj = permutation[j];\n             for (int i = j + 1; i < solvedCols; ++i) {\n-                weightedResidualJacobian[i][pj] = weightedResidualJacobian[j][permutation[i]];\n+                weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];\n             }\n             lmDir[j] = diagR[pj];\n             work[j]  = qy[j];\n \n                     final double sin;\n                     final double cos;\n-                    double rkk = weightedResidualJacobian[k][pk];\n+                    double rkk = weightedJacobian[k][pk];\n                     if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\n                         final double cotan = rkk / lmDiag[k];\n                         sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\n \n                     // compute the modified diagonal element of R and\n                     // the modified element of (Qty,0)\n-                    weightedResidualJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n+                    weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                     final double temp = cos * work[k] + sin * qtbpj;\n                     qtbpj = -sin * work[k] + cos * qtbpj;\n                     work[k] = temp;\n \n                     // accumulate the tranformation in the row of s\n                     for (int i = k + 1; i < solvedCols; ++i) {\n-                        double rik = weightedResidualJacobian[i][pk];\n+                        double rik = weightedJacobian[i][pk];\n                         final double temp2 = cos * rik + sin * lmDiag[i];\n                         lmDiag[i] = -sin * rik + cos * lmDiag[i];\n-                        weightedResidualJacobian[i][pk] = temp2;\n+                        weightedJacobian[i][pk] = temp2;\n                     }\n                 }\n             }\n \n             // store the diagonal element of s and restore\n             // the corresponding diagonal element of R\n-            lmDiag[j] = weightedResidualJacobian[j][permutation[j]];\n-            weightedResidualJacobian[j][permutation[j]] = lmDir[j];\n+            lmDiag[j] = weightedJacobian[j][permutation[j]];\n+            weightedJacobian[j][permutation[j]] = lmDir[j];\n         }\n \n         // solve the triangular system for z, if the system is\n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = j + 1; i < nSing; ++i) {\n-                    sum += weightedResidualJacobian[i][pj] * work[i];\n+                    sum += weightedJacobian[i][pj] * work[i];\n                 }\n                 work[j] = (work[j] - sum) / lmDiag[j];\n             }\n      * are performed in non-increasing columns norms order thanks to columns\n      * pivoting. The diagonal elements of the R matrix are therefore also in\n      * non-increasing absolute values order.</p>\n+     *\n+     * @param jacobian Weighte Jacobian matrix at the current point.\n      * @exception ConvergenceException if the decomposition cannot be performed\n      */\n-    private void qrDecomposition() throws ConvergenceException {\n+    private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\n+        weightedJacobian = jacobian.getData();\n+        final int nR = weightedJacobian.length;\n+        final int nC = weightedJacobian[0].length;\n \n         // initializations\n-        for (int k = 0; k < cols; ++k) {\n+        for (int k = 0; k < nC; ++k) {\n             permutation[k] = k;\n             double norm2 = 0;\n-            for (int i = 0; i < weightedResidualJacobian.length; ++i) {\n-                double akk = weightedResidualJacobian[i][k];\n+            for (int i = 0; i < nR; ++i) {\n+                double akk = weightedJacobian[i][k];\n                 norm2 += akk * akk;\n             }\n             jacNorm[k] = FastMath.sqrt(norm2);\n         }\n \n         // transform the matrix column after column\n-        for (int k = 0; k < cols; ++k) {\n+        for (int k = 0; k < nC; ++k) {\n \n             // select the column with the greatest norm on active components\n             int nextColumn = -1;\n             double ak2 = Double.NEGATIVE_INFINITY;\n-            for (int i = k; i < cols; ++i) {\n+            for (int i = k; i < nC; ++i) {\n                 double norm2 = 0;\n-                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n-                    double aki = weightedResidualJacobian[j][permutation[i]];\n+                for (int j = k; j < nR; ++j) {\n+                    double aki = weightedJacobian[j][permutation[i]];\n                     norm2 += aki * aki;\n                 }\n                 if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                     throw new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n-                            rows, cols);\n+                                                   nR, nC);\n                 }\n                 if (norm2 > ak2) {\n                     nextColumn = i;\n             permutation[k]          = pk;\n \n             // choose alpha such that Hk.u = alpha ek\n-            double akk   = weightedResidualJacobian[k][pk];\n+            double akk   = weightedJacobian[k][pk];\n             double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n             double betak = 1.0 / (ak2 - akk * alpha);\n             beta[pk]     = betak;\n \n             // transform the current column\n             diagR[pk]        = alpha;\n-            weightedResidualJacobian[k][pk] -= alpha;\n+            weightedJacobian[k][pk] -= alpha;\n \n             // transform the remaining columns\n-            for (int dk = cols - 1 - k; dk > 0; --dk) {\n+            for (int dk = nC - 1 - k; dk > 0; --dk) {\n                 double gamma = 0;\n-                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n-                    gamma += weightedResidualJacobian[j][pk] * weightedResidualJacobian[j][permutation[k + dk]];\n+                for (int j = k; j < nR; ++j) {\n+                    gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];\n                 }\n                 gamma *= betak;\n-                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n-                    weightedResidualJacobian[j][permutation[k + dk]] -= gamma * weightedResidualJacobian[j][pk];\n+                for (int j = k; j < nR; ++j) {\n+                    weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];\n                 }\n             }\n         }\n      * @param y vector to multiply (will be overwritten with the result)\n      */\n     private void qTy(double[] y) {\n-        for (int k = 0; k < cols; ++k) {\n+        final int nR = weightedJacobian.length;\n+        final int nC = weightedJacobian[0].length;\n+\n+        for (int k = 0; k < nC; ++k) {\n             int pk = permutation[k];\n             double gamma = 0;\n-            for (int i = k; i < rows; ++i) {\n-                gamma += weightedResidualJacobian[i][pk] * y[i];\n+            for (int i = k; i < nR; ++i) {\n+                gamma += weightedJacobian[i][pk] * y[i];\n             }\n             gamma *= beta[pk];\n-            for (int i = k; i < rows; ++i) {\n-                y[i] -= gamma * weightedResidualJacobian[i][pk];\n+            for (int i = k; i < nR; ++i) {\n+                y[i] -= gamma * weightedJacobian[i][pk];\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerAbstractTest.java\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n-                               new double[] { 98.680, 47.345 });\n+        PointVectorValuePair optimum\n+            = optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                                 new double[] { 98.680, 47.345 });\n         Assert.assertTrue(optimizer.getEvaluations() < 10);\n         Assert.assertTrue(optimizer.getJacobianEvaluations() < 10);\n         double rms = optimizer.getRMS();\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n-        PointVectorValuePair optimum =\n-            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n+        PointVectorValuePair optimum\n+            = optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         Assert.assertTrue(optimizer.getEvaluations() < 25);\n         Assert.assertTrue(optimizer.getJacobianEvaluations() < 20);\n--- a/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizerTest.java\n         }, new double[] { 1, 1, 1 });\n \n         AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n-        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n \n-        optimizer.getCovariances(1.5e-14);\n+        optimizer.computeCovariances(optimum.getPoint(), 1.5e-14);\n     }\n \n     @Test\n         final LevenbergMarquardtOptimizer optimizer\n             = new LevenbergMarquardtOptimizer();\n \n-        final PointVectorValuePair optimum =\n-            optimizer.optimize(100, problem, dataPoints[1], weights,\n+        final PointVectorValuePair optimum\n+            = optimizer.optimize(100, problem, dataPoints[1], weights,\n                                new double[] { 10, 900, 80, 27, 225 });\n \n         final double[] solution = optimum.getPoint();\n         final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 };\n \n-        final double[][] covarMatrix = optimizer.getCovariances();\n+        final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14);\n         final double[][] expectedCovarMatrix = {\n             { 3.38, -3.69, 27.98, -2.34, -49.24 },\n             { -3.69, 2492.26, 81.89, -69.21, -8.9 },\n         final double[] paramFound = optimum.getPoint();\n \n         // Retrieve errors estimation.\n-        final double[][] covMatrix = optimizer.getCovariances();\n+        final double[][] covMatrix = optimizer.computeCovariances(paramFound, 1e-14);\n         final double[] asymptoticStandardErrorFound = optimizer.guessParametersErrors();\n         final double[] sigmaFound = new double[covMatrix.length];\n         for (int i = 0; i < covMatrix.length; i++) {", "timestamp": 1352471449, "metainfo": ""}