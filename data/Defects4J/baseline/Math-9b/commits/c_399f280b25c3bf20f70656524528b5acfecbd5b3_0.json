{"sha": "399f280b25c3bf20f70656524528b5acfecbd5b3", "log": "Remove reflection tests as they are in FastMathStrictComparisonTest Enable fail if not all StrictMath methods have been implemented  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n  */\n package org.apache.commons.math.util;\n \n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Type;\n-import java.util.Arrays;\n \n import org.apache.commons.math.dfp.Dfp;\n import org.apache.commons.math.dfp.DfpField;\n     private static final double MAX_ERROR_ULP = 0.51;\n     private static final int NUMBER_OF_TRIALS = 1000;\n \n-    // Values which often need special handling\n-    private static final Double[] DOUBLE_SPECIAL_VALUES = {\n-        -0.0, +0.0,                                         // 1,2\n-        Double.NaN,                                         // 3\n-        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5\n-        -Double.MAX_VALUE, Double.MAX_VALUE,                // 6,7\n-        // decreasing order of absolute value to help catch first failure\n-        -MathUtils.EPSILON, MathUtils.EPSILON,              // 8,9\n-        -MathUtils.SAFE_MIN, MathUtils.SAFE_MIN,            // 10,11\n-        -Double.MIN_VALUE, Double.MIN_VALUE,                // 12,13\n-    };\n-\n-    private static final Float [] FLOAT_SPECIAL_VALUES = {\n-        -0.0f, +0.0f,                                       // 1,2\n-        Float.NaN,                                          // 3\n-        Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,   // 4,5\n-        Float.MIN_VALUE, Float.MAX_VALUE,                   // 6,7\n-        -Float.MIN_VALUE, -Float.MAX_VALUE,                 // 8,9\n-    };\n \n     private DfpField field;\n     private RandomGenerator generator;\n         Assert.assertEquals(Float.NEGATIVE_INFINITY,  FastMath.scalb(-1.1e-7f,         152), 0F);\n     }\n \n-    private static void reportError(String message) {\n-        final boolean fatal = false;\n-        if (fatal) {\n-            Assert.fail(message);\n-        } else {\n-            System.out.println(message);\n-        }\n-    }\n-    \n-    private static void check(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries){\n-        if (!expected.equals(actual)){\n-            if (expected instanceof Double) {\n-                double exp = (Double) expected;\n-                // Need to discount 0 otherwise +0.0 == -0.0\n-                if (exp != 0 && MathUtils.equals(exp, (Double) actual, 1)) {\n-                    return;\n-                }\n-            } else {\n-                float exp = (Float) expected;\n-                // Need to discount 0 otherwise +0.0 == -0.0\n-                if (exp != 0 && MathUtils.equals(exp, ((Float) actual), 1)) {\n-                    return;\n-                }\n-            }\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(mathMethod.getReturnType().getSimpleName());\n-            sb.append(\" \");\n-            sb.append(mathMethod.getName());\n-            sb.append(\"(\");\n-            String sep = \"\";\n-            for(Object o : params){\n-                sb.append(sep);\n-                sb.append(o);\n-                sep=\", \";\n-            }\n-            sb.append(\") expected \");\n-            sb.append(expected);\n-            sb.append(\" actual \");\n-            sb.append(actual);\n-            sb.append(\" entries \");\n-            sb.append(Arrays.toString(entries));\n-            reportError(sb.toString());\n-        }            \n-    }\n-\n-    private static class CompareSpecials {\n-        private final Object[] specialvalues;\n-        CompareSpecials(Object[] values){\n-            specialvalues=values;\n-        }\n-        void compareSpecials(Method mathMethod, Method fastMethod, Type[] types) throws Exception {\n-            Object[] params = new Object[types.length];\n-            int entry1 = 0;\n-            int[] entries = new int[types.length];\n-            for(Object d : specialvalues) {\n-                entry1++;\n-                params[0] = d;\n-                entries[0] = entry1;\n-                if (params.length > 1){\n-                    int entry2 = 0;\n-                    for(Object d1 : specialvalues) {\n-                        entry2++;\n-                        params[1] = d1;                    \n-                        entries[1] = entry2;\n-                        compare(mathMethod, fastMethod, params, entries);                        \n-                    }\n-                } else {\n-                    compare(mathMethod, fastMethod, params, entries);                    \n-                }\n-            }\n-        }\n-        private void compare(Method mathMethod, Method fastMethod,\n-                Object[] params, int[] entries) throws IllegalAccessException,\n-                InvocationTargetException {\n-            try {\n-                Object expected = mathMethod.invoke(mathMethod, params);\n-                Object actual = fastMethod.invoke(mathMethod, params);\n-                check(mathMethod, params, expected, actual, entries);\n-            } catch (IllegalArgumentException e) {\n-                Assert.fail(mathMethod+\" \"+e);\n-            }\n-        }\n-    }\n-\n-    private void testSpecialCases(Class<?> type, CompareSpecials comparer) throws Exception {\n-        Method math[] = StrictMath.class.getDeclaredMethods();\n-        for(Method mathMethod : math) {\n-            Type ret = mathMethod.getGenericReturnType();\n-            if (ret.equals(type) && Modifier.isPublic(mathMethod.getModifiers())){\n-                Type []params = mathMethod.getGenericParameterTypes();\n-                if (params.length >=1 && params[0].equals(type)) {\n-                    Method fastMethod = null;\n-                    String name = mathMethod.getName();\n-                    try {\n-                        fastMethod = FastMath.class.getDeclaredMethod(name, (Class[]) params);\n-                        if (Modifier.isPublic(fastMethod.getModifiers())) {\n-                            comparer.compareSpecials(mathMethod, fastMethod, params);\n-                        } else {\n-                            System.out.println(\"Cannot find public FastMath method corresponding to: \"+mathMethod);                            \n-                        }\n-                    } catch (NoSuchMethodException e) {\n-                        System.out.println(\"Cannot find FastMath method corresponding to: \"+mathMethod);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testFloatSpecialCases() throws Exception {\n-        testSpecialCases(float.class, new CompareSpecials(FLOAT_SPECIAL_VALUES));\n-    }\n-\n-    @Test\n-    public void testDoubleSpecialCases() throws Exception {\n-        testSpecialCases(double.class, new CompareSpecials(DOUBLE_SPECIAL_VALUES));\n-    }\n-\n     private boolean compareClassMethods(Class<?> class1, Class<?> class2){\n         boolean allfound = true;\n         for(Method method1 : class1.getDeclaredMethods()){\n     @Test\n     public void checkMissingFastMathClasses() {\n         boolean ok = compareClassMethods(StrictMath.class, FastMath.class);\n-        // TODO Assert.assertTrue(\"FastMath should implement all StrictMath methods\", ok);\n+        Assert.assertTrue(\"FastMath should implement all StrictMath methods\", ok);\n     }\n \n     @Ignore", "timestamp": 1295892468, "metainfo": ""}