{"sha": "eb8a3fa490e8c0a05276771f7e58b445f6af3259", "log": "Removal of statistical (min/max) and deleteFrontElements methods from DoubleArray interface (per our previous discussion)  Adjusted dependent Test and StoreUnivariateImpl classes accordingly to accomidate changes.  Added new constructor to FixedDoubleArray for double[].   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n package org.apache.commons.math.stat;\n \n import org.apache.commons.math.util.ContractableDoubleArray;\n-import org.apache.commons.math.util.DoubleArray;\n \n /**\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n     // Use an internal double array\n-    DoubleArray eDA;\n+    ContractableDoubleArray eDA;\n \n     // Store the windowSize\n     private int windowSize = Univariate.INFINITE_WINDOW;\n--- a/src/java/org/apache/commons/math/util/DoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/DoubleArray.java\n      */\n     void clear();\n \n-    /**\n-     * Discards values from the front of the list.  This function removes n \n-     * elements from the front of the array.\n-     * \n-     *@param i number of elements to discard from the front of the array.\n-     */\n-    void discardFrontElements(int i);\n-\n-    /**\n-     * Returns the minimum value stored in this array\n-     *\n-     * @return minimum value contained in this array\n-     */\n-    double getMin();\n-\n-    /**\n-     * Returns the maximum value stored in this array\n-     *\n-     * @return maximum value contained in this array\n-     */\n-    double getMax();\n }\n--- a/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n         return elementArray;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.DoubleArray#getMax()\n-     */\n-    public double getMax() {\n-        double max = internalArray[startIndex];\n-\t\t\n-        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n-            if (internalArray[i] > max) {\n-                max = internalArray[i];\n-            }\n-        }\n-\n-        return max;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.DoubleArray#getMin()\n-     */\n-    public double getMin() {\n-        double min = internalArray[startIndex];\n-\n-        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n-            if (internalArray[i] < min) {\n-                min = internalArray[i];\n-            }\n-        }\n-\n-        return min;\n-    }\n }\n--- a/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n     }\n \n     /**\n+     * Create a fixed array backed by the provided double[] implementation. \n+     * the array should have all the elements occupied. the size and maxElements\n+     * are drawn from the array's length.\n+     * \n+     * This implementation of DoubleArray was created to provide a more \n+     * \"performance-oriented\" in-place rolling mechanism for calculations \n+     * which need to operate on a rolling window of values.\n+     * @param array the backing array\n+     */\n+    public FixedDoubleArray(double[] array) {\n+        this.maxElements = array.length;\n+        this.size = array.length;\n+        internalArray = array;\n+    }\n+    \n+    /**\n      * Retrieves the current size of the array.\n      * @see org.apache.commons.math.DoubleArray#getNumElements()\n      */\n         throw new RuntimeException(msg);\n     }\n \n-    /**\n-     * Retrieves the minimum double value contained in this array.\n-     *\n-     * @return The number less than all other numbers in this \n-     *         array.\n-     * @see org.apache.commons.math.DoubleArray#getMin()\n-     */\n-    public double getMin() {\n-        double min = internalArray[0];\n-        for (int i = 1; i < size; i++) {\n-            if (internalArray[i] < min) {\n-                min = internalArray[i];\n-            }\n-        }\n-        return min;\n-    }\n-\n-    /**\n-     * Retrieves the maximum double value contained in this array.\n-     * \n-     * @return The number greater than all other numbers in this\n-     *         array.\n-     * @see org.apache.commons.math.DoubleArray#getMax()\n-     */\n-    public double getMax() {\n-        double max = internalArray[0];\n-        for (int i = 1; i < size; i++) {\n-            if (internalArray[i] > max) {\n-                max = internalArray[i];\n-            }\n-        }\n-        return max;\n-    }\n }\n--- a/src/test/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n+++ b/src/test/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n  * <http://www.apache.org/>.\n  */\n package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.stat.StatUtils;\n \n import junit.framework.TestCase;\n \n \t\tassertEquals(\n \t\t\t\"The max element should be 2.0\",\n \t\t\t2.0,\n-\t\t\tra.getMax(),\n+            StatUtils.max(ra.getElements()),\n \t\t\tDouble.MIN_VALUE);\n \t\tassertEquals(\n \t\t\t\"The min element should be 1.0\",\n \t\t\t1.0,\n-\t\t\tra.getMin(),\n+            StatUtils.min(ra.getElements()),\n \t\t\tDouble.MIN_VALUE);\n \n \t\tfor (int i = 0; i < 1024; i++) {\n \t\tda.addElement(122.0);\n \t\tda.addElement(1212.0);\n \n-\t\tassertEquals(\"Min should be -2.0\", -2.0, da.getMin(), Double.MIN_VALUE);\n+\t\tassertEquals(\"Min should be -2.0\", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);\n \t\tassertEquals(\n \t\t\t\"Max should be 1212.0\",\n \t\t\t1212.0,\n-\t\t\tda.getMax(),\n+            StatUtils.max(da.getElements()),\n \t\t\tDouble.MIN_VALUE);\n \t}\n \n--- a/src/test/org/apache/commons/math/util/ExpandableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/util/ExpandableDoubleArrayTest.java\n \t\tda.addElement(2.0);\n \t\tassertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n \t\t\n-\t\tda.discardFrontElements(5);\n+\t\t((ExpandableDoubleArray)da).discardFrontElements(5);\n \t\tassertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n \t\t\n \t\ttry {\n-\t\t\tda.discardFrontElements(-1);\n+            ((ExpandableDoubleArray)da).discardFrontElements(-1);\n \t\t\tfail( \"Trying to discard a negative number of element is not allowed\");\n \t\t} catch( Exception e ){\n \t\t}\n \t\t\n \t\ttry {\n-\t\t\tda.discardFrontElements( 10000 );\n+            ((ExpandableDoubleArray)da).discardFrontElements( 10000 );\n \t\t\tfail( \"You can't discard more elements than the array contains\");\n \t\t} catch( Exception e ){\n \t\t}\n--- a/src/test/org/apache/commons/math/util/FixedDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/util/FixedDoubleArrayTest.java\n \t\t\t\t\n \t}\n \t\n-\tpublic void testDiscardFront() {\n-\t\ttry {\n-\t\t\tda.discardFrontElements( 2 );\n-\t\t\tfail( \"Discard front elements should throw an exception\");\n-\t\t} catch( Exception e ) {\n-\t\t}\n-\t}\n \t\t\n }", "timestamp": 1056747508, "metainfo": ""}