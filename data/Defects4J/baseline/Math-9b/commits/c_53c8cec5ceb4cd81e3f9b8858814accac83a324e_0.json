{"sha": "53c8cec5ceb4cd81e3f9b8858814accac83a324e", "log": "Fixed an event resetting issue in ODE.  When several discrete events occur during the same ODE integration step, they are handled chronologically or reverse chronologically depending on the integration direction. If one of the event truncates the step (for example because its eventOccurred method returns RESET or RESET_DERIVATIVES for example), the stepAccepted method of the pending events later in the step were not called. This implied that in the next step, these events were still referring to data from previous step, they had lost synchronization with the integrator.  JIRA: MATH-695  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.Precision;\n \n /**\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n-            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n--- a/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n \n \n import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.junit.Assert;\n \n     }\n \n+    // Jira: MATH-695\n+    @Test\n+    public void testIssue695() {\n+\n+        FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n+            \n+            public int getDimension() {\n+                return 1;\n+            }\n+            \n+            public void computeDerivatives(double t, double[] y, double[] yDot) {\n+                yDot[0] = 1.0;\n+            }\n+        };\n+\n+        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n+        integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n+        integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n+        integrator.setInitialStepSize(3.0);\n+\n+        double target = 30.0;\n+        double[] y = new double[1];\n+        double tEnd = integrator.integrate(equation, 0.0, y, target, y);\n+        Assert.assertEquals(target, tEnd, 1.0e-10);\n+        Assert.assertEquals(32.0, y[0], 1.0e-10);\n+\n+    }\n+\n+    private static class ResettingEvent implements EventHandler {\n+\n+        private static double lastTriggerTime = Double.NEGATIVE_INFINITY;\n+        private final double tEvent;\n+\n+        public ResettingEvent(final double tEvent) {\n+            this.tEvent = tEvent;\n+        }\n+\n+        public double g(double t, double[] y) {\n+            // the bug corresponding to issue 695 causes the g function\n+            // to be called at obsolete times t despite an event\n+            // occurring later has already been triggered.\n+            // When this occurs, the following assertion is violated\n+            Assert.assertTrue(\"going backard in time! (\" + t + \" < \" + lastTriggerTime + \")\",\n+                              t >= lastTriggerTime);\n+            return t - tEvent;\n+        }\n+\n+        public Action eventOccurred(double t, double[] y, boolean increasing) {\n+            // remember in a class variable when the event was triggered\n+            lastTriggerTime = t;\n+            return Action.RESET_STATE;\n+        }\n+\n+        public void resetState(double t, double[] y) {\n+            y[0] += 1.0;\n+        }\n+\n+    };\n+\n+\n }", "timestamp": 1319620102, "metainfo": ""}