{"sha": "f81847d8079753ce45b049813730055188a22efb", "log": "Fixed a wrong assumption on BSP tree attributes.  The assumption was that the attribute was always a boolean when boundary was empty. This assumption was false when emptiness resulted from a collapsed boundary. Boolean attributes occur only at leaf nodes, so it is the cut sub-hyperplane that needed to be checked.  JIRA: MATH-780  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n-            if ((Boolean) getTree(false).getAttribute()) {\n+            final BSPTree<Euclidean2D> tree = getTree(false);\n+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+                // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.java\n  */\n package org.apache.commons.math3.geometry.euclidean.threed;\n \n+import java.util.ArrayList;\n+\n+import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet;\n+import org.apache.commons.math3.geometry.euclidean.twod.SubLine;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.geometry.partitioning.BSPTree;\n import org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;\n import org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;\n import org.apache.commons.math3.geometry.partitioning.Region;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n+import org.apache.commons.math3.geometry.partitioning.SubHyperplane;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n     }\n \n+    @Test\n+    public void testIssue780() {\n+        float[] coords = {\n+            1.000000f, -1.000000f, -1.000000f, \n+            1.000000f, -1.000000f, 1.000000f, \n+            -1.000000f, -1.000000f, 1.000000f, \n+            -1.000000f, -1.000000f, -1.000000f, \n+            1.000000f, 1.000000f, -1f, \n+            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n+            -1.000000f, 1.000000f, 1.000000f, \n+            -1.000000f, 1.000000f, -1.000000f};\n+        int[] indices = {\n+            0, 1, 2, 0, 2, 3, \n+            4, 7, 6, 4, 6, 5, \n+            0, 4, 5, 0, 5, 1, \n+            1, 5, 6, 1, 6, 2, \n+            2, 6, 7, 2, 7, 3, \n+            4, 0, 3, 4, 3, 7};\n+        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n+        for (int idx = 0; idx < indices.length; idx += 3) {\n+            int idxA = indices[idx] * 3;\n+            int idxB = indices[idx + 1] * 3;\n+            int idxC = indices[idx + 2] * 3;\n+            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n+            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n+            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n+            Vector3D[] vertices = {v_1, v_2, v_3};\n+            Plane polyPlane = new Plane(v_1, v_2, v_3);\n+            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n+\n+            Vector2D[] projPts = new Vector2D[vertices.length];\n+            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n+                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n+            }\n+\n+            SubLine lineInPlane = null;\n+            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n+                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n+                lines.add(lineInPlane);\n+            }\n+            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n+            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n+            subHyperplaneList.add(polygon);\n+        }\n+        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n+        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n+        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n+    }\n+\n     private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) {\n         for (int i = 0; i < points.length; ++i) {\n             Assert.assertEquals(expected, tree.checkPoint(points[i]));", "timestamp": 1336924316, "metainfo": ""}