{"sha": "fd4808e7623b770cd3aa67253e4b8d0025434068", "log": "Removed methods treating T[] as FieldVector. Modified SparseFieldVectorTest to allow for testing of operations on mixed types (Sparse/non-sparse).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public FieldVector<T> add(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T[] out = buildArray(data.length);\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i].add(v[i]);\n-        }\n-        return new ArrayFieldVector<T>(field, out, false);\n-    }\n-\n     /**\n      * Compute the sum of this and v.\n      * @param v vector to be added\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n     public ArrayFieldVector<T> add(ArrayFieldVector<T> v) {\n-        return (ArrayFieldVector<T>) add(v.data);\n+        checkVectorDimensions(v.data.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(v.data[i]);\n+        }\n+        return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public FieldVector<T> subtract(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T[] out = buildArray(data.length);\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i].subtract(v[i]);\n-        }\n-        return new ArrayFieldVector<T>(field, out, false);\n-    }\n-\n     /**\n      * Compute this minus v.\n      * @param v vector to be subtracted\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n     public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v) {\n-        return (ArrayFieldVector<T>) subtract(v.data);\n+        checkVectorDimensions(v.data.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(v.data[i]);\n+        }\n+        return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T[] out = buildArray(data.length);\n-        for (int i = 0; i < data.length; i++) {\n-            out[i] = data[i].multiply(v[i]);\n-        }\n-        return new ArrayFieldVector<T>(field, out, false);\n-    }\n-\n     /**\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n     public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v) {\n-        return (ArrayFieldVector<T>) ebeMultiply(v.data);\n+        checkVectorDimensions(v.data.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(v.data[i]);\n+        }\n+        return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T[] out = buildArray(data.length);\n-        for (int i = 0; i < data.length; i++) {\n-                out[i] = data[i].divide(v[i]);\n-        }\n-        return new ArrayFieldVector<T>(field, out, false);\n-    }\n-\n     /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n     public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v) {\n-        return (ArrayFieldVector<T>) ebeDivide(v.data);\n+        checkVectorDimensions(v.data.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v.data[i]);\n+        }\n+        return new ArrayFieldVector<T>(field, out, false);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public T dotProduct(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T dot = field.getZero();\n-        for (int i = 0; i < data.length; i++) {\n-            dot = dot.add(data[i].multiply(v[i]));\n-        }\n-        return dot;\n-    }\n-\n     /**\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n     public T dotProduct(ArrayFieldVector<T> v) {\n-        return dotProduct(v.data);\n+        checkVectorDimensions(v.data.length);\n+        T dot = field.getZero();\n+        for (int i = 0; i < data.length; i++) {\n+            dot = dot.add(data[i].multiply(v.data[i]));\n+        }\n+        return dot;\n     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> projection(FieldVector<T> v) {\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldVector<T> projection(T[] v) {\n-        return projection(new ArrayFieldVector<T>(getField(), v, false));\n     }\n \n    /** Find the orthogonal projection of this vector onto another vector.\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n     public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {\n-        return outerProduct(v.data);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(T[] v) {\n         final int m = data.length;\n-        final int n = v.length;\n+        final int n = v.data.length;\n         final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n         for (int i = 0; i < m; i++) {\n             for (int j = 0; j < n; j++) {\n-                out.setEntry(i, j, data[i].multiply(v[j]));\n+                out.setEntry(i, j, data[i].multiply(v.data[j]));\n             }\n         }\n         return out;\n         System.arraycopy(data, 0, out, 0, data.length);\n         out[data.length] = in;\n         return new ArrayFieldVector<T>(field, out, false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldVector<T> append(T[] in) {\n-        return new ArrayFieldVector<T>(this, in);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    public void setSubVector(int index, T[] v) {\n-        try {\n-            System.arraycopy(v, 0, data, index, v.length);\n-        } catch (IndexOutOfBoundsException e) {\n-            checkIndex(index);\n-            checkIndex(index + v.length - 1);\n-        }\n-    }\n-\n     /**\n      * Set a set of consecutive elements.\n      *\n      * inconsistent with vector size\n      */\n     public void set(int index, ArrayFieldVector<T> v) {\n-        setSubVector(index, v.data);\n+        try {\n+            System.arraycopy(v.data, 0, data, index, v.data.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.data.length - 1);\n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java\n         throws IllegalArgumentException;\n \n     /**\n-     * Compute the sum of this and v.\n-     * @param v vector to be added\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    FieldVector<T> add(T[] v)\n-        throws IllegalArgumentException;\n-\n-    /**\n      * Compute this minus v.\n      * @param v vector to be subtracted\n      * @return this + v\n         throws IllegalArgumentException;\n \n     /**\n-     * Compute this minus v.\n-     * @param v vector to be subtracted\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    FieldVector<T> subtract(T[] v)\n-        throws IllegalArgumentException;\n-\n-    /**\n      * Map an addition operation to each entry.\n      * @param d value to be added to each entry\n      * @return this + d\n     FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException;\n \n     /**\n-     * Element-by-element multiplication.\n-     * @param v vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException;\n-\n-    /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n     FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException;\n-\n-    /**\n-     * Element-by-element division.\n-     * @param v vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException;\n \n     /**\n      * Returns vector entries as a T array.\n     T dotProduct(FieldVector<T> v)\n         throws IllegalArgumentException;\n \n-    /**\n-     * Compute the dot product.\n-     * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    T dotProduct(T[] v)\n-        throws IllegalArgumentException;\n-\n     /** Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which instance must be projected\n      * @return projection of the instance onto v\n     FieldVector<T> projection(FieldVector<T> v)\n         throws IllegalArgumentException;\n \n-    /** Find the orthogonal projection of this vector onto another vector.\n-     * @param v vector onto which instance must be projected\n-     * @return projection of the instance onto v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    FieldVector<T> projection(T[] v)\n-        throws IllegalArgumentException;\n-\n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n      * @return the matrix outer product between instance and v\n      */\n     FieldMatrix<T> outerProduct(FieldVector<T> v);\n-\n-    /**\n-     * Compute the outer product.\n-     * @param v vector with which outer product should be computed\n-     * @return the matrix outer product between instance and v\n-     */\n-    FieldMatrix<T> outerProduct(T[] v);\n \n     /**\n      * Returns the entry in the specified index.\n     FieldVector<T> append(T d);\n \n     /**\n-     * Construct a vector by appending a T array to this vector.\n-     * @param a T array to append.\n-     * @return a new vector\n-     */\n-    FieldVector<T> append(T[] a);\n-\n-    /**\n      * Get a subvector from consecutive elements.\n      * @param index index of first element.\n      * @param n number of elements to be retrieved.\n     void setSubVector(int index, FieldVector<T> v);\n \n     /**\n-     * Set a set of consecutive elements.\n-     * @param index index of first element to be set.\n-     * @param v vector containing the values to set.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is inconsistent with vector size.\n-     * @see #setSubVector(int, FieldVector)\n-     */\n-    void setSubVector(int index, T[] v);\n-\n-    /**\n      * Set all elements to a single value.\n      * @param value single value to set for all elements\n      */\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n \n     }\n \n-\n-    /** {@inheritDoc} */\n-    public FieldVector<T> add(T[] v) {\n-        checkVectorDimensions(v.length);\n-        SparseFieldVector<T> res = new SparseFieldVector<T>(field,getDimension());\n-        for (int i = 0; i < v.length; i++) {\n-            res.setEntry(i, v[i].add(getEntry(i)));\n-        }\n-        return res;\n-    }\n-\n     /**\n      * Construct a vector by appending a vector to this vector.\n      *\n         if (v instanceof SparseFieldVector<?>) {\n             return append((SparseFieldVector<T>) v);\n         } else {\n-            return append(v.toArray());\n+            final int n = v.getDimension();\n+            FieldVector<T> res = new SparseFieldVector<T>(this, n);\n+            for (int i = 0; i < n; i++) {\n+                res.setEntry(i + virtualSize, v.getEntry(i));\n+            }\n+            return res;\n         }\n     }\n \n      }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> append(T[] a) {\n-        FieldVector<T> res = new SparseFieldVector<T>(this, a.length);\n-        for (int i = 0; i < a.length; i++) {\n-            res.setEntry(i + virtualSize, a[i]);\n-        }\n-        return res;\n-     }\n-\n-    /** {@inheritDoc} */\n     public FieldVector<T> copy() {\n         return new SparseFieldVector<T>(this);\n    }\n         }\n         return res;\n     }\n-\n-    /** {@inheritDoc} */\n-    public T dotProduct(T[] v) {\n-        checkVectorDimensions(v.length);\n-        T res = field.getZero();\n-        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            int idx = iter.key();\n-            T value = field.getZero();\n-            if (idx < v.length) {\n-                value = v[idx];\n-            }\n-            res = res.add(value.multiply(iter.value()));\n-        }\n-        return res;\n-     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> ebeDivide(FieldVector<T> v) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(T[] v) {\n-        checkVectorDimensions(v.length);\n-        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n-        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res.setEntry(iter.key(), iter.value().divide(v[iter.key()]));\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n     public FieldVector<T> ebeMultiply(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key())));\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-     public FieldVector<T> ebeMultiply(T[] v) {\n-        checkVectorDimensions(v.length);\n-        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n-        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res.setEntry(iter.key(), iter.value().multiply(v[iter.key()]));\n         }\n         return res;\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(T[] v) {\n-        final int n = v.length;\n-        FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, n);\n-        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            int row = iter.key();\n-            FieldElement<T>value = iter.value();\n-            for (int col = 0; col < n; col++) {\n-                res.setEntry(row, col, value.multiply(v[col]));\n-            }\n-        }\n-        return res;\n-     }\n-\n-    /** {@inheritDoc} */\n     public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n         if (v instanceof SparseFieldVector<?>) {\n             return outerProduct((SparseFieldVector<T>)v);\n         } else {\n-            return outerProduct(v.toArray());\n+            final int n = v.getDimension();\n+            FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, n);\n+            OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+            while (iter.hasNext()) {\n+                iter.advance();\n+                int row = iter.key();\n+                FieldElement<T>value = iter.value();\n+                for (int col = 0; col < n; col++) {\n+                    res.setEntry(row, col, value.multiply(v.getEntry(col)));\n+                }\n+            }\n+            return res;\n         }\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> projection(T[] v) {\n-        checkVectorDimensions(v.length);\n-        return projection(new SparseFieldVector<T>(field,v));\n-    }\n-\n-    /** {@inheritDoc} */\n     public void set(T value) {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, value);\n     public void setSubVector(int index, FieldVector<T> v) {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n-        setSubVector(index, v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setSubVector(int index, T[] v) {\n-        checkIndex(index);\n-        checkIndex(index + v.length - 1);\n-        for (int i = 0; i < v.length; i++) {\n-            setEntry(i + index, v[i]);\n-        }\n-\n+        final int n = v.getDimension();\n+        for (int i = 0; i < n; i++) {\n+            setEntry(i + index, v.getEntry(i));\n+        }\n     }\n \n     /**\n         if (v instanceof SparseFieldVector<?>) {\n             return subtract((SparseFieldVector<T>)v);\n         } else {\n-            return subtract(v.toArray());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldVector<T> subtract(T[] v) {\n-        checkVectorDimensions(v.length);\n-        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n-        for (int i = 0; i < v.length; i++) {\n-            if (entries.containsKey(i)) {\n-                res.setEntry(i, entries.get(i).subtract(v[i]));\n-            } else {\n-                res.setEntry(i, field.getZero().subtract(v[i]));\n-            }\n-        }\n-        return res;\n+            final int n = v.getDimension();\n+            checkVectorDimensions(n);\n+            SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+            for (int i = 0; i < n; i++) {\n+                if (entries.containsKey(i)) {\n+                    res.setEntry(i, entries.get(i).subtract(v.getEntry(i)));\n+                } else {\n+                    res.setEntry(i, field.getZero().subtract(v.getEntry(i)));\n+                }\n+            }\n+            return res;\n+        }\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public FieldVector<T> add(FieldVector<T> v) {\n         if (v instanceof SparseFieldVector<?>) {\n-            return add((SparseFieldVector<T>)v);\n+            return add((SparseFieldVector<T>) v);\n         } else {\n-            return add(v.toArray());\n+            final int n = v.getDimension();\n+            checkVectorDimensions(n);\n+            SparseFieldVector<T> res = new SparseFieldVector<T>(field,\n+                                                                getDimension());\n+            for (int i = 0; i < n; i++) {\n+                res.setEntry(i, v.getEntry(i).add(getEntry(i)));\n+            }\n+            return res;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n         Assert.assertEquals(4, v_append_2.getDimension());\n         Assert.assertEquals(new Fraction(2), v_append_2.getEntry(3));\n \n-        FieldVector<Fraction> v_append_3 = v1.append(vec2);\n-        Assert.assertEquals(6, v_append_3.getDimension());\n-        Assert.assertEquals(new Fraction(4), v_append_3.getEntry(3));\n-\n         FieldVector<Fraction> v_append_4 = v1.append(v2_t);\n         Assert.assertEquals(6, v_append_4.getDimension());\n         Assert.assertEquals(new Fraction(4), v_append_4.getEntry(3));\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n         SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);\n \n-        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2);\n+        FieldVector<Fraction> v2_t = new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);\n \n         //octave =  v1 + v2\n         FieldVector<Fraction> v_add = v1.add(v2);\n         Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n         Assert.assertArrayEquals(\"compare vect\" ,v_add.getData(),result_add);\n \n-        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);\n+        FieldVector<Fraction> vt2 = new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);\n         FieldVector<Fraction> v_add_i = v1.add(vt2);\n         Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n         Assert.assertArrayEquals(\"compare vect\" ,v_add_i.getData(),result_add_i);", "timestamp": 1316284923, "metainfo": ""}