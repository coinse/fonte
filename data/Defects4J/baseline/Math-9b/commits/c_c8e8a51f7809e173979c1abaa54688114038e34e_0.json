{"sha": "c8e8a51f7809e173979c1abaa54688114038e34e", "log": "Code cleanup: Removed calls to \"min\" function when result was already known.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n             n = matrix.getColumnDimension();\n         }\n  \n-        final int nu = FastMath.min(m, n);\n-        singularValues = new double[FastMath.min(m + 1, n)];\n-        final double[][] U = new double[m][nu];\n+        singularValues = new double[n];\n+        final double[][] U = new double[m][n];\n         final double[][] V = new double[n][n];\n         final double[] e = new double[n];\n         final double[] work = new double[m];\n         // Reduce A to bidiagonal form, storing the diagonal elements\n         // in s and the super-diagonal elements in e.\n         final int nct = FastMath.min(m - 1, n);\n-        final int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n+        final int nrt = FastMath.max(0, n - 2);\n         for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n             if (k < nct) {\n                 // Compute the transformation for the k-th column and\n             }\n         }\n         // Set up the final bidiagonal matrix or order p.\n-        int p = FastMath.min(n, m + 1);\n+        int p = n;\n         if (nct < n) {\n             singularValues[nct] = A[nct][nct];\n         }\n         e[p - 1] = 0.0;\n \n         // Generate U.\n-        for (int j = nct; j < nu; j++) {\n+        for (int j = nct; j < n; j++) {\n             for (int i = 0; i < m; i++) {\n                 U[i][j] = 0.0;\n             }\n         }\n         for (int k = nct - 1; k >= 0; k--) {\n             if (singularValues[k] != 0.0) {\n-                for (int j = k + 1; j < nu; j++) {\n+                for (int j = k + 1; j < n; j++) {\n                     double t = 0;\n                     for (int i = k; i < m; i++) {\n                         t += U[i][k] * U[i][j];\n         for (int k = n - 1; k >= 0; k--) {\n             if (k < nrt &&\n                 e[k] != 0) {\n-                for (int j = k + 1; j < nu; j++) {\n+                for (int j = k + 1; j < n; j++) {\n                     double t = 0;\n                     for (int i = k + 1; i < n; i++) {\n                         t += V[i][k] * V[i][j];\n         } else {\n             cachedU = MatrixUtils.createRealMatrix(V);\n             cachedV = MatrixUtils.createRealMatrix(U);\n-\n         }\n     }\n \n \n     /** {@inheritDoc} */\n     public double getConditionNumber() {\n-        return singularValues[0] / singularValues[FastMath.min(m, n) - 1];\n+        return singularValues[0] / singularValues[n - 1];\n     }\n \n     /** {@inheritDoc} */", "timestamp": 1313190077, "metainfo": ""}