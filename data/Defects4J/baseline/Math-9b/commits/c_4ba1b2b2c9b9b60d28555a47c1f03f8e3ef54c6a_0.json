{"sha": "4ba1b2b2c9b9b60d28555a47c1f03f8e3ef54c6a", "log": "Select bracketing side from the solve method instead of through a setter for consistency with the other solvers.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolutions.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolutions.java\n  * This basically controls whether or not under-approximations and\n  * over-approximations are allowed.\n  *\n- * <p>If all solutions are accepted ({@link #EITHER_SIDE}), then the solution\n+ * <p>If all solutions are accepted ({@link #ANY_SIDE}), then the solution\n  * that the root-finding algorithm returns for a given root may be equal to the\n  * actual root, but it may also be an approximation that is slightly smaller\n  * or slightly larger than the actual root. Root-finding algorithms generally\n      * root-finding result s may be smaller than x0, equal to x0, or greater\n      * than x0.\n      */\n-    EITHER_SIDE,\n+    ANY_SIDE,\n \n     /** Only solutions that are less than or equal to the actual root are\n      * acceptable as solutions for root-finding. In other words,\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n /** Interface for {@link UnivariateRealSolver (univariate real) root-finding\n  * algorithms} that maintain a bracketed solution. There are several advantages\n  * to having such root-finding algorithms:\n  * </ul>\n  *\n  * <p>For backwards compatibility, all root-finding algorithms must have\n- * {@link AllowedSolutions#EITHER_SIDE EITHER_SIDE} as default for the allowed\n+ * {@link AllowedSolutions#ANY_SIDE ANY_SIDE} as default for the allowed\n  * solutions.</p>\n  *\n  * @see AllowedSolutions\n  * @since 3.0\n  * @version $Id$\n  */\n-public interface BracketedUnivariateRealSolver extends UnivariateRealSolver {\n-    /** Returns the kind of solutions that the root-finding algorithm may\n+public interface BracketedUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n+    extends BaseUnivariateRealSolver<FUNC> {\n+\n+    /**\n+     * Solve for a zero in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    double solve(int maxEval, FUNC f, double min, double max,\n+                 AllowedSolutions allowedSolutions);\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n      *\n-     * @return the kind of solutions that the root-finding algorithm may\n-     * accept as solutions\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n      */\n-    AllowedSolutions getAllowedSolutions();\n+    double solve(int maxEval, FUNC f, double min, double max, double startValue,\n+                 AllowedSolutions allowedSolutions);\n \n-    /** Sets the kind of solutions that the root-finding algorithm may accept\n-     * as solutions.\n-     *\n-     * @param allowedSolutions the kind of solutions that the root-finding\n-     * algorithm may accept as solutions\n-     */\n-    void setAllowedSolutions(AllowedSolutions allowedSolutions);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class IllinoisSolver extends BaseBracketedSecantSolver {\n+public class IllinoisSolver extends BaseSecantSolver {\n+\n     /** Construct a solver with default accuracy (1e-6). */\n     public IllinoisSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.ILLINOIS);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class PegasusSolver extends BaseBracketedSecantSolver {\n+public class PegasusSolver extends BaseSecantSolver {\n+\n     /** Construct a solver with default accuracy (1e-6). */\n     public PegasusSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.PEGASUS);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class RegulaFalsiSolver extends BaseBracketedSecantSolver {\n+public class RegulaFalsiSolver extends BaseSecantSolver {\n+\n     /** Construct a solver with default accuracy (1e-6). */\n     public RegulaFalsiSolver() {\n         super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n     public void testSolutionLeftSide() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n-        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n-        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.LEFT_SIDE);\n-        double left = -1.5;\n-        double right = 0.05;\n-        for(int i = 0; i < 10; i++) {\n-            // Test whether the allowed solutions are taken into account.\n-            double solution = solver.solve(100, f, left, right);\n-            Assert.assertTrue(solution <= 0.0);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.LEFT_SIDE);\n+            if (!Double.isNaN(solution)) {\n+                Assert.assertTrue(solution <= 0.0);\n+            }\n \n             // Prepare for next test.\n             left -= 0.1;\n     public void testSolutionRightSide() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n-        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n-        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.RIGHT_SIDE);\n-        double left = -1.5;\n-        double right = 0.05;\n-        for(int i = 0; i < 10; i++) {\n-            // Test whether the allowed solutions are taken into account.\n-            double solution = solver.solve(100, f, left, right);\n-            Assert.assertTrue(solution >= 0.0);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.RIGHT_SIDE);\n+            if (!Double.isNaN(solution)) {\n+                Assert.assertTrue(solution >= 0.0);\n+            }\n \n             // Prepare for next test.\n             left -= 0.1;\n     public void testSolutionBelowSide() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n-        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n-        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.BELOW_SIDE);\n-        double left = -1.5;\n-        double right = 0.05;\n-        for(int i = 0; i < 10; i++) {\n-            // Test whether the allowed solutions are taken into account.\n-            double solution = solver.solve(100, f, left, right);\n-            Assert.assertTrue(f.value(solution) <= 0.0);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.BELOW_SIDE);\n+            if (!Double.isNaN(solution)) {\n+                Assert.assertTrue(f.value(solution) <= 0.0);\n+            }\n \n             // Prepare for next test.\n             left -= 0.1;\n     public void testSolutionAboveSide() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = getSolver();\n-        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n-        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.ABOVE_SIDE);\n-        double left = -1.5;\n-        double right = 0.05;\n-        for(int i = 0; i < 10; i++) {\n-            // Test whether the allowed solutions are taken into account.\n-            double solution = solver.solve(100, f, left, right);\n-            Assert.assertTrue(f.value(solution) >= 0.0);\n-\n-            // Prepare for next test.\n-            left -= 0.1;\n-            right += 0.3;\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.ABOVE_SIDE);\n+            if (!Double.isNaN(solution)) {\n+                Assert.assertTrue(f.value(solution) >= 0.0);\n+            }\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n+    private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateRealFunction f,\n+                               double left, double right, AllowedSolutions allowedSolutions) {\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n+            (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n+            return bracketing.solve(100, f, left, right, allowedSolutions);\n+        } catch (ClassCastException cce) {\n+            double baseRoot = solver.solve(maxEval, f, left, right);\n+            if ((baseRoot <= left) || (baseRoot >= right)) {\n+                // the solution slipped out of interval\n+                return Double.NaN;\n+            }\n+            PegasusSolver bracketing =\n+                    new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n+            return UnivariateRealSolverUtils.forceSide(maxEval - solver.getEvaluations(),\n+                                                       f, bracketing, baseRoot, left, right,\n+                                                       allowedSolutions);\n         }\n     }\n ", "timestamp": 1310296255, "metainfo": ""}