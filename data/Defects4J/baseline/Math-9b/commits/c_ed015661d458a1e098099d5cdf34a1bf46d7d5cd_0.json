{"sha": "ed015661d458a1e098099d5cdf34a1bf46d7d5cd", "log": "Renamed ComplexMath to ComplexUtils.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implementations of various transcendental functions for\n+ * {@link org.apache.commons.math.complex.Complex} arguments.\n+ *\n+ * Reference:\n+ * <ul>\n+ * <li><a href=\"http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\">\n+ * Multiple Precision Complex Arithmetic and Functions</a></li>\n+ * </ul>\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/07/12 00:27:09 $\n+ */\n+public class ComplexUtils {\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    private ComplexUtils() {\n+        super();\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/InverseCosine.html\">\n+     * inverse cosine</a> for the given complex argument.\n+     * @param z the value whose inverse cosine is to be returned.\n+     * @return the inverse cosine of <code>z</code>.\n+     */\n+    public static Complex acos(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return Complex.I.negate().multiply(log(z.add(\n+            Complex.I.multiply(sqrt1z(z)))));       \n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/InverseSine.html\">\n+     * inverse sine</a> for the given complex argument.\n+     * @param z the value whose inverse sine is to be returned.\n+     * @return the inverse sine of <code>z</code>.\n+     */\n+    public static Complex asin(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return Complex.I.negate().multiply(log(sqrt1z(z).add(\n+            Complex.I.multiply(z))));       \n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/InverseTangent.html\">\n+     * inverse tangent</a> for the given complex argument.\n+     * @param z the value whose inverse tangent is to be returned.\n+     * @return the inverse tangent of <code>z</code>.\n+     */\n+    public static Complex atan(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        \n+        return Complex.I.multiply(\n+            log(Complex.I.add(z).divide(Complex.I.subtract(z))))\n+            .divide(new Complex(2.0, 0.0));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/Cosine.html\">cosine</a>\n+     * for the given complex argument.\n+     * @param z the value whose cosine is to be returned.\n+     * @return the cosine of <code>z</code>.\n+     */\n+    public static Complex cos(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(Math.cos(a) * MathUtils.cosh(b),\n+            -Math.sin(a) * MathUtils.sinh(b));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n+     * hyperbolic cosine</a> for the given complex argument.\n+     * @param z the value whose hyperbolic cosine is to be returned.\n+     * @return the hyperbolic cosine of <code>z</code>.\n+     */\n+    public static Complex cosh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(MathUtils.cosh(a) * Math.cos(b),\n+            MathUtils.sinh(a) * Math.sin(b));\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\">\n+     * exponential function</a> for the given complex argument.\n+     * @param z the value.\n+     * @return <i>e</i><sup><code>z</code></sup>.\n+     */\n+    public static Complex exp(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double b = z.getImaginary();\n+        double expA = Math.exp(z.getReal());\n+        double sinB = Math.sin(b);\n+        double cosB = Math.cos(b);\n+        return new Complex(expA * cosB, expA * sinB);\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\">\n+     * natural logarithm</a> for the given complex argument.\n+     * @param z the value.\n+     * @return ln <code>z</code>.\n+     */\n+    public static Complex log(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return new Complex(Math.log(z.abs()),\n+            Math.atan2(z.getImaginary(), z.getReal()));        \n+    }\n+    \n+    \n+    /**\n+     * Returns of value of <code>y</code> raised to the power of <code>x</code>.\n+     * @param y the base.\n+     * @param x the exponent.\n+     * @return <code>y</code><sup><code>z</code></sup>.\n+     */\n+    public static Complex pow(Complex y, Complex x) {\n+        return exp(x.multiply(log(y)));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/Sine.html\">sine</a>\n+     * for the given complex argument.\n+     * @param z the value whose sine is to be returned.\n+     * @return the sine of <code>z</code>.\n+     */\n+    public static Complex sin(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(Math.sin(a) * MathUtils.cosh(b),\n+            Math.cos(a) * MathUtils.sinh(b));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * hyperbolic sine</a> for the given complex argument.\n+     * @param z the value whose hyperbolic sine is to be returned.\n+     * @return the hyperbolic sine of <code>z</code>.\n+     */\n+    public static Complex sinh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        return new Complex(MathUtils.sinh(a) * Math.cos(b),\n+            MathUtils.cosh(a) * Math.sin(b));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/SquareRoot.html\">squre\n+     * root</a> for the given complex argument.\n+     * @param z the value whose square root is to be returned.\n+     * @return the square root of <code>z</code>.\n+     */\n+    public static Complex sqrt(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a = z.getReal();\n+        double b = z.getImaginary();\n+        \n+        double t = Math.sqrt((Math.abs(a) + z.abs()) / 2.0);\n+        if (a >= 0.0) {\n+            return new Complex(t, b / (2.0 * t));\n+        } else {\n+            return new Complex(Math.abs(z.getImaginary()) / (2.0 * t),\n+                MathUtils.indicator(b) * t);\n+        }\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/SquareRoot.html\">squre\n+     * root of 1 - <code>z</code><sup>2</sup> for the given complex argument.\n+     * @param z the value.\n+     * @return the square root of 1 - <code>z</code><sup>2</sup>.\n+     */\n+    public static Complex sqrt1z(Complex z) {\n+        return sqrt(Complex.ONE.subtract(z.multiply(z)));\n+    }\n+    \n+    /**\n+     * Compute the <a href=\"http://mathworld.wolfram.com/Tangent.html\">\n+     * tangent</a> for the given complex argument.\n+     * @param z the value whose tangent is to be returned.\n+     * @return the tangent of <code>z</code>.\n+     */\n+    public static Complex tan(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a2 = 2.0 * z.getReal();\n+        double b2 = 2.0 * z.getImaginary();\n+        double d = Math.cos(a2) + MathUtils.cosh(b2);\n+        \n+        return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / d);\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\">\n+     * hyperbolic tangent</a> for the given complex argument.\n+     * @param z the value whose hyperbolic tangent is to be returned.\n+     * @return the hyperbolic tangent of <code>z</code>.\n+     */\n+    public static Complex tanh(Complex z) {\n+        if (z.isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double a2 = 2.0 * z.getReal();\n+        double b2 = 2.0 * z.getImaginary();\n+        double d = MathUtils.cosh(a2) + Math.cos(b2);\n+        \n+        return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / d);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/07/12 00:27:09 $\n+ */\n+public class ComplexUtilsTest extends TestCase {\n+    \n+    public void testAcos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.936812, -2.30551);\n+        TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);\n+    }\n+    \n+    public void testAcosNaN() {\n+        assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testAsin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.633984, 2.30551);\n+        TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);\n+    }\n+    \n+    public void testAsinNaN() {\n+        assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testAtan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.44831, 0.158997);\n+        TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);\n+    }\n+    \n+    public void testAtanNaN() {\n+        assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testCos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-27.03495, -3.851153);\n+        TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);\n+    }\n+    \n+    public void testCosh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.58066, -7.58155);\n+        TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);\n+    }\n+    \n+    public void testCoshNaN() {\n+        assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testCosNaN() {\n+        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testExp() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-13.12878, -15.20078);\n+        TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);\n+    }\n+    \n+    public void testExpNaN() {\n+        assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testLog() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.60944, 0.927295);\n+        TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);\n+    }\n+    \n+    public void testLogNaN() {\n+        assertTrue(ComplexUtils.log(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testPow() {\n+        Complex x = new Complex(3, 4);\n+        Complex y = new Complex(5, 6);\n+        Complex expected = new Complex(-1.860893, 11.83677);\n+        TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);\n+    }\n+    \n+    public void testPowNaNBase() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());\n+    }\n+    \n+    public void testPowNaNExponent() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(3.853738, -27.01681);\n+        TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);\n+    }\n+    \n+    public void testSinh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.54812, -7.61923);\n+        TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);\n+    }\n+    \n+    public void testSinhNaN() {\n+        assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSinNaN() {\n+        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSqrtRealPositive() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(2, 1);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealZero() {\n+        Complex z = new Complex(0.0, 4);\n+        Complex expected = new Complex(1.41421, 1.41421);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealNegative() {\n+        Complex z = new Complex(-3.0, 4);\n+        Complex expected = new Complex(1, 2);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryZero() {\n+        Complex z = new Complex(-3.0, 0.0);\n+        Complex expected = new Complex(0.0, 1.73205);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryNegative() {\n+        Complex z = new Complex(-3.0, -4.0);\n+        Complex expected = new Complex(1.0, -2.0);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n+    }\n+\n+    public void testSqrt1z() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(4.08033, -2.94094);\n+        TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrt1zNaN() {\n+        assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSqrtNaN() {\n+        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testTan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-0.000187346, 0.999356);\n+        TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);\n+    }\n+    \n+    public void testTanh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.00071, 0.00490826);\n+        TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);\n+    }\n+    \n+    public void testTanhNaN() {\n+        assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testTanNaN() {\n+        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());\n+    }\n+}", "timestamp": 1089592029, "metainfo": ""}