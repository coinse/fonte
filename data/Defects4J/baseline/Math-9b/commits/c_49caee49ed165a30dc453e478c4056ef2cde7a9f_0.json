{"sha": "49caee49ed165a30dc453e478c4056ef2cde7a9f", "log": "added the optimization package from Mantissa  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This interface specifies how to check if a {@link\n+ * DirectSearchOptimizer direct search method} has converged.\n+\n+ * <p>Deciding if convergence has been reached is a problem-dependent\n+ * issue. The user should provide a class implementing this interface\n+ * to allow the optimization algorithm to stop its search according to\n+ * the problem at hand.</p>\n+\n+ * @version $Id: ConvergenceChecker.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface ConvergenceChecker {\n+\n+  /** Check if the optimization algorithm has converged on the simplex.\n+   * @param simplex ordered simplex (all points in the simplex have\n+   * been eavluated and are sorted from lowest to largest cost)\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  public boolean converged (PointCostPair[] simplex);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/CostException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** This class represents exceptions thrown by cost functions.\n+\n+ * @version $Id: CostException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class CostException\n+  extends MathException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 467695563268795689L;\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public CostException(String pattern, Object[] arguments) {\n+      super(pattern, arguments);\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public CostException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/CostFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This interface represents a cost function to be minimized.\n+ * @author Luc Maisonobe\n+ * @version $Id: CostFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public interface CostFunction {\n+\n+\n+  /** Compute the cost associated to the given parameters array.\n+   * @param x parameters array\n+   * @return cost associated to the parameters array\n+   * @exception CostException if no cost can be computed for the parameters\n+   * @see PointCostPair\n+   */\n+  public double cost(double[] x) throws CostException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.NotPositiveDefiniteMatrixException;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.apache.commons.math.random.UniformRandomGenerator;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+\n+/** This class implements simplex-based direct search optimization\n+ * algorithms.\n+\n+ * <p>Direct search methods only use cost function values, they don't\n+ * need derivatives and don't either try to compute approximation of\n+ * the derivatives. According to a 1996 paper by Margaret H. Wright\n+ * (<a href=\"http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz\">Direct\n+ * Search Methods: Once Scorned, Now Respectable</a>), they are used\n+ * when either the computation of the derivative is impossible (noisy\n+ * functions, unpredictable dicontinuities) or difficult (complexity,\n+ * computation cost). In the first cases, rather than an optimum, a\n+ * <em>not too bad</em> point is desired. In the latter cases, an\n+ * optimum is desired but cannot be reasonably found. In all cases\n+ * direct search methods can be useful.</p>\n+\n+ * <p>Simplex-based direct search methods are based on comparison of\n+ * the cost function values at the vertices of a simplex (which is a\n+ * set of n+1 points in dimension n) that is updated by the algorithms\n+ * steps.</p>\n+\n+ * <p>The instances can be built either in single-start or in\n+ * multi-start mode. Multi-start is a traditional way to try to avoid\n+ * beeing trapped in a local minimum and miss the global minimum of a\n+ * function. It can also be used to verify the convergence of an\n+ * algorithm. In multi-start mode, the {@link #minimizes(CostFunction,\n+ * int, ConvergenceChecker, double[], double[]) minimizes}\n+ * method returns the best minimum found after all starts, and the\n+ * {@link #getMinima getMinima} method can be used to retrieve all\n+ * minima from all starts (including the one already provided by the\n+ * {@link #minimizes(CostFunction, int, ConvergenceChecker, double[],\n+ * double[]) minimizes} method).</p>\n+\n+ * <p>This class is the base class performing the boilerplate simplex\n+ * initialization and handling. The simplex update by itself is\n+ * performed by the derived classes according to the implemented\n+ * algorithms.</p>\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: DirectSearchOptimizer.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see CostFunction\n+ * @see NelderMead\n+ * @see MultiDirectional\n+ */\n+public abstract class DirectSearchOptimizer {\n+\n+    /** Simple constructor.\n+     */\n+    protected DirectSearchOptimizer() {\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The initial simplex is built from two vertices that are\n+     * considered to represent two opposite vertices of a box parallel\n+     * to the canonical axes of the space. The simplex is the subset of\n+     * vertices encountered while going from vertexA to vertexB\n+     * travelling along the box edges only. This can be seen as a scaled\n+     * regular simplex using the projected separation between the given\n+     * points as the scaling factor along each coordinate axis.</p>\n+     * <p>The optimization is performed in single-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param vertexA first vertex\n+     * @param vertexB last vertex\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception NoConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   double[] vertexA, double[] vertexB)\n+    throws CostException, ConvergenceException {\n+\n+        // set up optimizer\n+        buildSimplex(vertexA, vertexB);\n+        setSingleStart();\n+\n+        // compute minimum\n+        return minimizes(f, maxEvaluations, checker);\n+\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The initial simplex is built from two vertices that are\n+     * considered to represent two opposite vertices of a box parallel\n+     * to the canonical axes of the space. The simplex is the subset of\n+     * vertices encountered while going from vertexA to vertexB\n+     * travelling along the box edges only. This can be seen as a scaled\n+     * regular simplex using the projected separation between the given\n+     * points as the scaling factor along each coordinate axis.</p>\n+     * <p>The optimization is performed in multi-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param vertexA first vertex\n+     * @param vertexB last vertex\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param seed seed for the random vector generator\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception NoConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   double[] vertexA, double[] vertexB,\n+                                   int starts, long seed)\n+    throws CostException, ConvergenceException {\n+\n+        // set up the simplex travelling around the box\n+        buildSimplex(vertexA, vertexB);\n+\n+        // we consider the simplex could have been produced by a generator\n+        // having its mean value at the center of the box, the standard\n+        // deviation along each axe beeing the corresponding half size\n+        double[] mean              = new double[vertexA.length];\n+        double[] standardDeviation = new double[vertexA.length];\n+        for (int i = 0; i < vertexA.length; ++i) {\n+            mean[i]              = 0.5 * (vertexA[i] + vertexB[i]);\n+            standardDeviation[i] = 0.5 * Math.abs(vertexA[i] - vertexB[i]);\n+        }\n+\n+        RandomGenerator rg = new JDKRandomGenerator();\n+        rg.setSeed(seed);\n+        UniformRandomGenerator urg = new UniformRandomGenerator(rg);\n+        RandomVectorGenerator rvg =\n+            new UncorrelatedRandomVectorGenerator(mean, standardDeviation, urg);\n+        setMultiStart(starts, rvg);\n+\n+        // compute minimum\n+        return minimizes(f, maxEvaluations, checker);\n+\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The simplex is built from all its vertices.</p>\n+     * <p>The optimization is performed in single-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param vertices array containing all vertices of the simplex\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception ConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   double[][] vertices)\n+    throws CostException, ConvergenceException {\n+\n+        // set up optimizer\n+        buildSimplex(vertices);\n+        setSingleStart();\n+\n+        // compute minimum\n+        return minimizes(f, maxEvaluations, checker);\n+\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The simplex is built from all its vertices.</p>\n+     * <p>The optimization is performed in multi-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param vertices array containing all vertices of the simplex\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param seed seed for the random vector generator\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception NotPositiveDefiniteMatrixException if the vertices\n+     * array is degenerated\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception ConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   double[][] vertices,\n+                                   int starts, long seed)\n+    throws NotPositiveDefiniteMatrixException,\n+    CostException, ConvergenceException {\n+\n+        try {\n+            // store the points into the simplex\n+            buildSimplex(vertices);\n+\n+            // compute the statistical properties of the simplex points\n+            VectorialMean meanStat = new VectorialMean(vertices[0].length);\n+            VectorialCovariance covStat = new VectorialCovariance(vertices[0].length);\n+            for (int i = 0; i < vertices.length; ++i) {\n+                meanStat.increment(vertices[i]);\n+                covStat.increment(vertices[i]);\n+            }\n+\n+            RandomGenerator rg = new JDKRandomGenerator();\n+            rg.setSeed(seed);\n+            RandomVectorGenerator rvg =\n+                new CorrelatedRandomVectorGenerator(meanStat.getResult(),\n+                                                    covStat.getResult(),\n+                                                    new UniformRandomGenerator(rg));\n+            setMultiStart(starts, rvg);\n+\n+            // compute minimum\n+            return minimizes(f, maxEvaluations, checker);\n+\n+        } catch (DimensionMismatchException dme) {\n+            // this should not happen\n+            throw new RuntimeException(\"internal error\");\n+        }\n+\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The simplex is built randomly.</p>\n+     * <p>The optimization is performed in single-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param generator random vector generator\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception ConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   RandomVectorGenerator generator)\n+    throws CostException, ConvergenceException {\n+\n+        // set up optimizer\n+        buildSimplex(generator);\n+        setSingleStart();\n+\n+        // compute minimum\n+        return minimizes(f, maxEvaluations, checker);\n+\n+    }\n+\n+    /** Minimizes a cost function.\n+     * <p>The simplex is built randomly.</p>\n+     * <p>The optimization is performed in multi-start mode.</p>\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @param generator random vector generator\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception ConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    public PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                   ConvergenceChecker checker,\n+                                   RandomVectorGenerator generator,\n+                                   int starts)\n+    throws CostException, ConvergenceException {\n+\n+        // set up optimizer\n+        buildSimplex(generator);\n+        setMultiStart(starts, generator);\n+\n+        // compute minimum\n+        return minimizes(f, maxEvaluations, checker);\n+\n+    }\n+\n+    /** Build a simplex from two extreme vertices.\n+     * <p>The two vertices are considered to represent two opposite\n+     * vertices of a box parallel to the canonical axes of the\n+     * space. The simplex is the subset of vertices encountered while\n+     * going from vertexA to vertexB travelling along the box edges\n+     * only. This can be seen as a scaled regular simplex using the\n+     * projected separation between the given points as the scaling\n+     * factor along each coordinate axis.</p>\n+     * @param vertexA first vertex\n+     * @param vertexB last vertex\n+     */\n+    private void buildSimplex(double[] vertexA, double[] vertexB) {\n+\n+        int n = vertexA.length;\n+        simplex = new PointCostPair[n + 1];\n+\n+        // set up the simplex travelling around the box\n+        for (int i = 0; i <= n; ++i) {\n+            double[] vertex = new double[n];\n+            if (i > 0) {\n+                System.arraycopy(vertexB, 0, vertex, 0, i);\n+            }\n+            if (i < n) {\n+                System.arraycopy(vertexA, i, vertex, i, n - i);\n+            }\n+            simplex[i] = new PointCostPair(vertex, Double.NaN);\n+        }\n+\n+    }\n+\n+    /** Build a simplex from all its points.\n+     * @param vertices array containing all vertices of the simplex\n+     */\n+    private void buildSimplex(double[][] vertices) {\n+        int n = vertices.length - 1;\n+        simplex = new PointCostPair[n + 1];\n+        for (int i = 0; i <= n; ++i) {\n+            simplex[i] = new PointCostPair(vertices[i], Double.NaN);\n+        }\n+    }\n+\n+    /** Build a simplex randomly.\n+     * @param generator random vector generator\n+     */\n+    private void buildSimplex(RandomVectorGenerator generator) {\n+\n+        // use first vector size to compute the number of points\n+        double[] vertex = generator.nextVector();\n+        int n = vertex.length;\n+        simplex = new PointCostPair[n + 1];\n+        simplex[0] = new PointCostPair(vertex, Double.NaN);\n+\n+        // fill up the vertex\n+        for (int i = 1; i <= n; ++i) {\n+            simplex[i] = new PointCostPair(generator.nextVector(), Double.NaN);\n+        }\n+\n+    }\n+\n+    /** Set up single-start mode.\n+     */\n+    private void setSingleStart() {\n+        starts    = 1;\n+        generator = null;\n+        minima    = null;\n+    }\n+\n+    /** Set up multi-start mode.\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public void setMultiStart(int starts, RandomVectorGenerator generator) {\n+        if (starts < 2) {\n+            this.starts    = 1;\n+            this.generator = null;\n+            minima         = null;\n+        } else {\n+            this.starts    = starts;\n+            this.generator = generator;\n+            minima         = null;\n+        }\n+    }\n+\n+    /** Get all the minima found during the last call to {@link\n+     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimizes}.\n+     * <p>The optimizer stores all the minima found during a set of\n+     * restarts when multi-start mode is enabled. The {@link\n+     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimizes} method returns the best point only. This method\n+     * returns all the points found at the end of each starts, including\n+     * the best one already returned by the {@link #minimizes(CostFunction,\n+     * int, ConvergenceChecker, double[], double[]) minimizes} method.\n+     * The array as one element for each start as specified in the constructor\n+     * (it has one element only if optimizer has been set up for single-start).</p>\n+     * <p>The array containing the minima is ordered with the results\n+     * from the runs that did converge first, sorted from lowest to\n+     * highest minimum cost, and null elements corresponding to the runs\n+     * that did not converge (all elements will be null if the {@link\n+     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimizes} method throwed a {@link ConvergenceException\n+     * ConvergenceException}).</p>\n+     * @return array containing the minima, or null if {@link\n+     * #minimizes(CostFunction, int, ConvergenceChecker, double[], double[])\n+     * minimizes} has not been called\n+     */\n+    public PointCostPair[] getMinima() {\n+        return (PointCostPair[]) minima.clone();\n+    }\n+\n+    /** Minimizes a cost function.\n+     * @param f cost function\n+     * @param maxEvaluations maximal number of function calls for each\n+     * start (note that the number will be checked <em>after</em>\n+     * complete simplices have been evaluated, this means that in some\n+     * cases this number will be exceeded by a few units, depending on\n+     * the dimension of the problem)\n+     * @param checker object to use to check for convergence\n+     * @return the point/cost pairs giving the minimal cost\n+     * @exception CostException if the cost function throws one during\n+     * the search\n+     * @exception ConvergenceException if none of the starts did\n+     * converge (it is not thrown if at least one start did converge)\n+     */\n+    private PointCostPair minimizes(CostFunction f, int maxEvaluations,\n+                                    ConvergenceChecker checker)\n+    throws CostException, ConvergenceException {\n+\n+        this.f = f;\n+        minima = new PointCostPair[starts];\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            evaluations = 0;\n+            evaluateSimplex();\n+\n+            for (boolean loop = true; loop;) {\n+                if (checker.converged(simplex)) {\n+                    // we have found a minimum\n+                    minima[i] = simplex[0];\n+                    loop = false;\n+                } else if (evaluations >= maxEvaluations) {\n+                    // this start did not converge, try a new one\n+                    minima[i] = null;\n+                    loop = false;\n+                } else {\n+                    iterateSimplex();\n+                }\n+            }\n+\n+            if (i < (starts - 1)) {\n+                // restart\n+                buildSimplex(generator);\n+            }\n+\n+        }\n+\n+        // sort the minima from lowest cost to highest cost, followed by\n+        // null elements\n+        Arrays.sort(minima, pointCostPairComparator);\n+\n+        // return the found point given the lowest cost\n+        if (minima[0] == null) {\n+            throw new ConvergenceException(\"none of the {0} start points\"\n+                    + \" lead to convergence\",\n+                    new String[] {\n+                            Integer.toString(starts)\n+                    });\n+        }\n+        return minima[0];\n+\n+    }\n+\n+    /** Compute the next simplex of the algorithm.\n+     */\n+    protected abstract void iterateSimplex()\n+    throws CostException;\n+\n+    /** Evaluate the cost on one point.\n+     * <p>A side effect of this method is to count the number of\n+     * function evaluations</p>\n+     * @param x point on which the cost function should be evaluated\n+     * @return cost at the given point\n+     * @exception CostException if no cost can be computed for the parameters\n+     */\n+    protected double evaluateCost(double[] x)\n+    throws CostException {\n+        evaluations++;\n+        return f.cost(x);\n+    }\n+\n+    /** Evaluate all the non-evaluated points of the simplex.\n+     * @exception CostException if no cost can be computed for the parameters\n+     */\n+    protected void evaluateSimplex()\n+    throws CostException {\n+\n+        // evaluate the cost at all non-evaluated simplex points\n+        for (int i = 0; i < simplex.length; ++i) {\n+            PointCostPair pair = simplex[i];\n+            if (Double.isNaN(pair.cost)) {\n+                simplex[i] = new PointCostPair(pair.point, evaluateCost(pair.point));\n+            }\n+        }\n+\n+        // sort the simplex from lowest cost to highest cost\n+        Arrays.sort(simplex, pointCostPairComparator);\n+\n+    }\n+\n+    /** Replace the worst point of the simplex by a new point.\n+     * @param pointCostPair point to insert\n+     */\n+    protected void replaceWorstPoint(PointCostPair pointCostPair) {\n+        int n = simplex.length - 1;\n+        for (int i = 0; i < n; ++i) {\n+            if (simplex[i].cost > pointCostPair.cost) {\n+                PointCostPair tmp = simplex[i];\n+                simplex[i]        = pointCostPair;\n+                pointCostPair     = tmp;\n+            }\n+        }\n+        simplex[n] = pointCostPair;\n+    }\n+\n+    /** Comparator for {@link PointCostPair PointCostPair} objects. */\n+    private static Comparator pointCostPairComparator = new Comparator() {\n+        public int compare(Object o1, Object o2) {\n+            if (o1 == null) {\n+                return (o2 == null) ? 0 : +1;\n+            } else if (o2 == null) {\n+                return -1;\n+            } else {\n+                double cost1 = ((PointCostPair) o1).cost;\n+                double cost2 = ((PointCostPair) o2).cost;\n+                return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n+            }\n+        }\n+    };\n+\n+    /** Simplex. */\n+    protected PointCostPair[] simplex;\n+\n+    /** Cost function. */\n+    private CostFunction f;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found minima. */\n+    private PointCostPair[] minima;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiDirectional.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This class implements the multi-directional direct search method.\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: MultiDirectional.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see NelderMead\n+ */\n+public class MultiDirectional\n+  extends DirectSearchOptimizer {\n+\n+  /** Build a multi-directional optimizer with default coefficients.\n+   * <p>The default values are 2.0 for khi and 0.5 for gamma.</p>\n+   */\n+  public MultiDirectional() {\n+    super();\n+    this.khi   = 2.0;\n+    this.gamma = 0.5;\n+  }\n+\n+  /** Build a multi-directional optimizer with specified coefficients.\n+   * @param khi expansion coefficient\n+   * @param gamma contraction coefficient\n+   */\n+  public MultiDirectional(double khi, double gamma) {\n+    super();\n+    this.khi   = khi;\n+    this.gamma = gamma;\n+  }\n+\n+  /** Compute the next simplex of the algorithm.\n+   */\n+  protected void iterateSimplex()\n+    throws CostException {\n+\n+    while (true) {\n+\n+      // save the original vertex\n+      PointCostPair[] original = simplex;\n+      double originalCost = original[0].cost;\n+\n+      // perform a reflection step\n+      double reflectedCost = evaluateNewSimplex(original, 1.0);\n+      if (reflectedCost < originalCost) {\n+\n+        // compute the expanded simplex\n+        PointCostPair[] reflected = simplex;\n+        double expandedCost = evaluateNewSimplex(original, khi);\n+        if (reflectedCost <= expandedCost) {\n+          // accept the reflected simplex\n+          simplex = reflected;\n+        }\n+\n+        return;\n+\n+      }\n+\n+      // compute the contracted simplex\n+      double contractedCost = evaluateNewSimplex(original, gamma);\n+      if (contractedCost < originalCost) {\n+        // accept the contracted simplex\n+        return;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** Compute and evaluate a new simplex.\n+   * @param original original simplex (to be preserved)\n+   * @param coeff linear coefficient\n+   * @return smallest cost in the transformed simplex\n+   * @exception CostException if the function cannot be evaluated at\n+   * some point\n+   */\n+  private double evaluateNewSimplex(PointCostPair[] original, double coeff)\n+    throws CostException {\n+\n+    double[] xSmallest = original[0].point;\n+    int n = xSmallest.length;\n+\n+    // create the linearly transformed simplex\n+    simplex = new PointCostPair[n + 1];\n+    simplex[0] = original[0];\n+    for (int i = 1; i <= n; ++i) {\n+      double[] xOriginal    = original[i].point;\n+      double[] xTransformed = new double[n];\n+      for (int j = 0; j < n; ++j) {\n+        xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n+      }\n+      simplex[i] = new PointCostPair(xTransformed, Double.NaN);\n+    }\n+\n+    // evaluate it\n+    evaluateSimplex();\n+    return simplex[0].cost;\n+\n+  }\n+\n+  /** Expansion coefficient. */\n+  private double khi;\n+\n+  /** Contraction coefficient. */\n+  private double gamma;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/NelderMead.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This class implements the Nelder-Mead direct search method.\n+\n+ * @author Luc Maisonobe\n+ * @version $Id: NelderMead.java 1705 2006-09-17 19:57:39Z luc $\n+ * @see MultiDirectional\n+ */\n+public class NelderMead\n+  extends DirectSearchOptimizer {\n+\n+  /** Build a Nelder-Mead optimizer with default coefficients.\n+   * <p>The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+   * for both gamma and sigma.</p>\n+   */\n+  public NelderMead() {\n+    super();\n+    this.rho   = 1.0;\n+    this.khi   = 2.0;\n+    this.gamma = 0.5;\n+    this.sigma = 0.5;\n+  }\n+\n+  /** Build a Nelder-Mead optimizer with specified coefficients.\n+   * @param rho reflection coefficient\n+   * @param khi expansion coefficient\n+   * @param gamma contraction coefficient\n+   * @param sigma shrinkage coefficient\n+   */\n+  public NelderMead(double rho, double khi, double gamma, double sigma) {\n+    super();\n+    this.rho   = rho;\n+    this.khi   = khi;\n+    this.gamma = gamma;\n+    this.sigma = sigma;\n+  }\n+\n+  /** Compute the next simplex of the algorithm.\n+   */\n+  protected void iterateSimplex()\n+    throws CostException {\n+\n+    // the simplex has n+1 point if dimension is n\n+    int n = simplex.length - 1;\n+\n+    // interesting costs\n+    double   smallest      = simplex[0].cost;\n+    double   secondLargest = simplex[n-1].cost;\n+    double   largest       = simplex[n].cost;\n+    double[] xLargest      = simplex[n].point;\n+\n+    // compute the centroid of the best vertices\n+    // (dismissing the worst point at index n)\n+    double[] centroid = new double[n];\n+    for (int i = 0; i < n; ++i) {\n+      double[] x = simplex[i].point;\n+      for (int j = 0; j < n; ++j) {\n+        centroid[j] += x[j];\n+      }\n+    }\n+    double scaling = 1.0 / n;\n+    for (int j = 0; j < n; ++j) {\n+      centroid[j] *= scaling;\n+    }\n+\n+    // compute the reflection point\n+    double[] xR       = new double[n];\n+    for (int j = 0; j < n; ++j) {\n+      xR[j] = centroid[j] + rho * (centroid[j] - xLargest[j]);\n+    }\n+    double costR = evaluateCost(xR);\n+\n+    if ((smallest <= costR) && (costR < secondLargest)) {\n+\n+      // accept the reflected point\n+      replaceWorstPoint(new PointCostPair(xR, costR));\n+\n+    } else if (costR < smallest) {\n+\n+      // compute the expansion point\n+      double[] xE = new double[n];\n+      for (int j = 0; j < n; ++j) {\n+        xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n+      }\n+      double costE = evaluateCost(xE);\n+\n+      if (costE < costR) {\n+        // accept the expansion point\n+        replaceWorstPoint(new PointCostPair(xE, costE));\n+      } else {\n+        // accept the reflected point\n+        replaceWorstPoint(new PointCostPair(xR, costR));\n+      }\n+\n+    } else {\n+\n+      if (costR < largest) {\n+\n+        // perform an outside contraction\n+        double[] xC = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n+        }\n+        double costC = evaluateCost(xC);\n+\n+        if (costC <= costR) {\n+          // accept the contraction point\n+          replaceWorstPoint(new PointCostPair(xC, costC));\n+          return;\n+        }\n+\n+      } else {\n+\n+        // perform an inside contraction\n+        double[] xC = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);\n+        }\n+        double costC = evaluateCost(xC);\n+\n+        if (costC < largest) {\n+          // accept the contraction point\n+          replaceWorstPoint(new PointCostPair(xC, costC));\n+          return;\n+        }\n+\n+      }\n+\n+      // perform a shrink\n+      double[] xSmallest = simplex[0].point;\n+      for (int i = 1; i < simplex.length; ++i) {\n+        double[] x = simplex[i].point;\n+        for (int j = 0; j < n; ++j) {\n+          x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n+        }\n+        simplex[i] = new PointCostPair(x, Double.NaN);\n+      }\n+      evaluateSimplex();\n+\n+    }\n+\n+  }\n+\n+  /** Reflection coefficient. */\n+  private double rho;\n+\n+  /** Expansion coefficient. */\n+  private double khi;\n+\n+  /** Contraction coefficient. */\n+  private double gamma;\n+\n+  /** Shrinkage coefficient. */\n+  private double sigma;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/PointCostPair.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This class holds a point and its associated cost.\n+ * <p>This is a simple immutable container.</p>\n+ * @author Luc Maisonobe\n+ * @version $Id: PointCostPair.java 1709 2006-12-03 21:16:50Z luc $\n+ * @see CostFunction\n+ */\n+public class PointCostPair {\n+\n+  /** Build a point/cost pair.\n+   * @param point point coordinates\n+   * @param cost point cost\n+   */\n+  public PointCostPair(double[] point, double cost) {\n+    this.point = (double[]) point.clone();\n+    this.cost = cost;\n+  }\n+\n+  /** Point coordinates. */\n+  public final double[] point;\n+\n+  /** Cost associated to the point. */\n+  public final double cost;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.CostException;\n+import org.apache.commons.math.optimization.CostFunction;\n+import org.apache.commons.math.optimization.MultiDirectional;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.optimization.PointCostPair;\n+\n+import junit.framework.*;\n+\n+public class MultiDirectionalTest\n+  extends TestCase {\n+\n+  public MultiDirectionalTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testRosenbrock()\n+    throws CostException, ConvergenceException {\n+\n+    CostFunction rosenbrock =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                                       new double[] { -1.2,  1.0 },\n+                                       new double[] {  3.5, -2.3 });\n+\n+    assertTrue(count > 60);\n+    assertTrue(optimum.cost > 0.02);\n+\n+  }\n+\n+  public void testPowell()\n+    throws CostException, ConvergenceException {\n+\n+    CostFunction powell =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),\n+                                       new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                                       new double[] {  4.0,  0.0, 1.0, 2.0 });\n+    assertTrue(count > 850);\n+    assertTrue(optimum.cost > 0.015);\n+\n+  }\n+\n+  private static class ValueChecker implements ConvergenceChecker {\n+\n+    public ValueChecker(double threshold) {\n+      this.threshold = threshold;\n+    }\n+\n+    public boolean converged(PointCostPair[] simplex) {\n+      PointCostPair smallest = simplex[0];\n+      PointCostPair largest  = simplex[simplex.length - 1];\n+      return (largest.cost - smallest.cost) < threshold;\n+    }\n+\n+    private double threshold;\n+\n+  };\n+\n+  public static Test suite() {\n+    return new TestSuite(MultiDirectionalTest.class);\n+  }\n+\n+  private int count;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.CostException;\n+import org.apache.commons.math.optimization.CostFunction;\n+import org.apache.commons.math.optimization.NelderMead;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.optimization.PointCostPair;\n+\n+import junit.framework.*;\n+\n+public class NelderMeadTest\n+  extends TestCase {\n+\n+  public NelderMeadTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testRosenbrock()\n+    throws CostException, ConvergenceException {\n+\n+    CostFunction rosenbrock =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[1] - x[0] * x[0];\n+          double b = 1.0 - x[0];\n+          return 100 * a * a + b * b;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new NelderMead().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),\n+                                 new double[] { -1.2,  1.0 },\n+                                 new double[] {  3.5, -2.3 });\n+\n+    assertTrue(count < 50);\n+    assertEquals(0.0, optimum.cost, 6.0e-4);\n+    assertEquals(1.0, optimum.point[0], 0.05);\n+    assertEquals(1.0, optimum.point[1], 0.05);\n+\n+  }\n+\n+  public void testPowell()\n+    throws CostException, ConvergenceException {\n+\n+    CostFunction powell =\n+      new CostFunction() {\n+        public double cost(double[] x) {\n+          ++count;\n+          double a = x[0] + 10 * x[1];\n+          double b = x[2] - x[3];\n+          double c = x[1] - 2 * x[2];\n+          double d = x[0] - x[3];\n+          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;\n+        }\n+      };\n+\n+    count = 0;\n+    PointCostPair optimum =\n+      new NelderMead().minimizes(powell, 200, new ValueChecker(1.0e-3),\n+                                 new double[] {  3.0, -1.0, 0.0, 1.0 },\n+                                 new double[] {  4.0,  0.0, 1.0, 2.0 });\n+    assertTrue(count < 150);\n+    assertEquals(0.0, optimum.cost, 6.0e-4);\n+    assertEquals(0.0, optimum.point[0], 0.07);\n+    assertEquals(0.0, optimum.point[1], 0.07);\n+    assertEquals(0.0, optimum.point[2], 0.07);\n+    assertEquals(0.0, optimum.point[3], 0.07);\n+\n+  }\n+\n+  private static class ValueChecker implements ConvergenceChecker {\n+\n+    public ValueChecker(double threshold) {\n+      this.threshold = threshold;\n+    }\n+\n+    public boolean converged(PointCostPair[] simplex) {\n+      PointCostPair smallest = simplex[0];\n+      PointCostPair largest  = simplex[simplex.length - 1];\n+      return (largest.cost - smallest.cost) < threshold;\n+    }\n+\n+    private double threshold;\n+\n+  };\n+\n+  public static Test suite() {\n+    return new TestSuite(NelderMeadTest.class);\n+  }\n+\n+  private int count;\n+\n+}", "timestamp": 1172607832, "metainfo": ""}