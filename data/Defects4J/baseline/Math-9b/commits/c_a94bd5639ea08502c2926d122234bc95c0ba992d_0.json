{"sha": "a94bd5639ea08502c2926d122234bc95c0ba992d", "log": "Merged LUDecomposition and LUDecompositionImpl (see MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/LUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecomposition.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n- * An interface to classes that implement an algorithm to calculate the\n- * LU-decomposition of a real matrix.\n- * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n- * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n- * to rearrange the rows of A before so that it can be decomposed. L is a lower\n- * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n- * <p>This interface is based on the class with similar name from the\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices L, U and\n+ * P that satisfy: P&times;A = L&times;U. L is lower triangular (with unit\n+ * diagonal terms), U is upper triangular and P is a permutation matrix. All\n+ * matrices are m&times;m.</p>\n+ * <p>As shown by the presence of the P matrix, this decomposition is\n+ * implemented using partial pivoting.</p>\n+ * <p>This class is based on the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n  * <ul>\n  *   <li>a {@link #getP() getP} method has been added,</li>\n- *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant()\n+ *   <li>the {@code det} method has been renamed as {@link #getDeterminant()\n  *   getDeterminant},</li>\n- *   <li>the <code>getDoublePivot</code> method has been removed (but the int based\n+ *   <li>the {@code getDoublePivot} method has been removed (but the int based\n  *   {@link #getPivot() getPivot} method has been kept),</li>\n- *   <li>the <code>solve</code> and <code>isNonSingular</code> methods have been replaced\n- *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n- *   the returned {@link DecompositionSolver}.</li>\n+ *   <li>the {@code solve} and {@code isNonSingular} methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods\n+ *   provided by the returned {@link DecompositionSolver}.</li>\n  * </ul>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n  * @version $Id$\n- * @since 2.0\n+ * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public interface LUDecomposition {\n+public class LUDecomposition {\n+    /** Default bound to determine effective singularity in LU decomposition. */\n+    private static final double DEFAULT_TOO_SMALL = 1e-11;\n+    /** Entries of LU decomposition. */\n+    private final double[][] lu;\n+    /** Pivot permutation associated with LU decomposition. */\n+    private final int[] pivot;\n+    /** Parity of the permutation associated with the LU decomposition. */\n+    private boolean even;\n+    /** Singularity indicator. */\n+    private boolean singular;\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix.\n+     * This constructor uses 1e-11 as default value for the singularity\n+     * threshold.\n+     *\n+     * @param matrix Matrix to decompose.\n+     * @throws NonSquareMatrixException if matrix is not square.\n+     */\n+    public LUDecomposition(RealMatrix matrix) {\n+        this(matrix, DEFAULT_TOO_SMALL);\n+    }\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @throws NonSquareMatrixException if matrix is not square\n+     */\n+    public LUDecomposition(RealMatrix matrix, double singularityThreshold) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getColumnDimension();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        even     = true;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final double[] luRow = lu[row];\n+                double sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = Double.NEGATIVE_INFINITY;\n+            for (int row = col; row < m; row++) {\n+                final double[] luRow = lu[row];\n+                double sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+\n+                // maintain best permutation choice\n+                if (FastMath.abs(sum) > largest) {\n+                    largest = FastMath.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (FastMath.abs(lu[max][col]) < singularityThreshold) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                final double[] luMax = lu[max];\n+                final double[] luCol = lu[col];\n+                for (int i = 0; i < m; i++) {\n+                    tmp = luMax[i];\n+                    luMax[i] = luCol[i];\n+                    luCol[i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                even = !even;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                lu[row][col] /= luDiag;\n+            }\n+        }\n+    }\n \n     /**\n      * Returns the matrix L of the decomposition.\n-     * <p>L is an lower-triangular matrix</p>\n+     * <p>L is a lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n      */\n-    RealMatrix getL();\n+    public RealMatrix getL() {\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedL = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final double[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, 1.0);\n+            }\n+        }\n+        return cachedL;\n+    }\n \n     /**\n      * Returns the matrix U of the decomposition.\n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n      */\n-    RealMatrix getU();\n+    public RealMatrix getU() {\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedU = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final double[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n+        }\n+        return cachedU;\n+    }\n \n     /**\n      * Returns the P rows permutation matrix.\n      * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n      * @see #getPivot()\n      */\n-    RealMatrix getP();\n+    public RealMatrix getP() {\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedP = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedP.setEntry(i, pivot[i], 1.0);\n+            }\n+        }\n+        return cachedP;\n+    }\n \n     /**\n      * Returns the pivot permutation vector.\n      * @return the pivot permutation vector\n      * @see #getP()\n      */\n-    int[] getPivot();\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n \n     /**\n      * Return the determinant of the matrix\n      * @return determinant of the matrix\n      */\n-    double getDeterminant();\n-\n-    /**\n-     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n+    public double getDeterminant() {\n+        if (singular) {\n+            return 0;\n+        } else {\n+            final int m = pivot.length;\n+            double determinant = even ? 1 : -1;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= lu[i][i];\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in exact linear\n+     * sense.\n      * @return a solver\n      */\n-    DecompositionSolver getSolver();\n-\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lu, pivot, singular);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Entries of LU decomposition. */\n+        private final double[][] lu;\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b) {\n+            final int m = pivot.length;\n+            if (b.getDimension() != m) {\n+                throw new DimensionMismatchException(b.getDimension(), m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] bp = new double[m];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b.getEntry(pivot[row]);\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final double bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] -= bpCol * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                final double bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bpCol * lu[i][col];\n+                }\n+            }\n+\n+            return new ArrayRealVector(bp, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            final double[][] bp = new double[m][nColB];\n+            for (int row = 0; row < m; row++) {\n+                final double[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final double[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final double[] bpCol = bp[col];\n+                final double luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] /= luDiag;\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowRealMatrix(bp, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUDecomposition;\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n         // Compute the covariances matrix.\n         final DecompositionSolver solver\n-            = new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj), threshold).getSolver();\n+            = new LUDecomposition(MatrixUtils.createRealMatrix(jTj), threshold).getSolver();\n         return solver.getInverse().getData();\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.DecompositionSolver;\n-import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.SingularMatrixException;\n                 // solve the linearized least squares problem\n                 RealMatrix mA = new BlockRealMatrix(a);\n                 DecompositionSolver solver = useLU ?\n-                        new LUDecompositionImpl(mA).getSolver() :\n+                        new LUDecomposition(mA).getSolver() :\n                         new QRDecompositionImpl(mA).getSolver();\n                 final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                 // update the estimated parameters\n--- a/src/main/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUDecomposition;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n      */\n     protected RealMatrix getOmegaInverse() {\n         if (OmegaInverse == null) {\n-            OmegaInverse = new LUDecompositionImpl(Omega).getSolver().getInverse();\n+            OmegaInverse = new LUDecomposition(Omega).getSolver().getInverse();\n         }\n         return OmegaInverse;\n     }\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XT = X.transpose();\n         RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n-        RealMatrix inverse = new LUDecompositionImpl(XTOIX).getSolver().getInverse();\n+        RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n         return inverse.multiply(XT).multiply(OI).operate(Y);\n     }\n \n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n-        return new LUDecompositionImpl(XTOIX).getSolver().getInverse();\n+        return new LUDecomposition(XTOIX).getSolver().getInverse();\n     }\n \n \n--- a/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n package org.apache.commons.math.stat.regression;\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUDecomposition;\n import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n     protected RealMatrix calculateBetaVariance() {\n         int p = X.getColumnDimension();\n         RealMatrix Raug = qr.getR().getSubMatrix(0, p - 1 , 0, p - 1);\n-        RealMatrix Rinv = new LUDecompositionImpl(Raug).getSolver().getInverse();\n+        RealMatrix Rinv = new LUDecomposition(Raug).getSolver().getInverse();\n         return Rinv.multiply(Rinv.transpose());\n     }\n \n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n     @Test\n     public void testTranspose() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n-        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n-        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = new Array2DRowRealMatrix(testData2);\n         RealMatrix mt = new Array2DRowRealMatrix(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n+        RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);\n         RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);\n-        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);\n         final double cst0 = constants.getEntry(0);\n         final double cst1 = constants.getEntry(1);\n         final double cst2 = constants.getEntry(2);\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n     @Test\n     public void testTranspose() {\n         RealMatrix m = new BlockRealMatrix(testData);\n-        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n-        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();\n         assertClose(mIT, mTI, normTolerance);\n         m = new BlockRealMatrix(testData2);\n         RealMatrix mt = new BlockRealMatrix(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n+        RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n         RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);\n-        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);\n         final double cst0 = constants.getEntry(0);\n         final double cst1 = constants.getEntry(1);\n         final double cst2 = constants.getEntry(2);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/LUDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class LUDecompositionTest {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] testDataMinus = {\n+            { -1.0, -2.0, -3.0},\n+            { -2.0, -5.0, -3.0},\n+            { -1.0,  0.0, -8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+\n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        LUDecomposition LU = new LUDecomposition(matrix);\n+        Assert.assertEquals(testData.length, LU.getL().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getRowDimension());\n+        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    @Test\n+    public void testNonSquare() {\n+        try {\n+            new LUDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));\n+            Assert.fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ime) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    @Test\n+    public void testPAEqualLU() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        LUDecomposition lu = new LUDecomposition(matrix);\n+        RealMatrix l = lu.getL();\n+        RealMatrix u = lu.getU();\n+        RealMatrix p = lu.getP();\n+        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealMatrix(testDataMinus);\n+        lu = new LUDecomposition(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealIdentityMatrix(17);\n+        lu = new LUDecomposition(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealMatrix(singular);\n+        lu = new LUDecomposition(matrix);\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n+\n+        matrix = MatrixUtils.createRealMatrix(bigSingular);\n+        lu = new LUDecomposition(matrix);\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        Assert.assertNull(lu.getL());\n+        Assert.assertNull(lu.getU());\n+        Assert.assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    @Test\n+    public void testLLowerTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix l = new LUDecomposition(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            Assert.assertEquals(l.getEntry(i, i), 1, entryTolerance);\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                Assert.assertEquals(l.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    @Test\n+    public void testUUpperTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix u = new LUDecomposition(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                Assert.assertEquals(u.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    @Test\n+    public void testPPermutation() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);\n+        RealMatrix p   = new LUDecomposition(matrix).getP();\n+\n+        RealMatrix ppT = p.multiply(p.transpose());\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());\n+        Assert.assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);\n+            Assert.assertEquals(1, oneCount);\n+            Assert.assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+    /** test singular */\n+    @Test\n+    public void testSingular() {\n+        LUDecomposition lu =\n+            new LUDecomposition(MatrixUtils.createRealMatrix(testData));\n+        Assert.assertTrue(lu.getSolver().isNonSingular());\n+        lu = new LUDecomposition(MatrixUtils.createRealMatrix(singular));\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+        lu = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular));\n+        Assert.assertFalse(lu.getSolver().isNonSingular());\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues1() {\n+       LUDecomposition lu =\n+            new LUDecomposition(MatrixUtils.createRealMatrix(testData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1.0, 0.0, 0.0 },\n+                { 0.5, 1.0, 0.0 },\n+                { 0.5, 0.2, 1.0 }\n+        });\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 2.0,  5.0, 3.0 },\n+                { 0.0, -2.5, 6.5 },\n+                { 0.0,  0.0, 0.2 }\n+        });\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 0.0, 0.0, 1.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 1, 2, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+\n+    }\n+\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues2() {\n+       LUDecomposition lu =\n+            new LUDecomposition(MatrixUtils.createRealMatrix(luData));\n+        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {\n+                {    1.0,    0.0, 0.0 },\n+                {    0.0,    1.0, 0.0 },\n+                { 1.0 / 3.0, 0.0, 1.0 }\n+        });\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 6.0, 9.0,    8.0    },\n+                { 0.0, 5.0,    7.0    },\n+                { 0.0, 0.0, 1.0 / 3.0 }\n+        });\n+        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 2, 1, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            Assert.assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(l == lu.getL());\n+        Assert.assertTrue(u == lu.getU());\n+        Assert.assertTrue(p == lu.getP());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n                                                        { 2.0, 5.0, 3.0},\n                                                        { 4.000001, 9.0, 9.0}\n                                                      });\n-        Assert.assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());\n-        Assert.assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());\n+        Assert.assertFalse(new LUDecomposition(matrix, 1.0e-5).getSolver().isNonSingular());\n+        Assert.assertTrue(new LUDecomposition(matrix, 1.0e-10).getSolver().isNonSingular());\n     }\n \n     /** test singular */\n     @Test\n     public void testSingular() {\n         DecompositionSolver solver =\n-            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+            new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();\n         Assert.assertTrue(solver.isNonSingular());\n-        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n+        solver = new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();\n         Assert.assertFalse(solver.isNonSingular());\n-        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();\n+        solver = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular)).getSolver();\n         Assert.assertFalse(solver.isNonSingular());\n     }\n \n     @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n-            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+            new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n     @Test\n     public void testSolveSingularityErrors() {\n         DecompositionSolver solver =\n-            new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();\n+            new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n     @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n-            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();\n+            new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1, 0 }, { 2, -5 }, { 3, 1 }\n         });\n     }\n \n     private double getDeterminant(RealMatrix m) {\n-        return new LUDecompositionImpl(m).getDeterminant();\n+        return new LUDecomposition(m).getDeterminant();\n     }\n }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n     @Test\n     public void testTranspose() {\n         RealMatrix m = createSparseMatrix(testData);\n-        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n-        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse();\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = createSparseMatrix(testData2);\n         RealMatrix mt = createSparseMatrix(testData2T);\n         Assert.assertEquals(2, p.getRowDimension());\n         Assert.assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n+        RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse();\n         Assert.assertEquals(2, pInverse.getRowDimension());\n         Assert.assertEquals(2, pInverse.getColumnDimension());\n \n                 { 4, -3, -5 } };\n         RealMatrix coefficients = createSparseMatrix(coefficientsData);\n         RealVector constants = new ArrayRealVector(new double[]{ 1, -2, 1 }, false);\n-        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants);\n         final double cst0 = constants.getEntry(0);\n         final double cst1 = constants.getEntry(1);\n         final double cst2 = constants.getEntry(2);", "timestamp": 1316838516, "metainfo": ""}