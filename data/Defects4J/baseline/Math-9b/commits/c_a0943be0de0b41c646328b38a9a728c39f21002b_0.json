{"sha": "a0943be0de0b41c646328b38a9a728c39f21002b", "log": "tighten rules for constants naming conventions  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n    */\n   @Override\n   public Object[][] getContents() {\n-    return contents.clone();\n+    return CONTENTS.clone();\n   }\n \n   /** Non-translated/translated messages arrays. */\n-  private static final Object[][] contents = {\n+  private static final Object[][] CONTENTS = {\n \n     // org.apache.commons.math.util.MathUtils\n     { \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n \n     /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n     public static final Complex I = new Complex(0.0, 1.0);\n-    \n+\n+    // CHECKSTYLE: stop ConstantName\n     /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n+    // CHECKSTYLE: resume ConstantName\n \n     /** A complex number representing \"+INF + INFi\" */\n     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n   /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n   public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n \n+  // CHECKSTYLE: stop ConstantName\n   /** A vector with all coordinates set to NaN. */\n   public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+  // CHECKSTYLE: resume ConstantName\n \n   /** A vector with all coordinates set to positive infinity. */\n   public static final Vector3D POSITIVE_INFINITY =\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n public class AdamsNordsieckTransformer {\n \n     /** Cache for already computed coefficients. */\n-    private static final Map<Integer, AdamsNordsieckTransformer> cache =\n+    private static final Map<Integer, AdamsNordsieckTransformer> CACHE =\n         new HashMap<Integer, AdamsNordsieckTransformer>();\n \n     /** Initialization matrix for the higher order derivatives wrt y'', y''' ... */\n      * @return Nordsieck transformer for the specified number of steps\n      */\n     public static AdamsNordsieckTransformer getInstance(final int nSteps) {\n-        synchronized(cache) {\n-            AdamsNordsieckTransformer t = cache.get(nSteps);\n+        synchronized(CACHE) {\n+            AdamsNordsieckTransformer t = CACHE.get(nSteps);\n             if (t == null) {\n                 t = new AdamsNordsieckTransformer(nSteps);\n-                cache.put(nSteps, t);\n+                CACHE.put(nSteps, t);\n             }\n             return t;\n         }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n public class ClassicalRungeKuttaIntegrator extends RungeKuttaIntegrator {\n \n   /** Time steps Butcher array. */\n-  private static final double[] c = {\n+  private static final double[] STATIC_C = {\n     1.0 / 2.0, 1.0 / 2.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] a = {\n+  private static final double[][] STATIC_A = {\n     { 1.0 / 2.0 },\n     { 0.0, 1.0 / 2.0 },\n     { 0.0, 0.0, 1.0 }\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] b = {\n+  private static final double[] STATIC_B = {\n     1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n   };\n \n    * @param step integration step\n    */\n   public ClassicalRungeKuttaIntegrator(final double step) {\n-    super(\"classical Runge-Kutta\", c, a, b,\n+    super(\"classical Runge-Kutta\", STATIC_C, STATIC_A, STATIC_B,\n           new ClassicalRungeKuttaStepInterpolator(), step);\n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n   private static final String METHOD_NAME = \"Dormand-Prince 5(4)\";\n \n   /** Time steps Butcher array. */\n-  private static final double[] staticC = {\n+  private static final double[] STATIC_C = {\n     1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] staticA = {\n+  private static final double[][] STATIC_A = {\n     {1.0/5.0},\n     {3.0/40.0, 9.0/40.0},\n     {44.0/45.0, -56.0/15.0, 32.0/9.0},\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] staticB = {\n+  private static final double[] STATIC_B = {\n     35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n   };\n \n   /** Error array, element 1. */\n-  private static final double e1 =     71.0 / 57600.0;\n+  private static final double E1 =     71.0 / 57600.0;\n \n   // element 2 is zero, so it is neither stored nor used\n \n   /** Error array, element 3. */\n-  private static final double e3 =    -71.0 / 16695.0;\n+  private static final double E3 =    -71.0 / 16695.0;\n \n   /** Error array, element 4. */\n-  private static final double e4 =     71.0 / 1920.0;\n+  private static final double E4 =     71.0 / 1920.0;\n \n   /** Error array, element 5. */\n-  private static final double e5 = -17253.0 / 339200.0;\n+  private static final double E5 = -17253.0 / 339200.0;\n \n   /** Error array, element 6. */\n-  private static final double e6 =     22.0 / 525.0;\n+  private static final double E6 =     22.0 / 525.0;\n \n   /** Error array, element 7. */\n-  private static final double e7 =     -1.0 / 40.0;\n+  private static final double E7 =     -1.0 / 40.0;\n \n   /** Simple constructor.\n    * Build a fifth order Dormand-Prince integrator with the given step bounds\n   public DormandPrince54Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n-    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public DormandPrince54Integrator(final double minStep, final double maxStep,\n                                    final double[] vecAbsoluteTolerance,\n                                    final double[] vecRelativeTolerance) {\n-    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n \n     double error = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +\n-                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +\n-                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+        final double errSum = E1 * yDotK[0][j] +  E3 * yDotK[2][j] +\n+                              E4 * yDotK[3][j] +  E5 * yDotK[4][j] +\n+                              E6 * yDotK[5][j] +  E7 * yDotK[6][j];\n \n         final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n         final double tol = (vecAbsoluteTolerance == null) ?\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n           final double yDot4 = yDotK[4][i];\n           final double yDot5 = yDotK[5][i];\n           final double yDot6 = yDotK[6][i];\n-          v1[i] = a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5;\n+          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n           v2[i] = yDot0 - v1[i];\n           v3[i] = v1[i] - v2[i] - yDot6;\n-          v4[i] = d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6;\n+          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n       }\n \n       vectorsInitialized = true;\n   private boolean vectorsInitialized;\n \n   /** Last row of the Butcher-array internal weights, element 0. */\n-  private static final double a70 =    35.0 /  384.0;\n+  private static final double A70 =    35.0 /  384.0;\n \n   // element 1 is zero, so it is neither stored nor used\n \n   /** Last row of the Butcher-array internal weights, element 2. */\n-  private static final double a72 =   500.0 / 1113.0;\n+  private static final double A72 =   500.0 / 1113.0;\n \n   /** Last row of the Butcher-array internal weights, element 3. */\n-  private static final double a73 =   125.0 /  192.0;\n+  private static final double A73 =   125.0 /  192.0;\n \n   /** Last row of the Butcher-array internal weights, element 4. */\n-  private static final double a74 = -2187.0 / 6784.0;\n+  private static final double A74 = -2187.0 / 6784.0;\n \n   /** Last row of the Butcher-array internal weights, element 5. */\n-  private static final double a75 =    11.0 /   84.0;\n+  private static final double A75 =    11.0 /   84.0;\n \n   /** Shampine (1986) Dense output, element 0. */\n-  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+  private static final double D0 =  -12715105075.0 /  11282082432.0;\n \n   // element 1 is zero, so it is neither stored nor used\n \n   /** Shampine (1986) Dense output, element 2. */\n-  private static final double d2 =   87487479700.0 /  32700410799.0;\n+  private static final double D2 =   87487479700.0 /  32700410799.0;\n \n   /** Shampine (1986) Dense output, element 3. */\n-  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+  private static final double D3 =  -10690763975.0 /   1880347072.0;\n \n   /** Shampine (1986) Dense output, element 4. */\n-  private static final double d4 =  701980252875.0 / 199316789632.0;\n+  private static final double D4 =  701980252875.0 / 199316789632.0;\n \n   /** Shampine (1986) Dense output, element 5. */\n-  private static final double d5 =   -1453857185.0 /    822651844.0;\n+  private static final double D5 =   -1453857185.0 /    822651844.0;\n \n   /** Shampine (1986) Dense output, element 6. */\n-  private static final double d6 =      69997945.0 /     29380423.0;\n+  private static final double D6 =      69997945.0 /     29380423.0;\n \n   /** Serializable version identifier */\n   private static final long serialVersionUID = 4104157279605906956L;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n   private static final String METHOD_NAME = \"Dormand-Prince 8 (5, 3)\";\n \n   /** Time steps Butcher array. */\n-  private static final double[] staticC = {\n+  private static final double[] STATIC_C = {\n     (12.0 - 2.0 * Math.sqrt(6.0)) / 135.0, (6.0 - Math.sqrt(6.0)) / 45.0, (6.0 - Math.sqrt(6.0)) / 30.0,\n     (6.0 + Math.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n     6.0/7.0, 1.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] staticA = {\n+  private static final double[][] STATIC_A = {\n \n     // k2\n     {(12.0 - 2.0 * Math.sqrt(6.0)) / 135.0},\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] staticB = {\n+  private static final double[] STATIC_B = {\n       104257.0/1920240.0,\n       0.0,\n       0.0,\n   };\n \n   /** First error weights array, element 1. */\n-  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+  private static final double E1_01 =         116092271.0 / 8848465920.0;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** First error weights array, element 6. */\n-  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+  private static final double E1_06 =          -1871647.0 / 1527680.0;\n \n   /** First error weights array, element 7. */\n-  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+  private static final double E1_07 =         -69799717.0 / 140793660.0;\n \n   /** First error weights array, element 8. */\n-  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+  private static final double E1_08 =     1230164450203.0 / 739113984000.0;\n \n   /** First error weights array, element 9. */\n-  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+  private static final double E1_09 = -1980813971228885.0 / 5654156025964544.0;\n \n   /** First error weights array, element 10. */\n-  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+  private static final double E1_10 =         464500805.0 / 1389975552.0;\n \n   /** First error weights array, element 11. */\n-  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+  private static final double E1_11 =     1606764981773.0 / 19613062656000.0;\n \n   /** First error weights array, element 12. */\n-  private static final double e1_12 =           -137909.0 / 6168960.0;\n+  private static final double E1_12 =           -137909.0 / 6168960.0;\n \n \n   /** Second error weights array, element 1. */\n-  private static final double e2_01 =           -364463.0 / 1920240.0;\n+  private static final double E2_01 =           -364463.0 / 1920240.0;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** Second error weights array, element 6. */\n-  private static final double e2_06 =           3399327.0 / 763840.0;\n+  private static final double E2_06 =           3399327.0 / 763840.0;\n \n   /** Second error weights array, element 7. */\n-  private static final double e2_07 =          66578432.0 / 35198415.0;\n+  private static final double E2_07 =          66578432.0 / 35198415.0;\n \n   /** Second error weights array, element 8. */\n-  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+  private static final double E2_08 =       -1674902723.0 / 288716400.0;\n \n   /** Second error weights array, element 9. */\n-  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+  private static final double E2_09 =   -74684743568175.0 / 176692375811392.0;\n \n   /** Second error weights array, element 10. */\n-  private static final double e2_10 =           -734375.0 / 4826304.0;\n+  private static final double E2_10 =           -734375.0 / 4826304.0;\n \n   /** Second error weights array, element 11. */\n-  private static final double e2_11 =         171414593.0 / 851261400.0;\n+  private static final double E2_11 =         171414593.0 / 851261400.0;\n \n   /** Second error weights array, element 12. */\n-  private static final double e2_12 =             69869.0 / 3084480.0;\n+  private static final double E2_12 =             69869.0 / 3084480.0;\n \n   /** Simple constructor.\n    * Build an eighth order Dormand-Prince integrator with the given step bounds\n   public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                     final double scalAbsoluteTolerance,\n                                     final double scalRelativeTolerance) {\n-    super(METHOD_NAME, true, staticC, staticA, staticB,\n+    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n   public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                     final double[] vecAbsoluteTolerance,\n                                     final double[] vecRelativeTolerance) {\n-    super(METHOD_NAME, true, staticC, staticA, staticB,\n+    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n     double error2 = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-      final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +\n-                             e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +\n-                             e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +\n-                             e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n-      final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +\n-                             e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +\n-                             e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +\n-                             e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\n+                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\n+                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\n+                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\n+      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\n+                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\n+                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\n+                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n \n       final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n       final double tol = (vecAbsoluteTolerance == null) ?\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n           final double yDot14 = yDotKLast[0][i];\n           final double yDot15 = yDotKLast[1][i];\n           final double yDot16 = yDotKLast[2][i];\n-          v[0][i] = b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +\n-                    b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +\n-                    b_11 * yDot11 + b_12 * yDot12;\n+          v[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\n+                    B_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\n+                    B_11 * yDot11 + B_12 * yDot12;\n           v[1][i] = yDot1 - v[0][i];\n           v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n-          for (int k = 0; k < d.length; ++k) {\n-              v[k+3][i] = d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +\n-                          d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +\n-                          d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +\n-                          d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16;\n+          for (int k = 0; k < D.length; ++k) {\n+              v[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\n+                          D[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\n+                          D[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\n+                          D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n           }\n       }\n \n \n     // k14\n     for (int j = 0; j < currentState.length; ++j) {\n-      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j] +\n-          k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j] +\n-          k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n+          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n+          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+    integrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\n \n     // k15\n     for (int j = 0; j < currentState.length; ++j) {\n-     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j] +\n-         k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j] +\n-         k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j] +\n-         k15_14 * yDotKLast[0][j];\n+     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n+         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n+         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n+         K15_14 * yDotKLast[0][j];\n      yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+    integrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\n \n     // k16\n     for (int j = 0; j < currentState.length; ++j) {\n-      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j] +\n-          k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j] +\n-          k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j] +\n-          k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n+          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n+          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n+          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n       yTmp[j] = currentState[j] + h * s;\n     }\n-    integrator.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+    integrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n \n   }\n \n   private boolean vectorsInitialized;\n \n   /** Propagation weights, element 1. */\n-  private static final double b_01 =         104257.0 / 1920240.0;\n+  private static final double B_01 =         104257.0 / 1920240.0;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** Propagation weights, element 6. */\n-  private static final double b_06 =        3399327.0 / 763840.0;\n+  private static final double B_06 =        3399327.0 / 763840.0;\n \n   /** Propagation weights, element 7. */\n-  private static final double b_07 =       66578432.0 / 35198415.0;\n+  private static final double B_07 =       66578432.0 / 35198415.0;\n \n   /** Propagation weights, element 8. */\n-  private static final double b_08 =    -1674902723.0 / 288716400.0;\n+  private static final double B_08 =    -1674902723.0 / 288716400.0;\n \n   /** Propagation weights, element 9. */\n-  private static final double b_09 = 54980371265625.0 / 176692375811392.0;\n+  private static final double B_09 = 54980371265625.0 / 176692375811392.0;\n \n   /** Propagation weights, element 10. */\n-  private static final double b_10 =        -734375.0 / 4826304.0;\n+  private static final double B_10 =        -734375.0 / 4826304.0;\n \n   /** Propagation weights, element 11. */\n-  private static final double b_11 =      171414593.0 / 851261400.0;\n+  private static final double B_11 =      171414593.0 / 851261400.0;\n \n   /** Propagation weights, element 12. */\n-  private static final double b_12 =         137909.0 / 3084480.0;\n+  private static final double B_12 =         137909.0 / 3084480.0;\n \n   /** Time step for stage 14 (interpolation only). */\n-  private static final double c14    = 1.0 / 10.0;\n+  private static final double C14    = 1.0 / 10.0;\n \n   /** Internal weights for stage 14, element 1. */\n-  private static final double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+  private static final double K14_01 =       13481885573.0 / 240030000000.0      - B_01;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** Internal weights for stage 14, element 6. */\n-  private static final double k14_06 =                 0.0                       - b_06;\n+  private static final double K14_06 =                 0.0                       - B_06;\n \n   /** Internal weights for stage 14, element 7. */\n-  private static final double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+  private static final double K14_07 =      139418837528.0 / 549975234375.0      - B_07;\n \n   /** Internal weights for stage 14, element 8. */\n-  private static final double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+  private static final double K14_08 =   -11108320068443.0 / 45111937500000.0    - B_08;\n \n   /** Internal weights for stage 14, element 9. */\n-  private static final double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+  private static final double K14_09 = -1769651421925959.0 / 14249385146080000.0 - B_09;\n \n   /** Internal weights for stage 14, element 10. */\n-  private static final double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+  private static final double K14_10 =          57799439.0 / 377055000.0         - B_10;\n \n   /** Internal weights for stage 14, element 11. */\n-  private static final double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+  private static final double K14_11 =      793322643029.0 / 96734250000000.0    - B_11;\n \n   /** Internal weights for stage 14, element 12. */\n-  private static final double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+  private static final double K14_12 =        1458939311.0 / 192780000000.0      - B_12;\n \n   /** Internal weights for stage 14, element 13. */\n-  private static final double k14_13 =             -4149.0 / 500000.0;\n+  private static final double K14_13 =             -4149.0 / 500000.0;\n \n   /** Time step for stage 15 (interpolation only). */\n-  private static final double c15    = 1.0 / 5.0;\n+  private static final double C15    = 1.0 / 5.0;\n \n \n   /** Internal weights for stage 15, element 1. */\n-  private static final double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+  private static final double K15_01 =     1595561272731.0 / 50120273500000.0    - B_01;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** Internal weights for stage 15, element 6. */\n-  private static final double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+  private static final double K15_06 =      975183916491.0 / 34457688031250.0    - B_06;\n \n   /** Internal weights for stage 15, element 7. */\n-  private static final double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+  private static final double K15_07 =    38492013932672.0 / 718912673015625.0   - B_07;\n \n   /** Internal weights for stage 15, element 8. */\n-  private static final double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+  private static final double K15_08 = -1114881286517557.0 / 20298710767500000.0 - B_08;\n \n   /** Internal weights for stage 15, element 9. */\n-  private static final double k15_09 =                 0.0                       - b_09;\n+  private static final double K15_09 =                 0.0                       - B_09;\n \n   /** Internal weights for stage 15, element 10. */\n-  private static final double k15_10 =                 0.0                       - b_10;\n+  private static final double K15_10 =                 0.0                       - B_10;\n \n   /** Internal weights for stage 15, element 11. */\n-  private static final double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+  private static final double K15_11 =    -2538710946863.0 / 23431227861250000.0 - B_11;\n \n   /** Internal weights for stage 15, element 12. */\n-  private static final double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+  private static final double K15_12 =        8824659001.0 / 23066716781250.0    - B_12;\n \n   /** Internal weights for stage 15, element 13. */\n-  private static final double k15_13 =      -11518334563.0 / 33831184612500.0;\n+  private static final double K15_13 =      -11518334563.0 / 33831184612500.0;\n \n   /** Internal weights for stage 15, element 14. */\n-  private static final double k15_14 =        1912306948.0 / 13532473845.0;\n+  private static final double K15_14 =        1912306948.0 / 13532473845.0;\n \n   /** Time step for stage 16 (interpolation only). */\n-  private static final double c16    = 7.0 / 9.0;\n+  private static final double C16    = 7.0 / 9.0;\n \n \n   /** Internal weights for stage 16, element 1. */\n-  private static final double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+  private static final double K16_01 =      -13613986967.0 / 31741908048.0       - B_01;\n \n   // elements 2 to 5 are zero, so they are neither stored nor used\n \n   /** Internal weights for stage 16, element 6. */\n-  private static final double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+  private static final double K16_06 =       -4755612631.0 / 1012344804.0        - B_06;\n \n   /** Internal weights for stage 16, element 7. */\n-  private static final double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+  private static final double K16_07 =    42939257944576.0 / 5588559685701.0     - B_07;\n \n   /** Internal weights for stage 16, element 8. */\n-  private static final double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+  private static final double K16_08 =    77881972900277.0 / 19140370552944.0    - B_08;\n \n   /** Internal weights for stage 16, element 9. */\n-  private static final double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+  private static final double K16_09 =    22719829234375.0 / 63689648654052.0    - B_09;\n \n   /** Internal weights for stage 16, element 10. */\n-  private static final double k16_10 =                 0.0                       - b_10;\n+  private static final double K16_10 =                 0.0                       - B_10;\n \n   /** Internal weights for stage 16, element 11. */\n-  private static final double k16_11 =                 0.0                       - b_11;\n+  private static final double K16_11 =                 0.0                       - B_11;\n \n   /** Internal weights for stage 16, element 12. */\n-  private static final double k16_12 =                 0.0                       - b_12;\n+  private static final double K16_12 =                 0.0                       - B_12;\n \n   /** Internal weights for stage 16, element 13. */\n-  private static final double k16_13 =       -1199007803.0 / 857031517296.0;\n+  private static final double K16_13 =       -1199007803.0 / 857031517296.0;\n \n   /** Internal weights for stage 16, element 14. */\n-  private static final double k16_14 =      157882067000.0 / 53564469831.0;\n+  private static final double K16_14 =      157882067000.0 / 53564469831.0;\n \n   /** Internal weights for stage 16, element 15. */\n-  private static final double k16_15 =     -290468882375.0 / 31741908048.0;\n+  private static final double K16_15 =     -290468882375.0 / 31741908048.0;\n \n   /** Interpolation weights.\n    * (beware that only the non-null values are in the table)\n    */\n-  private static final double[][] d = {\n+  private static final double[][] D = {\n \n     {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n             -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n public class EulerIntegrator extends RungeKuttaIntegrator {\n \n   /** Time steps Butcher array. */\n-  private static final double[] c = {\n+  private static final double[] STATIC_C = {\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] a = {\n+  private static final double[][] STATIC_A = {\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] b = {\n+  private static final double[] STATIC_B = {\n     1.0\n   };\n \n    * @param step integration step\n    */\n   public EulerIntegrator(final double step) {\n-    super(\"Euler\", c, a, b, new EulerStepInterpolator(), step);\n+    super(\"Euler\", STATIC_C, STATIC_A, STATIC_B, new EulerStepInterpolator(), step);\n   }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n public class GillIntegrator extends RungeKuttaIntegrator {\n \n   /** Time steps Butcher array. */\n-  private static final double[] c = {\n+  private static final double[] STATIC_C = {\n     1.0 / 2.0, 1.0 / 2.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] a = {\n+  private static final double[][] STATIC_A = {\n     { 1.0 / 2.0 },\n     { (Math.sqrt(2.0) - 1.0) / 2.0, (2.0 - Math.sqrt(2.0)) / 2.0 },\n     { 0.0, -Math.sqrt(2.0) / 2.0, (2.0 + Math.sqrt(2.0)) / 2.0 }\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] b = {\n+  private static final double[] STATIC_B = {\n     1.0 / 6.0, (2.0 - Math.sqrt(2.0)) / 6.0, (2.0 + Math.sqrt(2.0)) / 6.0, 1.0 / 6.0\n   };\n \n    * @param step integration step\n    */\n   public GillIntegrator(final double step) {\n-    super(\"Gill\", c, a, b, new GillStepInterpolator(), step);\n+    super(\"Gill\", STATIC_C, STATIC_A, STATIC_B, new GillStepInterpolator(), step);\n   }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n     final double soMt      = s * oMt;\n     final double c23       = soMt * (1 + twoTheta);\n     final double coeff1    = soMt * (1 - fourTheta);\n-    final double coeff2    = c23  * tMq;\n-    final double coeff3    = c23  * tPq;\n+    final double coeff2    = c23  * TWO_MINUS_SQRT_2;\n+    final double coeff3    = c23  * TWO_PLUS_SQRT_2;\n     final double coeff4    = s * (1 + theta * (1 + fourTheta));\n     final double coeffDot1 = theta * (twoTheta - 3) + 1;\n     final double cDot23    = theta * oMt;\n-    final double coeffDot2 = cDot23  * tMq;\n-    final double coeffDot3 = cDot23  * tPq;\n+    final double coeffDot2 = cDot23  * TWO_MINUS_SQRT_2;\n+    final double coeffDot3 = cDot23  * TWO_PLUS_SQRT_2;\n     final double coeffDot4 = theta * (twoTheta - 1);\n \n     for (int i = 0; i < interpolatedState.length; ++i) {\n   }\n \n   /** First Gill coefficient. */\n-  private static final double tMq = 2 - Math.sqrt(2.0);\n+  private static final double TWO_MINUS_SQRT_2 = 2 - Math.sqrt(2.0);\n \n   /** Second Gill coefficient. */\n-  private static final double tPq = 2 + Math.sqrt(2.0);\n+  private static final double TWO_PLUS_SQRT_2 = 2 + Math.sqrt(2.0);\n \n   /** Serializable version identifier */\n   private static final long serialVersionUID = -107804074496313322L;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n   private static final String METHOD_NAME = \"Higham-Hall 5(4)\";\n \n   /** Time steps Butcher array. */\n-  private static final double[] staticC = {\n+  private static final double[] STATIC_C = {\n     2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] staticA = {\n+  private static final double[][] STATIC_A = {\n     {2.0/9.0},\n     {1.0/12.0, 1.0/4.0},\n     {1.0/8.0, 0.0, 3.0/8.0},\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] staticB = {\n+  private static final double[] STATIC_B = {\n     1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n   };\n \n   /** Error weights Butcher array. */\n-  private static final double[] staticE = {\n+  private static final double[] STATIC_E = {\n     -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n   };\n \n   public HighamHall54Integrator(final double minStep, final double maxStep,\n                                 final double scalAbsoluteTolerance,\n                                 final double scalRelativeTolerance) {\n-    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+    super(METHOD_NAME, false, STATIC_C, STATIC_A, STATIC_B, new HighamHall54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public HighamHall54Integrator(final double minStep, final double maxStep,\n                                 final double[] vecAbsoluteTolerance,\n                                 final double[] vecRelativeTolerance) {\n-    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+    super(METHOD_NAME, false, STATIC_C, STATIC_A, STATIC_B, new HighamHall54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n   }\n \n     double error = 0;\n \n     for (int j = 0; j < y0.length; ++j) {\n-      double errSum = staticE[0] * yDotK[0][j];\n-      for (int l = 1; l < staticE.length; ++l) {\n-        errSum += staticE[l] * yDotK[l][j];\n+      double errSum = STATIC_E[0] * yDotK[0][j];\n+      for (int l = 1; l < STATIC_E.length; ++l) {\n+        errSum += STATIC_E[l] * yDotK[l][j];\n       }\n \n       final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n public class MidpointIntegrator extends RungeKuttaIntegrator {\n \n   /** Time steps Butcher array. */\n-  private static final double[] c = {\n+  private static final double[] STATIC_C = {\n     1.0 / 2.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] a = {\n+  private static final double[][] STATIC_A = {\n     { 1.0 / 2.0 }\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] b = {\n+  private static final double[] STATIC_B = {\n     0.0, 1.0\n   };\n \n    * @param step integration step\n    */\n   public MidpointIntegrator(final double step) {\n-    super(\"midpoint\", c, a, b, new MidpointStepInterpolator(), step);\n+    super(\"midpoint\", STATIC_C, STATIC_A, STATIC_B, new MidpointStepInterpolator(), step);\n   }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n public class ThreeEighthesIntegrator extends RungeKuttaIntegrator {\n \n   /** Time steps Butcher array. */\n-  private static final double[] c = {\n+  private static final double[] STATIC_C = {\n     1.0 / 3.0, 2.0 / 3.0, 1.0\n   };\n \n   /** Internal weights Butcher array. */\n-  private static final double[][] a = {\n+  private static final double[][] STATIC_A = {\n     {  1.0 / 3.0 },\n     { -1.0 / 3.0, 1.0 },\n     {  1.0, -1.0, 1.0 }\n   };\n \n   /** Propagation weights Butcher array. */\n-  private static final double[] b = {\n+  private static final double[] STATIC_B = {\n     1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n   };\n \n    * @param step integration step\n    */\n   public ThreeEighthesIntegrator(final double step) {\n-    super(\"3/8\", c, a, b, new ThreeEighthesStepInterpolator(), step);\n+    super(\"3/8\", STATIC_C, STATIC_A, STATIC_B, new ThreeEighthesStepInterpolator(), step);\n   }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n    * @return the only instance\n    */\n   public static DummyStepHandler getInstance() {\n-    return instance;\n+    return INSTANCE;\n   }\n \n   /** Determines whether this handler needs dense output.\n   }\n \n   /** The only instance. */\n-  private static final DummyStepHandler instance = new DummyStepHandler();\n+  private static final DummyStepHandler INSTANCE = new DummyStepHandler();\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n     /**\n      * Golden section.\n      */\n-    private static final double c = 0.5 * (3 - Math.sqrt(5));\n+    private static final double GOLDEN_SECTION = 0.5 * (3 - Math.sqrt(5));\n \n     /**\n      * Construct a solver.\n     private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n                             double a, double b, final double eps, final double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        double x = a + c * (b - a);\n+        double x = a + GOLDEN_SECTION * (b - a);\n         double v = x;\n         double w = x;\n         double e = 0;\n                     }\n                 } else { // Golden section step.\n                     e = ((x < m) ? b : a) - x;\n-                    d = c * e;\n+                    d = GOLDEN_SECTION * e;\n                 }\n \n                 // f must not be evaluated too close to a or b.\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n     private static final double DEFAULT_EPSILON = 10e-15;\n \n     /** Lanczos coefficients */\n-    private static final double[] lanczos =\n+    private static final double[] LANCZOS =\n     {\n         0.99999999999999709182,\n         57.156235665862923517,\n             double g = 607.0 / 128.0;\n             \n             double sum = 0.0;\n-            for (int i = lanczos.length - 1; i > 0; --i) {\n-                sum = sum + (lanczos[i] / (x + i));\n+            for (int i = LANCZOS.length - 1; i > 0; --i) {\n+                sum = sum + (LANCZOS[i] / (x + i));\n             }\n-            sum = sum + lanczos[0];\n+            sum = sum + LANCZOS[0];\n \n             double tmp = x + g + .5;\n             ret = ((x + .5) * Math.log(tmp)) - tmp +\n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n public final class StatUtils {\n \n     /** sum */\n-    private static final UnivariateStatistic sum = new Sum();\n+    private static final UnivariateStatistic SUM = new Sum();\n \n     /** sumSq */\n-    private static final UnivariateStatistic sumSq = new SumOfSquares();\n+    private static final UnivariateStatistic SUM_OF_SQUARES = new SumOfSquares();\n \n     /** prod */\n-    private static final UnivariateStatistic prod = new Product();\n+    private static final UnivariateStatistic PRODUCT = new Product();\n \n     /** sumLog */\n-    private static final UnivariateStatistic sumLog = new SumOfLogs();\n+    private static final UnivariateStatistic SUM_OF_LOGS = new SumOfLogs();\n \n     /** min */\n-    private static final UnivariateStatistic min = new Min();\n+    private static final UnivariateStatistic MIN = new Min();\n \n     /** max */\n-    private static final UnivariateStatistic max = new Max();\n+    private static final UnivariateStatistic MAX = new Max();\n \n     /** mean */\n-    private static final UnivariateStatistic mean = new Mean();\n+    private static final UnivariateStatistic MEAN = new Mean();\n \n     /** variance */\n-    private static final Variance variance = new Variance();\n+    private static final Variance VARIANCE = new Variance();\n \n     /** percentile */\n-    private static final Percentile percentile = new Percentile();\n+    private static final Percentile PERCENTILE = new Percentile();\n     \n     /** geometric mean */\n-    private static final GeometricMean geometricMean = new GeometricMean();\n+    private static final GeometricMean GEOMETRIC_MEAN = new GeometricMean();\n \n     /**\n      * Private Constructor\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double sum(final double[] values) {\n-        return sum.evaluate(values);\n+        return SUM.evaluate(values);\n     }\n \n     /**\n      */\n     public static double sum(final double[] values, final int begin, \n             final int length) {\n-        return sum.evaluate(values, begin, length);\n+        return SUM.evaluate(values, begin, length);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double sumSq(final double[] values) {\n-        return sumSq.evaluate(values);\n+        return SUM_OF_SQUARES.evaluate(values);\n     }\n \n     /**\n      */\n     public static double sumSq(final double[] values, final int begin,\n             final int length) {\n-        return sumSq.evaluate(values, begin, length);\n+        return SUM_OF_SQUARES.evaluate(values, begin, length);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double product(final double[] values) {\n-        return prod.evaluate(values);\n+        return PRODUCT.evaluate(values);\n     }\n \n     /**\n      */\n     public static double product(final double[] values, final int begin,\n             final int length) {\n-        return prod.evaluate(values, begin, length);\n+        return PRODUCT.evaluate(values, begin, length);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double sumLog(final double[] values) {\n-        return sumLog.evaluate(values);\n+        return SUM_OF_LOGS.evaluate(values);\n     }\n \n     /**\n      */\n     public static double sumLog(final double[] values, final int begin,\n             final int length) {\n-        return sumLog.evaluate(values, begin, length);\n+        return SUM_OF_LOGS.evaluate(values, begin, length);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double mean(final double[] values) {\n-        return mean.evaluate(values);\n+        return MEAN.evaluate(values);\n     }\n \n     /**\n      */\n     public static double mean(final double[] values, final int begin,\n             final int length) {\n-        return mean.evaluate(values, begin, length);\n+        return MEAN.evaluate(values, begin, length);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double geometricMean(final double[] values) {\n-        return geometricMean.evaluate(values);\n+        return GEOMETRIC_MEAN.evaluate(values);\n     }\n \n     /**\n      */\n     public static double geometricMean(final double[] values, final int begin,\n             final int length) {\n-        return geometricMean.evaluate(values, begin, length);\n+        return GEOMETRIC_MEAN.evaluate(values, begin, length);\n     }\n     \n \n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double variance(final double[] values) {\n-        return variance.evaluate(values);\n+        return VARIANCE.evaluate(values);\n     }\n \n     /**\n      */\n     public static double variance(final double[] values, final int begin,\n             final int length) {\n-        return variance.evaluate(values, begin, length);\n+        return VARIANCE.evaluate(values, begin, length);\n     }\n     \n     /**\n      */\n     public static double variance(final double[] values, final double mean, \n             final int begin, final int length) {\n-        return variance.evaluate(values, mean, begin, length);    \n+        return VARIANCE.evaluate(values, mean, begin, length);    \n     }\n     \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double variance(final double[] values, final double mean) {\n-        return variance.evaluate(values, mean);    \n+        return VARIANCE.evaluate(values, mean);    \n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double max(final double[] values) {\n-        return max.evaluate(values);\n+        return MAX.evaluate(values);\n     }\n \n     /**\n      */\n     public static double max(final double[] values, final int begin,\n             final int length) {\n-        return max.evaluate(values, begin, length);\n+        return MAX.evaluate(values, begin, length);\n     }\n \n      /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double min(final double[] values) {\n-        return min.evaluate(values);\n+        return MIN.evaluate(values);\n     }\n \n      /**\n      */\n     public static double min(final double[] values, final int begin,\n             final int length) {\n-        return min.evaluate(values, begin, length);\n+        return MIN.evaluate(values, begin, length);\n     }\n     \n     /**\n      * or p is invalid\n      */\n     public static double percentile(final double[] values, final double p) {\n-            return percentile.evaluate(values,p);\n+            return PERCENTILE.evaluate(values,p);\n     }\n \n      /**\n      */\n     public static double percentile(final double[] values, final int begin, \n             final int length, final double p) {\n-        return percentile.evaluate(values, begin, length, p);\n+        return PERCENTILE.evaluate(values, begin, length, p);\n     }   \n     \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     }\n     \n     /** All long-representable factorials */\n-    private static final long[] factorials = new long[] \n+    private static final long[] FACTORIALS = new long[] \n        {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n         479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n         355687428096000l, 6402373705728000l, 121645100408832000l,\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }\n-        return factorials[n];\n+        return FACTORIALS[n];\n     }\n \n     /**", "timestamp": 1251834466, "metainfo": ""}