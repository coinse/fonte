{"sha": "b9ee639f2ad4c863ec29324421b4904d350000f2", "log": "Replaced Characterization by an internal class in AbstractRegion.  Note that the suppresses class was a package private one and did not belong to the public API. It was used only when building the boundaries in the AbstractRegion class. The change simplifies the package and makes better use of the existing visitor pattern.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java\n  */\n package org.apache.commons.math3.geometry.partitioning;\n \n+import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Comparator;\n     public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {\n         if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n             // we need to compute the boundary attributes\n-            recurseBuildBoundary(tree);\n+            tree.visit(new BoundaryBuilder<S>());\n         }\n         return tree;\n     }\n \n-    /** Recursively build the boundary shell tree.\n-     * @param node current node in the inout tree\n-     */\n-    private void recurseBuildBoundary(final BSPTree<S> node) {\n-        if (node.getCut() != null) {\n+    /** Visitor building boundary shell tree.\n+     * <p>\n+     * The boundary shell is represented as {@link BoundaryAttribute boundary attributes}\n+     * at each internal node.\n+     * </p>\n+     */\n+    private static class BoundaryBuilder<S extends Space> implements BSPTreeVisitor<S> {\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(BSPTree<S> node) {\n+            return Order.PLUS_MINUS_SUB;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(BSPTree<S> node) {\n \n             SubHyperplane<S> plusOutside = null;\n             SubHyperplane<S> plusInside  = null;\n \n             // characterize the cut sub-hyperplane,\n             // first with respect to the plus sub-tree\n-            final Characterization<S> plusChar = new Characterization<S>();\n+            @SuppressWarnings(\"unchecked\")\n+            final SubHyperplane<S>[] plusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2);\n             characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n \n-            if (plusChar.hasOut()) {\n-                // plusChar.getOut() corresponds to a subset of the cut\n-                // sub-hyperplane known to have outside cells on its plus\n-                // side, we want to check if parts of this subset do have\n-                // inside cells on their minus side\n-                final Characterization<S> minusChar = new Characterization<S>();\n-                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n-                if (minusChar.hasIn()) {\n-                    plusOutside = minusChar.getIn();\n-                }\n-            }\n-\n-            if (plusChar.hasIn()) {\n-                // plusChar.getIn() corresponds to a subset of the cut\n-                // sub-hyperplane known to have inside cells on its plus\n-                // side, we want to check if parts of this subset do have\n-                // outside cells on their minus side\n-                final Characterization<S> minusChar = new Characterization<S>();\n-                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n-                if (minusChar.hasOut()) {\n-                    plusInside = minusChar.getOut();\n-                }\n-            }\n-\n+            if (plusChar[0] != null && !plusChar[0].isEmpty()) {\n+                // plusChar[0] corresponds to a subset of the cut sub-hyperplane known to have\n+                // outside cells on its plus side, we want to check if parts of this subset\n+                // do have inside cells on their minus side\n+                @SuppressWarnings(\"unchecked\")\n+                final SubHyperplane<S>[] minusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2);\n+                characterize(node.getMinus(), plusChar[0], minusChar);\n+                if (minusChar[1] != null && !minusChar[1].isEmpty()) {\n+                    // this part belongs to the boundary,\n+                    // it has the outside on its plus side and the inside on its minus side\n+                    plusOutside = minusChar[1];\n+                }\n+            }\n+\n+            if (plusChar[1] != null && !plusChar[1].isEmpty()) {\n+                // plusChar[1] corresponds to a subset of the cut sub-hyperplane known to have\n+                // inside cells on its plus side, we want to check if parts of this subset\n+                // do have outside cells on their minus side\n+                @SuppressWarnings(\"unchecked\")\n+                final SubHyperplane<S>[] minusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2);\n+                characterize(node.getMinus(), plusChar[1], minusChar);\n+                if (minusChar[0] != null && !minusChar[0].isEmpty()) {\n+                    // this part belongs to the boundary,\n+                    // it has the inside on its plus side and the outside on its minus side\n+                    plusInside = minusChar[0];\n+                }\n+            }\n+\n+            // set the boundary attribute at non-leaf nodes\n             node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));\n-            recurseBuildBoundary(node.getPlus());\n-            recurseBuildBoundary(node.getMinus());\n-\n-        }\n-    }\n-\n-    /** Filter the parts of an hyperplane belonging to the boundary.\n-     * <p>The filtering consist in splitting the specified\n-     * sub-hyperplane into several parts lying in inside and outside\n-     * cells of the tree. The principle is to call this method twice for\n-     * each cut sub-hyperplane in the tree, once one the plus node and\n-     * once on the minus node. The parts that have the same flag\n-     * (inside/inside or outside/outside) do not belong to the boundary\n-     * while parts that have different flags (inside/outside or\n-     * outside/inside) do belong to the boundary.</p>\n-     * @param node current BSP tree node\n-     * @param sub sub-hyperplane to characterize\n-     * @param characterization placeholder where to put the characterized parts\n-     */\n-    private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\n-                              final Characterization<S> characterization) {\n-        if (node.getCut() == null) {\n-            // we have reached a leaf node\n-            final boolean inside = (Boolean) node.getAttribute();\n-            characterization.add(sub, inside);\n-        } else {\n-            final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n-            switch (sub.side(hyperplane)) {\n-            case PLUS:\n-                characterize(node.getPlus(), sub, characterization);\n-                break;\n-            case MINUS:\n-                characterize(node.getMinus(), sub, characterization);\n-                break;\n-            case BOTH:\n-                final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n-                characterize(node.getPlus(),  split.getPlus(),  characterization);\n-                characterize(node.getMinus(), split.getMinus(), characterization);\n-                break;\n-            default:\n-                // this should not happen\n-                throw new MathInternalError();\n-            }\n-        }\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(BSPTree<S> node) {\n+        }\n+\n+        /** Filter the parts of an hyperplane belonging to the boundary.\n+         * <p>The filtering consist in splitting the specified\n+         * sub-hyperplane into several parts lying in inside and outside\n+         * cells of the tree. The principle is to call this method twice for\n+         * each cut sub-hyperplane in the tree, once one the plus node and\n+         * once on the minus node. The parts that have the same flag\n+         * (inside/inside or outside/outside) do not belong to the boundary\n+         * while parts that have different flags (inside/outside or\n+         * outside/inside) do belong to the boundary.</p>\n+         * @param node current BSP tree node\n+         * @param sub sub-hyperplane to characterize\n+         * @param characterization placeholder where to put the characterized parts\n+         */\n+        private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\n+                                  final SubHyperplane<S>[] characterization) {\n+            if (node.getCut() == null) {\n+                // we have reached a leaf node\n+                final boolean inside = (Boolean) node.getAttribute();\n+                if (inside) {\n+                    if (characterization[1] == null) {\n+                        characterization[1] = sub;\n+                    } else {\n+                        characterization[1] = characterization[1].reunite(sub);\n+                    }\n+                } else {\n+                    if (characterization[0] == null) {\n+                        characterization[0] = sub;\n+                    } else {\n+                        characterization[0] = characterization[0].reunite(sub);\n+                    }\n+                }\n+            } else {\n+                final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n+                switch (sub.side(hyperplane)) {\n+                case PLUS:\n+                    characterize(node.getPlus(), sub, characterization);\n+                    break;\n+                case MINUS:\n+                    characterize(node.getMinus(), sub, characterization);\n+                    break;\n+                case BOTH:\n+                    final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n+                    characterize(node.getPlus(),  split.getPlus(),  characterization);\n+                    characterize(node.getMinus(), split.getMinus(), characterization);\n+                    break;\n+                default:\n+                    // this should not happen\n+                    throw new MathInternalError();\n+                }\n+            }\n+        }\n+\n     }\n \n     /** {@inheritDoc} */", "timestamp": 1338580924, "metainfo": ""}