{"sha": "feb43d631efa5fef4c842f6ba02e417e555293a2", "log": "MATH-534 Refactored \"PolynomialFitter\". Moved parametric function inner class to \"PolynomialFunction\". Adapted affected classes.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n  */\n public class SmoothingPolynomialBicubicSplineInterpolator\n     extends BicubicSplineInterpolator {\n-\n     /** Fitter for x. */\n     private final PolynomialFitter xFitter;\n-\n     /** Fitter for y. */\n     private final PolynomialFitter yFitter;\n \n                 xFitter.addObservedPoint(1, xval[i], fval[i][j]);\n             }\n \n-            yPolyX[j] = xFitter.fit();\n+            yPolyX[j] = new PolynomialFunction(xFitter.fit());\n         }\n \n         // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n                 yFitter.addObservedPoint(1, yval[j], fval_1[i][j]);\n             }\n \n-            xPolyY[i] = yFitter.fit();\n+            xPolyY[i] = new PolynomialFunction(yFitter.fit());\n         }\n \n         // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n \n /**\n             throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         double result = coefficients[n - 1];\n-        for (int j = n -2; j >=0; j--) {\n+        for (int j = n - 2; j >= 0; j--) {\n             result = argument * result + coefficients[j];\n         }\n         return result;\n                 return \"0\";\n             }\n         } else {\n-            //         s.append(Double.toString(coefficients[0])); XXX\n             s.append(toString(coefficients[0]));\n         }\n \n \n                 double absAi = FastMath.abs(coefficients[i]);\n                 if ((absAi - 1) != 0) {\n-                    //             s.append(Double.toString(absAi)); XXX\n                     s.append(toString(absAi));\n                     s.append(' ');\n                 }\n         }\n         return true;\n     }\n+\n+    /**\n+     * Dedicated parametric polynomial class.\n+     */\n+    public static class Parametric implements ParametricUnivariateRealFunction {\n+        /** {@inheritDoc} */\n+        public double[] gradient(double x, double[] parameters) {\n+            final double[] gradient = new double[parameters.length];\n+            double xn = 1.0;\n+            for (int i = 0; i < parameters.length; ++i) {\n+                gradient[i] = xn;\n+                xn *= x;\n+            }\n+            return gradient;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double value(final double x, final double[] parameters) {\n+            return PolynomialFunction.evaluate(parameters, x);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n-import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n \n /** This class implements a curve fitting specialized for polynomials.\n  * @since 2.0\n  */\n \n-public class PolynomialFitter {\n-    /** Fitter for the coefficients. */\n-    private final CurveFitter fitter;\n+public class PolynomialFitter extends CurveFitter {\n     /** Polynomial degree. */\n     private final int degree;\n \n     /**\n      * Simple constructor.\n-     *\n      * <p>The polynomial fitter built this way are complete polynomials,\n      * ie. a n-degree polynomial has n+1 coefficients.</p>\n-     * @param degree maximal degree of the polynomial\n-     * @param optimizer optimizer to use for the fitting\n+     *\n+     * @param degree Maximal degree of the polynomial.\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public PolynomialFitter(int degree, final DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        this.fitter = new CurveFitter(optimizer);\n+        super(optimizer);\n         this.degree = degree;\n-    }\n-\n-    /**\n-     * Add an observed weighted (x,y) point to the sample.\n-     *\n-     * @param weight weight of the observed point in the fit\n-     * @param x abscissa of the point\n-     * @param y observed value of the point at x, after fitting we should\n-     * have P(x) as close as possible to this value\n-     */\n-    public void addObservedPoint(double weight, double x, double y) {\n-        fitter.addObservedPoint(weight, x, y);\n-    }\n-\n-    /**\n-     * Remove all observations.\n-     * @since 2.2\n-     */\n-    public void clearObservations() {\n-        fitter.clearObservations();\n     }\n \n     /**\n      * Get the polynomial fitting the weighted (x, y) points.\n      *\n-     * @return polynomial function best fitting the observed points\n+     * @return the coefficients of the polynomial that best fits the observed points.\n      * @throws org.apache.commons.math.exception.ConvergenceException\n      * if the algorithm failed to converge.\n      */\n-    public PolynomialFunction fit() {\n-        return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n-    }\n-\n-    /**\n-     * Dedicated parametric polynomial class.\n-     */\n-    private static class ParametricPolynomial implements ParametricUnivariateRealFunction {\n-\n-        /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters) {\n-            final double[] gradient = new double[parameters.length];\n-            double xn = 1.0;\n-            for (int i = 0; i < parameters.length; ++i) {\n-                gradient[i] = xn;\n-                xn *= x;\n-            }\n-            return gradient;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double value(final double x, final double[] parameters) {\n-            double y = 0;\n-            for (int i = parameters.length - 1; i >= 0; --i) {\n-                y = y * x + parameters[i];\n-            }\n-            return y;\n-        }\n+    public double[] fit() {\n+        return fit(new PolynomialFunction.Parametric(), new double[degree + 1]);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import java.util.Random;\n \n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n+\n import org.junit.Test;\n+import org.junit.Assert;\n \n public class PolynomialFitterTest {\n \n                 fitter.addObservedPoint(1.0, i, p.value(i));\n             }\n \n-            PolynomialFunction fitted = fitter.fit();\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                                (1.0 + FastMath.abs(p.value(x)));\n-                assertEquals(0.0, error, 1.0e-6);\n+                Assert.assertEquals(0.0, error, 1.0e-6);\n             }\n-\n         }\n-\n     }\n \n     @Test\n                                         p.value(x) + 0.1 * randomizer.nextGaussian());\n             }\n \n-            PolynomialFunction fitted = fitter.fit();\n+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n                 double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                               (1.0 + FastMath.abs(p.value(x)));\n                 maxError = FastMath.max(maxError, error);\n-                assertTrue(FastMath.abs(error) < 0.1);\n+                Assert.assertTrue(FastMath.abs(error) < 0.1);\n             }\n         }\n-        assertTrue(maxError > 0.01);\n+        Assert.assertTrue(maxError > 0.01);\n \n     }\n \n \n             try {\n                 fitter.fit();\n-                assertTrue(solvable || (degree == 0));\n+                Assert.assertTrue(solvable || (degree == 0));\n             } catch(ConvergenceException e) {\n-                assertTrue((! solvable) && (degree > 0));\n+                Assert.assertTrue((! solvable) && (degree > 0));\n             }\n-\n         }\n-\n     }\n \n     private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {\n         }\n         return new PolynomialFunction(coefficients);\n     }\n-\n }", "timestamp": 1298813507, "metainfo": ""}