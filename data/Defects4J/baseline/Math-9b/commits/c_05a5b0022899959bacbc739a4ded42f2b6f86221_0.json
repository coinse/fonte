{"sha": "05a5b0022899959bacbc739a4ded42f2b6f86221", "log": "Added method o.a.c.m.linear.IterativeLinearSolverEvent.getNormOfResidual() (MATH-735).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n         /** The current estimate of the residual. */\n         private final RealVector r;\n \n+        /** The current estimate of the norm of the residual. */\n+        private final double rnorm;\n+\n         /** The current estimate of the solution. */\n         private final RealVector x;\n \n          * @param x the current estimate of the solution\n          * @param b the right-hand side vector\n          * @param r the current estimate of the residual\n+         * @param rnorm the norm of the current estimate of the residual\n          */\n-        public ConjugateGradientEvent(final Object source, final int iterations, final RealVector x, final RealVector b, final RealVector r) {\n+        public ConjugateGradientEvent(final Object source, final int iterations,\n+            final RealVector x, final RealVector b, final RealVector r,\n+            final double rnorm) {\n             super(source, iterations);\n             this.x = RealVector.unmodifiableRealVector(x);\n             this.b = RealVector.unmodifiableRealVector(b);\n             this.r = RealVector.unmodifiableRealVector(r);\n+            this.rnorm = rnorm;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public double getNormOfResidual() {\n+            return rnorm;\n         }\n \n         /** {@inheritDoc} */\n         final IterationManager manager = getIterationManager();\n         // Initialization of default stopping criterion\n         manager.resetIterationCount();\n-        final double r2max = delta * delta * b.dotProduct(b);\n+        final double rmax = delta * b.getNorm();\n \n         // Initialization phase counts as one iteration.\n         manager.incrementIterationCount();\n         RealVector q = a.operate(p);\n \n         final RealVector r = b.combine(1, -1, q);\n-        double r2 = r.dotProduct(r);\n+        double rnorm = r.getNorm();\n         RealVector z;\n         if (m == null) {\n             z = r;\n             z = null;\n         }\n         IterativeLinearSolverEvent evt;\n-        evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+        evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n         manager.fireInitializationEvent(evt);\n-        if (r2 <= r2max) {\n+        if (rnorm <= rmax) {\n             manager.fireTerminationEvent(evt);\n             return x;\n         }\n         double rhoPrev = 0.;\n         while (true) {\n             manager.incrementIterationCount();\n-            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n             manager.fireIterationStartedEvent(evt);\n             if (m != null) {\n                 z = m.solve(r);\n             x.combineToSelf(1., alpha, p);\n             r.combineToSelf(1., -alpha, q);\n             rhoPrev = rhoNext;\n-            r2 = r.dotProduct(r);\n-            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+            rnorm = r.getNorm();\n+            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n             manager.fireIterationPerformedEvent(evt);\n-            if (r2 <= r2max) {\n+            if (rnorm <= rmax) {\n                 manager.fireTerminationEvent(evt);\n                 return x;\n             }\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n     public abstract RealVector getRightHandSideVector();\n \n     /**\n+     * Returns the norm of the residual. The returned value is not required to\n+     * be <em>exact</em>. Instead, the norm of the so-called <em>updated</em>\n+     * residual (if available) should be returned. For example, the\n+     * {@link ConjugateGradient conjugate gradient} method computes a sequence\n+     * of residuals, the norm of which is cheap to compute. However, due to\n+     * accumulation of round-off errors, this residual might differ from the\n+     * true residual after some iterations. See e.g. A. Greenbaum and\n+     * Z. Strakos, <em>Predicting the Behavior of Finite Precision Lanzos and\n+     * Conjugate Gradient Computations</em>, Technical Report 538, Department of\n+     * Computer Science, New York University, 1991 (available\n+     * <a href=\"http://www.archive.org/details/predictingbehavi00gree\">here</a>).\n+     *\n+     * @return an estimate of the norm of the residual\n+     */\n+    public abstract double getNormOfResidual();\n+\n+    /**\n      * Returns the current estimate of the solution to the linear system to be\n      * solved. This method should return an unmodifiable view, or a deep copy of\n      * the actual current solution, in order not to compromise subsequent\n--- a/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n          */\n \n         /** */\n-        private static final long serialVersionUID = 20120128L;\n+        private static final long serialVersionUID = 2012012801L;\n \n         /** A reference to the state of this solver. */\n         private final State state;\n             this.state = state;\n         }\n \n+        /** {@inheritDoc} */\n         @Override\n         public int getIterations() {\n             return getIterationManager().getIterations();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public double getNormOfResidual() {\n+            return FastMath.min(state.cgnorm, state.lqnorm);\n         }\n \n         /** {@inheritDoc} */\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.IterationEvent;\n import org.apache.commons.math.util.IterationListener;\n import org.junit.Assert;\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n-                RealVector v = ((ProvidesResidual)e).getResidual();\n+                RealVector v = ((ProvidesResidual) e).getResidual();\n                 r.setSubVector(0, v);\n                 v = ((IterativeLinearSolverEvent) e).getSolution();\n                 x.setSubVector(0, v);\n          */\n         final int[] count = new int[] {0, 0, 0, 0};\n         final IterationListener listener = new IterationListener() {\n-\n             public void initializationPerformed(final IterationEvent e) {\n                 ++count[0];\n             }\n             Assert.assertEquals(msg, 1, count[3]);\n         }\n     }\n+\n+    @Test\n+    public void testUnpreconditionedNormOfResidual() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        final IterationListener listener = new IterationListener() {\n+\n+            private void doTestNormOfResidual(final IterationEvent e) {\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                final RealVector x = evt.getSolution();\n+                final RealVector b = evt.getRightHandSideVector();\n+                final RealVector r = b.subtract(a.operate(x));\n+                final double rnorm = r.getNorm();\n+                Assert.assertEquals(\"iteration performed (residual)\",\n+                    rnorm, evt.getNormOfResidual(),\n+                    FastMath.max(1E-5 * rnorm, 1E-10));\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+        };\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, b);\n+        }\n+    }\n+\n+    @Test\n+    public void testPreconditionedNormOfResidual() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver solver;\n+        final IterationListener listener = new IterationListener() {\n+\n+            private void doTestNormOfResidual(final IterationEvent e) {\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                final RealVector x = evt.getSolution();\n+                final RealVector b = evt.getRightHandSideVector();\n+                final RealVector r = b.subtract(a.operate(x));\n+                final double rnorm = r.getNorm();\n+                Assert.assertEquals(\"iteration performed (residual)\",\n+                    rnorm, evt.getNormOfResidual(),\n+                    FastMath.max(1E-5 * rnorm, 1E-10));\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+        };\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, m, b);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n         });\n         new SymmLQ(100, 1., true).solve(a, m, b);\n     }\n+\n+    @Test\n+    public void testUnpreconditionedNormOfResidual() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        final IterationListener listener = new IterationListener() {\n+\n+            private void doTestNormOfResidual(final IterationEvent e) {\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                final RealVector x = evt.getSolution();\n+                final RealVector b = evt.getRightHandSideVector();\n+                final RealVector r = b.subtract(a.operate(x));\n+                final double rnorm = r.getNorm();\n+                Assert.assertEquals(\"iteration performed (residual)\",\n+                    rnorm, evt.getNormOfResidual(),\n+                    FastMath.max(1E-5 * rnorm, 1E-10));\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+        };\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, b);\n+        }\n+    }\n+\n+    @Test\n+    public void testPreconditionedNormOfResidual() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver solver;\n+        final IterationListener listener = new IterationListener() {\n+\n+            private void doTestNormOfResidual(final IterationEvent e) {\n+                final IterativeLinearSolverEvent evt;\n+                evt = (IterativeLinearSolverEvent) e;\n+                final RealVector x = evt.getSolution();\n+                final RealVector b = evt.getRightHandSideVector();\n+                final RealVector r = b.subtract(a.operate(x));\n+                final double rnorm = r.getNorm();\n+                Assert.assertEquals(\"iteration performed (residual)\",\n+                    rnorm, evt.getNormOfResidual(),\n+                    FastMath.max(1E-5 * rnorm, 1E-10));\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                doTestNormOfResidual(e);\n+            }\n+        };\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, m, b);\n+        }\n+    }\n }\n+", "timestamp": 1327763442, "metainfo": ""}