{"sha": "e1da0ae3c9daf1861ff6c4e59cbe23a9ed128c37", "log": "added a Vector3DFormat class  ", "commit": "\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.util.MathUtils;\n+\n /** \n  * This class implements vectors in a three-dimensional space.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n   /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n   public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n \n+  /** A vector with all coordinates set to NaN. */\n+  public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+\n+  /** A vector with all coordinates set to positive infinity. */\n+  public static final Vector3D POSITIVE_INFINITY =\n+      new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+  /** A vector with all coordinates set to negative infinity. */\n+  public static final Vector3D NEGATIVE_INFINITY =\n+      new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+  /** Default format. */\n+  private static final Vector3DFormat DEFAULT_FORMAT =\n+      Vector3DFormat.getInstance();\n+\n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -6155041477622120793L;\n+  private static final long serialVersionUID = 5133268763396045979L;\n \n   /** Abscissa. */\n   private final double x;\n     return new Vector3D(a * x, a * y, a * z);\n   }\n \n+  /**\n+   * Returns true if any coordinate of this vector is NaN; false otherwise\n+   * @return  true if any coordinate of this vector is NaN; false otherwise\n+   */\n+  public boolean isNaN() {\n+      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        \n+  }\n+  \n+  /**\n+   * Returns true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   * @return  true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   */\n+  public boolean isInfinite() {\n+      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        \n+  }\n+  \n+  /**\n+   * Test for the equality of two 3D vectors.\n+   * <p>\n+   * If all coordinates of two 3D vectors are exactly the same, and none are\n+   * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n+   * </p>\n+   * <p>\n+   * All <code>NaN</code> values are considered to be equal - i.e, if either\n+   * (or all) coordinates of the 3D vector are equal to <code>Double.NaN</code>,\n+   * the complex number is equal to \n+   * <code>Complex.NaN</code>.</p>\n+   *\n+   * @param other Object to test for equality to this\n+   * @return true if two 3D vector objects are equal, false if\n+   *         object is null, not an instance of Vector3D, or\n+   *         not equal to this Vector3D instance\n+   * \n+   */\n+  public boolean equals(Object other) {\n+\n+    if (this == other) { \n+      return true;\n+    }\n+\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    try {\n+\n+        Vector3D rhs = (Vector3D)other;\n+      if (rhs.isNaN()) {\n+          return this.isNaN();\n+      }\n+\n+      return (Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(rhs.x)) &&\n+             (Double.doubleToRawLongBits(y) == Double.doubleToRawLongBits(rhs.y)) &&\n+             (Double.doubleToRawLongBits(z) == Double.doubleToRawLongBits(rhs.z)); \n+\n+    } catch (ClassCastException ex) {\n+        // ignore exception\n+        return false;\n+    }\n+\n+  }\n+  \n+  /**\n+   * Get a hashCode for the 3D vector.\n+   * <p>\n+   * All NaN values have the same hash code.</p>\n+   * \n+   * @return a hash code value for this object\n+   */\n+  public int hashCode() {\n+      if (isNaN()) {\n+          return 8;\n+      }\n+      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n+  }\n+\n   /** Compute the dot-product of two vectors.\n    * @param v1 first vector\n    * @param v2 second vector\n     return dx * dx + dy * dy + dz * dz;\n   }\n \n+  /** Get a string representation of this vector.\n+   * @return a string representation of this vector\n+   */\n+  public String toString() {\n+      return DEFAULT_FORMAT.format(this);\n+  }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a 3D vector in components list format \"{x; y; z}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \", \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Vector3DFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5447606608652576301L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector3DFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which 3D vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static Vector3DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static Vector3DFormat getInstance(final Locale locale) {\n+        return new Vector3DFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * Vector3DFormat.\n+     *\n+     * @param v Vector3D object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatVector3D(Vector3D v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link Vector3D} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        formatDouble(vector.getX(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getY(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getZ(), format, toAppendTo, pos);\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link Vector3D} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof Vector3D) {\n+            return format( (Vector3D)obj, toAppendTo, pos);\n+        }\n+\n+        throw new IllegalArgumentException(\"Cannot format given Object as a Vector3D\");\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Vector3D} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Vector3D parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector3D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable 3D vector: \\\"\" + source +\n+                                     \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Vector3D} object.\n+     */\n+    public Vector3D parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse X component\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number x = parseNumber(source, format, pos);\n+        if (x == null) {\n+            // invalid abscissa\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Y component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number y = parseNumber(source, format, pos);\n+        if (y == null) {\n+            // invalid ordinate\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Z component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number z = parseNumber(source, format, pos);\n+        if (z == null) {\n+            // invalid height\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {\n+    \n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class Vector3DFormatAbstractTest extends TestCase {\n+ \n+    Vector3DFormat vector3DFormat = null;\n+    Vector3DFormat vector3DFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+    \n+    protected void setUp() throws Exception {\n+        vector3DFormat = Vector3DFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"{1; 1; 1}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        Vector3D c = new Vector3D(1.23, 1.43, 1.63);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = vector3DFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatVector3D() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        Vector3D c = new Vector3D(232.222, -342.33, 432.444);\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = Vector3DFormat.formatVector3D(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        Vector3D c = Vector3D.NaN;\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        Vector3D c = Vector3D.POSITIVE_INFINITY;\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        Vector3D c = Vector3D.NEGATIVE_INFINITY;\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NaN, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        Vector3DFormat cf = new Vector3DFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new Vector3DFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class Vector3DFormatTest extends Vector3DFormatAbstractTest {\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}", "timestamp": 1217097101, "metainfo": ""}