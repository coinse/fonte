{"sha": "468ed8550b7759858a4dc59d694859a8ae7d35f0", "log": "Fixed an error in rectangular Cholesky decomposition.  JIRA: MATH-789  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n     public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         throws NonPositiveDefiniteMatrixException {\n \n-        int order = matrix.getRowDimension();\n-        double[][] c = matrix.getData();\n-        double[][] b = new double[order][order];\n+        final int order = matrix.getRowDimension();\n+        final double[][] c = matrix.getData();\n+        final double[][] b = new double[order][order];\n \n-        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            swap[r] = r;\n+            int swapR = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isi = index[swap[i]];\n-                if (c[ii][ii] > c[isi][isi]) {\n-                    swap[r] = i;\n+                int isr = index[swapR];\n+                if (c[ii][ii] > c[isr][isr]) {\n+                    swapR = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swap[r] != r) {\n-                int tmp = index[r];\n-                index[r] = index[swap[r]];\n-                index[swap[r]] = tmp;\n+            if (swapR != r) {\n+                final int tmpIndex    = index[r];\n+                index[r]              = index[swapR];\n+                index[swapR]          = tmpIndex;\n+                final double[] tmpRow = b[r];\n+                b[r]                  = b[swapR];\n+                b[swapR]              = tmpRow;\n             }\n \n             // check diagonal element\n             } else {\n \n                 // transform the matrix\n-                double sqrt = FastMath.sqrt(c[ir][ir]);\n+                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n-                double inverse = 1 / sqrt;\n+                final double inverse  = 1 / sqrt;\n+                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n-                    int ii = index[i];\n-                    double e = inverse * c[ii][ir];\n+                    final int ii = index[i];\n+                    final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= e * e;\n+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n-                        int ij = index[j];\n-                        double f = c[ii][ij] - e * b[j][r];\n+                        final int ij = index[j];\n+                        final double f = c[ii][ij] - e * b[j][r];\n                         c[ii][ij] = f;\n                         c[ij][ii] = f;\n                     }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RectangularCholeskyDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class RectangularCholeskyDecompositionTest {\n+\n+    @Test\n+    public void testDecomposition3x3() {\n+\n+        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {\n+            { 1,   9,   9 },\n+            { 9, 225, 225 },\n+            { 9, 225, 625 }\n+        });\n+\n+        RectangularCholeskyDecomposition d =\n+                new RectangularCholeskyDecomposition(m, 1.0e-6);\n+\n+        // as this decomposition permutes lines and columns, the root is NOT triangular\n+        // (in fact here it is the lower right part of the matrix which is zero and\n+        //  the upper left non-zero)\n+        Assert.assertEquals(0.8,  d.getRootMatrix().getEntry(0, 2), 1.0e-15);\n+        Assert.assertEquals(25.0, d.getRootMatrix().getEntry(2, 0), 1.0e-15);\n+        Assert.assertEquals(0.0,  d.getRootMatrix().getEntry(2, 2), 1.0e-15);\n+\n+        RealMatrix root = d.getRootMatrix();\n+        RealMatrix rebuiltM = root.multiply(root.transpose());\n+        Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);\n+\n+    }\n+\n+    @Test\n+    public void testFullRank() {\n+\n+        RealMatrix base = MatrixUtils.createRealMatrix(new double[][] {\n+            { 0.1159548705,      0.,           0.,           0.      },\n+            { 0.0896442724, 0.1223540781,      0.,           0.      },\n+            { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      },\n+            { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 }\n+        });\n+\n+        RealMatrix m = base.multiply(base.transpose());\n+\n+        RectangularCholeskyDecomposition d =\n+                new RectangularCholeskyDecomposition(m, 1.0e-10);\n+\n+        RealMatrix root = d.getRootMatrix();\n+        RealMatrix rebuiltM = root.multiply(root.transpose());\n+        Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);\n+\n+        // the pivoted Cholesky decomposition is *not* unique. Here, the root is\n+        // not equal to the original trianbular base matrix\n+        Assert.assertTrue(root.subtract(base).getNorm() > 0.3);\n+\n+    }\n+\n+    @Test\n+    public void testMath789() {\n+\n+        final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{\n+            {0.013445532, 0.010394690, 0.009881156, 0.010499559},\n+            {0.010394690, 0.023006616, 0.008196856, 0.010732709},\n+            {0.009881156, 0.008196856, 0.019023866, 0.009210099},\n+            {0.010499559, 0.010732709, 0.009210099, 0.019107243}\n+        });\n+        RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix();\n+        RealMatrix rebuiltM1 = root1.multiply(root1.transpose());\n+        Assert.assertEquals(0.0, m1.subtract(rebuiltM1).getNorm(), 1.0e-16);\n+\n+        final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{\n+            {0.0, 0.0, 0.0, 0.0, 0.0},\n+            {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n+            {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n+            {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n+            {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n+        });\n+        RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix();\n+        RealMatrix rebuiltM2 = root2.multiply(root2.transpose());\n+        Assert.assertEquals(0.0, m2.subtract(rebuiltM2).getNorm(), 1.0e-16);\n+\n+        final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{\n+            {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n+            {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n+            {0.0, 0.0, 0.0, 0.0, 0.0},\n+            {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n+            {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n+        });\n+        RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix();\n+        RealMatrix rebuiltM3 = root3.multiply(root3.transpose());\n+        Assert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16);\n+\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math3/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/CorrelatedRandomVectorGeneratorTest.java\n \n package org.apache.commons.math3.random;\n \n+import java.util.Arrays;\n+\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.correlation.StorelessCovariance;\n import org.apache.commons.math3.stat.descriptive.moment.VectorialCovariance;\n import org.apache.commons.math3.stat.descriptive.moment.VectorialMean;\n import org.apache.commons.math3.util.FastMath;\n         CorrelatedRandomVectorGenerator sg =\n             new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);\n \n+        double[] min = new double[mean.length];\n+        Arrays.fill(min, Double.POSITIVE_INFINITY);\n+        double[] max = new double[mean.length];\n+        Arrays.fill(max, Double.NEGATIVE_INFINITY);\n         for (int i = 0; i < 10; i++) {\n             double[] generated = sg.nextVector();\n-            Assert.assertTrue(FastMath.abs(generated[0] - 1) > 0.1);\n+            for (int j = 0; j < generated.length; ++j) {\n+                min[j] = FastMath.min(min[j], generated[j]);\n+                max[j] = FastMath.max(max[j], generated[j]);\n+            }\n+        }\n+        for (int j = 0; j < min.length; ++j) {\n+            Assert.assertTrue(max[j] - min[j] > 2.0);\n         }\n \n     }\n         }\n \n     }\n+\n+    @Test\n+    public void testSampleWithZeroCovariance() {\n+        final double[][] covMatrix1 = new double[][]{\n+                {0.013445532, 0.010394690, 0.009881156, 0.010499559},\n+                {0.010394690, 0.023006616, 0.008196856, 0.010732709},\n+                {0.009881156, 0.008196856, 0.019023866, 0.009210099},\n+                {0.010499559, 0.010732709, 0.009210099, 0.019107243}\n+        };\n+        \n+        final double[][] covMatrix2 = new double[][]{\n+                {0.0, 0.0, 0.0, 0.0, 0.0},\n+                {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n+                {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n+                {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n+                {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n+        };\n+        \n+        final double[][] covMatrix3 = new double[][]{\n+                {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n+                {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n+                {0.0, 0.0, 0.0, 0.0, 0.0},\n+                {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n+                {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n+        };\n+        \n+        testSampler(covMatrix1, 10000, 0.001);\n+        testSampler(covMatrix2, 10000, 0.001);\n+        testSampler(covMatrix3, 10000, 0.001);\n+\n+    }\n+\n+    private CorrelatedRandomVectorGenerator createSampler(double[][] cov) {\n+        RealMatrix matrix = new Array2DRowRealMatrix(cov);\n+        double small = 10e-12 * matrix.getNorm();\n+        return new CorrelatedRandomVectorGenerator(\n+                new double[cov.length],\n+                matrix,\n+                small,\n+                new GaussianRandomGenerator(new JDKRandomGenerator()));\n+    }\n+\n+    private void testSampler(final double[][] covMatrix, int samples, double epsilon) {\n+        CorrelatedRandomVectorGenerator sampler = createSampler(covMatrix);\n+        \n+        StorelessCovariance cov = new StorelessCovariance(covMatrix.length);\n+        for (int i = 0; i < samples; ++i) {\n+            cov.increment(sampler.nextVector());\n+        }\n+\n+        double[][] sampleCov = cov.getData();\n+        for (int r = 0; r < covMatrix.length; ++r) {\n+            TestUtils.assertEquals(covMatrix[r], sampleCov[r], epsilon);\n+        }\n+\n+    }\n+\n }", "timestamp": 1347549183, "metainfo": ""}