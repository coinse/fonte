{"sha": "ed5fdf67a31518149a74e05db23371056af10842", "log": "MATH-599 \"SecantSolver\" modified to correspond to the original algorithm. Added several secant-based solvers. Patch provided by Dennis Hendriks.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolutions.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+\n+/** The kinds of solutions that a {@link UnivariateRealSolver (univariate real)\n+ * root-finding algorithm} may accept as solutions. This basically controls\n+ * whether or not under-approximations and over-approximations are allowed.\n+ *\n+ * <p>If all solutions are accepted ({@link #EITHER_SIDE}), then the solution\n+ * that the root-finding algorithm returns for a given root may be equal to the\n+ * actual root, but it may also be an approximation that is slightly smaller\n+ * or slightly larger than the actual root. Root-finding algorithms generally\n+ * only guarantee that the returned solution is within the requested\n+ * tolerances. In certain cases however, in particular for\n+ * {@link EventHandler state events} of {@link ODEIntegrator ODE solvers}, it\n+ * may be necessary to guarantee that a solution is returned that does not\n+ * under-approximate the solution.</p>\n+ *\n+ * @see BracketedSolution\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public enum AllowedSolutions {\n+    /** There are no additional side restriction on the solutions for\n+     * root-finding. That is, both under-approximations and over-approximations\n+     * are allowed. So, if a function f(x) has a root at x = y, then the\n+     * root-finding result s may be smaller than y, equal to y, or greater\n+     * than y.\n+     */\n+    EITHER_SIDE,\n+\n+    /** Only solutions that are less than or equal to the actual root are\n+     * acceptable as solutions for root-finding. In other words,\n+     * over-approximations are not allowed. So, if a function f(x) has a root\n+     * at x = y, then the root-finding result s must satisfy s &lt;= y.\n+     */\n+    LEFT_SIDE,\n+\n+    /** Only solutions that are greater than or equal to the actual root are\n+     * acceptable as solutions for root-finding. In other words,\n+     * under-approximations are not allowed. So, if a function f(x) has a root\n+     * at x = y, then the root-finding result s must satisfy s &gt;= y.\n+     */\n+    RIGHT_SIDE;\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.\n      *\n+     * @param maxEval Maximum number of evaluations.\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n-     * @param maxEval Maximum number of evaluations.\n      * @return a value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.\n      *\n+     * @param maxEval Maximum number of evaluations.\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n-     * @param maxEval Maximum number of evaluations.\n      * @return a value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedSolution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/** Interface for {@link UnivariateRealSolver (univariate real) root-finding\n+ * algorithms} that maintain a bracketed solution. There are several advantages\n+ * to having such root-finding algorithms:\n+ * <ul>\n+ *  <li>The bracketed solution guarantees that the root is kept within the\n+ *      interval. As such, these algorithms generally also guarantee\n+ *      convergence.</li>\n+ *  <li>The bracketed solution means that we have the opportunity to only\n+ *      return roots that are greater than or equal to the actual root, or\n+ *      are less than or equal to the actual root. That is, we can control\n+ *      whether under-approximations and over-approximations are\n+ *      {@link AllowedSolutions allowed solutions}. Other root-finding\n+ *      algorithms can usually only guarantee that the solution (the root that\n+ *      was found) is around the actual root.</li>\n+ * </ul>\n+ *\n+ * <p>For backwards compatibility, all root-finding algorithms must have\n+ * {@link AllowedSolutions#EITHER_SIDE EITHER_SIDE} as default for the allowed\n+ * solutions.</p>\n+ *\n+ * @see AllowedSolutions\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface BracketedSolution {\n+    /** Returns the kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     *\n+     * @return the kind of solutions that the root-finding algorithm may\n+     * accept as solutions\n+     */\n+    AllowedSolutions getAllowedSolutions();\n+\n+    /** Sets the kind of solutions that the root-finding algorithm may accept\n+     * as solutions.\n+     *\n+     * @param allowedSolutions the kind of solutions that the root-finding\n+     * algorithm may accept as solutions\n+     */\n+    void setAllowedSolutions(AllowedSolutions allowedSolutions);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Implements the <em>Illinois</em> method for root-finding (approximating\n+ * a zero of a univariate real function). It is a modified\n+ * {@link RegulaFalsiSolver <em>Regula Falsi</em>} method.\n+ *\n+ * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n+ * maintaining a bracketed solution. The <em>Illinois</em> method however,\n+ * should converge much faster than the original <em>Regula Falsi</em>\n+ * method.</p>\n+ *\n+ * <p>The <em>Illinois</em> method assumes that the function is continuous,\n+ * but not necessarily smooth.</p>\n+ *\n+ * <p>Implementation based on the following article: M. Dowell and P. Jarratt,\n+ * <em>A modified regula falsi method for computing the root of an\n+ * equation</em>, BIT Numerical Mathematics, volume 11, number 2,\n+ * pages 168-174, Springer, 1971.</p>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class IllinoisSolver extends SecantBase implements BracketedSolution {\n+    /** Construct a solver with default accuracy (1e-6). */\n+    public IllinoisSolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY, Method.ILLINOIS);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public IllinoisSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy, Method.ILLINOIS);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public IllinoisSolver(final double relativeAccuracy,\n+                          final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, Method.ILLINOIS);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public AllowedSolutions getAllowedSolutions() {\n+        return allowedSolutions;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n+        this.allowedSolutions = allowedSolutions;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Implements the <em>Pegasus</em> method for root-finding (approximating\n+ * a zero of a univariate real function). It is a modified\n+ * {@link RegulaFalsiSolver <em>Regula Falsi</em>} method.\n+ *\n+ * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n+ * maintaining a bracketed solution. The <em>Pegasus</em> method however,\n+ * should converge much faster than the original <em>Regula Falsi</em> method.\n+ * Furthermore, it should converge faster than the\n+ * {@link IllinoisSolver <em>Illinois</em>} method, another\n+ * <em>Regula Falsi</em>-based method.</p>\n+ *\n+ * <p>The <em>Pegasus</em> method assumes that the function is continuous,\n+ * but not necessarily smooth.</p>\n+ *\n+ * <p>Implementation based on the following article: M. Dowell and P. Jarratt,\n+ * <em>The \"Pegasus\" method for computing the root of an equation</em>,\n+ * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,\n+ * 1972.</p>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PegasusSolver extends SecantBase implements BracketedSolution {\n+    /** Construct a solver with default accuracy (1e-6). */\n+    public PegasusSolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY, Method.PEGASUS);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public PegasusSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy, Method.PEGASUS);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public PegasusSolver(final double relativeAccuracy,\n+                         final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, Method.PEGASUS);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public AllowedSolutions getAllowedSolutions() {\n+        return allowedSolutions;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n+        this.allowedSolutions = allowedSolutions;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Implements the <em>Regula Falsi</em> or <em>False position</em> method for\n+ * root-finding (approximating a zero of a univariate real function). It is a\n+ * modified {@link SecantSolver <em>Secant</em>} method. Unlike the\n+ * <em>Secant</em> method, convergence is guaranteed by maintaining a\n+ * {@link BracketedSolution bracketed solution}.\n+ *\n+ * <p>The <em>Regula Falsi</em> method assumes that the function is continuous,\n+ * but not necessarily smooth.</p>\n+ *\n+ * <p>Implementation based on the following article: M. Dowell and P. Jarratt,\n+ * <em>A modified regula falsi method for computing the root of an\n+ * equation</em>, BIT Numerical Mathematics, volume 11, number 2,\n+ * pages 168-174, Springer, 1971.</p>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class RegulaFalsiSolver extends SecantBase implements BracketedSolution {\n+    /** Construct a solver with default accuracy (1e-6). */\n+    public RegulaFalsiSolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public RegulaFalsiSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy, Method.REGULA_FALSI);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     */\n+    public RegulaFalsiSolver(final double relativeAccuracy,\n+                             final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, Method.REGULA_FALSI);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public AllowedSolutions getAllowedSolutions() {\n+        return allowedSolutions;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setAllowedSolutions(final AllowedSolutions allowedSolutions) {\n+        this.allowedSolutions = allowedSolutions;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathInternalError;\n+\n+/**\n+ * Base class for all <em>Secant</em>-based methods for root-finding\n+ * (approximating a zero of a univariate real function).\n+ *\n+ * <p>Implementation of the {@link SecantSolver <em>Secant</em>},\n+ * {@link RegulaFalsiSolver <em>Regula Falsi</em>}, and\n+ * {@link IllinoisSolver <em>Illinois</em>} methods is based on the\n+ * following article: M. Dowell and P. Jarratt,\n+ * <em>A modified regula falsi method for computing the root of an\n+ * equation</em>, BIT Numerical Mathematics, volume 11, number 2,\n+ * pages 168-174, Springer, 1971.</p>\n+ *\n+ * <p>Implementation of the {@link PegasusSolver <em>Pegasus</em>} method is\n+ * based on the following article: M. Dowell and P. Jarratt,\n+ * <em>The \"Pegasus\" method for computing the root of an equation</em>,\n+ * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,\n+ * 1972.</p>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class SecantBase extends AbstractUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+    /** The kinds of solutions that the algorithm may accept. */\n+    protected AllowedSolutions allowedSolutions = AllowedSolutions.EITHER_SIDE;\n+    /** The <em>Secant</em>-based root-finding method to use. */\n+    private final Method method;\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method <em>Secant</em>-based root-finding method to use\n+     */\n+    protected SecantBase(final double absoluteAccuracy, final Method method) {\n+        super(absoluteAccuracy);\n+        this.method = method;\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n+     * @param method <em>Secant</em>-based root-finding method to use\n+     */\n+    protected SecantBase(final double relativeAccuracy,\n+                         final double absoluteAccuracy,\n+                         final Method method) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+        this.method = method;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected final double doSolve() {\n+        // Get initial solution\n+        double x0 = getMin();\n+        double x1 = getMax();\n+        double f0 = computeObjectiveValue(x0);\n+        double f1 = computeObjectiveValue(x1);\n+\n+        // If one of the bounds is the exact root, return it. Since these are\n+        // not under-approximations or over-approximations, we can return them\n+        // regardless of the allowed solutions.\n+        if (f0 == 0.0) return x0;\n+        if (f1 == 0.0) return x1;\n+\n+        // Verify bracketing of initial solution.\n+        verifyBracketing(x0, x1);\n+\n+        // Get accuracies.\n+        final double ftol = getFunctionValueAccuracy();\n+        final double atol = getAbsoluteAccuracy();\n+        final double rtol = getRelativeAccuracy();\n+\n+        // Variables to hold new bounds.\n+        double x;\n+        double fx;\n+\n+        // Keep track of inverted intervals, meaning that the left bound is\n+        // larger than the right bound. Not used for the original Secant\n+        // method.\n+        boolean inverted = false;\n+\n+        // Keep finding better approximations.\n+        while (true) {\n+            // Calculate the next approximation.\n+            x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+            fx = computeObjectiveValue(x);\n+\n+            // If the new approximation is the exact root, return it. Since\n+            // this is not an under-approximation or an over-approximation,\n+            // we can return it regardless of the allowed solutions.\n+            if (fx == 0.0) return x;\n+\n+            // Update the bounds with the new approximation.\n+            if (method == Method.SECANT) {\n+                x0 = x1;\n+                f0 = f1;\n+                x1 = x;\n+                f1 = fx;\n+            } else if (f1 * fx < 0) {\n+                // We had [x0..x1]. We update it to [x1, x]. Note that the\n+                // value of x1 has switched to the other bound, thus inverting\n+                // the interval.\n+                x0 = x1;\n+                f0 = f1;\n+                x1 = x;\n+                f1 = fx;\n+                inverted = !inverted;\n+            } else {\n+                // We had [x0..x1]. We update it to [x0, x].\n+                if (method == Method.ILLINOIS) f0 *= 0.5;\n+                if (method == Method.PEGASUS) f0 *= f1 / (f1 + fx);\n+                x1 = x;\n+                f1 = fx;\n+            }\n+\n+            // If the function value of the last approximation is too small,\n+            // given the function value accuracy, then we can't get close to\n+            // the root than we already are.\n+            if (FastMath.abs(f1) <= ftol) {\n+                switch (allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    if (inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case RIGHT_SIDE:\n+                    if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n+                }\n+            }\n+\n+            // If the current interval is within the given accuracies, we\n+            // are satisfied with the current approximation.\n+            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n+                                                     atol)) {\n+                switch (allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    return inverted ? x1 : x0;\n+                case RIGHT_SIDE:\n+                    return inverted ? x0 : x1;\n+                default:\n+                    throw new MathInternalError();\n+                }\n+            }\n+        }\n+    }\n+\n+    /** <em>Secant</em>-based root-finding methods. */\n+    protected enum Method {\n+        /** The original {@link SecantSolver <em>Secant</em>} method. */\n+        SECANT,\n+\n+        /**\n+         * The {@link RegulaFalsiSolver <em>Regula Falsi</em>} or\n+         * <em>False Position</em> method.\n+         */\n+        REGULA_FALSI,\n+\n+        /** The {@link IllinoisSolver <em>Illinois</em>} method. */\n+        ILLINOIS,\n+\n+        /** The {@link PegasusSolver <em>Pegasus</em>} method. */\n+        PEGASUS,\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.exception.NoBracketingException;\n-import org.apache.commons.math.util.FastMath;\n-\n-\n /**\n- * Implements a modified version of the\n- * <a href=\"http://mathworld.wolfram.com/SecantMethod.html\">secant method</a>\n- * for approximating a zero of a real univariate function.\n- * <p>\n- * The algorithm is modified to maintain bracketing of a root by successive\n- * approximations. Because of forced bracketing, convergence may be slower than\n- * the unrestricted secant algorithm. However, this implementation should in\n- * general outperform the\n- * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n- * regula falsi method.</a></p>\n- * <p>\n- * The function is assumed to be continuous but not necessarily smooth.</p>\n+ * Implements the <em>Secant</em> method for root-finding (approximating a\n+ * zero of a univariate real function). The solution that is maintained is\n+ * not bracketed, and as such convergence is not guaranteed.\n+ *\n+ * <p>Implementation based on the following article: M. Dowell and P. Jarratt,\n+ * <em>A modified regula falsi method for computing the root of an\n+ * equation</em>, BIT Numerical Mathematics, volume 11, number 2,\n+ * pages 168-174, Springer, 1971.</p>\n+ *\n+ * <p>Note that since release 3.0 this class implements the actual\n+ * <em>Secant</em> algorithm, and not a modified one. As such, the 3.0 version\n+ * is not backwards compatible with previous versions. To use an algorithm\n+ * similar to the pre-3.0 releases, use the\n+ * {@link IllinoisSolver <em>Illinois</em>} algorithm or the\n+ * {@link PegasusSolver <em>Pegasus</em>} algorithm.</p>\n  *\n  * @version $Id$\n  */\n-public class SecantSolver extends AbstractUnivariateRealSolver {\n-    /** Default absolute accuracy. */\n-    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+public class SecantSolver extends SecantBase {\n+    /** Construct a solver with default accuracy (1e-6). */\n+    public SecantSolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY, Method.SECANT);\n+    }\n \n-    /**\n-     * Construct a solver with default accuracy (1e-6).\n-     */\n-    public SecantSolver() {\n-        this(DEFAULT_ABSOLUTE_ACCURACY);\n-    }\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy Absolute accuracy.\n+     * @param absoluteAccuracy absolute accuracy\n      */\n-    public SecantSolver(double absoluteAccuracy) {\n-        super(absoluteAccuracy);\n+    public SecantSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy, Method.SECANT);\n     }\n+\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy Relative accuracy.\n-     * @param absoluteAccuracy Absolute accuracy.\n+     * @param relativeAccuracy relative accuracy\n+     * @param absoluteAccuracy absolute accuracy\n      */\n-    public SecantSolver(double relativeAccuracy,\n-                        double absoluteAccuracy) {\n-        super(relativeAccuracy, absoluteAccuracy);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected double doSolve() {\n-        double min = getMin();\n-        double max = getMax();\n-        verifyInterval(min, max);\n-\n-        final double functionValueAccuracy = getFunctionValueAccuracy();\n-\n-        // Index 0 is the old approximation for the root.\n-        // Index 1 is the last calculated approximation  for the root.\n-        // Index 2 is a bracket for the root with respect to x0.\n-        // OldDelta is the length of the bracketing interval of the last\n-        // iteration.\n-        double x0 = min;\n-        double x1 = max;\n-\n-        double y0 = computeObjectiveValue(x0);\n-        // return the first endpoint if it is good enough\n-        if (FastMath.abs(y0) <= functionValueAccuracy) {\n-            return x0;\n-        }\n-\n-        // return the second endpoint if it is good enough\n-        double y1 = computeObjectiveValue(x1);\n-        if (FastMath.abs(y1) <= functionValueAccuracy) {\n-            return x1;\n-        }\n-\n-        // Verify bracketing\n-        if (y0 * y1 >= 0) {\n-            throw new NoBracketingException(min, max, y0, y1);\n-        }\n-\n-        final double absoluteAccuracy = getAbsoluteAccuracy();\n-        final double relativeAccuracy = getRelativeAccuracy();\n-\n-        double x2 = x0;\n-        double y2 = y0;\n-        double oldDelta = x2 - x1;\n-        while (true) {\n-            if (FastMath.abs(y2) < FastMath.abs(y1)) {\n-                x0 = x1;\n-                x1 = x2;\n-                x2 = x0;\n-                y0 = y1;\n-                y1 = y2;\n-                y2 = y0;\n-            }\n-            if (FastMath.abs(y1) <= functionValueAccuracy) {\n-                return x1;\n-            }\n-            if (FastMath.abs(oldDelta) < FastMath.max(relativeAccuracy * FastMath.abs(x1),\n-                                                      absoluteAccuracy)) {\n-                return x1;\n-            }\n-            double delta;\n-            if (FastMath.abs(y1) > FastMath.abs(y0)) {\n-                // Function value increased in last iteration. Force bisection.\n-                delta = 0.5 * oldDelta;\n-            } else {\n-                delta = (x0 - x1) / (1 - y0 / y1);\n-                if (delta / oldDelta > 1) {\n-                    // New approximation falls outside bracket.\n-                    // Fall back to bisection.\n-                    delta = 0.5 * oldDelta;\n-                }\n-            }\n-            x0 = x1;\n-            y0 = y1;\n-            x1 = x1 + delta;\n-            y1 = computeObjectiveValue(x1);\n-            if ((y1 > 0) == (y2 > 0)) {\n-                // New bracket is (x0,x1).\n-                x2 = x0;\n-                y2 = y0;\n-            }\n-            oldDelta = x2 - x1;\n-        }\n+    public SecantSolver(final double relativeAccuracy,\n+                        final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, Method.SECANT);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/XMinus5Function.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Auxiliary class for testing solvers.\n+ *\n+ * @version $Id$\n+ */\n+public class XMinus5Function implements DifferentiableUnivariateRealFunction {\n+\n+    /* Evaluate x - 5 fuction.\n+     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) {\n+        return x - 5;\n+    }\n+\n+    /* First derivative of x - 5 function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) {\n+                return 1.0;\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Test case for {@link IllinoisSolver Illinois} solver.\n+ *\n+ * @version $Id$\n+ */\n+public final class IllinoisSolverTest extends SecantBaseTest {\n+    /** {@inheritDoc} */\n+    protected UnivariateRealSolver getSolver() {\n+        return new IllinoisSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected int[] getQuinticEvalCounts() {\n+        return new int[] {3, 7, 9, 10, 10, 10, 12, 12, 14, 15, 20};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Test case for {@link PegasusSolver Pegasus} solver.\n+ *\n+ * @version $Id$\n+ */\n+public final class PegasusSolverTest extends SecantBaseTest {\n+    /** {@inheritDoc} */\n+    protected UnivariateRealSolver getSolver() {\n+        return new PegasusSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected int[] getQuinticEvalCounts() {\n+        return new int[] {3, 7, 9, 8, 9, 8, 10, 10, 12, 16, 18};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Test case for {@link RegulaFalsiSolver Regula Falsi} solver.\n+ *\n+ * @version $Id$\n+ */\n+public final class RegulaFalsiSolverTest extends SecantBaseTest {\n+    /** {@inheritDoc} */\n+    protected UnivariateRealSolver getSolver() {\n+        return new RegulaFalsiSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected int[] getQuinticEvalCounts() {\n+        // While the Regula Falsi method guarantees convergence, convergence\n+        // may be extremely slow. The last test case does not converge within\n+        // even a million iterations. As such, it was disabled.\n+        return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantBaseTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.XMinus5Function;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Base class for {@link SecantBase} derived root-finding algorithms tests.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class SecantBaseTest {\n+    /** Returns the solver to use to perform the tests.\n+     * @return the solver to use to perform the tests\n+     */\n+    protected abstract UnivariateRealSolver getSolver();\n+\n+    /** Returns the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that\n+     * the test should be skipped for that solver.\n+     * @return the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test\n+     */\n+    protected abstract int[] getQuinticEvalCounts();\n+\n+    @Test\n+    public void testSinZero() {\n+        // The sinus function is behaved well around the root at pi. The second\n+        // order derivative is zero, which means linear approximating methods\n+        // still converge quadratically.\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+\n+        result = solver.solve(100, f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 6);\n+        result = solver.solve(100, f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n+    }\n+\n+    @Test\n+    public void testQuinticZero() {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second\n+        // derivative of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1,\n+        // because the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613\n+        // and 0.82221643, intervals containing these values are harder for\n+        // the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+        double atol = solver.getAbsoluteAccuracy();\n+        int[] counts = getQuinticEvalCounts();\n+\n+        // Tests data: initial bounds, and expected solution, per test case.\n+        double[][] testsData = {{-0.2,  0.2,  0.0},\n+                                {-0.1,  0.3,  0.0},\n+                                {-0.3,  0.45, 0.0},\n+                                { 0.3,  0.7,  0.5},\n+                                { 0.2,  0.6,  0.5},\n+                                { 0.05, 0.95, 0.5},\n+                                { 0.85, 1.25, 1.0},\n+                                { 0.8,  1.2,  1.0},\n+                                { 0.85, 1.75, 1.0},\n+                                { 0.55, 1.45, 1.0},\n+                                { 0.85, 5.0,  1.0},\n+                               };\n+        int maxIter = 500;\n+\n+        for(int i = 0; i < testsData.length; i++) {\n+            // Skip test, if needed.\n+            if (counts[i] == -1) continue;\n+\n+            // Compute solution.\n+            double[] testData = testsData[i];\n+            result = solver.solve(maxIter, f, testData[0], testData[1]);\n+            //System.out.println(\n+            //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+\n+            // Check solution.\n+            Assert.assertEquals(result, testData[2], atol);\n+            Assert.assertTrue(solver.getEvaluations() <= counts[i] + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testRootEndpoints() {\n+        UnivariateRealFunction f = new XMinus5Function();\n+        UnivariateRealSolver solver = getSolver();\n+\n+        // End-point is root. This should be a special case in the solver, and\n+        // the initial end-point should be returned exactly.\n+        double result = solver.solve(100, f, 5.0, 6.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 5.0, 6.0, 5.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0, 4.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+    }\n+\n+    @Test\n+    public void testBadEndpoints() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        try {  // bad interval\n+            solver.solve(100, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5, 1.2);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionLeftSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(\n+                                                AllowedSolutions.LEFT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution <= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionRightSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(\n+                                                AllowedSolutions.RIGHT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution >= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.analysis.QuinticFunction;\n-import org.apache.commons.math.analysis.SinFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.NumberIsTooLargeException;\n-import org.apache.commons.math.exception.NoBracketingException;\n-import org.apache.commons.math.util.FastMath;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n /**\n- * Test case for {@link SecantSolver}.\n+ * Test case for {@link SecantSolver Secant} solver.\n  *\n  * @version $Id$\n  */\n-public final class SecantSolverTest {\n-    @Test\n-    public void testSinZero() {\n-        // The sinus function is behaved well around the root at pi. The second\n-        // order derivative is zero, which means linar approximating methods will\n-        // still converge quadratically.\n-        UnivariateRealFunction f = new SinFunction();\n-        double result;\n-        UnivariateRealSolver solver = new SecantSolver();\n-\n-        result = solver.solve(100, f, 3, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 6);\n-        result = solver.solve(100, f, 1, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 7);\n+public final class SecantSolverTest extends SecantBaseTest {\n+    /** {@inheritDoc} */\n+    protected UnivariateRealSolver getSolver() {\n+        return new SecantSolver();\n     }\n \n-    @Test\n-    public void testQuinticZero() {\n-        // The quintic function has zeros at 0, +-0.5 and +-1.\n-        // Around the root of 0 the function is well behaved, with a second derivative\n-        // of zero a 0.\n-        // The other roots are less well to find, in particular the root at 1, because\n-        // the function grows fast for x>1.\n-        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n-        // intervals containing these values are harder for the solvers.\n-        UnivariateRealFunction f = new QuinticFunction();\n-        double result;\n-        // Brent-Dekker solver.\n-        UnivariateRealSolver solver = new SecantSolver();\n-        result = solver.solve(100, f, -0.2, 0.2);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 3);\n-        result = solver.solve(100, f, -0.1, 0.3);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 7);\n-        result = solver.solve(100, f, -0.3, 0.45);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 8);\n-        result = solver.solve(100, f, 0.3, 0.7);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 9);\n-        result = solver.solve(100, f, 0.2, 0.6);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 8);\n-        result = solver.solve(100, f, 0.05, 0.95);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 10);\n-        result = solver.solve(100, f, 0.85, 1.25);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 12);\n-        result = solver.solve(100, f, 0.8, 1.2);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 10);\n-        result = solver.solve(100, f, 0.85, 1.75);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 16);\n-        // The followig is especially slow because the solver first has to reduce\n-        // the bracket to exclude the extremum. After that, convergence is rapide.\n-        result = solver.solve(100, f, 0.55, 1.45);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 9);\n-        result = solver.solve(100, f, 0.85, 5);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n-        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        Assert.assertTrue(solver.getEvaluations() <= 16);\n-    }\n-\n-    @Test\n-    public void testRootEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n-        SecantSolver solver = new SecantSolver();\n-\n-        // endpoint is root\n-        double result = solver.solve(100, f, FastMath.PI, 4);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(100, f, 3, FastMath.PI);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(100, f, FastMath.PI, 4, 3.5);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(100, f, 3, FastMath.PI, 3.07);\n-        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-    }\n-\n-    @Test\n-    public void testBadEndpoints() {\n-        UnivariateRealFunction f = new SinFunction();\n-        SecantSolver solver = new SecantSolver();\n-        try {  // bad interval\n-            solver.solve(100, f, 1, -1);\n-            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n-        } catch (NumberIsTooLargeException ex) {\n-            // expected\n-        }\n-        try {  // no bracket\n-            solver.solve(100, f, 1, 1.5);\n-            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n-        } catch (NoBracketingException ex) {\n-            // expected\n-        }\n-        try {  // no bracket\n-            solver.solve(100, f, 1, 1.5, 1.2);\n-            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n-        } catch (NoBracketingException ex) {\n-            // expected\n-        }\n+    /** {@inheritDoc} */\n+    protected int[] getQuinticEvalCounts() {\n+        // As the Secant method does not maintain a bracketed solution,\n+        // convergence is not guaranteed. Two test cases are disabled (-1) due\n+        // to bad solutions.\n+        return new int[] {3, 7, -1, 8, 9, 8, 11, 12, 14, -1, 16};\n     }\n }", "timestamp": 1308874337, "metainfo": ""}