{"sha": "fc871d745753842f01d52e0be4763e0de6af0cfc", "log": "In o.a.c.m.transform, introduced an enumeration for the type (forward, inverse) of transform asked by the user (MATH-743).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n+import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n             t1 += c;\n         }\n         FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.STANDARD);\n-        Complex[] y = transformer.transform(x);\n+        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n+        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n \n         // reconstruct the FCT result for the original array\n         transformed[0] = y[0].getReal();\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  */\n public class FastFourierTransformer implements Serializable {\n \n-    /** The various types of normalizations that can be applied. */\n-    public static enum Normalization {\n-        /** Standard DFT. */\n+    /**\n+     * The various types of normalizations that can be applied to discrete\n+     * Fourier transforms.\n+     *\n+     * @see FastFourierTransformer\n+     */\n+    public static enum DftNormalization {\n+        /** The normalization to be specified for standard DFT. */\n         STANDARD,\n \n-        /** Unitary DFT. */\n+        /** The normalization to be specified for unitary DFT. */\n         UNITARY;\n     }\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120902L;\n+    static final long serialVersionUID = 20120210L;\n \n     /**\n      * {@code W_SUB_N_R[i]} is the real part of\n             , -0x1.921fb54442d18p-54, -0x1.921fb54442d18p-55, -0x1.921fb54442d18p-56, -0x1.921fb54442d18p-57\n             , -0x1.921fb54442d18p-58, -0x1.921fb54442d18p-59, -0x1.921fb54442d18p-60 };\n \n-    /**\n-     * The type of DFT to be performed.\n-     */\n-    private final Normalization type;\n+    /** The type of DFT to be performed. */\n+    private final DftNormalization normalization;\n \n     /**\n      * Creates a new instance of this class, with various normalization\n      * conventions.\n      *\n-     * @param type the type of transform to be computed\n-     */\n-    public FastFourierTransformer(final Normalization type) {\n-        this.type = type;\n+     * @param normalization the type of normalization to be applied to the\n+     * transformed data\n+     */\n+    public FastFourierTransformer(final DftNormalization normalization) {\n+        this.normalization = normalization;\n     }\n \n     /**\n      * Applies the proper normalization to the specified transformed data.\n      *\n      * @param dataRI the unscaled transformed data\n-     * @param type the type of transform\n-     * @param inverse {@code true} if normalization should be performed for the\n-     * inverse transform\n+     * @param normalization the normalization to be applied\n+     * @param type the type of transform (forward, inverse) which resulted in the\n+     * specified data\n      */\n     private static void normalizeTransformedData(final double[][] dataRI,\n-        final Normalization type, final boolean inverse) {\n+        final DftNormalization normalization, final TransformType type) {\n \n         final double[] dataR = dataRI[0];\n         final double[] dataI = dataRI[1];\n         final int n = dataR.length;\n         assert dataI.length == n;\n \n-        switch (type) {\n+        switch (normalization) {\n             case STANDARD:\n-                if (inverse) {\n+                if (type == TransformType.INVERSE) {\n                     final double scaleFactor = 1.0 / ((double) n);\n                     for (int i = 0; i < n; i++) {\n                         dataR[i] *= scaleFactor;\n      *\n      * @param dataRI the two dimensional array of real and imaginary parts of\n      * the data\n-     * @param type the type of normalization to be applied to the transformed\n+     * @param normalization the normalization to be applied to the transformed\n      * data\n-     * @param inverse {@code true} if the inverse standard transform must be\n-     * performed\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @throws DimensionMismatchException if the number of rows of the specified\n      * array is not two, or the array is not rectangular\n      * @throws MathIllegalArgumentException if the number of data points is not\n      * a power of two\n      */\n     public static void transformInPlace(final double[][] dataRI,\n-        final Normalization type, final boolean inverse) throws\n-        DimensionMismatchException, MathIllegalArgumentException {\n+        final DftNormalization normalization, final TransformType type) {\n \n         if (dataRI.length != 2) {\n             throw new DimensionMismatchException(dataRI.length, 2);\n             dataR[1] = srcR0 - srcR1;\n             dataI[1] = srcI0 - srcI1;\n \n-            normalizeTransformedData(dataRI, type, inverse);\n+            normalizeTransformedData(dataRI, normalization, type);\n             return;\n         }\n \n         bitReversalShuffle2(dataR, dataI);\n \n         // Do 4-term DFT.\n-        if (inverse) {\n+        if (type == TransformType.INVERSE) {\n             for (int i0 = 0; i0 < n; i0 += 4) {\n                 final int i1 = i0 + 1;\n                 final int i2 = i0 + 2;\n             int logN0 = lastLogN0 + 1;\n             double wSubN0R = W_SUB_N_R[logN0];\n             double wSubN0I = W_SUB_N_I[logN0];\n-            if (inverse) {\n+            if (type == TransformType.INVERSE) {\n                 wSubN0I = -wSubN0I;\n             }\n \n             lastLogN0 = logN0;\n         }\n \n-        normalizeTransformedData(dataRI, type, inverse);\n-    }\n-\n-    /**\n-     * Returns the forward transform of the specified real data set.\n+        normalizeTransformedData(dataRI, normalization, type);\n+    }\n+\n+    /**\n+     * Returns the (forward, inverse) transform of the specified real data set.\n      *\n      * @param f the real data array to be transformed\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] transform(double[] f) {\n+    public Complex[] transform(final double[] f, final TransformType type) {\n         final double[][] dataRI = new double[][] {\n             MathArrays.copyOf(f, f.length), new double[f.length]\n         };\n \n-        transformInPlace(dataRI, type, false);\n-\n-//        if (unitary) {\n-//            final double s = 1.0 / FastMath.sqrt(f.length);\n-//            TransformUtils.scaleArray(dataRI[0], s);\n-//            TransformUtils.scaleArray(dataRI[1], s);\n-//        }\n+        transformInPlace(dataRI, normalization, type);\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n \n     /**\n-     * Returns the forward transform of the specified real function, sampled on\n-     * the specified interval.\n+     * Returns the (forward, inverse) transform of the specified real function,\n+     * sampled on the specified interval.\n      *\n      * @param f the function to be sampled and transformed\n      * @param min the (inclusive) lower bound for the interval\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n      * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n      * if the lower bound is greater than, or equal to the upper bound\n      * @throws MathIllegalArgumentException if the number of sample points\n      * {@code n} is not a power of two\n      */\n-    public Complex[] transform(UnivariateFunction f,\n-            double min, double max, int n) {\n+    public Complex[] transform(final UnivariateFunction f,\n+            final double min, final double max, final int n,\n+            final TransformType type) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n-        return transform(data);\n-    }\n-\n-    /**\n-     * Returns the forward transform of the specified complex data set.\n+        return transform(data, type);\n+    }\n+\n+    /**\n+     * Returns the (forward, inverse) transform of the specified complex data\n+     * set.\n      *\n      * @param f the complex data array to be transformed\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return the complex transformed array\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] transform(Complex[] f) {\n+    public Complex[] transform(final Complex[] f, final TransformType type) {\n         final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n \n-        transformInPlace(dataRI, type, false);\n-        // if (unitary) {\n-        // final double s = 1.0 / FastMath.sqrt(f.length);\n-        // TransformUtils.scaleArray(dataRI[0], s);\n-        // TransformUtils.scaleArray(dataRI[1], s);\n-        // }\n-\n-        return TransformUtils.createComplexArray(dataRI);\n-    }\n-\n-    /**\n-     * Returns the inverse transform of the specified real data set.\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the complex inversely transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n-     */\n-    public Complex[] inverseTransform(double[] f) {\n-        final double[][] dataRI = new double[][] {\n-            MathArrays.copyOf(f, f.length), new double[f.length]\n-        };\n-\n-        transformInPlace(dataRI, type, true);\n-        // if (unitary) {\n-        // final double s = FastMath.sqrt(f.length);\n-        // TransformUtils.scaleArray(dataRI[0], s);\n-        // TransformUtils.scaleArray(dataRI[1], s);\n-        // }\n-\n-        return TransformUtils.createComplexArray(dataRI);\n-    }\n-\n-    /**\n-     * Returns the inverse transform of the specified real function, sampled\n-     * on the given interval.\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the (inclusive) lower bound for the interval\n-     * @param max the (exclusive) upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the complex inversely transformed array\n-     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n-     * if the lower bound is greater than, or equal to the upper bound\n-     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n-     * if the number of sample points {@code n} is negative\n-     * @throws MathIllegalArgumentException if the number of sample points\n-     * {@code n} is not a power of two\n-     */\n-    public Complex[] inverseTransform(UnivariateFunction f,\n-            double min, double max, int n) {\n-        final double[] data = FunctionUtils.sample(f, min, max, n);\n-        return inverseTransform(data);\n-    }\n-\n-    /**\n-     * Returns the inverse transform of the specified complex data set.\n-     *\n-     * @param f the complex data array to be inversely transformed\n-     * @return the complex inversely transformed array\n-     * @throws MathIllegalArgumentException if the length of the data array is\n-     * not a power of two\n-     */\n-    public Complex[] inverseTransform(Complex[] f) {\n-        final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n-        final double[] dataR = dataRI[0];\n-        final double[] dataI = dataRI[1];\n-\n-        transformInPlace(dataRI, type, true);\n-//        if (unitary) {\n-//            final double s = FastMath.sqrt(f.length);\n-//            TransformUtils.scaleArray(dataR, s);\n-//            TransformUtils.scaleArray(dataI, s);\n-//        }\n+        transformInPlace(dataRI, normalization, type);\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n      *\n      * @param mdca Multi-Dimensional Complex Array id est\n      * {@code Complex[][][][]}\n-     * @param forward {@link #inverseTransform} is performed if this is\n-     * {@code false}\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @return transform of {@code mdca} as a Multi-Dimensional Complex Array\n      * id est {@code Complex[][][][]}\n      * @throws IllegalArgumentException if any dimension is not a power of two\n-     */\n-    public Object mdfft(Object mdca, boolean forward) {\n+     * @deprecated see MATH-736\n+     */\n+    @Deprecated\n+    public Object mdfft(Object mdca, TransformType type) {\n         MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n                 new MultiDimensionalComplexMatrix(mdca).clone();\n         int[] dimensionSize = mdcm.getDimensionSizes();\n         //cycle through each dimension\n         for (int i = 0; i < dimensionSize.length; i++) {\n-            mdfft(mdcm, forward, i, new int[0]);\n+            mdfft(mdcm, type, i, new int[0]);\n         }\n         return mdcm.getArray();\n     }\n      * Performs one dimension of a multi-dimensional Fourier transform.\n      *\n      * @param mdcm input matrix\n-     * @param forward {@link #inverseTransform} is performed if this is\n-     * {@code false}\n+     * @param type the type of transform (forward, inverse) to be performed\n      * @param d index of the dimension to process\n      * @param subVector recursion subvector\n      * @throws IllegalArgumentException if any dimension is not a power of two\n-     */\n+     * @deprecated see MATH-736\n+     */\n+    @Deprecated\n     private void mdfft(MultiDimensionalComplexMatrix mdcm,\n-            boolean forward, int d, int[] subVector) {\n+            TransformType type, int d, int[] subVector) {\n \n         int[] dimensionSize = mdcm.getDimensionSizes();\n         //if done\n                 temp[i] = mdcm.get(subVector);\n             }\n \n-            if (forward) {\n-                temp = transform(temp);\n-            } else {\n-                temp = inverseTransform(temp);\n-            }\n+            temp = transform(temp, type);\n \n             for (int i = 0; i < dimensionSize[d]; i++) {\n                 subVector[d] = i;\n                 //value is not important once the recursion is done.\n                 //then an fft will be applied along the dimension d.\n                 vector[d] = 0;\n-                mdfft(mdcm, forward, d, vector);\n+                mdfft(mdcm, type, d, vector);\n             } else {\n                 for (int i = 0; i < dimensionSize[subVector.length]; i++) {\n                     vector[subVector.length] = i;\n                     //further split along the next dimension\n-                    mdfft(mdcm, forward, d, vector);\n+                    mdfft(mdcm, type, d, vector);\n                 }\n             }\n         }\n      * eventually be replaced by jsr-83 of the java community process\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n-     */\n+     *\n+     * @deprecated see MATH-736\n+     */\n+    @Deprecated\n     private static class MultiDimensionalComplexMatrix\n         implements Cloneable {\n \n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n+import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n             x[n - i] = a - b;\n         }\n         FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.STANDARD);\n-        Complex[] y = transformer.transform(x);\n+        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n+        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n \n         // reconstruct the FST result for the original array\n         transformed[0] = 0.0;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/TransformType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+/**\n+ * This enumeration defines the type of transform which is to be computed.\n+ *\n+ * @version $Id Revision$\n+ * @since 3.0\n+ */\n+public enum TransformType {\n+    /** The type to be specified for forward transforms. */\n+    FORWARD,\n+\n+    /** The type to be specified for inverse transforms. */\n+    INVERSE;\n+}\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n-import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n+import org.apache.commons.math.transform.FastFourierTransformer.DftNormalization;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     private final static long SEED = 20110111L;\n \n     /*\n-     * Precondition checks for standard transform.\n-     */\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardTransformComplexSizeNotAPowerOfTwo() {\n+     * Precondition checks.\n+     */\n+\n+    @Test\n+    public void testTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardTransformRealSizeNotAPowerOfTwo() {\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                final FastFourierTransformer fft;\n+                fft = new FastFourierTransformer(norm[i]);\n+                try {\n+                    fft.transform(x, type[j]);\n+                    Assert.fail(norm[i] + \", \" + type[j] +\n+                        \": MathIllegalArgumentException was expected\");\n+                } catch (MathIllegalArgumentException e) {\n+                    // Expected behaviour\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardTransformFunctionSizeNotAPowerOfTwo() {\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                final FastFourierTransformer fft;\n+                fft = new FastFourierTransformer(norm[i]);\n+                try {\n+                    fft.transform(x, type[j]);\n+                    Assert.fail(norm[i] + \", \" + type[j] +\n+                        \": MathIllegalArgumentException was expected\");\n+                } catch (MathIllegalArgumentException e) {\n+                    // Expected behaviour\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NotStrictlyPositiveException.class)\n-    public void testStandardTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                final FastFourierTransformer fft;\n+                fft = new FastFourierTransformer(norm[i]);\n+                try {\n+                    fft.transform(f, 0.0, Math.PI, n, type[j]);\n+                    Assert.fail(norm[i] + \", \" + type[j] +\n+                        \": MathIllegalArgumentException was expected\");\n+                } catch (MathIllegalArgumentException e) {\n+                    // Expected behaviour\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NumberIsTooLargeException.class)\n-    public void testStandardTransformFunctionInvalidBounds() {\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                final FastFourierTransformer fft;\n+                fft = new FastFourierTransformer(norm[i]);\n+                try {\n+                    fft.transform(f, 0.0, Math.PI, n, type[j]);\n+                    fft.transform(f, 0.0, Math.PI, n, type[j]);\n+                    Assert.fail(norm[i] + \", \" + type[j] +\n+                        \": NotStrictlyPositiveException was expected\");\n+                } catch (NotStrictlyPositiveException e) {\n+                    // Expected behaviour\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(f, Math.PI, 0.0, n);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardInverseTransformComplexSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.inverseTransform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardInverseTransformRealSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final double[] x = createRealData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.inverseTransform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testStandardInverseTransformFunctionSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.inverseTransform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NotStrictlyPositiveException.class)\n-    public void testStandardInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n-        final int n = -128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.inverseTransform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NumberIsTooLargeException.class)\n-    public void testStandardInverseTransformFunctionInvalidBounds() {\n-        final int n = 128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.STANDARD);\n-        fft.transform(f, Math.PI, 0.0, n);\n-    }\n-\n-    /*\n-     * Precondition checks for unitary transform.\n-     */\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryTransformComplexSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryTransformRealSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final double[] x = createRealData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryTransformFunctionSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NotStrictlyPositiveException.class)\n-    public void testUnitaryTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n-        final int n = -128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NumberIsTooLargeException.class)\n-    public void testUnitaryTransformFunctionInvalidBounds() {\n-        final int n = 128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(f, Math.PI, 0.0, n);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryInverseTransformComplexSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.inverseTransform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryInverseTransformRealSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final double[] x = createRealData(n);\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.inverseTransform(x);\n-    }\n-\n-    @Test(expected = MathIllegalArgumentException.class)\n-    public void testUnitaryInverseTransformFunctionSizeNotAPowerOfTwo() {\n-        final int n = 127;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.inverseTransform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NotStrictlyPositiveException.class)\n-    public void testUnitaryInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n-        final int n = -128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.inverseTransform(f, 0.0, Math.PI, n);\n-    }\n-\n-    @Test(expected = NumberIsTooLargeException.class)\n-    public void testUnitaryInverseTransformFunctionInvalidBounds() {\n-        final int n = 128;\n-        final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft;\n-        fft = new FastFourierTransformer(Normalization.UNITARY);\n-        fft.transform(f, Math.PI, 0.0, n);\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                final FastFourierTransformer fft;\n+                fft = new FastFourierTransformer(norm[i]);\n+                try {\n+                    fft.transform(f, Math.PI, 0.0, n, type[j]);\n+                    Assert.fail(norm[i] + \", \" + type[j] +\n+                        \": NumberIsTooLargeException was expected\");\n+                } catch (NumberIsTooLargeException e) {\n+                    // Expected behaviour\n+                }\n+            }\n+        }\n     }\n \n     /*\n     }\n \n     private static void doTestTransformComplex(final int n, final double tol,\n-        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer.DftNormalization normalization,\n+        final TransformType type) {\n         final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = new FastFourierTransformer(Normalization.STANDARD);\n-        } else {\n-            fft = new FastFourierTransformer(Normalization.UNITARY);\n-        }\n+        fft = new FastFourierTransformer(normalization);\n         final Complex[] x = createComplexData(n);\n         final Complex[] expected;\n-        final Complex[] actual;\n         final double s;\n-        if (forward) {\n+        if (type==TransformType.FORWARD) {\n             expected = dft(x, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(x);\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD){\n+                s = 1.0;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n         } else {\n             expected = dft(x, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(x);\n-        }\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+                s = 1.0 / n;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n+        }\n+        final Complex[] actual = fft.transform(x, type);\n+        for (int i = 0; i < n; i++) {\n+            final String msg;\n+            msg = String.format(\"%s, %s, %d, %d\", normalization, type, n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformReal(final int n, final double tol,\n+        final FastFourierTransformer.DftNormalization normalization,\n+        final TransformType type) {\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(normalization);\n+        final double[] x = createRealData(n);\n+        final Complex[] xc = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            xc[i] = new Complex(x[i], 0.0);\n+        }\n+        final Complex[] expected;\n+        final double s;\n+        if (type == TransformType.FORWARD) {\n+            expected = dft(xc, -1);\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+                s = 1.0;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n+        } else {\n+            expected = dft(xc, 1);\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+                s = 1.0 / n;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n+        }\n+        final Complex[] actual = fft.transform(x, type);\n+        for (int i = 0; i < n; i++) {\n+            final String msg;\n+            msg = String.format(\"%s, %s, %d, %d\", normalization, type, n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformFunction(final UnivariateFunction f,\n+        final double min, final double max, int n, final double tol,\n+        final FastFourierTransformer.DftNormalization normalization,\n+        final TransformType type) {\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(normalization);\n+        final Complex[] x = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double t = min + i * (max - min) / n;\n+            x[i] = new Complex(f.value(t));\n+        }\n+        final Complex[] expected;\n+        final double s;\n+        if (type == TransformType.FORWARD) {\n+            expected = dft(x, -1);\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+                s = 1.0;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n+        } else {\n+            expected = dft(x, 1);\n+            if (normalization == FastFourierTransformer.DftNormalization.STANDARD) {\n+                s = 1.0 / n;\n+            } else {\n+                s = 1.0 / FastMath.sqrt(n);\n+            }\n+        }\n+        final Complex[] actual = fft.transform(f, min, max, n, type);\n         for (int i = 0; i < n; i++) {\n             final String msg = String.format(\"%d, %d\", n, i);\n             final double re = s * expected[i].getReal();\n         }\n     }\n \n-    private static void doTestTransformReal(final int n, final double tol,\n-        final boolean forward, final boolean standard) {\n-        final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = new FastFourierTransformer(Normalization.STANDARD);\n-        } else {\n-            fft = new FastFourierTransformer(Normalization.UNITARY);\n-        }\n-        final double[] x = createRealData(n);\n-        final Complex[] xc = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            xc[i] = new Complex(x[i], 0.0);\n-        }\n-        final Complex[] expected;\n-        final Complex[] actual;\n-        final double s;\n-        if (forward) {\n-            expected = dft(xc, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(x);\n-        } else {\n-            expected = dft(xc, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(x);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            final String msg = String.format(\"%d, %d\", n, i);\n-            final double re = s * expected[i].getReal();\n-            Assert.assertEquals(msg, re, actual[i].getReal(),\n-                tol * FastMath.abs(re));\n-            final double im = s * expected[i].getImaginary();\n-            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n-                FastMath.abs(re));\n-        }\n-    }\n-\n-    private static void doTestTransformFunction(final UnivariateFunction f,\n-        final double min, final double max, int n, final double tol,\n-        final boolean forward, final boolean standard) {\n-        final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = new FastFourierTransformer(Normalization.STANDARD);\n-        } else {\n-            fft = new FastFourierTransformer(Normalization.UNITARY);\n-        }\n-        final Complex[] x = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            final double t = min + i * (max - min) / n;\n-            x[i] = new Complex(f.value(t));\n-        }\n-        final Complex[] expected;\n-        final Complex[] actual;\n-        final double s;\n-        if (forward) {\n-            expected = dft(x, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(f, min, max, n);\n-        } else {\n-            expected = dft(x, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(f, min, max, n);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            final String msg = String.format(\"%d, %d\", n, i);\n-            final double re = s * expected[i].getReal();\n-            Assert.assertEquals(msg, re, actual[i].getReal(),\n-                tol * FastMath.abs(re));\n-            final double im = s * expected[i].getImaginary();\n-            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n-                FastMath.abs(re));\n-        }\n-    }\n-\n     /*\n      * Tests of standard transform (when data is valid).\n      */\n \n     @Test\n-    public void testStandardTransformComplex() {\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    public void testTransformComplex() {\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                doTestTransformComplex(2, 1.0E-15, norm[i], type[j]);\n+                doTestTransformComplex(4, 1.0E-14, norm[i], type[j]);\n+                doTestTransformComplex(8, 1.0E-14, norm[i], type[j]);\n+                doTestTransformComplex(16, 1.0E-13, norm[i], type[j]);\n+                doTestTransformComplex(32, 1.0E-13, norm[i], type[j]);\n+                doTestTransformComplex(64, 1.0E-12, norm[i], type[j]);\n+                doTestTransformComplex(128, 1.0E-12, norm[i], type[j]);\n+            }\n+        }\n     }\n \n     @Test\n     public void testStandardTransformReal() {\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-13, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                doTestTransformReal(2, 1.0E-15, norm[i], type[j]);\n+                doTestTransformReal(4, 1.0E-14, norm[i], type[j]);\n+                doTestTransformReal(8, 1.0E-14, norm[i], type[j]);\n+                doTestTransformReal(16, 1.0E-13, norm[i], type[j]);\n+                doTestTransformReal(32, 1.0E-13, norm[i], type[j]);\n+                doTestTransformReal(64, 1.0E-13, norm[i], type[j]);\n+                doTestTransformReal(128, 1.0E-11, norm[i], type[j]);\n+            }\n+        }\n     }\n \n     @Test\n         final UnivariateFunction f = new Sinc();\n         final double min = -FastMath.PI;\n         final double max = FastMath.PI;\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformComplex() {\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformReal() {\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-12, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    /*\n-     * Tests of unitary transform (when data is valid).\n-     */\n-\n-    @Test\n-    public void testUnitaryTransformComplex() {\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryTransformReal() {\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-13, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformComplex() {\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformComplex(2, 1.0E-14, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformReal() {\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-12, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+        final FastFourierTransformer.DftNormalization[] norm;\n+        norm = FastFourierTransformer.DftNormalization.values();\n+        final TransformType[] type;\n+        type = TransformType.values();\n+        for (int i = 0; i < norm.length; i++) {\n+            for (int j = 0; j < type.length; j++) {\n+                doTestTransformFunction(f, min, max, 2, 1.0E-15, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 4, 1.0E-14, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 8, 1.0E-14, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 16, 1.0E-13, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 32, 1.0E-13, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 64, 1.0E-12, norm[i], type[j]);\n+                doTestTransformFunction(f, min, max, 128, 1.0E-11, norm[i], type[j]);\n+            }\n+        }\n     }\n \n     /*\n     @Test\n     public void testAdHocData() {\n         FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.STANDARD);\n+        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n         Complex result[]; double tolerance = 1E-12;\n \n         double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};\n             new Complex(-2.6, -2.7),\n             new Complex(-2.09497474683058, -1.91507575950825)};\n \n-        result = transformer.transform(x);\n+        result = transformer.transform(x, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i].getReal(), result[i].getReal(), tolerance);\n             Assert.assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n \n-        result = transformer.inverseTransform(y);\n+        result = transformer.transform(y, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i].getReal(), tolerance);\n             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         TransformUtils.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));\n         Complex y2[] = y;\n \n-        transformer = new FastFourierTransformer(Normalization.UNITARY);\n-        result = transformer.transform(y2);\n+        transformer = new FastFourierTransformer(DftNormalization.UNITARY);\n+        result = transformer.transform(y2, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x2[i], result[i].getReal(), tolerance);\n             Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n \n-        result = transformer.inverseTransform(x2);\n+        result = transformer.transform(x2, TransformType.INVERSE);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);\n             Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n         FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.STANDARD);\n+        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n         Complex result[]; int N = 1 << 8;\n         double min, max, tolerance = 1E-12;\n \n         min = 0.0; max = 2.0 * FastMath.PI;\n-        result = transformer.transform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.FORWARD);\n         Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n         Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n         Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n         }\n \n         min = -FastMath.PI; max = FastMath.PI;\n-        result = transformer.inverseTransform(f, min, max, N);\n+        result = transformer.transform(f, min, max, N, TransformType.INVERSE);\n         Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n         Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);\n         Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n     @Test\n     public void test2DData() {\n         FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.STANDARD);\n+        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n \n         double tolerance = 1E-12;\n         Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n                 FastMath.sqrt(goodOutput[i].length) *\n                     FastMath.sqrt(goodOutput.length));\n         }\n-        Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n-        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n+        Complex[][] output = (Complex[][])transformer.mdfft(input, TransformType.FORWARD);\n+        Complex[][] output2 = (Complex[][])transformer.mdfft(output, TransformType.INVERSE);\n+\n+        Assert.assertEquals(input.length, output.length);\n+        Assert.assertEquals(input.length, output2.length);\n+        Assert.assertEquals(input[0].length, output[0].length);\n+        Assert.assertEquals(input[0].length, output2[0].length);\n+        Assert.assertEquals(input[1].length, output[1].length);\n+        Assert.assertEquals(input[1].length, output2[1].length);\n+\n+        for (int i = 0; i < input.length; i++) {\n+            for (int j = 0; j < input[0].length; j++) {\n+                System.out.println(i + \", \" + j + \", \" + input[i][j] + \", \" +\n+                        goodOutput[i][j] + \", \" + output[i][j] + \", \");\n+                Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n+                             tolerance);\n+                Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n+                Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n+                             tolerance);\n+                Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test2DDataUnitary() {\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(DftNormalization.UNITARY);\n+        double tolerance = 1E-12;\n+        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n+                                                            new Complex(2, 0)},\n+                                             new Complex[] {new Complex(3, 1),\n+                                                            new Complex(4, 2)}};\n+        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,\n+                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,\n+                -1.5), new Complex(0, .5)}};\n+        Complex[][] output = (Complex[][])transformer.mdfft(input, TransformType.FORWARD);\n+        Complex[][] output2 = (Complex[][])transformer.mdfft(output, TransformType.INVERSE);\n \n         Assert.assertEquals(input.length, output.length);\n         Assert.assertEquals(input.length, output2.length);\n         }\n     }\n \n-    @Test\n-    public void test2DDataUnitary() {\n-        FastFourierTransformer transformer;\n-        transformer = new FastFourierTransformer(Normalization.UNITARY);\n-        double tolerance = 1E-12;\n-        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n-                                                            new Complex(2, 0)},\n-                                             new Complex[] {new Complex(3, 1),\n-                                                            new Complex(4, 2)}};\n-        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,\n-                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,\n-                -1.5), new Complex(0, .5)}};\n-        Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n-        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n-\n-        Assert.assertEquals(input.length, output.length);\n-        Assert.assertEquals(input.length, output2.length);\n-        Assert.assertEquals(input[0].length, output[0].length);\n-        Assert.assertEquals(input[0].length, output2[0].length);\n-        Assert.assertEquals(input[1].length, output[1].length);\n-        Assert.assertEquals(input[1].length, output2[1].length);\n-\n-        for (int i = 0; i < input.length; i++) {\n-            for (int j = 0; j < input[0].length; j++) {\n-                Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n-                             tolerance);\n-                Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n-                Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n-                             tolerance);\n-                Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n-            }\n-        }\n-    }\n-\n }", "timestamp": 1328863600, "metainfo": ""}