{"sha": "db099373cb92bd1f26672c4c604e0cc6cddd49b0", "log": "Added support for iterative linear solvers (Conjugate Gradient only for now). See MATH-581.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.util.ExceptionContext;\n+import org.apache.commons.math.util.IterationManager;\n+\n+/**\n+ * <p>\n+ * This is an implementation of the conjugate gradient method for\n+ * {@link RealLinearOperator}. It follows closely the template by <a\n+ * href=\"#BARR1994\">Barrett et al. (1994)</a> (figure 2.5). The linear system at\n+ * hand is A &middot; x = b, and the residual is r = b - A &middot; x.\n+ * </p>\n+ * <h3><a id=\"stopcrit\">Default stopping criterion</a></h3>\n+ * <p>\n+ * A default stopping criterion is implemented. The iterations stop when || r ||\n+ * &le; &delta; || b ||, where b is the right-hand side vector, r the current\n+ * estimate of the residual, and &delta; a user-specified tolerance. It should\n+ * be noted that r is the so-called <em>updated</em> residual, which might\n+ * differ from the true residual due to rounding-off errors (see e.g. <a\n+ * href=\"#STRA2002\">Strakos and Tichy, 2002</a>).\n+ * </p>\n+ * <h3>Iteration count</h3>\n+ * <p>\n+ * In the present context, an iteration should be understood as one evaluation\n+ * of the matrix-vector product A &middot; x. The initialization phase therefore\n+ * counts as one iteration.\n+ * </p>\n+ * <h3><a id=\"context\">Exception context</a></h3>\n+ * <p>\n+ * Besides standard {@link DimensionMismatchException}, this class might throw\n+ * {@link NonPositiveDefiniteLinearOperatorException} if the linear operator or\n+ * the preconditioner are not positive definite. In this case, the\n+ * {@link ExceptionContext} provides some more information\n+ * <ul>\n+ * <li>key {@code \"operator\"} points to the offending linear operator, say L,</li>\n+ * <li>key {@code \"vector\"} points to the offending vector, say x, such that\n+ * x<sup>T</sup> &middot; L &middot; x < 0.</li>\n+ * </ul>\n+ * </p>\n+ * <h3>References</h3>\n+ * <dl>\n+ * <dt><a id=\"BARR1994\">Barret et al. (1994)</a></dt>\n+ * <dd>R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. M. Donato, J. Dongarra,\n+ * V. Eijkhout, R. Pozo, C. Romine and H. Van der Vorst,\n+ * <em>Templates for the Solution of Linear Systems: Building Blocks for\n+ * Iterative Methods</em>, SIAM</dd>\n+ * <dt><a id=\"STRA2002\">Strakos and Tichy (2002)\n+ * <dt>\n+ * <dd>Z. Strakos and P. Tichy, <a\n+ * href=\"http://etna.mcs.kent.edu/vol.13.2002/pp56-80.dir/pp56-80.pdf\">\n+ * <em>On error estimation in the conjugate gradient method and why it works\n+ * in finite precision computations</em></a>, Electronic Transactions on\n+ * Numerical Analysis 13: 56-80, 2002</dd>\n+ * </dl>\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class ConjugateGradient\n+    extends PreconditionedIterativeLinearSolver {\n+\n+    /**\n+     * The type of all events fired by this implementation of the Conjugate\n+     * Gradient method.\n+     *\n+     * @version $Id$\n+     */\n+    public abstract static class ConjugateGradientEvent\n+        extends IterativeLinearSolverEvent\n+        implements ProvidesResidual {\n+\n+        /** */\n+        private static final long serialVersionUID = 6461730085343318121L;\n+\n+        /**\n+         * Creates a new instance of this class.\n+         *\n+         * @param source The iterative algorithm on which the event initially\n+         *        occurred.\n+         */\n+        public ConjugateGradientEvent(final Object source) {\n+            super(source);\n+        }\n+    }\n+\n+    /** Key for the <a href=\"#context\">exception context</a>. */\n+    public static final String OPERATOR = \"operator\";\n+\n+    /** Key for the <a href=\"#context\">exception context</a>. */\n+    public static final String VECTOR = \"vector\";\n+\n+    /**\n+     * {@code true} if positive-definiteness of matrix and preconditioner should\n+     * be checked.\n+     */\n+    private boolean check;\n+\n+    /** The value of &delta;, for the default stopping criterion. */\n+    private final double delta;\n+\n+    /**\n+     * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n+     * stopping criterion</a>.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param check {@code true} if positive definiteness of both matrix and\n+     *        preconditioner should be checked.\n+     */\n+    public ConjugateGradient(final int maxIterations, final double delta,\n+                             final boolean check) {\n+        super(maxIterations);\n+        this.delta = delta;\n+        this.check = check;\n+    }\n+\n+    /**\n+     * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n+     * stopping criterion</a> and custom iteration manager.\n+     *\n+     * @param manager Custom iteration manager.\n+     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param check {@code true} if positive definiteness of both matrix and\n+     *        preconditioner should be checked.\n+     */\n+    public ConjugateGradient(final IterationManager manager,\n+                             final double delta, final boolean check) {\n+        super(manager);\n+        this.delta = delta;\n+        this.check = check;\n+    }\n+\n+    /**\n+     * Returns {@code true} if positive-definiteness should be checked for both\n+     * matrix and preconditioner.\n+     *\n+     * @return {@code true} if the tests are to be performed.\n+     */\n+    public final boolean getCheck() {\n+        return check;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a,\n+                            final InvertibleRealLinearOperator m,\n+                            final RealVector b, final RealVector x0,\n+                            final boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        checkParameters(a, m, b, x0, inPlace);\n+        final IterationManager manager = getIterationManager();\n+        // Initialization of default stopping criterion\n+        manager.resetIterationCount();\n+        final double r2max = delta * delta * b.dotProduct(b);\n+\n+        // p and x are constructed as copies of x0, since presumably, the type\n+        // of x is optimized for the calculation of the matrix-vector product\n+        // A.x.\n+        final RealVector x;\n+        if (inPlace) {\n+            x = x0;\n+        } else {\n+            if (x0 != null) {\n+                x = x0.copy();\n+            } else {\n+                x = new ArrayRealVector(a.getColumnDimension());\n+            }\n+        }\n+        final RealVector p = x.copy();\n+        RealVector q = a.operate(p);\n+        manager.incrementIterationCount();\n+        final RealVector r = b.combine(1, -1, q);\n+        double r2 = r.dotProduct(r);\n+        RealVector z;\n+        if (m == null) {\n+            z = r;\n+        } else {\n+            z = null;\n+        }\n+        final IterativeLinearSolverEvent event;\n+        event = new ConjugateGradientEvent(this) {\n+\n+            public RealVector getResidual() {\n+                return ArrayRealVector.unmodifiableRealVector(r);\n+            }\n+\n+            @Override\n+            public RealVector getRightHandSideVector() {\n+                return ArrayRealVector.unmodifiableRealVector(b);\n+            }\n+\n+            @Override\n+            public RealVector getSolution() {\n+                return ArrayRealVector.unmodifiableRealVector(x);\n+            }\n+        };\n+        manager.fireInitializationEvent(event);\n+        if (r2 <= r2max) {\n+            manager.fireTerminationEvent(event);\n+            return x;\n+        }\n+        double rhoPrev = 0.;\n+        while (true) {\n+            manager.fireIterationStartedEvent(event);\n+            if (m != null) {\n+                z = m.solve(r);\n+            }\n+            final double rhoNext = r.dotProduct(z);\n+            if (check && (rhoNext <= 0.)) {\n+                final NonPositiveDefiniteLinearOperatorException e;\n+                e = new NonPositiveDefiniteLinearOperatorException();\n+                final ExceptionContext context = e.getContext();\n+                context.setValue(OPERATOR, m);\n+                context.setValue(VECTOR, r);\n+                throw e;\n+            }\n+            if (manager.getIterations() == 1) {\n+                p.setSubVector(0, z);\n+            } else {\n+                p.combineToSelf(rhoNext / rhoPrev, 1., z);\n+            }\n+            q = a.operate(p);\n+            manager.incrementIterationCount();\n+            final double pq = p.dotProduct(q);\n+            if (check && (pq <= 0.)) {\n+                final NonPositiveDefiniteLinearOperatorException e;\n+                e = new NonPositiveDefiniteLinearOperatorException();\n+                final ExceptionContext context = e.getContext();\n+                context.setValue(OPERATOR, a);\n+                context.setValue(VECTOR, p);\n+                throw e;\n+            }\n+            final double alpha = rhoNext / pq;\n+            x.combineToSelf(1., alpha, p);\n+            r.combineToSelf(1., -alpha, q);\n+            rhoPrev = rhoNext;\n+            r2 = r.dotProduct(r);\n+            manager.fireIterationPerformedEvent(event);\n+            if (r2 <= r2max) {\n+                manager.fireTerminationEvent(event);\n+                return x;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.IterationManager;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This abstract class defines an iterative solver for the linear system A\n+ * &middot; x = b. In what follows, the <em>residual</em> r is defined as r = b\n+ * - A &middot; x, where A is the linear operator of the linear system, b is the\n+ * right-hand side vector, and x the current estimate of the solution.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class IterativeLinearSolver {\n+\n+    /** The object in charge of managing the iterations. */\n+    private final IterationManager manager;\n+\n+    /**\n+     * Creates a new instance of this class, with default iteration manager.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     */\n+    public IterativeLinearSolver(final int maxIterations) {\n+        this.manager = new IterationManager(maxIterations);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class, with custom iteration manager.\n+     *\n+     * @param manager Custom iteration manager.\n+     */\n+    public IterativeLinearSolver(final IterationManager manager) {\n+        MathUtils.checkNotNull(manager);\n+        this.manager = manager;\n+    }\n+    /**\n+     * Performs all dimension checks on the parameters of\n+     * {@link #solve(RealLinearOperator, RealVector, RealVector, boolean)}, and\n+     * throws an exception if one of the checks fails.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution (can be {@code null} if\n+     *        {@code inPlace} is set to {@code false}).\n+     * @param inPlace {@code true} if the initial guess is to be updated with\n+     *        the current estimate of the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} or {@code x0} have\n+     *         dimensions inconsistent with {@code a}.\n+     */\n+    protected static void checkParameters(final RealLinearOperator a,\n+                                          final RealVector b,\n+                                          final RealVector x0,\n+                                          final boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException {\n+        MathUtils.checkNotNull(a);\n+        MathUtils.checkNotNull(b);\n+        if (a.getRowDimension() != a.getColumnDimension()) {\n+            throw new NonSquareLinearOperatorException(a.getRowDimension(),\n+                                                       a.getColumnDimension());\n+        }\n+        if (b.getDimension() != a.getRowDimension()) {\n+            throw new DimensionMismatchException(b.getDimension(),\n+                                                 a.getRowDimension());\n+        }\n+        if (inPlace) {\n+            MathUtils.checkNotNull(x0);\n+            if (x0.getDimension() != a.getColumnDimension()) {\n+                throw new DimensionMismatchException(x0.getDimension(),\n+                                                     a.getColumnDimension());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the {@link IterationManager} attached to this solver.\n+     *\n+     * @return the manager.\n+     */\n+    public IterationManager getIterationManager() {\n+        return manager;\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. If no initial estimate of the solution is provided, (0, &hellip;, 0)\n+     * is assumed.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution (can be {@code null} if\n+     *        {@code inPlace} is set to {@code false}).\n+     * @param inPlace {@code true} if the initial guess is to be updated with\n+     *        the current estimate of the solution.\n+     * @return A reference to {@code x0} (shallow copy) if {@code inPlace} was\n+     *         set to {@code true}. Otherwise, a new vector containing the\n+     *         solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} is not square.\n+     * @throws DimensionMismatchException if {@code b} or {@code x0} have\n+     *         dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     *         unless a custom {@link MaxCountExceededCallback callback} has\n+     *         been set at construction.\n+     */\n+    public abstract RealVector solve(RealLinearOperator a, RealVector b,\n+                                     RealVector x0, boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.util.IterationEvent;\n+\n+/**\n+ * This is the base class for all events occuring during the iterations of a\n+ * {@link IterativeLinearSolver}.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class IterativeLinearSolverEvent\n+    extends IterationEvent {\n+\n+    /** */\n+    private static final long serialVersionUID = 283291016904748030L;\n+\n+    /**\n+     * Creates a new instance of this class.\n+     *\n+     * @param source The iterative algorithm on which the event initially\n+     *        occurred.\n+     */\n+    public IterativeLinearSolverEvent(final Object source) {\n+        super(source);\n+    }\n+\n+    /**\n+     * Returns the current right-hand side of the linear system to be solved.\n+     * This method should return an unmodifiable view, or a deep copy of the\n+     * actual right-hand side, in order not to compromise subsequent iterations\n+     * of the source {@link IterativeLinearSolver}.\n+     *\n+     * @return The right-hand side vector, b.\n+     */\n+    public abstract RealVector getRightHandSideVector();\n+\n+    /**\n+     * Returns the current estimate of the solution to the linear system to be\n+     * solved. This method should return an unmodifiable view, or a deep copy of\n+     * the actual current solution, in order not to compromise subsequent\n+     * iterations of the source {@link IterativeLinearSolver}.\n+     *\n+     * @return The solution, x.\n+     */\n+    public abstract RealVector getSolution();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/JacobiPreconditioner.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * This class implements the standard Jacobi (diagonal) preconditioner.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class JacobiPreconditioner\n+    extends InvertibleRealLinearOperator {\n+\n+    /** The diagonal coefficients of the preconditioner. */\n+    private final ArrayRealVector diag;\n+\n+    /**\n+     * Creates a new instance of this class.\n+     *\n+     * @param diag Diagonal coefficients of the preconditioner.\n+     * @param deep {@code true} if a deep copy of the above array should be\n+     *        performed.\n+     */\n+    public JacobiPreconditioner(final double[] diag, final boolean deep) {\n+        this.diag = new ArrayRealVector(diag, deep);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class. This method extracts the diagonal\n+     * coefficients of the specified linear operator. If {@code a} does not\n+     * extend {@link AbstractRealMatrix}, then the coefficients of the\n+     * underlying matrix are not accessible, coefficient extraction is made by\n+     * matrix-vector products with the basis vectors (and might therefore take\n+     * some time). With matrices, direct entry access is carried out.\n+     *\n+     * @param a Linear operator for which the preconditioner should be built.\n+     * @return Preconditioner made of the diagonal coefficients of the specified\n+     *         linear operator.\n+     * @throws NonSquareLinearOperatorException if {@code a} is not square.\n+     */\n+    public static JacobiPreconditioner create(final RealLinearOperator a)\n+        throws NonSquareLinearOperatorException {\n+        final int n = a.getColumnDimension();\n+        if (a.getRowDimension() != n) {\n+            throw new NonSquareLinearOperatorException(a.getRowDimension(), n);\n+        }\n+        final double[] diag = new double[n];\n+        if (a instanceof AbstractRealMatrix) {\n+            final AbstractRealMatrix m = (AbstractRealMatrix) a;\n+            for (int i = 0; i < n; i++) {\n+                diag[i] = m.getEntry(i, i);\n+            }\n+        } else {\n+            final ArrayRealVector x = new ArrayRealVector(n);\n+            for (int i = 0; i < n; i++) {\n+                x.set(0.);\n+                x.setEntry(i, 1.);\n+                diag[i] = a.operate(x).getEntry(i);\n+            }\n+        }\n+        return new JacobiPreconditioner(diag, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return diag.getDimension();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return diag.getDimension();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector operate(final RealVector x) {\n+        // Dimension check is carried out by ebeMultiply\n+        return x.ebeMultiply(diag);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector solve(final RealVector b) {\n+        // Dimension check is carried out by ebeDivide\n+        return b.ebeDivide(diag);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/PreconditionedIterativeLinearSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.IterationManager;\n+\n+/**\n+ * This abstract class defines preconditioned iterative solvers. When A is\n+ * ill-conditioned, instead of solving system A &middot; x = b directly, it is\n+ * preferable to solve M<sup>-1</sup> &middot; A &middot; x = M<sup>-1</sup>\n+ * &middot; b, where M approximates in some way A, while remaining comparatively\n+ * easier to invert. M (not M<sup>-1</sup>!) is called the\n+ * <em>preconditionner</em>.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class PreconditionedIterativeLinearSolver\n+    extends IterativeLinearSolver {\n+\n+    /**\n+     * Creates a new instance of this class, with default iteration manager.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     */\n+    public PreconditionedIterativeLinearSolver(final int maxIterations) {\n+        super(maxIterations);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class, with custom iteration manager.\n+     *\n+     * @param manager Custom iteration manager.\n+     */\n+    public PreconditionedIterativeLinearSolver(final IterationManager manager) {\n+        super(manager);\n+    }\n+\n+    /**\n+     * Performs all dimension checks on the parameters of\n+     * {@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector, boolean)}\n+     * , and throws an exception if one of the checks fails.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution (can be {@code null} if\n+     *        {@code inPlace} is set to {@code false}).\n+     * @param inPlace {@code true} if the initial guess is to be updated with\n+     *        the current estimate of the solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     *         square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     *         have dimensions inconsistent with {@code a}.\n+     */\n+    protected static void checkParameters(final RealLinearOperator a,\n+                                          final InvertibleRealLinearOperator m,\n+                                          final RealVector b,\n+                                          final RealVector x0,\n+                                          final boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException {\n+        checkParameters(a, b, x0, inPlace);\n+        if (m != null) {\n+            if (m.getColumnDimension() != m.getRowDimension()) {\n+                throw new NonSquareLinearOperatorException(\n+                                                           m.getColumnDimension(),\n+                                                           m.getRowDimension());\n+            }\n+            if (m.getRowDimension() != a.getRowDimension()) {\n+                throw new DimensionMismatchException(m.getRowDimension(),\n+                                                     a.getRowDimension());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns an estimate of the solution to the linear system A &middot; x =\n+     * b. If no initial estimate of the solution is provided, (0, &hellip;, 0)\n+     * is assumed.\n+     *\n+     * @param a Linear operator A of the system.\n+     * @param m Preconditioner (can be {@code null}).\n+     * @param b Right-hand side vector.\n+     * @param x0 Initial guess of the solution (can be {@code null} if\n+     *        {@code inPlace} is set to {@code false}).\n+     * @param inPlace {@code true} if the initial guess is to be updated with\n+     *        the current estimate of the solution.\n+     * @return A reference to {@code x0} (shallow copy) if {@code update} was\n+     *         set to {@code true}. Otherwise, a new vector containing the\n+     *         solution.\n+     * @throws NullArgumentException if one of the parameters is {@code null}.\n+     * @throws NonSquareLinearOperatorException if {@code a} or {@code m} is not\n+     *         square.\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     *         have dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     *         unless a custom {@link MaxCountExceededCallback callback} has\n+     *         been set at construction.\n+     */\n+    public abstract RealVector solve(RealLinearOperator a,\n+                                     InvertibleRealLinearOperator m,\n+                                     RealVector b, RealVector x0,\n+                                     final boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException;\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector solve(final RealLinearOperator a, final RealVector b,\n+                            final RealVector x, final boolean inPlace)\n+        throws NullArgumentException, NonSquareLinearOperatorException,\n+        DimensionMismatchException, MaxCountExceededException {\n+        checkParameters(a, b, x, inPlace);\n+        return solve(a, null, b, x, inPlace);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/ProvidesResidual.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * This interface provides access to the current value of the residual of an\n+ * {@link IterativeLinearSolver}. It might be implemented by\n+ * {@link IterativeLinearSolverEvent}, for example.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface ProvidesResidual {\n+    /**\n+     * Returns the current value of the residual. This should be an\n+     * unmodifiable view or a deep copy of the residual, in order not to\n+     * compromise the subsequent iterations.\n+     *\n+     * @return the current value of the residual.\n+     */\n+    RealVector getResidual();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.util.IterationEvent;\n+import org.apache.commons.math.util.IterationListener;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ConjugateGradientTest {\n+\n+    @Test(expected = NonSquareLinearOperatorException.class)\n+    public void testNonSquareOperator() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());\n+        solver.solve(a, b, x, false);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testDimensionMismatchRightHandSide() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(2);\n+        final ArrayRealVector x = new ArrayRealVector(3);\n+        solver.solve(a, b, x, false);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testDimensionMismatchSolution() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0., false);\n+        final ArrayRealVector b = new ArrayRealVector(3);\n+        final ArrayRealVector x = new ArrayRealVector(2);\n+        solver.solve(a, b, x, false);\n+    }\n+\n+    @Test(expected = NonPositiveDefiniteLinearOperatorException.class)\n+    public void testNonPositiveDefiniteLinearOperator() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        a.setEntry(0, 0, -1.);\n+        a.setEntry(0, 1, 2.);\n+        a.setEntry(1, 0, 3.);\n+        a.setEntry(1, 1, 4.);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0., true);\n+        final ArrayRealVector b = new ArrayRealVector(2);\n+        b.setEntry(0, -1.);\n+        b.setEntry(1, -1.);\n+        final ArrayRealVector x = new ArrayRealVector(2);\n+        solver.solve(a, b, x, false);\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedSolution() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x = solver.solve(a, b, null, false);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-10 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d]\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedInPlaceSolutionWithInitialGuess() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x0 = new ArrayRealVector(n);\n+            x0.set(1.);\n+            final RealVector x = solver.solve(a, b, x0, true);\n+            Assert.assertSame(\"x should be a reference to x0\", x0, x);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-10 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d)\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUnpreconditionedSolutionWithInitialGuess() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x0 = new ArrayRealVector(n);\n+            x0.set(1.);\n+            final RealVector x = solver.solve(a, b, x0, false);\n+            Assert.assertNotSame(\"x should not be a reference to x0\", x0, x);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-10 * Math.abs(expected);\n+                final String msg = String.format(\"entry[%d][%d]\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+                Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check whether the estimate of the (updated) residual corresponds to the\n+     * exact residual. This fails to be true for a large number of iterations,\n+     * due to the loss of orthogonality of the successive search directions.\n+     * Therefore, in the present test, the number of iterations is limited.\n+     */\n+    @Test(expected = MaxCountExceededException.class)\n+    public void testUnpreconditionedResidual() {\n+        final int n = 10;\n+        final int maxIterations = n;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final ConjugateGradient solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-15, true);\n+        final RealVector r = new ArrayRealVector(n);\n+        final IterationListener listener = new IterationListener() {\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                r.setSubVector(0, ((ProvidesResidual) e).getResidual());\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                // Do nothing\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                // Do nothing\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                // Do nothing\n+            }\n+        };\n+        solver.getIterationManager().addIterationListener(listener);\n+\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+\n+            final RealVector x = solver.solve(a, b, null, false);\n+            final RealVector y = a.operate(x);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = b.getEntry(i) - y.getEntry(i);\n+                final double expected = r.getEntry(i);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String\n+                    .format(\"column %d, residual %d\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test(expected = NonSquareLinearOperatorException.class)\n+    public void testNonSquarePreconditioner() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0d, false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        solver.solve(a, m, b, null, false);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testMismatchedOperatorDimensions() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 3;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0d, false);\n+        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());\n+        solver.solve(a, m, b, null, false);\n+    }\n+\n+    @Test(expected = NonPositiveDefiniteLinearOperatorException.class)\n+    public void testNonPositiveDefinitePreconditioner() {\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n+        a.setEntry(0, 0, 1d);\n+        a.setEntry(0, 1, 2d);\n+        a.setEntry(1, 0, 3d);\n+        a.setEntry(1, 1, 4d);\n+        final InvertibleRealLinearOperator m;\n+        m = new InvertibleRealLinearOperator() {\n+\n+            @Override\n+            public RealVector operate(final RealVector x) {\n+                final ArrayRealVector y = new ArrayRealVector(2);\n+                y.setEntry(0, -x.getEntry(0));\n+                y.setEntry(1, x.getEntry(1));\n+                return y;\n+            }\n+\n+            @Override\n+            public int getRowDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public int getColumnDimension() {\n+                return 2;\n+            }\n+\n+            @Override\n+            public RealVector solve(final RealVector b) {\n+                final ArrayRealVector x = new ArrayRealVector(2);\n+                x.setEntry(0, -b.getEntry(0));\n+                x.setEntry(1, b.getEntry(1));\n+                return x;\n+            }\n+        };\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new ConjugateGradient(10, 0d, true);\n+        final ArrayRealVector b = new ArrayRealVector(2);\n+        b.setEntry(0, -1d);\n+        b.setEntry(1, -1d);\n+        solver.solve(a, m, b, null, false);\n+    }\n+\n+    @Test\n+    public void testPreconditionedSolution() {\n+        final int n = 8;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-15, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x = solver.solve(a, m, b, null, false);\n+            for (int i = 0; i < n; i++) {\n+                final double actual = x.getEntry(i);\n+                final double expected = ainv.getEntry(i, j);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String.format(\"coefficient (%d, %d)\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test(expected = MaxCountExceededException.class)\n+    public void testPreconditionedResidual() {\n+        final int n = 10;\n+        final int maxIterations = n;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final ConjugateGradient solver;\n+        solver = new ConjugateGradient(maxIterations, 1E-15, true);\n+        final RealVector r = new ArrayRealVector(n);\n+        final IterationListener listener = new IterationListener() {\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                r.setSubVector(0, ((ProvidesResidual) e).getResidual());\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n+                // Do nothing\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                // Do nothing\n+            }\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                // Do nothing\n+            }\n+        };\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector x = solver.solve(a, m, b, null, false);\n+            final RealVector y = a.operate(x);\n+            double rnorm = 0.;\n+            for (int i = 0; i < n; i++) {\n+                final double actual = b.getEntry(i) - y.getEntry(i);\n+                final double expected = r.getEntry(i);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                final String msg = String\n+                    .format(\"column %d, residual %d\", i, j);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+            rnorm = r.getNorm();\n+            Assert.assertEquals(\"norm of residual\", rnorm, r.getNorm(),\n+                                1E-6 * Math.abs(rnorm));\n+        }\n+    }\n+\n+    @Test\n+    public void testPreconditionedSolution2() {\n+        final int n = 100;\n+        final int maxIterations = 100000;\n+        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n);\n+        double daux = 1.;\n+        for (int i = 0; i < n; i++) {\n+            a.setEntry(i, i, daux);\n+            daux *= 1.2;\n+            for (int j = i + 1; j < n; j++) {\n+                if (i == j) {\n+                } else {\n+                    final double value = 1.0;\n+                    a.setEntry(i, j, value);\n+                    a.setEntry(j, i, value);\n+                }\n+            }\n+        }\n+        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final PreconditionedIterativeLinearSolver pcg;\n+        final IterativeLinearSolver cg;\n+        pcg = new ConjugateGradient(maxIterations, 1E-6, true);\n+        cg = new ConjugateGradient(maxIterations, 1E-6, true);\n+        final RealVector b = new ArrayRealVector(n);\n+        final String pattern = \"preconditioned gradient (%d iterations) should\"\n+                               + \" have been faster than unpreconditioned (%d iterations)\";\n+        String msg;\n+        for (int j = 0; j < 1; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            final RealVector px = pcg.solve(a, m, b, null, false);\n+            final RealVector x = cg.solve(a, b, null, false);\n+            final int npcg = pcg.getIterationManager().getIterations();\n+            final int ncg = cg.getIterationManager().getIterations();\n+            msg = String.format(pattern, npcg, ncg);\n+            Assert.assertTrue(msg, npcg < ncg);\n+            for (int i = 0; i < n; i++) {\n+                msg = String.format(\"row %d, column %d\", i, j);\n+                final double expected = x.getEntry(i);\n+                final double actual = px.getEntry(i);\n+                final double delta = 1E-6 * Math.abs(expected);\n+                Assert.assertEquals(msg, expected, actual, delta);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEventManagement() {\n+        final int n = 5;\n+        final int maxIterations = 100;\n+        final RealLinearOperator a = new HilbertMatrix(n);\n+        final IterativeLinearSolver solver;\n+        final int[] count = new int[] {\n+            0, 0, 0, 0\n+        };\n+        final IterationListener listener = new IterationListener() {\n+\n+            public void initializationPerformed(final IterationEvent e) {\n+                count[0] = 1;\n+                count[1] = 0;\n+                count[2] = 0;\n+                count[3] = 0;\n+\n+            }\n+\n+            public void iterationPerformed(final IterationEvent e) {\n+                ++count[2];\n+            }\n+\n+            public void iterationStarted(IterationEvent e) {\n+                ++count[1];\n+\n+            }\n+\n+            public void terminationPerformed(final IterationEvent e) {\n+                ++count[3];\n+            }\n+        };\n+        solver = new ConjugateGradient(maxIterations, 1E-10, true);\n+        solver.getIterationManager().addIterationListener(listener);\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+            solver.solve(a, b, null, false);\n+            String msg = String.format(\"column %d (initialization)\", j);\n+            Assert.assertEquals(msg, 1, count[0]);\n+            msg = String.format(\"column %d (iterations started)\", j);\n+            Assert.assertEquals(msg, solver.getIterationManager()\n+                .getIterations() - 1, count[1]);\n+            msg = String.format(\"column %d (iterations performed)\", j);\n+            Assert.assertEquals(msg, solver.getIterationManager()\n+                .getIterations() - 1, count[2]);\n+            msg = String.format(\"column %d (finalization)\", j);\n+            Assert.assertEquals(msg, 1, count[3]);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/HilbertMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+\n+/** This class implements Hilbert Matrices as {@link RealLinearOperator}. */\n+public class HilbertMatrix\n+    extends RealLinearOperator {\n+\n+    /** The size of the matrix. */\n+    private final int n;\n+\n+    /**\n+     * Creates a new instance of this class.\n+     *\n+     * @param n Size of the matrix to be created..\n+     */\n+    public HilbertMatrix(final int n) {\n+        this.n = n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector operate(final RealVector x) {\n+        if (x.getDimension() != n) {\n+            throw new DimensionMismatchException(x.getDimension(), n);\n+        }\n+        final double[] y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            double pos = 0.;\n+            double neg = 0.;\n+            for (int j = 0; j < n; j++) {\n+                final double xj = x.getEntry(j);\n+                final double coeff = 1. / (i + j + 1.);\n+                // Positive and negative values are sorted out in order to limit\n+                // catastrophic cancellations (do not forget that Hilbert\n+                // matrices are *very* ill-conditioned!\n+                if (xj > 0.) {\n+                    pos += coeff * xj;\n+                } else {\n+                    neg += coeff * xj;\n+                }\n+            }\n+            y[i] = pos + neg;\n+        }\n+        return new ArrayRealVector(y, false);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/InverseHilbertMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements inverses of Hilbert Matrices as\n+ * {@link RealLinearOperator}.\n+ */\n+public class InverseHilbertMatrix\n+    extends RealLinearOperator {\n+\n+    /** The size of the matrix. */\n+    private final int n;\n+\n+    /**\n+     * Creates a new instance of this class.\n+     *\n+     * @param n Size of the matrix to be created.\n+     */\n+    public InverseHilbertMatrix(final int n) {\n+        this.n = n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns the {@code (i, j)} entry of the inverse Hilbert matrix. Exact\n+     * arithmetic is used; in case of overflow, an exception is thrown.\n+     *\n+     * @param i Row index (starts at 0).\n+     * @param j Column index (starts at 0).\n+     * @return The coefficient of the inverse Hilbert matrix.\n+     */\n+    public long getEntry(final int i, final int j) {\n+        long val = i + j + 1;\n+        long aux = MathUtils.binomialCoefficient(n + i, n - j - 1);\n+        val = MathUtils.mulAndCheck(val, aux);\n+        aux = MathUtils.binomialCoefficient(n + j, n - i - 1);\n+        val = MathUtils.mulAndCheck(val, aux);\n+        aux = MathUtils.binomialCoefficient(i + j, i);\n+        val = MathUtils.mulAndCheck(val, aux);\n+        val = MathUtils.mulAndCheck(val, aux);\n+        return ((i + j) & 1) == 0 ? val : -val;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector operate(final RealVector x) {\n+        if (x.getDimension() != n) {\n+            throw new DimensionMismatchException(x.getDimension(), n);\n+        }\n+        final double[] y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            double pos = 0.;\n+            double neg = 0.;\n+            for (int j = 0; j < n; j++) {\n+                final double xj = x.getEntry(j);\n+                final long coeff = getEntry(i, j);\n+                final double daux = coeff * xj;\n+                // Positive and negative values are sorted out in order to limit\n+                // catastrophic cancellations (do not forget that Hilbert\n+                // matrices are *very* ill-conditioned!\n+                if (daux > 0.) {\n+                    pos += daux;\n+                } else {\n+                    neg += daux;\n+                }\n+            }\n+            y[i] = pos + neg;\n+        }\n+        return new ArrayRealVector(y, false);\n+    }\n+}", "timestamp": 1316962098, "metainfo": ""}