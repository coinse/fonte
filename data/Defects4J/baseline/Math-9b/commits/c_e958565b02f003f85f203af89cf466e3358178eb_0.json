{"sha": "e958565b02f003f85f203af89cf466e3358178eb", "log": "Added support for multi-dimensional Fourier transform. JIRA: MATH-152  ", "commit": "\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n+import java.lang.reflect.Array;\n import java.io.Serializable;\n+import java.util.Arrays;\n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.complex.*;\n import org.apache.commons.math.MathException;\n                 \", \" + upper + \"]\");\n         }       \n     }\n+    \n+    /**\n+     * Performs a multi-dimensional Fourier transform on a given\n+     * array, using {@link #inversetransform2(Complex[])} and\n+     * {@link #transform2(Complex[])} in a row-column implementation\n+     * in any number of dimensions with \u0398(N\u00d7log(N)) complexity with\n+     * N=n_1\u00d7n_2\u00d7n_3\u00d7\u22ef\u00d7n_d, n_x=number of elements in dimension x,\n+     * and d=total number of dimensions.\n+     *\n+     * @param forward inverseTransform2 is preformed if this is false\n+     * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n+     * @throws MathException if any dimension is not a power of two\n+     */\n+    public Object mdfft(Object mdca, boolean forward) throws MathException {\n+        MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n+                new MultiDimensionalComplexMatrix(mdca).clone();\n+        int[] dimensionSize = mdcm.getDimensionSizes();\n+        //cycle through each dimension\n+        for (int i = 0; i < dimensionSize.length; i++) {\n+            mdfft(mdcm, forward, i, new int[0]);\n+        }\n+        return mdcm.getArray();\n+    }\n+    \n+    private void mdfft(MultiDimensionalComplexMatrix mdcm, boolean forward,\n+                         int d, int[] subVector) throws MathException {\n+        int[] dimensionSize = mdcm.getDimensionSizes();\n+        //if done\n+        if (subVector.length == dimensionSize.length) {\n+            Complex[] temp = new Complex[dimensionSize[d]];\n+            for (int i = 0; i < dimensionSize[d]; i++) {\n+                //fft along dimension d\n+                subVector[d] = i;\n+                temp[i] = mdcm.get(subVector);\n+            }\n+            \n+            if (forward)\n+                temp = transform2(temp);\n+            else\n+                temp = inversetransform2(temp);\n+            \n+            for (int i = 0; i < dimensionSize[d]; i++) {\n+                subVector[d] = i;\n+                mdcm.set(temp[i], subVector);\n+            }\n+        } else {\n+            int[] vector = new int[subVector.length + 1];\n+            System.arraycopy(subVector, 0, vector, 0, subVector.length);\n+            if (subVector.length == d) {\n+                //value is not important once the recursion is done.\n+                //then an fft will be applied along the dimension d.\n+                vector[d] = 0;\n+                mdfft(mdcm, forward, d, vector);\n+            } else {\n+                for (int i = 0; i < dimensionSize[subVector.length]; i++) {\n+                    vector[subVector.length] = i;\n+                    //further split along the next dimension\n+                    mdfft(mdcm, forward, d, vector);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    /*\n+     * not designed for synchronized access\n+     * may eventually be replaced by jsr-83 of the java community process\n+     * http://jcp.org/en/jsr/detail?id=83\n+     * may require additional exception throws for other basic requirements.\n+     */\n+    private class MultiDimensionalComplexMatrix implements Serializable,\n+                                                           Cloneable {\n+        private static final long serialVersionUID =  0x564FCD47EBA8169BL;\n+        \n+        protected int[] dimensionSize = new int[1];\n+        protected Object multiDimensionalComplexArray;\n+        \n+        public MultiDimensionalComplexMatrix(Object\n+                                             multiDimensionalComplexArray) {\n+            this.multiDimensionalComplexArray = multiDimensionalComplexArray;\n+            int numOfDimensions = 0;\n+            \n+            Object lastDimension = multiDimensionalComplexArray;\n+            while(lastDimension instanceof Object[]) {\n+                numOfDimensions++;\n+                //manually implement variable size int[]\n+                if (dimensionSize.length < numOfDimensions) {\n+                    int[] newDimensionSize = new int[(int) Math.ceil(\n+                            dimensionSize.length*1.6)];\n+                    System.arraycopy(dimensionSize, 0, newDimensionSize, 0,\n+                                     dimensionSize.length);\n+                    dimensionSize = newDimensionSize;\n+                }\n+                dimensionSize[numOfDimensions - 1] = ((Object[])\n+                                                      lastDimension).length;\n+                lastDimension = ((Object[]) lastDimension)[0];\n+            }\n+            if (dimensionSize.length > numOfDimensions) {\n+                int[] newDimensionSize = new int[numOfDimensions];\n+                System.arraycopy(dimensionSize, 0, newDimensionSize, 0,\n+                                 numOfDimensions);\n+                dimensionSize = newDimensionSize;\n+            }\n+        }\n+        \n+        public Complex get(int... vector) {\n+            if ((vector == null && dimensionSize.length > 1) ||\n+                    vector.length != dimensionSize.length) {\n+                throw new IllegalArgumentException(\"Number of dimensions must \"\n+                                                   + \"match\");\n+            }\n+            \n+            Object lastDimension = multiDimensionalComplexArray;\n+            \n+            for (int i = 0; i < dimensionSize.length; i++) {\n+                lastDimension = ((Object[]) lastDimension)[vector[i]];\n+            }\n+            return (Complex) lastDimension;\n+        }\n+        \n+        public Complex set(Complex magnitude, int... vector) {\n+            if ((vector == null && dimensionSize.length > 1) ||\n+                    vector.length != dimensionSize.length) {\n+                throw new IllegalArgumentException(\"Number of dimensions must \"\n+                                                   + \"match\");\n+            }\n+            \n+            Object lastDimension = multiDimensionalComplexArray;\n+            \n+            for (int i = 0; i < dimensionSize.length - 1; i++) {\n+                lastDimension = ((Object[]) lastDimension)[vector[i]];\n+            }\n+            \n+            Complex lastValue = (Complex) ((Object[])\n+                    lastDimension)[vector[dimensionSize.length - 1]];\n+            ((Object[]) lastDimension)[vector[dimensionSize.length - 1]] =\n+                    magnitude;\n+            return lastValue;\n+        }\n+        \n+        public int[] getDimensionSizes() {\n+            return dimensionSize.clone();\n+        }\n+        \n+        public Object getArray() {\n+            return multiDimensionalComplexArray;\n+        }\n+        \n+        @Override\n+        public Object clone() {\n+            MultiDimensionalComplexMatrix mdcm =\n+                    new MultiDimensionalComplexMatrix(Array.newInstance(\n+                    Complex.class, dimensionSize));\n+            clone(mdcm);\n+            return mdcm;\n+        }\n+        \n+        /*\n+         * Copy contents of current array into mdcm.\n+         */\n+        private void clone(MultiDimensionalComplexMatrix mdcm) {\n+            int[] vector = new int[dimensionSize.length];\n+            int size = 1;\n+            for (int i = 0; i < dimensionSize.length; i++) {\n+                size *= dimensionSize[i];\n+            }\n+            int[][] vectorList = new int[size][dimensionSize.length];\n+            for (int[] nextVector: vectorList) {\n+                System.arraycopy(vector, 0, nextVector, 0,\n+                                 dimensionSize.length);\n+                for (int i = 0; i < dimensionSize.length; i++) {\n+                    vector[i]++;\n+                    if (vector[i] < dimensionSize[i]) {\n+                        break;\n+                    } else {\n+                        vector[i] = 0;\n+                    }\n+                }\n+            }\n+            \n+            for (int[] nextVector: vectorList) {\n+                mdcm.set(get(nextVector), nextVector);\n+            }\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/org/apache/commons/math/transform/FastFourierTransformerTest.java\n             assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n     }\n-\n+    \n+    public void test2DData() throws MathException {\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        double tolerance = 1E-12;\n+        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n+                                                            new Complex(2, 0)},\n+                                             new Complex[] {new Complex(3, 1),\n+                                                            new Complex(4, 2)}};\n+        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,\n+                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,\n+                -1.5), new Complex(0, .5)}};\n+        Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n+        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n+        \n+        assertEquals(input.length, output.length);\n+        assertEquals(input.length, output2.length);\n+        assertEquals(input[0].length, output[0].length);\n+        assertEquals(input[0].length, output2[0].length);\n+        assertEquals(input[1].length, output[1].length);\n+        assertEquals(input[1].length, output2[1].length);\n+        \n+        for (int i = 0; i < input.length; i++) {\n+            for (int j = 0; j < input[0].length; j++) {\n+                assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n+                             tolerance);\n+                assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);\n+                assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),\n+                             tolerance);\n+                assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);\n+            }\n+        }\n+    }\n+    \n     /**\n      * Test of transformer for the sine function.\n      */", "timestamp": 1228682880, "metainfo": ""}