{"sha": "46625319483ea5d652297256d4bdd1c54e6bcc5f", "log": "MATH-841 Performance improvement in method \"gcd(int, int)\" (~2 to 4 times faster than the previous implementation). Thanks to Sebastien Riou.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n+++ b/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n     }\n \n     /**\n-     * <p>\n-     * Gets the greatest common divisor of the absolute value of two numbers,\n-     * using the \"binary gcd\" method which avoids division and modulo\n-     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n-     * Stein (1961).\n-     * </p>\n+     * Computes the greatest common divisor of the absolute value of two\n+     * numbers, using the \"binary gcd\" method which avoids division and\n+     * modulo operations.\n+     * See Knuth 4.5.2 algorithm B.\n+     * The algorithm is due to Josef Stein (1961).\n+     * <br/>\n      * Special cases:\n      * <ul>\n-     * <li>The invocations\n-     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n-     * {@code gcd(Integer.MIN_VALUE, 0)} and\n-     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n-     * {@code ArithmeticException}, because the result would be 2^31, which\n-     * is too large for an int value.</li>\n-     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n-     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n-     * for the special cases above.\n-     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n-     * {@code 0}.</li>\n+     *  <li>The invocations\n+     *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n+     *   {@code gcd(Integer.MIN_VALUE, 0)} and\n+     *   {@code gcd(0, Integer.MIN_VALUE)} throw an\n+     *   {@code ArithmeticException}, because the result would be 2^31, which\n+     *   is too large for an int value.</li>\n+     *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     *   {@code gcd(x, 0)} is the absolute value of {@code x}, except\n+     *   for the special cases above.</li>\n+     *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     *   {@code 0}.</li>\n      * </ul>\n      *\n      * @param p Number.\n      * a non-negative {@code int} value.\n      * @since 1.1\n      */\n-    public static int gcd(final int p, final int q) {\n-        int u = p;\n-        int v = q;\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+    public static int gcd(int p,\n+                          int q)\n+        throws MathArithmeticException {\n+        int a = p;\n+        int b = q;\n+        if (a == 0 ||\n+            b == 0) {\n+            if (a == Integer.MIN_VALUE ||\n+                b == Integer.MIN_VALUE) {\n                 throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                                   p, q);\n             }\n-            return FastMath.abs(u) + FastMath.abs(v);\n-        }\n-        // keep u and v negative, as negative integers range down to\n-        // -2^31, while positive numbers can only be as large as 2^31-1\n-        // (i.e. we can't necessarily negate a negative number without\n-        // overflow)\n-        /* assert u!=0 && v!=0; */\n-        if (u > 0) {\n-            u = -u;\n-        } // make u negative\n-        if (v > 0) {\n-            v = -v;\n-        } // make v negative\n-        // B1. [Find power of 2]\n-        int k = 0;\n-        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n-                                                            // both even...\n-            u /= 2;\n-            v /= 2;\n-            k++; // cast out twos.\n-        }\n-        if (k == 31) {\n-            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                                              p, q);\n-        }\n-        // B2. Initialize: u and v have been divided by 2^k and at least\n-        // one is odd.\n-        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n-        // t negative: u was odd, v may be even (t replaces v)\n-        // t positive: u was even, v is odd (t replaces u)\n-        do {\n-            /* assert u<0 && v<0; */\n-            // B4/B3: cast out twos from t.\n-            while ((t & 1) == 0) { // while t is even..\n-                t /= 2; // cast out twos\n-            }\n-            // B5 [reset max(u,v)]\n-            if (t > 0) {\n-                u = -t;\n+            return FastMath.abs(a + b);\n+        }\n+\n+        long al = a;\n+        long bl = b;\n+        boolean useLong = false;\n+        if (a < 0) {\n+            if(Integer.MIN_VALUE == a) {\n+                useLong = true;\n             } else {\n-                v = t;\n-            }\n-            // B6/B3. at this point both u and v should be odd.\n-            t = (v - u) / 2;\n-            // |u| larger: t positive (replace u)\n-            // |v| larger: t negative (replace v)\n-        } while (t != 0);\n-        return -u * (1 << k); // gcd is u*2^k\n+                a = -a;\n+            }\n+            al = -al;\n+        }\n+        if (b < 0) {\n+            if (Integer.MIN_VALUE == b) {\n+                useLong = true;\n+            } else {\n+                b = -b;\n+            }\n+            bl = -bl;\n+        }\n+        if (useLong) {\n+            if(al == bl) {\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                                  p, q);\n+            }\n+            long blbu = bl;\n+            bl = al;\n+            al = blbu % al;\n+            if (al == 0) {\n+                if (bl > Integer.MAX_VALUE) {\n+                    throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                                      p, q);\n+                }\n+                return (int) bl;\n+            }\n+            blbu = bl;\n+\n+            // Now \"al\" and \"bl\" fit in an \"int\".\n+            b = (int) al;\n+            a = (int) (blbu % al);\n+        }\n+\n+        return gcdPositive(a, b);\n+    }\n+\n+    /**\n+     * Computes the greatest common divisor of two <em>positive</em> numbers\n+     * (this precondition is <em>not</em> checked and the result is undefined\n+     * if not fulfilled) using the \"binary gcd\" method which avoids division\n+     * and modulo operations.\n+     * See Knuth 4.5.2 algorithm B.\n+     * The algorithm is due to Josef Stein (1961).\n+     * <br/>\n+     * Special cases:\n+     * <ul>\n+     *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     *   {@code gcd(x, 0)} is the value of {@code x}.</li>\n+     *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     *   {@code 0}.</li>\n+     * </ul>\n+     *\n+     * @param a Positive number.\n+     * @param b Positive number.\n+     * @return the greatest common divisor.\n+     */\n+    private static int gcdPositive(int a,\n+                                   int b) {\n+        if (a == 0) {\n+            return b;\n+        }\n+        else if (b == 0) {\n+            return a;\n+        }\n+\n+        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n+        final int aTwos = Integer.numberOfTrailingZeros(a);\n+        a >>= aTwos;\n+        final int bTwos = Integer.numberOfTrailingZeros(b);\n+        b >>= bTwos;\n+        final int shift = Math.min(aTwos, bTwos);\n+\n+        // \"a\" and \"b\" are positive.\n+        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n+        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n+        // Hence, in the successive iterations:\n+        //  \"a\" becomes the absolute difference of the current values,\n+        //  \"b\" becomes the minimum of the current values.\n+        while (a != b) {\n+            final int delta = a - b;\n+            b = Math.min(a, b);\n+            a = Math.abs(delta);\n+\n+            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n+            a >>= Integer.numberOfTrailingZeros(a);\n+        }\n+\n+        // Recover the common power of 2.\n+        return a << shift;\n     }\n \n     /**", "timestamp": 1346856419, "metainfo": ""}