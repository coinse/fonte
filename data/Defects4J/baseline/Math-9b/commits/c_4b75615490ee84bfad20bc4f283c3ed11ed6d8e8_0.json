{"sha": "4b75615490ee84bfad20bc4f283c3ed11ed6d8e8", "log": "Added a normalization feature to transform samples so they have zero mean and unit standard deviation Jira: MATH-426  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n         }\n         return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n     }\n+    \n+    \n+\t/**\n+\t * Normalize (standardize) the series, so in the end it is having a mean of 0 and a standard deviation of 1.\n+\t * \n+\t * @param sample sample to normalize\n+\t * @return normalized (standardized) sample\n+\t */\n+\tpublic static double[] normalize(final double[] sample) {\n+\t\tDescriptiveStatistics stats = new DescriptiveStatistics();\n+\n+\t\t// Add the data from the series to stats\n+\t\tfor (int i = 0; i < sample.length; i++) {\n+\t\t\tstats.addValue(sample[i]);\n+\t\t}\n+\n+\t\t// Compute mean and standard deviation\n+\t\tdouble mean = stats.getMean();\n+\t\tdouble standardDeviation = stats.getStandardDeviation();\n+\n+\t\t// initialize the standardizedSample, which has the same length as the sample \n+\t\tdouble[] standardizedSample = new double[sample.length];\n+\n+\t\tfor (int i = 0; i < sample.length; i++) {\n+\t\t\t// z = (x- mean)/standardDeviation\n+\t\t\tstandardizedSample[i] = (sample[i] - mean) / standardDeviation;\n+\t\t}\n+\t\treturn standardizedSample;\n+\t}\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n     }\n+    \n+    \n+\t/**\n+\t * Run the test with the values 50 and 100 and assume standardized values \n+\t */\n+\n+\tpublic void testNormalize1() {\n+\t\tdouble sample[] = { 50, 100 };\n+\t\tdouble expectedSample[] = { -25 / Math.sqrt(1250), 25 / Math.sqrt(1250) };\n+\t\tdouble[] out = StatUtils.normalize(sample);\n+\t\tfor (int i = 0; i < out.length; i++) {\n+\t\t\tassertEquals(out[i], expectedSample[i]);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Run with 77 random values, assuming that the outcome has a mean of 0 and a standard deviation of 1 with a\n+\t * precision of 1E-10.\n+\t */\n+\n+\tpublic void testNormalize2() {\n+\t\t// create an sample with 77 values \n+\t\tint length = 77;\n+\t\tdouble sample[] = new double[length];\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tsample[i] = Math.random();\n+\t\t}\n+\t\t// normalize this sample\n+\t\tdouble standardizedSample[] = StatUtils.normalize(sample);\n+\n+\t\tDescriptiveStatistics stats = new DescriptiveStatistics();\n+\t\t// Add the data from the array\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tstats.addValue(standardizedSample[i]);\n+\t\t}\n+\t\t// the calculations do have a limited precision  \n+\t\tdouble distance = 1E-10;\n+\t\t// check the mean an standard deviation\n+\t\tassertEquals(0.0, stats.getMean(), distance);\n+\t\tassertEquals(1.0, stats.getStandardDeviation(), distance);\n+\n+\t}\n+    \n }", "timestamp": 1290288704, "metainfo": ""}