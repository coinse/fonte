{"sha": "725eff7db400661631416be3d58bb2758a793b7a", "log": "Commited patch for issue 20112 from Phil Steitz.  EmpiricalDistribution -- represents an empirical probability distribution and supports generation of data values that are \"like\" values in an input file without making any assumptions about the functional form of the probability distribution that the data come from.   This is useful in simulation applications where historical data about component performance are available but do not follow standard distributions (or any application that requires random data generation from an empirical distribution). Also generates data for grouped frequency histograms based on the input file.  ValueServer -- a wrapper for RandomData and EmpiricalDistribution that generates values in each of the following modes:   * DIGEST_MODE -- uses an empirical distribution   * REPLAY_MODE -- replays data from an input file   * UNIFORM_MODE -- generates uniformly distributed random values   * EXPONENTIAL_MODE -- generates exponentially distributed random                         values   * GAUSSIAN_MODE -- generates Gaussian distributed random values   * CONSTANT_MODE -- returns the same value every time.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/EmpiricalDistribution.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.util.ArrayList;\n+\n+/**\n+ * Represents an <a href=http://random.mat.sbg.ac.at/~ste/dipl/node11.html>\n+ * empirical probability distribution</a> -- a probability distribution derived\n+ * from observed data without making any assumptions about the functional form\n+ * of the population distribution that the data come from.<p>\n+ * Implementations of this interface maintain data structures, called \n+ * <i>distribution digests</i>, that describe empirical distributions and \n+ * support the following operations: <ul>\n+ * <li>loading the distribution from a file of observed data values</li>\n+ * <li>saving and re-loading distribution digests to/from \"digest files\" </li>\n+ * <li>dividing the input data into \"bin ranges\" and reporting bin frequency\n+ *     counts (data for histogram)</li>\n+ * <li>reporting univariate statistics describing the full set of data values\n+ *     as well as the observations within each bin</li>\n+ * <li>generating random values from the distribution</li>\n+ * </ul>\n+ * Applications can use <code>EmpiricalDistribution</code> implementations to \n+ * build grouped frequnecy histograms representing the input data or to\n+ * generate random values \"like\" those in the input file -- i.e., the values\n+ * generated will follow the distribution of the values in the file.\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+public interface EmpiricalDistribution {\n+    \n+    /**\n+     * Computes the empirical distribution from the input file\n+     * @param filePath fully qualified name of a file in the local file system\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(String filePath) throws IOException; \n+    \n+    /**\n+     * Computes the empirical distribution from the input file\n+     * @param URL url of the input file\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(File file) throws IOException;\n+    \n+    /** \n+     * Generates a random value from this distribution<p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    double getNextValue() throws IllegalStateException;  \n+    \n+     \n+    /** \n+     * <p>Returns a Univariate describing this distribution</p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    Univariate getSampleStats();\n+    \n+    /** \n+     * Loads a saved distribution from a file.\n+     * @param file File reference for a file containing a digested distribution\n+     * @throws IOException if an error occurs reading the file\n+     */\n+    void loadDistribution(File file) throws IOException;  \n+    \n+    /** \n+     * Loads a saved distribution from a file.\n+     * @param filePath fully qualified file path for a file \n+     * containing a digested distribution \n+     * @throws IOException if an error occurs reading the file\n+     */\n+    void loadDistribution(String filePath) throws IOException; \n+    \n+    /** \n+     * Saves distribution to a file. Overwrites the file if it exists.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @param fully qualified file path for the file to be written\n+     * @throws IOException if an error occurs reading the file\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    void saveDistribution(String filePath) throws \n+        IOException,IllegalStateException;\n+    \n+    /** \n+     * Saves distribution to a file. Overwrites the file if it exists.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @param file File reference for the file to be written\n+     * @throws IOException if an error occurs reading the file\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    void saveDistribution(File file) throws IOException,IllegalStateException;\n+    \n+    /**\n+     * property indicating whether or not the distribution has been loaded\n+     * @return true if the distribution has been loaded\n+     */\n+    boolean isLoaded();  \n+    \n+     /** \n+     * Returns the number of bins\n+     * @return the number of bins.\n+     */\n+    int getBinCount();\n+    \n+    /** \n+     * Returns a list of Univariates containing statistics describing the\n+     * values in each of the bins.  The ArrayList is indexed on the bin number.\n+     * @return ArrayList of bin statistics.\n+     */\n+    ArrayList getBinStats();\n+    \n+    /** \n+     * Returns the array of upper bounds for the bins.  Bins are: <br>\n+     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n+     *  (upperBounds[binCount-1],max]\n+     * @return array of bin upper bounds\n+     */\n+    double[] getUpperBounds();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/EmpiricalDistributionImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.ArrayList;\n+import java.io.Serializable;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.File;\n+import java.io.IOException;\n+\n+/**\n+ * Implements <code>EmpiricalDistribution</code> interface using \n+ * what amounts to the \n+ * <a href=http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html>\n+ * Variable Kernel Method</a> with Gaussian smoothing:<p>\n+ * <strong>Digesting the input file</strong>\n+ * <ol><li>Pass the file once to compute min and max.</li>  \n+ * <li>Divide the range from min-max into <code>binCount</code> \"bins.\"</li>\n+ * <li>Pass the data file again, computing bin counts and univariate\n+ *     statistics (mean, std dev.) for each of the bins </li>\n+ * <li>Divide the interval (0,1) into subintervals associated with the bins,\n+ *     with the length of a bin's subinterval proportional to its count.</li></ol>\n+ * <strong>Generating random values from the distribution</strong><ol>\n+ * <li>Generate a uniformly distributed value in (0,1) </li>\n+ * <li>Select the subinterval to which the value belongs.\n+ * <li>Generate a random Gaussian value with mean = mean of the associated\n+ *     bin and std dev = std dev of associated bin.</li></ol></p><p>\n+ *<strong>USAGE NOTES:</strong><ul>\n+ *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n+ *    is to set the bin count to approximately the length of the input file divided\n+ *    by 10.  See TODO: add reference </li>\n+ *<li>The input file <i>must</i> be a plain text file containing one valid numeric\n+ *    entry per line.</li>\n+ * </ol></p>\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+public class EmpiricalDistributionImpl implements Serializable,EmpiricalDistribution {\n+\n+    \n+    /** List of Univariate objects characterizing the bins */\n+    private ArrayList binStats = null;\n+    \n+    /** Sample statistics */\n+    Univariate sampleStats = null;\n+    \n+    /** number of bins */\n+    private int binCount = 1000;\n+    \n+    /** is the distribution loaded? */\n+    private boolean loaded = false;\n+    \n+    /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n+    private double[] upperBounds = null;\n+    \n+    /** \n+     * Creates a new EmpiricalDistribution  with the default bin count\n+     */\n+    public EmpiricalDistributionImpl() {\n+        binStats = new ArrayList();\n+    }\n+    \n+    /** \n+     * Creates a new EmpiricalDistribution  with the specified bin count\n+     * @param binCount number of bins\n+     */\n+    public EmpiricalDistributionImpl(int binCount) {\n+        this.binCount = binCount;\n+        binStats = new ArrayList();\n+    }\n+    \n+    \n+    public void load(String filePath) throws IOException {\n+        File file = new File(filePath);\n+        load(file);\n+    }\n+    \n+     \n+    public void load(File file) throws IOException {\n+        // Pass the file once to get sample stats\n+         BufferedReader in = null;\n+         try {  \n+            in = new BufferedReader(new FileReader(file));\n+            String str = null;\n+            double val = 0.0;\n+            sampleStats = new UnivariateImpl();\n+            while ((str = in.readLine()) != null) {\n+              val = new Double(str).doubleValue();\n+              sampleStats.addValue(val);   \n+            }\n+            in.close();\n+            in = null;\n+         } finally {\n+             if (in != null) try {in.close();} catch (Exception ex) {};\n+         }               \n+        \n+         // Load array of bin upper bounds -- evenly spaced from min - max\n+         double min = sampleStats.getMin();\n+         double max = sampleStats.getMax();\n+         double delta = (max - min)/(new Double(binCount)).doubleValue();\n+         double[] binUpperBounds = new double[binCount];\n+         binUpperBounds[0] = min + delta;\n+         for (int i = 1; i< binCount - 1; i++) {\n+             binUpperBounds[i] = binUpperBounds[i-1] + delta;\n+         }\n+         binUpperBounds[binCount -1] = max;\n+         \n+        // Initialize binStats ArrayList\n+        if (!binStats.isEmpty()) {\n+            binStats.clear();\n+        }\n+        for (int i = 0; i < binCount; i++) {\n+            Univariate stats = new UnivariateImpl();\n+            binStats.add(i,stats);\n+        }\n+         \n+        // Pass the data again, filling data in binStats Array \n+         try {\n+            in = new BufferedReader(new FileReader(file));\n+            String str = null;\n+            double val = 0.0d;\n+            while ((str = in.readLine()) != null) {\n+              val = new Double(str).doubleValue();\n+              \n+              // Find bin and add value to binStats for the bin\n+              boolean found = false;\n+              int i = 0; \n+              while (!found) {\n+                  if (i >= binCount) {\n+                      throw new RuntimeException(\"bin alignment error\");\n+                  }\n+                  if (val <= binUpperBounds[i]) {\n+                      found = true;\n+                      Univariate stats = (Univariate)binStats.get(i);\n+                      stats.addValue(val);\n+                  }\n+                  i++;\n+              }       \n+            }\n+            in.close();\n+            in = null;\n+         } finally {\n+             if (in != null) try {in.close();} catch (Exception ex) {};\n+         }               \n+        \n+         // Assign upperBounds based on bin counts\n+         upperBounds = new double[binCount];\n+         upperBounds[0] = \n+            (((Univariate)binStats.get(0)).getN())/sampleStats.getN();\n+         for (int i = 1; i < binCount-1; i++) {\n+             upperBounds[i] = upperBounds[i-1] +\n+               (((Univariate)binStats.get(i)).getN())/sampleStats.getN();\n+         }\n+         upperBounds[binCount-1] = 1.0d;   \n+         \n+         loaded = true;\n+    }\n+    \n+    /** Generates a random value from this distribution */\n+    public double getNextValue() throws IllegalStateException {    \n+        \n+        if (!loaded) {\n+            throw new IllegalStateException(\"distribution not loaded\");\n+        }\n+        \n+        // Start with a uniformly distributed random number in (0,1)\n+        double x = Math.random();\n+       \n+        // Use this to select the bin and generate a Gaussian within the bin\n+        RandomData rd = new RandomDataImpl();\n+        for (int i = 0; i < binCount; i++) {\n+           if (x <= upperBounds[i]) {\n+               Univariate stats = (Univariate)binStats.get(i);\n+               if (stats.getN() > 0.5) { // really mean > 0, but avoid fp error\n+                   if (stats.getStandardDeviation() > 0) {  // more than one obs \n+                        return rd.nextGaussian\n+                            (stats.getMean(),stats.getStandardDeviation());\n+                   } else {\n+                       return stats.getMean(); // only one obs in bin\n+                   }\n+               }\n+           }\n+        }\n+        throw new RuntimeException(\"No bin selected\");\n+    }\n+       \n+    public void loadDistribution(String filePath) throws IOException {\n+        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+    \n+    public void loadDistribution(File file) throws IOException {\n+        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+       \n+    public void saveDistribution(String filePath) throws \n+        IOException,IllegalStateException {\n+       throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+    \n+    public void saveDistribution(File file) throws \n+        IOException,IllegalStateException {\n+       throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+        \n+    public Univariate getSampleStats() {\n+        return sampleStats;\n+    }\n+    \n+    public int getBinCount() {\n+        return binCount;\n+    }\n+      \n+    public ArrayList getBinStats() {\n+        return binStats;\n+    }\n+       \n+    public double[] getUpperBounds() {\n+        return upperBounds;\n+    }\n+    \n+    public boolean isLoaded() {\n+        return loaded;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ValueServer.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.File;\n+import java.net.URL;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+\n+/**\n+ * Generates values for use in simulation applications.<br>\n+ * How values are generated is determined by the <code>mode</code>\n+ * property. <p> \n+ * Supported <code>mode</code> values are: <ul>\n+ * <li> DIGEST_MODE -- uses an empirical distribution </li>\n+ * <li> REPLAY_MODE -- replays data from <code>valuesFile</code></li> \n+ * <li> UNIFORM_MODE -- generates uniformly distributed random values with\n+ *                      mean = <code>mu</code> </li>\n+ * <li> EXPONENTIAL_MODE -- generates exponentially distributed random values\n+ *                         with mean = <code>mu</code></li>\n+ * <li> GAUSSIAN_MODE -- generates Gaussian distributed random values with\n+ *                       mean = <code>mu</code> and \n+ *                       standard deviation = <code>sigma</code></li>\n+ * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul> \n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ *\n+ */\n+public class ValueServer {\n+    /** mode determines how values are generated */\n+    private int mode = 5;\n+    \n+    /** URI to raw data values  */\n+    private URL valuesFileURL = null;\n+    \n+    /** Mean for use with non-data-driven modes */\n+    private double mu = 0.0;\n+    \n+    /** Standard deviation for use with GAUSSIAN_MODE */\n+    private double sigma = 0.0;\n+    \n+    /** Empirical probability distribution for use with DIGEST_MODE */\n+    private EmpiricalDistribution empiricalDistribution = null;\n+    \n+    /** file pointer for REPLAY_MODE */\n+    private BufferedReader filePointer = null;\n+    \n+    /** RandomDataImpl to use for random data generation */\n+    private RandomDataImpl randomData = new RandomDataImpl();\n+    \n+    // Data generation modes ======================================\n+   \n+    /** Use empirical distribution  */\n+    public static final int DIGEST_MODE = 0;        \n+    \n+    /** Replay data from valuesFilePath */\n+    public static final int REPLAY_MODE = 1;      \n+    \n+    /** Uniform random variates with mean = mu */\n+    public static final int UNIFORM_MODE = 2;    \n+    \n+    /** Exponential random variates with mean = mu */\n+    public static final int EXPONENTIAL_MODE = 3;  \n+    \n+    /** Gaussian random variates with mean = mu, std dev = sigma */\n+    public static final int GAUSSIAN_MODE = 4;  \n+    \n+    /** Always return mu */\n+    public static final int CONSTANT_MODE = 5;   \n+    \n+    /** Creates new ValueServer */\n+    public ValueServer() {\n+    }\n+\n+    /** \n+     * Returns the next generated value, generated according\n+     * to the mode value (see MODE constants) \n+     *\n+     * @return generated value \n+     * @throws IOException in REPLAY_MODE if file I/O error occurs\n+     */\n+    public double getNext() throws IOException {\n+        switch (mode) {\n+            case DIGEST_MODE: return getNextDigest();\n+            case REPLAY_MODE: return getNextReplay();\n+            case UNIFORM_MODE: return getNextUniform();\n+            case EXPONENTIAL_MODE: return getNextExponential();\n+            case GAUSSIAN_MODE: return getNextGaussian();\n+            case CONSTANT_MODE: return mu;\n+            default: throw new IllegalStateException\n+                       (\"Bad mode: \" + mode);\n+        }\n+    }\n+    \n+    /** \n+     * Computes the empirical distribution using values from file\n+     * in <code>valuesFilePath</code>, using the default number of bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be\n+     * readable by *this at runtime.\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DISGEST_MODE</code>\n+     *\n+     * @throws IOException if an I/O error occurs reading the input file\n+     */\n+    public void computeDistribution() throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl();\n+        empiricalDistribution.load(valuesFileURL.getFile());\n+    }\n+    \n+    /** \n+     * Computes the empirical distribution using values from the file\n+     * in <code>valuesFilePath</code> and <code>binCount</code> bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be\n+     * readable by *this at runtime.\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DISGEST_MODE</code>\n+     *\n+     * @throws IOException if an error occurs reading the input file\n+     */\n+    public void computeDistribution(int binCount) \n+            throws IOException{\n+        empiricalDistribution = new EmpiricalDistributionImpl(binCount);\n+        empiricalDistribution.load(valuesFileURL.getFile());\n+        mu = empiricalDistribution.getSampleStats().getMean();\n+        sigma = empiricalDistribution.getSampleStats().getStandardDeviation();\n+    }\n+    \n+    /** \n+     * Gets a random value in DIGEST_MODE.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Before this method is called, <code>computeDistribution()</code>\n+     * must have completed successfully; otherwise an \n+     * <code>IllegalStateException</code> will be thrown</li></ul>\n+     *\n+     * @return next random value form the empirical distribution digest \n+     */\n+    private double getNextDigest() {\n+        if ((empiricalDistribution == null) ||\n+            (empiricalDistribution.getBinStats().size() == 0)) {\n+            throw new IllegalStateException(\"Digest not initialized\");\n+        }\n+        return empiricalDistribution.getNextValue();     \n+    }\n+    \n+    /**\n+     * Gets next sequential value from the <code>valuesFilePath</code> \n+     * opened by <code>openReplayFile()</code>.\n+     * <p>\n+     * Throws an IOException if <code>filePointer</code> is null or read fails.\n+     * Will wrap around to BOF is EOF is encountered.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li> openReplayfile() must have completed successfully before \n+     * invoking this method; otherwise an <code>IlleglaStateException</code>\n+     * will be thrown</li></ul>\n+     *\n+     * @return next value from the replay file\n+     * @throws IOException if there is a problem reading from the file\n+     */\n+    private double getNextReplay() throws IOException{\n+        String str = null;\n+        if (filePointer == null) {\n+            throw new IllegalStateException(\"replay file not open\");\n+        }\n+        if ((str = filePointer.readLine()) == null) {\n+            closeReplayFile();\n+            openReplayFile();\n+            str = filePointer.readLine();\n+        }         \n+        return new Double(str).doubleValue();\n+    }\n+    \n+    /** \n+     * Gets a uniformly distributed random value with mean = mu \n+     *\n+     * @return random uniform value\n+     */\n+    private double getNextUniform() {\n+        return 2.0*mu*Math.random();\n+    }\n+    \n+    /** \n+     * Gets an exponentially distributed random value with mean = mu \n+     *\n+     * @return random exponential value\n+     */\n+    private double getNextExponential() {\n+        return randomData.nextExponential(mu);    \n+    }\n+    \n+    /** \n+     * Gets a Gaussian distributed random value with mean = mu\n+     * and standard deviation = sigma\n+     *\n+     * @return random Gaussian value\n+     */\n+    private double getNextGaussian() {\n+        return randomData.nextGaussian(mu,sigma);\n+    }\n+    \n+    /** Getter for property mode.\n+     * @return Value of property mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+    \n+    /** Setter for property mode.\n+     * @param mode New value of property mode.\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+    \n+    /** Getter for property valuesFilePath.\n+     * @return Value of property valuesFilePath.\n+     */\n+    public String getValuesFileURL() {\n+        return valuesFileURL.toString();\n+    }\n+    \n+    /** Setter for property valuesFilePath.\n+     * @param valuesFilePath New value of property valuesFilePath.\n+     */\n+    public void setValuesFileURL(String URL) throws MalformedURLException {\n+        this.valuesFileURL = new URL(URL);\n+    }\n+    \n+    /** Getter for property empiricalDistribution.\n+     * @return Value of property empiricalDistribution.\n+     */\n+    public EmpiricalDistribution getEmpiricalDistribution() {\n+        return empiricalDistribution;\n+    }    \n+    \n+    /**  \n+     * Opens <code>valuesFilePath</code> to use in REPLAY_MODE\n+     *\n+     * @throws IOException if an error occurs opening the file\n+     */\n+    public void openReplayFile() throws IOException {\n+        filePointer = new BufferedReader(new FileReader\n+                            (new File(valuesFileURL.getFile())));\n+    }\n+    \n+    /** \n+     * Closes <code>valuesFilePath</code> after use in REPLAY_MODE\n+     *\n+     * @throws IOException if an error occurs closing the file\n+     */\n+    public void closeReplayFile() throws IOException {\n+        if (filePointer != null) {\n+            filePointer.close();\n+        }     \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/EmpiricalDistributionTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.framework.AssertionFailedError;\n+import java.io.File;\n+import java.net.URL;\n+\n+/**\n+ * Test cases for the EmpiricalDistribution class\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/05/21 14:21:15 $\n+ */\n+\n+public final class EmpiricalDistributionTest extends TestCase {\n+\n+    private EmpiricalDistribution empiricalDistribution = null;\n+    private File file = null;\n+    \n+    public EmpiricalDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        empiricalDistribution = new EmpiricalDistributionImpl(100);\n+        URL url = getClass().getResource(\"testData.txt\");\n+        file = new File(url.getFile());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);\n+        suite.setName(\"EmpiricalDistribution Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Test EmpiricalDistrbution.load() using sample data file.<br> \n+     * Check that the sampleCount, mu and sigma match data in \n+     * the sample data file.\n+     */\n+    public void testLoad() throws Exception {\n+        empiricalDistribution.load(file);   \n+        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n+        // Make sure that loaded distribution matches this\n+        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n+        //TODO: replace with statistical tests\n+        assertEquals\n+            (empiricalDistribution.getSampleStats().getMean(),\n+                5.069831575018909,10E-7);\n+        assertEquals\n+          (empiricalDistribution.getSampleStats().getStandardDeviation(),\n+                1.0173699343977738,10E-7);\n+    }\n+    \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNext() throws Exception {\n+        tstGen(0.1);\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+     */\n+    public void testNexFail() {\n+        try {\n+            empiricalDistribution.getNextValue();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+     * Make sure we can handle a grid size that is too fine\n+     */\n+    public void testGridTooFine() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(10000);\n+        tstGen(0.1);    \n+    }\n+    \n+    /**\n+     * How about too fat?\n+     */\n+    public void testGridTooFat() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(1);\n+        tstGen(5); // ridiculous tolerance; but ridiculous grid size\n+                   // really just checking to make sure we do not bomb\n+    }\n+    \n+    private void tstGen(double tolerance)throws Exception {\n+        empiricalDistribution.load(file);   \n+        Univariate stats = new UnivariateImpl();\n+        for (int i = 1; i < 1000; i++) {\n+            stats.addValue(empiricalDistribution.getNextValue());\n+        }\n+        //TODO: replace these with statistical tests -- refactor as necessary\n+        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        assertEquals\n+         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+    }\n+        \n+        \n+       \n+        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ValueServerTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.framework.AssertionFailedError;\n+import java.net.URL;\n+ \n+/**\n+ * Test cases for the ValueServer class.\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+\n+public final class ValueServerTest extends TestCase {\n+\n+    private ValueServer vs = new ValueServer();\n+    \n+    public ValueServerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        vs.setMode(ValueServer.DIGEST_MODE);\n+        try {\n+            URL url = getClass().getResource(\"testData.txt\");\n+            vs.setValuesFileURL(url.toExternalForm()); \n+        } catch (Exception ex) {\n+            fail(\"malformed test URL\");\n+        }\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValueServerTest.class);\n+        suite.setName(\"ValueServer Tests\");\n+        return suite;\n+    }\n+\n+   \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNextDigest() throws Exception{\n+        double next = 0.0;\n+        double tolerance = 0.1;\n+        vs.computeDistribution();\n+        Univariate stats = new UnivariateImpl();\n+        for (int i = 1; i < 1000; i++) {\n+            next = vs.getNext();\n+            stats.addValue(next);\n+        }    \n+        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        assertEquals\n+         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+      */\n+    public void testNextDigestFail() throws Exception {\n+        try {\n+            vs.getNext();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if nextReplay() is attempted\n+      * before opening replay file.\n+      */\n+    public void testNextReplayFail() throws Exception {\n+        try {\n+            vs.setMode(ValueServer.REPLAY_MODE);\n+            vs.getNext();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+     * Test ValueServer REPLAY_MODE using values in testData file.<br> \n+     * Check that the values 1,2,1001,1002 match data file values 1 and 2.\n+     * the sample data file.\n+     */\n+    public void testReplay() throws Exception {\n+        double firstDataValue = 4.038625496201205;\n+        double secondDataValue = 3.6485326248346936;\n+        double tolerance = 10E-15;\n+        double compareValue = 0.0d;\n+        vs.setMode(ValueServer.REPLAY_MODE);\n+        vs.openReplayFile();\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+        for (int i = 3; i < 1001; i++) {\n+           compareValue = vs.getNext();\n+        }\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+    }\n+}", "timestamp": 1053526875, "metainfo": ""}