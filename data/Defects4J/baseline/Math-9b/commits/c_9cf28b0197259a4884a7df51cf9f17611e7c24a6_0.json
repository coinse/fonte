{"sha": "9cf28b0197259a4884a7df51cf9f17611e7c24a6", "log": "This commit adds the constructor and internals for setting and External Moment object to base internal calculations on. It also remove author tags and adds a new class FirstMoment to the project.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat.univariate.moment;\n+\n+import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * \n+ */\n+public class FirstMoment extends AbstractStorelessUnivariateStatistic {\n+\n+    /** count of values that have been added */\n+    protected int n = 0;\n+\n+    /** first moment of values that have been added */\n+    protected double m1 = Double.NaN;\n+    \n+    /** temporary internal state made available for higher order moments */\n+    protected double dev = 0.0;\n+    \n+    /** temporary internal state made available for higher order moments */\n+    protected double v = 0.0;\n+    \n+    /** temporary internal state made available for higher order moments */\n+    protected double n0 = 0.0;\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public double increment(double d) {\n+        if (n < 1) {\n+             m1 = 0.0;\n+        }\n+        \n+        n++;\n+        dev = d - m1;\n+        n0 = (double)n;\n+        v = dev / n0;\n+\n+        return m1 += v;                    \n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        m1 = Double.NaN;\n+        n = 0;\n+        dev = 0.0;\n+        v = 0.0;\n+        n0 = 0.0;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n+     */\n+    public double getValue() {\n+        return m1;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n public class FourthMoment extends ThirdMoment {\n \n     /** fourth moment of values that have been added */\n     protected double m4 = Double.NaN;\n+    \n+    /** temporary internal state made available for higher order moments */\n+    protected double prevM3 = 0.0;\n \n+    /** temporary internal state made available for higher order moments */\n+    protected double n3 = 0.0;\n+            \n+            \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n             m4 = m3 = m2 = m1 = 0.0;\n         }\n \n-        n++;\n-        double dev = d - m1;\n-        double v = dev / ((double) n);\n-        double v2 = v * v;\n+        /* retain previous m3 */\n+        prevM3 = m3;\n+        \n+        /* increment m1, m2 and m3 (and prevM2, _n0, _n1, _n2, _v, _v2) */\n+        super.increment(d);\n \n-        double n0 = (double) n;\n-        double n1 = (double) (n - 1);\n-        double n2 = (double) (n - 2);\n-\n+        n3 = (double) (n - 3);\n+        \n         m4 =\n             m4\n-                - (4.0 * v * m3)\n-                + (6.0 * v2 * m2)\n+                - (4.0 * v * prevM3)\n+                + (6.0 * v2 * prevM2)\n                 + ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n-\n-        m3 = m3 - (3.0 * v * m2) + (n0 * n1 * n2 * v2 * v);\n-\n-        m2 = m2 + n1 * dev * v;\n-\n-        m1 = m1 + v;\n \n         return m4;\n     }\n-\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public void clear() {\n         super.clear();\n         m4 = Double.NaN;\n+        prevM3 = 0.0;\n+        n3 = 0.0;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n \n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n public class GeometricMean extends SumOfLogs {\n  \n-    //private SumOfLogs sumLog = new SumOfLogs();\n-    \n     private double geoMean = Double.NaN;\n     \n     private int n = 0;\n     }\n     \n     /**\n+     * Returns the geometric mean for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the geometric mean or Double.NaN if the array is empty or\n+     * any of the values are &lt;= 0.\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n+\n /**\n- * @author Mark Diggory\n+ *\n  */\n-public class Kurtosis extends FourthMoment {\n+public class Kurtosis extends AbstractStorelessUnivariateStatistic {\n \n     private double kurtosis = Double.NaN;\n+\n+    protected FourthMoment moment = null;\n+\n+    protected boolean incMoment = true;\n+\n+    public Kurtosis() {\n+        moment = new FourthMoment();\n+    }\n+\n+    public Kurtosis(FourthMoment m4) {\n+        incMoment = false;\n+        this.moment = m4;\n+    }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        super.increment(d);\n-        \n-        double variance = (n <= 1) ? 0.0 : m2 / (double) (n - 1);\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+\n+        double variance =\n+            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n \n         kurtosis =\n-            (n <= 3 || variance < 10E-20)\n+            (moment.n <= 3 || variance < 10E-20)\n                 ? 0.0\n-                : ((double)n * ((double)n + 1) * m4 - 3 * m2 * m2 * (n-1))\n-                    / ((n-1) * (n-2) * (n-3) * variance * variance);\n-        \n+                : (moment.n0 * (moment.n0 + 1) * moment.m4\n+                    - 3 * moment.m2 * moment.m2 * moment.n1)\n+                    / (moment.n1 * moment.n2 * moment.n3 * variance * variance);\n+\n         return kurtosis;\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n         return kurtosis;\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        super.clear();\n+        if (incMoment) {\n+            moment.clear();\n+        }\n         kurtosis = Double.NaN;\n     }\n \n+    /*UnvariateStatistic Approach */\n+\n+    Mean mean = new Mean();\n+\n     /**\n-        * Returns the kurtosis for this collection of values. Kurtosis is a \n-        * measure of the \"peakedness\" of a distribution.\n-        * @param values Is a double[] containing the values\n-        * @param begin processing at this point in the array\n-        * @param length processing at this point in the array\n-        * @return the kurtosis of the values or Double.NaN if the array is empty\n-        */\n-       public double evaluate(double[] values, int begin, int length) {\n-           test(values, begin, length);\n+    * This algorithm uses a corrected two pass algorithm of the following \n+    * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n+    * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n+    * \"Algorithms for Computing the Sample Variance: Analysis and\n+    * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+    * 1983, American Statistician, vol. 37, pp. 242?247.\n+    * <p/>\n+    * Returns the kurtosis for this collection of values. Kurtosis is a \n+    * measure of the \"peakedness\" of a distribution.\n+    * @param values Is a double[] containing the values\n+    * @param begin processing at this point in the array\n+    * @param length processing at this point in the array\n+    * @return the kurtosis of the values or Double.NaN if the array is empty\n+    */\n+    public double evaluate(double[] values, int begin, int length) {\n+        test(values, begin, length);\n \n-           // Initialize the kurtosis\n-           double kurt = Double.NaN;\n+        // Initialize the kurtosis\n+        double kurt = Double.NaN;\n \n-           // Get the mean and the standard deviation\n-           double mean = super.evaluate(values, begin, length);\n+        // Get the mean and the standard deviation\n+        double m = mean.evaluate(values, begin, length);\n \n-           // Calc the std, this is implemented here instead of using the \n-           // standardDeviation method eliminate a duplicate pass to get the mean\n-           double accum = 0.0;\n-           double accum2 = 0.0;\n-           for (int i = begin; i < begin + length; i++) {\n-               accum += Math.pow((values[i] - mean), 2.0);\n-               accum2 += (values[i] - mean);\n-           }\n-        \n-           double stdDev =\n-               Math.sqrt(\n-                   (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                       / (double) (length - 1));\n+        // Calc the std, this is implemented here instead of using the \n+        // standardDeviation method eliminate a duplicate pass to get the mean\n+        double accum = 0.0;\n+        double accum2 = 0.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            accum += Math.pow((values[i] - m), 2.0);\n+            accum2 += (values[i] - m);\n+        }\n \n-           // Sum the ^4 of the distance from the mean divided by the \n-           // standard deviation\n-           double accum3 = 0.0;\n-           for (int i = begin; i < begin + length; i++) {\n-               accum3 += Math.pow((values[i] - mean) / stdDev, 4.0);\n-           }\n+        double stdDev =\n+            Math.sqrt(\n+                (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                    / (double) (length - 1));\n \n-           // Get N\n-           double n = length;\n+        // Sum the ^4 of the distance from the mean divided by the \n+        // standard deviation\n+        double accum3 = 0.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            accum3 += Math.pow((values[i] - m) / stdDev, 4.0);\n+        }\n \n-           double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-           double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n-        \n-           // Calculate kurtosis\n-           kurt = (coefficientOne * accum3) - termTwo;\n+        // Get N\n+        double n = length;\n \n-           return kurt;\n-       }\n-       \n+        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n+\n+        // Calculate kurtosis\n+        kurt = (coefficientOne * accum3) - termTwo;\n+\n+        return kurt;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.univariate.summary.Sum;\n \n /**\n- * @author Mark Diggory\n+ *\n  */\n public class Mean extends AbstractStorelessUnivariateStatistic {\n \n+    /** first moment of values that have been added */\n+    protected FirstMoment moment = null;\n \n-    /** count of values that have been added */\n-    protected int n = 0;\n+    protected boolean incMoment = true;\n \n-    /** first moment of values that have been added */\n-    protected double m1 = Double.NaN;\n-    \n-    private Sum sum = new Sum();\n-    \n+    public Mean() {\n+        moment = new FirstMoment();\n+    }\n+\n+    public Mean(FirstMoment m1) {\n+        this.moment = m1;\n+        incMoment = false;\n+    }\n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        if (n < 1) {\n-             m1 = 0.0;\n+        if (incMoment) {\n+            moment.increment(d);\n         }\n-         \n-        n++;\n-        m1 += (d - m1) / ((double) n);\n-        return m1;\n+\n+        return moment.m1;\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        m1 = Double.NaN;\n-        n = 0;\n+        if (incMoment) {\n+            moment.clear();\n+        }\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return m1;\n+        return moment.m1;\n     }\n \n+    /*UnvariateStatistic Approach */\n+    Sum sum = new Sum();\n+\n     /**\n+     * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n+     * arithmetic mean </a> of the available values \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the mean of the values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n-        if(test(values,begin,length))\n+        if (test(values, begin, length)) {\n             return sum.evaluate(values, begin, length) / ((double) length);\n+        }\n         return Double.NaN;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org\n-    .apache\n-    .commons\n-    .math\n-    .stat\n-    .univariate\n-    .AbstractStorelessUnivariateStatistic;\n-\n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n-public class SecondMoment extends Mean {\n+public class SecondMoment extends FirstMoment {\n \n     /** second moment of values that have been added */\n     protected double m2 = Double.NaN;\n \n+    /** temporary internal state made availabel for higher order moments */\n+    protected double n1 = 0.0;\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n         if (n < 1) {\n             m1 = m2 = 0.0;\n         }\n+        \n+        /* increment m1 and _n0, _dev,  _v) */\n+        super.increment(d);\n \n-        n++;\n-\n-        double dev = d - m1;\n-        double v = dev / ((double) n);\n-\n-        m2 += ((double)(n - 1)) * dev * v;\n-        m1 += v;\n+        n1 = n0 - 1;\n+        \n+        /* increment and return m2 */\n+        m2 += n1 * dev * v;\n         \n         return m2;\n+        \n     }\n \n     /**\n     public void clear() {\n         super.clear();\n         m2 = Double.NaN;\n+        n1 = 0.0;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n+\n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n-public class Skewness extends ThirdMoment {\n+public class Skewness extends AbstractStorelessUnivariateStatistic {\n \n     private double skewness = Double.NaN;\n+\n+    protected ThirdMoment moment = null;\n+\n+    protected boolean incMoment = true;\n+\n+    public Skewness() {\n+        moment = new ThirdMoment();\n+    }\n+\n+    public Skewness(ThirdMoment m3) {\n+        incMoment = false;\n+        this.moment = m3;\n+    }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n \n-        super.increment(d);\n-\n-        double variance = (n <= 1) ? 0.0 : m2 / (double) (n - 1);\n+        double variance =\n+            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n \n         skewness =\n-            (n <= 2 || variance < 10E-20)\n+            (moment.n <= 2 || variance < 10E-20)\n                 ? 0.0\n-                : (((double) n) * m3)\n-                    / ((n - 1) * (n - 2) * Math.sqrt(variance) * variance);\n+                : (moment.n0 * moment.m3)\n+                    / (moment.n1 * moment.n2 * Math.sqrt(variance) * variance);\n \n         return skewness;\n     }\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        super.clear();\n+        if (incMoment) {\n+            moment.clear();\n+        }\n         skewness = Double.NaN;\n     }\n \n+    /*UnvariateStatistic Approach */\n+\n+    Mean mean = new Mean();\n+\n     /**\n-      * Returns the skewness of a collection of values.  Skewness is a \n-      * measure of the assymetry of a given distribution. \n-      * @param values Is a double[] containing the values\n-      * @param begin processing at this point in the array\n-      * @param length processing at this point in the array\n-      * @return the skewness of the values or Double.NaN if the array is empty\n-      */\n-     public double evaluate(double[] values, int begin, int length) {\n+     * This algorithm uses a corrected two pass algorithm of the following \n+     * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n+     * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n+     * \"Algorithms for Computing the Sample Variance: Analysis and\n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * 1983, American Statistician, vol. 37, pp. 242?247.\n+     * <p/>\n+     * Returns the skewness of a collection of values.  Skewness is a \n+     * measure of the assymetry of a given distribution. \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the skewness of the values or Double.NaN if the array is empty\n+     * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(double[] values, int begin, int length) {\n \n-         test(values, begin, length);\n+        test(values, begin, length);\n \n-         // Initialize the skewness\n-         double skew = Double.NaN;\n+        // Initialize the skewness\n+        double skew = Double.NaN;\n \n-         // Get the mean and the standard deviation\n-         double mean = super.evaluate(values, begin, length);\n+        // Get the mean and the standard deviation\n+        double m = mean.evaluate(values, begin, length);\n \n-         // Calc the std, this is implemented here instead of using the \n-         // standardDeviation method eliminate a duplicate pass to get the mean\n-         double accum = 0.0;\n-         double accum2 = 0.0;\n-         for (int i = begin; i < begin + length; i++) {\n-             accum += Math.pow((values[i] - mean), 2.0);\n-             accum2 += (values[i] - mean);\n-         }\n-         double stdDev =\n-             Math.sqrt(\n-                 (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                     / (double) (length - 1));\n+        // Calc the std, this is implemented here instead of using the \n+        // standardDeviation method eliminate a duplicate pass to get the mean\n+        double accum = 0.0;\n+        double accum2 = 0.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            accum += Math.pow((values[i] - m), 2.0);\n+            accum2 += (values[i] - m);\n+        }\n+        double stdDev =\n+            Math.sqrt(\n+                (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                    / (double) (length - 1));\n \n-         // Calculate the skew as the sum the cubes of the distance \n-         // from the mean divided by the standard deviation.\n-         double accum3 = 0.0;\n-         for (int i = begin; i < begin + length; i++) {\n-             accum3 += Math.pow((values[i] - mean) / stdDev, 3.0);\n-         }\n+        // Calculate the skew as the sum the cubes of the distance \n+        // from the mean divided by the standard deviation.\n+        double accum3 = 0.0;\n+        for (int i = begin; i < begin + length; i++) {\n+            accum3 += Math.pow((values[i] - m) / stdDev, 3.0);\n+        }\n \n-         // Get N\n-         double n = length;\n+        // Get N\n+        double n = length;\n \n-         // Calculate skewness\n-         skew = (n / ((n - 1) * (n - 2))) * accum3;\n+        // Calculate skewness\n+        skew = (n / ((n - 1) * (n - 2))) * accum3;\n \n-         return skew;\n-     }\n-     \n+        return skew;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n-\n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n-public class StandardDeviation extends AbstractStorelessUnivariateStatistic {\n+public class StandardDeviation extends Variance {\n \n-    private double value = Double.NaN;\n+    private double std = Double.NaN;\n     \n-    private Variance var = new Variance();\n+    public StandardDeviation(){\n+        super();\n+    }\n+    \n+    public StandardDeviation(SecondMoment m2){\n+        super(m2);\n+    }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        var.increment(d);\n-        value = Math.sqrt(var.getValue());\n-        return value;\n+        super.increment(d);\n+        std = (variance != 0.0) ? Math.sqrt(variance) : 0.0;\n+        return std;\n     }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return value;\n+        return std;\n     }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        var.clear();\n-        value = Double.NaN;\n+        super.clear();\n+        std = Double.NaN;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Returns the Standard Deviation on an array of values.  \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n-        double tmp = var.evaluate(values, begin, length);\n+        double tmp = super.evaluate(values, begin, length);\n         return tmp != 0.0 ? Math.sqrt(tmp) : 0.0;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n package org.apache.commons.math.stat.univariate.moment;\n \n /**\n- * @author Mark Diggory\n+ * \n  *\n  */\n public class ThirdMoment extends SecondMoment{\n     /** third moment of values that have been added */\n     protected double m3 = Double.NaN;\n \n+    /** temporary internal state made availabel for higher order moments */\n+    protected double v2 = 0.0;\n+    \n+    /** temporary internal state made availabel for higher order moments */\n+    protected double n2 = 0.0;\n+            \n+    /** temporary internal state made availabel for higher order moments */\n+    protected double prevM2 = 0.0;\n+                  \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n             m3 = m2 = m1 = 0.0;\n         }\n         \n-        n++;\n+        /* retain a reference to the last m2*/\n+        prevM2 = m2;\n         \n-        double dev = d - m1;\n-        double v = dev / ((double) n);\n-        double v2 = v * v;\n+        /* increment m1 and m2 (and _n0, _n1, _v) */\n+        super.increment(d);\n+        \n+        v2 = v * v;\n+        n2 = (double) (n - 2);\n \n-        double n0 = (double) n;\n-        double n1 = (double) (n - 1);\n-        double n2 = (double) (n - 2);\n+        m3 = m3 - (3.0 * v * prevM2) + (n0 * n1 * n2 * v2 * v);\n \n-        \n-        m3 = m3 - (3.0 * v * m2) + (n0 * n1 * n2 * v2 * v);\n-\n-        m2 = m2 + n1 * dev * v;\n-\n-        m1 = m1 + v;\n-        \n         return m3;\n     }\n \n     public void clear() {\n         super.clear();\n         m3 = Double.NaN;\n+        v2 = 0.0;\n+        n2 = 0.0;\n+        prevM2 = 0.0;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org\n-    .apache\n-    .commons\n-    .math\n-    .stat\n-    .univariate\n-    .AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n+ *\n  *\n  */\n-public class Variance extends SecondMoment {\n+public class Variance extends AbstractStorelessUnivariateStatistic{\n \n-    private double variance = Double.NaN;\n+    protected double variance = Double.NaN;\n \n+    protected SecondMoment moment = null;\n+    \n+    protected boolean incMoment = true;\n+    \n+    public Variance(){\n+        moment = new SecondMoment();\n+    }\n+    \n+    public Variance(SecondMoment m2){\n+        incMoment = false;\n+        this.moment = m2;\n+    }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public double increment(double d) {\n-        super.increment(d);\n-\n-        variance = (n < 1) ? 0.0 : m2 / (double)(n - 1);\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+        \n+        variance = (moment.n < 1) ? 0.0 : moment.m2 / (double)(moment.n - 1);\n         \n         return variance;\n     }\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        super.clear();\n+        if (incMoment) {\n+            moment.clear();\n+        }\n         variance = Double.NaN;\n     }\n     \n-    /* (non-Javadoc)\n+    /*UnvariateStatistic Approach */\n+\n+    Mean mean = new Mean();\n+    \n+    /**\n+     * Returns the variance of the available values. This uses a corrected\n+     * two pass algorithm of the following \n+     * <a href=\"http://lib-www.lanl.gov/numerical/bookcpdf/c14-1.pdf\">\n+     * corrected two pass formula (14.1.8)</a>, and also referenced in:<p/>\n+     * \"Algorithms for Computing the Sample Variance: Analysis and\n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * 1983, American Statistician, vol. 37, pp. 242?247.\n+     * \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n         if (values.length == 1) {\n             var = 0;\n         } else if (values.length > 1) {\n-            double m = super.evaluate(values, begin, length);\n+            double m = mean.evaluate(values, begin, length);\n             double accum = 0.0;\n             double accum2 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n+ *\n  */\n public class Max extends AbstractStorelessUnivariateStatistic {\n \n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Median.java\n \n \n /**\n- * @author Mark Diggory\n+ *\n  */\n public class Median extends Percentile {\n \n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n+ *\n  */\n public class Min extends AbstractStorelessUnivariateStatistic {\n \n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Percentile.java\n import org.apache.commons.math.stat.univariate.AbstractUnivariateStatistic;\n \n /**\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @author Mark Diggory\n- * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n+ *\n  */\n public class Percentile extends AbstractUnivariateStatistic {\n \n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n+ *\n  */\n public class Product extends AbstractStorelessUnivariateStatistic {\n \n     }\n \n     /**\n+     * Returns the product for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the product values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n  *\n  */\n public class Sum extends AbstractStorelessUnivariateStatistic {\n     }\n \n     /**\n+     * The sum of the values that have been added to Univariate.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sum of the values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n  *\n  */\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic {\n     }\n     \n     /**\n+     * Returns the sum of the natural logs for this collection of values\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sumLog value or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @author Mark Diggory\n  *\n  */\n public class SumOfSquares extends AbstractStorelessUnivariateStatistic {\n     }\n \n     /**\n+     * Returns the sum of the squares of the available values.\n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @return the sum of the squared values or Double.NaN if the array is empty\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {", "timestamp": 1057619208, "metainfo": ""}