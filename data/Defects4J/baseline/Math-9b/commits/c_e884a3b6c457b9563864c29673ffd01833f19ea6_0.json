{"sha": "e884a3b6c457b9563864c29673ffd01833f19ea6", "log": "Added a FiniteDifferencesDifferentiator class.  This class implements both UnivariateFunctionDifferentiator, UnivariateVectorFunctionDifferentiator and UnivariateMatrixFunctionDifferentiator. It is not limited in the derivation order, but checks the order is consistent with the number of points. Typically, attempting to extract 5th derivative from a 3 points scheme will not work (a NumberIsTooLargeException will be thrown, referencing the derivation order).  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.UnivariateMatrixFunction;\n+import org.apache.commons.math3.analysis.UnivariateVectorFunction;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+\n+/** Univariate functions differentiator using finite differences.\n+ * <p>\n+ * This class creates some wrapper objetcs around regular\n+ * {@link UnivariateFunction univariate functions} (or {@link\n+ * UnivariateVectorFunction univariate vector functions} or {@link\n+ * UnivariateMatrixFunction univariate matrix functions}). These\n+ * wrapper objects compute derivatives in addition to function\n+ * value.\n+ * </p>\n+ * <p>\n+ * The wrapper objects work by calling the underlying function on\n+ * a sampling grid around the current point and perform polynomial\n+ * interpolation. A finite differences scheme with n points is\n+ * theoretically able to compute derivatives up to order n-1, but\n+ * it is generally better to have a slight margin. The step size must\n+ * also be small enough in order for the polynomial approximation to\n+ * be good in the current point neighborhood, but it should not be too\n+ * small because numerical instability appears quickly (there are several\n+ * differences of close points). Choosing the number of points and\n+ * the step size is highly problem dependent.\n+ * </p>\n+ * <p>\n+ * As an example of good and bad settings, lets consider the quintic\n+ * polynomial function {@code f(x) = (x-1)*(x-0.5)*x*(x+0.5)*(x+1)}.\n+ * Since it is a polynomial, finite differences with at least 6 points\n+ * should theoretically recover the exact same polynomial and hence\n+ * compute accurate derivatives for any order. However, due to numerical\n+ * errors, we get the following results for a 7 points finite differences\n+ * for abscissae in the [-10, 10] range:\n+ * <ul>\n+ *   <li>step size = 0.25, second order derivative error about 9.97e-10</li>\n+ *   <li>step size = 0.25, fourth order derivative error about 5.43e-8</li>\n+ *   <li>step size = 1.0e-6, second order derivative error about 56.25</li>\n+ *   <li>step size = 1.0e-6, fourth order derivative error about 2.47e+14</li>\n+ * </ul>\n+ * This example shows that the small step size is really bad, even simply\n+ * for second order derivative!\n+ * </p>\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class FiniteDifferencesDifferentiator\n+    implements UnivariateFunctionDifferentiator, UnivariateVectorFunctionDifferentiator,\n+               UnivariateMatrixFunctionDifferentiator, Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20120917L;\n+\n+    /** Number of points to use. */\n+    private final int nbPoints;\n+\n+    /** Step size. */\n+    private double stepSize;\n+\n+    /**\n+     * Build a differentiator with number of points and step size.\n+     * <p>\n+     * Beware that wrong settings for the finite differences differentiator\n+     * can lead to highly unstable and inaccurate results, especially for\n+     * high derivation orders. Using very small step sizes is often a\n+     * <em>bad</em> idea.\n+     * </p>\n+     * @param nbPoints number of points to use\n+     * @param stepSize step size (gap between each point)\n+     * @exception NotPositiveException if {@code stepsize <= 0} (note that\n+     * {@link NotPositiveException} extends {@link NumberIsTooSmallException})\n+     * @exception NumberIsTooSmallException {@code nbPoint <= 1}\n+     */\n+    public FiniteDifferencesDifferentiator(final int nbPoints, final double stepSize)\n+        throws NotPositiveException, NumberIsTooSmallException {\n+\n+        if (nbPoints <= 1) {\n+            throw new NumberIsTooSmallException(stepSize, 1, false);\n+        }\n+        this.nbPoints = nbPoints;\n+\n+        if (stepSize <= 0) {\n+            throw new NotPositiveException(stepSize);\n+        }\n+        this.stepSize = stepSize;\n+\n+    }\n+\n+    /**\n+     * Get the number of points to use.\n+     * @return number of points to use\n+     */\n+    public int getNbPoints() {\n+        return nbPoints;\n+    }\n+\n+    /**\n+     * Get the step size.\n+     * @return step size\n+     */\n+    public double getStepSize() {\n+        return stepSize;\n+    }\n+\n+    /**\n+     * Evaluate derivatives from a centered sample.\n+     * @param t central value and derivatives\n+     * @param y function values at {@code t + stepSize * (i - 0.5 * (nbPoints - 1))}\n+     * @return value and derivatives at {@code t}\n+     * @exception NumberIsTooLargeException if the requested derivation order\n+     * is larger or equal to the number of points\n+     */\n+    private DerivativeStructure evaluate(final DerivativeStructure t, final double[] y)\n+        throws NumberIsTooLargeException {\n+\n+        // check we can achieve the requested derivation order with the sample\n+        final int order = t.getOrder();\n+        if (order >= nbPoints) {\n+            throw new NumberIsTooLargeException(order, nbPoints, false);\n+        }\n+\n+        // create divided differences diagonal arrays\n+        final double[] top    = new double[nbPoints];\n+        final double[] bottom = new double[nbPoints];\n+\n+        for (int i = 0; i < nbPoints; ++i) {\n+\n+            // update the bottom diagonal of the divided differences array\n+            bottom[i] = y[i];\n+            for (int j = 1; j <= i; ++j) {\n+                bottom[i - j] = (bottom[i - j + 1] - bottom[i - j]) / (j * stepSize);\n+            }\n+\n+            // update the top diagonal of the divided differences array\n+            top[i] = bottom[0];\n+\n+        }\n+\n+        // evaluate interpolation polynomial (represented by top diagonal) at t\n+        final int parameters = t.getFreeParameters();\n+        final double[] derivatives = t.getAllDerivatives();\n+        DerivativeStructure interpolation = new DerivativeStructure(parameters, order, 0.0);\n+        DerivativeStructure monomial      = new DerivativeStructure(parameters, order, 1.0);\n+        for (int i = 0; i < nbPoints; ++i) {\n+            interpolation = interpolation.add(monomial.multiply(top[i]));\n+            derivatives[0] = stepSize * (0.5 * (nbPoints - 1) - i);\n+            final DerivativeStructure deltaX = new DerivativeStructure(parameters, order, derivatives);\n+            monomial = monomial.multiply(deltaX);\n+        }\n+\n+        return interpolation;\n+\n+    }\n+\n+    /** {@inheritDoc}\n+     * <p>The returned object cannot compute derivatives to arbitrary orders. The\n+     * value function will throw a {@link NumberIsTooLargeException} if the requested\n+     * derivation order is larger or equal to the number of points.\n+     * </p>\n+     */\n+    public UnivariateDifferentiableFunction differentiate(final UnivariateFunction function) {\n+        return new UnivariateDifferentiableFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double value(final double x) throws MathIllegalArgumentException {\n+                return function.value(x);\n+            }\n+            \n+            /** {@inheritDoc} */\n+            public DerivativeStructure value(final DerivativeStructure t)\n+                throws MathIllegalArgumentException {\n+\n+                // get sample points centered around t value\n+                final double t0 = t.getValue();\n+                final double[] y = new double[nbPoints];\n+                for (int i = 0; i < nbPoints; ++i) {\n+                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n+                    y[i] = function.value(xi);\n+                }\n+\n+                // evaluate derivatives\n+                return evaluate(t, y);\n+\n+            }\n+\n+        };\n+    }\n+\n+    /** {@inheritDoc}\n+     * <p>The returned object cannot compute derivatives to arbitrary orders. The\n+     * value function will throw a {@link NumberIsTooLargeException} if the requested\n+     * derivation order is larger or equal to the number of points.\n+     * </p>\n+     */\n+    public UnivariateDifferentiableVectorFunction differentiate(final UnivariateVectorFunction function) {\n+        return new UnivariateDifferentiableVectorFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double[]value(final double x) throws MathIllegalArgumentException {\n+                return function.value(x);\n+            }\n+            \n+            /** {@inheritDoc} */\n+            public DerivativeStructure[] value(final DerivativeStructure t)\n+                throws MathIllegalArgumentException {\n+\n+                // get sample points centered around t value\n+                final double t0 = t.getValue();\n+                double[][] y = null;\n+                for (int i = 0; i < nbPoints; ++i) {\n+                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n+                    final double[] v = function.value(xi);\n+                    if (i == 0) {\n+                        y = new double[v.length][nbPoints];\n+                    }\n+                    for (int j = 0; j < v.length; ++j) {\n+                        y[j][i] = v[j];\n+                    }\n+                }\n+\n+                // evaluate derivatives\n+                final DerivativeStructure[] value = new DerivativeStructure[y.length];\n+                for (int j = 0; j < value.length; ++j) {\n+                    value[j] = evaluate(t, y[j]);\n+                }\n+\n+                return value;\n+\n+            }\n+\n+        };\n+    }\n+\n+    /** {@inheritDoc}\n+     * <p>The returned object cannot compute derivatives to arbitrary orders. The\n+     * value function will throw a {@link NumberIsTooLargeException} if the requested\n+     * derivation order is larger or equal to the number of points.\n+     * </p>\n+     */\n+    public UnivariateDifferentiableMatrixFunction differentiate(final UnivariateMatrixFunction function) {\n+        return new UnivariateDifferentiableMatrixFunction() {\n+\n+            /** {@inheritDoc} */\n+            public double[][]  value(final double x) throws MathIllegalArgumentException {\n+                return function.value(x);\n+            }\n+            \n+            /** {@inheritDoc} */\n+            public DerivativeStructure[][]  value(final DerivativeStructure t)\n+                throws MathIllegalArgumentException {\n+\n+                // get sample points centered around t value\n+                final double t0 = t.getValue();\n+                double[][][] y = null;\n+                for (int i = 0; i < nbPoints; ++i) {\n+                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n+                    final double[][] v = function.value(xi);\n+                    if (i == 0) {\n+                        y = new double[v.length][v[0].length][nbPoints];\n+                    }\n+                    for (int j = 0; j < v.length; ++j) {\n+                        for (int k = 0; k < v[j].length; ++k) {\n+                            y[j][k][i] = v[j][k];\n+                        }\n+                    }\n+                }\n+\n+                // evaluate derivatives\n+                final DerivativeStructure[][] value = new DerivativeStructure[y.length][y[0].length];\n+                for (int j = 0; j < value.length; ++j) {\n+                    for (int k = 0; k < y[j].length; ++k) {\n+                        value[j][k] = evaluate(t, y[j][k]);\n+                    }\n+                }\n+\n+                return value;\n+\n+            }\n+\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.analysis.QuinticFunction;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.UnivariateMatrixFunction;\n+import org.apache.commons.math3.analysis.UnivariateVectorFunction;\n+import org.apache.commons.math3.analysis.function.Gaussian;\n+import org.apache.commons.math3.analysis.function.Sin;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for class {@link FiniteDifferencesDifferentiator}.\n+ */\n+public class FiniteDifferencesDifferentiatorTest {\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testWrongNumberOfPoints() {\n+        new FiniteDifferencesDifferentiator(1, 1.0);\n+    }\n+\n+    @Test(expected=NotPositiveException.class)\n+    public void testWrongStepSize() {\n+        new FiniteDifferencesDifferentiator(3, 0.0);\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(3, 1.0e-3);\n+        FiniteDifferencesDifferentiator recovered =\n+                (FiniteDifferencesDifferentiator) TestUtils.serializeAndRecover(differentiator);\n+        Assert.assertEquals(differentiator.getNbPoints(), recovered.getNbPoints());\n+        Assert.assertEquals(differentiator.getStepSize(), recovered.getStepSize(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testConstant() {\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(5, 0.01);\n+        UnivariateDifferentiableFunction f =\n+                differentiator.differentiate(new UnivariateFunction() {\n+                    public double value(double x) {\n+                        return 42.0;\n+                    }\n+                });\n+        for (double x = -10; x < 10; x += 0.1) {\n+            DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x));\n+            Assert.assertEquals(42.0, y.getValue(), 1.0e-15);\n+            Assert.assertEquals( 0.0, y.getPartialDerivative(1), 1.0e-15);\n+            Assert.assertEquals( 0.0, y.getPartialDerivative(2), 1.0e-15);\n+        }\n+    }\n+\n+    @Test\n+    public void testLinear() {\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(5, 0.01);\n+        UnivariateDifferentiableFunction f =\n+                differentiator.differentiate(new UnivariateFunction() {\n+                    public double value(double x) {\n+                        return 2 - 3 * x;\n+                    }\n+                });\n+        for (double x = -10; x < 10; x += 0.1) {\n+            DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x));\n+            Assert.assertEquals(2 - 3 * x, y.getValue(), 1.0e-20);\n+            Assert.assertEquals(-3.0, y.getPartialDerivative(1), 4.0e-13);\n+            Assert.assertEquals( 0.0, y.getPartialDerivative(2), 5.0e-11);\n+        }\n+    }\n+\n+    @Test\n+    public void testGaussian() {\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(9, 0.02);\n+        UnivariateDifferentiableFunction gaussian = new Gaussian(1.0, 2.0);\n+        UnivariateDifferentiableFunction f =\n+                differentiator.differentiate(gaussian);\n+        double[] expectedError = new double[] {\n+            2.776e-17, 1.742e-15, 2.385e-13, 1.329e-11, 2.668e-9, 8.873e-8\n+        };\n+       double[] maxError = new double[expectedError.length];\n+        for (double x = -10; x < 10; x += 0.1) {\n+            DerivativeStructure dsX  = new DerivativeStructure(1, maxError.length - 1, 0, x);\n+            DerivativeStructure yRef = gaussian.value(dsX);\n+            DerivativeStructure y    = f.value(dsX);\n+            for (int order = 0; order <= yRef.getOrder(); ++order) {\n+                maxError[order] = FastMath.max(maxError[order],\n+                                        FastMath.abs(yRef.getPartialDerivative(order) -\n+                                                     y.getPartialDerivative(order)));\n+            }\n+        }\n+        for (int i = 0; i < maxError.length; ++i) {\n+            Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testStepSizeUnstability() {\n+        UnivariateDifferentiableFunction quintic = new QuinticFunction();\n+        UnivariateDifferentiableFunction goodStep =\n+                new FiniteDifferencesDifferentiator(7, 0.25).differentiate(quintic);\n+        UnivariateDifferentiableFunction badStep =\n+                new FiniteDifferencesDifferentiator(7, 1.0e-6).differentiate(quintic);\n+        double[] maxErrorGood = new double[7];\n+        double[] maxErrorBad  = new double[7];\n+        for (double x = -10; x < 10; x += 0.1) {\n+            DerivativeStructure dsX  = new DerivativeStructure(1, 6, 0, x);\n+            DerivativeStructure yRef  = quintic.value(dsX);\n+            DerivativeStructure yGood = goodStep.value(dsX);\n+            DerivativeStructure yBad  = badStep.value(dsX);\n+            for (int order = 0; order <= 6; ++order) {\n+                maxErrorGood[order] = FastMath.max(maxErrorGood[order],\n+                                                   FastMath.abs(yRef.getPartialDerivative(order) -\n+                                                                yGood.getPartialDerivative(order)));\n+                maxErrorBad[order]  = FastMath.max(maxErrorBad[order],\n+                                                   FastMath.abs(yRef.getPartialDerivative(order) -\n+                                                                yBad.getPartialDerivative(order)));\n+            }\n+        }\n+\n+        // the 0.25 step size is good for finite differences in the quintic on this abscissa range for 7 points\n+        // the errors are fair\n+        final double[] expectedGood = new double[] {\n+            7.276e-12, 7.276e-11, 9.968e-10, 3.092e-9, 5.432e-8, 8.196e-8, 1.818e-6\n+        };\n+\n+        // the 1.0e-6 step size is far too small for finite differences in the quintic on this abscissa range for 7 points\n+        // the errors are huge!\n+        final double[] expectedBad = new double[] {\n+            1.792e-22, 6.926e-5, 56.25, 1.783e8, 2.468e14, 3.056e20, 5.857e26            \n+        };\n+\n+        for (int i = 0; i < maxErrorGood.length; ++i) {\n+            Assert.assertEquals(expectedGood[i], maxErrorGood[i], 0.01 * expectedGood[i]);\n+            Assert.assertEquals(expectedBad[i],  maxErrorBad[i],  0.01 * expectedBad[i]);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testVectorFunction() {\n+\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(7, 0.01);\n+        UnivariateDifferentiableVectorFunction f =\n+                differentiator.differentiate(new UnivariateVectorFunction() {\n+            \n+            public double[] value(double x) {\n+                return new double[] { FastMath.cos(x), FastMath.sin(x) };\n+            }\n+            \n+        });\n+\n+        for (double x = -10; x < 10; x += 0.1) {\n+            DerivativeStructure[] y = f.value(new DerivativeStructure(1, 2, 0, x));\n+            double cos = FastMath.cos(x);\n+            double sin = FastMath.sin(x);\n+            Assert.assertEquals(cos, y[0].getValue(), 2.0e-16);\n+            Assert.assertEquals(sin, y[1].getValue(), 2.0e-16);\n+            Assert.assertEquals(-sin, y[0].getPartialDerivative(1), 5.0e-14);\n+            Assert.assertEquals( cos, y[1].getPartialDerivative(1), 5.0e-14);\n+            Assert.assertEquals(-cos, y[0].getPartialDerivative(2), 6.0e-12);\n+            Assert.assertEquals(-sin, y[1].getPartialDerivative(2), 6.0e-12);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMatrixFunction() {\n+\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(7, 0.01);\n+        UnivariateDifferentiableMatrixFunction f =\n+                differentiator.differentiate(new UnivariateMatrixFunction() {\n+            \n+            public double[][] value(double x) {\n+                return new double[][] {\n+                    { FastMath.cos(x),  FastMath.sin(x)  },\n+                    { FastMath.cosh(x), FastMath.sinh(x) }\n+                };\n+            }\n+            \n+        });\n+\n+        for (double x = -1; x < 1; x += 0.02) {\n+            DerivativeStructure[][] y = f.value(new DerivativeStructure(1, 2, 0, x));\n+            double cos = FastMath.cos(x);\n+            double sin = FastMath.sin(x);\n+            double cosh = FastMath.cosh(x);\n+            double sinh = FastMath.sinh(x);\n+            Assert.assertEquals(cos,   y[0][0].getValue(), 7.0e-18);\n+            Assert.assertEquals(sin,   y[0][1].getValue(), 7.0e-18);\n+            Assert.assertEquals(cosh,  y[1][0].getValue(), 3.0e-16);\n+            Assert.assertEquals(sinh,  y[1][1].getValue(), 3.0e-16);\n+            Assert.assertEquals(-sin,  y[0][0].getPartialDerivative(1), 2.0e-14);\n+            Assert.assertEquals( cos,  y[0][1].getPartialDerivative(1), 2.0e-14);\n+            Assert.assertEquals( sinh, y[1][0].getPartialDerivative(1), 3.0e-14);\n+            Assert.assertEquals( cosh, y[1][1].getPartialDerivative(1), 3.0e-14);\n+            Assert.assertEquals(-cos,  y[0][0].getPartialDerivative(2), 3.0e-12);\n+            Assert.assertEquals(-sin,  y[0][1].getPartialDerivative(2), 3.0e-12);\n+            Assert.assertEquals( cosh, y[1][0].getPartialDerivative(2), 6.0e-12);\n+            Assert.assertEquals( sinh, y[1][1].getPartialDerivative(2), 6.0e-12);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSeveralFreeParameters() {\n+        FiniteDifferencesDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(5, 0.001);\n+        UnivariateDifferentiableFunction sine = new Sin();\n+        UnivariateDifferentiableFunction f =\n+                differentiator.differentiate(sine);\n+        double[] expectedError = new double[] {\n+            1.110e-16, 2.66e-12, 4.803e-9, 5.486e-5\n+        };\n+        double[] maxError = new double[expectedError.length];\n+       for (double x = -2; x < 2; x += 0.1) {\n+           for (double y = -2; y < 2; y += 0.1) {\n+               DerivativeStructure dsX  = new DerivativeStructure(2, maxError.length - 1, 0, x);\n+               DerivativeStructure dsY  = new DerivativeStructure(2, maxError.length - 1, 1, y);\n+               DerivativeStructure dsT  = dsX.multiply(3).subtract(dsY.multiply(2));\n+               DerivativeStructure sRef = sine.value(dsT);\n+               DerivativeStructure s    = f.value(dsT);\n+               for (int xOrder = 0; xOrder <= sRef.getOrder(); ++xOrder) {\n+                   for (int yOrder = 0; yOrder <= sRef.getOrder(); ++yOrder) {\n+                       if (xOrder + yOrder <= sRef.getOrder()) {\n+                           maxError[xOrder +yOrder] = FastMath.max(maxError[xOrder + yOrder],\n+                                                                    FastMath.abs(sRef.getPartialDerivative(xOrder, yOrder) -\n+                                                                                 s.getPartialDerivative(xOrder, yOrder)));\n+                       }\n+                   }\n+               }\n+           }\n+       }\n+       for (int i = 0; i < maxError.length; ++i) {\n+           Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]);\n+       }\n+    }\n+\n+}", "timestamp": 1347903767, "metainfo": ""}