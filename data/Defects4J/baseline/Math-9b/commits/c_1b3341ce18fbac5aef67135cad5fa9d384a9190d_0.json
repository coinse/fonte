{"sha": "1b3341ce18fbac5aef67135cad5fa9d384a9190d", "log": "Added rigging for checking eigenvalues and eigenvectors and some easy test cases.  ", "commit": "\n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n         }\n \n     }\n+    \n+    /**\n+     * Matrix with eigenvalues {8, -1, -1}\n+     */\n+    public void testRepeatedEigenvalue() {\n+        RealMatrix repeated = new RealMatrixImpl(new double[][] {\n+                {3,  2,  4},\n+                {2,  0,  2},\n+                {4,  2,  3}\n+        }); \n+        EigenDecomposition ed = new EigenDecompositionImpl(repeated);\n+        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n+        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Matrix with eigenvalues {2, 0, 12}\n+     */\n+    public void testDistinctEigenvalues() {\n+        RealMatrix distinct = new RealMatrixImpl(new double[][] {\n+                {3, 1, -4},  \n+                {1, 3, -4}, \n+                {-4, -4, 8}\n+        });\n+        EigenDecomposition ed = new EigenDecompositionImpl(distinct);\n+        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n+        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Verifies that the given EigenDecomposition has eigenvalues equivalent to\n+     * the targetValues, ignoring the order of the values and allowing\n+     * values to differ by tolerance.\n+     */\n+    protected void checkEigenValues(double[] targetValues,\n+            EigenDecomposition ed, double tolerance) {\n+        double[] observed = ed.getEigenvalues();\n+        for (int i = 0; i < observed.length; i++) {\n+            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n+            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n+        }\n+    }\n+    \n+    /**\n+     * Returns true iff there is an entry within tolerance of value in\n+     * searchArray.\n+     */\n+    private boolean isIncludedValue(double value, double[] searchArray,\n+            double tolerance) {\n+       boolean found = false;\n+       int i = 0;\n+       while (!found && i < searchArray.length) {\n+           if (Math.abs(value - searchArray[i]) < tolerance) {\n+               found = true;\n+           }\n+           i++;\n+       }\n+       return found;\n+    }\n+    \n+    /**\n+     * Returns true iff eigenVector is a scalar multiple of one of the columns\n+     * of ed.getV().  Does not try linear combinations - i.e., should only be\n+     * used to find vectors in one-dimensional eigenspaces.\n+     */\n+    protected void checkEigenVector(double[] eigenVector,\n+            EigenDecomposition ed, double tolerance) {\n+        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n+    }\n+    \n+    /**\n+     * Returns true iff there is a column that is a scalar multiple of column\n+     * in searchMatrix (modulo tolerance)\n+     */\n+    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,\n+            double tolerance) {\n+        boolean found = false;\n+        int i = 0;\n+        while (!found && i < searchMatrix.getColumnDimension()) {\n+            double multiplier = 1d;\n+            boolean matching = true;\n+            int j = 0;\n+            while (matching && j < searchMatrix.getRowDimension()) {\n+                double colEntry = searchMatrix.getEntry(j, i);\n+                // Use the first entry where both are non-zero as scalar\n+                if (multiplier == 1d && Math.abs(colEntry) > 1E-14\n+                        && Math.abs(column[j]) > 1e-14) {\n+                    multiplier = colEntry / column[j];\n+                } \n+                if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {\n+                    matching = false;\n+                }\n+                j++;\n+            }\n+            found = matching;\n+            i++;\n+        }\n+        return found;\n+    }\n \n     public void setUp() {\n         refValues = new double[] {", "timestamp": 1228095296, "metainfo": ""}