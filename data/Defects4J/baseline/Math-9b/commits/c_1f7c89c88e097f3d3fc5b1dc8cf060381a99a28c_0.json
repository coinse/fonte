{"sha": "1f7c89c88e097f3d3fc5b1dc8cf060381a99a28c", "log": "MATH-854: fill the throws clause of all methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n \n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n      *\n      * @param index Index location of entry to be fetched.\n      * @return the vector entry at {@code index}.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the index is not valid.\n+     * @throws OutOfRangeException if the index is not valid.\n      * @see #setEntry(int, double)\n      */\n-    public abstract double getEntry(int index);\n+    public abstract double getEntry(int index) throws OutOfRangeException;\n \n     /**\n      * Set a single element.\n      *\n      * @param index element index.\n      * @param value new value for the element.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the index is not valid.\n+     * @throws OutOfRangeException if the index is not valid.\n      * @see #getEntry(int)\n      */\n-    public abstract void setEntry(int index, double value);\n+    public abstract void setEntry(int index, double value)\n+        throws OutOfRangeException;\n \n     /**\n      * Change an entry at the specified index.\n      *\n      * @param index Index location of entry to be set.\n      * @param increment Value to add to the vector entry.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the index is not valid.\n+     * @throws OutOfRangeException if the index is not valid.\n      * @since 3.0\n      */\n-    public void addToEntry(int index, double increment) {\n+    public void addToEntry(int index, double increment)\n+        throws OutOfRangeException {\n         setEntry(index, getEntry(index) + increment);\n     }\n \n      * @param index index of first element.\n      * @param n number of elements to be retrieved.\n      * @return a vector containing n elements.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @throws org.apache.commons.math3.exception.NotPositiveException\n-     * if the number of elements is not positive\n-     */\n-    public abstract RealVector getSubVector(int index, int n);\n+     * @throws OutOfRangeException if the index is not valid.\n+     * @throws NotPositiveException if the number of elements is not positive.\n+     */\n+    public abstract RealVector getSubVector(int index, int n)\n+        throws NotPositiveException, OutOfRangeException;\n \n     /**\n      * Set a sequence of consecutive elements.\n      *\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the index is not valid.\n-     */\n-    public abstract void setSubVector(int index, RealVector v);\n+     * @throws OutOfRangeException if the index is not valid.\n+     */\n+    public abstract void setSubVector(int index, RealVector v)\n+        throws OutOfRangeException;\n \n     /**\n      * Check whether any coordinate of this vector is {@code NaN}.\n      * @throws DimensionMismatchException if the vectors do not\n      * have the same dimension.\n      */\n-    protected void checkVectorDimensions(RealVector v) {\n+    protected void checkVectorDimensions(RealVector v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n     }\n \n      * @throws DimensionMismatchException if the dimension is\n      * inconsistent with the vector size.\n      */\n-    protected void checkVectorDimensions(int n) {\n+    protected void checkVectorDimensions(int n)\n+        throws DimensionMismatchException {\n         int d = getDimension();\n         if (d != n) {\n             throw new DimensionMismatchException(d, n);\n      * @param index Index to check.\n      * @exception OutOfRangeException if {@code index} is not valid.\n      */\n-    protected void checkIndex(final int index) {\n+    protected void checkIndex(final int index) throws OutOfRangeException {\n         if (index < 0 ||\n             index >= getDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.INDEX,\n      * @throws OutOfRangeException if {@code start} of {@code end} are not valid\n      * @throws NumberIsTooSmallException if {@code end < start}\n      */\n-    protected void checkIndices(final int start, final int end) {\n+    protected void checkIndices(final int start, final int end)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         final int dim = getDimension();\n         if ((start < 0) || (start >= dim)) {\n             throw new OutOfRangeException(LocalizedFormats.INDEX, start, 0,\n      *\n      * @param v Vector to be added.\n      * @return {@code this} + {@code v}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector add(RealVector v) {\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public RealVector add(RealVector v) throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         RealVector result = v.copy();\n         Iterator<Entry> it = sparseIterator();\n      *\n      * @param v Vector to be subtracted.\n      * @return {@code this} - {@code v}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector subtract(RealVector v) {\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public RealVector subtract(RealVector v) throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         RealVector result = v.mapMultiply(-1d);\n         Iterator<Entry> it = sparseIterator();\n      *\n      * @param v Vector with which dot product should be computed\n      * @return the scalar dot product between this instance and {@code v}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public double dotProduct(RealVector v) {\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public double dotProduct(RealVector v) throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         double d = 0;\n         final int n = getDimension();\n      * @throws DimensionMismatchException if the dimensions of {@code this} and\n      * {@code v} do not match\n      */\n-    public double cosine(RealVector v) throws MathArithmeticException {\n+    public double cosine(RealVector v) throws DimensionMismatchException,\n+        MathArithmeticException {\n         final double norm = getNorm();\n         final double vNorm = v.getNorm();\n \n      *\n      * @param v Vector by which instance elements must be divided.\n      * @return a vector containing this[i] / v[i] for all i.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n      * @deprecated As of version 3.1, this method is deprecated, and will be\n      * removed in version 4.0. This decision follows the discussion reported in\n      * <a href=\"https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150\">MATH-803</a>.\n      * the sake of efficiency).\n      */\n     @Deprecated\n-    public abstract RealVector ebeDivide(RealVector v);\n+    public abstract RealVector ebeDivide(RealVector v)\n+        throws DimensionMismatchException;\n \n     /**\n      * Element-by-element multiplication.\n      *\n      * @param v Vector by which instance elements must be multiplied\n      * @return a vector containing this[i] * v[i] for all i.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n      * @deprecated As of version 3.1, this method is deprecated, and will be\n      * removed in version 4.0. This decision follows the discussion reported in\n      * <a href=\"https://issues.apache.org/jira/browse/MATH-803?focusedCommentId=13399150#comment-13399150\">MATH-803</a>.\n      * the sake of efficiency).\n      */\n     @Deprecated\n-    public abstract RealVector ebeMultiply(RealVector v);\n+    public abstract RealVector ebeMultiply(RealVector v)\n+        throws DimensionMismatchException;\n \n     /**\n      * Distance between two vectors.\n      *\n      * @param v Vector to which distance is requested.\n      * @return the distance between two vectors.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n      * @see #getL1Distance(RealVector)\n      * @see #getLInfDistance(RealVector)\n      * @see #getNorm()\n      */\n-    public double getDistance(RealVector v) {\n+    public double getDistance(RealVector v) throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n      *\n      * @param v Vector to which distance is requested.\n      * @return the distance between two vectors.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public double getL1Distance(RealVector v) {\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public double getL1Distance(RealVector v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n      *\n      * @param v Vector to which distance is requested.\n      * @return the distance between two vectors.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n      * @see #getDistance(RealVector)\n      * @see #getL1Distance(RealVector)\n      * @see #getLInfNorm()\n      */\n-    public double getLInfDistance(RealVector v) {\n+    public double getLInfDistance(RealVector v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n      *\n      * @param v vector onto which instance must be projected.\n      * @return projection of the instance onto {@code v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this} vector.\n      * @throws MathArithmeticException if {@code this} or {@code v} is the null\n-     *         vector\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     *         this vector.\n-     */\n-    public RealVector projection(final RealVector v) throws MathArithmeticException {\n+     * vector\n+     */\n+    public RealVector projection(final RealVector v)\n+        throws DimensionMismatchException, MathArithmeticException {\n         final double norm2 = v.dotProduct(v);\n         if (norm2 == 0.0) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n      * @param y Vector with which {@code this} is linearly combined.\n      * @return a vector containing {@code a * this[i] + b * y[i]} for all\n      * {@code i}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public RealVector combine(double a, double b, RealVector y) {\n+     * @throws DimensionMismatchException if {@code y} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public RealVector combine(double a, double b, RealVector y)\n+        throws DimensionMismatchException {\n         return copy().combineToSelf(a, b, y);\n     }\n \n      * @param y Vector with which {@code this} is linearly combined.\n      * @return {@code this}, with components equal to\n      * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public RealVector combineToSelf(double a, double b, RealVector y) {\n+     * @throws DimensionMismatchException if {@code y} is not the same size as\n+     * {@code this} vector.\n+     */\n+    public RealVector combineToSelf(double a, double b, RealVector y)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(y);\n         for (int i = 0; i < getDimension(); i++) {\n             final double xi = getEntry(i);\n      * @param end the index of the last entry to be visited (inclusive)\n      * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n      * at the end of the walk\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code end < start}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      */\n     public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n-                                     final int start, final int end) {\n+                                     final int start, final int end)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         checkIndices(start, end);\n         visitor.start(getDimension(), start, end);\n         for (int i = start; i <= end; i++) {\n      * @param end the index of the last entry to be visited (inclusive)\n      * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n      * at the end of the walk\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code end < start}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      */\n     public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor,\n-                                       final int start, final int end) {\n+                                       final int start, final int end)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         return walkInDefaultOrder(visitor, start, end);\n     }\n \n      * @param end the index of the last entry to be visited (inclusive)\n      * @return the value returned by {@link RealVectorChangingVisitor#end()}\n      * at the end of the walk\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code end < start}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      */\n     public double walkInDefaultOrder(final RealVectorChangingVisitor visitor,\n-                              final int start, final int end) {\n+                              final int start, final int end)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         checkIndices(start, end);\n         visitor.start(getDimension(), start, end);\n         for (int i = start; i <= end; i++) {\n      * @param end the index of the last entry to be visited (inclusive)\n      * @return the value returned by {@link RealVectorChangingVisitor#end()}\n      * at the end of the walk\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n-     * the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code end < start}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      */\n     public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor,\n-                                       final int start, final int end) {\n+                                       final int start, final int end)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         return walkInDefaultOrder(visitor, start, end);\n     }\n \n      */\n     @Override\n     public boolean equals(Object other) {\n-        throw new UnsupportedOperationException();\n+        throw new MathUnsupportedOperationException();\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        throw new UnsupportedOperationException();\n+        throw new MathUnsupportedOperationException();\n     }\n \n     /**\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector add(RealVector w) {\n+            public RealVector add(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.add(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector subtract(RealVector w) {\n+            public RealVector subtract(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.subtract(w);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector ebeMultiply(RealVector w) {\n+            public RealVector ebeMultiply(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.ebeMultiply(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector ebeDivide(RealVector w) {\n+            public RealVector ebeDivide(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.ebeDivide(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double dotProduct(RealVector w) {\n+            public double dotProduct(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.dotProduct(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double cosine(RealVector w) throws MathArithmeticException {\n+            public double cosine(RealVector w)\n+                throws DimensionMismatchException, MathArithmeticException {\n                 return v.cosine(w);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public double getDistance(RealVector w) {\n+            public double getDistance(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.getDistance(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double getL1Distance(RealVector w) {\n+            public double getL1Distance(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.getL1Distance(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double getLInfDistance(RealVector w) {\n+            public double getLInfDistance(RealVector w)\n+                throws DimensionMismatchException {\n                 return v.getLInfDistance(w);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public double getEntry(int index) {\n+            public double getEntry(int index) throws OutOfRangeException {\n                 return v.getEntry(index);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector getSubVector(int index, int n) {\n+            public RealVector getSubVector(int index, int n)\n+                throws OutOfRangeException, NotPositiveException {\n                 return v.getSubVector(index, n);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector combine(double a, double b, RealVector y) {\n+            public RealVector combine(double a, double b, RealVector y)\n+                throws DimensionMismatchException {\n                 return v.combine(a, b, y);\n             }\n \n             class UnmodifiableEntry extends Entry {\n                 /** {@inheritDoc} */\n                 @Override\n-                    public double getValue() {\n+                public double getValue() {\n                     return v.getEntry(getIndex());\n                 }\n \n                 /** {@inheritDoc} */\n                 @Override\n-                    public void setValue(double value) {\n+                public void setValue(double value) {\n                     throw new MathUnsupportedOperationException();\n                 }\n             }", "timestamp": 1346728111, "metainfo": ""}