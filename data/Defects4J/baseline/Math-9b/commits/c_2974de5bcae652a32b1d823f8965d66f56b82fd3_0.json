{"sha": "2974de5bcae652a32b1d823f8965d66f56b82fd3", "log": "improved error handling in linear package with finer grained exceptions  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+* Base class for commons-math unchecked exceptions.\n+* \n+* @version $Revision$ $Date$\n+* @since 2.0\n+*/\n+public class MathRuntimeException extends RuntimeException {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2880601850253924272L;\n+\n+    /** Cache for resources bundle. */\n+    private static ResourceBundle cachedResources = null;\n+ \n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final String pattern;\n+\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(final String s, final Locale locale) {\n+        try {\n+            if ((cachedResources == null) || (! cachedResources.getLocale().equals(locale))) {\n+                // caching the resource bundle\n+                cachedResources =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            }\n+\n+            if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated string\n+                return cachedResources.getString(s);\n+            }\n+            \n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n+    /**\n+     * Builds a message string by from a pattern and its arguments.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param locale Locale in which the message should be translated\n+     * @return a message string\n+     */\n+    private static String buildMessage(final String pattern, final Object[] arguments,\n+                                       final Locale locale) {\n+        return new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with no\n+     * detail message.\n+     */\n+    public MathRuntimeException() {\n+        super();\n+        this.pattern   = null;\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final String pattern, final Object[] arguments) {\n+      super(buildMessage(pattern, arguments, Locale.US));\n+      this.pattern   = pattern;\n+      this.arguments = (Object[]) arguments.clone();\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathRuntimeException(final Throwable rootCause) {\n+        super(rootCause);\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     */\n+    public MathRuntimeException(final String pattern, final Object[] arguments,\n+                                final Throwable rootCause) {\n+      super(buildMessage(pattern, arguments, Locale.US), rootCause);\n+      this.pattern   = pattern;\n+      this.arguments = (Object[]) arguments.clone();\n+    }\n+\n+    /** Gets the pattern used to build the message of this throwable.\n+     *\n+     * @return the pattern used to build the message of this throwable\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /** Gets the arguments used to build the message of this throwable.\n+     *\n+     * @return the arguments used to build the message of this throwable\n+     */\n+    public Object[] getArguments() {\n+        return (Object[]) arguments.clone();\n+    }\n+\n+    /** Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated\n+     * \n+     * @return localized message\n+     */\n+    public String getMessage(final Locale locale) {\n+        return (pattern == null) ? null : buildMessage(pattern, arguments, locale);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the standard error stream.\n+     */\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     *\n+     * @param out  the <code>PrintStream</code> to use for output\n+     */\n+    public void printStackTrace(final PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"unable to orthogonalize matrix in {0} iterations\",\n       \"impossible de rendre la matrice orthogonale en {0} it\\u00e9rations\" },\n \n-    // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator\n     { \"minimal step size ({0}) reached, integration needs {1}\",\n       \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n     { \"dimensions mismatch: state vector has dimension {0},\" +\n       \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n       \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n \n-    // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator,\n-    // org.apache.commons.math.ode.RungeKuttaIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator,\n+    // org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator\n     { \"dimensions mismatch: ODE problem has dimension {0},\" +\n       \" initial state vector has dimension {1}\",\n       \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n+    // org.apache.commons.math.ode.ContinuousOutputModel\n+    // org.apache.commons.math.optimization.DirectSearchOptimizer\n+    { \"unexpected exception caught\",\n+      \"exception inattendue lev\\u00e9e\" },\n+\n     // org.apache.commons.math.optimization.DirectSearchOptimizer\n     { \"none of the {0} start points lead to convergence\",\n-      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  }\n+      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n+\n+    // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    { \"no bin selected\",\n+      \"aucun compartiment s\\u00e9lectionn\\u00e9\" },\n+\n+    // org.apache.commons.math.linear.EigenDecompositionImpl\n+    { \"negative element on decomposed tridiagonal of {0}x{1} matrix\",\n+      \"\\u00e9l\\u00e9ment n\\u00e9gatif dans la d\\u00e9composition tri-diagonale d''une matrice {0}x{1}\" },\n+\n+    // org.apache.commons.math.linear.NonSquareMatrixException\n+    { \"a {0}x{1} matrix was provided instead of a square matrix\",\n+      \"une matrice {0}x{1} a \\u00e9t\\u00e9 fournie \\u00e0 la place d''une matrice carr\\u00e9e\" },\n+\n+    // org.apache.commons.math.linear.SingularMatrixException\n+    { \"matrix is singular\",\n+      \"matrice singuli\\u00e8re\" },\n+\n+    // org.apache.commons.math.linear.RankDeficientMatrixException\n+    { \"matrix is rank-deficient\",\n+      \"le rang de la matrice est inf\\u00e9rieur \\u00e0 sa dimension\" },\n+\n+    // org.apache.commons.math.linear.RealVectorImpl\n+    { \"index {0} out of allowed range [{1}, {2}]\",\n+      \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+\n+    // org.apache.commons.math.linear.BigMatrixImpl\n+    // org.apache.commons.math.linear.RealMatrixImpl\n+    { \"row index {0} out of allowed range [{1}, {2}]\",\n+      \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"column index {0} out of allowed range [{1}, {2}]\",\n+      \"index de colonne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+      \"pas d''entr\\u00e9e aux indices ({0}, {1}) dans une matrice {2}x{3}\" },\n+    { \"initial row {0} after final row {1}\",\n+      \"ligne initiale {0} apr\\u00e8s la ligne finale {1}\" },\n+    { \"initial column {0} after final column {1}\",\n+      \"colonne initiale {0} apr\\u00e8s la colonne finale {1}\" },\n+    { \"empty selected row index array\",\n+      \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n+    { \"empty selected column index array\",\n+      \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" }\n \n   };\n \n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n     public BigMatrix getSubMatrix(int startRow, int endRow,\n                                   int startColumn, int endColumn)\n         throws MatrixIndexException {\n-        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n-                startColumn < 0 || startColumn > endColumn ||\n-                endColumn > data[0].length ) {\n-            throw new MatrixIndexException(\n-            \"invalid row or column index selection\");\n-        }\n+\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n         final BigDecimal[][] subMatrixData =\n             new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n             System.arraycopy(data[i], startColumn,\n-                    subMatrixData[i - startRow], 0,\n-                    endColumn - startColumn + 1);\n-        }\n+                             subMatrixData[i - startRow], 0,\n+                             endColumn - startColumn + 1);\n+        }\n+\n         return new BigMatrixImpl(subMatrixData, false);\n+\n     }\n     \n     /**\n      */\n     public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n         throws MatrixIndexException {\n+\n         if (selectedRows.length * selectedColumns.length == 0) {\n-            throw new MatrixIndexException(\n-            \"selected row and column index arrays must be non-empty\");\n-        }\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", new Object[0]);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", new Object[0]);\n+        }\n+\n         final BigDecimal[][] subMatrixData =\n             new BigDecimal[selectedRows.length][selectedColumns.length];\n         try  {\n                     subI[j] = dataSelectedI[selectedColumns[j]];\n                 }\n             }\n-        }\n-        catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix dimension mismatch\");\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                checkRowIndex(row);\n+            }\n+            for (final int column : selectedColumns) {\n+                checkColumnIndex(column);\n+            }\n         }\n         return new BigMatrixImpl(subMatrixData, false);\n     } \n      */\n     public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) \n     throws MatrixIndexException {\n-        if ((row < 0) || (column < 0)){\n-            throw new MatrixIndexException\n-            (\"invalid row or column index selection\");          \n-        }\n+\n         final int nRows = subMatrix.length;\n+        final int nCols = subMatrix[0].length;\n+\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n-        final int nCols = subMatrix[0].length;\n+            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+        }\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n-        }\n+            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+        }\n+\n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n-            }\n-        }       \n+                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+            }\n+        }\n+\n         if (data == null) {\n-            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n-            (\"matrix must be initialized to perfom this method\");\n+            if ((row > 0) || (column > 0)) {\n+                throw new IllegalStateException(\"matrix must be initialized to perform this method\");\n+            }\n             data = new BigDecimal[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n-        }   \n-        if (((nRows + row) > this.getRowDimension()) ||\n-            (nCols + column > this.getColumnDimension()))\n-            throw new MatrixIndexException(\n-            \"invalid row or column index selection\");                   \n+        } else {\n+            checkRowIndex(row);\n+            checkColumnIndex(column);\n+            checkRowIndex(nRows + row - 1);\n+            checkColumnIndex(nCols + column - 1);\n+        }\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n+\n         lu = null;\n+\n     }\n     \n     /**\n      * @throws MatrixIndexException if the specified row index is invalid\n      */\n     public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0)) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n+        checkRowIndex(row);\n         final int ncols = this.getColumnDimension();\n         final BigDecimal[][] out = new BigDecimal[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n      * @throws MatrixIndexException if the specified column index is invalid\n      */\n     public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, column)) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n+        checkColumnIndex(column);\n         final int nRows = this.getRowDimension();\n         final BigDecimal[][] out = new BigDecimal[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public BigDecimal[] getRow(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n+        checkRowIndex(row);\n         final int ncols = this.getColumnDimension();\n         final BigDecimal[] out = new BigDecimal[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n+        checkRowIndex(row);\n         final int ncols = this.getColumnDimension();\n         final double[] out = new double[ncols];\n         for (int i=0;i<ncols;i++) {\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate(0, col) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n+        checkColumnIndex(col);\n         final int nRows = this.getRowDimension();\n         final BigDecimal[] out = new BigDecimal[nRows];\n         for (int i = 0; i < nRows; i++) {\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, col ) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n+        checkColumnIndex(col);\n         final int nrows = this.getRowDimension();\n         final double[] out = new double[nrows];\n         for (int i=0;i<nrows;i++) {\n         try {\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix entry does not exist\");\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n         }\n     }\n     \n      */\n     public BigDecimal getDeterminant() throws InvalidMatrixException {\n         if (!isSquare()) {\n-            throw new InvalidMatrixException(\"matrix is not square\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n             return ZERO;\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         if (!this.isSquare()) {\n-            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         if (this.isSingular()) { // side effect: compute LU decomp\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n+            throw new SingularMatrixException();\n         }\n         \n         final int nCol = this.getColumnDimension();\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (nRows != nCols) {\n-            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         lu = this.getData();\n         \n             // Singularity check\n             if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n                 lu = null;\n-                throw new InvalidMatrixException(\"matrix is singular\");\n+                throw new SingularMatrixException();\n             }\n             \n             // Pivot if necessary\n         }\n         lu = null;\n     }\n-    \n-    /**\n-     * Tests a given coordinate as being valid or invalid\n-     *\n-     * @param row the row index.\n-     * @param col the column index.\n-     * @return true if the coordinate is with the current dimensions\n-     */\n-    private boolean isValidCoordinate(int row, int col) {\n-        final int nRows = this.getRowDimension();\n-        final int nCols = this.getColumnDimension();\n-        return !(row < 0 || row >= nRows || col < 0 || col >= nCols);\n-    }\n-    \n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { row, 0, getRowDimension() - 1});\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { column, 0, getColumnDimension() - 1});\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * Thrown when a system attempts an operation on a matrix, and\n  * that matrix does not satisfy the preconditions for the\n  * aforementioned operation.\n  * @version $Revision$ $Date$\n  */\n-public class InvalidMatrixException extends RuntimeException {\n+public class InvalidMatrixException extends MathRuntimeException {\n \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = 5318837237354354107L;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1135533765052675495L;\n \n     /**\n-     * Default constructor.\n+     * Construct an exception with the given message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n      */\n-    public InvalidMatrixException() {\n-        this(null);\n+    public InvalidMatrixException(final String pattern, final Object[] arguments) {\n+        super(pattern, arguments);\n     }\n \n     /**\n      * Construct an exception with the given message.\n-     * @param message descriptive error message.\n+     * @param cause the exception or error that caused this exception\n+     * to be thrown.\n+     * @since 2.0\n      */\n-    public InvalidMatrixException(String message) {\n-        super(message);\n+    public InvalidMatrixException(final Throwable cause) {\n+        super(cause);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n     public void decompose(RealMatrix matrix, double singularityThreshold)\n         throws InvalidMatrixException {\n         if (!matrix.isSquare()) {\n-            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square\");\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n         }\n         final int m = matrix.getColumnDimension();\n         lu = matrix.getData();\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n         if (singular) {\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n+            throw new SingularMatrixException();\n         }\n \n         final double[] bp = new double[m];\n                 throw new IllegalArgumentException(\"constant vector has wrong length\");\n             }\n             if (singular) {\n-                throw new InvalidMatrixException(\"Matrix is singular.\");\n+                throw new SingularMatrixException();\n             }\n \n             final double[] bp = new double[m];\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         if (singular) {\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n+            throw new SingularMatrixException();\n         }\n \n         final int nColB = b.getColumnDimension();\n--- a/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n- * Thrown when an operation addresses a matrix coordinate (row,col)\n+ * Thrown when an operation addresses a matrix coordinate (row, col)\n  * which is outside of the dimensions of a matrix.\n  * @version $Revision$ $Date$\n  */\n-public class MatrixIndexException extends RuntimeException {\n+public class MatrixIndexException extends MathRuntimeException {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 3728473373420246054L;\n+    private static final long serialVersionUID = -2382324504109300625L;\n \n     /**\n-     * Construct an exception with the given message and root cause.\n-     * @param message descriptive error message.\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n      */\n-    public MatrixIndexException(String message) {\n-        super(message);\n+    public MatrixIndexException(final String pattern, final Object[] arguments) {\n+      super(pattern, arguments);\n     }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when an operation defined only for square matrices is applied to non-square ones.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NonSquareMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8996207526636673730L;\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param rows number of rows of the faulty matrix\n+     * @param columns number of columns of the faulty matrix\n+     */\n+    public NonSquareMatrixException(final int rows, final int columns) {\n+        super(\"a {0}x{1} matrix was provided instead of a square matrix\",\n+              new Object[] { rows, columns });\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         if (!isNonSingular()) {\n-            throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n+            throw new RankDeficientMatrixException();\n         }\n \n         final double[] x = new double[n];\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         if (!isNonSingular()) {\n-            throw new InvalidMatrixException(\"Matrix is rank-deficient\");\n+            throw new RankDeficientMatrixException();\n         }\n \n         final int cols = b.getColumnDimension();\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RankDeficientMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when a matrix is singular.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RankDeficientMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7051890448195709736L;\n+\n+    /**\n+     * Construct an exception with a default message.\n+     */\n+    public RankDeficientMatrixException() {\n+        super(\"matrix is rank-deficient\", new Object[0]);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     public RealMatrix getSubMatrix(int startRow, int endRow,\n                                    int startColumn, int endColumn)\n         throws MatrixIndexException {\n-        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n-             startColumn < 0 || startColumn > endColumn ||\n-             endColumn > data[0].length) {\n-            throw new MatrixIndexException(\n-                    \"invalid row or column index selection\");\n-        }\n+\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n         final double[][] subMatrixData =\n             new double[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n     /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n         throws MatrixIndexException {\n+\n         if (selectedRows.length * selectedColumns.length == 0) {\n-            throw new MatrixIndexException(\n-                    \"selected row and column index arrays must be non-empty\");\n-        }\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", new Object[0]);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", new Object[0]);\n+        }\n+\n         final double[][] subMatrixData =\n             new double[selectedRows.length][selectedColumns.length];\n         try  {\n                 }\n             }\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix dimension mismatch\");\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                checkRowIndex(row);\n+            }\n+            for (final int column : selectedColumns) {\n+                checkColumnIndex(column);\n+            }\n         }\n         return new RealMatrixImpl(subMatrixData, false);\n     } \n      */\n     public void setSubMatrix(double[][] subMatrix, int row, int column) \n         throws MatrixIndexException {\n-        if ((row < 0) || (column < 0)){\n-            throw new MatrixIndexException\n-                (\"invalid row or column index selection\");          \n-        }\n+\n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n+            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+        }\n+\n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n-        }\n+            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+        }\n+\n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n-            }\n-        }       \n+                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+            }\n+        }\n+\n         if (data == null) {\n-            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n-                (\"matrix must be initialized to perfom this method\");\n+            if ((row > 0) || (column > 0)) {\n+                throw new IllegalStateException(\"matrix must be initialized to perform this method\");\n+            }\n             data = new double[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n-        }   \n-        if (((nRows + row) > this.getRowDimension()) ||\n-            (nCols + column > this.getColumnDimension()))\n-            throw new MatrixIndexException(\n-                    \"invalid row or column index selection\");                   \n+        } else {\n+            checkRowIndex(row);\n+            checkColumnIndex(column);\n+            checkRowIndex(nRows + row - 1);\n+            checkColumnIndex(nCols + column - 1);\n+        }\n+\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n+\n         lu = null;\n+\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0)) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n+        checkRowIndex(row);\n         final int ncols = this.getColumnDimension();\n         final double[][] out = new double[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n     \n     /** {@inheritDoc} */\n     public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, column)) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n+        checkColumnIndex(column);\n         final int nRows = this.getRowDimension();\n         final double[][] out = new double[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n \n     /** {@inheritDoc} */\n     public double[] getRow(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n+        checkRowIndex(row);\n         final int ncols = this.getColumnDimension();\n         final double[] out = new double[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n \n     /** {@inheritDoc} */\n     public double[] getColumn(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate(0, col) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n+        checkColumnIndex(col);\n         final int nRows = this.getRowDimension();\n         final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n         try {\n             return data[row][column];\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix entry does not exist\");\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n         }\n     }\n \n      * @throws NullPointerException if input array is null\n      */\n     private void copyIn(double[][] in) {\n-        setSubMatrix(in,0,0);\n-    }\n-\n-    /**\n-     * Tests a given coordinate as being valid or invalid\n-     *\n-     * @param row the row index.\n-     * @param col the column index.\n-     * @return true if the coordinate is with the current dimensions\n-     */\n-    private boolean isValidCoordinate(int row, int col) {\n-        final int nRows = getRowDimension();\n-        final int nCols = getColumnDimension();\n-        return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { row, 0, getRowDimension() - 1});\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { column, 0, getColumnDimension() - 1});\n+        }\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n \n     /** {@inheritDoc} */\n     public RealVector get(int index, int n) {\n+        RealVectorImpl out = new RealVectorImpl(n);\n         try {\n-            RealVectorImpl out = new RealVectorImpl(n);\n             System.arraycopy(data, index, out.data, 0, n);\n-\n-            return out;\n         } catch (IndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(e.getMessage());\n-        }\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n     }\n \n     /** {@inheritDoc} */\n         try {\n             data[index] = value;\n         } catch (IndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(e.getMessage());\n+            checkIndex(index);\n         }\n     }\n \n                 }\n             }\n         } catch (IndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(e.getMessage());\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n         }\n     }\n \n         try {\n             System.arraycopy(v, 0, data, index, v.length);\n         } catch (IndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(e.getMessage());\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n         }\n     }\n \n         return MathUtils.hash(data);\n     }\n \n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\"index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { index, 0, getDimension() - 1});\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when a matrix is singular.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SingularMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7379143356784298432L;\n+\n+    /**\n+     * Construct an exception with a default message.\n+     */\n+    public SingularMatrixException() {\n+        super(\"matrix is singular\", new Object[0]);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n     public TriDiagonalTransformer(RealMatrix matrix)\n         throws InvalidMatrixException {\n         if (!matrix.isSquare()) {\n-            throw new InvalidMatrixException(\"transformation to tridiagonal requires that the matrix be square\");\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n         }\n \n         final int m = matrix.getRowDimension();\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+            throw new InvalidMatrixException(\"incorrect dimensions\", new Object[0]);\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n--- a/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n  * @version $Revision$ $Date$\n  */\n public class InvalidMatrixExceptionTest extends TestCase {\n-    /**\n-     * \n-     */\n-    public void testConstructor(){\n-        InvalidMatrixException ex = new InvalidMatrixException();\n-        assertNull(ex.getMessage());\n-    }\n     \n     /**\n      * \n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        InvalidMatrixException ex = new InvalidMatrixException(msg);\n+        InvalidMatrixException ex = new InvalidMatrixException(msg, new Object[0]);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- a/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        MatrixIndexException ex = new MatrixIndexException(msg);\n+        MatrixIndexException ex = new MatrixIndexException(msg, new Object[0]);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         RealMatrixImpl m2 = new RealMatrixImpl();\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n             // expected\n         }\n         \n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+            throw new InvalidMatrixException(\"incorrect dimensions\", new Object[0]);\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {", "timestamp": 1225747946, "metainfo": ""}