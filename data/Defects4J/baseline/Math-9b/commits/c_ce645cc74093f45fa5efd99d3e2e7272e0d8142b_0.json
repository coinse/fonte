{"sha": "ce645cc74093f45fa5efd99d3e2e7272e0d8142b", "log": "MATH-503 Added parametric version of the \"Logistic\" function.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n \n     /** {@inheritDoc} */\n     public double value(double x) {\n-        return a + (k - a) / FastMath.pow(1 + q * FastMath.exp(b * (m - x)), oneOverN);\n+        return value(m - x, k, b, q, a, oneOverN);\n     }\n \n     /** {@inheritDoc} */\n             }\n         };\n     }\n+\n+    /**\n+     * Parametric function where the input array contains the parameters of\n+     * the logit function, ordered as follows:\n+     * <ul>\n+     *  <li>Lower asymptote</li>\n+     *  <li>Higher asymptote</li>\n+     * </ul>\n+     */\n+    public static class Parametric implements ParametricUnivariateRealFunction {\n+        /**\n+         * Computes the value of the sigmoid at {@code x}.\n+         *\n+         * @param x Value for which the function must be computed.\n+         * @param param Values for {@code k}, {@code m}, {@code b}, {@code q},\n+         * {@code a} and  {@code n}.\n+         * @return the value of the function.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 6.\n+         */\n+        public double value(double x,\n+                            double[] param) {\n+            validateParameters(param);\n+            return Logistic.value(param[1] - x, param[0],\n+                                  param[2], param[3],\n+                                  param[4], 1 / param[5]);\n+        }\n+\n+        /**\n+         * Computes the value of the gradient at {@code x}.\n+         * The components of the gradient vector are the partial\n+         * derivatives of the function with respect to each of the\n+         * <em>parameters</em>.\n+         *\n+         * @param x Value at which the gradient must be computed.\n+         * @param param Values for {@code k}, {@code m}, {@code b}, {@code q},\n+         * {@code a} and  {@code n}.\n+         * @return the gradient vector at {@code x}.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 6.\n+         */\n+        public double[] gradient(double x, double[] param) {\n+            validateParameters(param);\n+\n+            final double b = param[2];\n+            final double q = param[3];\n+\n+            final double mMinusX = param[1] - x;\n+            final double oneOverN = 1 / param[5];\n+            final double exp = FastMath.exp(b * mMinusX);\n+            final double qExp = q * exp;\n+            final double qExp1 = qExp + 1;\n+            final double factor1 = (param[0] - param[4]) * oneOverN / FastMath.pow(qExp1, oneOverN);\n+            final double factor2 = -factor1 / qExp1;\n+\n+            // Components of the gradient.\n+            final double gk = Logistic.value(mMinusX, 1, b, q, 0, oneOverN);\n+            final double gm = factor2 * b * qExp;\n+            final double gb = factor2 * mMinusX * qExp;\n+            final double gq = factor2 * exp;\n+            final double ga = Logistic.value(mMinusX, 0, b, q, 1, oneOverN);\n+            final double gn = factor1 * Math.log(qExp1) * oneOverN;\n+\n+            return new double[] { gk, gm, gb, gq, ga, gn };\n+        }\n+\n+        /**\n+         * Validates parameters to ensure they are appropriate for the evaluation of\n+         * the {@link #value(double,double[])} and {@link #gradient(double,double[])}\n+         * methods.\n+         *\n+         * @param param Values for {@code k}, {@code m}, {@code b}, {@code q},\n+         * {@code a} and  {@code n}.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 6.\n+         */\n+        private void validateParameters(double[] param) {\n+            if (param == null) {\n+                throw new NullArgumentException();\n+            }\n+            if (param.length != 6) {\n+                throw new DimensionMismatchException(param.length, 6);\n+            }\n+            if (param[5] <= 0) {\n+                throw new NotStrictlyPositiveException(param[5]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param mMinusX {@code m - x}.\n+     * @param k {@code k}.\n+     * @param b {@code b}.\n+     * @param q {@code q}.\n+     * @param a {@code a}.\n+     * @param oneOverN {@code 1 / n}.\n+     * @return the value of the function.\n+     */\n+    private static double value(double mMinusX,\n+                                double k,\n+                                double b,\n+                                double q,\n+                                double a,\n+                                double oneOverN) {\n+        return a + (k - a) / FastMath.pow(1 + q * FastMath.exp(b * mMinusX), oneOverN);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/function/LogisticTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/LogisticTest.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n \n import org.junit.Assert;\n             Assert.assertEquals(\"x=\" + x, dgdx.value(x), dfdx.value(x), EPS);\n         }\n     }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage1() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.value(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage2() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.value(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage3() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.gradient(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage4() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.gradient(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testParametricUsage5() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.value(0, new double[] {1, 0, 1, 1, 0 ,0});\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testParametricUsage6() {\n+        final Logistic.Parametric g = new Logistic.Parametric();\n+        g.gradient(0, new double[] {1, 0, 1, 1, 0 ,0});\n+    }\n+\n+    @Test\n+    public void testGradientComponent0Component4() {\n+        final double k = 3;\n+        final double a = 2;\n+\n+        final Logistic.Parametric f = new Logistic.Parametric();\n+        // Compare using the \"Sigmoid\" function.\n+        final Sigmoid.Parametric g = new Sigmoid.Parametric();\n+        \n+        final double x = 0.12345;\n+        final double[] gf = f.gradient(x, new double[] {k, 0, 1, 1, a, 1});\n+        final double[] gg = g.gradient(x, new double[] {a, k});\n+\n+        Assert.assertEquals(gg[0], gf[4], EPS);\n+        Assert.assertEquals(gg[1], gf[0], EPS);\n+    }\n+\n+    @Test\n+    public void testGradientComponent5() {\n+        final double m = 1.2;\n+        final double k = 3.4;\n+        final double a = 2.3;\n+        final double q = 0.567;\n+        final double b = -FastMath.log(q);\n+        final double n = 3.4;\n+\n+        final Logistic.Parametric f = new Logistic.Parametric();\n+        \n+        final double x = m - 1;\n+        final double qExp1 = 2;\n+\n+        final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});\n+\n+        Assert.assertEquals((k - a) * FastMath.log(qExp1) / (n * n * FastMath.pow(qExp1, 1 / n)),\n+                            gf[5], EPS);\n+    }\n+\n+    @Test\n+    public void testGradientComponent1Component2Component3() {\n+        final double m = 1.2;\n+        final double k = 3.4;\n+        final double a = 2.3;\n+        final double b = 0.567;\n+        final double q = 1 / FastMath.exp(b * m);\n+        final double n = 3.4;\n+\n+        final Logistic.Parametric f = new Logistic.Parametric();\n+        \n+        final double x = 0;\n+        final double qExp1 = 2;\n+\n+        final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});\n+\n+        final double factor = (a - k) / (n * FastMath.pow(qExp1, 1 / n + 1));\n+        Assert.assertEquals(factor * b, gf[1], EPS);\n+        Assert.assertEquals(factor * m, gf[2], EPS);\n+        Assert.assertEquals(factor / q, gf[3], EPS);\n+    }\n }", "timestamp": 1299852239, "metainfo": ""}