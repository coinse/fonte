{"sha": "39d423c40411646aa26182266ef727d6bea9e018", "log": "[MATH-666] make FieldVector#getData() method deprecated in favor of toArray(), minor formatting, move implementation of SparseFieldVector#getData() to toArray().  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n      * Compute the sum of {@code this} and {@code v}.\n      * @param v vector to be added\n      * @return {@code this + v}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      */\n     FieldVector<T> add(FieldVector<T> v) throws DimensionMismatchException;\n \n      * Compute {@code this} minus {@code v}.\n      * @param v vector to be subtracted\n      * @return {@code this - v}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      */\n     FieldVector<T> subtract(FieldVector<T> v) throws DimensionMismatchException;\n \n \n     /**\n      * Map the 1/x function to each entry.\n-     * @return a vector containing the result of applying the function to each\n-     * entry.\n+     * @return a vector containing the result of applying the function to each entry.\n      * @throws MathArithmeticException if one of the entries is zero.\n      */\n     FieldVector<T> mapInv() throws MathArithmeticException;\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @return a vector containing {@code this[i] * v[i]} for all {@code i}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      */\n     FieldVector<T> ebeMultiply(FieldVector<T> v)\n         throws DimensionMismatchException;\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      * @throws MathArithmeticException if one entry of {@code v} is zero.\n      */\n     FieldVector<T> ebeDivide(FieldVector<T> v)\n     /**\n      * Returns vector entries as a T array.\n      * @return T array of entries\n-     */\n-     T[] getData();\n+     * @deprecated as of 3.1, to be removed in 4.0. Please use the {@link #toArray()} method instead.\n+     */\n+    @Deprecated\n+    T[] getData();\n \n     /**\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      * @return the scalar dot product of {@code this} and {@code v}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      */\n     T dotProduct(FieldVector<T> v) throws DimensionMismatchException;\n \n-    /** Find the orthogonal projection of this vector onto another vector.\n+    /**\n+     * Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which {@code this} must be projected\n      * @return projection of {@code this} onto {@code v}\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as {@code this}\n      * @throws MathArithmeticException if {@code v} is the null vector.\n      */\n     FieldVector<T> projection(FieldVector<T> v)\n--- a/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n     /** {@inheritDoc} */\n     public FieldVector<T> copy() {\n         return new SparseFieldVector<T>(this);\n-   }\n+    }\n \n     /** {@inheritDoc} */\n     public T dotProduct(FieldVector<T> v) throws DimensionMismatchException {\n         return res;\n     }\n \n-     /** {@inheritDoc} */\n-     public T[] getData() {\n-        T[] res = buildArray(virtualSize);\n-        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res[iter.key()] = iter.value();\n-        }\n-        return res;\n-     }\n-\n-     /** {@inheritDoc} */\n-     public int getDimension() {\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @deprecated as of 3.1, to be removed in 4.0. Please use the {@link #toArray()} method instead.\n+     */\n+    @Deprecated\n+    public T[] getData() {\n+        return toArray();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n         return virtualSize;\n     }\n \n-     /** {@inheritDoc} */\n-     public T getEntry(int index) throws OutOfRangeException {\n+    /** {@inheritDoc} */\n+    public T getEntry(int index) throws OutOfRangeException {\n         checkIndex(index);\n         return entries.get(index);\n    }\n \n-     /** {@inheritDoc} */\n-     public Field<T> getField() {\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n         return field;\n     }\n \n-     /** {@inheritDoc} */\n+    /** {@inheritDoc} */\n     public FieldVector<T> getSubVector(int index, int n)\n         throws OutOfRangeException, NotPositiveException {\n         if (n < 0) {\n         return res;\n     }\n \n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n         return copy().mapAddToSelf(d);\n-   }\n-\n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, getEntry(i).add(d));\n         }\n         return this;\n     }\n \n-     /** {@inheritDoc} */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapDivide(T d)\n         throws NullArgumentException, MathArithmeticException {\n         return copy().mapDivideToSelf(d);\n     }\n \n-     /** {@inheritDoc} */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapDivideToSelf(T d)\n         throws NullArgumentException, MathArithmeticException {\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n             entries.put(iter.key(), iter.value().divide(d));\n         }\n         return this;\n-   }\n-\n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapInv() throws MathArithmeticException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInv() throws MathArithmeticException {\n         return copy().mapInvToSelf();\n-   }\n-\n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, field.getOne().divide(getEntry(i)));\n         }\n         return this;\n-   }\n-\n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n         return copy().mapMultiplyToSelf(d);\n     }\n \n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException {\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             entries.put(iter.key(), iter.value().multiply(d));\n         }\n         return this;\n-   }\n-\n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n         return copy().mapSubtractToSelf(d);\n     }\n \n-     /** {@inheritDoc} */\n-     public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException {\n         return mapAddToSelf(field.getZero().subtract(d));\n     }\n \n     public void setEntry(int index, T value) throws OutOfRangeException {\n         checkIndex(index);\n         entries.put(index, value);\n-   }\n+    }\n \n     /** {@inheritDoc} */\n     public void setSubVector(int index, FieldVector<T> v)\n \n     /** {@inheritDoc} */\n     public T[] toArray() {\n-        return getData();\n+        T[] res = buildArray(virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n     }\n \n     /**", "timestamp": 1347814232, "metainfo": ""}