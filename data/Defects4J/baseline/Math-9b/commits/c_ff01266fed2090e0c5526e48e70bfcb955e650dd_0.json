{"sha": "ff01266fed2090e0c5526e48e70bfcb955e650dd", "log": "MATH-854: populated throws clause of AbstractRealMatrix.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java\n import java.util.Locale;\n \n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.MathUtils;\n import org.apache.commons.math3.util.FastMath;\n      * @param columnDimension  the number of columns in the new matrix\n      * @throws NotStrictlyPositiveException if row or column dimension is not positive\n      */\n-    protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\n+    protected AbstractRealMatrix(final int rowDimension,\n+        final int columnDimension)\n+        throws NotStrictlyPositiveException {\n         if (rowDimension < 1) {\n             throw new NotStrictlyPositiveException(rowDimension);\n         }\n     public abstract RealMatrix copy();\n \n     /** {@inheritDoc} */\n-    public RealMatrix add(RealMatrix m) {\n-        // Safety check.\n+    public RealMatrix add(RealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix subtract(final RealMatrix m) {\n-        // Safety check.\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix multiply(final RealMatrix m) {\n-        // Safety check.\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws DimensionMismatchException {\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int nRows = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix preMultiply(final RealMatrix m) {\n+    public RealMatrix preMultiply(final RealMatrix m)\n+        throws DimensionMismatchException {\n         return m.multiply(this);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix power(final int p) {\n+    public RealMatrix power(final int p)\n+        throws NotPositiveException, NonSquareMatrixException {\n         if (p < 0) {\n-            throw new IllegalArgumentException(\"p must be >= 0\");\n+            throw new NotPositiveException(LocalizedFormats.NOT_POSITIVE_EXPONENT, p);\n         }\n \n         if (!isSquare()) {\n \n     /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(final int startRow, final int endRow,\n-                                   final int startColumn, final int endColumn) {\n+                                   final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n         final RealMatrix subMatrix =\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) {\n-        // safety checks\n+    public RealMatrix getSubMatrix(final int[] selectedRows,\n+                                   final int[] selectedColumns)\n+        throws NullArgumentException, NoDataException, OutOfRangeException {\n         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n \n-        // copy entries\n         final RealMatrix subMatrix =\n             createMatrix(selectedRows.length, selectedColumns.length);\n         subMatrix.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n                               final int startColumn, final int endColumn,\n-                              final double[][] destination) {\n-        // safety checks\n+                              final double[][] destination)\n+        throws OutOfRangeException, NumberIsTooSmallException,\n+        MatrixDimensionMismatchException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         final int rowsCount    = endRow + 1 - startRow;\n         final int columnsCount = endColumn + 1 - startColumn;\n                                                        rowsCount, columnsCount);\n         }\n \n-        // copy entries\n         walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n \n             /** Initial row index. */\n     }\n \n     /** {@inheritDoc} */\n-    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) {\n-        // safety checks\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns,\n+                              double[][] destination)\n+        throws OutOfRangeException, NullArgumentException, NoDataException,\n+        MatrixDimensionMismatchException {\n         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n                                                        selectedRows.length, selectedColumns.length);\n         }\n \n-        // copy entries\n         for (int i = 0; i < selectedRows.length; i++) {\n             final double[] destinationI = destination[i];\n             for (int j = 0; j < selectedColumns.length; j++) {\n \n     /** {@inheritDoc} */\n     public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n-        throws NoDataException, DimensionMismatchException, NullArgumentException {\n+        throws NoDataException, OutOfRangeException,\n+        DimensionMismatchException, NullArgumentException {\n         MathUtils.checkNotNull(subMatrix);\n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getRowMatrix(final int row) {\n+    public RealMatrix getRowMatrix(final int row) throws OutOfRangeException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(1, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowMatrix(final int row, final RealMatrix matrix) {\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getColumnMatrix(final int column) {\n+    public RealMatrix getColumnMatrix(final int column)\n+        throws OutOfRangeException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final RealMatrix out = createMatrix(nRows, 1);\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnMatrix(final int column, final RealMatrix matrix) {\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getRowVector(final int row) {\n+    public RealVector getRowVector(final int row)\n+        throws OutOfRangeException {\n         return new ArrayRealVector(getRow(row), false);\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowVector(final int row, final RealVector vector) {\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getColumnVector(final int column) {\n+    public RealVector getColumnVector(final int column)\n+        throws OutOfRangeException {\n         return new ArrayRealVector(getColumn(column), false);\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnVector(final int column, final RealVector vector) {\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getRow(final int row) {\n+    public double[] getRow(final int row) throws OutOfRangeException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final double[] out = new double[nCols];\n     }\n \n     /** {@inheritDoc} */\n-    public void setRow(final int row, final double[] array) {\n+    public void setRow(final int row, final double[] array)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getColumn(final int column) {\n+    public double[] getColumn(final int column) throws OutOfRangeException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final double[] out = new double[nRows];\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumn(final int column, final double[] array) {\n+    public void setColumn(final int column, final double[] array)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n     public abstract void setEntry(int row, int column, double value);\n \n     /** {@inheritDoc} */\n-    public void addToEntry(int row, int column, double increment) {\n+    public void addToEntry(int row, int column, double increment)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         setEntry(row, column, getEntry(row, column) + increment);\n     }\n \n     /** {@inheritDoc} */\n-    public void multiplyEntry(int row, int column, double factor) {\n+    public void multiplyEntry(int row, int column, double factor)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         setEntry(row, column, getEntry(row, column) * factor);\n     }\n     public abstract int getColumnDimension();\n \n     /** {@inheritDoc} */\n-    public double getTrace() {\n+    public double getTrace() throws NonSquareMatrixException {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (nRows != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public double[] operate(final double[] v) {\n+    public double[] operate(final double[] v)\n+        throws DimensionMismatchException {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector operate(final RealVector v) {\n+    public RealVector operate(final RealVector v)\n+        throws DimensionMismatchException {\n         try {\n             return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public double[] preMultiply(final double[] v) {\n+    public double[] preMultiply(final double[] v) throws DimensionMismatchException {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector preMultiply(final RealVector v) {\n+    public RealVector preMultiply(final RealVector v) throws DimensionMismatchException {\n         try {\n             return new ArrayRealVector(preMultiply(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     /** {@inheritDoc} */\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn) {\n+                                 final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     /** {@inheritDoc} */\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn) {\n+                                 final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     /** {@inheritDoc} */\n     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                     final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn) {\n+                                    final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     /** {@inheritDoc} */\n     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                     final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn) {\n+                                    final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     /** {@inheritDoc} */\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                        final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn,\n+                                       final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n     /** {@inheritDoc} */\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                        final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn,\n+                                       final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n--- a/src/main/java/org/apache/commons/math3/linear/RealLinearOperator.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealLinearOperator.java\n      *\n      * @param x the vector to operate on\n      * @return the product of {@code this} instance with {@code x}\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if the column dimension does not match the size of {@code x}\n+     * @throws DimensionMismatchException if the column dimension does not match\n+     * the size of {@code x}\n      */\n-    public abstract RealVector operate(final RealVector x);\n+    public abstract RealVector operate(final RealVector x)\n+        throws DimensionMismatchException;\n \n     /**\n      * Returns the result of multiplying the transpose of {@code this} operator\n--- a/src/main/java/org/apache/commons/math3/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealMatrix.java\n package org.apache.commons.math3.linear;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.ZeroException;\n \n /**\n  * Interface defining a real-valued matrix with basic algebraic operations.\n      * @return The subMatrix containing the data of the\n      * specified rows and columns.\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      */\n     RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-        int endColumn)\n-        throws OutOfRangeException;\n-\n-    /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n+                            int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException;\n+\n+    /**\n+     * Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.\n      *\n      * @param selectedRows Array of row indices.\n      * @param selectedColumns Array of column indices.\n-     * @return The subMatrix containing the data in the\n-     * specified rows and columns\n+     * @return The subMatrix containing the data in the specified rows and\n+     * columns\n+     * @throws NullArgumentException if the row or column selections are\n+     * {@code null}\n+     * @throws NoDataException if the row or column selections are empty (zero\n+     * length).\n      * @throws OutOfRangeException if the indices are not valid.\n      */\n     RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-        throws OutOfRangeException;\n-\n-   /**\n-    * Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.\n-    *\n-    * @param startRow Initial row index\n-    * @param endRow Final row index (inclusive)\n-    * @param startColumn Initial column index\n-    * @param endColumn Final column index (inclusive)\n-    * @param destination The arrays where the submatrix data should be copied\n-    * (if larger than rows/columns counts, only the upper-left part will be used)\n-    * @throws OutOfRangeException if the indices are not valid.\n-    * @throws MatrixDimensionMismatchException if the destination array is too\n-    * small.\n-    */\n+        throws NullArgumentException, NoDataException, OutOfRangeException;\n+\n+    /**\n+     * Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @param destination The arrays where the submatrix data should be copied\n+     * (if larger than rows/columns counts, only the upper-left part will be\n+     * used)\n+     * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n+     * @throws MatrixDimensionMismatchException if the destination array is too\n+     * small.\n+     */\n     void copySubMatrix(int startRow, int endRow, int startColumn,\n-        int endColumn, double[][] destination)\n-        throws OutOfRangeException, MatrixDimensionMismatchException;\n-\n-    /**\n-     * Copy a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n+                       int endColumn, double[][] destination)\n+        throws OutOfRangeException, NumberIsTooSmallException,\n+        MatrixDimensionMismatchException;\n+\n+    /**\n+     * Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.\n      *\n      * @param selectedRows Array of row indices.\n      * @param selectedColumns Array of column indices.\n      * @param destination The arrays where the submatrix data should be copied\n-     * (if larger than rows/columns counts, only the upper-left part will be used)\n+     * (if larger than rows/columns counts, only the upper-left part will be\n+     * used)\n+     * @throws NullArgumentException if the row or column selections are\n+     * {@code null}\n+     * @throws NoDataException if the row or column selections are empty (zero\n+     * length).\n      * @throws OutOfRangeException if the indices are not valid.\n      * @throws MatrixDimensionMismatchException if the destination array is too\n      * small.\n      */\n     void copySubMatrix(int[] selectedRows, int[] selectedColumns,\n-        double[][] destination)\n-        throws OutOfRangeException, MatrixDimensionMismatchException;\n+                       double[][] destination)\n+        throws OutOfRangeException, NullArgumentException, NoDataException,\n+        MatrixDimensionMismatchException;\n \n    /**\n     * Replace the submatrix starting at {@code row, column} using data in the\n     * @param subMatrix  array containing the submatrix replacement data\n     * @param row  row coordinate of the top, left element to be replaced\n     * @param column  column coordinate of the top, left element to be replaced\n-    * @throws ZeroException if {@code subMatrix} does not contain at least one column.\n+    * @throws NoDataException if {@code subMatrix} is empty.\n     * @throws OutOfRangeException if {@code subMatrix} does not fit into\n     * this matrix from element in {@code (row, column)}.\n-    * @throws DimensionMismatchException if {@code subMatrix} is not rectangular.\n+    * @throws DimensionMismatchException if {@code subMatrix} is not rectangular\n     * (not all rows have the same length) or empty.\n     * @throws NullArgumentException if {@code subMatrix} is {@code null}.\n     * @since 2.0\n     */\n     void setSubMatrix(double[][] subMatrix, int row, int column)\n-        throws ZeroException, OutOfRangeException, DimensionMismatchException, NullArgumentException;\n+        throws NoDataException, OutOfRangeException,\n+        DimensionMismatchException, NullArgumentException;\n \n    /**\n     * Get the entries at the given row index as a row matrix.  Row indices start\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n      */\n     double walkInRowOrder(RealMatrixChangingVisitor visitor, int startRow,\n         int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n \n     /**\n      * Visit (but don't change) some matrix entries in row order.\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      */\n     double walkInRowOrder(RealMatrixPreservingVisitor visitor, int startRow,\n         int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n \n     /**\n      * Visit (and possibly change) all matrix entries in column order.\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      */\n     double walkInColumnOrder(RealMatrixChangingVisitor visitor, int startRow,\n         int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n \n     /**\n      * Visit (but don't change) some matrix entries in column order.\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      */\n     double walkInColumnOrder(RealMatrixPreservingVisitor visitor, int startRow,\n         int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n \n     /**\n      * Visit (and possibly change) all matrix entries using the fastest possible order.\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      */\n     double walkInOptimizedOrder(RealMatrixChangingVisitor visitor,\n         int startRow, int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n \n     /**\n      * Visit (but don't change) some matrix entries using the fastest possible order.\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      */\n     double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor,\n         int startRow, int endRow, int startColumn, int endColumn)\n-        throws OutOfRangeException;\n+        throws OutOfRangeException, NumberIsTooSmallException;\n }", "timestamp": 1347950313, "metainfo": ""}