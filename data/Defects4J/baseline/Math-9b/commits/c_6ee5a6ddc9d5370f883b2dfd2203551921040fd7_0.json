{"sha": "6ee5a6ddc9d5370f883b2dfd2203551921040fd7", "log": "Formatting only. Removed tabs and trailing spaces.   ", "commit": "\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * empirical probability distribution</a> -- a probability distribution derived\n  * from observed data without making any assumptions about the functional form\n  * of the population distribution that the data come from.<p>\n- * Implementations of this interface maintain data structures, called \n- * <i>distribution digests</i>, that describe empirical distributions and \n+ * Implementations of this interface maintain data structures, called\n+ * <i>distribution digests</i>, that describe empirical distributions and\n  * support the following operations: <ul>\n  * <li>loading the distribution from a file of observed data values</li>\n  * <li>saving and re-loading distribution digests to/from \"digest files\" </li>\n  *     as well as the observations within each bin</li>\n  * <li>generating random values from the distribution</li>\n  * </ul>\n- * Applications can use <code>EmpiricalDistribution</code> implementations to \n+ * Applications can use <code>EmpiricalDistribution</code> implementations to\n  * build grouped frequnecy histograms representing the input data or to\n  * generate random values \"like\" those in the input file -- i.e., the values\n  * generated will follow the distribution of the values in the file.\n- * @version $Revision: 1.17 $ $Date: 2004/04/12 02:27:49 $\n+ * @version $Revision: 1.18 $ $Date: 2004/06/14 23:15:14 $\n  */\n public interface EmpiricalDistribution {\n- \n+\n     /**\n      * Computes the empirical distribution from the provided\n      * array of numbers.\n      * @param dataArray the data array\n      */\n-    void load(double[] dataArray); \n-        \n+    void load(double[] dataArray);\n+\n     /**\n      * Computes the empirical distribution from the input file.\n      * @param filePath fully qualified name of a file in the local file system\n      * @throws IOException if an IO error occurs\n      */\n-    void load(String filePath) throws IOException; \n-    \n+    void load(String filePath) throws IOException;\n+\n     /**\n      * Computes the empirical distribution from the input file.\n      * @param file the input file\n      * @throws IOException if an IO error occurs\n      */\n     void load(File file) throws IOException;\n-    \n+\n     /**\n      * Computes the empirical distribution using data read from a URL.\n      * @param url url of the input file\n      * @throws IOException if an IO error occurs\n      */\n     void load(URL url) throws IOException;\n-    \n-    /** \n+\n+    /**\n      * Generates a random value from this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @return the random value.\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n-    double getNextValue() throws IllegalStateException;  \n-    \n-     \n-    /** \n+    double getNextValue() throws IllegalStateException;\n+\n+\n+    /**\n      * Returns a DescriptiveStatistics describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n     SummaryStatistics getSampleStats() throws IllegalStateException;\n-    \n-    /** \n+\n+    /**\n      * Loads a saved distribution from a file.\n      * @param file File reference for a file containing a digested distribution\n      * @throws IOException if an error occurs reading the file\n      */\n-    void loadDistribution(File file) throws IOException;  \n-    \n-    /** \n+    void loadDistribution(File file) throws IOException;\n+\n+    /**\n      * Loads a saved distribution from a file.\n-     * @param filePath fully qualified file path for a file \n-     * containing a digested distribution \n+     * @param filePath fully qualified file path for a file\n+     * containing a digested distribution\n      * @throws IOException if an error occurs reading the file\n      */\n-    void loadDistribution(String filePath) throws IOException; \n-    \n-    /** \n+    void loadDistribution(String filePath) throws IOException;\n+\n+    /**\n      * Saves distribution to a file. Overwrites the file if it exists.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @throws IOException if an error occurs reading the file\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n-    void saveDistribution(String filePath) throws \n+    void saveDistribution(String filePath) throws\n         IOException,IllegalStateException;\n-    \n-    /** \n+\n+    /**\n      * Saves distribution to a file. Overwrites the file if it exists.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n     void saveDistribution(File file) throws IOException,IllegalStateException;\n-    \n+\n     /**\n      * property indicating whether or not the distribution has been loaded\n      * @return true if the distribution has been loaded\n      */\n-    boolean isLoaded();  \n-    \n-     /** \n+    boolean isLoaded();\n+\n+     /**\n      * Returns the number of bins\n      * @return the number of bins.\n      */\n     int getBinCount();\n-    \n-    /** \n+\n+    /**\n      * Returns a list of Univariates containing statistics describing the\n      * values in each of the bins.  The ArrayList is indexed on the bin number.\n      * @return ArrayList of bin statistics.\n      */\n     ArrayList getBinStats();\n-    \n-    /** \n+\n+    /**\n      * Returns the array of upper bounds for the bins.  Bins are: <br/>\n      * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n      *  (upperBounds[binCount-1],max]\n      * @return array of bin upper bounds\n      */\n     double[] getUpperBounds();\n-    \n+\n }\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n- * uses what amounts to the \n+ * uses what amounts to the\n  * <a href=\"http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html\">\n  * Variable Kernel Method</a> with Gaussian smoothing:<p>\n  * <strong>Digesting the input file</strong>\n- * <ol><li>Pass the file once to compute min and max.</li>  \n+ * <ol><li>Pass the file once to compute min and max.</li>\n  * <li>Divide the range from min-max into <code>binCount</code> \"bins.\"</li>\n  * <li>Pass the data file again, computing bin counts and univariate\n  *     statistics (mean, std dev.) for each of the bins </li>\n  *    entry per line.</li>\n  * </ul></p>\n  *\n- * @version $Revision: 1.20 $ $Date: 2004/06/02 00:20:21 $\n+ * @version $Revision: 1.21 $ $Date: 2004/06/14 23:15:14 $\n  */\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = -6773236347582113490L;\n-    \n+\n     /** List of DescriptiveStatistics objects characterizing the bins */\n     private ArrayList binStats = null;\n-    \n+\n     /** Sample statistics */\n     SummaryStatistics sampleStats = null;\n-    \n+\n     /** number of bins */\n     private int binCount = 1000;\n-    \n+\n     /** is the distribution loaded? */\n     private boolean loaded = false;\n-    \n+\n     /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n     private double[] upperBounds = null;\n-    \n+\n     /** RandomData instance to use in repeated calls to getNext() */\n     private RandomData randomData = new RandomDataImpl();\n-    \n-    /** \n+\n+    /**\n      * Creates a new EmpiricalDistribution  with the default bin count\n      */\n     public EmpiricalDistributionImpl() {\n         binStats = new ArrayList();\n     }\n-    \n-    /** \n+\n+    /**\n      * Creates a new EmpiricalDistribution  with the specified bin count\n      * @param binCount number of bins\n      */\n             throw new RuntimeException(e.getMessage());\n         }\n         loaded = true;\n-        \n-    }\n-    \n+\n+    }\n+\n     public void load(String filePath) throws IOException {\n-        BufferedReader in = \n-            new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));  \n+        BufferedReader in =\n+            new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));\n         try {\n             DataAdapter da = new StreamDataAdapter(in);\n             try {\n             } catch (Exception e) {\n                 throw new IOException(e.getMessage());\n             }\n-            in = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));  \n+            in = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));\n             fillBinStats(in);\n             loaded = true;\n         } finally {\n            if (in != null) try {in.close();} catch (Exception ex) {};\n         }\n     }\n-    \n+\n     public void load(URL url) throws IOException {\n-        BufferedReader in = \n+        BufferedReader in =\n             new BufferedReader(new InputStreamReader(url.openStream()));\n         try {\n             DataAdapter da = new StreamDataAdapter(in);\n            if (in != null) try {in.close();} catch (Exception ex) {};\n         }\n     }\n-     \n+\n     public void load(File file) throws IOException {\n         BufferedReader in = new BufferedReader(new FileReader(file));\n         try {\n                 };\n         }\n     }\n-    \n-    /**\n-     * Provides methods for computing <code>sampleStats</code> and \n-     * <code>beanStats</code> abstracting the source of data. \n+\n+    /**\n+     * Provides methods for computing <code>sampleStats</code> and\n+     * <code>beanStats</code> abstracting the source of data.\n      */\n     private abstract class DataAdapter{\n-        public abstract void computeBinStats(double min, double delta) \n+        public abstract void computeBinStats(double min, double delta)\n                 throws Exception;\n         public abstract void computeStats() throws Exception;\n     }\n     /**\n      * Factory of <code>DataAdapter</code> objects. For every supported source\n      * of data (array of doubles, file, etc.) an instance of the proper object\n-     * is returned. \n+     * is returned.\n      */\n     private class DataAdapterFactory{\n         public DataAdapter getAdapter(Object in) {\n         /**\n          * Computes binStats\n          */\n-        public void computeBinStats(double min, double delta) \n+        public void computeBinStats(double min, double delta)\n                 throws IOException {\n             String str = null;\n             double val = 0.0d;\n             for (int i = 0; i < inputArray.length; i++) {\n                 SummaryStatistics stats =\n                     (SummaryStatistics) binStats.get(\n-                        Math.max((int) Math.ceil((inputArray[i] - min) / delta) \n+                        Math.max((int) Math.ceil((inputArray[i] - min) / delta)\n                             - 1, 0));\n                 stats.addValue(inputArray[i]);\n             }\n-        }    \n+        }\n     }\n \n     /**\n      * Fills binStats array (second pass through data file).\n      */\n-    private void fillBinStats(Object in) throws IOException {    \n+    private void fillBinStats(Object in) throws IOException {\n         // Load array of bin upper bounds -- evenly spaced from min - max\n         double min = sampleStats.getMin();\n         double max = sampleStats.getMax();\n             binUpperBounds[i] = binUpperBounds[i-1] + delta;\n         }\n         binUpperBounds[binCount -1] = max;\n-        \n+\n         // Initialize binStats ArrayList\n         if (!binStats.isEmpty()) {\n             binStats.clear();\n             SummaryStatistics stats = SummaryStatistics.newInstance();\n             binStats.add(i,stats);\n         }\n-        \n+\n         // Filling data in binStats Array\n         DataAdapterFactory aFactory = new DataAdapterFactory();\n         DataAdapter da = aFactory.getAdapter(in);\n                 throw new IOException(e.getMessage());\n             }\n         }\n-        \n+\n         // Assign upperBounds based on bin counts\n         upperBounds = new double[binCount];\n         upperBounds[0] =\n         }\n         upperBounds[binCount-1] = 1.0d;\n     }\n-    \n+\n     /**\n      * Generates a random value from this distribution\n      * @return the random value.\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n-    public double getNextValue() throws IllegalStateException {    \n-        \n+    public double getNextValue() throws IllegalStateException {\n+\n         if (!loaded) {\n             throw new IllegalStateException(\"distribution not loaded\");\n         }\n-        \n+\n         // Start with a uniformly distributed random number in (0,1)\n         double x = Math.random();\n-       \n+\n         // Use this to select the bin and generate a Gaussian within the bin\n         for (int i = 0; i < binCount; i++) {\n            if (x <= upperBounds[i]) {\n                SummaryStatistics stats = (SummaryStatistics)binStats.get(i);\n-               if (stats.getN() > 0) { \n-                   if (stats.getStandardDeviation() > 0) {  // more than one obs \n+               if (stats.getN() > 0) {\n+                   if (stats.getStandardDeviation() > 0) {  // more than one obs\n                         return randomData.nextGaussian\n                             (stats.getMean(),stats.getStandardDeviation());\n                    } else {\n         }\n         throw new RuntimeException(\"No bin selected\");\n     }\n-       \n+\n     public void loadDistribution(String filePath) throws IOException {\n         throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n     }\n-    \n+\n     public void loadDistribution(File file) throws IOException {\n         throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n     }\n-       \n-    public void saveDistribution(String filePath) throws \n+\n+    public void saveDistribution(String filePath) throws\n         IOException,IllegalStateException {\n        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n     }\n-    \n-    public void saveDistribution(File file) throws \n+\n+    public void saveDistribution(File file) throws\n         IOException,IllegalStateException {\n        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n     }\n-        \n+\n     public SummaryStatistics getSampleStats() {\n         return sampleStats;\n     }\n-    \n+\n     public int getBinCount() {\n         return binCount;\n     }\n-      \n+\n     public ArrayList getBinStats() {\n         return binStats;\n     }\n-       \n+\n     public double[] getUpperBounds() {\n         return upperBounds;\n     }\n-    \n+\n     public boolean isLoaded() {\n         return loaded;\n     }\n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Random data generation utilities\n- * @version $Revision: 1.9 $ $Date: 2004/04/11 19:00:45 $\n+ * @version $Revision: 1.10 $ $Date: 2004/06/14 23:15:15 $\n  */\n-public interface RandomData {      \n+public interface RandomData {\n     /**\n      * Generates a random string of hex characters of length\n      * <code>len</code>.\n      * <p>\n-     * The generated string will be random, but not cryptographically \n-     * secure. To generate cryptographically secure strings, use \n+     * The generated string will be random, but not cryptographically\n+     * secure. To generate cryptographically secure strings, use\n      * <code>nextSecureHexString</code>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n-     *     is thrown.)</li>\n-     * </ul>\n-     * \n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param len the length of the string to be generated\n-     * @return random string of hex characters of length <code>len</code>  \n-     */\n-    String nextHexString(int len);  \n-    \n-    /**\n-     * Generates a uniformly distributed random integer between \n+     * @return random string of hex characters of length <code>len</code>\n+     */\n+    String nextHexString(int len);\n+\n+    /**\n+     * Generates a uniformly distributed random integer between\n      * <code>lower</code> and <code>upper</code> (endpoints included).\n      * <p>\n      * The generated integer will be random, but not cryptographically secure.\n-     * To generate cryptographically secure integer sequences, use \n+     * To generate cryptographically secure integer sequences, use\n      * <code>nextSecureInt</code>.\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n-     *     is thrown.)</li>\n-     * </ul>\n-     *\n-     * @param lower lower bound for generated integer\n-     * @param upper upper bound for generated integer\n-     * @return a random integer greater than or equal to <code>lower</code> \n-     * and less than or equal to <code>upper</code>.\n-     */\n-    int nextInt(int lower, int upper);  \n-    \n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    int nextInt(int lower, int upper);\n+\n     /**\n      * Generates a uniformly distributed random long integer between\n      * <code>lower</code> and <code>upper</code> (endpoints included).\n      * <p>\n-     * The generated long integer values will be random, but not \n+     * The generated long integer values will be random, but not\n      * cryptographically secure.\n-     * To generate cryptographically secure sequences of longs, use \n+     * To generate cryptographically secure sequences of longs, use\n      * <code>nextSecureLong</code>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      *\n      * @return a random integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    long nextLong(long lower, long upper);  \n-    \n-    /**\n-     * Generates a random string of hex characters from a secure random \n+    long nextLong(long lower, long upper);\n+\n+    /**\n+     * Generates a random string of hex characters from a secure random\n      * sequence.\n      * <p>\n-     * If cryptographic security is not required, \n+     * If cryptographic security is not required,\n      * use <code>nextHexString()</code>.\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      * @param len length of return string\n      * @return the random hex string\n      */\n-    String nextSecureHexString(int len);  \n-    \n-    /**\n-     * Generates a uniformly distributed random integer between \n-     * <code>lower</code> and <code>upper</code> (endpoints included) \n+    String nextSecureHexString(int len);\n+\n+    /**\n+     * Generates a uniformly distributed random integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included)\n      * from a secure random sequence.\n      * <p>\n-     * Sequences of integers generated using this method will be \n-     * cryptographically secure. If cryptographic security is not required, \n-     * <code>nextInt</code> should be used instead of this method. \n+     * Sequences of integers generated using this method will be\n+     * cryptographically secure. If cryptographic security is not required,\n+     * <code>nextInt</code> should be used instead of this method.\n      * <p>\n      * <strong>Definition</strong>:\n      * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n      * Secure Random Sequence</a>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      *\n      * @return a random integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    int nextSecureInt(int lower, int upper);  \n-    \n+    int nextSecureInt(int lower, int upper);\n+\n     /**\n      * Generates a random long integer between <code>lower</code>\n      * and <code>upper</code> (endpoints included).<p>\n-     * Sequences of long values generated using this method will be \n+     * Sequences of long values generated using this method will be\n      * cryptographically secure. If cryptographic security is not required,\n      * <code>nextLong</code> should be used instead of this method.\n      * <p>\n      * Secure Random Sequence</a>\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      *\n      * @return a long integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    long nextSecureLong(long lower, long upper);  \n-    \n-    /** \n-     * Generates a random value from the Poisson distribution with \n+    long nextSecureLong(long lower, long upper);\n+\n+    /**\n+     * Generates a random value from the Poisson distribution with\n      * the given mean.\n      * <p>\n-     * <strong>Definition</strong>: \n+     * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm\">\n      * Poisson Distribution</a>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified mean <i>must</i> be positive (otherwise an \n+     * <li>The specified mean <i>must</i> be positive (otherwise an\n      *     IllegalArgumentException is thrown.)</li>\n      * </ul>\n      * @param mean Mean of the distribution\n      * @return poisson deviate with the specified mean\n      */\n-    long nextPoisson(double mean);  \n-    \n-    /** \n+    long nextPoisson(double mean);\n+\n+    /**\n      * Generates a random value from the\n      * Normal (or Gaussian) distribution with the given mean\n      * and standard deviation.\n      * <p>\n-     * <strong>Definition</strong>: \n+     * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm\">\n      * Normal Distribution</a>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException \n+     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      * @param mu Mean of the distribution\n      * @return random value from Gaussian distribution with mean = mu,\n      * standard deviation = sigma\n      */\n-    double nextGaussian(double mu, double sigma);  \n-    \n+    double nextGaussian(double mu, double sigma);\n+\n     /**\n      * Generates a random value from the exponential distribution\n      * with expected value = <code>mean</code>.\n      * <p>\n-     * <strong>Definition</strong>: \n+     * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm\">\n      * Exponential Distribution</a>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException \n+     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      * @param mean Mean of the distribution\n      * @return random value from exponential distribution\n      */\n-    double nextExponential(double mean);   \n-    \n+    double nextExponential(double mean);\n+\n     /**\n      * Generates a uniformly distributed random value from the open interval\n      * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded).\n      * <p>\n-     * <strong>Definition</strong>: \n+     * <strong>Definition</strong>:\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm\">\n-     * Uniform Distribution</a> <code>lower</code> and \n-     * <code>upper - lower</code> are the \n+     * Uniform Distribution</a> <code>lower</code> and\n+     * <code>upper - lower</code> are the\n      * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm\">\n      * location and scale parameters</a>, respectively.\n      * <p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n      *     is thrown.)</li>\n      * </ul>\n      *\n      * and upper (exclusive)\n      */\n     double nextUniform(double lower, double upper);\n-    \n+\n     /**\n      * Generates an integer array of length <code>k</code> whose entries\n      * are selected randomly, without repetition, from the integers <code>\n-     * 0 through n-1</code> (inclusive). \n+     * 0 through n-1</code> (inclusive).\n      * <p>\n      * Generated arrays represent permutations\n-     * of <code>n</code> taken <code>k</code> at a time. \n+     * of <code>n</code> taken <code>k</code> at a time.\n      * <p>\n      * <strong>Preconditions:</strong><ul>\n      * <li> <code>k <= n</code></li>\n      * </ul>\n      * If the preconditions are not met, an IllegalArgumentException is\n      * thrown.\n-     * \n+     *\n      * @param n domain of the permutation\n      * @param k size of the permutation\n-     * @return random k-permutation of n \n+     * @return random k-permutation of n\n      */\n     int[] nextPermutation(int n, int k);\n-    \n+\n     /**\n      * Returns an array of <code>k</code> objects selected randomly\n-     * from the Collection <code>c</code>. \n+     * from the Collection <code>c</code>.\n      * <p>\n      * Sampling from <code>c</code>\n      * is without replacement; but if <code>c</code> contains identical\n      * objects, the sample may include repeats.  If all elements of <code>\n-     * c</code> are distinct, the resulting object array represents a \n+     * c</code> are distinct, the resulting object array represents a\n      * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000\">\n      * Simple Random Sample</a> of size\n      * <code>k</code> from the elements of <code>c</code>.\n-     * <p>   \n+     * <p>\n      * <strong>Preconditions:</strong><ul>\n      * <li> k must be less than or equal to the size of c </li>\n      * <li> c must not be empty </li>\n      * </ul>\n      * If the preconditions are not met, an IllegalArgumentException is\n      * thrown.\n-     * \n+     *\n      * @param c collection to be sampled\n      * @param k size of the sample\n-     * @return random sample of k elements from c \n+     * @return random sample of k elements from c\n      */\n     Object[] nextSample(Collection c, int k);\n }\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import java.util.Collection;\n \n /**\n- * Implements the <code>RandomData</code> interface using \n- * <code>java.util.Random</code> and \n- * <code>java.util.Random.SecureRandom</code> instances to generate data. \n+ * Implements the <code>RandomData</code> interface using\n+ * <code>java.util.Random</code> and\n+ * <code>java.util.Random.SecureRandom</code> instances to generate data.\n  * <p>\n- * Supports reseeding the underlying \n+ * Supports reseeding the underlying\n  * <a href=\"http://en.wikipedia.org/wiki/Pseudorandom_number_generator\">\n  * PRNG</a>. The <code>SecurityProvider</code> and <code>Algorithm</code>\n  * used by the <code>SecureRandom</code> instance can also be reset.\n  * <p>\n- * For details on the PRNGs, see the JDK documentation for \n- * <code>java.util.Random</code> and \n+ * For details on the PRNGs, see the JDK documentation for\n+ * <code>java.util.Random</code> and\n  * <code>java.util.Random.SecureRandom</code>\n  * <p>\n  * <strong>Usage Notes</strong>: <ul>\n  * <li>\n- * Instance variables are used to maintain <code>Random</code> and \n+ * Instance variables are used to maintain <code>Random</code> and\n  * <code>SecureRandom</code> instances used in data generation. Therefore,\n  * to generate a random sequence of values or strings, you should use just\n  * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n  * the appropriate generator.  If you do not explicitly seed the generator, it\n  * is by default seeded with the current time in milliseconds</li>\n  * <li>\n- * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate \n- * to the corresponding methods on the underlying <code>Random</code> and \n- * <code>SecureRandom</code> instances.  Therefore, the contracts of these \n- * methods are as defined in the JDK documentation.  In particular, \n- * <code>reSeed(long)</code> fully resets the initial state of the non-secure \n- * random number generator (so that reseeding with a specific value always \n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate\n+ * to the corresponding methods on the underlying <code>Random</code> and\n+ * <code>SecureRandom</code> instances.  Therefore, the contracts of these\n+ * methods are as defined in the JDK documentation.  In particular,\n+ * <code>reSeed(long)</code> fully resets the initial state of the non-secure\n+ * random number generator (so that reseeding with a specific value always\n  * results in the same subsequent random sequence); whereas reSeedSecure(long)\n- * does <strong>not</strong> reinitialize the secure random number generator \n- * (so secure sequences started with calls to reseedSecure(long) won't be \n+ * does <strong>not</strong> reinitialize the secure random number generator\n+ * (so secure sequences started with calls to reseedSecure(long) won't be\n  * identical).</li></ul>\n- * \n- * @version $Revision: 1.14 $ $Date: 2004/06/02 00:20:21 $\n+ *\n+ * @version $Revision: 1.15 $ $Date: 2004/06/14 23:15:15 $\n  */\n public class RandomDataImpl implements RandomData, Serializable {\n-    \n+\n     /** Serializable version identifier */\n     static final long serialVersionUID = -626730818244969716L;\n \n     /** underlying random number generator */\n     private Random rand = null;\n-    \n+\n     /** underlying secure random number generator */\n     private SecureRandom secRand = null;\n-    \n+\n     /**\n      * Construct a RandomDataImpl.\n      */\n     public RandomDataImpl() {\n     }\n-          \n-    /**\n-     * <strong>Algorithm Description:</strong> hex strings are generated \n+\n+    /**\n+     * <strong>Algorithm Description:</strong> hex strings are generated\n      * using a 2-step process. <ol>\n      * <li>\n      * len/2+1 binary bytes are generated using the underlying Random</li>\n         if (len <= 0) {\n             throw new IllegalArgumentException(\"length must be positive\");\n         }\n-            \n+\n         //Get a random number generator\n         Random ran = getRan();\n-        \n+\n         //Initialize output buffer\n         StringBuffer outBuffer = new StringBuffer();\n-            \n+\n         //Get int(len/2)+1 random bytes\n         byte[] randomBytes = new byte[(len / 2) + 1];\n         ran.nextBytes(randomBytes);\n- \n+\n         //Convert each byte to 2 hex digits\n         for (int i = 0; i < randomBytes.length; i++) {\n             Integer c = new Integer(randomBytes[i]);\n-                \n+\n             /* Add 128 to byte value to make interval 0-255 before\n              * doing hex conversion.\n              * This guarantees <= 2 hex digits from toHexString()\n              * toHexString would otherwise add 2^32 to negative arguments.\n              */\n              String hex = Integer.toHexString(c.intValue() + 128);\n-                \n+\n              // Make sure we add 2 hex digits for each byte\n              if (hex.length() == 1)  {\n                  hex = \"0\" + hex;\n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n-     */       \n+     */\n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n         Random rand = getRan();\n         return lower + (int) (rand.nextDouble() * (upper - lower + 1));\n     }\n-    \n+\n     /**\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.\n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n-     */       \n+     */\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n         Random rand = getRan();\n         return lower + (long) (rand.nextDouble() * (upper - lower + 1));\n     }\n-    \n+\n      /**\n-     * <strong>Algorithm Description:</strong> hex strings are generated in \n+     * <strong>Algorithm Description:</strong> hex strings are generated in\n      * 40-byte segments using a 3-step process. <ol>\n      * <li>\n-     * 20 random bytes are generated using the underlying \n+     * 20 random bytes are generated using the underlying\n      * <code>SecureRandom</code>.</li>\n      * <li>\n      * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n      * <li>\n      * Each byte of the binary digest is converted to 2 hex digits</li></ol>\n      * <p>\n-     * TODO: find external reference or provide justification for the claim \n+     * TODO: find external reference or provide justification for the claim\n      * that this yields a cryptographically secure sequence of hex strings.\n      * @param len the desired string length.\n      * @return the random string.\n         if (len <= 0) {\n             throw new IllegalArgumentException(\"length must be positive\");\n         }\n-       \n+\n        // Get SecureRandom and setup Digest provider\n        SecureRandom secRan = getSecRan();\n        MessageDigest alg = null;\n        } catch (NoSuchAlgorithmException ex) {\n            return null; // gulp FIXME? -- this *should* never fail.\n        }\n-       alg.reset(); \n-       \n+       alg.reset();\n+\n        //Compute number of iterations required (40 bytes each)\n        int numIter = (len / 40) + 1;\n-       \n+\n        StringBuffer outBuffer = new StringBuffer();\n        for (int iter = 1; iter < numIter + 1; iter++) {\n             byte[] randomBytes = new byte[40];\n             secRan.nextBytes(randomBytes);\n             alg.update(randomBytes);\n-    \n+\n             //Compute hash -- will create 20-byte binary hash\n             byte hash[] = alg.digest();\n-            \n+\n             //Loop over the hash, converting each byte to 2 hex digits\n             for (int i = 0; i < hash.length; i++) {\n                 Integer c = new Integer(hash[i]);\n-        \n+\n                 /* Add 128 to byte value to make interval 0-255\n                  * This guarantees <= 2 hex digits from toHexString()\n-                 * toHexString would otherwise add 2^32 to negative \n+                 * toHexString would otherwise add 2^32 to negative\n                  * arguments\n                  */\n                 String hex = Integer.toHexString(c.intValue() + 128);\n-                    \n+\n                //Keep strings uniform length -- guarantees 40 bytes\n                 if (hex.length() == 1) {\n                     hex = \"0\" + hex;\n         }\n         return outBuffer.toString().substring(0, len);\n     }\n-     \n+\n     /**\n      * Generate a random int value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n-     */       \n+     */\n     public int nextSecureInt(int lower, int upper) {\n           if (lower >= upper) {\n               throw new IllegalArgumentException\n           SecureRandom sec = getSecRan();\n           return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n     }\n-     \n+\n     /**\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n-     */       \n+     */\n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n         SecureRandom sec = getSecRan();\n         return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n     }\n-    \n-    /** \n+\n+    /**\n      * Generates a random long value from the Poisson distribution with the given mean.\n      * <p>\n      * <strong>Algorithm Description</strong>:\n-     * Uses simulation of a Poisson process using Uniform deviates, as \n-     * described \n+     * Uses simulation of a Poisson process using Uniform deviates, as\n+     * described\n      * <a href =\"http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm\">\n      * here.</a>\n-     * <p>  \n+     * <p>\n      * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n      * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n         double r = 1.0d;\n         double rnd = 1.0d;\n         Random rand = getRan();\n-        while (n < 1000 * mean) {     \n+        while (n < 1000 * mean) {\n             rnd = rand.nextDouble();\n             r = r * rnd;\n             if (r >= p) {\n         }\n         return n;\n     }\n-    \n-    /**\n-     * Generate a random value from a Normal distribution.  This algorithm \n+\n+    /**\n+     * Generate a random value from a Normal distribution.  This algorithm\n      * generates random values for the general Normal distribution with the\n      * given mean, <code>mu</code> and the given standard deviation,\n      * <code>sigma</code>.\n         Random rand = getRan();\n         return sigma * rand.nextGaussian() + mu;\n     }\n-    \n-    /**\n-     * <strong>Algorithm Description</strong>:  Uses the \n-     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> \n+\n+    /**\n+     * <strong>Algorithm Description</strong>:  Uses the\n+     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\">\n      * Inversion Method</a> to generate exponential from uniform deviates.\n      * @param mean the mean of the distribution.\n      * @return the random Exponential value.\n         }\n         return -mean * Math.log(unif);\n     }\n-    \n-    /**\n-     * <strong>Algorithm Description</strong>: scales the output of \n+\n+    /**\n+     * <strong>Algorithm Description</strong>: scales the output of\n      * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n-     * random double if Random.nextDouble() returns 0). \n-     * This is necessary to provide a symmetric output interval \n+     * random double if Random.nextDouble() returns 0).\n+     * This is necessary to provide a symmetric output interval\n      * (both endpoints excluded).\n      * @param lower the lower bound.\n      * @param upper the upper bound.\n             (\"lower bound must be <= upper bound\");\n         }\n         Random rand = getRan();\n-        \n+\n         // insure nextDouble() isn't 0.0\n         double u = rand.nextDouble();\n         while(u <= 0.0){\n             u = rand.nextDouble();\n         }\n-        \n+\n         return lower + u * (upper - lower);\n     }\n-    \n-    /** \n+\n+    /**\n      * Returns the static Random used to generate random data.\n      * <p>\n      * Creates and initializes if null.\n-     * \n+     *\n      * @return the static Random used to generate random data\n      */\n     private Random getRan() {\n         }\n         return rand;\n     }\n-    \n-    /** \n+\n+    /**\n      * Returns the static SecureRandom used to generate secure random data.\n      * <p>\n      * Creates and initializes if null.\n         }\n         return secRand;\n     }\n-    \n+\n     /**\n      * Reseeds the random number generator with the supplied seed.\n      * <p>\n         }\n         rand.setSeed(seed);\n     }\n-    \n+\n     /**\n      * Reseeds the secure random number generator with the current time\n-     * in milliseconds. \n-     * <p> \n+     * in milliseconds.\n+     * <p>\n      * Will create and initialize if null.\n      */\n     public void reSeedSecure() {\n         }\n         secRand.setSeed(System.currentTimeMillis());\n     }\n-    \n+\n     /**\n      * Reseeds the secure random number generator with the supplied seed.\n      * <p>\n         }\n         secRand.setSeed(seed);\n     }\n-    \n+\n     /**\n      * Reseeds the random number generator with the current time\n      * in milliseconds.\n         }\n         rand.setSeed(System.currentTimeMillis());\n     }\n-    \n+\n     /**\n      * Sets the PRNG algorithm for the underlying SecureRandom instance\n-     * using the Security Provider API.  The Security Provider API is defined in \n+     * using the Security Provider API.  The Security Provider API is defined in\n      * <a href=\"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n      * Java Cryptography Architecture API Specification & Reference.</a>\n      * <p>\n-     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i> \n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n      * overhead and may take several seconds to execute.\n      * </p>\n      *\n      * @param algorithm the name of the PRNG algorithm\n-     * @param provider the name of the provider \n-     * @throws NoSuchAlgorithmException if the specified algorithm \n+     * @param provider the name of the provider\n+     * @throws NoSuchAlgorithmException if the specified algorithm\n      * is not available\n-     * @throws NoSuchProviderException if the specified provider \n+     * @throws NoSuchProviderException if the specified provider\n      * is not installed\n      */\n-    public void setSecureAlgorithm(String algorithm, String provider) \n+    public void setSecureAlgorithm(String algorithm, String provider)\n         throws NoSuchAlgorithmException, NoSuchProviderException {\n         secRand = SecureRandom.getInstance(algorithm, provider);\n     }\n-    \n+\n     /**\n      * Uses a 2-cycle permutation shuffle to generate a random permutation.\n      * The shuffling process is described\n         if (k > n) {\n             throw new IllegalArgumentException\n                 (\"permutation k exceeds n\");\n-        }       \n+        }\n         if (k == 0) {\n             throw new IllegalArgumentException\n                 (\"permutation k must be > 0\");\n         }\n-        \n+\n         int[] index = getNatural(n);\n         shuffle(index, n - k);\n         int[] result = new int[k];\n         for (int i = 0; i < k; i++) {\n             result[i] = index[n - i - 1];\n         }\n-  \n+\n         return result;\n     }\n-    \n+\n     /**\n      * Uses a 2-cycle permutation shuffle to generate a random permutation.\n-     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation \n-     * shuffle to generate a random permutation of <code>c.size()</code> and \n-     * then returns the elements whose indexes correspond to the elements of \n-     * the generated permutation.  \n-     * This technique is described, and proven to generate random samples, \n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n+     * shuffle to generate a random permutation of <code>c.size()</code> and\n+     * then returns the elements whose indexes correspond to the elements of\n+     * the generated permutation.\n+     * This technique is described, and proven to generate random samples,\n      * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>\n      * @param c Collection to sample from.\n      * @param k sample size.\n      * @return the random sample.\n-     */ \n+     */\n     public Object[] nextSample(Collection c, int k) {\n         int len = c.size();\n         if (k > len) {\n             throw new IllegalArgumentException\n                 (\"sample size must be > 0\");\n         }\n-            \n+\n        Object[] objects = c.toArray();\n        int[] index = nextPermutation(len, k);\n        Object[] result = new Object[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = objects[index[i]];\n-       }  \n+       }\n        return result;\n     }\n-    \n+\n     //------------------------Private methods----------------------------------\n-    \n-    /** \n+\n+    /**\n      * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n      * of list.\n-     * \n+     *\n      * @param list list to be shuffled\n      * @param end element past which shuffling begins\n      */\n         int target = 0;\n         for (int i = list.length - 1 ; i >= end; i--) {\n             if (i == 0) {\n-                target = 0; \n+                target = 0;\n             } else {\n                 target = nextInt(0, i);\n             }\n             int temp = list[target];\n             list[target] = list[i];\n             list[i] = temp;\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Returns an array representing n.\n      *\n         }\n         return natural;\n     }\n-        \n+\n }\n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Generates values for use in simulation applications.\n  * <p>\n  * How values are generated is determined by the <code>mode</code>\n- * property. \n- * <p> \n+ * property.\n+ * <p>\n  * Supported <code>mode</code> values are: <ul>\n  * <li> DIGEST_MODE -- uses an empirical distribution </li>\n- * <li> REPLAY_MODE -- replays data from <code>valuesFileURL</code></li> \n+ * <li> REPLAY_MODE -- replays data from <code>valuesFileURL</code></li>\n  * <li> UNIFORM_MODE -- generates uniformly distributed random values with\n  *                      mean = <code>mu</code> </li>\n  * <li> EXPONENTIAL_MODE -- generates exponentially distributed random values\n  *                         with mean = <code>mu</code></li>\n  * <li> GAUSSIAN_MODE -- generates Gaussian distributed random values with\n- *                       mean = <code>mu</code> and \n+ *                       mean = <code>mu</code> and\n  *                       standard deviation = <code>sigma</code></li>\n- * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul> \n- *\n- * @version $Revision: 1.12 $ $Date: 2004/02/21 21:35:15 $\n+ * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul>\n+ *\n+ * @version $Revision: 1.13 $ $Date: 2004/06/14 23:15:15 $\n  *\n  */\n public class ValueServer implements Serializable {\n     /** mode determines how values are generated */\n     private int mode = 5;\n-    \n+\n     /** URI to raw data values  */\n     private URL valuesFileURL = null;\n-    \n+\n     /** Mean for use with non-data-driven modes */\n     private double mu = 0.0;\n-    \n+\n     /** Standard deviation for use with GAUSSIAN_MODE */\n     private double sigma = 0.0;\n-    \n+\n     /** Empirical probability distribution for use with DIGEST_MODE */\n     private EmpiricalDistribution empiricalDistribution = null;\n-    \n+\n     /** file pointer for REPLAY_MODE */\n     private BufferedReader filePointer = null;\n-    \n+\n     /** RandomDataImpl to use for random data generation */\n     private RandomDataImpl randomData = new RandomDataImpl();\n-    \n+\n     // Data generation modes ======================================\n-   \n+\n     /** Use empirical distribution  */\n-    public static final int DIGEST_MODE = 0;        \n-    \n+    public static final int DIGEST_MODE = 0;\n+\n     /** Replay data from valuesFilePath */\n-    public static final int REPLAY_MODE = 1;      \n-    \n+    public static final int REPLAY_MODE = 1;\n+\n     /** Uniform random deviates with mean = mu */\n-    public static final int UNIFORM_MODE = 2;    \n-    \n+    public static final int UNIFORM_MODE = 2;\n+\n     /** Exponential random deviates with mean = mu */\n-    public static final int EXPONENTIAL_MODE = 3;  \n-    \n+    public static final int EXPONENTIAL_MODE = 3;\n+\n     /** Gaussian random deviates with mean = mu, std dev = sigma */\n-    public static final int GAUSSIAN_MODE = 4;  \n-    \n+    public static final int GAUSSIAN_MODE = 4;\n+\n     /** Always return mu */\n-    public static final int CONSTANT_MODE = 5;   \n-    \n+    public static final int CONSTANT_MODE = 5;\n+\n     /** Creates new ValueServer */\n     public ValueServer() {\n     }\n \n-    /** \n+    /**\n      * Returns the next generated value, generated according\n-     * to the mode value (see MODE constants). \n-     *\n-     * @return generated value \n+     * to the mode value (see MODE constants).\n+     *\n+     * @return generated value\n      * @throws IOException in REPLAY_MODE if a file I/O error occurs\n      */\n     public double getNext() throws IOException {\n                        (\"Bad mode: \" + mode);\n         }\n     }\n-    \n+\n     /**\n      * Fills the input array with values generated using getNext() repeatedly.\n      *\n             values[i] = getNext();\n         }\n     }\n-    \n-    /**\n-     * Returns an array of length <code>length</code> with values generated \n+\n+    /**\n+     * Returns an array of length <code>length</code> with values generated\n      * using getNext() repeatedly.\n      *\n      * @param length length of output array\n             out[i] = getNext();\n         }\n         return out;\n-    }       \n-    \n-    /** \n+    }\n+\n+    /**\n      * Computes the empirical distribution using values from the file\n      * in <code>valuesFileURL</code>, using the default number of bins.\n      * <p>\n         empiricalDistribution = new EmpiricalDistributionImpl();\n         empiricalDistribution.load(valuesFileURL);\n     }\n-    \n-    /** \n+\n+    /**\n      * Computes the empirical distribution using values from the file\n      * in <code>valuesFileURL</code> and <code>binCount</code> bins.\n      * <p>\n      * distribution\n      * @throws IOException if an error occurs reading the input file\n      */\n-    public void computeDistribution(int binCount) \n+    public void computeDistribution(int binCount)\n             throws IOException {\n         empiricalDistribution = new EmpiricalDistributionImpl(binCount);\n         empiricalDistribution.load(valuesFileURL);\n         mu = empiricalDistribution.getSampleStats().getMean();\n         sigma = empiricalDistribution.getSampleStats().getStandardDeviation();\n     }\n-    \n+\n     /** Getter for property mode.\n      * @return Value of property mode.\n      */\n     public int getMode() {\n         return mode;\n     }\n-    \n+\n     /** Setter for property mode.\n      * @param mode New value of property mode.\n      */\n     public void setMode(int mode) {\n         this.mode = mode;\n     }\n-    \n+\n     /**\n      * Getter for <code>valuesFileURL<code>\n      * @return Value of property valuesFileURL.\n     public URL getValuesFileURL() {\n         return valuesFileURL;\n     }\n-    \n+\n     /**\n      * Sets the <code>valuesFileURL</code> using a string URL representation\n      * @param url String representation for new valuesFileURL.\n     public void setValuesFileURL(String url) throws MalformedURLException {\n         this.valuesFileURL = new URL(url);\n     }\n-    \n+\n     /**\n      * Sets the <code>valuesFileURL</code>\n      * @param url New value of property valuesFileURL.\n     public void setValuesFileURL(URL url) {\n         this.valuesFileURL = url;\n     }\n-    \n+\n     /** Getter for property empiricalDistribution.\n      * @return Value of property empiricalDistribution.\n      */\n     public EmpiricalDistribution getEmpiricalDistribution() {\n         return empiricalDistribution;\n-    }    \n-    \n-    /**  \n+    }\n+\n+    /**\n      * Opens <code>valuesFileURL</code> to use in REPLAY_MODE.\n      *\n      * @throws IOException if an error occurs opening the file\n     public void openReplayFile() throws IOException {\n         resetReplayFile();\n     }\n-    \n-    /**  \n+\n+    /**\n      * Resets REPLAY_MODE file pointer to the beginning of the <code>valuesFileURL</code>.\n      *\n      * @throws IOException if an error occurs opening the file\n         }\n         filePointer = new BufferedReader(new InputStreamReader(valuesFileURL.openStream()));\n     }\n-    \n-    /** \n+\n+    /**\n      * Closes <code>valuesFileURL</code> after use in REPLAY_MODE.\n      *\n      * @throws IOException if an error occurs closing the file\n         if (filePointer != null) {\n             filePointer.close();\n             filePointer = null;\n-        }     \n-    }\n-    \n+        }\n+    }\n+\n     /** Getter for property mu.\n      * @return Value of property mu.\n      */\n     public double getMu() {\n         return mu;\n     }\n-    \n+\n     /** Setter for property mu.\n      * @param mu New value of property mu.\n      */\n     public void setMu(double mu) {\n         this.mu = mu;\n     }\n-    \n+\n     /** Getter for property sigma.\n      * @return Value of property sigma.\n      */\n     public double getSigma() {\n         return sigma;\n     }\n-    \n+\n     /** Setter for property sigma.\n      * @param sigma New value of property sigma.\n      */\n     public void setSigma(double sigma) {\n         this.sigma = sigma;\n     }\n-    \n+\n     //------------- private methods ---------------------------------\n-    \n-    /** \n+\n+    /**\n      * Gets a random value in DIGEST_MODE.\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>Before this method is called, <code>computeDistribution()</code>\n-     * must have completed successfully; otherwise an \n+     * must have completed successfully; otherwise an\n      * <code>IllegalStateException</code> will be thrown</li></ul>\n      *\n-     * @return next random value from the empirical distribution digest \n+     * @return next random value from the empirical distribution digest\n      */\n     private double getNextDigest() {\n         if ((empiricalDistribution == null) ||\n             (empiricalDistribution.getBinStats().size() == 0)) {\n             throw new IllegalStateException(\"Digest not initialized\");\n         }\n-        return empiricalDistribution.getNextValue();     \n-    }\n-    \n+        return empiricalDistribution.getNextValue();\n+    }\n+\n     /**\n      * Gets next sequential value from the <code>valuesFileURL</code>.\n      * <p>\n      * Throws an IOException if the read fails.\n      * <p>\n-     * This method will open the <code>valuesFileURL</code> if there is no \n+     * This method will open the <code>valuesFileURL</code> if there is no\n      * replay file open.\n      * <p>\n-     * The <code>valuesFileURL</code> will be closed and reopened to wrap around \n+     * The <code>valuesFileURL</code> will be closed and reopened to wrap around\n      * from EOF to BOF if EOF is encountered.\n      *\n      * @return next value from the replay file\n             closeReplayFile();\n             resetReplayFile();\n             str = filePointer.readLine();\n-        }         \n+        }\n         return new Double(str).doubleValue();\n     }\n-    \n-    /** \n-     * Gets a uniformly distributed random value with mean = mu. \n+\n+    /**\n+     * Gets a uniformly distributed random value with mean = mu.\n      *\n      * @return random uniform value\n      */\n     private double getNextUniform() {\n         return randomData.nextUniform(0, 2 * mu);\n     }\n-    \n-    /** \n-     * Gets an exponentially distributed random value with mean = mu. \n+\n+    /**\n+     * Gets an exponentially distributed random value with mean = mu.\n      *\n      * @return random exponential value\n      */\n     private double getNextExponential() {\n-        return randomData.nextExponential(mu);    \n-    }\n-    \n-    /** \n+        return randomData.nextExponential(mu);\n+    }\n+\n+    /**\n      * Gets a Gaussian distributed random value with mean = mu\n      * and standard deviation = sigma.\n      *\n     private double getNextGaussian() {\n         return randomData.nextGaussian(mu, sigma);\n     }\n-    \n+\n }", "timestamp": 1087254915, "metainfo": ""}