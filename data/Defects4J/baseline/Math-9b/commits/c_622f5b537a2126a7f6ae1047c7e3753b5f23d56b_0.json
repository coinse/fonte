{"sha": "622f5b537a2126a7f6ae1047c7e3753b5f23d56b", "log": "MATH-447 Made all new exception classes inherit from \"MathRuntimeException\". Changed accordingly all tests that relied on catching the standard Java exception (e.g. \"MathIllegalArgumentEception\" is not a subclass of \"IllegalArgumentEception\" anymore). Replaced occurrences of the old \"MathRuntimeException\" by the appropriate exception from the \"exception\" package (MATH-459).    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.util.MathUtils;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.util.MathUtils;\n \n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n                                                           final double[][] fval)\n-        throws MathException, IllegalArgumentException {\n+        throws MathException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NoDataException;\n \n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n     }\n \n     /**\n-     * Formats a object to produce a string.  <code>obj</code> must be either a\n+     * Formats a object to produce a string.  {@code obj} must be either a\n      * {@link Complex} object or a {@link Number} object.  Any other type of\n      * object will result in an {@link IllegalArgumentException} being thrown.\n      *\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     * @throws IllegalArgumentException is {@code obj} is not a valid type.\n      */\n     @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                 toAppendTo, pos);\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX,\n-                  obj.getClass().getName());\n+            throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX,\n+                                                   obj.getClass().getName());\n         }\n \n         return ret;\n     /**\n      * Modify the imaginaryCharacter.\n      * @param imaginaryCharacter The new imaginaryCharacter value.\n-     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n-     *         <code>null</code> or an empty string.\n+     * @throws NullArgumentException if {@code imaginaryCharacter} is\n+     * {@code null}.\n+     * @throws NoDataException if {@code imaginaryCharacter} is an\n+     * empty string.\n      */\n     public void setImaginaryCharacter(String imaginaryCharacter) {\n-        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.EMPTY_STRING_FOR_IMAGINARY_CHARACTER);\n+        if (imaginaryCharacter == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (imaginaryCharacter.length() == 0) {\n+            throw new NoDataException();\n         }\n         this.imaginaryCharacter = imaginaryCharacter;\n     }\n         }\n         this.realFormat = realFormat;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n      * @param x0 the (inclusive) lower bound\n      * @param x1 the (inclusive) upper bound\n      * @return the probability that a random variable with this distribution\n-     * will take a value between <code>x0</code> and <code>x1</code>,\n+     * will take a value between {@code x0} and {@code x1},\n      * including the endpoints.\n      * @throws MathException if the cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     * @throws NumberIsTooLargeException if {@code x0 > x1}\n      */\n     public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n         if (x0 > x1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                  x0, x1);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n         throws MathException {\n         if (x1 < x0) {\n             throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                                                x0, x1, true);\n+                                                x1, x0, true);\n         }\n         if (FastMath.floor(x0) < x0) {\n             return cumulativeProbability(((int) FastMath.floor(x0)) + 1,\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n         if (x1 < x0) {\n             throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n-                                                x0, x1, true);\n+                                                x1, x0, true);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        if (FastMath.abs(dev) > 40 * standardDeviation) { \n+        if (FastMath.abs(dev) > 40 * standardDeviation) {\n             return dev < 0 ? 0.0d : 1.0d;\n         }\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n+        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * FastMath.sqrt(2))));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java\n  */\n package org.apache.commons.math.exception;\n \n-import java.util.Locale;\n-\n-import org.apache.commons.math.exception.util.ArgUtils;\n-import org.apache.commons.math.exception.util.MessageFactory;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n  * @since 3.0\n  * @version $Revision$ $Date$\n  */\n-public class MathArithmeticException extends ArithmeticException {\n-\n+public class MathArithmeticException extends MathRuntimeException {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n-\n-    /**\n-     * Pattern used to build the message (specific context).\n-     */\n-    private final Localizable specific;\n-    /**\n-     * Arguments used to build the message.\n-     */\n-    private final Object[] arguments;\n \n     /**\n      * @param args Arguments.\n      */\n     public MathArithmeticException(Localizable specific,\n                                    Object ... args) {\n-        this.specific = specific;\n-        arguments = ArgUtils.flatten(args);\n-    }\n-\n-    /**\n-     * Get the message in a specified locale.\n-     *\n-     * @param locale Locale in which the message should be translated.\n-     *\n-     * @return the localized message.\n-     */\n-    public String getMessage(final Locale locale) {\n-        return MessageFactory.buildMessage(locale,\n-                                           specific,\n-                                           LocalizedFormats.UNSUPPORTED_OPERATION,\n-                                           arguments);\n-    }\n-\n-   /** {@inheritDoc} */\n-    @Override\n-    public String getMessage() {\n-        return getMessage(Locale.US);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        super(null, specific, LocalizedFormats.ARITHMETIC_EXCEPTION, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java\n  */\n package org.apache.commons.math.exception;\n \n-import java.util.Locale;\n-\n-import org.apache.commons.math.exception.util.ArgUtils;\n-import org.apache.commons.math.exception.util.MessageFactory;\n import org.apache.commons.math.exception.util.Localizable;\n \n /**\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class MathIllegalArgumentException extends IllegalArgumentException implements MathThrowable {\n-\n+public class MathIllegalArgumentException extends MathRuntimeException {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n-\n-    /**\n-     * Pattern used to build the message (specific context).\n-     */\n-    private final Localizable specific;\n-    /**\n-     * Pattern used to build the message (general problem description).\n-     */\n-    private final Localizable general;\n-    /**\n-     * Arguments used to build the message.\n-     */\n-    private final Object[] arguments;\n \n     /**\n      * @param specific Message pattern providing the specific context of\n     public MathIllegalArgumentException(Localizable specific,\n                                         Localizable general,\n                                         Object ... args) {\n-        this.specific = specific;\n-        this.general = general;\n-        arguments = ArgUtils.flatten(args);\n+        super(null, specific, general, args);\n     }\n     /**\n      * @param general Message pattern explaining the cause of the error.\n                                         Object ... args) {\n         this(null, general, args);\n     }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return specific;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return general;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n-    }\n-\n-    /**\n-     * Get the message in a specified locale.\n-     *\n-     * @param locale Locale in which the message should be translated.\n-     * @return the localized message.\n-     */\n-    public String getMessage(final Locale locale) {\n-        return MessageFactory.buildMessage(locale, specific, general, arguments);\n-    }\n-\n-   /** {@inheritDoc} */\n-    @Override\n-    public String getMessage() {\n-        return getMessage(Locale.US);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java\n  */\n package org.apache.commons.math.exception;\n \n-import java.util.Locale;\n-\n-import org.apache.commons.math.exception.util.ArgUtils;\n-import org.apache.commons.math.exception.util.MessageFactory;\n import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * Base class for all exceptions that signal a mismatch between the\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class MathIllegalStateException extends IllegalStateException implements MathThrowable {\n-\n+public class MathIllegalStateException extends MathRuntimeException {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n-\n-    /**\n-     * Pattern used to build the message (specific context).\n-     */\n-    private final Localizable specific;\n-    /**\n-     * Pattern used to build the message (general problem description).\n-     */\n-    private final Localizable general;\n-    /**\n-     * Arguments used to build the message.\n-     */\n-    private final Object[] arguments;\n \n     /**\n      * @param specific Message pattern providing the specific context of\n     public MathIllegalStateException(Localizable specific,\n                                      Localizable general,\n                                      Object ... args) {\n-        this.specific = specific;\n-        this.general = general;\n-        arguments = ArgUtils.flatten(args);\n+        super(null, specific, general, args);\n     }\n     /**\n-     * @param general Message pattern explaining the cause of the error.\n+     * @param specific Message pattern explaining the cause of the error.\n      * @param args Arguments.\n      */\n-    public MathIllegalStateException(Localizable general,\n+    public MathIllegalStateException(Localizable specific,\n                                      Object ... args) {\n-        this(null, general, args);\n+        this(specific, LocalizedFormats.ILLEGAL_STATE, args);\n     }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return specific;\n+    /**\n+     * @param args Arguments.\n+     */\n+    public MathIllegalStateException(Object ... args) {\n+        this(null, args);\n     }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return general;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n-    }\n-\n-    /**\n-     * Get the message in a specified locale.\n-     *\n-     * @param locale Locale in which the message should be translated.\n-     *\n-     * @return the localized message.\n-     */\n-    public String getMessage(final Locale locale) {\n-        return MessageFactory.buildMessage(locale, specific, general, arguments);\n-    }\n-\n-   /** {@inheritDoc} */\n-    @Override\n-    public String getMessage() {\n-        return getMessage(Locale.US);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/exception/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathRuntimeException.java\n import org.apache.commons.math.exception.util.MessageFactory;\n \n /**\n- * This class is intended as a base class for exceptions that must wrap\n- * low-level exceptions in order to propagate an exception that better\n- * corresponds to the high-level action that triggered the problem.\n+ * This class is primarily intended as a base class for exceptions\n+ * that must wrap low-level exceptions in order to propagate an\n+ * exception that better corresponds to the high-level action that\n+ * triggered the problem.\n  *\n  * @since 3.0\n  * @version $Revision$ $Date$\n     private final Object[] arguments;\n \n     /**\n-     * Builds an exception from two patterns (specific and general) and\n+     * Build an exception from two patterns (specific and general) and\n      * an argument list.\n      *\n      * @param cause Cause of the error (may be null).\n      * @param arguments Format arguments. They will be substituted in\n      * <em>both</em> the {@code general} and {@code specific} format specifiers.\n      */\n-    protected MathRuntimeException(final Throwable cause,\n-                                   final Localizable specific,\n-                                   final Localizable general,\n-                                   final Object ... arguments) {\n+    public MathRuntimeException(final Throwable cause,\n+                                final Localizable specific,\n+                                final Localizable general,\n+                                final Object ... arguments) {\n         super(cause);\n         this.specific = specific;\n         this.general = general;\n         this.arguments = ArgUtils.flatten(arguments);\n+    }\n+\n+    /**\n+     * Wrap an exception.\n+     *\n+     * @param cause Cause of the error (may be null).\n+     */\n+    public MathRuntimeException(final Throwable cause) {\n+        this(cause, null, null);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/exception/MathUnsupportedOperationException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathUnsupportedOperationException.java\n  */\n package org.apache.commons.math.exception;\n \n-import java.util.Locale;\n-\n-import org.apache.commons.math.exception.util.ArgUtils;\n-import org.apache.commons.math.exception.util.MessageFactory;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class MathUnsupportedOperationException extends UnsupportedOperationException implements MathThrowable {\n-\n+public class MathUnsupportedOperationException extends MathRuntimeException {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -6024911025449780478L;\n-\n-    /**\n-     * Pattern used to build the message (specific context).\n-     */\n-    private final Localizable specific;\n-    /**\n-     * Arguments used to build the message.\n-     */\n-    private final Object[] arguments;\n \n     /**\n      * @param args Arguments.\n      */\n     public MathUnsupportedOperationException(Localizable specific,\n                                              Object ... args) {\n-        this.specific = specific;\n-        arguments = ArgUtils.flatten(args);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getSpecificPattern() {\n-        return specific;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Localizable getGeneralPattern() {\n-        return LocalizedFormats.UNSUPPORTED_OPERATION;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public Object[] getArguments() {\n-        return arguments.clone();\n-    }\n-\n-    /**\n-     * Get the message in a specified locale.\n-     *\n-     * @param locale Locale in which the message should be translated.\n-     *\n-     * @return the localized message.\n-     */\n-    public String getMessage(final Locale locale) {\n-        return MessageFactory.buildMessage(locale,\n-                                           specific,\n-                                           LocalizedFormats.UNSUPPORTED_OPERATION,\n-                                           arguments);\n-    }\n-\n-   /** {@inheritDoc} */\n-    @Override\n-    public String getMessage() {\n-        return getMessage(Locale.US);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public String getLocalizedMessage() {\n-        return getMessage(Locale.getDefault());\n+        super(null, specific, LocalizedFormats.UNSUPPORTED_OPERATION, args);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     UNPARSEABLE_REAL_VECTOR(\"unparseable real vector: \\\"{0}\\\"\"),\n     UNSUPPORTED_EXPANSION_MODE(\"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\"),\n     UNSUPPORTED_OPERATION(\"unsupported operation\"), /* keep */\n+    ARITHMETIC_EXCEPTION(\"arithmetic exception\"), /* keep */\n+    ILLEGAL_STATE(\"illegal state\"), /* keep */\n     USER_EXCEPTION(\"exception generated in user code\"), /* keep */\n     URL_CONTAINS_NO_DATA(\"URL {0} contains no data\"),\n     VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC(\"{0} values have been added before statistic is configured\"),\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n import java.math.BigInteger;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n      * </p>\n      * @param value the double value to convert to a fraction.\n      * @param epsilon maximum error allowed.  The resulting fraction is within\n-     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     *        {@code epsilon} of {@code value}, in absolute terms.\n      * @param maxIterations maximum number of convergents\n      * @throws FractionConversionException if the continued fraction failed to\n      *         converge.\n      *\n      * @param value the double value to convert to a fraction.\n      * @param epsilon maximum error allowed.  The resulting fraction is within\n-     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     *        {@code epsilon} of {@code value}, in absolute terms.\n      * @param maxDenominator maximum denominator value allowed.\n      * @param maxIterations maximum number of convergents\n      * @throws FractionConversionException if the continued fraction failed to\n      * reduced to lowest terms.\n      * @param num the numerator.\n      * @param den the denominator.\n-     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     * @throws MathArithmeticException if the denominator is {@code zero}\n      */\n     public Fraction(int num, int den) {\n         if (den == 0) {\n-            throw MathRuntimeException.createArithmeticException(\n-                  LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, num, den);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n+                                              num, den);\n         }\n         if (den < 0) {\n-            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n-                throw MathRuntimeException.createArithmeticException(\n-                      LocalizedFormats.OVERFLOW_IN_FRACTION, num, den);\n+            if (num == Integer.MIN_VALUE ||\n+                den == Integer.MIN_VALUE) {\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n+                                                  num, den);\n             }\n             num = -num;\n             den = -den;\n      */\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n-            throw MathRuntimeException.createArithmeticException(\n-                  LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n         }\n         return new Fraction(-numerator, denominator);\n     }\n      * <p>Adds the value of this fraction to another, returning the result in reduced form.\n      * The algorithm follows Knuth, 4.5.1.</p>\n      *\n-     * @param fraction  the fraction to add, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n+     * @param fraction  the fraction to add, must not be {@code null}\n+     * @return a {@code Fraction} instance with the resulting values\n+     * @throws NullArgumentException if the fraction is {@code null}\n+     * @throws MathArithmeticException if the resulting numerator or denominator exceeds\n+     *  {@code Integer.MAX_VALUE}\n      */\n     public Fraction add(Fraction fraction) {\n         return addSub(fraction, true /* add */);\n      * <p>Subtracts the value of another fraction from the value of this one,\n      * returning the result in reduced form.</p>\n      *\n-     * @param fraction  the fraction to subtract, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator\n-     *   cannot be represented in an <code>int</code>.\n+     * @param fraction  the fraction to subtract, must not be {@code null}\n+     * @return a {@code Fraction} instance with the resulting values\n+     * @throws NullArgumentException if the fraction is {@code null}\n+     * @throws MathArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an {@code int}.\n      */\n     public Fraction subtract(Fraction fraction) {\n         return addSub(fraction, false /* subtract */);\n     /**\n      * Implement add and subtract using algorithm described in Knuth 4.5.1.\n      *\n-     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param fraction the fraction to subtract, must not be {@code null}\n      * @param isAdd true to add, false to subtract\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator\n-     *   cannot be represented in an <code>int</code>.\n+     * @return a {@code Fraction} instance with the resulting values\n+     * @throws NullArgumentException if the fraction is {@code null}\n+     * @throws MathArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an {@code int}.\n      */\n     private Fraction addSub(Fraction fraction, boolean isAdd) {\n         if (fraction == null) {\n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n-                                                                 w);\n+            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n+                                              w);\n         }\n         return new Fraction (w.intValue(),\n                 MathUtils.mulAndCheck(denominator/d1,\n      * <p>Multiplies the value of this fraction by another, returning the\n      * result in reduced form.</p>\n      *\n-     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n+     * @param fraction  the fraction to multiply by, must not be {@code null}\n+     * @return a {@code Fraction} instance with the resulting values\n+     * @throws NullArgumentException if the fraction is {@code null}\n+     * @throws MathArithmeticException if the resulting numerator or denominator exceeds\n+     *  {@code Integer.MAX_VALUE}\n      */\n     public Fraction multiply(Fraction fraction) {\n         if (fraction == null) {\n     /**\n      * <p>Divide the value of this fraction by another.</p>\n      *\n-     * @param fraction  the fraction to divide by, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the fraction to divide by is zero\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n+     * @param fraction  the fraction to divide by, must not be {@code null}\n+     * @return a {@code Fraction} instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is {@code null}\n+     * @throws MathArithmeticException if the fraction to divide by is zero\n+     * @throws MathArithmeticException if the resulting numerator or denominator exceeds\n+     *  {@code Integer.MAX_VALUE}\n      */\n     public Fraction divide(Fraction fraction) {\n         if (fraction == null) {\n             throw new NullArgumentException(LocalizedFormats.FRACTION);\n         }\n         if (fraction.numerator == 0) {\n-            throw MathRuntimeException.createArithmeticException(\n-                    LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n-                    fraction.numerator, fraction.denominator);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n+                                              fraction.numerator, fraction.denominator);\n         }\n         return multiply(fraction.reciprocal());\n     }\n     }\n \n     /**\n-     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n      *\n      * <p>Any negative signs are resolved to be on the numerator.</p>\n      * @param numerator  the numerator, for example the three in 'three sevenths'\n      * @param denominator  the denominator, for example the seven in 'three sevenths'\n      * @return a new fraction instance, with the numerator and denominator reduced\n-     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     * @throws MathArithmeticException if the denominator is {@code zero}\n      */\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n-            throw MathRuntimeException.createArithmeticException(\n-                  LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n+                                              numerator, denominator);\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n         if (denominator < 0) {\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n-                throw MathRuntimeException.createArithmeticException(\n-                      LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n+                                                  numerator, denominator);\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n \n     /**\n      * <p>\n-     * Returns the <code>String</code> representing this fraction, ie\n+     * Returns the {@code String} representing this fraction, ie\n      * \"num / dem\" or just \"num\" if the denominator is one.\n      * </p>\n      *\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.analysis.function.Add;\n import org.apache.commons.math.analysis.function.Multiply;\n import org.apache.commons.math.analysis.function.Divide;\n-import org.apache.commons.math.analysis.function.Power;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n \n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n  */\n package org.apache.commons.math.stat;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n      * @param sample1  the first array\n      * @param sample2  the second array\n      * @return sum of paired differences\n-     * @throws IllegalArgumentException if the arrays do not have the same\n-     * (positive) length\n-     */\n-    public static double sumDifference(final double[] sample1, final double[] sample2)\n-        throws IllegalArgumentException {\n+     * @throws DimensionMismatchException if the arrays do not have the same\n+     * (positive) length.\n+     * @throws NoDataException if the sample arrays are empty.\n+     */\n+    public static double sumDifference(final double[] sample1, final double[] sample2) {\n         int n = sample1.length;\n-        if (n  != sample2.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, sample2.length);\n-        }\n-        if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, sample2.length, 1);\n+        if (n != sample2.length) {\n+            throw new DimensionMismatchException(n, sample2.length);\n+        }\n+        if (n <= 0) {\n+            throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n         }\n         double result = 0;\n         for (int i = 0; i < n; i++) {\n      * @param sample1  the first array\n      * @param sample2  the second array\n      * @return mean of paired differences\n-     * @throws IllegalArgumentException if the arrays do not have the same\n-     * (positive) length\n-     */\n-    public static double meanDifference(final double[] sample1, final double[] sample2)\n-    throws IllegalArgumentException {\n+     * @throws DimensionMismatchException if the arrays do not have the same\n+     * (positive) length.\n+     * @throws NoDataException if the sample arrays are empty.\n+     */\n+    public static double meanDifference(final double[] sample1, final double[] sample2) {\n         return sumDifference(sample1, sample2) / sample1.length;\n     }\n \n      * @param meanDifference   the mean difference between corresponding entries\n      * @see #meanDifference(double[],double[])\n      * @return variance of paired differences\n-     * @throws IllegalArgumentException if the arrays do not have the same\n-     * length or their common length is less than 2.\n-     */\n-    public static double varianceDifference(final double[] sample1, final double[] sample2,\n-            double meanDifference)  throws IllegalArgumentException {\n+     * @throws DimensionMismatchException if the arrays do not have the same\n+     * length.\n+     * @throws NumberIsTooSmallException if the arrays length is less than 2.\n+     */\n+    public static double varianceDifference(final double[] sample1,\n+                                            final double[] sample2,\n+                                            double meanDifference) {\n         double sum1 = 0d;\n         double sum2 = 0d;\n         double diff = 0d;\n         int n = sample1.length;\n         if (n != sample2.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, n, sample2.length);\n+            throw new DimensionMismatchException(n, sample2.length);\n         }\n         if (n < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n+            throw new NumberIsTooSmallException(n, 2, true);\n         }\n         for (int i = 0; i < n; i++) {\n             diff = sample1[i] - sample2[i];\n         }\n         return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n     }\n-    \n-    \n-\t/**\n-\t * Normalize (standardize) the series, so in the end it is having a mean of 0 and a standard deviation of 1.\n-\t * \n-\t * @param sample sample to normalize\n-\t * @return normalized (standardized) sample\n-\t */\n-\tpublic static double[] normalize(final double[] sample) {\n-\t\tDescriptiveStatistics stats = new DescriptiveStatistics();\n-\n-\t\t// Add the data from the series to stats\n-\t\tfor (int i = 0; i < sample.length; i++) {\n-\t\t\tstats.addValue(sample[i]);\n-\t\t}\n-\n-\t\t// Compute mean and standard deviation\n-\t\tdouble mean = stats.getMean();\n-\t\tdouble standardDeviation = stats.getStandardDeviation();\n-\n-\t\t// initialize the standardizedSample, which has the same length as the sample \n-\t\tdouble[] standardizedSample = new double[sample.length];\n-\n-\t\tfor (int i = 0; i < sample.length; i++) {\n-\t\t\t// z = (x- mean)/standardDeviation\n-\t\t\tstandardizedSample[i] = (sample[i] - mean) / standardDeviation;\n-\t\t}\n-\t\treturn standardizedSample;\n-\t}\n-\n+\n+    /**\n+     * Normalize (standardize) the series, so in the end it is having a mean of 0 and a standard deviation of 1.\n+     *\n+     * @param sample Sample to normalize.\n+     * @return normalized (standardized) sample.\n+     */\n+    public static double[] normalize(final double[] sample) {\n+        DescriptiveStatistics stats = new DescriptiveStatistics();\n+\n+        // Add the data from the series to stats\n+        for (int i = 0; i < sample.length; i++) {\n+            stats.addValue(sample[i]);\n+        }\n+\n+        // Compute mean and standard deviation\n+        double mean = stats.getMean();\n+        double standardDeviation = stats.getStandardDeviation();\n+\n+        // initialize the standardizedSample, which has the same length as the sample\n+        double[] standardizedSample = new double[sample.length];\n+\n+        for (int i = 0; i < sample.length; i++) {\n+            // z = (x- mean)/standardDeviation\n+            standardizedSample[i] = (sample[i] - mean) / standardDeviation;\n+        }\n+        return standardizedSample;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n  */\n package org.apache.commons.math.stat.descriptive;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n         }\n \n         if (begin + length > values.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END);\n+            throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END,\n+                                                begin + length, values.length, true);\n         }\n \n         if (length == 0 && !allowEmpty) {\n         boolean containsPositiveWeight = false;\n         for (int i = begin; i < begin + length; i++) {\n             if (Double.isNaN(weights[i])) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.NAN_ELEMENT_AT_INDEX, i);\n+                throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, i);\n             }\n             if (Double.isInfinite(weights[i])) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.INFINITE_ARRAY_ELEMENT, weights[i], i);\n+                throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, weights[i], i);\n             }\n             if (weights[i] < 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, i, weights[i]);\n+                throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, i, weights[i]);\n             }\n             if (!containsPositiveWeight && weights[i] > 0.0) {\n                 containsPositiveWeight = true;\n         }\n \n         if (!containsPositiveWeight) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n+            throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n         }\n \n         return test(values, begin, length, allowEmpty);\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n import org.apache.commons.math.util.FastMath;\n         test(values, begin, length);\n \n         if ((p > 100) || (p <= 0)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p, 0, 100);\n         }\n         if (length == 0) {\n             return Double.NaN;\n      */\n     public void setQuantile(final double p) {\n         if (p <= 0 || p > 100) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p, 0, 100);\n         }\n         quantile = p;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      * @return chi-square test statistic\n-     * @throws IllegalArgumentException if preconditions are not met\n-     * or length is less than 2\n-     */\n-    public double chiSquare(double[] expected, long[] observed)\n-        throws IllegalArgumentException {\n+     * @throws DimensionMismatchException if the arrays length is less than 2.\n+     */\n+    public double chiSquare(double[] expected, long[] observed) {\n         if (expected.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, expected.length, 2);\n+            throw new DimensionMismatchException(expected.length, 2);\n         }\n         if (expected.length != observed.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, expected.length, observed.length);\n+            throw new DimensionMismatchException(expected.length, observed.length);\n         }\n         checkPositive(expected);\n         checkNonNegative(observed);\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      * @return p-value\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n     public double chiSquareTest(double[] expected, long[] observed)\n-        throws IllegalArgumentException, MathException {\n+        throws MathException {\n         distribution = new ChiSquaredDistributionImpl(expected.length - 1.0);\n         return 1.0 - distribution.cumulativeProbability(\n             chiSquare(expected, observed));\n      * @param alpha significance level of the test\n      * @return true iff null hypothesis can be rejected with confidence\n      * 1 - alpha\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n     public boolean chiSquareTest(double[] expected, long[] observed,\n-            double alpha) throws IllegalArgumentException, MathException {\n+                                 double alpha)\n+        throws MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n-                  alpha, 0, 0.5);\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n+                                          alpha, 0, 0.5);\n         }\n         return chiSquareTest(expected, observed) < alpha;\n     }\n     /**\n      * @param counts array representation of 2-way table\n      * @return chi-square test statistic\n-     * @throws IllegalArgumentException if preconditions are not met\n-     */\n-    public double chiSquare(long[][] counts) throws IllegalArgumentException {\n-\n+     * @throws MathIllegalArgumentException if preconditions are not met.\n+     */\n+    public double chiSquare(long[][] counts) {\n         checkArray(counts);\n         int nRows = counts.length;\n         int nCols = counts[0].length;\n     /**\n      * @param counts array representation of 2-way table\n      * @return p-value\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n     public double chiSquareTest(long[][] counts)\n-    throws IllegalArgumentException, MathException {\n+    throws MathException {\n         checkArray(counts);\n         double df = ((double) counts.length -1) * ((double) counts[0].length - 1);\n         distribution = new ChiSquaredDistributionImpl(df);\n      * @param alpha significance level of the test\n      * @return true iff null hypothesis can be rejected with confidence\n      * 1 - alpha\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n     public boolean chiSquareTest(long[][] counts, double alpha)\n-    throws IllegalArgumentException, MathException {\n+    throws MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n-                  alpha, 0.0, 0.5);\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n+                                          alpha, 0, 0.5);\n         }\n         return chiSquareTest(counts) < alpha;\n     }\n      * @param observed1 array of observed frequency counts of the first data set\n      * @param observed2 array of observed frequency counts of the second data set\n      * @return chi-square test statistic\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @since 1.2\n      */\n-    public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n-        throws IllegalArgumentException {\n-\n+    public double chiSquareDataSetsComparison(long[] observed1, long[] observed2) {\n         // Make sure lengths are same\n         if (observed1.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, observed1.length, 2);\n+            throw new DimensionMismatchException(observed1.length, 2);\n         }\n         if (observed1.length != observed2.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                  observed1.length, observed2.length);\n+            throw new DimensionMismatchException(observed1.length, observed2.length);\n         }\n \n         // Ensure non-negative counts\n         }\n         // Ensure neither sample is uniformly 0\n         if (countSum1 == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 1);\n+            throw new MathIllegalArgumentException(LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 1);\n         }\n         if (countSum2 == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 2);\n+            throw new MathIllegalArgumentException(LocalizedFormats.OBSERVED_COUNTS_ALL_ZERO, 2);\n         }\n         // Compare and compute weight only if different\n         unequalCounts = countSum1 != countSum2;\n         double obs2 = 0.0d;\n         for (int i = 0; i < observed1.length; i++) {\n             if (observed1[i] == 0 && observed2[i] == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY, i);\n+                throw new MathIllegalArgumentException(LocalizedFormats.OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY, i);\n             } else {\n                 obs1 = observed1[i];\n                 obs2 = observed2[i];\n      * @param observed1 array of observed frequency counts of the first data set\n      * @param observed2 array of observed frequency counts of the second data set\n      * @return p-value\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n      * @since 1.2\n      */\n     public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n-        throws IllegalArgumentException, MathException {\n+        throws MathException {\n         distribution = new ChiSquaredDistributionImpl((double) observed1.length - 1);\n         return 1 - distribution.cumulativeProbability(\n                 chiSquareDataSetsComparison(observed1, observed2));\n      * @param alpha significance level of the test\n      * @return true iff null hypothesis can be rejected with confidence\n      * 1 - alpha\n-     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathIllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      * @since 1.2\n      */\n     public boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,\n-            double alpha) throws IllegalArgumentException, MathException {\n-        if ((alpha <= 0) || (alpha > 0.5)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n-                  alpha, 0.0, 0.5);\n+                                                   double alpha)\n+        throws MathException {\n+        if (alpha <= 0 ||\n+            alpha > 0.5) {\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n+                                          alpha, 0, 0.5);\n         }\n         return chiSquareTestDataSetsComparison(observed1, observed2) < alpha;\n     }\n     /**\n      * Checks to make sure that the input long[][] array is rectangular,\n      * has at least 2 rows and 2 columns, and has all non-negative entries,\n-     * throwing IllegalArgumentException if any of these checks fail.\n+     * throwing MathIllegalArgumentException if any of these checks fail.\n      *\n      * @param in input 2-way table to check\n-     * @throws IllegalArgumentException if the array is not valid\n-     */\n-    private void checkArray(long[][] in) throws IllegalArgumentException {\n-\n+     * @throws MathIllegalArgumentException if the array is not valid\n+     */\n+    private void checkArray(long[][] in) {\n         if (in.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, in.length, 2);\n+            throw new NumberIsTooSmallException(in.length, 2, true);\n         }\n \n         if (in[0].length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DIMENSION, in[0].length, 2);\n+            throw new NumberIsTooSmallException(in[0].length, 2, true);\n         }\n \n         checkRectangular(in);\n     //---------------------  Private array methods -- should find a utility home for these\n \n     /**\n-     * Throws IllegalArgumentException if the input array is not rectangular.\n+     * Throws MathIllegalArgumentException if the input array is not rectangular.\n      *\n      * @param in array to be tested\n      * @throws NullPointerException if input array is null\n-     * @throws IllegalArgumentException if input array is not rectangular\n+     * @throws MathIllegalArgumentException if input array is not rectangular\n      */\n     private void checkRectangular(long[][] in) {\n         for (int i = 1; i < in.length; i++) {\n             if (in[i].length != in[0].length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                      in[i].length, in[0].length);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check all entries of the input array are > 0.\n-     *\n-     * @param in array to be tested\n-     * @exception IllegalArgumentException if one entry is not positive\n-     */\n-    private void checkPositive(double[] in) throws IllegalArgumentException {\n+                throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n+                                                     in[i].length, in[0].length);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check all entries of the input array are strictly postive.\n+     *\n+     * @param in Array to be tested.\n+     * @exception NotStrictlyPositiveException if one entry is not positive.\n+     */\n+    private void checkPositive(double[] in) {\n         for (int i = 0; i < in.length; i++) {\n             if (in[i] <= 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX,\n-                      i, in[i]);\n+                throw new NotStrictlyPositiveException(in[i]);\n             }\n         }\n     }\n     /**\n      * Check all entries of the input array are >= 0.\n      *\n-     * @param in array to be tested\n-     * @exception IllegalArgumentException if one entry is negative\n-     */\n-    private void checkNonNegative(long[] in) throws IllegalArgumentException {\n+     * @param in Array to be tested.\n+     * @exception NotPositiveException if one entry is negative.\n+     */\n+    private void checkNonNegative(long[] in) {\n         for (int i = 0; i < in.length; i++) {\n             if (in[i] < 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX,\n-                      i, in[i]);\n+                throw new NotPositiveException(in[i]);\n             }\n         }\n     }\n     /**\n      * Check all entries of the input array are >= 0.\n      *\n-     * @param in array to be tested\n-     * @exception IllegalArgumentException if one entry is negative\n-     */\n-    private void checkNonNegative(long[][] in) throws IllegalArgumentException {\n+     * @param in Array to be tested.\n+     * @exception NotPositiveException if one entry is negative.\n+     */\n+    private void checkNonNegative(long[][] in) {\n         for (int i = 0; i < in.length; i ++) {\n             for (int j = 0; j < in[i].length; j++) {\n                 if (in[i][j] < 0) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                          LocalizedFormats.NEGATIVE_ELEMENT_AT_2D_INDEX,\n-                          i, j, in[i][j]);\n+                    throw new NotPositiveException(in[i][j]);\n                 }\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n import java.util.Comparator;\n import java.util.Collections;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathRuntimeException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n \n /**\n      *\n      * @param x an addend\n      * @param y an addend\n-     * @return the sum <code>x+y</code>\n+     * @return the sum {@code x+y}\n      * @throws MathArithmeticException if the result can not be represented\n      * as an {@code int}.\n      * @since 1.1\n      *\n      * @param a an addend\n      * @param b an addend\n-     * @return the sum <code>a+b</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n+     * @return the sum {@code a+b}\n+     * @throws MathArithmeticException if the result can not be represented as an\n      *         long\n      * @since 1.2\n      */\n     /**\n      * Returns an exact representation of the <a\n      * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n-     * <code>k</code>-element subsets that can be selected from an\n-     * <code>n</code>-element set.\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n      * <p>\n      * <Strong>Preconditions</strong>:\n      * <ul>\n-     * <li> <code>0 <= k <= n </code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>. The\n-     * largest value of <code>n</code> for which all coefficients are\n-     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n-     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which all coefficients are\n+     * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n+     * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n      * thrown.</li>\n      * </ul></p>\n      *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n-     * @return <code>n choose k</code>\n-     * @throws IllegalArgumentException if preconditions are not met.\n-     * @throws ArithmeticException if the result is too large to be represented\n-     *         by a long integer.\n+     * @return {@code n choose k}\n+     * @throws MathIllegalArgumentException if preconditions are not met.\n+     * @throws MathArithmeticException if the result is too large to be\n+     * represented by a long integer.\n      */\n     public static long binomialCoefficient(final int n, final int k) {\n         checkBinomial(n, k);\n     }\n \n     /**\n-     * Returns a <code>double</code> representation of the <a\n+     * Returns a {@code double} representation of the <a\n      * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n-     * <code>k</code>-element subsets that can be selected from an\n-     * <code>n</code>-element set.\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n      * <p>\n      * <Strong>Preconditions</strong>:\n      * <ul>\n-     * <li> <code>0 <= k <= n </code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>. The\n-     * largest value of <code>n</code> for which all coefficients are <\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code double}. The\n+     * largest value of {@code n} for which all coefficients are <\n      * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n      * Double.POSITIVE_INFINITY is returned</li>\n      * </ul></p>\n      *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n-     * @return <code>n choose k</code>\n+     * @return {@code n choose k}\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n     }\n \n     /**\n-     * Returns the natural <code>log</code> of the <a\n+     * Returns the natural {@code log} of the <a\n      * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n-     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n-     * <code>k</code>-element subsets that can be selected from an\n-     * <code>n</code>-element set.\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n      * <p>\n      * <Strong>Preconditions</strong>:\n      * <ul>\n-     * <li> <code>0 <= k <= n </code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n      * </ul></p>\n      *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n-     * @return <code>n choose k</code>\n+     * @return {@code n choose k}\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientLog(final int n, final int k) {\n     }\n \n     /**\n-     * Returns n!. Shorthand for <code>n</code> <a\n+     * Returns n!. Shorthand for {@code n} <a\n      * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n-     * product of the numbers <code>1,...,n</code>.\n+     * product of the numbers {@code 1,...,n}.\n      * <p>\n      * <Strong>Preconditions</strong>:\n      * <ul>\n-     * <li> <code>n >= 0</code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>. The\n-     * largest value of <code>n</code> for which <code>n!</code> <\n-     * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n-     * an <code>ArithMeticException </code> is thrown.</li>\n+     * <li> {@code n >= 0} (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which {@code n!} <\n+     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n+     * an {@code ArithMeticException } is thrown.</li>\n      * </ul>\n      * </p>\n      *\n      * @param n argument\n-     * @return <code>n!</code>\n+     * @return {@code n!}\n      * @throws MathArithmeticException if the result is too large to be represented\n      * by a {@code long}.\n      * @throws NotPositiveException if {@code n < 0}.\n      * Special cases:\n      * <ul>\n      * <li>The invocations\n-     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n-     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n-     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n-     * <code>ArithmeticException</code>, because the result would be 2^31, which\n+     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n+     * {@code gcd(Integer.MIN_VALUE, 0)} and\n+     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^31, which\n      * is too large for an int value.</li>\n-     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n-     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n      * for the special cases above.\n-     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n-     * <code>0</code>.</li>\n+     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     * {@code 0}.</li>\n      * </ul>\n      *\n      * @param p Number.\n      * Special cases:\n      * <ul>\n      * <li>The invocations\n-     * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,\n-     * <code>gcd(Long.MIN_VALUE, 0L)</code> and\n-     * <code>gcd(0L, Long.MIN_VALUE)</code> throw an\n-     * <code>ArithmeticException</code>, because the result would be 2^63, which\n+     * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n+     * {@code gcd(Long.MIN_VALUE, 0L)} and\n+     * {@code gcd(0L, Long.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^63, which\n      * is too large for a long value.</li>\n-     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and\n-     * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n+     * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n      * for the special cases above.\n-     * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns\n-     * <code>0L</code>.</li>\n+     * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n+     * {@code 0L}.</li>\n      * </ul>\n      *\n      * @param p Number.\n \n     /**\n      * For a double precision value x, this method returns +1.0 if x >= 0 and\n-     * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n-     * <code>NaN</code>.\n+     * -1.0 if x < 0. Returns {@code NaN} if {@code x} is\n+     * {@code NaN}.\n      *\n      * @param x the value, a double\n      * @return +1.0 or -1.0, depending on the sign of x\n \n     /**\n      * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n-     * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n+     * 0. Returns {@code NaN} if {@code x} is {@code NaN}.\n      *\n      * @param x the value, a float\n      * @return +1.0F or -1.0F, depending on the sign of x\n     /**\n      * <p>\n      * Returns the least common multiple of the absolute value of two numbers,\n-     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n      * </p>\n      * Special cases:\n      * <ul>\n-     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n-     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n-     * power of 2, throw an <code>ArithmeticException</code>, because the result\n+     * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n+     * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n      * would be 2^31, which is too large for an int value.</li>\n-     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n-     * <code>0</code> for any <code>x</code>.\n+     * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n+     * {@code 0} for any {@code x}.\n      * </ul>\n      *\n      * @param a Number.\n     /**\n      * <p>\n      * Returns the least common multiple of the absolute value of two numbers,\n-     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n      * </p>\n      * Special cases:\n      * <ul>\n-     * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and\n-     * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n-     * power of 2, throw an <code>ArithmeticException</code>, because the result\n+     * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n+     * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n      * would be 2^63, which is too large for an int value.</li>\n-     * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is\n-     * <code>0L</code> for any <code>x</code>.\n+     * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n+     * {@code 0L} for any {@code x}.\n      * </ul>\n      *\n      * @param a Number.\n     /**\n      * <p>Returns the\n      * <a href=\"http://mathworld.wolfram.com/Logarithm.html\">logarithm</a>\n-     * for base <code>b</code> of <code>x</code>.\n+     * for base {@code b} of {@code x}.\n      * </p>\n-     * <p>Returns <code>NaN<code> if either argument is negative.  If\n-     * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.\n-     * If <code>base</code> is positive and <code>x</code> is 0,\n-     * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments\n-     * are 0, the result is <code>NaN</code>.</p>\n+     * <p>Returns {@code NaN} if either argument is negative. If\n+     * {@code base} is 0 and {@code x} is positive, 0 is returned.\n+     * If {@code base} is positive and {@code x} is 0,\n+     * {@code Double.NEGATIVE_INFINITY} is returned.  If both arguments\n+     * are 0, the result is {@code NaN}.</p>\n      *\n      * @param base the base of the logarithm, must be greater than 0\n      * @param x argument, must be greater than 0\n \n     /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n-     * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n+     * <p>If {@code d} is 0 or NaN or Infinite, it is returned unchanged.</p>\n      *\n      * @param d base number\n      * @param scaleFactor power of two by which d sould be multiplied\n      * <p>This method has three main uses:</p>\n      * <ul>\n      *   <li>normalize an angle between 0 and 2&pi;:<br/>\n-     *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>\n+     *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n      *   <li>normalize an angle between -&pi; and +&pi;<br/>\n-     *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>\n+     *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n      *   <li>compute the angle between two defining angular positions:<br>\n-     *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>\n+     *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n      * </ul>\n      * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n      * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n       * applied to each non-NaN element x of the input array, where sum is the\n       * sum of the non-NaN entries in the input array.</p>\n       *\n-      * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite\n+      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n       * or NaN and ArithmeticException if the input array contains any infinite elements\n       * or sums to 0</p>\n       *\n       * @param values input array to be normalized\n       * @param normalizedSum target sum for the normalized array\n       * @return normalized array\n-      * @throws ArithmeticException if the input array contains infinite elements or sums to zero\n-      * @throws IllegalArgumentException if the target sum is infinite or NaN\n+      * @throws MathArithmeticException if the input array contains infinite elements or sums to zero\n+      * @throws MathIllegalArgumentException if the target sum is infinite or NaN\n       * @since 2.1\n       */\n      public static double[] normalizeArray(double[] values, double normalizedSum) {\n          if (Double.isInfinite(normalizedSum)) {\n-             throw MathRuntimeException.createIllegalArgumentException(\n-                     LocalizedFormats.NORMALIZE_INFINITE);\n+             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n          }\n          if (Double.isNaN(normalizedSum)) {\n-             throw MathRuntimeException.createIllegalArgumentException(\n-                     LocalizedFormats.NORMALIZE_NAN);\n+             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n          }\n          double sum = 0d;\n          final int len = values.length;\n          double[] out = new double[len];\n          for (int i = 0; i < len; i++) {\n              if (Double.isInfinite(values[i])) {\n-                 throw MathRuntimeException.createArithmeticException(\n-                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n+                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n              }\n              if (!Double.isNaN(values[i])) {\n                  sum += values[i];\n              }\n          }\n          if (sum == 0) {\n-             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n+             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n          }\n          for (int i = 0; i < len; i++) {\n              if (Double.isNaN(values[i])) {\n             } else {\n                 return Double.NaN;\n             }\n+        } catch (RuntimeException ex) {\n+            throw new MathRuntimeException(ex);\n         }\n     }\n \n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for byte value <code>x</code>.\n+     * for byte value {@code x}.\n      * <p>\n      * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n      * x = 0, and (byte)(-1) if x < 0.</p>\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for double precision <code>x</code>.\n+     * for double precision {@code x}.\n      * <p>\n-     * For a double value <code>x</code>, this method returns\n-     * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n-     * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n-     * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>\n+     * For a double value {@code x}, this method returns\n+     * {@code +1.0} if {@code x > 0}, {@code 0.0} if\n+     * {@code x = 0.0}, and {@code -1.0} if {@code x < 0}.\n+     * Returns {@code NaN} if {@code x} is {@code NaN}.</p>\n      *\n      * @param x the value, a double\n      * @return +1.0, 0.0, or -1.0, depending on the sign of x\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for float value <code>x</code>.\n+     * for float value {@code x}.\n      * <p>\n      * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n-     * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n-     * is <code>NaN</code>.</p>\n+     * 0.0F, and -1.0F if x < 0. Returns {@code NaN} if {@code x}\n+     * is {@code NaN}.</p>\n      *\n      * @param x the value, a float\n      * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for int value <code>x</code>.\n+     * for int value {@code x}.\n      * <p>\n      * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n      * if x < 0.</p>\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for long value <code>x</code>.\n+     * for long value {@code x}.\n      * <p>\n      * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n      * -1L if x < 0.</p>\n             if (a < 0) {\n                 ret = a - b;\n             } else {\n-                throw new ArithmeticException(msg);\n+                throw new MathArithmeticException(msg);\n             }\n         } else {\n             // use additive inverse\n      *     with the distribution.</li>\n      * <li>The end-user documentation included with the redistribution, if any,\n      *     must include the following acknowledgment:\n-     *     <code>This product includes software developed by the University of\n-     *           Chicago, as Operator of Argonne National Laboratory.</code>\n+     *     {@code This product includes software developed by the University of\n+     *           Chicago, as Operator of Argonne National Laboratory.}\n      *     Alternately, this acknowledgment may appear in the software itself,\n      *     if and wherever such third-party acknowledgments normally appear.</li>\n      * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n         try {\n             bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n         double[] wyval = new double[] {-4, -1, -1, 2.5};\n         try {\n             bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n         double[][] wzval = new double[xval.length][yval.length - 1];\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n         try {\n             p = interpolator.interpolate(wxval, yval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n         try {\n             p = interpolator.interpolate(xval, wyval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.junit.Assert;\n         try {\n             p = interpolator.interpolate(wxval, yval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n         try {\n             p = interpolator.interpolate(xval, wyval, zval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n                                                           fval, fval, fval, fval,\n                                                           fval, fval, fval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n         double[] wyval = new double[] {-4, -1, -1, 2.5};\n                                                           fval, fval, fval, fval,\n                                                           fval, fval, fval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n         double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};\n                                                           fval, fval, fval, fval,\n                                                           fval, fval, fval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n         double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length];\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n         try {\n             p = interpolator.interpolate(wxval, yval, zval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n         try {\n             p = interpolator.interpolate(xval, wyval, zval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n         try {\n             p = interpolator.interpolate(xval, yval, wzval, fval);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MathIllegalArgumentException e) {\n             // Expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n package org.apache.commons.math.analysis.polynomials;\n \n import junit.framework.TestCase;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Testcase for Lagrange form of polynomial function.\n             double x[] = { 1.0 };\n             double y[] = { 2.0 };\n             new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting IllegalArgumentException - bad input array length\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             double x[] = { 1.0, 2.0, 3.0, 4.0 };\n             double y[] = { 0.0, -4.0, -24.0 };\n             new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n             double a[] = { 1.0 };\n             double c[] = { 2.0 };\n             new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting IllegalArgumentException - bad input array length\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - bad input array length\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             double a[] = { 1.0, 2.0, 3.0, 4.0 };\n             double c[] = { 4.0, 3.0, 2.0, 1.0 };\n             new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - mismatch input arrays\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n \n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n \n /**\n  * Tests the PolynomialSplineFunction implementation.\n \n         try { // too few knots\n             new PolynomialSplineFunction(new double[] {0}, polynomials);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try { // too many knots\n             new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try { // knots not increasing\n             new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n      */\n      protected int findKnot(double[] knots, double x) {\n          if (x < knots[0] || x >= knots[knots.length -1]) {\n-             throw new IllegalArgumentException(\"x is out of range\");\n+             throw new OutOfRangeException(x, knots[0], knots[knots.length -1]);\n          }\n          for (int i = 0; i < knots.length; i++) {\n              if (knots[i] > x) {\n-                 return i -1;\n+                 return i - 1;\n              }\n          }\n-         throw new IllegalArgumentException(\"x is out of range\");\n+         throw new MathIllegalStateException();\n      }\n }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n         try {\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n             Assert.fail();\n-        } catch(IllegalArgumentException ex){\n+        } catch(MathIllegalArgumentException ex){\n             // success\n         }\n     }\n         try { // bad endpoints\n             double root = UnivariateRealSolverUtils.solve(sin, 4.0, -0.1, 1e-6);\n             System.out.println(\"root=\" + root);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testSolveBadAccuracy() {\n         try { // bad accuracy\n             UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);\n-//             Assert.fail(\"Expecting IllegalArgumentException\"); // TODO needs rework since convergence behaviour was changed\n-        } catch (IllegalArgumentException ex) {\n+//             Assert.fail(\"Expecting MathIllegalArgumentException\"); // TODO needs rework since convergence behaviour was changed\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n             double accuracy = 1.0e-6;\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n             Assert.fail();\n-        } catch(IllegalArgumentException ex){\n+        } catch(MathIllegalArgumentException ex){\n             // success\n         }\n     }\n     public void testSolveNoRoot() {\n         try {\n             UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);\n-            Assert.fail(\"Expecting IllegalArgumentException \");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException \");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testNullFunction() {\n         try { // null function\n             UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testBadInitial() {\n         try { // initial not between endpoints\n             UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testBadEndpoints() {\n         try { // endpoints not valid\n             UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testBadMaximumIterations() {\n         try { // bad maximum iterations\n             UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n \n import org.apache.commons.math.util.CompositeFormat;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NullArgumentException;\n \n import junit.framework.TestCase;\n \n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryFormat(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n             ComplexFormat cf = new ComplexFormat();\n             cf.setRealFormat(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryCharacter(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (NullArgumentException ex) {\n             // success\n         }\n     }\n             ComplexFormat cf = new ComplexFormat();\n             cf.setImaginaryCharacter(\"\");\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n             Object object = new Object();\n             cf.format(object);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Abstract base class for {@link ContinuousDistribution} tests.\n     public void testIllegalArguments() throws Exception {\n         try {\n             distribution.cumulativeProbability(1, 0);\n-            fail(\"Expecting IllegalArgumentException for bad cumulativeProbability interval\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(-1);\n-            fail(\"Expecting IllegalArgumentException for p = -1\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for p = -1\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(2);\n-            fail(\"Expecting IllegalArgumentException for p = 2\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for p = 2\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n     public void testIllegalArguments() throws Exception {\n         try {\n             distribution.cumulativeProbability(1, 0);\n-            fail(\"Expecting IllegalArgumentException for bad cumulativeProbability interval\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for bad cumulativeProbability interval\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(-1);\n-            fail(\"Expecting IllegalArgumentException for p = -1\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for p = -1\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             distribution.inverseCumulativeProbability(2);\n-            fail(\"Expecting IllegalArgumentException for p = 2\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for p = 2\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n package org.apache.commons.math.fraction;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n \n         try {\n             new Fraction(Integer.MIN_VALUE, -1);\n             fail();\n-        } catch (ArithmeticException ex) {\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n         try {\n             new Fraction(1, Integer.MIN_VALUE);\n             fail();\n-        } catch (ArithmeticException ex) {\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n         try {\n         f = new Fraction(0, 3);\n         try {\n             f = f.reciprocal();\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         // large values\n         f = new Fraction(Integer.MAX_VALUE, 1);\n         f = new Fraction(Integer.MIN_VALUE, 1);\n         try {\n             f = f.negate();\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n     }\n \n     public void testAdd() {\n \n         try {\n             f.add(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n \n         // if this fraction is added naively, it will overflow.\n         // check that it doesn't.\n \n         try {\n             f = f.add(Fraction.ONE); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = new Fraction(Integer.MIN_VALUE, 5);\n         f2 = new Fraction(-1,5);\n         try {\n             f = f1.add(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             f = f1.add(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n     }\n \n     public void testDivide() {\n         Fraction f2 = Fraction.ZERO;\n         try {\n             f1.divide(f2);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(0, 5);\n         f2 = new Fraction(2, 7);\n \n         try {\n             f.divide(null);\n-            fail(\"IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+            fail(\"MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n \n         try {\n             f1 = new Fraction(1, Integer.MAX_VALUE);\n             f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n         try {\n             f1 = new Fraction(1, -Integer.MAX_VALUE);\n             f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(6, 35);\n         f  = f1.divide(15);\n \n         try {\n             f.multiply(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n \n         f1 = new Fraction(6, 35);\n         f  = f1.multiply(15);\n         Fraction f = new Fraction(1,1);\n         try {\n             f.subtract(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n \n         // if this fraction is subtracted naively, it will overflow.\n         // check that it doesn't.\n             f1 = new Fraction(1, Integer.MAX_VALUE);\n             f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n             f = f1.subtract(f2);\n-            fail(\"expecting ArithmeticException\");  //should overflow\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");  //should overflow\n+        } catch (MathArithmeticException ex) {}\n \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = new Fraction(Integer.MIN_VALUE, 5);\n         f2 = new Fraction(1,5);\n         try {\n             f = f1.subtract(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(Integer.MIN_VALUE, 1);\n             f = f.subtract(Fraction.ONE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         try {\n             f= new Fraction(Integer.MAX_VALUE, 1);\n             f = f.subtract(Fraction.ONE.negate());\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n \n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             f = f1.subtract(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting MathArithmeticException but got: \" + f.toString());\n+        } catch (MathArithmeticException ex) {}\n     }\n \n     public void testEqualsAndHashCode() {\n         assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n         try {\n             Fraction.getReducedFraction(1, 0);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // expected\n         }\n         assertEquals(Fraction.getReducedFraction\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n \n /**\n  * Test cases for the {@link Array2DRowRealMatrix} class.\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(new Array2DRowRealMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(new Array2DRowRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = new Array2DRowRealMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(new Array2DRowRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting IllegalStateException\");\n-        } catch (IllegalStateException e) {\n+            fail(\"expecting MathIllegalStateException\");\n+        } catch (MathIllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting IllegalStateException\");\n-        } catch (IllegalStateException e) {\n+            fail(\"expecting MathIllegalStateException\");\n+        } catch (MathIllegalStateException e) {\n             // expected\n         }\n \n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n \n     /** extracts the l  and u matrices from compact lu representation */\n     protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) {\n-        if (!lu.isSquare() ||\n-            lowerData.length != lowerData[0].length ||\n-            upperData.length != upperData[0].length ||\n-            lowerData.length != upperData.length ||\n-            lowerData.length != lu.getRowDimension()) {\n-            throw new IllegalArgumentException(\"incorrect dimensions\");\n-        }\n+        if (!lu.isSquare()) {\n+            throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());\n+        }\n+        if (lowerData.length != lowerData[0].length) {\n+            throw new DimensionMismatchException(lowerData.length, lowerData[0].length);\n+        }\n+        if (upperData.length != upperData[0].length) {\n+            throw new DimensionMismatchException(upperData.length, upperData[0].length);\n+        }\n+        if (lowerData.length != upperData.length) {\n+            throw new DimensionMismatchException(lowerData.length, upperData.length);\n+        }\n+        if (lowerData.length != lu.getRowDimension()) {\n+            throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());\n+        }\n+\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n \n     /** Returns the result of applying the given row permutation to the matrix */\n     protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n-        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n-            throw new IllegalArgumentException(\"dimension mismatch\");\n-        }\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+        if (matrix.getRowDimension() != permutation.length) {\n+            throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);\n+        }\n+\n         int n = matrix.getRowDimension();\n         int m = matrix.getColumnDimension();\n         double out[][] = new double[m][n];\n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link ArrayFieldVector} class.\n         assertEquals(new Fraction(4), v4.getEntry(0));\n         try {\n             new ArrayFieldVector<Fraction>(vec4, 8, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         assertEquals(new Fraction(4), v6.getEntry(0));\n         try {\n             new ArrayFieldVector<Fraction>(dvec1, 8, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n          */\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n        try {\n             v1.checkVectorDimensions(v4);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         try {\n             v1.checkVectorDimensions(v4_2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         // when the field is not specified, array cannot be empty\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0]);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0], true);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n         try {\n             new ArrayFieldVector<Fraction>(new Fraction[0], false);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.analysis.function.Abs;\n import org.apache.commons.math.analysis.function.Acos;\n import org.apache.commons.math.analysis.function.Asin;\n         Assert.assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0), 0);\n         try {\n             new ArrayRealVector(vec4, 8, 3);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         Assert.assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0), 0);\n         try {\n             new ArrayRealVector(dvec1, 8, 3);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n \n         try {\n             v_null.unitVector();\n-            Assert.fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // expected behavior\n         }\n \n         assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n         try {\n             v_null.unitize();\n-            Assert.fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // expected behavior\n         }\n \n          */\n         try {\n             v1.checkVectorDimensions(2);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n        try {\n             v1.checkVectorDimensions(v4);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         try {\n             v1.checkVectorDimensions(v4_2);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link BlockFieldMatrix} class.\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = new BlockFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link BlockRealMatrix} class.\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(new BlockRealMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(new BlockRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = new BlockRealMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(new BlockRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.exception.SingularMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n import junit.framework.TestCase;\n-\n-import org.apache.commons.math.util.MathUtils;\n \n public class EigenSolverTest extends TestCase {\n \n         try {\n             es.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             es.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link Array2DRowFieldMatrix} class.\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting IllegalStateException\");\n-        } catch (IllegalStateException e) {\n+            fail(\"expecting MathIllegalStateException\");\n+        } catch (MathIllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting IllegalStateException\");\n-        } catch (IllegalStateException e) {\n+            fail(\"expecting MathIllegalStateException\");\n+        } catch (MathIllegalStateException e) {\n             // expected\n         }\n \n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n     protected void splitLU(FieldMatrix<Fraction> lu,\n                            Fraction[][] lowerData,\n                            Fraction[][] upperData) {\n-        if (!lu.isSquare() ||\n-            lowerData.length != lowerData[0].length ||\n-            upperData.length != upperData[0].length ||\n-            lowerData.length != upperData.length ||\n-            lowerData.length != lu.getRowDimension()) {\n-            throw new IllegalArgumentException(\"incorrect dimensions\");\n+        if (!lu.isSquare()) {\n+            throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());\n+        }\n+        if (lowerData.length != lowerData[0].length) {\n+            throw new DimensionMismatchException(lowerData.length, lowerData[0].length);\n+        }\n+        if (upperData.length != upperData[0].length) {\n+            throw new DimensionMismatchException(upperData.length, upperData[0].length);\n+        }\n+        if (lowerData.length != upperData.length) {\n+            throw new DimensionMismatchException(lowerData.length, upperData.length);\n+        }\n+        if (lowerData.length != lu.getRowDimension()) {\n+            throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());\n         }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n \n     /** Returns the result of applying the given row permutation to the matrix */\n     protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {\n-        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n-            throw new IllegalArgumentException(\"dimension mismatch\");\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+        if (matrix.getRowDimension() != permutation.length) {\n+            throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);\n         }\n         int n = matrix.getRowDimension();\n         int m = matrix.getColumnDimension();\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.SingularMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import junit.framework.TestCase;\n \n public class LUSolverTest extends TestCase {\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link MatrixUtils} class.\n                 MatrixUtils.createRealMatrix(testData));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n                      MatrixUtils.createFieldMatrix(fractionColMatrix));\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n                      new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));\n         try {\n             MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n                      new BlockRealMatrix(colMatrix));\n         try {\n             MatrixUtils.createColumnRealMatrix(new double[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n \n         try {\n             MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));\n         try {\n             MatrixUtils.createRealIdentityMatrix(0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));\n         try {\n             MatrixUtils.createRealIdentityMatrix(0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.SingularMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n import junit.framework.TestCase;\n \n public class QRSolverTest extends TestCase {\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.util.CompositeFormat;\n \n public abstract class RealVectorFormatAbstractTest extends TestCase {\n             Object object = new Object();\n             cf.format(object);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import org.junit.Assert;\n import org.junit.Test;\n         try {\n             solver.solve(b);\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             Assert.fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link SparseFieldMatrix} class.\n         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(createSparseMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(createSparseMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(createSparseMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         }\n         try {\n             new SparseFieldMatrix<Fraction>(field, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] { {} }, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.fraction.FractionField;\n-\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n         assertTrue(\"some output \",  out1.length()!=0);\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link OpenMapRealMatrix} class.\n         OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n         try {\n             m.add(m2);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.subtract(createSparseMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.multiply(createSparseMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         try {\n             m.preMultiply(createSparseMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n         }\n         try {\n             new OpenMapRealMatrix(0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // ragged\n         try {\n             m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n         // empty\n         try {\n             m.setSubMatrix(new double[][] { {} }, 0, 0);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.function.Abs;\n import org.apache.commons.math.analysis.function.Acos;\n         //Assert.assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n         //try {\n         //    new SparseRealVector(vec4, 8, 3);\n-        //    Assert.fail(\"IllegalArgumentException expected\");\n-        //} catch (IllegalArgumentException ex) {\n+        //    Assert.fail(\"MathIllegalArgumentException expected\");\n+        //} catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         //}\n \n \n         try {\n             v_null.unitVector();\n-            Assert.fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // expected behavior\n         }\n \n         assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n         try {\n             v_null.unitize();\n-            Assert.fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // expected behavior\n         }\n \n         Assert.assertTrue(\"some output \",  out1.length()!=0);\n         try {\n             v1.checkVectorDimensions(2);\n-            Assert.fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n import java.io.Serializable;\n \n import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n         try {\n             optimizer.getOptima();\n             fail(\"an exception should have been thrown\");\n-        } catch (IllegalStateException ise) {\n+        } catch (MathIllegalStateException ise) {\n             // expected\n         }\n         VectorialPointValuePair optimum =\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n \n import static org.junit.Assert.assertEquals;\n \n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.general.\n-       LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+\n import org.junit.Test;\n \n /**\n      * Basic.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit01()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET1, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Zero points is not enough observed points.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n-     */\n-    @Test(expected=IllegalArgumentException.class)\n+     */\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testFit02()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         fitter.fit();\n     }\n      * Two points is not enough observed points.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n-     */\n-    @Test(expected=IllegalArgumentException.class)\n+     */\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testFit03()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(new double[][] {\n             {4.0254623,  531026.0},\n      * Poor data: right of peak not symmetric with left of peak.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit04()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET2, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Poor data: long tails.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit05()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET3, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Poor data: right of peak is missing.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit06()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET4, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n      * Basic with smaller dataset.\n      *\n      * @throws OptimizationException in the event of a test case error\n-     * @throws MathUserException in the event of a test case error\n      */\n     @Test\n     public void testFit07()\n-    throws OptimizationException, MathUserException {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET5, fitter);\n         GaussianFunction fitFunction = fitter.fit();\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n \n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n-import org.apache.commons.math.optimization.general.\n-       LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.junit.Test;\n \n import static org.junit.Assert.assertEquals;\n      *\n      * @throws MathUserException in the event of a test case error\n      */\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testValue01() throws MathUserException {\n         ParametricGaussianFunction f = new ParametricGaussianFunction();\n         f.value(0.0, null);\n      *\n      * @throws MathUserException in the event of a test case error\n      */\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testValue02() throws MathUserException {\n         ParametricGaussianFunction f = new ParametricGaussianFunction();\n         f.value(0.0, new double[] {0.0, 1.0});\n--- a/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.stat.Frequency;\n-\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the AbstractRandomGenerator class\n     public void testNextInt() {\n         try {\n             testGenerator.nextInt(-1);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency freq = new Frequency();\n--- a/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n+++ b/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n \n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n import org.junit.Test;\n \n public class MersenneTwisterTest {\n                      0.006);\n     }\n \n-    @Test(expected=java.lang.IllegalArgumentException.class)\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testNextIntNeg() {\n         new MersenneTwister(1).nextInt(-1);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the RandomData class.\n     public void testNextInt() {\n         try {\n             randomData.nextInt(4, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency freq = new Frequency();\n     public void testNextLong() {\n         try {\n             randomData.nextLong(4, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency freq = new Frequency();\n     public void testNextSecureLong() {\n         try {\n             randomData.nextSecureLong(4, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency freq = new Frequency();\n     public void testNextSecureInt() {\n         try {\n             randomData.nextSecureInt(4, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency freq = new Frequency();\n     public void testNextPoisson() {\n         try {\n             randomData.nextPoisson(0);\n-            fail(\"zero mean -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         Frequency f = new Frequency();\n         assertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n         try {\n             randomData.nextPoisson(-1);\n-            fail(\"negative mean supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"negative mean supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextPoisson(0);\n-            fail(\"0 mean supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"0 mean supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n     public void testNextHex() {\n         try {\n             randomData.nextHexString(-1);\n-            fail(\"negative length supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"negative length supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextHexString(0);\n-            fail(\"zero length supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero length supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         String hexString = randomData.nextHexString(3);\n         }\n         try {\n             hexString = randomData.nextHexString(0);\n-            fail(\"zero length requested -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         if (hexString.length() != 1) {\n     public void testNextSecureHex() {\n         try {\n             randomData.nextSecureHexString(-1);\n-            fail(\"negative length -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"negative length -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextSecureHexString(0);\n-            fail(\"zero length -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero length -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         String hexString = randomData.nextSecureHexString(3);\n         }\n         try {\n             hexString = randomData.nextSecureHexString(0);\n-            fail(\"zero length requested -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         if (hexString.length() != 1) {\n     public void testNextUniform() {\n         try {\n             randomData.nextUniform(4, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextUniform(3, 3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         double[] expected = { 500, 500 };\n     public void testNextGaussian() {\n         try {\n             randomData.nextGaussian(0, 0);\n-            fail(\"zero sigma -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero sigma -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         SummaryStatistics u = new SummaryStatistics();\n     public void testNextExponential() {\n         try {\n             randomData.nextExponential(-1);\n-            fail(\"negative mean -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"negative mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             randomData.nextExponential(0);\n-            fail(\"zero mean -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         long cumFreq = 0;\n         // Make sure we fail for sample size > collection size\n         try {\n             one = randomData.nextSample(hs, 2);\n-            fail(\"sample size > set size, expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"sample size > set size, expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             hs = new HashSet<Object>();\n             one = randomData.nextSample(hs, 0);\n-            fail(\"n = k = 0, expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"n = k = 0, expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n     }\n             // Make sure we fail for k size > n\n             try {\n                 perm = randomData.nextPermutation(2, 3);\n-                fail(\"permutation k > n, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n+                fail(\"permutation k > n, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n \n             // Make sure we fail for n = 0\n             try {\n                 perm = randomData.nextPermutation(0, 0);\n-                fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n+                fail(\"permutation k = n = 0, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n \n             // Make sure we fail for k < n < 0\n             try {\n                 perm = randomData.nextPermutation(-1, -3);\n-                fail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n+                fail(\"permutation k < n < 0, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n                 // ignored\n             }\n \n--- a/src/test/java/org/apache/commons/math/random/Well1024aTest.java\n+++ b/src/test/java/org/apache/commons/math/random/Well1024aTest.java\n import org.junit.Assert;\n \n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n                      0.003);\n     }\n \n-    @Test(expected=java.lang.IllegalArgumentException.class)\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testNextIntNeg() {\n         new Well1024a(1).nextInt(-1);\n     }\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link StatUtils} class.\n         try {\n             StatUtils.sumSq(x);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.sumSq(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.product(x);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.product(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.sumLog(x);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.sumLog(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.mean(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.variance(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.max(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.min(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.percentile(x, .25);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n             StatUtils.percentile(x, 0, 4, 0.25);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n                 StatUtils.variance(diff), tolerance);\n         try {\n             StatUtils.meanDifference(sample1, small);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             StatUtils.varianceDifference(sample1, small, meanDifference);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             double[] single = {1.0};\n             StatUtils.varianceDifference(single, single, meanDifference);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n         double[] test = null;\n         try {\n             StatUtils.geometricMean(test);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         test = new double[] {2, 4, 6, 8};\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n \n /**\n         assertFalse(testStatistic.test(testArray, 0, 0));\n         try {\n             testStatistic.test(singletonArray, 2, 1);  // start past end\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, 0, 7);  // end past end\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, -1, 1);  // start negative\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, 0, -1);  // length negative\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(nullArray, 0, 1);  // null array\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, nullArray, 0, 1);  // null weights array\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.StatUtils;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n         try {\n             sv.evaluate(nothing);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n         }\n \n         try {\n             sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n             sv.evaluate(nothing);\n             fail(\"null is not a valid data array.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (MathIllegalArgumentException iae) {\n         }\n         nothing = new double[] {};\n         assertTrue(Double.isNaN(sv.evaluate(nothing)));\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n \n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n         try {\n             p.evaluate(d, 0, d.length, -1.0);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n         try {\n             p.evaluate(d, 0, d.length, 101.0);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n     }\n         double[] emptyArray = new double[] {};\n         try {\n             percentile.evaluate(nullArray);\n-            fail(\"Expecting IllegalArgumentException for null array\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException for null array\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));\n         assertEquals(100, percentile.getQuantile(), 0);\n         try {\n             percentile.setQuantile(0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             new Percentile(0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n  */\n package org.apache.commons.math.stat.inference;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n import junit.framework.TestCase;\n \n /**\n \n         try {\n             testStatistic.chiSquareTest(expected1, observed1, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         double[] tooShortEx = { 1 };\n         try {\n             testStatistic.chiSquare(tooShortEx, tooShortObs);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         double[] unMatchedEx = { 1, 1, 2 };\n         try {\n             testStatistic.chiSquare(unMatchedEx, unMatchedObs);\n-            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         expected[0] = 0;\n         try {\n             testStatistic.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         observed[0] = -1;\n         try {\n             testStatistic.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n             testStatistic.chiSquare(counts3);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             testStatistic.chiSquare(counts4);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             testStatistic.chiSquare(counts5);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             testStatistic.chiSquare(counts6);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         // bad alpha\n         try {\n             testStatistic.chiSquareTest(counts, 0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed1, observed2);\n-            fail(\"Expecting IllegalArgumentException - negative count\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - negative count\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[] observed3 = {10, 0, 12, 10, 15};\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed3, observed4);\n-            fail(\"Expecting IllegalArgumentException - double 0's\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - double 0's\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[] observed5 = {10, 10, 12, 10, 15};\n         try {\n             testStatistic.chiSquareTestDataSetsComparison(\n                     observed5, observed6);\n-            fail(\"Expecting IllegalArgumentException - vanishing counts\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException - vanishing counts\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n /**\n  * Test cases for the TTestImpl class.\n  *\n  * @version $Revision$ $Date$\n  */\n-\n public class TTestTest extends TestCase {\n \n     protected TTest testStatistic = new TTestImpl();\n \n         try {\n             testStatistic.t(mu, (double[]) null);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, (SummaryStatistics) null);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, emptyObs);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, emptyStats);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(mu, tooShortObs);\n-            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.tTest(mu, tooShortObs);\n-            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n \n         try {\n             testStatistic.t(mu, tooShortStats);\n-            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             testStatistic.tTest(mu, tooShortStats);\n-            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n         try {\n             testStatistic.tTest(0d, oneSidedP, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(0d, oneSidedPStats, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n \n         try {\n             testStatistic.tTest(sample1, sample2, .95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, sampleStats2, .95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sample1, tooShortObs, .01);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats, .01);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.tTest(sample1, tooShortObs);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n \n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(sample1, tooShortObs);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             testStatistic.t(sampleStats1, tooShortStats);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n            // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n import junit.framework.TestCase;\n \n-import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n /**\n  * Test cases for the TestUtils class.\n  *\n  * @version $Revision$ $Date$\n  */\n-\n public class TestUtilsTest extends TestCase {\n \n     public TestUtilsTest(String name) {\n \n         try {\n             TestUtils.chiSquareTest(expected1, observed1, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         double[] tooShortEx = { 1 };\n         try {\n             TestUtils.chiSquare(tooShortEx, tooShortObs);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         double[] unMatchedEx = { 1, 1, 2 };\n         try {\n             TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n-            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arrays have different lengths, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         expected[0] = 0;\n         try {\n             TestUtils.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         observed[0] = -1;\n         try {\n             TestUtils.chiSquareTest(expected, observed, .01);\n-            fail(\"bad expected count, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"bad expected count, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n             TestUtils.chiSquare(counts3);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             TestUtils.chiSquare(counts4);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             TestUtils.chiSquare(counts5);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             TestUtils.chiSquare(counts6);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         // bad alpha\n         try {\n             TestUtils.chiSquareTest(counts, 0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n         try {\n             TestUtils.t(mu, (double[]) null);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, (SummaryStatistics) null);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, emptyObs);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, emptyStats);\n-            fail(\"arguments too short, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"arguments too short, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, tooShortObs);\n-            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             TestUtils.tTest(mu, tooShortObs);\n-            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(mu, (SummaryStatistics) null);\n-            fail(\"insufficient data to compute t statistic, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to compute t statistic, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             TestUtils.tTest(mu, (SummaryStatistics) null);\n-            fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data to perform t test, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n         try {\n             TestUtils.tTest(0d, oneSidedP, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(0d, oneSidedPStats, 95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n \n         try {\n             TestUtils.tTest(sample1, sample2, .95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, sampleStats2, .95);\n-            fail(\"alpha out of range, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"alpha out of range, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sample1, tooShortObs, .01);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sample1, tooShortObs);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(sample1, tooShortObs);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n \n         try {\n             TestUtils.t(sampleStats1, (SummaryStatistics) null);\n-            fail(\"insufficient data, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"insufficient data, MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n package org.apache.commons.math.stat.regression;\n \n import java.util.Random;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import junit.framework.TestCase;\n \n \n         try {\n             regression.getSlopeConfidenceInterval(1);\n-            fail(\"expecting IllegalArgumentException for alpha = 1\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException for alpha = 1\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathRuntimeException;\n import org.apache.commons.math.random.RandomDataImpl;\n \n /**\n     /**\n      * Exact (caching) recursive implementation to test against\n      */\n-    private long binomialCoefficient(int n, int k) throws ArithmeticException {\n+    private long binomialCoefficient(int n, int k) throws MathArithmeticException {\n         if (binomialCache.size() > n) {\n             Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n             if (cachedResult != null) {\n                 binomialCoefficient(n - 1, k));\n         }\n         if (result == -1) {\n-            throw new ArithmeticException(\n+            throw new MathArithmeticException(\n                 \"error computing binomial coefficient\");\n         }\n         for (int i = binomialCache.size(); i < n + 1; i++) {\n         assertEquals(big, MathUtils.addAndCheck(big, 0));\n         try {\n             MathUtils.addAndCheck(big, 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.addAndCheck(bigNeg, -1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n     }\n \n     private void testAddAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.addAndCheck(a, b);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n     }\n                 boolean didThrow = false;\n                 try {\n                     ourResult = MathUtils.binomialCoefficient(n, k);\n-                } catch (ArithmeticException ex) {\n+                } catch (MathArithmeticException ex) {\n                     didThrow = true;\n                 }\n                 try {\n                     exactResult = binomialCoefficient(n, k);\n-                } catch (ArithmeticException ex) {\n+                } catch (MathArithmeticException ex) {\n                     shouldThrow = true;\n                 }\n                 assertEquals(n + \" choose \" + k, exactResult, ourResult);\n         // This one should throw\n         try {\n             MathUtils.binomialCoefficient(700, 300);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // Expected\n         }\n \n     public void testBinomialCoefficientFail() {\n         try {\n             MathUtils.binomialCoefficient(4, 5);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficientDouble(4, 5);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficientLog(4, 5);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficient(-1, -2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficientDouble(-1, -2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficientLog(-1, -2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n \n         try {\n             MathUtils.binomialCoefficient(67, 30);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.binomialCoefficient(67, 34);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // ignored\n         }\n         double x = MathUtils.binomialCoefficientDouble(1030, 515);\n     public void testFactorialFail() {\n         try {\n             MathUtils.factorial(-1);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorialDouble(-1);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorialLog(-1);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n         try {\n             MathUtils.factorial(21);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // ignored\n         }\n         assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n         try {\n             // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n             MathUtils.gcd(Integer.MIN_VALUE, 0);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             MathUtils.gcd(0, Integer.MIN_VALUE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n         try {\n             // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n             MathUtils.gcd(Long.MIN_VALUE, 0);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n             MathUtils.gcd(0, Long.MIN_VALUE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n         try {\n             // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n             MathUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n         try {\n             MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Long.MIN_VALUE, 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Long.MIN_VALUE, 1<<20);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n \n             MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n         try {\n             MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException expected) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n             // expected\n         }\n     }\n         assertEquals(big, MathUtils.mulAndCheck(big, 1));\n         try {\n             MathUtils.mulAndCheck(big, 2);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.mulAndCheck(bigNeg, 2);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n     }\n \n     private void testMulAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.mulAndCheck(a, b);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n     }\n                 MathUtils.normalizeArray(testValues3, 1),\n                 Double.MIN_VALUE);\n \n-        // Zero sum -> ArithmeticException\n+        // Zero sum -> MathArithmeticException\n         double[] zeroSum = new double[] {-1, 1};\n         try {\n             MathUtils.normalizeArray(zeroSum, 1);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-\n-        // Infinite elements -> ArithmeticException\n+            fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {}\n+\n+        // Infinite elements -> MathArithmeticException\n         double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};\n         try {\n             MathUtils.normalizeArray(hasInf, 1);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-\n-        // Infinite target -> IllegalArgumentException\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n+\n+        // Infinite target -> MathIllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-\n-        // NaN target -> IllegalArgumentException\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n+\n+        // NaN target -> MathIllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.NaN);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+            fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {}\n \n     }\n \n         try {\n             MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n             fail();\n-        } catch (ArithmeticException ex) {\n+        } catch (MathRuntimeException ex) { // XXX Loosing semantics?\n             // success\n         }\n \n         try {\n             MathUtils.round(1.234, 2, 1923);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathRuntimeException ex) { // XXX Loosing semantics?\n             // success\n         }\n \n         try {\n             MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n             fail();\n-        } catch (ArithmeticException ex) {\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n \n         try {\n             MathUtils.round(1.234f, 2, 1923);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (MathIllegalArgumentException ex) {\n             // success\n         }\n \n         assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));\n         try {\n             MathUtils.subAndCheck(big, -1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n         try {\n             MathUtils.subAndCheck(bigNeg, 1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n         }\n     }\n \n         int big = Integer.MAX_VALUE;\n         try {\n             MathUtils.subAndCheck(big, -1);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             assertTrue(ex.getMessage().length() > 1);\n         }\n     }\n     private void testSubAndCheckLongFailure(long a, long b) {\n         try {\n             MathUtils.subAndCheck(a, b);\n-            fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n             // success\n         }\n \n         assertEquals(1, MathUtils.pow(21, 0));\n         try {\n             MathUtils.pow(21, -7);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(1, MathUtils.pow(21, 0l));\n         try {\n             MathUtils.pow(21, -7l);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(1l, MathUtils.pow(21l, 0));\n         try {\n             MathUtils.pow(21l, -7);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(1l, MathUtils.pow(21l, 0l));\n         try {\n             MathUtils.pow(21l, -7l);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));\n         try {\n             MathUtils.pow(twentyOne, -7);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));\n         try {\n             MathUtils.pow(twentyOne, -7l);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n \n         assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));\n         try {\n             MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+            fail(\"Expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n             // expected behavior\n         }\n ", "timestamp": 1291942250, "metainfo": ""}