{"sha": "04ba9f0eb1bf5834b0b7ea9c94267d099d27ce4c", "log": "fixed an error in multistart univariate optimizer: the optima found were sorted according to the independant variable x, not according to the function value y  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import java.util.Arrays;\n-\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n \n     /** Found optima. */\n     private double[] optima;\n+\n+    /** Found function values at optima. */\n+    private double[] optimaValues;\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer\n      * in the constructor. It is ordered with the results from the\n      * runs that did converge first, sorted from best to worst\n      * objective value (i.e in ascending order if minimizing and in\n-     * descending order if maximizing), followed by and null elements\n+     * descending order if maximizing), followed by Double.NaN elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(UnivariateRealFunction,\n+     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n      * GoalType, double, double) optimize} method did throw a {@link\n      * ConvergenceException ConvergenceException}). This also means that\n-     * if the first element is non null, it is the best point found across\n+     * if the first element is not NaN, it is the best point found across\n      * all starts.</p>\n      * @return array containing the optima\n      * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n      * GoalType, double, double) optimize} has not been called\n+     * @see #getOptimaValues()\n      */\n     public double[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n         return optima.clone();\n     }\n \n+    /** Get all the function values at optima found during the last call to {@link\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by Double.NaN elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is not NaN, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} has not been called\n+     * @see #getOptima()\n+     */\n+    public double[] getOptimaValues() throws IllegalStateException {\n+        if (optimaValues == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optimaValues.clone();\n+    }\n+\n     /** {@inheritDoc} */\n     public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                            final double min, final double max)\n             FunctionEvaluationException {\n \n         optima           = new double[starts];\n+        optimaValues     = new double[starts];\n         totalIterations  = 0;\n         totalEvaluations = 0;\n \n                 optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                 final double bound1 = min + generator.nextDouble() * (max - min);\n                 final double bound2 = min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goalType,\n-                                               Math.min(bound1, bound2),\n-                                               Math.max(bound1, bound2));\n+                optima[i]       = optimizer.optimize(f, goalType,\n+                                                     Math.min(bound1, bound2),\n+                                                     Math.max(bound1, bound2));\n+                optimaValues[i] = optimizer.getFunctionValue();\n             } catch (FunctionEvaluationException fee) {\n-                optima[i] = Double.NaN;\n+                optima[i]       = Double.NaN;\n+                optimaValues[i] = Double.NaN;\n             } catch (ConvergenceException ce) {\n-                optima[i] = Double.NaN;\n+                optima[i]       = Double.NaN;\n+                optimaValues[i] = Double.NaN;\n             }\n \n             totalIterations  += optimizer.getIterationCount();\n             if (Double.isNaN(optima[i])) {\n                 optima[i] = optima[--lastNaN];\n                 optima[lastNaN + 1] = Double.NaN;\n+                optimaValues[i] = optimaValues[--lastNaN];\n+                optimaValues[lastNaN + 1] = Double.NaN;\n             }\n         }\n-        Arrays.sort(optima, 0, lastNaN);\n-        if (goalType == GoalType.MAXIMIZE) {\n-            for (int i = 0, j = lastNaN - 1; i < j; ++i, --j) {\n-                double tmp = optima[i];\n-                optima[i] = optima[j];\n-                optima[j] = tmp;\n+\n+        double currX = optima[0];\n+        double currY = optimaValues[0];\n+        for (int j = 1; j < lastNaN; ++j) {\n+            final double prevY = currY;\n+            currX = optima[j];\n+            currY = optimaValues[j];\n+            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n+                // the current element should be inserted closer to the beginning\n+                int i = j - 1;\n+                double mIX = optima[i];\n+                double mIY = optimaValues[i];\n+                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n+                    optima[i + 1]       = mIX;\n+                    optimaValues[i + 1] = mIY;\n+                    if (i-- != 0) {\n+                        mIX = optima[i];\n+                        mIY = optimaValues[i];\n+                    } else {\n+                        mIX = Double.NaN;\n+                        mIY = Double.NaN;\n+                    }\n+                }\n+                optima[i + 1]       = currX;\n+                optimaValues[i + 1] = currY;\n+                currX = optima[j];\n+                currY = optimaValues[j];\n             }\n         }\n ", "timestamp": 1248538345, "metainfo": ""}