{"sha": "6809f1b932ec3c1fc75175dd02c52224807213a9", "log": "Updated @since tag  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.linear;\n-\n-import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.util.FastMath;\n-\n-\n-/**\n- * Calculates the Cholesky decomposition of a matrix.\n- * <p>The Cholesky decomposition of a real symmetric positive-definite\n- * matrix A consists of a lower triangular matrix L with same size such\n- * that: A = LL<sup>T</sup>. In a sense, this is the square root of A.</p>\n- * <p>This class is based on the class with similar name from the\n- * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n- * following changes:</p>\n- * <ul>\n- *   <li>a {@link #getLT() getLT} method has been added,</li>\n- *   <li>the {@code isspd} method has been removed, since the constructor of\n- *   this class throws a {@link NonPositiveDefiniteMatrixException} when a\n- *   matrix cannot be decomposed,</li>\n- *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n- *   <li>the {@code solve} method has been replaced by a {@link #getSolver()\n- *   getSolver} method and the equivalent method provided by the returned\n- *   {@link DecompositionSolver}.</li>\n- * </ul>\n- *\n- * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n- * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n- * @version $Id$\n- * @since 2.0\n- */\n-public class CholeskyDecomposition {\n-    /**\n-     * Default threshold above which off-diagonal elements are considered too different\n-     * and matrix not symmetric.\n-     */\n-    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n-    /**\n-     * Default threshold below which diagonal elements are considered null\n-     * and matrix not positive definite.\n-     */\n-    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n-    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n-    private double[][] lTData;\n-    /** Cached value of L. */\n-    private RealMatrix cachedL;\n-    /** Cached value of LT. */\n-    private RealMatrix cachedLT;\n-\n-    /**\n-     * Calculates the Cholesky decomposition of the given matrix.\n-     * <p>\n-     * Calling this constructor is equivalent to call {@link\n-     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n-     * thresholds set to the default values {@link\n-     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n-     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n-     * </p>\n-     * @param matrix the matrix to decompose\n-     * @throws NonSquareMatrixException if the matrix is not square.\n-     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n-     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n-     * strictly positive definite.\n-     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n-     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n-     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n-     */\n-    public CholeskyDecomposition(final RealMatrix matrix) {\n-        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n-             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n-    }\n-\n-    /**\n-     * Calculates the Cholesky decomposition of the given matrix.\n-     * @param matrix the matrix to decompose\n-     * @param relativeSymmetryThreshold threshold above which off-diagonal\n-     * elements are considered too different and matrix not symmetric\n-     * @param absolutePositivityThreshold threshold below which diagonal\n-     * elements are considered null and matrix not positive definite\n-     * @throws NonSquareMatrixException if the matrix is not square.\n-     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n-     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n-     * strictly positive definite.\n-     * @see #CholeskyDecompositionImpl(RealMatrix)\n-     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n-     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n-     */\n-    public CholeskyDecomposition(final RealMatrix matrix,\n-                                     final double relativeSymmetryThreshold,\n-                                     final double absolutePositivityThreshold) {\n-        if (!matrix.isSquare()) {\n-            throw new NonSquareMatrixException(matrix.getRowDimension(),\n-                                               matrix.getColumnDimension());\n-        }\n-\n-        final int order = matrix.getRowDimension();\n-        lTData   = matrix.getData();\n-        cachedL  = null;\n-        cachedLT = null;\n-\n-        // check the matrix before transformation\n-        for (int i = 0; i < order; ++i) {\n-            final double[] lI = lTData[i];\n-\n-            // check off-diagonal elements (and reset them to 0)\n-            for (int j = i + 1; j < order; ++j) {\n-                final double[] lJ = lTData[j];\n-                final double lIJ = lI[j];\n-                final double lJI = lJ[i];\n-                final double maxDelta =\n-                    relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI));\n-                if (FastMath.abs(lIJ - lJI) > maxDelta) {\n-                    throw new NonSymmetricMatrixException(i, j, relativeSymmetryThreshold);\n-                }\n-                lJ[i] = 0;\n-           }\n-        }\n-\n-        // transform the matrix\n-        for (int i = 0; i < order; ++i) {\n-\n-            final double[] ltI = lTData[i];\n-\n-            // check diagonal element\n-            if (ltI[i] <= absolutePositivityThreshold) {\n-                throw new NonPositiveDefiniteMatrixException(ltI[i], i, absolutePositivityThreshold);\n-            }\n-\n-            ltI[i] = FastMath.sqrt(ltI[i]);\n-            final double inverse = 1.0 / ltI[i];\n-\n-            for (int q = order - 1; q > i; --q) {\n-                ltI[q] *= inverse;\n-                final double[] ltQ = lTData[q];\n-                for (int p = q; p < order; ++p) {\n-                    ltQ[p] -= ltI[q] * ltI[p];\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns the matrix L of the decomposition.\n-     * <p>L is an lower-triangular matrix</p>\n-     * @return the L matrix\n-     */\n-    public RealMatrix getL() {\n-        if (cachedL == null) {\n-            cachedL = getLT().transpose();\n-        }\n-        return cachedL;\n-    }\n-\n-    /**\n-     * Returns the transpose of the matrix L of the decomposition.\n-     * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n-     * @return the transpose of the matrix L of the decomposition\n-     */\n-    public RealMatrix getLT() {\n-\n-        if (cachedLT == null) {\n-            cachedLT = MatrixUtils.createRealMatrix(lTData);\n-        }\n-\n-        // return the cached matrix\n-        return cachedLT;\n-    }\n-\n-    /**\n-     * Return the determinant of the matrix\n-     * @return determinant of the matrix\n-     */\n-    public double getDeterminant() {\n-        double determinant = 1.0;\n-        for (int i = 0; i < lTData.length; ++i) {\n-            double lTii = lTData[i][i];\n-            determinant *= lTii * lTii;\n-        }\n-        return determinant;\n-    }\n-\n-    /**\n-     * Get a solver for finding the A &times; X = B solution in least square sense.\n-     * @return a solver\n-     */\n-    public DecompositionSolver getSolver() {\n-        return new Solver(lTData);\n-    }\n-\n-    /** Specialized solver. */\n-    private static class Solver implements DecompositionSolver {\n-        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n-        private final double[][] lTData;\n-\n-        /**\n-         * Build a solver from decomposed matrix.\n-         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n-         */\n-        private Solver(final double[][] lTData) {\n-            this.lTData = lTData;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public boolean isNonSingular() {\n-            // if we get this far, the matrix was positive definite, hence non-singular\n-            return true;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public RealVector solve(final RealVector b) {\n-            final int m = lTData.length;\n-            if (b.getDimension() != m) {\n-                throw new DimensionMismatchException(b.getDimension(), m);\n-            }\n-\n-            final double[] x = b.toArray();\n-\n-            // Solve LY = b\n-            for (int j = 0; j < m; j++) {\n-                final double[] lJ = lTData[j];\n-                x[j] /= lJ[j];\n-                final double xJ = x[j];\n-                for (int i = j + 1; i < m; i++) {\n-                    x[i] -= xJ * lJ[i];\n-                }\n-            }\n-\n-            // Solve LTX = Y\n-            for (int j = m - 1; j >= 0; j--) {\n-                x[j] /= lTData[j][j];\n-                final double xJ = x[j];\n-                for (int i = 0; i < j; i++) {\n-                    x[i] -= xJ * lTData[i][j];\n-                }\n-            }\n-\n-            return new ArrayRealVector(x, false);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b) {\n-            final int m = lTData.length;\n-            if (b.getRowDimension() != m) {\n-                throw new DimensionMismatchException(b.getRowDimension(), m);\n-            }\n-\n-            final int nColB = b.getColumnDimension();\n-            final double[][] x = b.getData();\n-\n-            // Solve LY = b\n-            for (int j = 0; j < m; j++) {\n-                final double[] lJ = lTData[j];\n-                final double lJJ = lJ[j];\n-                final double[] xJ = x[j];\n-                for (int k = 0; k < nColB; ++k) {\n-                    xJ[k] /= lJJ;\n-                }\n-                for (int i = j + 1; i < m; i++) {\n-                    final double[] xI = x[i];\n-                    final double lJI = lJ[i];\n-                    for (int k = 0; k < nColB; ++k) {\n-                        xI[k] -= xJ[k] * lJI;\n-                    }\n-                }\n-            }\n-\n-            // Solve LTX = Y\n-            for (int j = m - 1; j >= 0; j--) {\n-                final double lJJ = lTData[j][j];\n-                final double[] xJ = x[j];\n-                for (int k = 0; k < nColB; ++k) {\n-                    xJ[k] /= lJJ;\n-                }\n-                for (int i = 0; i < j; i++) {\n-                    final double[] xI = x[i];\n-                    final double lIJ = lTData[i][j];\n-                    for (int k = 0; k < nColB; ++k) {\n-                        xI[k] -= xJ[k] * lIJ;\n-                    }\n-                }\n-            }\n-\n-            return new Array2DRowRealMatrix(x);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public RealMatrix getInverse() {\n-            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+\n+\n+/**\n+ * Calculates the Cholesky decomposition of a matrix.\n+ * <p>The Cholesky decomposition of a real symmetric positive-definite\n+ * matrix A consists of a lower triangular matrix L with same size such\n+ * that: A = LL<sup>T</sup>. In a sense, this is the square root of A.</p>\n+ * <p>This class is based on the class with similar name from the\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getLT() getLT} method has been added,</li>\n+ *   <li>the {@code isspd} method has been removed, since the constructor of\n+ *   this class throws a {@link NonPositiveDefiniteMatrixException} when a\n+ *   matrix cannot be decomposed,</li>\n+ *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n+ *   <li>the {@code solve} method has been replaced by a {@link #getSolver()\n+ *   getSolver} method and the equivalent method provided by the returned\n+ *   {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Id: CholeskyDecomposition.java 1173481 2011-09-21 03:45:37Z celestin $\n+ * @since 2.0 (changed to concrete class in 3.0)\n+ */\n+public class CholeskyDecomposition {\n+    /**\n+     * Default threshold above which off-diagonal elements are considered too different\n+     * and matrix not symmetric.\n+     */\n+    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n+    /**\n+     * Default threshold below which diagonal elements are considered null\n+     * and matrix not positive definite.\n+     */\n+    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n+    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+    private double[][] lTData;\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+    /** Cached value of LT. */\n+    private RealMatrix cachedLT;\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * <p>\n+     * Calling this constructor is equivalent to call {@link\n+     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n+     * thresholds set to the default values {@link\n+     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n+     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n+     * </p>\n+     * @param matrix the matrix to decompose\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n+     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecomposition(final RealMatrix matrix) {\n+        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n+             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n+    }\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * @param matrix the matrix to decompose\n+     * @param relativeSymmetryThreshold threshold above which off-diagonal\n+     * elements are considered too different and matrix not symmetric\n+     * @param absolutePositivityThreshold threshold below which diagonal\n+     * elements are considered null and matrix not positive definite\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n+     * @see #CholeskyDecompositionImpl(RealMatrix)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecomposition(final RealMatrix matrix,\n+                                     final double relativeSymmetryThreshold,\n+                                     final double absolutePositivityThreshold) {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int order = matrix.getRowDimension();\n+        lTData   = matrix.getData();\n+        cachedL  = null;\n+        cachedLT = null;\n+\n+        // check the matrix before transformation\n+        for (int i = 0; i < order; ++i) {\n+            final double[] lI = lTData[i];\n+\n+            // check off-diagonal elements (and reset them to 0)\n+            for (int j = i + 1; j < order; ++j) {\n+                final double[] lJ = lTData[j];\n+                final double lIJ = lI[j];\n+                final double lJI = lJ[i];\n+                final double maxDelta =\n+                    relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI));\n+                if (FastMath.abs(lIJ - lJI) > maxDelta) {\n+                    throw new NonSymmetricMatrixException(i, j, relativeSymmetryThreshold);\n+                }\n+                lJ[i] = 0;\n+           }\n+        }\n+\n+        // transform the matrix\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] ltI = lTData[i];\n+\n+            // check diagonal element\n+            if (ltI[i] <= absolutePositivityThreshold) {\n+                throw new NonPositiveDefiniteMatrixException(ltI[i], i, absolutePositivityThreshold);\n+            }\n+\n+            ltI[i] = FastMath.sqrt(ltI[i]);\n+            final double inverse = 1.0 / ltI[i];\n+\n+            for (int q = order - 1; q > i; --q) {\n+                ltI[q] *= inverse;\n+                final double[] ltQ = lTData[q];\n+                for (int p = q; p < order; ++p) {\n+                    ltQ[p] -= ltI[q] * ltI[p];\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the matrix L of the decomposition.\n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix\n+     */\n+    public RealMatrix getL() {\n+        if (cachedL == null) {\n+            cachedL = getLT().transpose();\n+        }\n+        return cachedL;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix L of the decomposition.\n+     * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n+     * @return the transpose of the matrix L of the decomposition\n+     */\n+    public RealMatrix getLT() {\n+\n+        if (cachedLT == null) {\n+            cachedLT = MatrixUtils.createRealMatrix(lTData);\n+        }\n+\n+        // return the cached matrix\n+        return cachedLT;\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    public double getDeterminant() {\n+        double determinant = 1.0;\n+        for (int i = 0; i < lTData.length; ++i) {\n+            double lTii = lTData[i][i];\n+            determinant *= lTii * lTii;\n+        }\n+        return determinant;\n+    }\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lTData);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+        private final double[][] lTData;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n+         */\n+        private Solver(final double[][] lTData) {\n+            this.lTData = lTData;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            // if we get this far, the matrix was positive definite, hence non-singular\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(final RealVector b) {\n+            final int m = lTData.length;\n+            if (b.getDimension() != m) {\n+                throw new DimensionMismatchException(b.getDimension(), m);\n+            }\n+\n+            final double[] x = b.toArray();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                x[j] /= lJ[j];\n+                final double xJ = x[j];\n+                for (int i = j + 1; i < m; i++) {\n+                    x[i] -= xJ * lJ[i];\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                x[j] /= lTData[j][j];\n+                final double xJ = x[j];\n+                for (int i = 0; i < j; i++) {\n+                    x[i] -= xJ * lTData[i][j];\n+                }\n+            }\n+\n+            return new ArrayRealVector(x, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            final int m = lTData.length;\n+            if (b.getRowDimension() != m) {\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            final double[][] x = b.getData();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                final double lJJ = lJ[j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = j + 1; i < m; i++) {\n+                    final double[] xI = x[i];\n+                    final double lJI = lJ[i];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lJI;\n+                    }\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                final double lJJ = lTData[j][j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = 0; i < j; i++) {\n+                    final double[] xI = x[i];\n+                    final double lIJ = lTData[i][j];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lIJ;\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowRealMatrix(x);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n+        }\n+    }\n+}", "timestamp": 1316630742, "metainfo": ""}