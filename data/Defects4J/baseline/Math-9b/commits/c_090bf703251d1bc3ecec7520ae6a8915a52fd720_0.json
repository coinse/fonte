{"sha": "090bf703251d1bc3ecec7520ae6a8915a52fd720", "log": "* ContractableDoubleArray extends ExpandableDoubleArray - I sense the need for a DoubleArray interface.  * ExpandableDoubleArray and the extension ContractableDoubleArray should aim towards presenting a public interface that does not expose any details of the internal.  To this end, one is no longer able to get the internal storage array via public double[] getValues(), and the startIndex (which was relative to the internal storage array) is no longer available.  * [Expandable|Contractable]DoubleArray now allow one to discard elements from the front of the array.  Before this commit, one could accomplish the same goal by changing the starting index of the element array within the internal storage array.  This solution allowed one to discard elements from the front of the array (as well as) reclaiming elements by decreases the startIndex.  There were two problems with this approach (especially in ContractableDoubleArray).   The ContractableDoubleArray can be \"compacted\" at anytime thereby reseting the startIndex to zero and the size of the internal store array to number of elements plus one.  Second, \"reclaiming\" elements from the internal storage array by finagling internal \"pointers\" to the start and end index seems to violate the principles of encapsulation.  If you \"discard\" an element from the front of the array, consider it unavailable.  It should be noted that calling setNumElements allows one to move the end index of the internal element array at will.  Assume one has a 100 element array, and one calls setNumElements(10), thereby decreasing the ending index of the element array by 90.  The 90 \"dumped\" elements are not currently reinitializied to the default double primitive value.  This is an open question.  * Tests for ExpandableDoubleArray and ContractableDoubleArray were refactored.  both test classes now extend a DoubleArrayAbstractTest JUnit class which contained shared unit tests for both \"implementations\". An approach like this should be adopted to test the Univariate implementations.   ", "commit": "\n--- a/src/java/org/apache/commons/math/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ContractableDoubleArray.java\n \t */\n \tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor) {\n \t\tthis.expansionFactor = expansionFactor;\n-\t\tthis.initialCapacity = initialCapacity;\n+\t\tsetInitialCapacity( initialCapacity );\n \t\tinternalArray = new double[initialCapacity];\n \t\tcheckContractExpand(getContractionCriteria(), expansionFactor);\n \t}\n \tpublic ContractableDoubleArray(int initialCapacity, float expansionFactor, float contractionCriteria) {\n \t\tthis.contractionCriteria = contractionCriteria;\n \t\tthis.expansionFactor = expansionFactor;\n-\t\tthis.initialCapacity = initialCapacity;\n+\t\tsetInitialCapacity( initialCapacity );\n \t\tinternalArray = new double[initialCapacity];\n \t\tcheckContractExpand(contractionCriteria, expansionFactor);\n \t}\n \t\tsuper.setExpansionFactor(expansionFactor);\n \t}\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.ExpandableDoubleArray#setStartIndex(int)\n-\t */\n-\tpublic synchronized void setStartIndex(int i) {\n-\t\tsuper.setStartIndex(i);\n-\t\tif( shouldContract() ) {\n-\t\t\tcontract();\n-\t\t}\n-\t}\n-\n \t/**\n \t * The contraction criteria defines when the internal array will contract to store only the\n \t * number of elements in the element array.  This contractionCriteria gaurantees that\n \tpublic void setContractionCriteria(float contractionCriteria) {\n \t\tcheckContractExpand( contractionCriteria, getExpansionFactor() );\n \t\t\n-\t\tif( contractionCriteria <= 1.0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"The contraction criteria must be a number larger than\" +\n-\t\t\t\t\" one.  If the contractionCriteria is less than or equal to one an endless loop of contraction \" +\n-\t\t\t\t\"and expansion would ensue as an internalArray.length == numElements would satisfy \" +\n-\t\t\t\t\"the contraction criteria\");\n-\t\t}\n \t\tthis.contractionCriteria = contractionCriteria;\n \t}\n \t\n \t * @param expansionFactor \n \t * @param contractionCriteria\n \t */\n-\tpublic void checkContractExpand( float contractionCritera, float expansionFactor ) {\n+\tprotected void checkContractExpand( float contractionCritera, float expansionFactor ) {\n \t\t\n \t\tif( contractionCritera < expansionFactor ) {\n \t\t\tthrow new IllegalArgumentException( \"Contraction criteria can never be smaller than \" +\n \t\t\t\t\"the expansion factor.  This would lead to a never ending loop of expansion and \" +\n \t\t\t\t\"contraction as a newly expanded internal storage array would immediately \" +\n \t\t\t\t\"satisfy the criteria for contraction\");\n-\t\t}\n+\t\t} \n+\n+\t\tif( contractionCriteria <= 1.0 ) {\n+\t\t\tthrow new IllegalArgumentException( \"The contraction criteria must be a number larger than\" +\n+\t\t\t\t\" one.  If the contractionCriteria is less than or equal to one an endless loop of contraction \" +\n+\t\t\t\t\"and expansion would ensue as an internalArray.length == numElements would satisfy \" +\n+\t\t\t\t\"the contraction criteria\");\n+\t\t}\n+\t\t\n+\t\tif (expansionFactor < 1.0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"The expansion factor must be a number greater than\" + \"1.0\");\n+\t\t}\n+\n \t\t\n \t}\n \t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n+\t */\n+\tpublic synchronized void discardFrontElements(int i) {\n+\t\tsuper.discardFrontElements(i);\n+\t\tif( shouldContract() ) {\n+\t\t\tcontract();\n+\t\t}\n+\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n \t * \n \t * @return the internal storage array used by this object\n \t */\n-\tpublic double[] getValues() {\n+\tprotected double[] getValues() {\n \t\treturn (internalArray);\n \t}\n \n \t}\n \n \t/**\n-\t * Returns the starting index from the internal array.  This value should remain at\n-\t * zero in this implementation of ExpandableDoubleArray.\n-\t * \n-\t * @return the starting Index in the internal storage array, in this class it is always zero.\n-\t */\n-\tpublic int getStartIndex() {\n-\t\treturn startIndex;\n-\t}\n-\n-\t/**\n-\t * Sets the starting index of the element array in the internal array, and subtracts the difference\n-\t * between the original startIndex and the new startIndex from the number of elements.   This\n-\t * method should be used with care.\n-\t * \n-\t * @param Index relative to the internal array from which to start the element array\n-\t */\n-\tpublic synchronized void setStartIndex(int i) {\n-\t\t\n-\t\tif( i > (startIndex + numElements) ) {\n-\t\t\tthrow new IllegalArgumentException( \"Cannot start the element array outside of the \" +\n-\t\t\t\t\"current element array.\");\n+\t * Discards values from the front of the list.  This function removes n elements from\n+\t * the front of the array.\n+\t * \n+\t * @param i number of elements to discard from the front of the array.\n+\t */\n+\tpublic synchronized void discardFrontElements(int i) {\n+\t\t\n+\t\tif( i > numElements ) {\n+\t\t\tthrow new IllegalArgumentException( \"Cannot discard more elements than are\" +\n+\t\t\t\t\"contained in this array.\");\n \t\t} else if( i < 0 ) {\n-\t\t\tthrow new IllegalArgumentException( \"The starting index cannot be set to a negative index\");\n+\t\t\tthrow new IllegalArgumentException( \"Cannot discard a negative number\" +\n+\t\t\t\t\" of elements.\");\n \t\t} else {\n-\t\t\t\n-\t\t \t// Calculat the difference between the original start index and the current start index\n-\t\t\tint difference = i - startIndex;\n-\t\t\t\n-\t\t\t// \"Subtract\" this difference from numElements - this works both ways.  If the\n-\t\t\t// new start index is lower than the current start index then numElements is\n-\t\t\t// incremenet by that differen\n-\t\t\tnumElements -= difference;\n-\t\t\t\n-\t\t\tstartIndex = i;\n+\t\t\t// \"Subtract\" this number of discarded from numElements \n+\t\t\tnumElements -= i;\n+\t\t\tstartIndex += i;\n \t\t}\n \t}\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ContractableDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ContractableDoubleArrayTest extends DoubleArrayAbstractTest {\n+\n+\tpublic ContractableDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\teDA = new ContractableDoubleArray();\n+\t}\n+\n+\t/** Test normal operations and then test internal storage */\n+\tpublic void testAdd1000() {\n+\t\tsuper.testAdd1000();\n+\t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+\t\t\t\"16 and an expansion factor of 2.0\",\n+\t\t\t\t\t\t\t1024, eDA.getInternalLength());\n+\t}\n+\t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\tsuper.testSetElementArbitraryExpansion();\n+\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength(), 1001);\n+\t}\n+\n+\tpublic void testAddElementRolling() {\n+\t\tsuper.testAddElementRolling();\n+\t\tassertTrue( \"Even though there are only 6 element, internal storage should be less than 2.5 times the number of elements\", \n+\t\t\teDA.getInternalLength() < ((int) 6 * 2.5) );\n+\t}\n+\n+\n+\t/** Test ERROR conditions */\n+\t/** TEST ERROR CONDITIONS **/\n+\n+\tpublic void testIllegalInitialCapacity() {\n+\t\ttry {\n+\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(-3, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was negative, if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(0, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was ZERO if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t}\n+\t\n+\tpublic void testIllegalExpansionFactor() {\n+\t\ttry {\n+\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, 0.66f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.66 which would shrink the array instead of expand the array\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, 0.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.0\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tContractableDoubleArray eDA = new ContractableDoubleArray(3, -4.35f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for -4.35\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t}\n+\t\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/DoubleArrayAbstractTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public abstract class DoubleArrayAbstractTest extends TestCase {\n+\n+\tprotected ExpandableDoubleArray eDA = null;\n+\n+\tpublic DoubleArrayAbstractTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t\n+\t\n+\t/** TEST NORMAL OPERATIONS **/\n+\t\n+\tpublic void testAdd1000() {\n+\n+\t\tfor( int i = 0; i < 1000; i++) {\n+\t\t\teDA.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals(\"Number of elements should be equal to 1000 after adding 1000 values\",\n+\t\t\t\t\t\t\t1000, eDA.getNumElements() );\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t    \n+\t\tassertEquals(\"The element at the 56th index should be 56\", \n+\t\t\t\t\t\t\t56.0, eDA.getElement(56), Double.MIN_VALUE );\n+\t\t\t\t\t\t    \n+\t}\n+\t\n+\t\n+\tpublic void testGetValues() {\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\teDA.addElement(2.0);\n+\t\teDA.addElement(4.0);\n+\t\teDA.addElement(6.0);\n+\t\tdouble[] testArray = eDA.getValues();\n+\t\t\n+\t\tfor( int i = 0; i < eDA.getNumElements(); i++) {\n+\t\t\tassertEquals( \"The testArray values should equal the controlArray values, index i: \" + i +\n+\t\t\t\t\" does not match\", testArray[i], controlArray[i], Double.MIN_VALUE);\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\teDA.addElement(2.0);\n+\t\teDA.addElement(4.0);\n+\t\teDA.addElement(6.0);\n+\t\teDA.setElement(1, 3.0);\n+\t\t\n+\t\t// Expand the array arbitrarily to 1000 items\n+\t\teDA.setElement(1000, 3.4);\n+\n+\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", eDA.getNumElements(), 1001);\n+\t\t\n+\t\tassertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+\t\t\t\t\t\t\teDA.getElement( 760 ), Double.MIN_VALUE );\n+\t\t\n+\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, eDA.getElement(1000), Double.MIN_VALUE );\n+\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, eDA.getElement(0), Double.MIN_VALUE);\t\t\n+\t\t\n+\t}\n+\t\n+\tpublic void testSetNumberOfElements() {\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\tassertEquals( \"Number of elements should equal 6\", eDA.getNumElements(), 6);\n+\t\t\n+\t\teDA.setNumElements( 3 );\n+\t\tassertEquals( \"Number of elements should equal 3\", eDA.getNumElements(), 3);\n+\t\t\n+\t\ttry {\n+\t\t\teDA.setNumElements( -3 );\n+\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\n+\t\teDA.setNumElements(1024);\n+\t\tassertEquals( \"Number of elements should now be 1024\", eDA.getNumElements(), 1024);\n+\t\tassertEquals( \"Element 453 should be a default double\", eDA.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+\t\t\t\t\n+\t}\n+\t\n+\tpublic void testAddElementRolling() {\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElement( 1.0 );\n+\t\teDA.addElementRolling( 2.0 );\n+\t\t\n+\t\tassertEquals( \"There should be 6 elements in the eda\", eDA.getNumElements(), 6);\n+\t\tassertEquals( \"The last element should be 2.0\", eDA.getElement( eDA.getNumElements() -1 ), 2.0, Double.MIN_VALUE);\n+\t\t\n+\t\tfor( int i = 0; i  < 1024; i++ ) {\n+\t\t\teDA.addElementRolling( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"We just inserted 1024 rolling elements, num elements should still be 6\", eDA.getNumElements(), 6);\n+\t\t\t\t\n+\t}\n+\n+}\n--- a/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n  */\n package org.apache.commons.math;\n \n-import java.util.NoSuchElementException;\n-\n-import junit.framework.TestCase;\n \n /**\n  * This class contains test cases for the ExpandableDoubleArray.\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n-public class ExpandableDoubleArrayTest extends TestCase {\n+public class ExpandableDoubleArrayTest extends DoubleArrayAbstractTest {\n \n \tpublic ExpandableDoubleArrayTest(String name) {\n \t\tsuper( name );\n \t}\n \t\n-\t/** TEST NORMAL OPERATIONS **/\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\teDA = new ExpandableDoubleArray();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#tearDown()\n+\t */\n+\tprotected void tearDown() throws Exception {\n+\t\teDA = null;\n+\t}\n+\t\n+\t\n+\t/** TEST NORMAL OPERATIONS - calling super class test and then checking internal\n+\t *   storage **/\n \t\n \tpublic void testAdd1000() {\n-\n-\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray();\n-\t\t\n-\t\tfor( int i = 0; i < 1000; i++) {\n-\t\t\texDoubleArr.addElement( i );\n-\t\t}\n-\t\t\n-\t\tassertTrue(\"Number of elements should be equal to 1000 after adding 1000 values\",\n-\t\t\t\t\t\t\texDoubleArr.getNumElements() == 1000);\n-\t\t\t\t\t\t\t\n-\t\tassertTrue(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+\t\tsuper.testAdd1000();\n+\t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n \t\t\t\"16 and an expansion factor of 2.0\",\n-\t\t\t\t\t\t    exDoubleArr.getInternalLength() == 1024);\n-\t\t\t\t\t\t    \n-\t\tassertTrue(\"The element at the 56th index should be 56\", \n-\t\t\t\t\t\t\texDoubleArr.getElement(56) == 56 );\n-\t\t\t\t\t\t    \n+\t\t\t\t\t\t\t1024, eDA.getInternalLength());\n \t}\n \t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\tsuper.testSetElementArbitraryExpansion();\n+\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength(), 1001);\n+\t}\n+\n+\tpublic void testAddElementRolling() {\n+\t\tsuper.testAddElementRolling();\n+\t\tassertEquals( \"Even though there are only 6 element, internal storage should be 2048\", eDA.getInternalLength(), 2048);\n+\t}\n+\n+\t/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */\n+\n \tpublic void testWithInitialCapacity() {\n-\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray(2);\n \n-\t\tassertTrue(\"Initial internal length should be 2\", exDoubleArr.getInternalLength() == 2);\n-\t\tassertTrue(\"Initial number of elements should be 0\", exDoubleArr.getNumElements() == 0);\n+\t\tExpandableDoubleArray eDA2 = new ExpandableDoubleArray(2);\n+\t\tassertEquals(\"Initial internal length should be 2\", 2, eDA2.getInternalLength());\n+\t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n \n \t\tint iterations = (int) Math.pow(2.0, 15.0);\n \n \t\tfor( int i = 0; i < iterations; i++) {\n-\t\t\texDoubleArr.addElement( i );\n+\t\t\teDA2.addElement( i );\n \t\t}\n \t\t\n-\t\tassertTrue(\"Number of elements should be equal to 2^15\", exDoubleArr.getNumElements() == (int) Math.pow(2.0, 15.0));\n-\t\tassertTrue(\"Internal length should be 2^15\", exDoubleArr.getInternalLength() == (int) Math.pow(2.0, 15.0));\n+\t\tassertEquals(\"Number of elements should be equal to 2^15\", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());\n+\t\tassertEquals(\"Internal length should be 2^15\", (int) Math.pow(2.0, 15.0), eDA2.getInternalLength());\n \t\t\n-\t\texDoubleArr.addElement( 2.0 );\n+\t\teDA2.addElement( 2.0 );\n \t\t\n-\t\tassertTrue(\"Number of elements should be equals to 2^15 + 1\",\n-\t\t\t\t\t\t   exDoubleArr.getNumElements() == ( (int) Math.pow(2.0, 15.0) + 1 ) );\n-\t\tassertTrue(\"Internal length should be 2^16\", exDoubleArr.getInternalLength() == (int) Math.pow(2.0, 16.0));\n-\t\t\t\t\t\t   \n-\n+\t\tassertEquals(\"Number of elements should be equals to 2^15 + 1\",\n+\t\t        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );\n+\t\tassertEquals(\"Internal length should be 2^16\", (int) Math.pow(2.0, 16.0), eDA2.getInternalLength());\n \t}\n \n-\tpublic void testWithInitialCapacitAndExpansionFactor() {\n-\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray(3, 3.0f);\n+\tpublic void testWithInitialCapacityAndExpansionFactor() {\n \n-\t\tassertTrue(\"Initial internal length should be 3\", exDoubleArr.getInternalLength() == 3);\n-\t\tassertTrue(\"Initial number of elements should be 0\", exDoubleArr.getNumElements() == 0);\n+\t\tExpandableDoubleArray eDA3 = new ExpandableDoubleArray(3, 3.0f);\n+\t\tassertEquals(\"Initial internal length should be 3\", 3, eDA3.getInternalLength() );\n+\t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n \n \t\tint iterations = (int) Math.pow(3.0, 7.0);\n \n \t\tfor( int i = 0; i < iterations; i++) {\n-\t\t\texDoubleArr.addElement( i );\n+\t\t\teDA3.addElement( i );\n \t\t}\n \t\t\n-\t\tassertTrue(\"Number of elements should be equal to 3^7\", exDoubleArr.getNumElements() == (int) Math.pow(3.0, 7.0));\n-\t\tassertTrue(\"Internal length should be 3^7\", exDoubleArr.getInternalLength() == (int) Math.pow(3.0, 7.0));\n+\t\tassertEquals(\"Number of elements should be equal to 3^7\", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());\n+\t\tassertEquals(\"Internal length should be 3^7\", (int) Math.pow(3.0, 7.0), eDA3.getInternalLength());\n \t\t\n-\t\texDoubleArr.addElement( 2.0 );\n+\t\teDA3.addElement( 2.0 );\n \t\t\n-\t\tassertTrue(\"Number of elements should be equals to 3^7 + 1\",\n-\t\t\t\t\t\t   exDoubleArr.getNumElements() == ( (int) Math.pow(3.0, 7.0) + 1 ) );\n-\t\tassertTrue(\"Internal length should be 3^8\", exDoubleArr.getInternalLength() == (int) Math.pow(3.0, 8.0));\n+\t\tassertEquals(\"Number of elements should be equals to 3^7 + 1\",\n+\t\t\t( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );\n+\t\tassertEquals(\"Internal length should be 3^8\", (int) Math.pow(3.0, 8.0), eDA3.getInternalLength());\n \t\t\t\t\t\t   \n-\t\tassertTrue(\"Expansion factor should equal 3.0\", exDoubleArr.getExpansionFactor() == 3.0f);\n+\t\tassertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n \t}\n \t\n-\tpublic void testGetValues() {\n-\t\t\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\t\n-\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n-\t\t\n-\t\teDA.addElement(2.0);\n-\t\teDA.addElement(4.0);\n-\t\teDA.addElement(6.0);\n-\t\tdouble[] testArray = eDA.getValues();\n-\t\t\n-\t\tfor( int i = 0; i < eDA.getNumElements(); i++) {\n-\t\t\tassertTrue( \"The testArray values should equal the controlArray values, index i: \" + i +\n-\t\t\t\t\" does not match\", testArray[i] == controlArray[i]);\n-\t\t}\n-\t\t\n-\t}\n \t\n-\tpublic void testSetElementArbitraryExpansion() {\n-\t\t\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\t\n-\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n-\t\t\n-\t\teDA.addElement(2.0);\n-\t\teDA.addElement(4.0);\n-\t\teDA.addElement(6.0);\n-\t\teDA.setElement(1, 3.0);\n-\t\t\n-\t\t// Expand the array arbitrarily to 1000 items\n-\t\teDA.setElement(1000, 3.4);\n-\n-\t\tassertTrue( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength() == 1001);\n-\t\tassertTrue( \"The number of elements should now be 1001, it isn't\", eDA.getNumElements() == 1001);\n-\t\t\n-\t\tassertTrue( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", \n-\t\t\t\t\t\t\teDA.getElement( 760 ) == 0.0);\n-\t\t\n-\t\tassertTrue( \"The 1000th index should be 3.4, it isn't\", eDA.getElement(1000) == 3.4);\n-\t\tassertTrue( \"The 0th index should be 2.0, it isn't\", eDA.getElement(0) == 2.0);\t\t\n-\t\t\n-\t}\n-\t\n-\tpublic void testSetNumberOfElements() {\n-\t\t\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\tassertTrue( \"Number of elements should equal 6\", eDA.getNumElements() == 6);\n-\t\t\n-\t\teDA.setNumElements( 3 );\n-\t\tassertTrue( \"Number of elements should equal 3\", eDA.getNumElements() == 3);\n-\t\t\n-\t\ttry {\n-\t\t\teDA.setNumElements( -3 );\n-\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\n-\t\teDA.setNumElements(1024);\n-\t\tassertTrue( \"Number of elements should now be 1024\", eDA.getNumElements() == 1024);\n-\t\tassertTrue( \"Element 453 should be a default double\", eDA.getElement( 453 ) == 0.0);\n-\t\t\t\t\n-\t}\n-\t\n-\tpublic void testAddElementRolling() {\n-\t\t\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\t\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElementRolling( 2.0 );\n-\t\t\n-\t\tassertTrue( \"There should be 6 elements in the eda\", eDA.getNumElements() == 6);\n-\t\tassertTrue( \"The last element should be 2.0\", eDA.getElement( eDA.getNumElements() -1 ) == 2.0);\n-\t\t\n-\t\tfor( int i = 0; i  < 1024; i++ ) {\n-\t\t\teDA.addElementRolling( i );\n-\t\t}\n-\t\t\n-\t\tassertTrue( \"We just inserted 1024 rolling elements, num elements should still be 6\", eDA.getNumElements() == 6);\n-\t\tassertTrue( \"Even though there are only 6 element, internal storage should be 2048\", eDA.getInternalLength() == 2048);\n-\t\tassertEquals( \"The start index should be 1025\", 1025, eDA.getStartIndex());\n-\t\t\n-\t\teDA.setStartIndex( 0 );\n-\t\t\n-\t\tassertEquals( \"There shoud now be 1031 elements in this array\", 1031, eDA.getNumElements(), 0.001);\n-\t\tassertEquals( \"The first element should be 1.0\",1.0,  eDA.getElement(0), 0.001);\n-\t\t\n-\t\ttry {\n-\t\t\teDA.setStartIndex( 100000 );\n-\t\t\tfail( \"TRying to set the start index outside of the current array should have caused an error\");\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\n-\t\ttry {\n-\t\t\teDA.setStartIndex( -1 );\n-\t\t\tfail( \"TRying to set the start index to a negative number should have caused an error\");\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\t}\n-\n \t/** TEST ERROR CONDITIONS **/\n \n \tpublic void testIllegalInitialCapacity() {\n \t\t}\n \t}\n \t\n-\tpublic void testGetOutOfBounds() {\n-\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\teDA.addElement(2.0);\n-\t\teDA.addElement(3.0);\n-\t\t\n-\t\ttry {\n-\t\t\teDA.getElement(0);\n-\t\t\teDA.getElement(1);\n-\t\t} catch( NoSuchElementException nsee ) {\n-\t\t\tfail( \"There are values for index 0 and 1, this should not have thrown an exception\");\n-\t\t}\n-\t\t\n-\t\ttry {\n-\t\t\teDA.getElement(2);\n-\t\t\tfail( \"There are 2 elements in the array, you asked for index 2 implying that there are 3.  \" +\n-\t\t\t\t\"exception should have been thrown\");\n-\t\t} catch( NoSuchElementException nsee ) {\n-\t\t}\t\n-\t\t\n-\t\ttry {\n-\t\t\teDA.getElement(-234);\t\n-\t\t\tfail( \"You tried to retrieve a negative index, this should have thrown an exception. \" );\n-\t\t} catch( IllegalArgumentException iae) {\n-\t\t}\n-\t}\n-\n-\tpublic void testSetOutOfBounds() {\n-\n-\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n-\t\t\n-\t\ttry {\n-\t\t\teDA.setElement( -3, 3.4 );\n-\t\t\tfail( \"You tried to set an element with a negative index, thisshould have thrown an error\");\n-\t\t} catch( IllegalArgumentException iae ) {\n-\t\t}\n-\t}\n-\n }\n--- a/src/test/org/apache/commons/math/TestStatisticTest.java\n+++ b/src/test/org/apache/commons/math/TestStatisticTest.java\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n-import junit.framework.AssertionFailedError;\n /**\n  * Test cases for the TestStatistic class.\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/05/15 21:58:23 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/16 03:55:34 $\n  */\n \n public final class TestStatisticTest extends TestCase {", "timestamp": 1053057334, "metainfo": ""}