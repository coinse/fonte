{"sha": "9d1be9a1013a799940ed80eb7a78f1a79f12e54c", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20782 Submitted by:\tHotFusionMan@Yahoo.com  I added this, but there are changes I'd like to make in the near future. Only the \"running\" aspects of the variance calc should be in the insertValue function, all other calculation should be in the getVariance function.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n \n /**\n  *\n- * Accumulates univariate statistics for values fed in \n+ * Accumulates univariate statistics for values fed in\n  * through the addValue() method.  Does not store raw data values.\n  * All data are represented internally as doubles.\n- * Integers, floats and longs can be added, but will be converted\n- * to doubles by addValue().  \n+ * Integers, floats and longs can be added, but they will be converted\n+ * to doubles by addValue().\n  *\n  * @author Phil Steitz\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n- * @version $Revision: 1.4 $ $Date: 2003/06/14 04:17:49 $\n- * \n+ * @author <a href=\"mailto:HotFusionMan@Yahoo.com\">Albert Davidson Chou</a>\n+ * @version $Revision: 1.5 $ $Date: 2003/06/16 14:29:30 $\n+ *\n */\n public class UnivariateImpl implements Univariate, Serializable {\n \n     /** hold the window size **/\n     private int windowSize = Univariate.INFINITE_WINDOW;\n \n-    /** Just in case, the windowSize is not inifinite, we need to\n+    /** Just in case the windowSize is not infinite, we need to\n      *  keep an array to remember values 0 to N\n      */\n     private DoubleArray doubleArray;\n+\n+    /** count of values that have been added */\n+    private int n = 0;\n+\n+    /** min of values that have been added */\n+    private double min = Double.MAX_VALUE;\n+\n+    /** max of values that have been added */\n+    private double max = Double.MIN_VALUE;\n+\n+    /** product of values that have been added */\n+    private double product = Double.NaN;\n+\n+    /** mean of values that have been added */\n+    private double mean = Double.NaN ;\n+\n+    /** running ( variance * (n - 1) ) of values that have been added */\n+    private double pre_variance = Double.NaN ;\n+\n+    /** variance of values that have been added */\n+    private double variance = Double.NaN ;\n \n     /** running sum of values that have been added */\n     private double sum = 0.0;\n \n     /** running sum of 3rd powers that have been added */\n     private double sumCube = 0.0;\n-    \n+\n     /** running sum of 4th powers that have been added */\n     private double sumQuad = 0.0;\n-    \n-    /** count of values that have been added */\n-    private int n = 0;\n-\n-    /** min of values that have been added */\n-    private double min = Double.MAX_VALUE;\n-\n-    /** max of values that have been added */\n-    private double max = Double.MIN_VALUE;\n-\n-    /** product of values that have been added */\n-    private double product = Double.NaN;\n-\n-    /** Creates new univariate with an inifinite window */\n+\n+    /** Creates new univariate with an infinite window */\n     public UnivariateImpl() {\n         clear();\n     }\n-    \n+\n     /** Creates a new univariate with a fixed window **/\n     public UnivariateImpl(int window) {\n         windowSize = window;\n         doubleArray = new FixedDoubleArray( window );\n     }\n \n-     \n     /**\n      * @see org.apache.commons.math.stat.Univariate#addValue(double)\n      */\n         insertValue(v);\n     }\n \n-    \n     /**\n      * @see org.apache.commons.math.stat.Univariate#getMean()\n      */\n     public double getMean() {\n-        if (n == 0) {\n+        return mean ;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+     */\n+    public double getGeometricMean() {\n+        if ((product <= 0.0) || (n == 0)) {\n             return Double.NaN;\n         } else {\n-            return (sum / (double) n );\n-        }\n-     }\n-\n-     \n-    /**\n-     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-     */\n-    public double getGeometricMean() {\n-        if ((product <= 0.0) || (n == 0)) {\n-            return Double.NaN; \n-        } else {\n             return Math.pow(product,( 1.0 / (double) n ) );\n         }\n     }\n      */\n     public double getStandardDeviation() {\n         double variance = getVariance();\n+\n         if ((variance == 0.0) || (variance == Double.NaN)) {\n             return variance;\n         } else {\n             return Math.sqrt(variance);\n         }\n     }\n-    \n-    /**\n-     * Returns the variance of the values that have been added as described by\n-     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (5) for k-Statistics</a>.\n-     * \n+\n+    /**\n+     * Returns the variance of the values that have been added via West's\n+     * algorithm as described by\n+     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n+     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+     * vol. 22 no. 9, pp. 526-531.</a>.\n+     *\n      * @return The variance of a set of values.  Double.NaN is returned for\n      *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n      */\n     public double getVariance() {\n-        double variance = Double.NaN;\n-\n-        if( n == 1 ) {\n-            variance = 0.0;\n-        } else if( n > 1 ) {\n-            variance = (((double) n) * sumsq - (sum * sum)) / (double) (n * (n - 1));    \n-        }\n-\n-        return variance < 0 ? 0.0 : variance;\n-    }\n-     \n+        return variance ;\n+    }\n+\n     /**\n      * Returns the skewness of the values that have been added as described by\n      * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n-     * \n+     *\n      * @return The skew of a set of values.  Double.NaN is returned for\n      *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n      */\n     public double getSkewness() {\n-        \n+\n         if( n < 1) return Double.NaN;\n-        if( n <= 2 ) return 0.0;                  \n-            \n-        return ( 2 * Math.pow(sum, 3) - 3 * sum * sumsq + ((double) (n * n)) * sumCube ) / \n-               ( (double) (n * (n - 1) * (n - 2)) ) ;  \n-    }\n-    \n+        if( n <= 2 ) return 0.0;\n+\n+        return ( 2 * Math.pow(sum, 3) - 3 * sum * sumsq + ((double) (n * n)) * sumCube ) /\n+               ( (double) (n * (n - 1) * (n - 2)) ) ;\n+    }\n+\n     /**\n      * Returns the kurtosis of the values that have been added as described by\n      * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n-     * \n+     *\n      * @return The kurtosis of a set of values.  Double.NaN is returned for\n      *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n      */\n     public double getKurtosis() {\n-        \n+\n         if( n < 1) return Double.NaN;\n         if( n <= 3 ) return 0.0;\n-        \n+\n         double x1 = -6 * Math.pow(sum, 4);\n         double x2 = 12 * ((double) n) * Math.pow(sum, 2) * sumsq;\n         double x3 = -3 * ((double) (n * (n - 1))) * Math.pow(sumsq,2);\n         double x4 = -4 * ((double) (n * (n + 1))) * sum * sumCube;\n         double x5 = Math.pow(((double) n),2) * ((double) (n+1)) * sumQuad;\n-        \n-        return (x1 + x2 + x3 + x4 + x5) / \n+\n+        return (x1 + x2 + x3 + x4 + x5) /\n                ( (double) (n * (n - 1) * (n - 2) * (n - 3)) );\n-    } \n-    \n+    }\n+\n     /**\n      * Called in \"addValue\" to insert a new value into the statistic.\n      * @param v The value to be added.\n      */\n     private void insertValue(double v) {\n-\n         // The default value of product is NaN, if you\n         // try to retrieve the product for a univariate with\n         // no values, we return NaN.\n         // If this is the first call to insertValue, we want\n         // to set product to 1.0, so that our first element\n         // is not \"cancelled\" out by the NaN.\n+        //\n+        // For the first value added, the mean is that value,\n+        // and the variance is zero.\n         if( n == 0 ) {\n-            product = 1.0;\n+            product = 1.0 ;\n+            mean = v ;\n+            pre_variance = 0.0 ;\n+            variance = 0.0 ;\n         }\n \n         if( windowSize != Univariate.INFINITE_WINDOW ) {\n                 sum -= discarded;\n                 sumsq -= discarded * discarded;\n                 sumCube -= Math.pow(discarded, 3);\n-                sumQuad -= Math.pow(discarded, 4); \n-                \n+                sumQuad -= Math.pow(discarded, 4);\n+\n                 if(discarded == min) {\n                     min = doubleArray.getMin();\n                 } else if(discarded == max){\n                     max = doubleArray.getMax();\n-                } \n-                \n+                }\n+\n                 if(product != 0.0){\n                     // can safely remove discarded value\n-                    product *=  v / discarded;\n+                    product *= v / discarded;\n                 } else if(discarded == 0.0){\n                     // need to recompute product\n                     product = 1.0;\n                 } // else product = 0 and will still be 0 after discard\n \n             } else {\n-                doubleArray.addElement( v );            \n-                n += 1.0;\n+                doubleArray.addElement( v );\n+                n += 1 ;\n                 if (v < min) {\n                     min = v;\n                 }\n                 product *= v;\n             }\n         } else {\n-            // If the windowSize is inifinite please don't take the time to\n+            // If the windowSize is infinite please don't take the time to\n             // worry about storing any values.  We don't need to discard the\n             // influence of any single item.\n-            n += 1.0;\n+            n += 1 ;\n             if (v < min) {\n                 min = v;\n-            } \n+            }\n             if (v > max) {\n                 max = v;\n-            } \n+            }\n             product *= v;\n-        }\n-        \n+\n+            if ( n > 1 )\n+            {\n+                double deviationFromMean = v - mean ;\n+                double deviationFromMean_overN = deviationFromMean / n ;\n+                mean += deviationFromMean_overN ;\n+                pre_variance += (n - 1) * deviationFromMean * deviationFromMean_overN ;\n+                variance = pre_variance / (n - 1) ;\n+            }\n+        }\n+\n         sum += v;\n         sumsq += v * v;\n         sumCube += Math.pow(v,3);\n      * @return Value of property max.\n      */\n     public double getMax() {\n-        if (n == 0) { \n+        if (n == 0) {\n             return Double.NaN;\n         } else {\n             return max;\n      * @return Value of property min.\n      */\n     public double getMin() {\n-        if (n == 0) { \n+        if (n == 0) {\n             return Double.NaN;\n         } else {\n             return min;\n     public double getSumCube() {\n         return sumCube;\n     }\n-    \n+\n     /** Getter for property sumQuad.\n      * @return Value of property sumQuad.\n      */\n     public double getSumQuad() {\n         return sumQuad;\n     }\n-    \n-    /**\n-     * Generates a text report displaying \n+\n+    /**\n+     * Generates a text report displaying\n      * univariate statistics from values that\n      * have been added.\n      * @return String with line feeds displaying statistics\n         outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n         return outBuffer.toString();\n     }\n-    \n-    /** \n-     * Resets all sums to 0, resets min and max \n+\n+    /**\n+     * Resets all sums, product, mean, and variance to 0; resets min and max.\n      */\n     public void clear() {\n         this.sum = this.sumsq = this.sumCube = this.sumQuad = 0.0;\n         this.min = Double.MAX_VALUE;\n         this.max = Double.MIN_VALUE;\n         this.product = Double.NaN;\n+        this.mean = Double.NaN ;\n+        this.variance = this.pre_variance = Double.NaN ;\n     }\n \n     /* (non-Javadoc)\n--- a/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author Mark R. Diggory\n- * @version $Revision: 1.5 $ $Date: 2003/06/04 04:03:55 $\n+ * @version $Revision: 1.6 $ $Date: 2003/06/16 14:29:30 $\n  */\n \n public class CertifiedDataTest extends TestCase {\n \t\tassertEquals(\"Lottery: mean\", mean, u.getMean(), .000000000001);\t\n \t\t\n \t\tloadStats(\"data/PiDigits.txt\");\n-\t\tassertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .00000000000001);\n-\t\tassertEquals(\"PiDigits: mean\", mean, u.getMean(), .00000000000001);\t\n+\t\tassertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .0000000000001);\n+\t\tassertEquals(\"PiDigits: mean\", mean, u.getMean(), .0000000000001);\t\n \n \t\tloadStats(\"data/Mavro.txt\");\n \t\tassertEquals(\"Mavro: std\", std, u.getStandardDeviation(), .00000000000001);\n \t\tassertEquals(\"Lottery: mean\", mean, u.getMean(), .000000000001);\t\t\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n \t\tloadStats(\"data/PiDigits.txt\");\n-\t\tassertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .00000000000001);\n-\t\tassertEquals(\"PiDigits: mean\", mean, u.getMean(), .00000000000001);\n+\t\tassertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .0000000000001);\n+\t\tassertEquals(\"PiDigits: mean\", mean, u.getMean(), .0000000000001);\n \t\t\n \t\tloadStats(\"data/Mavro.txt\");\n \t\tassertEquals(\"Mavro: std\", std, u.getStandardDeviation(), .00000000000001);", "timestamp": 1055773770, "metainfo": ""}