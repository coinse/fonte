{"sha": "da153bf279f297890ec27bfd03e91bce36af2ef4", "log": "improved Well pseudo random numbers generators performances by inlining transforms and using indirection arrays to avoid index computation  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/AbstractWell.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractWell.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -8068371019303673353L;\n \n-    /** Number of bits blocks in the pool. */\n-    private final int r;\n-\n     /** Bit mask preserving the first w - p bits in a w bits block. */\n-    private final int mp;\n+    protected final int mp;\n \n     /** Bit mask preserving the last p bits in a w bits block. */\n-    private final int mpTilde;\n-\n-    /** First parameter of the algorithm. */\n-    private final int m1;\n-\n-    /** Second parameter of the algorithm. */\n-    private final int m2;\n-\n-    /** Third parameter of the algorithm. */\n-    private final int m3;\n+    protected final int mpTilde;\n \n     /** Current index in the bytes pool. */\n-    private int index;\n+    protected int index;\n \n     /** Bytes pool. */\n-    private final int[] v;\n+    protected final int[] v;\n+    protected final int[] iRm1;\n+    protected final int[] iRm2;\n+    protected final int[] i1;\n+    protected final int[] i2;\n+    protected final int[] i3;\n \n     /** Creates a new random number generator.\n      * <p>The instance is initialized using the current time as the\n         // of w bits blocks, w is the block size (always 32 in the original paper)\n         // and p is the number of unused bits in the last block\n         final int w = 32;\n-        this.r      = (k + w - 1) / w;\n+        final int r = (k + w - 1) / w;\n         final int p = r * w - k;\n \n         // set up  generator parameters\n         this.mp      = (-1) << p;\n         this.mpTilde = ~mp;\n-        this.m1      = m1;\n-        this.m2      = m2;\n-        this.m3      = m3;\n         this.v       = new int[r];\n         this.index   = 0;\n+\n+        // set up indirection indices\n+        iRm1 = new int[r];\n+        iRm2 = new int[r];\n+        i1   = new int[r];\n+        i2   = new int[r];\n+        i3   = new int[r];\n+        for (int j = 0; j < r; ++j) {\n+            iRm1[j] = (j + r - 1) % r;\n+            iRm2[j] = (j + r - 2) % r;\n+            i1[j]   = (j + m1)    % r;\n+            i2[j]   = (j + m2)    % r;\n+            i3[j]   = (j + m3)    % r;\n+        }\n \n         // initialize the pool content\n         setSeed(seed);\n         setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n     }\n \n-    /** Generate next pseudorandom number.\n-     * <p>This method is the core generation algorithm. It is used by all the\n-     * public generation methods for the various primitive types {@link\n-     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n-     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n-     * {@link #next(int)} and {@link #nextLong()}.</p>\n-     * <p>This implementation is the general WELL algorithm, described in\n-     * a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto\n-     * <a href=\"http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf\">Improved\n-     *  Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM\n-     *  Transactions on Mathematical Software, 32, 1 (2006).</p>\n-     * @param bits number of random bits to produce\n-     * @return random bits generated\n-     */\n-    protected int next(final int bits) {\n-\n-        final int iRm1   = (index + r - 1) % r;\n-        final int iRm2   = (index + r - 2) % r;\n-        final int i1     = (index + m1) % r;\n-        final int i2     = (index + m2) % r;\n-        final int i3     = (index + m3) % r;\n-\n-        final int z0 = (mp & v[iRm1]) ^ (mpTilde & v[iRm2]);\n-        final int z1 = t0(v[index])   ^ t1(v[i1]);\n-        final int z2 = t2(v[i2])      ^ t3(v[i3]);\n-        final int z3 = z1 ^ z2;\n-        final int z4 = t4(z0) ^ t5(z1) ^ t6(z2) ^ t7(z3);\n-\n-        v[index] = z3;\n-        v[iRm1]  = z4;\n-        v[iRm2] &= mp;\n-        index    = iRm1;\n-\n-        return z4 >>> (32 - bits);\n-\n-    }\n-\n-    /** Apply transform M<sub>0</sub> to a bits block.\n-     * @param x bits block to apply transform to\n-     * @return M<sub>0</sub>(x)\n-     */\n-    protected int m0(final int x) {\n-        return 0;\n-    }\n-\n-    /** Apply transform M<sub>1</sub> to a bits block.\n-     * @param x bits block to apply transform to\n-     * @return M<sub>1</sub>(x)\n-     */\n-    protected int m1(final int x) {\n-        return x;\n-    }\n-\n-    /** Apply transform M<sub>2</sub> to a bits block.\n-     * @param t parameter of the transform\n-     * @param x bits block to apply transform to\n-     * @return M<sub>2, t</sub>(x)\n-     */\n-    protected int m2(final int t, final int x) {\n-        return (t >= 0) ? (x >>> t) : (x << -t);\n-    }\n-\n-    /** Apply transform M<sub>3</sub> to a bits block.\n-     * @param t parameter of the transform\n-     * @param x bits block to apply transform to\n-     * @return M<sub>3, t</sub>(x)\n-     */\n-    protected int m3(final int t, final int x) {\n-        return x ^ ((t >= 0) ? (x >>> t) : (x << -t));\n-    }\n-\n-    /** Apply transform M<sub>4</sub> to a bits block.\n-     * @param a parameter of the transform\n-     * @param x bits block to apply transform to\n-     * @return M<sub>4, a</sub>(x)\n-     */\n-    protected int m4(final int a, final int x) {\n-        final int shiftedX = x >>> 1;\n-        return ((x & 0x80000000) != 0) ? (shiftedX ^ a) : shiftedX;\n-    }\n-\n-    /** Apply transform M<sub>5</sub> to a bits block.\n-     * @param t first parameter of the transform\n-     * @param b second parameter of the transform\n-     * @param x bits block to apply transform to\n-     * @return M<sub>5, t, b</sub>(x)\n-     */\n-    protected int m5(final int t, final int b, final int x) {\n-        // table I of the paper specifies that a left shift for positive t and\n-        // a right shift for negative t, however, reference implementation does\n-        // the opposite (and in fact this transform is used only by Well512a\n-        // with t = -28). Here, we follow the reference implementation with a\n-        // left shift for NEGATIVE t\n-        final int shiftedX = (t >= 0) ? (x >>> t) : (x << -t);\n-        return x ^ (shiftedX & b);\n-    }\n-\n-    /** Apply transform M<sub>6</sub> to a bits block.\n-     * @param q first parameter of the transform\n-     * @param dsMask second parameter of the transform as a bit mask\n-     * @param tMask third parameter of the transform as a bit mask\n-     * @param a fourth parameter of the transform\n-     * @param x bits block to apply transform to\n-     * @return M<sub>6, q, s, t, a</sub>(x)\n-     */\n-    protected int m6(final int q, final int dsMask, final int tMask, final int a, final int x) {\n-        final int lShiftedX = x << q;\n-        final int rShiftedX = x >>> (32 - q);\n-        final int z         = (lShiftedX ^ rShiftedX) & dsMask;\n-        return ((x & tMask) != 0) ? (z ^ a) : z;\n-    }\n-\n-    /** Apply transform T<sub>0</sub> to a bits block.\n-     * @param vi0 bits block to apply transform to\n-     * @return T<sub>0</sub> v<sub>i,0</sub>\n-     */\n-    protected abstract int t0(int vi0);\n-\n-    /** Apply transform T<sub>1</sub> to a bits block.\n-     * @param vim1 bits block to apply transform to\n-     * @return T<sub>1</sub> v<sub>i,m1</sub>\n-     */\n-    protected abstract int t1(int vim1);\n-\n-    /** Apply transform T<sub>2</sub> to a bits block.\n-     * @param vim2 bits block to apply transform to\n-     * @return T<sub>2</sub> v<sub>i,m2</sub>\n-     */\n-    protected abstract int t2(int vim2);\n-\n-    /** Apply transform T<sub>3</sub> to a bits block.\n-     * @param vim3 bits block to apply transform to\n-     * @return T<sub>3</sub> v<sub>i,m3</sub>\n-     */\n-    protected abstract int t3(int vim3);\n-\n-    /** Apply transform T<sub>4</sub> to a bits block.\n-     * @param z0 bits block to apply transform to\n-     * @return T<sub>4</sub> z<sub>0</sub>\n-     */\n-    protected abstract int t4(int z0);\n-\n-    /** Apply transform T<sub>5</sub> to a bits block.\n-     * @param z1 bits block to apply transform to\n-     * @return T<sub>5</sub> z<sub>1</sub>\n-     */\n-    protected abstract int t5(int z1);\n-\n-    /** Apply transform T<sub>6</sub> to a bits block.\n-     * @param z2 bits block to apply transform to\n-     * @return T<sub>6</sub> z<sub>2</sub>\n-     */\n-    protected abstract int t6(int z2);\n-\n-    /** Apply transform T<sub>7</sub> to a bits block.\n-     * @param z3 bits block to apply transform to\n-     * @return T<sub>7</sub> z<sub>3</sub>\n-     */\n-    protected abstract int t7(int z3);\n+    /** {@inheritDoc} */\n+    protected abstract int next(final int bits);\n \n }\n--- a/src/main/java/org/apache/commons/math/random/Well1024a.java\n+++ b/src/main/java/org/apache/commons/math/random/Well1024a.java\n public class Well1024a extends AbstractWell {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -5403981908127539981L;\n+    private static final long serialVersionUID = 5680173464174485492L;\n \n     /** Number of bits in the pool. */\n     private static final int K = 1024;\n     }\n \n     /** {@inheritDoc} */\n-    protected int t0(final int vi0) {\n-        return m1(vi0);\n+    protected int next(final int bits) {\n+\n+        final int indexRm1 = iRm1[index];\n+        final int indexRm2 = iRm2[index];\n+\n+        final int v0       = v[index];\n+        final int vM1      = v[i1[index]];\n+        final int vM2      = v[i2[index]];\n+        final int vM3      = v[i3[index]];\n+\n+        final int z0 = v[indexRm1];\n+        final int z1 = v0  ^ (vM1 ^ (vM1 >>> 8));\n+        final int z2 = (vM2 ^ (vM2 << 19)) ^ (vM3 ^ (vM3 << 14));\n+        final int z3 = z1      ^ z2;\n+        final int z4 = (z0 ^ (z0 << 11)) ^ (z1 ^ (z1 << 7)) ^ (z2 ^ (z2 << 13));\n+\n+        v[index]     = z3;\n+        v[indexRm1]  = z4;\n+        v[indexRm2] &= mp;\n+        index        = indexRm1;\n+\n+        return z4 >>> (32 - bits);\n+\n     }\n-\n-    /** {@inheritDoc} */\n-    protected int t1(final int vim1) {\n-        return m3(8, vim1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t2(final int vim2) {\n-        return m3(-19, vim2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t3(final int vim3) {\n-        return m3(-14, vim3);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t4(final int z0) {\n-        return m3(-11, z0);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t5(final int z1) {\n-        return m3(-7, z1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t6(final int z2) {\n-        return m3(-13, z2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t7(final int z3) {\n-        return m0(z3);\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/Well19937a.java\n+++ b/src/main/java/org/apache/commons/math/random/Well19937a.java\n public class Well19937a extends AbstractWell {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -8052371714518610855L;\n+    private static final long serialVersionUID = -7462102162223815419L;\n \n     /** Number of bits in the pool. */\n     private static final int K = 19937;\n     }\n \n     /** {@inheritDoc} */\n-    protected int t0(final int vi0) {\n-        return m3(-25, vi0);\n+    protected int next(final int bits) {\n+\n+        final int indexRm1 = iRm1[index];\n+        final int indexRm2 = iRm2[index];\n+\n+        final int v0       = v[index];\n+        final int vM1      = v[i1[index]];\n+        final int vM2      = v[i2[index]];\n+        final int vM3      = v[i3[index]];\n+\n+        final int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);\n+        final int z1 = (v0 ^ (v0 << 25))  ^ (vM1 ^ (vM1 >>> 27));\n+        final int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));\n+        final int z3 = z1      ^ z2;\n+        final int z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));\n+\n+        v[index]     = z3;\n+        v[indexRm1]  = z4;\n+        v[indexRm2] &= mp;\n+        index        = indexRm1;\n+\n+        return z4 >>> (32 - bits);\n+\n     }\n-\n-    /** {@inheritDoc} */\n-    protected int t1(final int vim1) {\n-        return m3(27, vim1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t2(final int vim2) {\n-        return m2(9, vim2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t3(final int vim3) {\n-        return m3(1, vim3);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t4(final int z0) {\n-        return m1(z0);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t5(final int z1) {\n-        return m3(-9, z1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t6(final int z2) {\n-        return m3(-21, z2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t7(final int z3) {\n-        return m3(21, z3);\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/Well19937c.java\n+++ b/src/main/java/org/apache/commons/math/random/Well19937c.java\n  * @since 2.2\n \n  */\n-public class Well19937c extends Well19937a {\n+public class Well19937c extends AbstractWell {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -7203498180754925124L;\n+\n+    /** Number of bits in the pool. */\n+    private static final int K = 19937;\n+\n+    /** First parameter of the algorithm. */\n+    private static final int M1 = 70;\n+\n+    /** Second parameter of the algorithm. */\n+    private static final int M2 = 179;\n+\n+    /** Third parameter of the algorithm. */\n+    private static final int M3 = 449;\n \n     /** Creates a new random number generator.\n      * <p>The instance is initialized using the current time as the\n      * seed.</p>\n      */\n     public Well19937c() {\n+        super(K, M1, M2, M3);\n     }\n \n     /** Creates a new random number generator using a single int seed.\n      * @param seed the initial seed (32 bits integer)\n      */\n     public Well19937c(int seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** Creates a new random number generator using an int array seed.\n      * the seed of the generator will be related to the current time\n      */\n     public Well19937c(int[] seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** Creates a new random number generator using a single long seed.\n      * @param seed the initial seed (64 bits integer)\n      */\n     public Well19937c(long seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** {@inheritDoc} */\n     protected int next(final int bits) {\n \n-        // compute raw value given by WELL19937a generator\n-        // which is NOT maximally-equidistributed\n-        int z = super.next(32);\n+        final int indexRm1 = iRm1[index];\n+        final int indexRm2 = iRm2[index];\n+\n+        final int v0       = v[index];\n+        final int vM1      = v[i1[index]];\n+        final int vM2      = v[i2[index]];\n+        final int vM3      = v[i3[index]];\n+\n+        final int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);\n+        final int z1 = (v0 ^ (v0 << 25))  ^ (vM1 ^ (vM1 >>> 27));\n+        final int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));\n+        final int z3 = z1      ^ z2;\n+        int z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));\n+\n+        v[index]     = z3;\n+        v[indexRm1]  = z4;\n+        v[indexRm2] &= mp;\n+        index        = indexRm1;\n+\n \n         // add Matsumoto-Kurita tempering\n         // to get a maximally-equidistributed generator\n-        z = z ^ ((z <<  7) & 0xe46e1700);\n-        z = z ^ ((z << 15) & 0x9b868000);\n+        z4 = z4 ^ ((z4 <<  7) & 0xe46e1700);\n+        z4 = z4 ^ ((z4 << 15) & 0x9b868000);\n \n-        return z >>> (32 - bits);\n+        return z4 >>> (32 - bits);\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/random/Well44497a.java\n+++ b/src/main/java/org/apache/commons/math/random/Well44497a.java\n public class Well44497a extends AbstractWell {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 5154222742730470272L;\n+    private static final long serialVersionUID = -3859207588353972099L;\n \n     /** Number of bits in the pool. */\n     private static final int K = 44497;\n     }\n \n     /** {@inheritDoc} */\n-    protected int t0(final int vi0) {\n-        return m3(-24, vi0);\n+    protected int next(final int bits) {\n+\n+        final int indexRm1 = iRm1[index];\n+        final int indexRm2 = iRm2[index];\n+\n+        final int v0       = v[index];\n+        final int vM1      = v[i1[index]];\n+        final int vM2      = v[i2[index]];\n+        final int vM3      = v[i3[index]];\n+\n+        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n+        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n+        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n+        final int z3       = z1      ^ z2;\n+        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n+        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n+        final int z4       = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n+\n+        v[index]     = z3;\n+        v[indexRm1]  = z4;\n+        v[indexRm2] &= mp;\n+        index        = indexRm1;\n+\n+        return z4 >>> (32 - bits);\n+\n     }\n-\n-    /** {@inheritDoc} */\n-    protected int t1(final int vim1) {\n-        return m3(30, vim1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t2(final int vim2) {\n-        return m3(-10, vim2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t3(final int vim3) {\n-        return m2(-26, vim3);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t4(final int z0) {\n-        return m1(z0);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t5(final int z1) {\n-        return m3(20, z1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t6(final int z2) {\n-        // table II of the paper specifies t6 to be m6(9, d14, t5, 0xb729fcec, z2)\n-        // however, the reference implementation uses m6(9, d26, t17, 0xb729fcec, z2).\n-        // Here, we follow the reference implementation\n-        return m6(9, (-1) ^ (0x1 << 26), 0x1 << 17, 0xb729fcec, z2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t7(final int z3) {\n-        return m1(z3);\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/Well44497b.java\n+++ b/src/main/java/org/apache/commons/math/random/Well44497b.java\n  * @since 2.2\n \n  */\n-public class Well44497b extends Well44497a {\n+public class Well44497b extends AbstractWell {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4032007538246675492L;\n+\n+    /** Number of bits in the pool. */\n+    private static final int K = 44497;\n+\n+    /** First parameter of the algorithm. */\n+    private static final int M1 = 23;\n+\n+    /** Second parameter of the algorithm. */\n+    private static final int M2 = 481;\n+\n+    /** Third parameter of the algorithm. */\n+    private static final int M3 = 229;\n \n     /** Creates a new random number generator.\n      * <p>The instance is initialized using the current time as the\n      * seed.</p>\n      */\n     public Well44497b() {\n+        super(K, M1, M2, M3);\n     }\n \n     /** Creates a new random number generator using a single int seed.\n      * @param seed the initial seed (32 bits integer)\n      */\n     public Well44497b(int seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** Creates a new random number generator using an int array seed.\n      * the seed of the generator will be related to the current time\n      */\n     public Well44497b(int[] seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** Creates a new random number generator using a single long seed.\n      * @param seed the initial seed (64 bits integer)\n      */\n     public Well44497b(long seed) {\n-        super(seed);\n+        super(K, M1, M2, M3, seed);\n     }\n \n     /** {@inheritDoc} */\n \n         // compute raw value given by WELL44497a generator\n         // which is NOT maximally-equidistributed\n-        int z = super.next(32);\n+        final int indexRm1 = iRm1[index];\n+        final int indexRm2 = iRm2[index];\n+\n+        final int v0       = v[index];\n+        final int vM1      = v[i1[index]];\n+        final int vM2      = v[i2[index]];\n+        final int vM3      = v[i3[index]];\n+\n+        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n+        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n+        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n+        final int z3       = z1      ^ z2;\n+        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n+        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n+        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n+\n+        v[index]     = z3;\n+        v[indexRm1]  = z4;\n+        v[indexRm2] &= mp;\n+        index        = indexRm1;\n \n         // add Matsumoto-Kurita tempering\n         // to get a maximally-equidistributed generator\n-        z = z ^ ((z <<  7) & 0x93dd1400);\n-        z = z ^ ((z << 15) & 0xfa118000);\n+        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\n+        z4 = z4 ^ ((z4 << 15) & 0xfa118000);\n \n-        return z >>> (32 - bits);\n+        return z4 >>> (32 - bits);\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/random/Well512a.java\n+++ b/src/main/java/org/apache/commons/math/random/Well512a.java\n public class Well512a extends AbstractWell {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 8706771840051210473L;\n+    private static final long serialVersionUID = -6104179812103820574L;\n \n     /** Number of bits in the pool. */\n     private static final int K = 512;\n     }\n \n     /** {@inheritDoc} */\n-    protected int t0(final int vi0) {\n-        return m3(-16, vi0);\n-    }\n+    protected int next(final int bits) {\n \n-    /** {@inheritDoc} */\n-    protected int t1(final int vim1) {\n-        return m3(-15, vim1);\n-    }\n+        final int indexRm1 = iRm1[index];\n \n-    /** {@inheritDoc} */\n-    protected int t2(final int vim2) {\n-        return m3(11, vim2);\n-    }\n+        final int vi = v[index];\n+        final int vi1 = v[i1[index]];\n+        final int vi2 = v[i2[index]];\n+        final int z0 = v[indexRm1];\n+        // m3: x ^ ((t >= 0) ? (x >>> t) : (x << -t));\n \n-    /** {@inheritDoc} */\n-    protected int t3(final int vim3) {\n-        return m0(vim3);\n-    }\n+        final int z1 = (vi ^ (vi << 16))   ^ (vi1 ^ (vi1 << 15));\n+        final int z2 = vi2 ^ (vi2 >>> 11);\n+        final int z3 = z1 ^ z2;\n+        final int z4 = (z0 ^ (z0 << 2)) ^ (z1 ^ (z1 << 18)) ^ (z2 << 28) ^ (z3 ^ ((z3 << 5) & 0xda442d24));\n \n-    /** {@inheritDoc} */\n-    protected int t4(final int z0) {\n-        return m3(-2, z0);\n-    }\n+        v[index] = z3;\n+        v[indexRm1]  = z4;\n+        index    = indexRm1;\n \n-    /** {@inheritDoc} */\n-    protected int t5(final int z1) {\n-        return m3(-18, z1);\n-    }\n+        return z4 >>> (32 - bits);\n \n-    /** {@inheritDoc} */\n-    protected int t6(final int z2) {\n-        // table II of the paper specifies t6 to be m3(-28, z2)\n-        // however, the reference implementation uses m2(-28, z2).\n-        // Here, we follow the reference implementation\n-        return m2(-28, z2);\n-    }\n-\n-    /** {@inheritDoc} */\n-    protected int t7(final int z3) {\n-        return m5(-5, 0xda442d24, z3);\n     }\n \n }", "timestamp": 1285020367, "metainfo": ""}