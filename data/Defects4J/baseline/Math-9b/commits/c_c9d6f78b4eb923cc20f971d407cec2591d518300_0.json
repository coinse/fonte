{"sha": "c9d6f78b4eb923cc20f971d407cec2591d518300", "log": "Adding unit test for SparseFieldMatrix   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.linear.decomposition.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SparseFieldMatrix} class.\n+ *\n+ * @version $Revision: 728186 $ $Date: 2009-04-20 11:42:11 -0700 (Mon, 20 Apr 2009) $\n+ */\n+public class SparseFieldMatrixTest extends TestCase {\n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };\n+    // Test data for group operations\n+    protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) },\n+            { new Fraction(1), new Fraction(0), new Fraction(8) } };\n+    protected Fraction[][] testDataLU = null;\n+    protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) },\n+            { new Fraction(3), new Fraction(2), new Fraction(10) } };\n+    protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) },\n+            { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } };\n+    protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) };\n+    protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) };\n+    protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) },\n+            { new Fraction(5), new Fraction(-2), new Fraction(-1) } };\n+    protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) };\n+    protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };\n+    protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } };\n+    protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) },\n+            { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } };\n+\n+    // lu decomposition tests\n+    protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } };\n+    protected Fraction[][] luDataLUDecomposition = null;\n+\n+    // singular matrices\n+    protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } };\n+    protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },\n+            { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th\n+\n+    // row\n+    // =\n+    // 1st\n+    // +\n+    // 2nd\n+    protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) },\n+            { new Fraction(7), new Fraction(8), new Fraction(10) } };\n+    protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } };\n+\n+    // vectors\n+    protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) };\n+    protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) };\n+\n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = null;\n+\n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } };\n+    protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } };\n+    protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } };\n+\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } };\n+    protected Fraction[][] subRows31Cols31 = null;\n+\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = null;\n+    protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } };\n+    protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } };\n+\n+    // row matrices\n+    protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } };\n+    protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };\n+\n+    // column matrices\n+    protected Fraction[][] subColumn1 = null;\n+    protected Fraction[][] subColumn3 = null;\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    protected Field<Fraction> field = FractionField.getInstance();\n+\n+    public SparseFieldMatrixTest(String name) {\n+        super(name);\n+        setupFractionArrays();\n+    }\n+\n+    private void setupFractionArrays() {\n+        try {\n+            testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },\n+                    { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };\n+            luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) },\n+                { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } };\n+            subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },\n+                    { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };\n+            subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } };\n+            subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } };\n+            subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } };\n+            subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } };\n+        } catch (FractionConversionException e) {\n+            // ignore, can't happen\n+        }\n+        \n+                \n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseFieldMatrixTest.class);\n+        suite.setName(\"SparseFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        assertEquals(\"testData row dimension\", 3, m.getRowDimension());\n+        assertEquals(\"testData column dimension\", 3, m.getColumnDimension());\n+        assertTrue(\"testData is square\", m.isSquare());\n+        assertEquals(\"testData2 row dimension\", m2.getRowDimension(), 2);\n+        assertEquals(\"testData2 column dimension\", m2.getColumnDimension(), 3);\n+        assertTrue(\"testData2 is not square\", !m2.isSquare());\n+    }\n+\n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);\n+        FieldMatrix<Fraction> m2 = m1.copy();\n+        assertTrue(m2 instanceof SparseFieldMatrix);\n+        assertEquals((m2), m1);\n+        SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);\n+        FieldMatrix<Fraction> m4 = m3.copy();\n+        assertTrue(m4 instanceof SparseFieldMatrix);\n+        assertEquals((m4), m3);\n+    }\n+\n+    /** test add */\n+    public void testAdd() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\", \n+                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(), \n+                    entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test add failure */\n+    public void testAddFail() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    \n+    /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);\n+        assertClose(\"m-n = m + -n\", m.subtract(n),\n+            n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);\n+        try {\n+            m.subtract(createSparseMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test multiply */\n+    public void testMultiply() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);\n+        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n+        assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", m.multiply(new FieldMatrixImpl<Fraction>(testDataInv)), identity,\n+                    entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.multiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.multiply(mInv), mInv,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m2.multiply(identity), m2,\n+                entryTolerance);\n+        try {\n+            m.multiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    // Additional Test for RealMatrixImplTest.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };\n+    private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };\n+    private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };\n+\n+    public void testMultiply2() {\n+        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n+        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n+        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+    }\n+\n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(id);\n+        assertEquals(\"identity trace\", 3d, m.getTrace().doubleValue(), entryTolerance);\n+        m = createSparseMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+            m.scalarAdd(new Fraction(2)), entryTolerance);\n+    }\n+\n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(id);\n+        assertClose(\"identity operate\", testVector, m.operate(testVector),\n+                entryTolerance);\n+        assertClose(\"identity operate\", testVector, m.operate(\n+                new FieldVectorImpl<Fraction>(testVector)).getData(), entryTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals(3.0, b[0].doubleValue(), 1.0e-12);\n+        assertEquals(7.0, b[1].doubleValue(), 1.0e-12);\n+        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n+    }\n+\n+    /** test transpose */\n+    public void testTranspose() {\n+        \n+        FieldMatrix<Fraction> m = createSparseMatrix(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = createSparseMatrix(testData2);\n+        FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+\n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n+            normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(\n+            new FieldVectorImpl<Fraction>(testVector).getData()), preMultTest, normTolerance);\n+        m = createSparseMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);\n+        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);\n+        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);\n+        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);\n+        assertClose(\"inverse multiply\", m.preMultiply(mInv), identity,\n+                entryTolerance);\n+        assertClose(\"inverse multiply\", mInv.preMultiply(m), identity,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", m.preMultiply(identity), m,\n+                entryTolerance);\n+        assertClose(\"identity multiply\", identity.preMultiply(mInv), mInv,\n+                entryTolerance);\n+        try {\n+            m.preMultiply(createSparseMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertClose(\"get row\", m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertEquals(\"get entry\", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };\n+        FieldMatrix<Fraction> m = createSparseMatrix(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } };\n+        FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+\n+        // Solve example\n+        Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },\n+                { new Fraction(4), new Fraction(-3), new Fraction(-5) } };\n+        FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);\n+        Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),\n+                constants[0].doubleValue(), 1E-12);\n+        assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),\n+                constants[1].doubleValue(), 1E-12);\n+        assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),\n+                constants[2].doubleValue(), 1E-12);\n+\n+    }\n+\n+    // test submatrix accessors\n+    public void testSubMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);\n+        FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33);\n+        FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23);\n+        FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13);\n+        FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12);\n+        FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);\n+        FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);\n+        FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);\n+        assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n+        assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n+        assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n+        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n+        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n+        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n+\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(-1, 1, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 2);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(1, 0, 2, 4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] {}, new int[] { 0 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);\n+        FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new FieldVectorImpl<Fraction>(data, false);\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();\n+        SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(createSparseMatrix(bigSingular)));\n+    }\n+\n+    /* Disable for now\n+    public void testToString() {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+            m.toString());\n+        m = new SparseFieldMatrix<Fraction>(field, 1, 1);\n+        assertEquals(\"SparseFieldMatrix<Fraction>{{0.0}}\", m.toString());\n+    }\n+    */\n+\n+    public void testSetSubMatrix() throws Exception {\n+        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n+        m.setSubMatrix(detData2, 1, 1);\n+        FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(detData2, 0, 0);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });\n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2, 0, 0);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });\n+        assertEquals(expected, m);\n+\n+        // javadoc example\n+        SparseFieldMatrix<Fraction> matrix = \n+            createSparseMatrix(new Fraction[][] { \n+        { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });\n+        matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);\n+        expected = createSparseMatrix(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });\n+        assertEquals(expected, matrix);\n+\n+        // dimension overflow\n+        try {\n+            m.setSubMatrix(testData, 1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {\n+            m.setSubMatrix(testData, -1, 1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {\n+            m.setSubMatrix(testData, 1, -1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+\n+        // null\n+        try {\n+            m.setSubMatrix(null, 1, 1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            new SparseFieldMatrix<Fraction>(field, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] { {} }, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+    // --------------- -----------------Protected methods\n+\n+    /** verifies that two matrices are close (1-norm) */\n+    protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n,\n+            double tolerance) {\n+        for(int i=0; i < m.getRowDimension(); i++){\n+            for(int j=0; j < m.getColumnDimension(); j++){\n+                assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);\n+            }\n+            \n+        }\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, Fraction[] m, Fraction[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" + i + \" elements differ\", m[i].doubleValue(), n[i].doubleValue(),\n+                    tolerance);\n+        }\n+    }\n+    \n+    private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {\n+        SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);\n+        for (int row = 0; row < data.length; row++) {\n+            for (int col = 0; col < data[row].length; col++) {\n+                matrix.setEntry(row, col, data[row][col]);\n+            }\n+        }\n+        return matrix;\n+    }\n+\n+}", "timestamp": 1241580415, "metainfo": ""}