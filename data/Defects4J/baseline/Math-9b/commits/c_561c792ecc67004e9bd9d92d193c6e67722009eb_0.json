{"sha": "561c792ecc67004e9bd9d92d193c6e67722009eb", "log": "Replaced obsolete exceptions.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.BigFractionField;\n      *\n      * @param d statistic\n      * @return H matrix\n-     * @throws MathArithmeticException\n+     * @throws NumberIsTooLargeException if fractional part is greater than 1\n+     * @throws FractionConversionException\n      *             if algorithm fails to convert {@code h} to a\n      *             {@link org.apache.commons.math.fraction.BigFraction} in\n      *             expressing {@code d} as {@code (k - h) / m} for integer\n         double hDouble = k - n * d;\n \n         if (hDouble >= 1) {\n-            throw new ArithmeticException(\"Could not \");\n+            throw new NumberIsTooLargeException(hDouble, 1.0, false);\n         }\n \n         BigFraction h = null;\n             try {\n                 h = new BigFraction(hDouble, 1.0e-10, 10000);\n             } catch (FractionConversionException e2) {\n-                try {\n-                    h = new BigFraction(hDouble, 1.0e-5, 10000);\n-                } catch (FractionConversionException e3) {\n-                    //throw new MathArithmeticException(hDouble, 10000);\n-                    throw new MathArithmeticException(LocalizedFormats.CANNOT_CONVERT_OBJECT_TO_FRACTION, hDouble);\n-                }\n+                h = new BigFraction(hDouble, 1.0e-5, 10000);\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA(\"cannot compute beta density at 0 when alpha = {0,number}\"),\n     CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA(\"cannot compute beta density at 1 when beta = %.3g\"),\n     CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N(\"cannot compute nth root for null or negative n: {0}\"),\n-    CANNOT_CONVERT_OBJECT_TO_FRACTION(\"cannot convert given object to a fraction number: {0}\"),\n     CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS(\"cannot discard a negative number of elements ({0})\"),\n     CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR(\"cannot format a {0} instance as a 3D vector\"),\n     CANNOT_FORMAT_INSTANCE_AS_COMPLEX(\"cannot format a {0} instance as a complex number\"),\n     UNKNOWN_MODE(\"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\"),\n     UNKNOWN_PARAMETER(\"unknown parameter {0}\"),\n     UNMATCHED_ODE_IN_EXPANDED_SET(\"ode does not match the main ode set in the extended set\"),\n-    CANNOT_PARSE_AS_TYPE(\"string {0} unparseable (from position {1}) as an object of type {2}\"), /* keep */\n-    CANNOT_PARSE(\"string {0} unparseable (from position {1})\"), /* keep */\n+    CANNOT_PARSE_AS_TYPE(\"string \\\"{0}\\\" unparseable (from position {1}) as an object of type {2}\"), /* keep */\n+    CANNOT_PARSE(\"string \\\"{0}\\\" unparseable (from position {1})\"), /* keep */\n     UNPARSEABLE_3D_VECTOR(\"unparseable 3D vector: \\\"{0}\\\"\"),\n     UNPARSEABLE_COMPLEX_NUMBER(\"unparseable complex number: \\\"{0}\\\"\"),\n-    UNPARSEABLE_FRACTION_NUMBER(\"unparseable fraction number: \\\"{0}\\\"\"),\n     UNPARSEABLE_REAL_VECTOR(\"unparseable real vector: \\\"{0}\\\"\"),\n     UNSUPPORTED_EXPANSION_MODE(\"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\"),\n     UNSUPPORTED_OPERATION(\"unsupported operation\"), /* keep */\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n import java.math.BigInteger;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.util.FastMath;\n \n /**\n  * Representation of a rational number without any overflow. This class is\n      *\n      * @param num the numerator, must not be {@code null}.\n      * @param den the denominator, must not be {@code null}.\n-     * @throws ArithmeticException if the denominator is zero.\n+     * @throws ZeroException if the denominator is zero.\n      * @throws NullArgumentException if either of the arguments is null\n      */\n     public BigFraction(BigInteger num, BigInteger den) {\n-        if (num == null) {\n-            throw new NullArgumentException(LocalizedFormats.NUMERATOR);\n-        }\n-        if (den == null) {\n-            throw new NullArgumentException(LocalizedFormats.DENOMINATOR);\n-        }\n+        MathUtils.checkNotNull(num, LocalizedFormats.NUMERATOR);\n+        MathUtils.checkNotNull(den, LocalizedFormats.DENOMINATOR);\n         if (BigInteger.ZERO.equals(den)) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n+            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n         if (BigInteger.ZERO.equals(num)) {\n             numerator   = BigInteger.ZERO;\n      * </p>\n      * @see #BigFraction(double, double, int)\n      * @param value the double value to convert to a fraction.\n-     * @exception IllegalArgumentException if value is NaN or infinite\n+     * @exception MathIllegalArgumentException if value is NaN or infinite\n      */\n     public BigFraction(final double value) throws IllegalArgumentException {\n         if (Double.isNaN(value)) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n+            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_CONVERSION);\n         }\n         if (Double.isInfinite(value)) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_VALUE_CONVERSION);\n         }\n \n         // compute m and k such that value = m * 2^k\n      *            <code>null</code>.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * @throws NullArgumentException if the {@code BigInteger} is {@code null}.\n-     * @throws ArithmeticException\n+     * @throws ZeroException\n      *             if the fraction to divide by is zero.\n      */\n     public BigFraction divide(final BigInteger bg) {\n         if (BigInteger.ZERO.equals(bg)) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n+            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n         return new BigFraction(numerator, denominator.multiply(bg));\n     }\n      * @param fraction Fraction to divide by, must not be {@code null}.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * @throws NullArgumentException if the {@code fraction} is {@code null}.\n-     * @throws ArithmeticException if the fraction to divide by is zero.\n+     * @throws ZeroException if the fraction to divide by is zero.\n      */\n     public BigFraction divide(final BigFraction fraction) {\n         if (fraction == null) {\n             throw new NullArgumentException(LocalizedFormats.FRACTION);\n         }\n         if (BigInteger.ZERO.equals(fraction.numerator)) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n+            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);\n         }\n \n         return multiply(fraction.reciprocal());\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n import java.math.BigInteger;\n import java.text.FieldPosition;\n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathParseException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     * @throws MathIllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n     @Override\n     public StringBuffer format(final Object obj,\n             ret = format(new BigFraction(((Number) obj).doubleValue()),\n                          toAppendTo, pos);\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n+            throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n         }\n \n         return ret;\n      * Parses a string to produce a {@link BigFraction} object.\n      * @param source the string to parse\n      * @return the parsed {@link BigFraction} object.\n-     * @exception ParseException if the beginning of the specified string\n+     * @exception MathParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n     @Override\n-    public BigFraction parse(final String source) throws ParseException {\n+    public BigFraction parse(final String source) throws MathParseException {\n         final ParsePosition parsePosition = new ParsePosition(0);\n         final BigFraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\n-                    parsePosition.getErrorIndex(),\n-                    LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER, source);\n+            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n \n import java.text.FieldPosition;\n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n-import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathParseException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     * @throws FractionConversionException if the numbrer cannot be converted to a fraction\n+     * @throws MathIllegalArgumentException is <code>obj</code> is not a valid type.\n      */\n     @Override\n     public StringBuffer format(final Object obj,\n-                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+                               final StringBuffer toAppendTo, final FieldPosition pos)\n+        throws FractionConversionException, MathIllegalArgumentException {\n         StringBuffer ret = null;\n \n         if (obj instanceof Fraction) {\n             ret = format((Fraction) obj, toAppendTo, pos);\n         } else if (obj instanceof Number) {\n-            try {\n-                ret = format(new Fraction(((Number) obj).doubleValue()),\n-                             toAppendTo, pos);\n-            } catch (ConvergenceException ex) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.CANNOT_CONVERT_OBJECT_TO_FRACTION,\n-                    ex.getLocalizedMessage());\n-            }\n+            ret = format(new Fraction(((Number) obj).doubleValue()), toAppendTo, pos);\n         } else {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n+            throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n         }\n \n         return ret;\n      * Parses a string to produce a {@link Fraction} object.\n      * @param source the string to parse\n      * @return the parsed {@link Fraction} object.\n-     * @exception ParseException if the beginning of the specified string\n+     * @exception MathParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n     @Override\n-    public Fraction parse(final String source) throws ParseException {\n+    public Fraction parse(final String source) throws MathParseException {\n         final ParsePosition parsePosition = new ParsePosition(0);\n         final Fraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw MathRuntimeException.createParseException(\n-                    parsePosition.getErrorIndex(),\n-                    LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER, source);\n+            throw new MathParseException(source, parsePosition.getErrorIndex(), Fraction.class);\n         }\n         return result;\n     }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n import java.text.ParseException;\n import java.util.Locale;\n \n+import org.apache.commons.math.exception.MathParseException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Before;\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.ONE, c.getNumerator());\n             Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n             Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n         try {\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n             Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-1, c.getNumeratorAsInt());\n             Assert.assertEquals(2, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(5, c.getNumeratorAsInt());\n             Assert.assertEquals(3, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n             Assert.fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-5, c.getNumeratorAsInt());\n             Assert.assertEquals(3, c.getDenominatorAsInt());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n             Assert.fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // expected\n         }\n         source = \"2 2 / -3\";\n         try {\n             properFormat.parse(source);\n             Assert.fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n         }\n         try {\n             new BigFraction(BigInteger.ONE, BigInteger.ZERO);\n-            Assert.fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException npe) {\n+            Assert.fail(\"Expecting ZeroException\");\n+        } catch (ZeroException npe) {\n             // expected\n         }\n         try {\n         f = new BigFraction(0, 3);\n         try {\n             f = f.reciprocal();\n-            Assert.fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"expecting ZeroException\");\n+        } catch (ZeroException ex) {\n         }\n \n         // large values\n         try {\n             f1.divide(f2);\n             Assert.fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+        } catch (ZeroException ex) {\n         }\n \n         f1 = new BigFraction(0, 5);\n         Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));\n         try {\n             BigFraction.getReducedFraction(1, 0);\n-            Assert.fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+            Assert.fail(\"expecting ZeroException\");\n+        } catch (ZeroException ex) {\n             // expected\n         }\n         Assert.assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);\n--- a/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n package org.apache.commons.math.fraction;\n \n import java.text.NumberFormat;\n-import java.text.ParseException;\n import java.util.Locale;\n \n+import org.apache.commons.math.exception.MathParseException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Before;\n             Assert.assertNotNull(c);\n             Assert.assertEquals(1, c.getNumerator());\n             Assert.assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(10, c.getNumerator());\n             Assert.assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n         try {\n             Assert.assertNotNull(c);\n             Assert.assertEquals(10, c.getNumerator());\n             Assert.assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n         try {\n             improperFormat.parse(source);\n             Assert.fail(msg);\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-1, c.getNumerator());\n             Assert.assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(5, c.getNumerator());\n             Assert.assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n             Assert.fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-5, c.getNumerator());\n             Assert.assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             Assert.fail(ex.getMessage());\n         }\n \n         try {\n             improperFormat.parse(source);\n             Assert.fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // success\n         }\n     }\n         try {\n             properFormat.parse(source);\n             Assert.fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // expected\n         }\n         source = \"2 2 / -3\";\n         try {\n             properFormat.parse(source);\n             Assert.fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n+        } catch (MathParseException ex) {\n             // expected\n         }\n     }", "timestamp": 1317567926, "metainfo": ""}