{"sha": "5a50073d07ca309d78cfc4e071f4bbe051bdbd40", "log": "MATH-863 Patch provided by Julien Anxionnat:  * method name change,  * bug fix and unit test for \"dotProduct\" (instance method).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/complex/Quaternion.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Quaternion.java\n \n     /**\n      * Builds a pure quaternion from a vector (assuming that the scalar\n-     * part is zero.\n+     * part is zero).\n      *\n      * @param v Components of the vector part of the pure quaternion.\n      */\n      * @param q2 Second quaternion.\n      * @return the product {@code q1} and {@code q2}, in that order.\n      */\n-    public static Quaternion product(final Quaternion q1, final Quaternion q2) {\n+    public static Quaternion multiply(final Quaternion q1, final Quaternion q2) {\n         // Components of the first quaternion.\n         final double q1a = q1.getQ0();\n         final double q1b = q1.getQ1();\n      * @return the product of this instance with {@code q}, in that order.\n      */\n     public Quaternion multiply(final Quaternion q) {\n-        return product(this, q);\n+        return multiply(this, q);\n     }\n \n     /**\n     }\n \n     /**\n-     * Compute the dot-product of the instance by a quaternion.\n+     * Computes the dot-product of the instance by a quaternion.\n      *\n      * @param q Quaternion.\n      * @return the dot product of this instance and {@code q}.\n      */\n     public double dotProduct(final Quaternion q) {\n-        return dotProduct(q);\n+        return dotProduct(this, q);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/complex/QuaternionTest.java\n+++ b/src/test/java/org/apache/commons/math3/complex/QuaternionTest.java\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.geometry.euclidean.threed.Rotation;\n import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n-import org.apache.commons.math3.util.Precision;\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Test;\n import org.junit.Assert;\n \n         final Quaternion qA = new Quaternion(1, 0.5, -3, 4);\n         final Quaternion qB = new Quaternion(6, 2, 1, -9);\n-        final Quaternion qResult = Quaternion.product(qA, qB);\n+        final Quaternion qResult = Quaternion.multiply(qA, qB);\n \n         Assert.assertEquals(44, qResult.getQ0(), EPS);\n         Assert.assertEquals(28, qResult.getQ1(), EPS);\n         // Conjugate of the product of two quaternions and product of their conjugates :\n         // Conj(qA * qB) = Conj(qB) * Conj(qA)\n \n-        final Quaternion conjugateOfProduct = Quaternion.product(qB.getConjugate(), qA.getConjugate());\n-        final Quaternion productOfConjugate = (Quaternion.product(qA, qB)).getConjugate();\n+        final Quaternion conjugateOfProduct = qB.getConjugate().multiply(qA.getConjugate());\n+        final Quaternion productOfConjugate = (qA.multiply(qB)).getConjugate();\n \n         Assert.assertEquals(conjugateOfProduct.getQ0(), productOfConjugate.getQ0(), EPS);\n         Assert.assertEquals(conjugateOfProduct.getQ1(), productOfConjugate.getQ1(), EPS);\n \n         final Quaternion quaternion = new Quaternion(4, 7, -1, 2);\n         final double[] vector = {2.0, 1.0, 3.0};\n-        final Quaternion qResultQxV = Quaternion.product(quaternion, new Quaternion(vector));\n+        final Quaternion qResultQxV = Quaternion.multiply(quaternion, new Quaternion(vector));\n \n         Assert.assertEquals(-19, qResultQxV.getQ0(), EPS);\n         Assert.assertEquals(3, qResultQxV.getQ1(), EPS);\n \n         // Case : Product between a vector and a quaternion : VxQ\n \n-        final Quaternion qResultVxQ = Quaternion.product(new Quaternion(vector), quaternion);\n+        final Quaternion qResultVxQ = Quaternion.multiply(new Quaternion(vector), quaternion);\n \n         Assert.assertEquals(-19, qResultVxQ.getQ0(), EPS);\n         Assert.assertEquals(13, qResultVxQ.getQ1(), EPS);\n         final Quaternion q1 = new Quaternion(1, 2, 2, 1);\n         final Quaternion q2 = new Quaternion(3, -2, -1, -3);\n \n-        final double actual = Quaternion.dotProduct(q1, q2);\n-\n-        Assert.assertEquals(expected, actual, EPS);\n+        final double actual1 = Quaternion.dotProduct(q1, q2);\n+        final double actual2 = q1.dotProduct(q2);\n+\n+        Assert.assertEquals(expected, actual1, EPS);\n+        Assert.assertEquals(expected, actual2, EPS);\n     }\n \n     @Test\n         final Quaternion q1 = new Quaternion(1., 2., -2., -1.);\n         final Quaternion q2 = new Quaternion(3., -3., 4., -3.);\n \n-        final Quaternion q = Quaternion.add(q1, q2);\n-\n-        Assert.assertEquals(w, q.getQ0(), EPS);\n-        Assert.assertEquals(x, q.getQ1(), EPS);\n-        Assert.assertEquals(y, q.getQ2(), EPS);\n-        Assert.assertEquals(z, q.getQ3(), EPS);\n+        final Quaternion qa = Quaternion.add(q1, q2);\n+        final Quaternion qb = q1.add(q2);\n+\n+        Assert.assertEquals(w, qa.getQ0(), EPS);\n+        Assert.assertEquals(x, qa.getQ1(), EPS);\n+        Assert.assertEquals(y, qa.getQ2(), EPS);\n+        Assert.assertEquals(z, qa.getQ3(), EPS);\n+\n+        Assert.assertEquals(w, qb.getQ0(), EPS);\n+        Assert.assertEquals(x, qb.getQ1(), EPS);\n+        Assert.assertEquals(y, qb.getQ2(), EPS);\n+        Assert.assertEquals(z, qb.getQ3(), EPS);\n     }\n \n     @Test\n         final Quaternion q1 = new Quaternion(1., 2., -2., -1.);\n         final Quaternion q2 = new Quaternion(3., -3., 4., -3.);\n \n-        final Quaternion q = Quaternion.subtract(q1, q2);\n-\n-        Assert.assertEquals(w, q.getQ0(), EPS);\n-        Assert.assertEquals(x, q.getQ1(), EPS);\n-        Assert.assertEquals(y, q.getQ2(), EPS);\n-        Assert.assertEquals(z, q.getQ3(), EPS);\n-    }\n+        final Quaternion qa = Quaternion.subtract(q1, q2);\n+        final Quaternion qb = q1.subtract(q2);\n+\n+        Assert.assertEquals(w, qa.getQ0(), EPS);\n+        Assert.assertEquals(x, qa.getQ1(), EPS);\n+        Assert.assertEquals(y, qa.getQ2(), EPS);\n+        Assert.assertEquals(z, qa.getQ3(), EPS);\n+\n+        Assert.assertEquals(w, qb.getQ0(), EPS);\n+        Assert.assertEquals(x, qb.getQ1(), EPS);\n+        Assert.assertEquals(y, qb.getQ2(), EPS);\n+        Assert.assertEquals(z, qb.getQ3(), EPS);\n+}\n \n     @Test\n     public final void testNorm() {\n \n         Assert.assertEquals(Math.sqrt(30), norm, 0);\n \n-        final double normSquareRef = Quaternion.product(q, q.getConjugate()).getScalarPart();\n+        final double normSquareRef = Quaternion.multiply(q, q.getConjugate()).getScalarPart();\n         Assert.assertEquals(Math.sqrt(normSquareRef), norm, 0);\n     }\n \n         Assert.assertEquals(-2.0 / 28.5, inverseQ.getQ2(), 0);\n         Assert.assertEquals(2.5 / 28.5, inverseQ.getQ3(), 0);\n \n-        final Quaternion product = Quaternion.product(inverseQ, q);\n+        final Quaternion product = Quaternion.multiply(inverseQ, q);\n         Assert.assertEquals(1, product.getQ0(), EPS);\n         Assert.assertEquals(0, product.getQ1(), EPS);\n         Assert.assertEquals(0, product.getQ2(), EPS);", "timestamp": 1348224150, "metainfo": ""}