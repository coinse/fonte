{"sha": "b163cc1ff167d77778444211f1957ea832daa83e", "log": "Added Fast Fourier transform JIRA: MATH-140 Contributed by Xiaogang Zhang   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n+ * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Cosine Transform</a>\n+ * for transformation of one-dimensional data sets. For reference, see\n+ * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n+ * <p>\n+ * FCT is its own inverse, up to a multiplier depending on conventions.\n+ * The equations are listed in the comments of the corresponding methods.\n+ * <p>\n+ * Different from FFT and FST, FCT requires the length of data set to be\n+ * power of 2 plus one. Users should especially pay attention to the\n+ * function transformation on how this affects the sampling.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FastCosineTransformer implements Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -7673941545134707766L;\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    FastCosineTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n+     *                        \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        return fct(f);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n+     *                        \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        return fct(data);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n+     *                        \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));\n+        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n+     *                        \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        double scaling_coefficient = Math.sqrt(2.0 / (n-1));\n+        return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n+     *                        (2/N) \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = 2.0 / (f.length - 1);\n+        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n+     *                        (2/N) \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        double scaling_coefficient = 2.0 / (n - 1);\n+        return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n+     *                        \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        return transform2(f);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n+     *                        \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        return transform2(f, min, max, n);\n+    }\n+\n+    /**\n+     * Perform the FCT algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fct(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double A, B, C, F1, x[], F[] = new double[f.length];\n+\n+        int N = f.length - 1;\n+        if (!FastFourierTransformer.isPowerOf2(N)) {\n+            throw new IllegalArgumentException\n+                (\"Number of samples not power of 2 plus one: \" + f.length);\n+        }\n+        if (N == 1) {       // trivial case\n+            F[0] = 0.5 * (f[0] + f[1]);\n+            F[1] = 0.5 * (f[0] - f[1]);\n+            return F;\n+        }\n+\n+        // construct a new array and perform FFT on it\n+        x = new double[N];\n+        x[0] = 0.5 * (f[0] + f[N]);\n+        x[N >> 1] = f[N >> 1];\n+        F1 = 0.5 * (f[0] - f[N]);   // temporary variable for F[1]\n+        for (int i = 1; i < (N >> 1); i++) {\n+            A = 0.5 * (f[i] + f[N-i]);\n+            B = Math.sin(i * Math.PI / N) * (f[i] - f[N-i]);\n+            C = Math.cos(i * Math.PI / N) * (f[i] - f[N-i]);\n+            x[i] = A - B;\n+            x[N-i] = A + B;\n+            F1 += C;\n+        }\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex y[] = transformer.transform(x);\n+\n+        // reconstruct the FCT result for the original array\n+        F[0] = y[0].getReal();\n+        F[1] = F1;\n+        for (int i = 1; i < (N >> 1); i++) {\n+            F[2*i] = y[i].getReal();\n+            F[2*i+1] = F[2*i-1] - y[i].getImaginary();\n+        }\n+        F[N] = y[N >> 1].getReal();\n+\n+        return F;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/FastFourierTransform.html\">\n+ * Fast Fourier Transform</a> for transformation of one-dimensional data sets.\n+ * For reference, see <b>Applied Numerical Linear Algebra</b>, ISBN 0898713897,\n+ * chapter 6.\n+ * <p>\n+ * There are several conventions for the definition of FFT and inverse FFT,\n+ * mainly on different coefficient and exponent. Here the equations are listed\n+ * in the comments of the corresponding methods.\n+ * <p>\n+ * We require the length of data set to be power of 2, this greatly simplifies\n+ * and speeds up the code. Users can pad the data with zeros to meet this\n+ * requirement. There are other flavors of FFT, for reference, see S. Winograd,\n+ * <i>On computing the discrete Fourier transform</i>, Mathematics of Computation,\n+ * 32 (1978), 175 - 199.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FastFourierTransformer implements Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 5138259215438106000L;\n+\n+    /** array of the roots of unity */\n+    private Complex omega[] = new Complex[0];\n+\n+    /**\n+     * |omegaCount| is the length of lasted computed omega[]. omegaCount\n+     * is positive for forward transform and negative for inverse transform.\n+     */\n+    private int omegaCount = 0;\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    FastFourierTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        return fft(f, false);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        return fft(data, false);\n+    }\n+\n+    /**\n+     * Transform the given complex data set.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     *\n+     * @param f the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(Complex f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        computeOmega(f.length);\n+        return fft(f);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f, false), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        return scaleArray(fft(data, false), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given complex data set.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     *\n+     * @param f the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(Complex f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        computeOmega(f.length);\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / f.length;\n+        return scaleArray(fft(f, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / n;\n+        return scaleArray(fft(data, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given complex data set.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     *\n+     * @param f the complex data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(Complex f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        computeOmega(-f.length);    // pass negative argument\n+        double scaling_coefficient = 1.0 / f.length;\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        return scaleArray(fft(data, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given complex data set.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     *\n+     * @param f the complex data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(Complex f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        computeOmega(-f.length);    // pass negative argument\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Perform the base-4 Cooley-Tukey FFT algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @param isInverse the indicator of forward or inverse transform\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(double f[], boolean isInverse) throws\n+        MathException, IllegalArgumentException {\n+\n+        verifyDataSet(f);\n+        Complex F[] = new Complex[f.length];\n+        if (f.length == 1) {\n+            F[0] = new Complex(f[0], 0.0);\n+            return F;\n+        }\n+\n+        // Rather than the naive real to complex conversion, pack 2N\n+        // real numbers into N complex numbers for better performance.\n+        int N = f.length >> 1;\n+        Complex c[] = new Complex[N];\n+        for (int i = 0; i < N; i++) {\n+            c[i] = new Complex(f[2*i], f[2*i+1]);\n+        }\n+        computeOmega(isInverse ? -N : N);\n+        Complex z[] = fft(c);\n+\n+        // reconstruct the FFT result for the original array\n+        computeOmega(isInverse ? -2*N : 2*N);\n+        F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n+        F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n+        for (int i = 1; i < N; i++) {\n+            Complex A = z[N-i].conjugate();\n+            Complex B = z[i].add(A);\n+            Complex C = z[i].subtract(A);\n+            Complex D = omega[i].multiply(Complex.I);\n+            F[i] = B.subtract(C.multiply(D));\n+            F[2*N-i] = F[i].conjugate();\n+        }\n+\n+        return scaleArray(F, 0.5);\n+    }\n+\n+    /**\n+     * Perform the base-4 Cooley-Tukey FFT algorithm (including inverse).\n+     *\n+     * @param data the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(Complex data[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        int i, j, k, m, N = data.length;\n+        Complex A, B, C, D, E, F, z, f[] = new Complex[N];\n+\n+        // initial simple cases\n+        verifyDataSet(data);\n+        if (N == 1) {\n+            f[0] = data[0];\n+            return f;\n+        }\n+        if (N == 2) {\n+            f[0] = data[0].add(data[1]);\n+            f[1] = data[0].subtract(data[1]);\n+            return f;\n+        }\n+\n+        // permute original data array in bit-reversal order\n+        j = 0;\n+        for (i = 0; i < N; i++) {\n+            f[i] = data[j];\n+            k = N >> 1;\n+            while (j >= k && k > 0) {\n+                j -= k; k >>= 1;\n+            }\n+            j += k;\n+        }\n+\n+        // the bottom base-4 round\n+        for (i = 0; i < N; i += 4) {\n+            A = f[i].add(f[i+1]);\n+            B = f[i+2].add(f[i+3]);\n+            C = f[i].subtract(f[i+1]);\n+            D = f[i+2].subtract(f[i+3]);\n+            E = C.add(D.multiply(Complex.I));\n+            F = C.subtract(D.multiply(Complex.I));\n+            f[i] = A.add(B);\n+            f[i+2] = A.subtract(B);\n+            // omegaCount indicates forward or inverse transform\n+            f[i+1] = omegaCount < 0 ? E : F;\n+            f[i+3] = omegaCount > 0 ? E : F;\n+        }\n+\n+        // iterations from bottom to top take O(N*logN) time\n+        for (i = 4; i < N; i <<= 1) {\n+            m = N / (i<<1);\n+            for (j = 0; j < N; j += i<<1) {\n+                for (k = 0; k < i; k++) {\n+                    z = f[i+j+k].multiply(omega[k*m]);\n+                    f[i+j+k] = f[j+k].subtract(z);\n+                    f[j+k] = f[j+k].add(z);\n+                }\n+            }\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Calculate the n-th roots of unity.\n+     * <p>\n+     * The computed omega[] = { 1, w, w^2, ... w^(n-1) } where\n+     * w = exp(-2 \\pi i / n), i = sqrt(-1). Note n is positive for\n+     * forward transform and negative for inverse transform.\n+     * \n+     * @param n the integer passed in\n+     * @throws IllegalArgumentException if n = 0\n+     */\n+    protected void computeOmega(int n) throws IllegalArgumentException {\n+        if (n == 0) {\n+            throw new IllegalArgumentException\n+                (\"Cannot compute 0-th root of unity, indefinite result.\");\n+        }\n+        // avoid repetitive calculations\n+        if (n == omegaCount) { return; }\n+        if (n + omegaCount == 0) {\n+            for (int i = 0; i < Math.abs(omegaCount); i++) {\n+                omega[i] = omega[i].conjugate();\n+            }\n+            omegaCount = n;\n+            return;\n+        }\n+        // calculate everything from scratch\n+        omega = new Complex[Math.abs(n)];\n+        double t = 2.0 * Math.PI / n;\n+        double cost = Math.cos(t);\n+        double sint = Math.sin(t);\n+        omega[0] = new Complex(1.0, 0.0);\n+        for (int i = 1; i < Math.abs(n); i++) {\n+            omega[i] = new Complex(\n+                omega[i-1].getReal() * cost + omega[i-1].getImaginary() * sint,\n+                omega[i-1].getImaginary() * cost - omega[i-1].getReal() * sint);\n+        }\n+        omegaCount = n;\n+    }\n+\n+    /**\n+     * Sample the given univariate real function on the given interval.\n+     * <p>\n+     * The interval is divided equally into N sections and sample points\n+     * are taken from min to max-(max-min)/N. Usually f(x) is periodic\n+     * such that f(min) = f(max) (note max is not sampled), but we don't\n+     * require that.\n+     *\n+     * @param f the function to be sampled\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the samples array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public static double[] sample(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\"Number of samples not positive.\");\n+        }\n+        verifyInterval(min, max);\n+\n+        double s[] = new double[n];\n+        double h = (max - min) / n;\n+        for (int i = 0; i < n; i++) {\n+            s[i] = f.value(min + i * h);\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Multiply every component in the given real array by the\n+     * given real number. The change is made in place.\n+     *\n+     * @param f the real array to be scaled\n+     * @param d the real scaling coefficient\n+     * @return a reference to the scaled array\n+     */\n+    public static double[] scaleArray(double f[], double d) {\n+        for (int i = 0; i < f.length; i++) {\n+            f[i] *= d;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Multiply every component in the given complex array by the\n+     * given real number. The change is made in place.\n+     *\n+     * @param f the complex array to be scaled\n+     * @param d the real scaling coefficient\n+     * @return a reference to the scaled array\n+     */\n+    public static Complex[] scaleArray(Complex f[], double d) {\n+        for (int i = 0; i < f.length; i++) {\n+            f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Returns true if the argument is power of 2.\n+     * \n+     * @param n the number to test\n+     * @return true if the argument is power of 2\n+     */\n+    public static boolean isPowerOf2(long n) {\n+        return (n > 0) && ((n & (n - 1)) == 0);\n+    }\n+\n+    /**\n+     * Verifies that the data set has length of power of 2.\n+     * \n+     * @param d the data array\n+     * @throws IllegalArgumentException if array length is not power of 2\n+     */\n+    public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n+        if (!isPowerOf2(d.length)) {\n+            throw new IllegalArgumentException\n+                (\"Number of samples not power of 2, consider padding for fix.\");\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the data set has length of power of 2.\n+     * \n+     * @param o the data array\n+     * @throws IllegalArgumentException if array length is not power of 2\n+     */\n+    public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n+        if (!isPowerOf2(o.length)) {\n+            throw new IllegalArgumentException\n+                (\"Number of samples not power of 2, consider padding for fix.\");\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the endpoints specify an interval.\n+     * \n+     * @param lower lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException if not interval\n+     */\n+    public static void verifyInterval(double lower, double upper) throws\n+        IllegalArgumentException {\n+\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"Endpoints do not specify an interval: [\" + lower +\n+                \", \" + upper + \"]\");\n+        }       \n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n+ * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Sine Transform</a>\n+ * for transformation of one-dimensional data sets. For reference, see\n+ * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n+ * <p>\n+ * FST is its own inverse, up to a multiplier depending on conventions.\n+ * The equations are listed in the comments of the corresponding methods.\n+ * <p>\n+ * Similar to FFT, we also require the length of data set to be power of 2.\n+ * In addition, the first element must be 0 and it's enforced in function\n+ * transformation after sampling.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FastSineTransformer implements Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -478002039949390854L;\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    FastSineTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ F_n = \\Sigma_{k=0}^{N-1} f_k \\sin(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        return fst(f);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ F_n = \\Sigma_{k=0}^{N-1} f_k \\sin(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        return fst(data);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ F_n = \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\sin(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = Math.sqrt(2.0 / f.length);\n+        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ F_n = \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\sin(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        double scaling_coefficient = Math.sqrt(2.0 / n);\n+        return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ f_k = (2/N) \\Sigma_{n=0}^{N-1} F_n \\sin(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double scaling_coefficient = 2.0 / f.length;\n+        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ f_k = (2/N) \\Sigma_{n=0}^{N-1} F_n \\sin(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        double scaling_coefficient = 2.0 / n;\n+        return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ f_k = \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\sin(\\pi nk/N) $\n+     *\n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        return transform2(f);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ f_k = \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\sin(\\pi nk/N) $\n+     *\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws MathException, IllegalArgumentException {\n+\n+        return transform2(f, min, max, n);\n+    }\n+\n+    /**\n+     * Perform the FST algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws MathException if any math-related errors occur\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fst(double f[]) throws MathException,\n+        IllegalArgumentException {\n+\n+        double A, B, x[], F[] = new double[f.length];\n+\n+        FastFourierTransformer.verifyDataSet(f);\n+        if (f[0] != 0.0) {\n+            throw new IllegalArgumentException\n+                (\"The first element is not zero: \" + f[0]);\n+        }\n+        int N = f.length;\n+        if (N == 1) {       // trivial case\n+            F[0] = 0.0;\n+            return F;\n+        }\n+\n+        // construct a new array and perform FFT on it\n+        x = new double[N];\n+        x[0] = 0.0;\n+        x[N >> 1] = 2.0 * f[N >> 1];\n+        for (int i = 1; i < (N >> 1); i++) {\n+            A = Math.sin(i * Math.PI / N) * (f[i] + f[N-i]);\n+            B = 0.5 * (f[i] - f[N-i]);\n+            x[i] = A + B;\n+            x[N-i] = A - B;\n+        }\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex y[] = transformer.transform(x);\n+\n+        // reconstruct the FST result for the original array\n+        F[0] = 0.0;\n+        F[1] = 0.5 * y[0].getReal();\n+        for (int i = 1; i < (N >> 1); i++) {\n+            F[2*i] = -y[i].getImaginary();\n+            F[2*i+1] = y[i].getReal() + F[2*i-1];\n+        }\n+\n+        return F;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast cosine transformer.\n+ * <p>\n+ * FCT algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastCosineTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data.\n+     */\n+    public void testAdHocData() throws MathException {\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+        double result[], tolerance = 1E-12;\n+\n+        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };\n+        double y[] = { 172.0, -105.096569476353, 27.3137084989848,\n+                      -12.9593152353742, 8.0, -5.78585076868676,\n+                       4.68629150101524, -4.15826451958632, 4.0 };\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));\n+\n+        result = transformer.transform2(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+        double min, max, result[], tolerance = 1E-12; int N = 9;\n+\n+        double expected[] = { 0.0, 3.26197262739567, 0.0,\n+                             -2.17958042710327, 0.0, -0.648846697642915,\n+                              0.0, -0.433545502649478, 0.0 };\n+        min = 0.0; max = 2.0 * Math.PI * N / (N-1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            assertEquals(expected[i], result[i], tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI * (N+1) / (N-1);\n+        result = transformer.transform(f, min, max, N);\n+        for (int i = 0; i < N; i++) {\n+            assertEquals(-expected[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastCosineTransformer transformer = new FastCosineTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 65);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast Fourier transformer.\n+ * <p>\n+ * FFT algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastFourierTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data taken from Mathematica.\n+     */\n+    public void testAdHocData() throws MathException {\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex result[]; double tolerance = 1E-12;\n+\n+        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};\n+        Complex y[] = {\n+            new Complex(21.9, 0.0),\n+            new Complex(-2.09497474683058, 1.91507575950825),\n+            new Complex(-2.6, 2.7),\n+            new Complex(-1.10502525316942, -4.88492424049175),\n+            new Complex(0.1, 0.0),\n+            new Complex(-1.10502525316942, 4.88492424049175),\n+            new Complex(-2.6, -2.7),\n+            new Complex(-2.09497474683058, -1.91507575950825)};\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);\n+            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};\n+        transformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));\n+        Complex y2[] = y;\n+\n+        result = transformer.transform2(y2);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x2[i], result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x2);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);\n+            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex result[]; int N = 1 << 8;\n+        double min, max, tolerance = 1E-12;\n+\n+        min = 0.0; max = 2.0 * Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(0.0, result[1].getReal(), tolerance);\n+        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n+        assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            assertEquals(0.0, result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI;\n+        result = transformer.inversetransform(f, min, max, N);\n+        assertEquals(0.0, result[1].getReal(), tolerance);\n+        assertEquals(-0.5, result[1].getImaginary(), tolerance);\n+        assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            assertEquals(0.0, result[i].getReal(), tolerance);\n+            assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 0);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 100);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/transform/FastSineTransformerTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for fast sine transformer.\n+ * <p>\n+ * FST algorithm is exact, the small tolerance number is used only\n+ * to account for round-off errors.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class FastSineTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the ad hoc data.\n+     */\n+    public void testAdHocData() throws MathException {\n+        FastSineTransformer transformer = new FastSineTransformer();\n+        double result[], tolerance = 1E-12;\n+\n+        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };\n+        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,\n+                       5.98642305066196, -4.0, 2.67271455167720,\n+                      -1.65685424949238, 0.795649469518633 };\n+\n+        result = transformer.transform(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));\n+\n+        result = transformer.transform2(y);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(x[i], result[i], tolerance);\n+        }\n+\n+        result = transformer.inversetransform2(x);\n+        for (int i = 0; i < result.length; i++) {\n+            assertEquals(y[i], result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastSineTransformer transformer = new FastSineTransformer();\n+        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n+\n+        min = 0.0; max = 2.0 * Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(N >> 1, result[2], tolerance);\n+        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n+            assertEquals(0.0, result[i], tolerance);\n+        }\n+\n+        min = -Math.PI; max = Math.PI;\n+        result = transformer.transform(f, min, max, N);\n+        assertEquals(-(N >> 1), result[2], tolerance);\n+        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n+            assertEquals(0.0, result[i], tolerance);\n+        }\n+    }\n+\n+    /**\n+     * Test of parameters for the transformer.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        FastSineTransformer transformer = new FastSineTransformer();\n+\n+        try {\n+            // bad interval\n+            transformer.transform(f, 1, -1, 64);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 0);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad samples number\n+            transformer.transform(f, -1, 1, 100);\n+            fail(\"Expecting IllegalArgumentException - bad samples number\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1152046734, "metainfo": ""}