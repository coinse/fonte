{"sha": "71f799cf419b3de39930f40beefc0328b348fe72", "log": "ade all distribution classes immutable (as per the conclusion of MATH-349). Modified two classes in the \"stat\" package where some code conflicted with ditribution immutability. Replaced instances of \"IllegalArgumentException\" with an appropriate stateful exception. Cleaned up Javadoc comments.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.util.FastMath;\n \n public abstract class AbstractContinuousDistribution\n     extends AbstractDistribution\n     implements ContinuousDistribution, Serializable {\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-\n     /**\n      * RandomData instance used to generate samples from the distribution\n      * @since 2.2\n      */\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n-\n     /**\n      * Solver absolute accuracy for inverse cum computation\n      * @since 2.1\n      */\n     private double solverAbsoluteAccuracy = BrentSolver.DEFAULT_ABSOLUTE_ACCURACY;\n-\n     /**\n      * Default constructor.\n      */\n-    protected AbstractContinuousDistribution() {\n-        super();\n-    }\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     * @param x  The point at which the density should be computed.\n-     * @return  The pdf at point x.\n-     * @throws MathRuntimeException if the specialized class hasn't implemented this function\n-     * @since 2.1\n-     */\n-    public double density(double x) throws MathRuntimeException {\n-        throw new MathRuntimeException(new UnsupportedOperationException(),\n-                LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION);\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n+    protected AbstractContinuousDistribution() {}\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract double density(double x);\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * computed due to convergence or other numerical errors.\n+     * @throws OutOfRangeException if {@code p} is not a valid probability.\n      */\n     public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n+            throw new OutOfRangeException(p, 0, 1);\n         }\n \n         // by default, do simple root finding using bracketing and default solver.\n                 try {\n                     ret = cumulativeProbability(x) - p;\n                 } catch (MathException ex) {\n-                    throw new FunctionEvaluationException(ex, x, ex.getLocalizablePattern(), ex.getArguments());\n+                    throw new FunctionEvaluationException(ex, x, ex.getLocalizablePattern(),\n+                                                          ex.getArguments());\n                 }\n                 if (Double.isNaN(ret)) {\n                     throw new FunctionEvaluationException(x,\n             bracket = UnivariateRealSolverUtils.bracket(\n                     rootFindingFunction, getInitialDomain(p),\n                     lowerBound, upperBound);\n-        }  catch (ConvergenceException ex) {\n+        } catch (ConvergenceException ex) {\n             /*\n              * Check domain endpoints to see if one gives value that is within\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n     }\n \n     /**\n-     * Reseeds the random generator used to generate samples.\n-     *\n-     * @param seed the new seed\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed New seed.\n      * @since 2.2\n      */\n     public void reseedRandomGenerator(long seed) {\n     }\n \n     /**\n-     * Generates a random value sampled from this distribution. The default\n+     * Generate a random value sampled from this distribution. The default\n      * implementation uses the\n-     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n-     *\n-     * @return random value\n-     * @since 2.2\n-     * @throws MathException if an error occurs generating the random value\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n+     *  inversion method.\n+     * </a>\n+     *\n+     * @return a random value.\n+     * @throws MathException if an error occurs generating the random value.\n+     * @since 2.2\n      */\n     public double sample() throws MathException {\n         return randomData.nextInversionDeviate(this);\n     }\n \n     /**\n-     * Generates a random sample from the distribution.  The default implementation\n+     * Generate a random sample from the distribution.  The default implementation\n      * generates the sample by calling {@link #sample()} in a loop.\n      *\n-     * @param sampleSize number of random values to generate\n-     * @since 2.2\n-     * @return an array representing the random sample\n-     * @throws MathException if an error occurs generating the sample\n-     * @throws IllegalArgumentException if sampleSize is not positive\n+     * @param sampleSize Number of random values to generate.\n+     * @return an array representing the random sample.\n+     * @throws MathException if an error occurs generating the sample.\n+     * @throws NotStrictlyPositiveException if {@code sampleSize} is not positive.\n+     * @since 2.2\n      */\n     public double[] sample(int sampleSize) throws MathException {\n         if (sampleSize <= 0) {\n-            MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, sampleSize);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                                                   sampleSize);\n         }\n         double[] out = new double[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     protected abstract double getInitialDomain(double p);\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     protected abstract double getDomainLowerBound(double p);\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     protected abstract double getDomainUpperBound(double p);\n \n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n       * @return beta.\n       */\n      double getBeta();\n-\n-     /**\n-      * Return the probability density for a particular point.\n-      *\n-      * @param x  Point at which the density should be computed.\n-      * @return the pdf at point {@code x}.\n-      */\n-     double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n  * <p>\n  * References:\n  * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n- * Cauchy Distribution</a></li>\n+ *  <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n+ *   Cauchy Distribution</a>\n+ *  </li>\n  * </ul>\n  * </p>\n  *\n  * @version $Revision$ $Date$\n  */\n public interface CauchyDistribution extends ContinuousDistribution {\n-\n     /**\n      * Access the median.\n-     * @return median for this distribution\n+     *\n+     * @return the median for this distribution.\n      */\n     double getMedian();\n \n     /**\n      * Access the scale parameter.\n-     * @return scale parameter for this distribution\n+     *\n+     * @return the scale parameter for this distribution.\n      */\n     double getScale();\n-\n-    /**\n-     * Modify the median.\n-     * @param median for this distribution\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setMedian(double median);\n-\n-    /**\n-     * Modify the scale parameter.\n-     * @param s scale parameter for this distribution\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setScale(double s);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n  */\n public class CauchyDistributionImpl extends AbstractContinuousDistribution\n         implements CauchyDistribution, Serializable {\n-\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n-\n     /** The median of this distribution. */\n     private double median = 0;\n-\n     /** The scale of this distribution. */\n     private double scale = 1;\n-\n     /** Inverse cumulative probability accuracy */\n     private final double solverAbsoluteAccuracy;\n \n      * Creates cauchy distribution with the medain equal to zero and scale\n      * equal to one.\n      */\n-    public CauchyDistributionImpl(){\n-        this(0.0, 1.0);\n+    public CauchyDistributionImpl() {\n+        this(0, 1);\n     }\n \n     /**\n      * Create a cauchy distribution using the given median and scale.\n-     * @param median median for this distribution\n-     * @param s scale parameter for this distribution\n-     */\n-    public CauchyDistributionImpl(double median, double s){\n-        this(median, s, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+     *\n+     * @param median Median for this distribution.\n+     * @param scale Scale parameter for this distribution.\n+     */\n+    public CauchyDistributionImpl(double median, double scale) {\n+        this(median, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n      * Create a cauchy distribution using the given median and scale.\n-     * @param median median for this distribution\n-     * @param s scale parameter for this distribution\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     *\n+     * @param median Median for this distribution.\n+     * @param scale Scale parameter for this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code s <= 0}.\n      * @since 2.1\n      */\n-    public CauchyDistributionImpl(double median, double s, double inverseCumAccuracy) {\n-        super();\n-        setMedianInternal(median);\n-        setScaleInternal(s);\n+    public CauchyDistributionImpl(double median, double scale,\n+                                  double inverseCumAccuracy) {\n+        if (scale <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);\n+        }\n+        this.scale = scale;\n+        this.median = median;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>.\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return CDF evaluted at {@code x}.\n      */\n     public double cumulativeProbability(double x) {\n         return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);\n     }\n \n     /**\n-     * Access the median.\n-     * @return median for this distribution\n+     * {@inheritDoc}\n      */\n     public double getMedian() {\n         return median;\n     }\n \n     /**\n-     * Access the scale parameter.\n-     * @return scale parameter for this distribution\n+     * {@inheritDoc}\n      */\n     public double getScale() {\n         return scale;\n     }\n \n     /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n+     * {@code Double.POSITIVE_INFINITY} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n+     * @throws OutOfRangeException if {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n-        if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n         } else if (p == 0) {\n             ret = Double.NEGATIVE_INFINITY;\n         } else  if (p == 1) {\n     }\n \n     /**\n-     * Modify the median.\n-     * @param median for this distribution\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setMedian(double median) {\n-        setMedianInternal(median);\n-    }\n-    /**\n-     * Modify the median.\n-     * @param newMedian for this distribution\n-     */\n-    private void setMedianInternal(double newMedian) {\n-        this.median = newMedian;\n-    }\n-\n-    /**\n-     * Modify the scale parameter.\n-     * @param s scale parameter for this distribution\n-     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setScale(double s) {\n-        setScaleInternal(s);\n-    }\n-    /**\n-     * Modify the scale parameter.\n-     * @param s scale parameter for this distribution\n-     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-     */\n-    private void setScaleInternal(double s) {\n-        if (s <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_SCALE, s);\n-        }\n-        scale = s;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = -Double.MAX_VALUE;\n         } else {\n             ret = median;\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return domain value lower bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = median;\n         } else {\n             ret = Double.MAX_VALUE;\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             ret = median - scale;\n-        } else if (p > .5) {\n+        } else if (p > 0.5) {\n             ret = median + scale;\n         } else {\n             ret = median;\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n  */\n public interface ChiSquaredDistribution extends ContinuousDistribution {\n     /**\n-     * Access the degrees of freedom.\n+     * Access the number of degrees of freedom.\n+     *\n      * @return the degrees of freedom.\n      */\n     double getDegreesOfFreedom();\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     * @param x  The point at which the density should be computed.\n-     * @return  The pdf at point x.\n-     */\n-    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     }\n \n     /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &lt; x).\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * @throws MathException if the cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         return gamma.cumulativeProbability(x);\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     * For this distribution, X, this method returns the critical point\n+     * {@code x}, such that {@code P(X < x) = p}.\n+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n+     * when p = 1.\n      *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * computed due to convergence or other numerical errors.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n      * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n import org.apache.commons.math.MathException;\n \n /**\n- * <p>Base interface for continuous distributions.</p>\n- *\n- * <p>Note: this interface will be extended in version 3.0 to include\n- * <br/><code>public double density(double x)</code><br/>\n- * that is, from version 3.0 forward, continuous distributions <strong>must</strong>\n- * include implementations of probability density functions. As of version\n- * 2.1, all continuous distribution implementations included in commons-math\n- * provide implementations of this method.</p>\n+ * Base interface for continuous distributions.\n  *\n  * @version $Revision$ $Date$\n  */\n public interface ContinuousDistribution extends Distribution {\n+    /**\n+     * For a distribution, {@code X}, compute {@code x} such that\n+     * {@code P(X < x) = p}.\n+     *\n+     * @param p Cumulative probability.\n+     * @return {@code x} such that {@code P(X < x) = p}.\n+     * @throws MathException if the inverse cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n+     */\n+    double inverseCumulativeProbability(double p) throws MathException;\n \n     /**\n-     * For this distribution, X, this method returns x such that P(X &lt; x) = p.\n-     * @param p the cumulative probability.\n-     * @return x.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * Probability density for a particular point.\n+     *\n+     * @param x Point at which the density should be computed.\n+     * @return the pdf at point {@code x}.\n      */\n-    double inverseCumulativeProbability(double p) throws MathException;\n+    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n      * @return the mean.\n      */\n     double getMean();\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x Point at which the density should be computed.\n-     * @return the pdf at point {@code x}.\n-     */\n-    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n \n     /**\n      * Create a exponential distribution with the given mean.\n-     * @param mean mean of this distribution.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     *\n+     * @param mean Mean of this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n      * cumulative probability estimates (defaults to\n      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n      * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n      * Exponential Distribution</a>, equation (1).</li>\n      * </ul>\n      *\n-     * @param x the value at which the CDF is evaluated.\n+     * @param x Value at which the CDF is evaluated.\n      * @return the CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that {@code P(X < x) = p}.\n-     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n-     *\n-     * @param p the desired probability\n+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n+     * when p = 1.\n+     *\n+     * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.\n      *\n      * @param p Desired probability for the critical value.\n--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n  */\n public interface FDistribution extends ContinuousDistribution {\n     /**\n-     * Modify the numerator degrees of freedom.\n-     * @param degreesOfFreedom the new numerator degrees of freedom.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setNumeratorDegreesOfFreedom(double degreesOfFreedom);\n-\n-    /**\n      * Access the numerator degrees of freedom.\n+     *\n      * @return the numerator degrees of freedom.\n      */\n     double getNumeratorDegreesOfFreedom();\n \n     /**\n-     * Modify the denominator degrees of freedom.\n-     * @param degreesOfFreedom the new denominator degrees of freedom.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setDenominatorDegreesOfFreedom(double degreesOfFreedom);\n-\n-    /**\n      * Access the denominator degrees of freedom.\n+     *\n      * @return the denominator degrees of freedom.\n      */\n     double getDenominatorDegreesOfFreedom();\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.math.distribution;\n \n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.FastMath;\n public class FDistributionImpl\n     extends AbstractContinuousDistribution\n     implements FDistribution, Serializable  {\n-\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8516354193418641566L;\n-\n     /** The numerator degrees of freedom*/\n     private double numeratorDegreesOfFreedom;\n-\n     /** The numerator degrees of freedom*/\n     private double denominatorDegreesOfFreedom;\n-\n     /** Inverse cumulative probability accuracy */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a F distribution using the given degrees of freedom.\n-     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n-     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n+     * @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0}\n+     * or {@code denominatorDegreesOfFreedom <= 0}.\n      */\n     public FDistributionImpl(double numeratorDegreesOfFreedom,\n                              double denominatorDegreesOfFreedom) {\n-        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Create a F distribution using the given degrees of freedom and inverse cumulative probability accuracy.\n-     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n-     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n+        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n+             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create an F distribution using the given degrees of freedom\n+     * and inverse cumulative probability accuracy.\n+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates.\n      * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n-     * @since 2.1\n-     */\n-    public FDistributionImpl(double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom,\n-            double inverseCumAccuracy) {\n-        super();\n-        setNumeratorDegreesOfFreedomInternal(numeratorDegreesOfFreedom);\n-        setDenominatorDegreesOfFreedomInternal(denominatorDegreesOfFreedom);\n+     * @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0}\n+     * or {@code denominatorDegreesOfFreedom <= 0}.\n+     * @since 2.1\n+     */\n+    public FDistributionImpl(double numeratorDegreesOfFreedom,\n+                             double denominatorDegreesOfFreedom,\n+                             double inverseCumAccuracy) {\n+        if (numeratorDegreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   numeratorDegreesOfFreedom);\n+        }\n+        if (denominatorDegreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   denominatorDegreesOfFreedom);\n+        }\n+        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n+        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n         final double logx = FastMath.log(x);\n         final double logn = FastMath.log(numeratorDegreesOfFreedom);\n         final double logm = FastMath.log(denominatorDegreesOfFreedom);\n-        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);\n-        return FastMath.exp(nhalf*logn + nhalf*logx - logx + mhalf*logm - nhalf*lognxm -\n-               mhalf*lognxm - Beta.logBeta(nhalf, mhalf));\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &lt; x).\n-     *\n-     * The implementation of this method is based on:\n+        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\n+                                           denominatorDegreesOfFreedom);\n+        return FastMath.exp(nhalf * logn + nhalf * logx - logx +\n+                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -\n+                            Beta.logBeta(nhalf, mhalf));\n+    }\n+\n+    /**\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * The implementation of this method is based on\n      * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n-     * F-Distribution</a>, equation (4).</li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+     *   F-Distribution</a>, equation (4).\n+     *  </li>\n      * </ul>\n      *\n-     * @param x the value at which the CDF is evaluated.\n+     * @param x Value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * @throws MathException if the cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         double ret;\n-        if (x <= 0.0) {\n-            ret = 0.0;\n+        if (x <= 0) {\n+            ret = 0;\n         } else {\n             double n = numeratorDegreesOfFreedom;\n             double m = denominatorDegreesOfFreedom;\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n+     * @throws MathException if the inverse cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if {@code p} is not a valid\n+     * probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p == 0) {\n-            return 0d;\n+            return 0;\n         }\n         if (p == 1) {\n             return Double.POSITIVE_INFINITY;\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n-        return 0.0;\n-    }\n-\n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+        return 0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n-        double ret = 1.0;\n+        double ret = 1;\n         double d = denominatorDegreesOfFreedom;\n-        if (d > 2.0) {\n+        if (d > 2) {\n             // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (d - 2);\n         }\n         return ret;\n     }\n \n     /**\n-     * Modify the numerator degrees of freedom.\n-     * @param degreesOfFreedom the new numerator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n-        setNumeratorDegreesOfFreedomInternal(degreesOfFreedom);\n-    }\n-\n-    /**\n-     * Modify the numerator degrees of freedom.\n-     * @param degreesOfFreedom the new numerator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     */\n-    private void setNumeratorDegreesOfFreedomInternal(double degreesOfFreedom) {\n-        if (degreesOfFreedom <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);\n-        }\n-        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n-    }\n-\n-    /**\n-     * Access the numerator degrees of freedom.\n-     * @return the numerator degrees of freedom.\n+     * {@inheritDoc}\n      */\n     public double getNumeratorDegreesOfFreedom() {\n         return numeratorDegreesOfFreedom;\n     }\n \n     /**\n-     * Modify the denominator degrees of freedom.\n-     * @param degreesOfFreedom the new denominator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n-        setDenominatorDegreesOfFreedomInternal(degreesOfFreedom);\n-    }\n-\n-    /**\n-     * Modify the denominator degrees of freedom.\n-     * @param degreesOfFreedom the new denominator degrees of freedom.\n-     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n-     *         positive.\n-     */\n-    private void setDenominatorDegreesOfFreedomInternal(double degreesOfFreedom) {\n-        if (degreesOfFreedom <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM, degreesOfFreedom);\n-        }\n-        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n-    }\n-\n-    /**\n-     * Access the denominator degrees of freedom.\n-     * @return the denominator degrees of freedom.\n+     * {@inheritDoc}\n      */\n     public double getDenominatorDegreesOfFreedom() {\n         return denominatorDegreesOfFreedom;\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n      * @return beta.\n      */\n     double getBeta();\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x Point at which the density should be computed..\n-     * @return the pdf at point {@code x}.\n-     */\n-    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n \n     /**\n      * Create a new gamma distribution with the given alpha and beta values.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n      * cumulative probability estimates (defaults to\n      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n      * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &lt; x).\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n      *\n      * The implementation of this method is based on:\n      * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n-     * Chi-Squared Distribution</a>, equation (9).</li>\n-     * <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n-     * Belmont, CA: Duxbury Press.</li>\n+     *  <li>\n+     *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n+     *    Chi-Squared Distribution</a>, equation (9).\n+     *  </li>\n+     *  <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n+     *    Belmont, CA: Duxbury Press.\n+     *  </li>\n      * </ul>\n      *\n-     * @param x the value at which the CDF is evaluated.\n+     * @param x Value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException{\n         double ret;\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that {@code P(X < x) = p}.\n-     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     * It will return 0 when p = 0 and {@code Double.POSITIVE_INFINITY}\n+     * when p = 1.\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n+     * @throws MathException if the inverse cumulative probability cannot be\n      * computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if {@code p} is not a valid\n-     * probability.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n      * @return the standard deviation for this distribution.\n      */\n     double getStandardDeviation();\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x Point at which the density should be computed.\n-     * @return the pdf at point {@code x}.\n-     */\n-    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n \n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n-     * @param mean mean for this distribution\n-     * @param sd standard deviation for this distribution\n+     *\n+     * @param mean Mean for this distribution.\n+     * @param sd Standard deviation for this distribution.\n      */\n     public NormalDistributionImpl(double mean, double sd){\n         this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n      *\n      * @param mean Mean for this distribution.\n      * @param sd Standard deviation for this distribution.\n-     * @param inverseCumAccuracy inverse cumulative probability accuracy.\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n      * @since 2.1\n      */\n         if (sd <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n         }\n-        \n+\n         this.mean = mean;\n         standardDeviation = sd;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public double density(double x) {\n         final double x0 = x - mean;\n         final double x1 = x0 / standardDeviation;\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point \n+     * For this distribution, X, this method returns the critical point\n      * {@code x}, such that {@code P(X < x) = p}.\n-     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and\n+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n      * {@code Double.POSITIVE_INFINITY} for p = 1.\n      *\n-     * @param p the desired probability\n+     * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * @throws MathException if the inverse cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n     }\n \n     /**\n-     * Generates a random value sampled from this distribution.\n-     *\n-     * @return random value\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value\n+     * @throws MathException if an error occurs generating the random value.\n      */\n     @Override\n     public double sample() throws MathException {\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n  */\n public interface TDistribution extends ContinuousDistribution {\n     /**\n-     * Modify the degrees of freedom.\n-     * @param degreesOfFreedom the new degrees of freedom.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setDegreesOfFreedom(double degreesOfFreedom);\n-\n-    /**\n-     * Access the degrees of freedom.\n+     * Access the number of degrees of freedom.\n+     *\n      * @return the degrees of freedom.\n      */\n     double getDegreesOfFreedom();\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.special.Gamma;\n public class TDistributionImpl\n     extends AbstractContinuousDistribution\n     implements TDistribution, Serializable  {\n-\n-    /**\n-     * Default inverse cumulative probability accuracy\n+    /**\n+     * Default inverse cumulative probability accuracy.\n      * @since 2.1\n-    */\n+     */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -5852615386664158222L;\n-\n-    /** The degrees of freedom*/\n+    /** The degrees of freedom. */\n     private double degreesOfFreedom;\n-\n-    /** Inverse cumulative probability accuracy */\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a t distribution using the given degrees of freedom and the\n      * specified inverse cumulative probability absolute accuracy.\n      *\n-     * @param degreesOfFreedom the degrees of freedom.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n      * @since 2.1\n      */\n     public TDistributionImpl(double degreesOfFreedom, double inverseCumAccuracy) {\n-        super();\n-        setDegreesOfFreedomInternal(degreesOfFreedom);\n+        if (degreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   degreesOfFreedom);\n+        }\n+        this.degreesOfFreedom = degreesOfFreedom;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n      * Create a t distribution using the given degrees of freedom.\n-     * @param degreesOfFreedom the degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n      */\n     public TDistributionImpl(double degreesOfFreedom) {\n         this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n-     * Modify the degrees of freedom.\n-     * @param degreesOfFreedom the new degrees of freedom.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setDegreesOfFreedom(double degreesOfFreedom) {\n-        setDegreesOfFreedomInternal(degreesOfFreedom);\n-    }\n-    /**\n-     * Modify the degrees of freedom.\n-     * @param newDegreesOfFreedom the new degrees of freedom.\n-     */\n-    private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {\n-        if (newDegreesOfFreedom <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM,\n-                  newDegreesOfFreedom);\n-        }\n-        this.degreesOfFreedom = newDegreesOfFreedom;\n-    }\n-\n-    /**\n      * Access the degrees of freedom.\n+     *\n      * @return the degrees of freedom.\n      */\n     public double getDegreesOfFreedom() {\n     }\n \n     /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n         final double n = degreesOfFreedom;\n         final double nPlus1Over2 = (n + 1) / 2;\n-        return FastMath.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -\n-                Gamma.logGamma(n/2) - nPlus1Over2 * FastMath.log(1 + x * x /n));\n-    }\n-\n-    /**\n-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluated at <code>x</code>.\n+        return FastMath.exp(Gamma.logGamma(nPlus1Over2) -\n+                            0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -\n+                            Gamma.logGamma(n/2) - nPlus1Over2 * FastMath.log(1 + x * x /n));\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns {@code P(X < x}).\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return CDF evaluated at {@code x}.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException{\n         double ret;\n-        if (x == 0.0) {\n+        if (x == 0) {\n             ret = 0.5;\n         } else {\n             double t =\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     * Returns {@code Double.NEGATIVE_INFINITY} when p = 0 and\n+     * {@code Double.POSITIVE_INFINITY} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n+     * @throws MathException if the inverse cumulative probability cannot be\n+     * computed due to convergence or other numerical errors.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') > p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n     }\n \n     /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n-        return 0.0;\n+        return 0;\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface WeibullDistribution extends ContinuousDistribution {\n-\n     /**\n      * Access the shape parameter.\n+     *\n      * @return the shape parameter.\n      */\n     double getShape();\n \n     /**\n      * Access the scale parameter.\n+     *\n      * @return the scale parameter.\n      */\n     double getScale();\n-\n-    /**\n-     * Modify the shape parameter.\n-     * @param alpha The new shape parameter value.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setShape(double alpha);\n-\n-    /**\n-     * Modify the scale parameter.\n-     * @param beta The new scale parameter value.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setScale(double beta);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n  */\n public class WeibullDistributionImpl extends AbstractContinuousDistribution\n         implements WeibullDistribution, Serializable {\n-\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n-\n     /** The shape parameter. */\n     private double shape;\n-\n     /** The scale parameter. */\n     private double scale;\n-\n-    /** Inverse cumulative probability accuracy */\n+    /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n-     * Creates weibull distribution with the given shape and scale and a\n+     * Create a Weibull distribution with the given shape and scale and a\n      * location equal to zero.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     */\n-    public WeibullDistributionImpl(double alpha, double beta){\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     */\n+    public WeibullDistributionImpl(double alpha, double beta) {\n         this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n-     * Creates weibull distribution with the given shape, scale and inverse\n+     * Create a Weibull distribution with the given shape, scale and inverse\n      * cumulative probability accuracy and a location equal to zero.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n      * @since 2.1\n      */\n-    public WeibullDistributionImpl(double alpha, double beta, double inverseCumAccuracy){\n-        super();\n-        setShapeInternal(alpha);\n-        setScaleInternal(beta);\n+    public WeibullDistributionImpl(double alpha, double beta,\n+                                   double inverseCumAccuracy) {\n+        if (alpha <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE,\n+                                                   alpha);\n+        }\n+        if (beta <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE,\n+                                                   beta);\n+        }\n+        scale = beta;\n+        shape = alpha;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n-     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>.\n+     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     *\n+     * @param x Value at which the CDF is evaluated.\n+     * @return the CDF evaluted at {@code x}.\n      */\n     public double cumulativeProbability(double x) {\n         double ret;\n     }\n \n     /**\n-     * Access the shape parameter.\n-     * @return the shape parameter.\n+     * {@inheritDoc}\n      */\n     public double getShape() {\n         return shape;\n     }\n \n     /**\n-     * Access the scale parameter.\n-     * @return the scale parameter.\n+     * {@inheritDoc}\n      */\n     public double getScale() {\n         return scale;\n     }\n \n     /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n     }\n \n     /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * For this distribution, {@code X}, this method returns the critical\n+     * point {@code x}, such that {@code P(X < x) = p}.\n+     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n+     * {@code Double.POSITIVE_INFINITY} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n+     * @throws OutOfRangeException if {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n+            throw new OutOfRangeException(p, 0.0, 1.0);\n         } else if (p == 0) {\n             ret = 0.0;\n         } else  if (p == 1) {\n         return ret;\n     }\n \n-    /**\n-     * Modify the shape parameter.\n-     * @param alpha the new shape parameter value.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setShape(double alpha) {\n-        setShapeInternal(alpha);\n-    }\n-    /**\n-     * Modify the shape parameter.\n-     * @param alpha the new shape parameter value.\n-     */\n-    private void setShapeInternal(double alpha) {\n-        if (alpha <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_SHAPE,\n-                  alpha);\n-        }\n-        this.shape = alpha;\n-    }\n-\n-    /**\n-     * Modify the scale parameter.\n-     * @param beta the new scale parameter value.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setScale(double beta) {\n-        setScaleInternal(beta);\n-    }\n-    /**\n-     * Modify the scale parameter.\n-     * @param beta the new scale parameter value.\n-     */\n-    private void setScaleInternal(double beta) {\n-        if (beta <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_SCALE,\n-                  beta);\n-        }\n-        this.scale = beta;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+\n+    /**\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n-        return 0.0;\n-    }\n-\n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n+        return 0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n package org.apache.commons.math.exception;\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.util.Localizable;\n \n /**\n  * Exception to be thrown when some argument is out of range.\n     public OutOfRangeException(Number wrong,\n                                Number lo,\n                                Number hi) {\n-        super(LocalizedFormats.OUT_OF_RANGE_SIMPLE, wrong, lo, hi);\n+        this(null, wrong, lo, hi);\n+    }\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions with a\n+     * specific context information.\n+     *\n+     * @param specific Context information.\n+     * @param wrong Requested value.\n+     * @param lo Lower bound.\n+     * @param hi Higher bound.\n+     */\n+    public OutOfRangeException(Localizable specific,\n+                               Number wrong,\n+                               Number lo,\n+                               Number hi) {\n+        super(specific, LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n+              wrong, lo, hi);\n         this.lo = lo;\n         this.hi = hi;\n     }\n+\n     /**\n      * @return the lower bound.\n      */\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     BETA(\"beta\"), /* keep */\n     NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix\"),\n+    DEGREES_OF_FREEDOM(\"degrees of freedom ({0})\"), /* keep */\n     NOT_POSITIVE_DEGREES_OF_FREEDOM(\"degrees of freedom must be positive ({0})\"),\n     NOT_POSITIVE_ELEMENT_AT_INDEX(\"element {0} is not positive: {1}\"),\n     NOT_POSITIVE_EXPONENT(\"invalid exponent {0} (must be positive)\"),\n     NOT_POSITIVE_ROW_DIMENSION(\"invalid row dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_SAMPLE_SIZE(\"sample size must be positive ({0})\"),\n     NOT_POSITIVE_SCALE(\"scale must be positive ({0})\"),\n+    SCALE(\"scale ({0})\"), /* keep */\n     NOT_POSITIVE_SHAPE(\"shape must be positive ({0})\"),\n+    SHAPE(\"shape ({0})\"), /* keep */\n     NOT_POSITIVE_STANDARD_DEVIATION(\"standard deviation must be positive ({0})\"),\n     STANDARD_DEVIATION(\"standard deviation ({0})\"), /* keep */\n     NOT_POSITIVE_UPPER_BOUND(\"upper bound must be positive ({0})\"),\n     OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY(\"observed counts are both zero for entry {0}\"),\n     OUT_OF_BOUNDS_QUANTILE_VALUE(\"out of bounds quantile value: {0}, must be in (0, 100]\"),\n     OUT_OF_BOUND_SIGNIFICANCE_LEVEL(\"out of bounds significance level {0}, must be between {1} and {2}\"),\n+    SIGNIFICANCE_LEVEL(\"significance level ({0})\"), /* keep */\n     OUT_OF_ORDER_ABSCISSA_ARRAY(\"the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n  * @version $Revision$ $Date$\n  */\n public class TTestImpl implements TTest  {\n-\n-    /** Distribution used to compute inference statistics. */\n-    private TDistribution distribution;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public TTestImpl() {\n-        this(new TDistributionImpl(1.0));\n-    }\n-\n-    /**\n-     * Create a test instance using the given distribution for computing\n-     * inference statistics.\n-     * @param t distribution used to compute inference statistics.\n-     * @since 1.2\n-     */\n-    public TTestImpl(TDistribution t) {\n-        super();\n-        setDistribution(t);\n-    }\n-\n     /**\n      * Computes a paired, 2-sample t-statistic based on the data in the input\n      * arrays.  The t-statistic returned is equivalent to what would be returned by\n         checkSampleData(sample2);\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n         return t(meanDifference, 0,\n-                StatUtils.varianceDifference(sample1, sample2, meanDifference),\n-                sample1.length);\n+                 StatUtils.varianceDifference(sample1, sample2, meanDifference),\n+                 sample1.length);\n     }\n \n      /**\n      * @throws MathException if an error occurs performing the test\n      */\n     public boolean tTest(StatisticalSummary sampleStats1,\n-            StatisticalSummary sampleStats2, double alpha)\n-    throws IllegalArgumentException, MathException {\n+                         StatisticalSummary sampleStats2,\n+                         double alpha)\n+        throws MathException {\n         checkSignificanceLevel(alpha);\n         return tTest(sampleStats1, sampleStats2) < alpha;\n     }\n      * @throws MathException if an error occurs computing the p-value\n      */\n     protected double tTest(double m, double mu, double v, double n)\n-    throws MathException {\n+        throws MathException {\n         double t = FastMath.abs(t(m, mu, v, n));\n-        distribution.setDegreesOfFreedom(n - 1);\n+        TDistribution distribution = new TDistributionImpl(n - 1);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n      * @return p-value\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    protected double tTest(double m1, double m2, double v1, double v2,\n-            double n1, double n2)\n-    throws MathException {\n+    protected double tTest(double m1, double m2,\n+                           double v1, double v2,\n+                           double n1, double n2)\n+        throws MathException {\n         double t = FastMath.abs(t(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = 0;\n         degreesOfFreedom = df(v1, v2, n1, n2);\n-        distribution.setDegreesOfFreedom(degreesOfFreedom);\n+        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n      * @return p-value\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    protected double homoscedasticTTest(double m1, double m2, double v1,\n-            double v2, double n1, double n2)\n-    throws MathException {\n+    protected double homoscedasticTTest(double m1, double m2,\n+                                        double v1, double v2,\n+                                        double n1, double n2)\n+        throws MathException {\n         double t = FastMath.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = n1 + n2 - 2;\n-        distribution.setDegreesOfFreedom(degreesOfFreedom);\n+        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n     /**\n-     * Modify the distribution used to compute inference statistics.\n-     * @param value the new distribution\n-     * @since 1.2\n-     */\n-    public void setDistribution(TDistribution value) {\n-        distribution = value;\n-    }\n-\n-    /** Check significance level.\n+     * Check significance level.\n+     *\n      * @param alpha significance level\n-     * @exception IllegalArgumentException if significance level is out of bounds\n-     */\n-    private void checkSignificanceLevel(final double alpha)\n-        throws IllegalArgumentException {\n-        if ((alpha <= 0) || (alpha > 0.5)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n-                  alpha, 0.0, 0.5);\n+     * @throws OutOfRangeException if the significance level is out of bounds.\n+     */\n+    private void checkSignificanceLevel(final double alpha) {\n+        if (alpha <= 0 || alpha > 0.5) {\n+            throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,\n+                                          alpha, 0.0, 0.5);\n         }\n     }\n \n-    /** Check sample data.\n-     * @param data sample data\n-     * @exception IllegalArgumentException if there is not enough sample data\n-     */\n-    private void checkSampleData(final double[] data)\n-        throws IllegalArgumentException {\n-        if ((data == null) || (data.length < 2)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n-                  (data == null) ? 0 : data.length);\n+    /**\n+     * Check sample data.\n+     *\n+     * @param data Sample data.\n+     * @throws NullArgumentException if {@code data} is {@code null}.\n+     * @throws NumberIsTooSmallException if there is not enough sample data.\n+     */\n+    private void checkSampleData(final double[] data) {\n+        if (data == null) {\n+            throw new NullArgumentException();\n         }\n-    }\n-\n-    /** Check sample data.\n-     * @param stat statistical summary\n-     * @exception IllegalArgumentException if there is not enough sample data\n-     */\n-    private void checkSampleData(final StatisticalSummary stat)\n-        throws IllegalArgumentException {\n-        if ((stat == null) || (stat.getN() < 2)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n-                  (stat == null) ? 0 : stat.getN());\n+        if (data.length < 2) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n+                                                data.length, 2, true);\n         }\n     }\n \n+    /**\n+     * Check sample data.\n+     *\n+     * @param stat Statistical summary.\n+     * @throws NullArgumentException if {@code data} is {@code null}.\n+     * @throws NumberIsTooSmallException if there is not enough sample data.\n+     */\n+    private void checkSampleData(final StatisticalSummary stat) {\n+        if (stat == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (stat.getN() < 2) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC,\n+                                                stat.getN(), 2, true);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      * Create an empty SimpleRegression instance\n      */\n     public SimpleRegression() {\n-        this(new TDistributionImpl(1.0));\n+        this(1);\n     }\n \n     /**\n      * Create an empty SimpleRegression using the given distribution object to\n      * compute inference statistics.\n-     * @param t the distribution used to compute inference statistics.\n-     * @since 1.2\n-     */\n-    public SimpleRegression(TDistribution t) {\n-        super();\n-        setDistribution(t);\n+     *\n+     * @param degrees Number of degrees of freedom of the distribution used\n+     * to compute inference statistics.\n+     * @since 2.2\n+     */\n+    public SimpleRegression(int degrees) {\n+        distribution = new TDistributionImpl(degrees);\n     }\n \n     /**\n         n++;\n \n         if (n > 2) {\n-            distribution.setDegreesOfFreedom(n - 2);\n+            distribution = new TDistributionImpl(n - 2);\n         }\n     }\n \n             n--;\n \n             if (n > 2) {\n-                distribution.setDegreesOfFreedom(n - 2);\n+                distribution = new TDistributionImpl(n - 2);\n             }\n         }\n     }\n     public double getSlopeConfidenceInterval(double alpha)\n         throws MathException {\n         if (alpha >= 1 || alpha <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL,\n-                  alpha, 0.0, 1.0);\n+            throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,\n+                                          alpha, 0, 1);\n         }\n         return getSlopeStdErr() *\n             distribution.inverseCumulativeProbability(1d - alpha / 2d);\n     private double getRegressionSumSquares(double slope) {\n         return slope * slope * sumXX;\n     }\n-\n-    /**\n-     * Modify the distribution used to compute inference statistics.\n-     * @param value the new distribution\n-     * @since 1.2\n-     */\n-    public void setDistribution(TDistribution value) {\n-        distribution = value;\n-\n-        // modify degrees of freedom\n-        if (n > 2) {\n-            distribution.setDegreesOfFreedom(n - 2);\n-        }\n-    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for CauchyDistribution.\n \n     public void testMedian() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = FastMath.random();\n-        distribution.setMedian(expected);\n-        assertEquals(expected, distribution.getMedian(), 0.0);\n+        assertEquals(1.2, distribution.getMedian(), 0.0);\n     }\n \n     public void testScale() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = FastMath.random();\n-        distribution.setScale(expected);\n-        assertEquals(expected, distribution.getScale(), 0.0);\n+        assertEquals(2.1, distribution.getScale(), 0.0);\n     }\n \n-    public void testSetScale() {\n-        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+    public void testPreconditions() {\n+        CauchyDistribution dist;\n         try {\n-            distribution.setScale(0.0);\n-            fail(\"Can not have 0.0 scale.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n+            dist = new CauchyDistributionImpl(0, 0);\n+            fail(\"Cannot have zero scale\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n-\n         try {\n-            distribution.setScale(-1.0);\n-            fail(\"Can not have negative scale.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n+            dist = new CauchyDistributionImpl(0, -1);\n+            fail(\"Cannot have negative scale\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for FDistribution.\n     }\n \n     public void testDfAccessors() {\n-        FDistribution distribution = (FDistribution) getDistribution();\n-        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n-        distribution.setNumeratorDegreesOfFreedom(4d);\n-        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n-        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n-        distribution.setDenominatorDegreesOfFreedom(4d);\n-        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n+        FDistribution dist = (FDistribution) getDistribution();\n+        assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n+        assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);\n+    }\n+\n+    public void testPreconditions() {\n+        FDistribution dist;\n         try {\n-            distribution.setNumeratorDegreesOfFreedom(0d);\n-            fail(\"Expecting IllegalArgumentException for df = 0\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n+            dist = new FDistributionImpl(0, 1);\n+            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n         try {\n-            distribution.setDenominatorDegreesOfFreedom(0d);\n-            fail(\"Expecting IllegalArgumentException for df = 0\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n+            dist = new FDistributionImpl(1, 0);\n+            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n     }\n \n     public void testLargeDegreesOfFreedom() throws Exception {\n-        org.apache.commons.math.distribution.FDistributionImpl fd =\n-            new org.apache.commons.math.distribution.FDistributionImpl(\n-                100000., 100000.);\n+        FDistributionImpl fd = new FDistributionImpl(100000, 100000);\n         double p = fd.cumulativeProbability(.999);\n         double x = fd.inverseCumulativeProbability(p);\n         assertEquals(.999, x, 1.0e-5);\n     }\n \n     public void testSmallDegreesOfFreedom() throws Exception {\n-        org.apache.commons.math.distribution.FDistributionImpl fd =\n-            new org.apache.commons.math.distribution.FDistributionImpl(\n-                1.0, 1.0);\n+        FDistributionImpl fd = new FDistributionImpl(1, 1);\n         double p = fd.cumulativeProbability(0.975);\n         double x = fd.inverseCumulativeProbability(p);\n         assertEquals(0.975, x, 1.0e-5);\n \n-        fd.setDenominatorDegreesOfFreedom(2.0);\n+        fd = new FDistributionImpl(1, 2);\n         p = fd.cumulativeProbability(0.975);\n         x = fd.inverseCumulativeProbability(p);\n         assertEquals(0.975, x, 1.0e-5);\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for TDistribution.\n     }\n \n     public void testDfAccessors() {\n-        TDistribution distribution = (TDistribution) getDistribution();\n-        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n-        distribution.setDegreesOfFreedom(4d);\n-        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n+        TDistribution dist = (TDistribution) getDistribution();\n+        assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);\n+    }\n+\n+    public void testPreconditions() {\n         try {\n-            distribution.setDegreesOfFreedom(0d);\n-            fail(\"Expecting IllegalArgumentException for df = 0\");\n-        } catch (IllegalArgumentException ex) {\n+            TDistribution dist = new TDistributionImpl(0);\n+            fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n+        } catch (NotStrictlyPositiveException ex) {\n             // expected\n         }\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for WeibullDistribution.\n     }\n \n     public void testAlpha() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = FastMath.random();\n-        distribution.setShape(expected);\n-        assertEquals(expected, distribution.getShape(), 0.0);\n+        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n+        assertEquals(1, dist.getShape(), 0);\n+        try {\n+            dist = new WeibullDistributionImpl(0, 2);\n+            fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n+        }\n     }\n \n     public void testBeta() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = FastMath.random();\n-        distribution.setScale(expected);\n-        assertEquals(expected, distribution.getScale(), 0.0);\n-    }\n-\n-    public void testSetAlpha() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n+        assertEquals(2, dist.getScale(), 0);\n         try {\n-            distribution.setShape(0.0);\n-            fail(\"Can not have 0.0 alpha.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-\n-        try {\n-            distribution.setShape(-1.0);\n-            fail(\"Can not have negative alpha.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n-    public void testSetBeta() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        try {\n-            distribution.setScale(0.0);\n-            fail(\"Can not have 0.0 beta.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-\n-        try {\n-            distribution.setScale(-1.0);\n-            fail(\"Can not have negative beta.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n+            dist = new WeibullDistributionImpl(1, 0);\n+            fail(\"NotStrictlyPositiveException expected\");\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n         }\n     }\n }", "timestamp": 1285851302, "metainfo": ""}