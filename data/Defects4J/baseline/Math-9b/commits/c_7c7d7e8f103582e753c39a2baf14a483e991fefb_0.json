{"sha": "7c7d7e8f103582e753c39a2baf14a483e991fefb", "log": "MATH-867 Modified \"encode\" and \"decode\" methods. Unit test \"testFitAccuracyDependsOnBoundary\" now passes and is thus enabled. Unit test \"testConstrainedRosen\" had to be modified in order to not fail with the new code (starting point is set closer to the solution).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n         for (int i = 0; i < guess.length; i++) {\n-            final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n+            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n         }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = (x[i] - boundaries[0][i]) / diff;\n+                res[i] = x[i] / diff;\n             }\n             return res;\n         }\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i] + boundaries[0][i];\n+                res[i] = diff * x[i];\n             }\n             return res;\n         }\n             if (boundaries == null) {\n                 return true;\n             }\n+\n+            final double[] bLoEnc = encode(boundaries[0]);\n+            final double[] bHiEnc = encode(boundaries[1]);\n+\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n+                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n-                if (x[i] > 1.0) {\n+                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n \n     @Test\n     public void testConstrainedRosen() {\n-        double[] startPoint = point(DIM, 0.1);\n-        double[] insigma = point(DIM, 1);\n+        double[] startPoint = point(DIM, 0.7);\n+        double[] insigma = point(DIM, 0.1);\n         double[][] boundaries = boundaries(DIM, -1, 2);\n         PointValuePair expected =\n             new PointValuePair(point(DIM,1.0),0.0);\n     /**\n      * Cf. MATH-867\n      */\n-    @Ignore@Test\n+    @Test\n     public void testFitAccuracyDependsOnBoundary() {\n         final CMAESOptimizer optimizer = new CMAESOptimizer();\n         final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n             };\n \n         final double[] start = { 1 };\n-\n+ \n         // No bounds.\n         PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                                    start);", "timestamp": 1348937898, "metainfo": ""}