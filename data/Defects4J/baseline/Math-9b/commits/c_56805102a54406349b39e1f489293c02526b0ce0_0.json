{"sha": "56805102a54406349b39e1f489293c02526b0ce0", "log": "Moved private class o.a.c.m.transform.FastFourierTransformer.RootsOfUnity to o.a.c.m.complex.RootsOfUnity (MATH-677).  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/complex/RootsOfUnity.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.complex;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * A helper class for the computation and caching of the {@code n}<sup>th</sup>\n+ * roots of unity.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class RootsOfUnity implements Serializable {\n+\n+    /** Serializable version id. */\n+    private static final long serialVersionUID = 6404784357747329667L;\n+\n+    /** Number of roots of unity. */\n+    private int omegaCount;\n+\n+    /** Real part of the roots. */\n+    private double[] omegaReal;\n+\n+    /** Imaginary part of the roots for forward transform. */\n+    private double[] omegaImaginaryForward;\n+\n+    /** Imaginary part of the roots for reverse transform. */\n+    private double[] omegaImaginaryInverse;\n+\n+    /** Forward/reverse indicator. */\n+    private boolean isForward;\n+\n+    /**\n+     * Build an engine for computing the {@code n}<sup>th</sup> roots of\n+     * unity.\n+     */\n+    public RootsOfUnity() {\n+\n+        omegaCount = 0;\n+        omegaReal = null;\n+        omegaImaginaryForward = null;\n+        omegaImaginaryInverse = null;\n+        isForward = true;\n+    }\n+\n+    /**\n+     * Check if computation has been done for forward or reverse transform.\n+     *\n+     * @return {@code true} if computation has been done for forward transform\n+     * @throws MathIllegalStateException if no roots of unity have been computed\n+     * yet\n+     */\n+    public synchronized boolean isForward()\n+            throws MathIllegalStateException {\n+\n+        if (omegaCount == 0) {\n+            throw new MathIllegalStateException(\n+                    LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+        }\n+        return isForward;\n+    }\n+\n+    /**\n+     * <p>\n+     * Computes the {@code n}<sup>th</sup> roots of unity. The roots are\n+     * stored in {@code omega[]}, such that {@code omega[k] = w ^ k}, where\n+     * {@code k = 0, ..., n - 1}, {@code w = exp(-2 &pi; i / n)} and\n+     * {@code i = sqrt(-1)}.\n+     * </p>\n+     * <p>\n+     * Note that {@code n} is positive for forward transform and negative\n+     * for inverse transform.\n+     * </p>\n+     *\n+     * @param n number of roots of unity to compute, positive for forward\n+     * transform, negative for inverse transform\n+     * @throws ZeroException if {@code n = 0}\n+     */\n+    public synchronized void computeOmega(int n) throws ZeroException {\n+\n+        if (n == 0) {\n+            throw new ZeroException(\n+                    LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);\n+        }\n+\n+        isForward = n > 0;\n+\n+        // avoid repetitive calculations\n+        final int absN = FastMath.abs(n);\n+\n+        if (absN == omegaCount) {\n+            return;\n+        }\n+\n+        // calculate everything from scratch, for both forward and inverse\n+        // versions\n+        final double t = 2.0 * FastMath.PI / absN;\n+        final double cosT = FastMath.cos(t);\n+        final double sinT = FastMath.sin(t);\n+        omegaReal = new double[absN];\n+        omegaImaginaryForward = new double[absN];\n+        omegaImaginaryInverse = new double[absN];\n+        omegaReal[0] = 1.0;\n+        omegaImaginaryForward[0] = 0.0;\n+        omegaImaginaryInverse[0] = 0.0;\n+        for (int i = 1; i < absN; i++) {\n+            omegaReal[i] = omegaReal[i - 1] * cosT +\n+                    omegaImaginaryForward[i - 1] * sinT;\n+            omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT -\n+                    omegaReal[i - 1] * sinT;\n+            omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n+        }\n+        omegaCount = absN;\n+    }\n+\n+    /**\n+     * Get the real part of the {@code k}<sup>th</sup>\n+     * {@code n}<sup>th</sup> root of unity.\n+     *\n+     * @param k index of the {@code n}<sup>th</sup> root of unity\n+     * @return real part of the {@code k}<sup>th</sup>\n+     * {@code n}<sup>th</sup> root of unity\n+     * @throws MathIllegalStateException if no roots of unity have been\n+     * computed yet\n+     * @throws MathIllegalArgumentException if {@code k} is out of range\n+     */\n+    public synchronized double getOmegaReal(int k)\n+            throws MathIllegalStateException, MathIllegalArgumentException {\n+\n+        if (omegaCount == 0) {\n+            throw new MathIllegalStateException(\n+                    LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+            throw new OutOfRangeException(\n+                    LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n+                    Integer.valueOf(k),\n+                    Integer.valueOf(0),\n+                    Integer.valueOf(omegaCount - 1));\n+        }\n+\n+        return omegaReal[k];\n+    }\n+\n+    /**\n+     * Get the imaginary part of the {@code k}<sup>th</sup>\n+     * {@code n}<sup>th</sup> root of unity.\n+     *\n+     * @param k index of the {@code n}<sup>th</sup> root of unity\n+     * @return imaginary part of the {@code k}<sup>th</sup>\n+     * {@code n}<sup>th</sup> root of unity\n+     * @throws MathIllegalStateException if no roots of unity have been\n+     * computed yet\n+     * @throws OutOfRangeException if {@code k} is out of range\n+     */\n+    public synchronized double getOmegaImaginary(int k)\n+            throws MathIllegalStateException, OutOfRangeException {\n+\n+        if (omegaCount == 0) {\n+            throw new MathIllegalStateException(\n+                    LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+            throw new OutOfRangeException(\n+                    LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n+                    Integer.valueOf(k),\n+                    Integer.valueOf(0),\n+                    Integer.valueOf(omegaCount - 1));\n+        }\n+\n+        return isForward ? omegaImaginaryForward[k] :\n+            omegaImaginaryInverse[k];\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.analysis.FunctionUtils;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.complex.RootsOfUnity;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n             }\n         }\n     }\n-\n-\n-    /**\n-     * Computes the {@code n}<sup>th</sup> roots of unity. A cache of already\n-     * computed values is maintained.\n-     */\n-    private static class RootsOfUnity implements Serializable {\n-\n-        /** Serializable version id. */\n-        private static final long serialVersionUID = 6404784357747329667L;\n-\n-        /** Number of roots of unity. */\n-        private int omegaCount;\n-\n-        /** Real part of the roots. */\n-        private double[] omegaReal;\n-\n-        /** Imaginary part of the roots for forward transform. */\n-        private double[] omegaImaginaryForward;\n-\n-        /** Imaginary part of the roots for reverse transform. */\n-        private double[] omegaImaginaryInverse;\n-\n-        /** Forward/reverse indicator. */\n-        private boolean isForward;\n-\n-        /**\n-         * Build an engine for computing the {@code n}<sup>th</sup> roots of\n-         * unity.\n-         */\n-        public RootsOfUnity() {\n-\n-            omegaCount = 0;\n-            omegaReal = null;\n-            omegaImaginaryForward = null;\n-            omegaImaginaryInverse = null;\n-            isForward = true;\n-        }\n-\n-        /**\n-         * Check if computation has been done for forward or reverse transform.\n-         *\n-         * @return {@code true} if computation has been done for forward transform\n-         * @throws MathIllegalStateException if no roots of unity have been computed\n-         * yet\n-         */\n-        public synchronized boolean isForward()\n-                throws MathIllegalStateException {\n-\n-            if (omegaCount == 0) {\n-                throw new MathIllegalStateException(\n-                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-            }\n-            return isForward;\n-        }\n-\n-        /**\n-         * <p>\n-         * Computes the {@code n}<sup>th</sup> roots of unity. The roots are\n-         * stored in {@code omega[]}, such that {@code omega[k] = w ^ k}, where\n-         * {@code k = 0, ..., n - 1}, {@code w = exp(-2 &pi; i / n)} and\n-         * {@code i = sqrt(-1)}.\n-         * </p>\n-         * <p>\n-         * Note that {@code n} is positive for forward transform and negative\n-         * for inverse transform.\n-         * </p>\n-         *\n-         * @param n number of roots of unity to compute, positive for forward\n-         * transform, negative for inverse transform\n-         * @throws ZeroException if {@code n = 0}\n-         */\n-        public synchronized void computeOmega(int n) throws ZeroException {\n-\n-            if (n == 0) {\n-                throw new ZeroException(\n-                        LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);\n-            }\n-\n-            isForward = n > 0;\n-\n-            // avoid repetitive calculations\n-            final int absN = FastMath.abs(n);\n-\n-            if (absN == omegaCount) {\n-                return;\n-            }\n-\n-            // calculate everything from scratch, for both forward and inverse\n-            // versions\n-            final double t = 2.0 * FastMath.PI / absN;\n-            final double cosT = FastMath.cos(t);\n-            final double sinT = FastMath.sin(t);\n-            omegaReal = new double[absN];\n-            omegaImaginaryForward = new double[absN];\n-            omegaImaginaryInverse = new double[absN];\n-            omegaReal[0] = 1.0;\n-            omegaImaginaryForward[0] = 0.0;\n-            omegaImaginaryInverse[0] = 0.0;\n-            for (int i = 1; i < absN; i++) {\n-                omegaReal[i] = omegaReal[i - 1] * cosT +\n-                        omegaImaginaryForward[i - 1] * sinT;\n-                omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT -\n-                        omegaReal[i - 1] * sinT;\n-                omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n-            }\n-            omegaCount = absN;\n-        }\n-\n-        /**\n-         * Get the real part of the {@code k}<sup>th</sup>\n-         * {@code n}<sup>th</sup> root of unity.\n-         *\n-         * @param k index of the {@code n}<sup>th</sup> root of unity\n-         * @return real part of the {@code k}<sup>th</sup>\n-         * {@code n}<sup>th</sup> root of unity\n-         * @throws MathIllegalStateException if no roots of unity have been\n-         * computed yet\n-         * @throws MathIllegalArgumentException if {@code k} is out of range\n-         */\n-        public synchronized double getOmegaReal(int k)\n-                throws MathIllegalStateException, MathIllegalArgumentException {\n-\n-            if (omegaCount == 0) {\n-                throw new MathIllegalStateException(\n-                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-            }\n-            if ((k < 0) || (k >= omegaCount)) {\n-                throw new OutOfRangeException(\n-                        LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n-                        Integer.valueOf(k),\n-                        Integer.valueOf(0),\n-                        Integer.valueOf(omegaCount - 1));\n-            }\n-\n-            return omegaReal[k];\n-        }\n-\n-        /**\n-         * Get the imaginary part of the {@code k}<sup>th</sup>\n-         * {@code n}<sup>th</sup> root of unity.\n-         *\n-         * @param k index of the {@code n}<sup>th</sup> root of unity\n-         * @return imaginary part of the {@code k}<sup>th</sup>\n-         * {@code n}<sup>th</sup> root of unity\n-         * @throws MathIllegalStateException if no roots of unity have been\n-         * computed yet\n-         * @throws OutOfRangeException if {@code k} is out of range\n-         */\n-        public synchronized double getOmegaImaginary(int k)\n-                throws MathIllegalStateException, OutOfRangeException {\n-\n-            if (omegaCount == 0) {\n-                throw new MathIllegalStateException(\n-                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-            }\n-            if ((k < 0) || (k >= omegaCount)) {\n-                throw new OutOfRangeException(\n-                        LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n-                        Integer.valueOf(k),\n-                        Integer.valueOf(0),\n-                        Integer.valueOf(omegaCount - 1));\n-            }\n-\n-            return isForward ? omegaImaginaryForward[k] :\n-                omegaImaginaryInverse[k];\n-        }\n-    }\n }", "timestamp": 1327905046, "metainfo": ""}