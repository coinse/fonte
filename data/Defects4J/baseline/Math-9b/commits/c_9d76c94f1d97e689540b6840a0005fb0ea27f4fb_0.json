{"sha": "9d76c94f1d97e689540b6840a0005fb0ea27f4fb", "log": "MATH-650 Refactored inner classes so that one can switch (at compile time) between using preset arrays or computing their contents.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n     private static final int EXP_INT_TABLE_MAX_INDEX = 750;\n     private static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n \n+    private static final boolean INIT_TABLES = true;\n+\n     // Enclose large data table in nested static class so it's only loaded on first access\n-  private static class ExpIntTable {\n-\n-    /** Exponential evaluated at integer values,\n-     * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n-     */\n-    private static final double EXP_INT_TABLE_A[] = \n-    {\n+    private static class ExpIntTable {\n+        /** Exponential evaluated at integer values,\n+         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n+         */\n+        private static final double[] EXP_INT_TABLE_A;\n+        /** Exponential evaluated at integer values,\n+         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]\n+         */\n+        private static final double[] EXP_INT_TABLE_B;\n+\n+        static {\n+            if (FastMath.INIT_TABLES) {\n+                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n+                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n+\n+                final double tmp[] = new double[2];\n+                final double recip[] = new double[2];\n+\n+                // Populate expIntTable\n+                for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n+                    expint(i, tmp);\n+                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n+                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n+\n+                    if (i != 0) {\n+                        // Negative integer powers\n+                        splitReciprocal(tmp, recip);\n+                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n+                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n+                    }\n+                }\n+            } else {\n+                EXP_INT_TABLE_A = new double[] {\n         +0.0d,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n-    };\n-\n-    /** Exponential evaluated at integer values,\n-     * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]\n-     */\n-    private static final double EXP_INT_TABLE_B[] =\n-    {\n+                };\n+\n+                EXP_INT_TABLE_B = new double[] {\n         +0.0d,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n         Double.NaN,\n-    };\n-  }\n-\n-    private static final int TWO_POWER_10 = 1024;\n-    private static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n-\n-    // Enclose large data table in nested static class so it's only loaded on first access\n-  private static class ExpFracTable {\n-\n-    /** Exponential over the range of 0 - 1 in increments of 2^-10\n-     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n-     * 1024 = 2^10\n-     */\n-    private static final double EXP_FRAC_TABLE_A[] = \n-        {\n+                };\n+            }\n+        }\n+    }\n+\n+      private static final int TWO_POWER_10 = 1024;\n+      private static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n+\n+      // Enclose large data table in nested static class so it's only loaded on first access\n+      private static class ExpFracTable {\n+          /** Exponential over the range of 0 - 1 in increments of 2^-10\n+           * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+           * 1024 = 2^10\n+           */\n+          private static final double[] EXP_FRAC_TABLE_A;\n+          /** Exponential over the range of 0 - 1 in increments of 2^-10\n+           * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+           */\n+          private static final double[] EXP_FRAC_TABLE_B;\n+\n+          static {\n+              if (FastMath.INIT_TABLES) {\n+                  EXP_FRAC_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n+                  EXP_FRAC_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n+\n+                  final double tmp[] = new double[2];\n+                  final double recip[] = new double[2];\n+\n+                  // Populate expFracTable\n+                  for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n+                      slowexp(i/1024.0, tmp); // TWO_POWER_10\n+                      EXP_FRAC_TABLE_A[i] = tmp[0];\n+                      EXP_FRAC_TABLE_B[i] = tmp[1];\n+                  }\n+              } else {\n+                  EXP_FRAC_TABLE_A = new double[] {\n         +1.0d,\n         +1.0009770393371582d,\n         +1.0019550323486328d,\n         +2.712977886199951d,\n         +2.7156286239624023d,\n         +2.7182817459106445d,\n-    };\n-\n-    /** Exponential over the range of 0 - 1 in increments of 2^-10\n-     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n-     */\n-    private static final double EXP_FRAC_TABLE_B[] =\n-        {\n+                  };\n+\n+                  EXP_FRAC_TABLE_B = new double[] {\n         +0.0d,\n         +1.552583321178453E-10d,\n         +1.2423699995465188E-9d,\n         -2.0599801342241997E-8d,\n         -7.184550924856607E-8d,\n         +8.254840070367875E-8d,\n-    };\n-  }\n+                  };\n+              }\n+          }\n+      }\n \n     private static final int FACT_LEN = 20;\n \n         +3.55687428096E14d,           \n         +6.402373705728E15d,          \n         +1.21645100408832E17d,\n-    };\n-            \n+        };\n \n     private static final int LN_MANT_LEN = 1024; // MAGIC NUMBER\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n-  private static class lnMant {\n-\n-    /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n-    private static final double LN_MANT[][] =     { \n+      private static class lnMant {\n+          /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n+          private static final double[][] LN_MANT;\n+\n+          static {\n+              if (FastMath.INIT_TABLES) {\n+                  LN_MANT = new double[FastMath.LN_MANT_LEN][];\n+\n+                  // Populate lnMant table\n+                  for (int i = 0; i < LN_MANT.length; i++) {\n+                      final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n+                      LN_MANT[i] = slowLog(d);\n+                  }\n+              } else {\n+                  LN_MANT = new double[][] { \n         {+0.0d,                   +0.0d,                   }, // 0\n         {+9.760860120877624E-4d,  -3.903230345984362E-11d, }, // 1\n         {+0.0019512202125042677d, -8.124251825289188E-11d, }, // 2\n         {+0.6916812658309937d,    -2.9535446262017846E-9d, }, // 1021\n         {+0.6921701431274414d,    -2.2153227096187463E-9d, }, // 1022\n         {+0.6926587820053101d,    -1.943473623641502E-9d,  }, // 1023\n-    };\n-  }\n-\n+                  };\n+              }\n+          }\n+      }\n \n     /** log(2) (high bits). */\n     private static final double LN_2_A = 0.693147063255310059;\n \n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n-\n-    private static final boolean INIT_TABLES = false;\n     \n     // Initialize tables\n-    static {\n-      if (INIT_TABLES) { // suppress table initialisation as now hard-coded\n-        int i;\n-\n-        // Generate an array of factorials\n-        FACT[0] = 1.0;\n-        for (i = 1; i < FACT.length; i++) {\n-            FACT[i] = FACT[i-1] * i;\n-        }\n-\n-        double tmp[] = new double[2];\n-        double recip[] = new double[2];\n-\n-        // Populate expIntTable\n-        for (i = 0; i < EXP_INT_TABLE_MAX_INDEX; i++) {\n-            expint(i, tmp);\n-            ExpIntTable.EXP_INT_TABLE_A[i+EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n-            ExpIntTable.EXP_INT_TABLE_B[i+EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n-\n-            if (i != 0) {\n-                // Negative integer powers\n-                splitReciprocal(tmp, recip);\n-                ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-i] = recip[0];\n-                ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-i] = recip[1];\n-            }\n-        }\n-\n-        // Populate expFracTable\n-        for (i = 0; i < ExpFracTable.EXP_FRAC_TABLE_A.length; i++) {\n-            slowexp(i/1024.0, tmp); // TWO_POWER_10\n-            ExpFracTable.EXP_FRAC_TABLE_A[i] = tmp[0];\n-            ExpFracTable.EXP_FRAC_TABLE_B[i] = tmp[1];\n-        }\n-\n-        // Populate lnMant table\n-        for (i = 0; i < lnMant.LN_MANT.length; i++) {\n-            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n-            lnMant.LN_MANT[i] = slowLog(d);\n-        }\n-\n-        // Build the sine and cosine tables\n-        buildSinCosTables();\n-      }\n-    }\n+    // static {\n+    //   if (INIT_TABLES) { // suppress table initialisation as now hard-coded\n+    //     int i;\n+\n+    //     // Generate an array of factorials\n+    //     FACT[0] = 1.0;\n+    //     for (i = 1; i < FACT.length; i++) {\n+    //         FACT[i] = FACT[i-1] * i;\n+    //     }\n+\n+    //     // Build the sine and cosine tables\n+    //     buildSinCosTables();\n+    //   }\n+    // }\n \n     public static void main(String[] a){\n         printarray(\"FACT\", FACT_LEN, FACT);", "timestamp": 1315701011, "metainfo": ""}