{"sha": "d64c1768c3fc4898ea80fd6fdce73666eb275b0d", "log": "improved error messages  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n+\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n  * Population of chromosomes represented by a {@link List}.\n      */\n     public ListPopulation (List<Chromosome> chromosomes, int populationLimit) {\n         if (chromosomes.size() > populationLimit) {\n-            throw new IllegalArgumentException(\"List of chromosomes bigger than maxPopulationSize.\");\n+            throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE,\n+                                                chromosomes.size(), populationLimit, false);\n         }\n         if (populationLimit < 0) {\n-            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+            throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n         }\n \n         this.chromosomes = chromosomes;\n      */\n     public ListPopulation (int populationLimit) {\n         if (populationLimit < 0) {\n-            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+            throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n         }\n         this.populationLimit = populationLimit;\n         this.chromosomes = new ArrayList<Chromosome>(populationLimit);\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n     ITERATOR_EXHAUSTED(\"iterator exhausted\"),\n     LCM_OVERFLOW_32_BITS(\"overflow: lcm({0}, {1}) is 2^31\"),\n     LCM_OVERFLOW_64_BITS(\"overflow: lcm({0}, {1}) is 2^63\"),\n+    LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE(\"list of chromosomes bigger than maxPopulationSize\"),\n     LOESS_EXPECTS_AT_LEAST_ONE_POINT(\"Loess expects at least 1 point\"),\n     LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"lower bound ({0}) must be strictly less than upper bound ({1})\"), /* keep */\n     LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT(\"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n+    OVERFLOW_IN_ADDITION(\"overflow in addition: {0} + {1}\"),\n+    OVERFLOW_IN_SUBTRACTION(\"overflow in subtraction: {0} - {1}\"),\n     PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD(\"cannot access {0} method in percentile implementation {1}\"),\n     PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD(\"percentile implementation {0} does not support {1}\"),\n     PERMUTATION_EXCEEDS_N(\"permutation size ({0}) exceeds permuation domain ({1})\"), /* keep */\n     POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS(\"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\"),\n+    POPULATION_LIMIT_NOT_POSITIVE(\"population limit has to be positive\"),\n     POSITION_SIZE_MISMATCH_INPUT_ARRAY(\"position {0} and size {1} don't fit to the size of the input array {2}\"),\n     POWER_NEGATIVE_PARAMETERS(\"cannot raise an integral value to a negative power ({0}^{1})\"),\n     PROPAGATION_DIRECTION_MISMATCH(\"propagation direction mismatch\"),\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     public static int addAndCheck(int x, int y) {\n         long s = (long)x + (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"overflow: add\");\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n         }\n         return (int)s;\n     }\n      * @since 1.2\n      */\n     public static long addAndCheck(long a, long b) {\n-        return addAndCheck(a, b, \"overflow: add\");\n+        return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n     }\n \n     /**\n      *\n      * @param a an addend\n      * @param b an addend\n-     * @param msg the message to use for any thrown exception.\n+     * @param pattern the pattern to use for any thrown exception.\n      * @return the sum <code>a+b</code>\n      * @throws ArithmeticException if the result can not be represented as an\n      *         long\n      * @since 1.2\n      */\n-    private static long addAndCheck(long a, long b, String msg) {\n+    private static long addAndCheck(long a, long b, Localizable pattern) {\n         long ret;\n         if (a > b) {\n             // use symmetry to reduce boundary cases\n-            ret = addAndCheck(b, a, msg);\n+            ret = addAndCheck(b, a, pattern);\n         } else {\n             // assert a <= b\n \n                     if (Long.MIN_VALUE - b <= a) {\n                         ret = a + b;\n                     } else {\n-                        throw new ArithmeticException(msg);\n+                        throw MathRuntimeException.createArithmeticException(pattern, a, b);\n                     }\n                 } else {\n                     // opposite sign addition is always safe\n                 if (a <= Long.MAX_VALUE - b) {\n                     ret = a + b;\n                 } else {\n-                    throw new ArithmeticException(msg);\n+                    throw MathRuntimeException.createArithmeticException(pattern, a, b);\n                 }\n             }\n         }\n     public static int subAndCheck(int x, int y) {\n         long s = (long)x - (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"overflow: subtract\");\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n         }\n         return (int)s;\n     }\n             }\n         } else {\n             // use additive inverse\n-            ret = addAndCheck(a, -b, msg);\n+            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n         }\n         return ret;\n     }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n import junit.framework.TestCase;\n             MathUtils.subAndCheck(big, -1);\n             fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n-            assertEquals(\"overflow: subtract\", ex.getMessage());\n+            assertTrue(ex.getMessage().length() > 1);\n         }\n     }\n ", "timestamp": 1280678996, "metainfo": ""}