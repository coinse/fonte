{"sha": "641ff186556957fe30ba08109439c58b7bdb5e99", "log": "Javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n  * </p>\n  * <h3>Preconditioning</h3>\n  * <p>\n- * Preconditioning may reduce the number of iterations required. The solver may be\n- * provided with a positive definite preconditioner M = C &middot; C<sup>T</sup>\n- * that is known to approximate (A - shift &middot; I) in some sense, where\n- * systems of the form M &middot; y = x can be solved efficiently. Then SYMMLQ\n- * will implicitly solve the system of equations P &middot; (A - shift &middot;\n- * I) &middot; P<sup>T</sup> &middot; xhat = P &middot; b, i.e. Ahat &middot;\n- * xhat = bhat, where P = C<sup>-1</sup>, Ahat = P &middot; (A - shift &middot;\n- * I) &middot; P<sup>T</sup>, bhat = P &middot; b, and return the solution x =\n- * P<sup>T</sup> &middot; xhat. The associated residual is rhat = bhat - Ahat\n- * &middot; xhat = P &middot; [b - (A - shift &middot; I) &middot; x] = P\n- * &middot; r.\n+ * Preconditioning may reduce the number of iterations required. The solver may\n+ * be provided with a positive definite preconditioner\n+ * M = C &middot; C<sup>T</sup>\n+ * that is known to approximate\n+ * (A - shift &middot; I) in some sense, where systems of the form\n+ * M &middot; y = x\n+ * can be solved efficiently. Then SYMMLQ will implicitly solve the system of\n+ * equations\n+ * P &middot; (A - shift &middot; I) &middot; P<sup>T</sup> &middot;\n+ * x<sub>hat</sub> = P &middot; b, i.e.\n+ * A<sub>hat</sub> &middot; x<sub>hat</sub> = b<sub>hat</sub>,\n+ * where P = C<sup>-1</sup>,\n+ * A<sub>hat</sub> = P &middot; (A - shift &middot; I) &middot; P<sup>T</sup>,\n+ * b<sub>hat</sub> = P &middot; b,\n+ * and return the solution\n+ * x = P<sup>T</sup> &middot; x<sub>hat</sub>.\n+ * The associated residual is\n+ * r<sub>hat</sub> = b<sub>hat</sub> - A<sub>hat</sub> &middot; x<sub>hat</sub>\n+ *                 = P &middot; [b - (A - shift &middot; I) &middot; x]\n+ *                 = P &middot; r.\n+ * </p>\n+ * <p>\n+ * In the case of preconditioning, the {@link IterativeLinearSolverEvent}s that\n+ * this solver throws are such that\n+ * {@link IterativeLinearSolverEvent#getNormOfResidual()} returns the norm of\n+ * the <em>preconditioned</em>, updated residual, ||P &middot; r||, not the norm\n+ * of the <em>true</em> residual ||r||.\n  * </p>\n  * <h3><a id=\"stopcrit\">Default stopping criterion</a></h3>\n  * <p>\n         }\n \n         /**\n+         * <p>\n          * Move to the CG point if it seems better. In this version of SYMMLQ,\n          * the convergence tests involve only cgnorm, so we're unlikely to stop\n          * at an LQ point, except if the iteration limit interferes.\n+         * </p>\n+         * <p>\n+         * Additional upudates are also carried out in case {@code goodb} is set\n+         * to {@code true}.\n+         * </p>\n          *\n          * @param x the vector to be updated with the refined value of xL\n          */", "timestamp": 1332826918, "metainfo": ""}