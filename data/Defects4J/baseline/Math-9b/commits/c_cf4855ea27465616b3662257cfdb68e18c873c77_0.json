{"sha": "cf4855ea27465616b3662257cfdb68e18c873c77", "log": "[MATH-777] Added UniformCrossover policy. Thanks for Reid Hochstedler.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/genetics/UniformCrossover.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+\n+/**\n+ * Perform Uniform Crossover [UX] on the specified chromosomes. A fixed mixing\n+ * ratio is used to combine genes from the first and second parents, e.g. using a\n+ * ratio of 0.5 would result in approximately 50% of genes coming from each\n+ * parent. This is typically a poor method of crossover, but empirical evidence\n+ * suggests that it is more exploratory and results in a larger part of the\n+ * problem space being searched.\n+ *\n+ * <p>This crossover policy evaluates each gene of the parent chromosomes by chosing a\n+ * uniform random number {@code p} in the range [0, 1]. If {@code p} &lt; {@code ratio},\n+ * the parent genes are swapped. This means with a ratio of 0.7, 30% of the genes from the\n+ * first parent and 70% from the second parent will be selected for the first offspring (and\n+ * vice versa for the second offspring).</p>\n+ *\n+ * <p>This policy works only on {@link AbstractListChromosome}, and therefore it\n+ * is parameterized by T. Moreover, the chromosomes must have same lengths.\n+ * </p>\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Crossover_%28genetic_algorithm%29\">Crossover techniques (Wikipedia)</a>\n+ * @see <a href=\"http://www.obitko.com/tutorials/genetic-algorithms/crossover-mutation.php\">Crossover (Obitko.com)</a>\n+ * @see <a href=\"http://www.tomaszgwiazda.com/uniformX.htm\">Uniform crossover</a>\n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class UniformCrossover<T> implements CrossoverPolicy {\n+\n+    /** The mixing ratio. */\n+    private final double ratio;\n+\n+    /**\n+     * Creates a new {@link UniformCrossover} policy using the given mixing ratio.\n+     *\n+     * @param ratio the mixing ratio\n+     * @throws OutOfRangeException if the mixing ratio is outside the [0, 1] range\n+     */\n+    public UniformCrossover(final double ratio) {\n+        if (ratio < 0.0d || ratio > 1.0d) {\n+            throw new OutOfRangeException(LocalizedFormats.CROSSOVER_RATE, ratio, 0.0d, 1.0d);\n+        }\n+        this.ratio = ratio;\n+    }\n+\n+    /**\n+     * Returns the mixing ratio used by this {@link CrossoverPolicy}.\n+     *\n+     * @return the mixing ratio\n+     */\n+    public double getRatio() {\n+        return ratio;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+        if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n+        }\n+        return mate((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     *\n+     * @param first the first chromosome\n+     * @param second the second chromosome\n+     * @return the pair of new chromosomes that resulted from the crossover\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n+     */\n+    private ChromosomePair mate(final AbstractListChromosome<T> first,\n+                                final AbstractListChromosome<T> second) {\n+        final int length = first.getLength();\n+        if (length != second.getLength()) {\n+            throw new DimensionMismatchException(second.getLength(), length);\n+        }\n+\n+        // array representations of the parents\n+        final List<T> parent1Rep = first.getRepresentation();\n+        final List<T> parent2Rep = second.getRepresentation();\n+        // and of the children\n+        final List<T> child1Rep = new ArrayList<T>(first.getLength());\n+        final List<T> child2Rep = new ArrayList<T>(second.getLength());\n+\n+        final RandomGenerator random = GeneticAlgorithm.getRandomGenerator();\n+\n+        for (int index = 0; index < length; index++) {\n+\n+            if (random.nextDouble() < ratio) {\n+                // swap the bits -> take other parent\n+                child1Rep.add(parent2Rep.get(index));\n+                child2Rep.add(parent1Rep.get(index));\n+            } else {\n+                child1Rep.add(parent1Rep.get(index));\n+                child2Rep.add(parent2Rep.get(index));\n+            }\n+        }\n+\n+        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n+                                  second.newFixedLengthChromosome(child2Rep));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/genetics/UniformCrossoverTest.java\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class UniformCrossoverTest {\n+    private static final int LEN = 10000;\n+    private static final List<Integer> p1 = new ArrayList<Integer>(LEN);\n+    private static final List<Integer> p2 = new ArrayList<Integer>(LEN);\n+\n+    @BeforeClass\n+    public static void setUpBeforeClass() {\n+        for (int i = 0; i < LEN; i++) {\n+            p1.add(0);\n+            p2.add(1);\n+        }\n+    }\n+\n+    @Test(expected = OutOfRangeException.class)\n+    public void testRatioTooLow() {\n+        new UniformCrossover<Integer>(-0.5d);\n+    }\n+    \n+    @Test(expected = OutOfRangeException.class)\n+    public void testRatioTooHigh() {\n+        new UniformCrossover<Integer>(1.5d);\n+    }\n+    \n+    @Test\n+    public void testCrossover() {\n+        // test crossover with different ratios\n+        performCrossover(0.5);\n+        performCrossover(0.7);\n+        performCrossover(0.2);        \n+    }\n+    \n+    private void performCrossover(double ratio) {\n+        final DummyBinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final DummyBinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new UniformCrossover<Integer>(ratio);\n+\n+        // make a number of rounds\n+        for (int i = 0; i < 20; i++) {\n+            final ChromosomePair pair = cp.crossover(p1c, p2c);\n+\n+            final List<Integer> c1 = ((DummyBinaryChromosome) pair.getFirst()).getRepresentation();\n+            final List<Integer> c2 = ((DummyBinaryChromosome) pair.getSecond()).getRepresentation();\n+\n+            int from1 = 0;\n+            int from2 = 0;\n+\n+            // check first child\n+            for (int val : c1) {\n+                if (val == 0) {\n+                    from1++;\n+                } else {\n+                    from2++;\n+                }\n+            }\n+\n+            Assert.assertEquals(1.0 - ratio, Double.valueOf((double) from1 / LEN), 0.1);\n+            Assert.assertEquals(ratio, Double.valueOf((double) from2 / LEN), 0.1);\n+\n+            from1 = 0;\n+            from2 = 0;\n+\n+            // check second child\n+            for (int val : c2) {\n+                if (val == 0) {\n+                    from1++;\n+                } else {\n+                    from2++;\n+                }\n+            }\n+\n+            Assert.assertEquals(ratio, Double.valueOf((double) from1 / LEN), 0.1);\n+            Assert.assertEquals(1.0 - ratio, Double.valueOf((double) from2 / LEN), 0.1);\n+        }\n+    }\n+    \n+    @Test(expected = DimensionMismatchException.class)\n+    public void testCrossoverDimensionMismatchException(){\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final Integer[] p2 = new Integer[] {0,1,1,0,1};\n+\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);\n+        cp.crossover(p1c, p2c);\n+    }\n+    \n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeFirst() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final Chromosome p2c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);\n+        cp.crossover(p1c, p2c);\n+    }\n+    \n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeSecond() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p1);\n+        final Chromosome p1c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d);\n+        cp.crossover(p1c, p2c);\n+    }\n+}", "timestamp": 1339706249, "metainfo": ""}