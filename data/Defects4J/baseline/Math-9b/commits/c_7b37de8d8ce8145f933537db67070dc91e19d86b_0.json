{"sha": "7b37de8d8ce8145f933537db67070dc91e19d86b", "log": "Improved linear RealMatrixImpl and BigMatrixImpl performances. The main changes are the following ones:  - use directly the storage array when possible for    diadic operations (add, subtract, multiply), as    suggested by Phil, this avoids the cost of the    generic getEntry method  - replaced custom indices checks by simple use of    the JVM checks and ArrayIndexOutOfBoundException  - put row arrays reference in local variables to    avoid multiple checks in double loops  - use final variables where possible  - removed unneeded array copying  - added a constructor to build a matrix from an    array without copying it where it makes sense  The speed gain is about 3X for multiplication. Performances for this operation are now on par with Jama.  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n     /**\n      * Create a new BigMatrix using <code>d</code> as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n         this.copyIn(d);\n         lu = null;\n     }\n-    \n+\n+    /**\n+     * Create a new BigMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #BigMatrix(BigDecimal[][])\n+     */\n+    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                }\n+            }       \n+            data = d;\n+        }\n+        lu = null;\n+    }\n+\n     /**\n      * Create a new BigMatrix using <code>d</code> as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>Since the underlying array will hold <code>BigDecimal</code>\n+     * instances, it will be created.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      * @throws NullPointerException if <code>d</code> is null\n      */\n     public BigMatrixImpl(double[][] d) {\n-        int nRows = d.length;\n+        final int nRows = d.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = d[0].length;\n+        final int nCols = d[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n      * @throws NullPointerException if <code>d</code> is null\n      */\n     public BigMatrixImpl(String[][] d) {\n-        int nRows = d.length;\n+        final int nRows = d.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = d[0].length;\n+        final int nCols = d[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n      * @param v column vector holding data for new matrix\n      */\n     public BigMatrixImpl(BigDecimal[] v) {\n-        int nRows = v.length;\n+        final int nRows = v.length;\n         data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = v[row];\n      * @return  the cloned matrix\n      */\n     public BigMatrix copy() {\n-        return new BigMatrixImpl(this.copyOut());\n+        return new BigMatrixImpl(this.copyOut(), false);\n     }\n     \n     /**\n      *\n      * @param m    matrix to be added\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as this\n+     * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return add((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].add(m.getEntry(row, col));\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Compute  this minus <code>m</code>.\n      *\n      * @param m    matrix to be subtracted\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n+     * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return subtract((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].subtract(m.getEntry(row, col));\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result of adding d to each entry of this.\n      *\n      * @return     d + this\n      */\n     public BigMatrix scalarAdd(BigDecimal d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].add(d);\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns the result multiplying each entry of this by <code>d</code>\n+                outDataRow[col] = dataRow[col].add(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of multiplying each entry of this by <code>d</code>\n      * @param d  value to multiply all entries by\n      * @return d * this\n      */\n     public BigMatrix scalarMultiply(BigDecimal d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].multiply(d);\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].multiply(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result of postmultiplying this by <code>m</code>.\n      * @param m    matrix to postmultiply by\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n+        try {\n+            return multiply((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            if (this.getColumnDimension() != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+            }\n+            final int nRows = this.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final int nSum = this.getColumnDimension();\n+            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n+            for (int row = 0; row < nRows; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < nCols; col++) {\n+                    BigDecimal sum = ZERO;\n+                    for (int i = 0; i < nSum; i++) {\n+                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));\n+                    }\n+                    outDataRow[col] = sum;\n+                }\n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = m.getColumnDimension();\n-        int nSum = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n-        BigDecimal sum = ZERO;\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < nCols; col++) {\n-                sum = ZERO;\n+                BigDecimal sum = ZERO;\n                 for (int i = 0; i < nSum; i++) {\n-                    sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n                 }\n-                outData[row][col] = sum;\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = sum;\n+            }\n+        }            \n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n      * @param m    matrix to premultiply by\n     public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n         return m.multiply(this);\n     }\n-    \n+\n     /**\n      * Returns matrix entries as a two-dimensional array.\n      * <p>\n      * @return    2-dimensional array of entries\n      */\n     public double[][] getDataAsDoubleArray() {\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n-        double d[][] = new double[nRows][nCols];\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final double d[][] = new double[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j<nCols;j++) {\n+            for (int j = 0; j < nCols; j++) {\n                 d[i][j] = data[i][j].doubleValue();\n             }\n         }\n      *         specified rows and columns\n      * @exception MatrixIndexException if row or column selections are not valid\n      */\n-    public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-            int endColumn) throws MatrixIndexException {\n+    public BigMatrix getSubMatrix(int startRow, int endRow,\n+                                  int startColumn, int endColumn)\n+        throws MatrixIndexException {\n         if (startRow < 0 || startRow > endRow || endRow > data.length ||\n                 startColumn < 0 || startColumn > endColumn ||\n                 endColumn > data[0].length ) {\n             throw new MatrixIndexException(\n             \"invalid row or column index selection\");\n         }\n-        BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,\n-                endColumn - startColumn+1);\n-        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n-            for (int j = startColumn; j <= endColumn; j++) {\n-                subMatrixData[i - startRow][j - startColumn] = data[i][j];\n-            }\n-        }\n-        return subMatrix;\n+            System.arraycopy(data[i], startColumn,\n+                    subMatrixData[i - startRow], 0,\n+                    endColumn - startColumn + 1);\n+        }\n+        return new BigMatrixImpl(subMatrixData, false);\n     }\n     \n     /**\n      *     are not valid\n      */\n     public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-    throws MatrixIndexException {\n+        throws MatrixIndexException {\n         if (selectedRows.length * selectedColumns.length == 0) {\n             throw new MatrixIndexException(\n             \"selected row and column index arrays must be non-empty\");\n         }\n-        BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,\n-                selectedColumns.length);\n-        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[selectedRows.length][selectedColumns.length];\n         try  {\n             for (int i = 0; i < selectedRows.length; i++) {\n+                final BigDecimal[] subI = subMatrixData[i];\n+                final BigDecimal[] dataSelectedI = data[selectedRows[i]];\n                 for (int j = 0; j < selectedColumns.length; j++) {\n-                    subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];\n+                    subI[j] = dataSelectedI[selectedColumns[j]];\n                 }\n             }\n         }\n         catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\"matrix dimension mismatch\");\n         }\n-        return subMatrix;\n+        return new BigMatrixImpl(subMatrixData, false);\n     } \n     \n     /**\n             throw new MatrixIndexException\n             (\"invalid row or column index selection\");          \n         }\n-        int nRows = subMatrix.length;\n+        final int nRows = subMatrix.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = subMatrix[0].length;\n+        final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n         if ( !isValidCoordinate( row, 0)) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         }\n-        int ncols = this.getColumnDimension();\n-        BigDecimal[][] out = new BigDecimal[1][ncols]; \n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n-        return new BigMatrixImpl(out);\n+        return new BigMatrixImpl(out, false);\n     } \n     \n     /**\n         if ( !isValidCoordinate( 0, column)) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         }\n-        int nRows = this.getRowDimension();\n-        BigDecimal[][] out = new BigDecimal[nRows][1]; \n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n             out[row][0] = data[row][column];\n         }\n-        return new BigMatrixImpl(out);\n+        return new BigMatrixImpl(out, false);\n     }\n     \n     /**\n         if ( !isValidCoordinate( row, 0 ) ) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         }\n-        int ncols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[ncols];\n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n         return out;\n     }\n         if ( !isValidCoordinate( row, 0 ) ) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         }\n-        int ncols = this.getColumnDimension();\n-        double[] out = new double[ncols];\n+        final int ncols = this.getColumnDimension();\n+        final double[] out = new double[ncols];\n         for (int i=0;i<ncols;i++) {\n             out[i] = data[row][i].doubleValue();\n         }\n         if ( !isValidCoordinate(0, col) ) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         }\n-        int nRows = this.getRowDimension();\n-        BigDecimal[] out = new BigDecimal[nRows];\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int i = 0; i < nRows; i++) {\n             out[i] = data[i][col];\n         }\n         if ( !isValidCoordinate( 0, col ) ) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         }\n-        int nrows = this.getRowDimension();\n-        double[] out = new double[nrows];\n+        final int nrows = this.getRowDimension();\n+        final double[] out = new double[nrows];\n         for (int i=0;i<nrows;i++) {\n             out[i] = data[i][col].doubleValue();\n         }\n      */\n     public BigDecimal getEntry(int row, int column)\n     throws MatrixIndexException {\n-        if (!isValidCoordinate(row,column)) {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\"matrix entry does not exist\");\n         }\n-        return data[row][column];\n     }\n     \n     /**\n      * @return transpose matrix\n      */\n     public BigMatrix transpose() {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);\n-        BigDecimal[][] outData = out.getDataRef();\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = data[row][col];\n-            }\n-        }\n-        return out;\n+                outData[col][row] = dataRow[col];\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n     }\n     \n     /**\n      * @throws InvalidMatrixException if this is not invertible\n      */\n     public BigMatrix inverse() throws InvalidMatrixException {\n-        return solve(MatrixUtils.createBigIdentityMatrix\n-                (this.getRowDimension()));\n+        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n     }\n     \n     /**\n         if (v.length != this.getColumnDimension()) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[v.length];\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n     public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n-        BigDecimal bd[] = new BigDecimal[v.length];\n-        for (int i=0;i<bd.length;i++) {\n+        final BigDecimal bd[] = new BigDecimal[v.length];\n+        for (int i = 0; i < bd.length; i++) {\n             bd[i] = new BigDecimal(v[i]);\n         }\n         return operate(bd);\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n     public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nCols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[nCols];\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[nCols];\n         for (int col = 0; col < nCols; col++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nRows; i++) {\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (b.length != nRows) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n-        BigMatrix bMatrix = new BigMatrixImpl(b);\n-        BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n-        BigDecimal[] out = new BigDecimal[nRows];\n+        final BigMatrix bMatrix = new BigMatrixImpl(b);\n+        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             out[row] = solution[row][0];\n         }\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        BigDecimal bd[] = new BigDecimal[b.length];\n-        for (int i=0;i<bd.length;i++) {\n+        final BigDecimal bd[] = new BigDecimal[b.length];\n+        for (int i = 0; i < bd.length; i++) {\n             bd[i] = new BigDecimal(b[i]);\n         }\n         return solve(bd);\n             throw new InvalidMatrixException(\"Matrix is singular.\");\n         }\n         \n-        int nCol = this.getColumnDimension();\n-        int nColB = b.getColumnDimension();\n-        int nRowB = b.getRowDimension();\n+        final int nCol = this.getColumnDimension();\n+        final int nColB = b.getColumnDimension();\n+        final int nRowB = b.getRowDimension();\n         \n         // Apply permutations to b\n-        BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n+        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n         for (int row = 0; row < nRowB; row++) {\n+            final BigDecimal[] bpRow = bp[row];\n             for (int col = 0; col < nColB; col++) {\n-                bp[row][col] = b.getEntry(permutation[row], col);\n+                bpRow[col] = b.getEntry(permutation[row], col);\n             }\n         }\n         \n         // Solve LY = b\n         for (int col = 0; col < nCol; col++) {\n             for (int i = col + 1; i < nCol; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                 }\n             }\n         }\n         \n         // Solve UX = Y\n         for (int col = nCol - 1; col >= 0; col--) {\n+            final BigDecimal[] bpCol = bp[col];\n+            final BigDecimal luDiag = lu[col][col];\n             for (int j = 0; j < nColB; j++) {\n-                bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);\n+                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);\n             }\n             for (int i = 0; i < col; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                 }\n             }\n         }\n-        \n-        BigMatrixImpl outMat = new BigMatrixImpl(bp);\n-        return outMat;\n+\n+        return new BigMatrixImpl(bp, false);\n+\n     }\n     \n     /**\n      */\n     public void luDecompose() throws InvalidMatrixException {\n         \n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n         if (nRows != nCols) {\n             throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n         }\n             \n             // upper\n             for (int row = 0; row < col; row++) {\n-                sum = lu[row][col];\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < row; i++) {\n-                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n             }\n             \n             // lower\n             int max = col; // permutation row\n             BigDecimal largest = ZERO;\n             for (int row = col; row < nRows; row++) {\n-                sum = lu[row][col];\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < col; i++) {\n-                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n                 \n                 // maintain best permutation choice\n                 if (sum.abs().compareTo(largest) == 1) {\n                 parity = -parity;\n             }\n             \n-            //Divide the lower elements by the \"winning\" diagonal elt.\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final BigDecimal luDiag = lu[col][col];\n             for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);\n+                final BigDecimal[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n             }\n             \n         }\n         res.append(\"BigMatrixImpl{\");\n         if (data != null) {\n             for (int i = 0; i < data.length; i++) {\n-                if (i > 0)\n+                if (i > 0) {\n                     res.append(\",\");\n+                }\n                 res.append(\"{\");\n                 for (int j = 0; j < data[0].length; j++) {\n-                    if (j > 0)\n+                    if (j > 0) {\n                         res.append(\",\");\n+                    }\n                     res.append(data[i][j]);\n                 } \n                 res.append(\"}\");\n         if (object instanceof BigMatrixImpl == false) {\n             return false;\n         }\n-        BigMatrix m = (BigMatrix) object;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final BigMatrix m = (BigMatrix) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n             return false;\n         }\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                if (!data[row][col].equals(m.getEntry(row, col))) {\n+                if (!dataRow[col].equals(m.getEntry(row, col))) {\n                     return false;\n                 }\n             }\n      */\n     public int hashCode() {\n         int ret = 7;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         ret = ret * 31 + nRows;\n         ret = ret * 31 + nCols;\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n                 ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n-                data[row][col].hashCode();\n+                dataRow[col].hashCode();\n             }\n         }   \n         return ret;\n      * @return the permutation\n      */\n     protected int[] getPermutation() {\n-        int[] out = new int[permutation.length];\n+        final int[] out = new int[permutation.length];\n         System.arraycopy(permutation, 0, out, 0, permutation.length);\n         return out;\n     }\n      * @return a copy of the underlying data array.\n      */\n     private BigDecimal[][] copyOut() {\n-        int nRows = this.getRowDimension();\n-        BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n         // can't copy 2-d array in one shot, otherwise get row references\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n      * @param in data to copy in\n      */\n     private void copyIn(double[][] in) {\n-        int nRows = in.length;\n-        int nCols = in[0].length;\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n         data = new BigDecimal[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j < nCols; j++) {\n-                data[i][j] = new BigDecimal(in[i][j]);\n+            final BigDecimal[] dataI = data[i];\n+            final double[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n             }\n         }\n         lu = null;\n      * @param in data to copy in\n      */\n     private void copyIn(String[][] in) {\n-        int nRows = in.length;\n-        int nCols = in[0].length;\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n         data = new BigDecimal[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j < nCols; j++) {\n-                data[i][j] = new BigDecimal(in[i][j]);\n+            final BigDecimal[] dataI = data[i];\n+            final String[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n             }\n         }\n         lu = null;\n      * @return true if the coordinate is with the current dimensions\n      */\n     private boolean isValidCoordinate(int row, int col) {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        \n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n         return !(row < 0 || row >= nRows || col < 0 || col >= nCols);\n     }\n     \n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n package org.apache.commons.math.linear;\n \n import java.math.BigDecimal;\n+import java.util.Arrays;\n \n /**\n  * A collection of static methods that operate on or return matrices.\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if data is null\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][], boolean)\n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n         return new RealMatrixImpl(data);\n     }\n-    \n+\n+    /**\n+     * Returns a {@link RealMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param data data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static RealMatrix createRealMatrix(double[][] data, boolean copyArray) {\n+        return new RealMatrixImpl(data, copyArray);\n+    }\n+\n     /**\n      * Returns <code>dimension x dimension</code> identity matrix.\n      *\n      * @since 1.1\n      */\n     public static RealMatrix createRealIdentityMatrix(int dimension) {\n-        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n-        double[][] d = out.getDataRef();\n+        double[][] d = new double[dimension][dimension];\n         for (int row = 0; row < dimension; row++) {\n-            for (int col = 0; col < dimension; col++) {\n-                d[row][col] = row == col ? 1d : 0d;\n-            }\n-        }\n-        return out;\n+            d[row][row] = 1d;\n+        }\n+        return new RealMatrixImpl(d, false);\n     }\n     \n     /**\n     public static BigMatrix createBigMatrix(BigDecimal[][] data) {\n         return new BigMatrixImpl(data);\n     }\n-    \n+\n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param data data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @return  BigMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {\n+        return new BigMatrixImpl(data, copyArray);\n+    }\n+\n     /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static RealMatrix createRowRealMatrix(double[] rowData) {\n-        int nCols = rowData.length;\n-        double[][] data = new double[1][nCols];\n+        final int nCols = rowData.length;\n+        final double[][] data = new double[1][nCols];\n         System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new RealMatrixImpl(data);\n+        return new RealMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(double[] rowData) {\n-        int nCols = rowData.length;\n-        double[][] data = new double[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {\n-        int nCols = rowData.length;\n-        BigDecimal[][] data = new BigDecimal[1][nCols];\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n         System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(String[] rowData) {\n-        int nCols = rowData.length;\n-        String[][] data = new String[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static RealMatrix createColumnRealMatrix(double[] columnData) {\n-        int nRows = columnData.length;\n-        double[][] data = new double[nRows][1];\n+        final int nRows = columnData.length;\n+        final double[][] data = new double[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = columnData[row];\n         }\n-        return new RealMatrixImpl(data);\n+        return new RealMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static BigMatrix createColumnBigMatrix(double[] columnData) {\n-        int nRows = columnData.length;\n-        double[][] data = new double[nRows][1];\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new BigMatrixImpl(data);\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {\n-        int nRows = columnData.length;\n-        BigDecimal[][] data = new BigDecimal[nRows][1];\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = columnData[row];\n         }\n-        return new BigMatrixImpl(data);\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      */\n     public static BigMatrix createColumnBigMatrix(String[] columnData) {\n         int nRows = columnData.length;\n-        String[][] data = new String[nRows][1];\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new BigMatrixImpl(data);\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @since 1.1\n      */\n     public static BigMatrix createBigIdentityMatrix(int dimension) {\n-        BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);\n-        BigDecimal[][] d = out.getDataRef();\n+        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n         for (int row = 0; row < dimension; row++) {\n-            for (int col = 0; col < dimension; col++) {\n-                d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;\n-            }\n-        }\n-        return out;\n+            final BigDecimal[] dRow = d[row];\n+            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n+            dRow[row] = BigMatrixImpl.ONE;\n+        }\n+        return new BigMatrixImpl(d, false);\n     }\n     \n }\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4237564493130426188L;\n+    private static final long serialVersionUID = -4828886979278117018L;\n \n     /** Entries of the matrix */\n     private double data[][] = null;\n     /**\n      * Create a new RealMatrix using the input array as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #RealMatrixImpl(double[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][], boolean)\n      */\n     public RealMatrixImpl(double[][] d) {\n-        this.copyIn(d);\n+        copyIn(d);\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][])\n+     */\n+    public RealMatrixImpl(double[][] d, boolean copyArray) {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                }\n+            }       \n+            data = d;\n+        }\n         lu = null;\n     }\n \n      * Create a new (column) RealMatrix using <code>v</code> as the\n      * data for the unique column of the <code>v.length x 1</code> matrix\n      * created.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced.</p>\n      *\n      * @param v column vector holding data for new matrix\n      */\n     public RealMatrixImpl(double[] v) {\n-        int nRows = v.length;\n+        final int nRows = v.length;\n         data = new double[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = v[row];\n      * @return  the cloned matrix\n      */\n     public RealMatrix copy() {\n-        return new RealMatrixImpl(this.copyOut());\n+        return new RealMatrixImpl(copyOut(), false);\n     }\n \n     /**\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return add((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final double[][] outData = new double[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n+                }  \n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + m.getEntry(row, col);\n+                outDataRow[col] = dataRow[col] + mRow[col];\n             }  \n         }\n-        return new RealMatrixImpl(outData);\n+        return new RealMatrixImpl(outData, false);\n     }\n \n     /**\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return subtract((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final double[][] outData = new double[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n+                }  \n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] - m.getEntry(row, col);\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n+                outDataRow[col] = dataRow[col] - mRow[col];\n+            }  \n+        }\n+        return new RealMatrixImpl(outData, false);\n     }\n \n     /**\n      * @return     d + this\n      */\n     public RealMatrix scalarAdd(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result multiplying each entry of this by <code>d</code>\n+                outDataRow[col] = dataRow[col] + d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of multiplying each entry of this by <code>d</code>\n      * @param d  value to multiply all entries by\n      * @return d * this\n      */\n     public RealMatrix scalarMultiply(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] * d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n+                outDataRow[col] = dataRow[col] * d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n     }\n \n     /**\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+        try {\n+            return multiply((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            if (this.getColumnDimension() != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+            }\n+            final int nRows = this.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final int nSum = this.getColumnDimension();\n+            final double[][] outData = new double[nRows][nCols];\n+            for (int row = 0; row < nRows; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < nCols; col++) {\n+                    double sum = 0;\n+                    for (int i = 0; i < nSum; i++) {\n+                        sum += dataRow[i] * m.getEntry(i, col);\n+                    }\n+                    outDataRow[col] = sum;\n+                }\n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = m.getColumnDimension();\n-        int nSum = this.getColumnDimension();\n-        double[][] outData = new double[nRows][nCols];\n-        double sum = 0;\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final double[][] outData = new double[nRows][nCols];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < nCols; col++) {\n-                sum = 0;\n+                double sum = 0;\n                 for (int i = 0; i < nSum; i++) {\n-                    sum += data[row][i] * m.getEntry(i, col);\n+                    sum += dataRow[i] * m.data[i][col];\n                 }\n-                outData[row][col] = sum;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result premultiplying this by <code>m</code>.\n+                outDataRow[col] = sum;\n+            }\n+        }            \n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of premultiplying this by <code>m</code>.\n      * @param m    matrix to premultiply by\n      * @return     m * this\n      * @throws     IllegalArgumentException\n      *         specified rows and columns\n      * @exception MatrixIndexException if row or column selections are not valid\n      */\n-    public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-            int endColumn) throws MatrixIndexException {\n+    public RealMatrix getSubMatrix(int startRow, int endRow,\n+                                   int startColumn, int endColumn)\n+        throws MatrixIndexException {\n         if (startRow < 0 || startRow > endRow || endRow > data.length ||\n              startColumn < 0 || startColumn > endColumn ||\n-             endColumn > data[0].length ) {\n+             endColumn > data[0].length) {\n             throw new MatrixIndexException(\n                     \"invalid row or column index selection\");\n         }\n-        RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,\n-                endColumn - startColumn+1);\n-        double[][] subMatrixData = subMatrix.getDataRef();\n+        final double[][] subMatrixData =\n+            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n-            for (int j = startColumn; j <= endColumn; j++) {\n-                    subMatrixData[i - startRow][j - startColumn] = data[i][j];\n-                }\n-            }\n-        return subMatrix;\n+            System.arraycopy(data[i], startColumn,\n+                             subMatrixData[i - startRow], 0,\n+                             endColumn - startColumn + 1);\n+        }\n+        return new RealMatrixImpl(subMatrixData, false);\n     }\n     \n     /**\n      *     are not valid\n      */\n     public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-    throws MatrixIndexException {\n+        throws MatrixIndexException {\n         if (selectedRows.length * selectedColumns.length == 0) {\n             throw new MatrixIndexException(\n                     \"selected row and column index arrays must be non-empty\");\n         }\n-        RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,\n-                selectedColumns.length);\n-        double[][] subMatrixData = subMatrix.getDataRef();\n+        final double[][] subMatrixData =\n+            new double[selectedRows.length][selectedColumns.length];\n         try  {\n             for (int i = 0; i < selectedRows.length; i++) {\n+                final double[] subI = subMatrixData[i];\n+                final double[] dataSelectedI = data[selectedRows[i]];\n                 for (int j = 0; j < selectedColumns.length; j++) {\n-                    subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];\n+                    subI[j] = dataSelectedI[selectedColumns[j]];\n                 }\n             }\n-        }\n-        catch (ArrayIndexOutOfBoundsException e) {\n+        } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\"matrix dimension mismatch\");\n         }\n-        return subMatrix;\n+        return new RealMatrixImpl(subMatrixData, false);\n     } \n \n     /**\n             throw new MatrixIndexException\n                 (\"invalid row or column index selection\");          \n         }\n-        int nRows = subMatrix.length;\n+        final int nRows = subMatrix.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = subMatrix[0].length;\n+        final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n         if ( !isValidCoordinate( row, 0)) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         }\n-        int ncols = this.getColumnDimension();\n-        double[][] out = new double[1][ncols]; \n+        final int ncols = this.getColumnDimension();\n+        final double[][] out = new double[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n-        return new RealMatrixImpl(out);\n+        return new RealMatrixImpl(out, false);\n     }\n     \n     /**\n         if ( !isValidCoordinate( 0, column)) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         }\n-        int nRows = this.getRowDimension();\n-        double[][] out = new double[nRows][1]; \n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n             out[row][0] = data[row][column];\n         }\n-        return new RealMatrixImpl(out);\n+        return new RealMatrixImpl(out, false);\n     }\n \n      /**\n         if ( !isValidCoordinate( row, 0 ) ) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         }\n-        int ncols = this.getColumnDimension();\n-        double[] out = new double[ncols];\n+        final int ncols = this.getColumnDimension();\n+        final double[] out = new double[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n         return out;\n     }\n         if ( !isValidCoordinate(0, col) ) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         }\n-        int nRows = this.getRowDimension();\n-        double[] out = new double[nRows];\n+        final int nRows = this.getRowDimension();\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             out[row] = data[row][col];\n         }\n      */\n     public double getEntry(int row, int column)\n         throws MatrixIndexException {\n-        if (!isValidCoordinate(row,column)) {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n             throw new MatrixIndexException(\"matrix entry does not exist\");\n         }\n-        return data[row][column];\n     }\n \n     /**\n      * @return transpose matrix\n      */\n     public RealMatrix transpose() {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n-        double[][] outData = out.getDataRef();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final double[][] outData = new double[nCols][nRows];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = data[row][col];\n-            }\n-        }\n-        return out;\n+                outData[col][row] = dataRow[col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n     }\n \n     /**\n      * @throws InvalidMatrixException if this is not invertible\n      */\n     public RealMatrix inverse() throws InvalidMatrixException {\n-        return solve(MatrixUtils.createRealIdentityMatrix\n-                (this.getRowDimension()));\n+        return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));\n     }\n \n     /**\n      * @return resulting vector\n      */\n     public double[] operate(double[] v) throws IllegalArgumentException {\n-        if (v.length != this.getColumnDimension()) {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        double[] out = new double[v.length];\n+        final double[] out = new double[v.length];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             double sum = 0;\n             for (int i = 0; i < nCols; i++) {\n-                sum += data[row][i] * v[i];\n+                sum += dataRow[i] * v[i];\n             }\n             out[row] = sum;\n         }\n      * @return resulting matrix\n      */\n     public double[] preMultiply(double[] v) throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nCols = this.getColumnDimension();\n-        double[] out = new double[nCols];\n+        final int nCols = this.getColumnDimension();\n+        final double[] out = new double[nCols];\n         for (int col = 0; col < nCols; col++) {\n             double sum = 0;\n             for (int i = 0; i < nRows; i++) {\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (b.length != nRows) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n-        RealMatrix bMatrix = new RealMatrixImpl(b);\n-        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n-        double[] out = new double[nRows];\n+        final RealMatrix bMatrix = new RealMatrixImpl(b);\n+        final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             out[row] = solution[row][0];\n         }\n             throw new InvalidMatrixException(\"Matrix is singular.\");\n         }\n \n-        int nCol = this.getColumnDimension();\n-        int nColB = b.getColumnDimension();\n-        int nRowB = b.getRowDimension();\n+        final int nCol  = this.getColumnDimension();\n+        final int nColB = b.getColumnDimension();\n+        final int nRowB = b.getRowDimension();\n \n         // Apply permutations to b\n-        double[][] bp = new double[nRowB][nColB];\n+        final double[][] bp = new double[nRowB][nColB];\n         for (int row = 0; row < nRowB; row++) {\n+            final double[] bpRow = bp[row];\n             for (int col = 0; col < nColB; col++) {\n-                bp[row][col] = b.getEntry(permutation[row], col);\n+                bpRow[col] = b.getEntry(permutation[row], col);\n             }\n         }\n \n         // Solve LY = b\n         for (int col = 0; col < nCol; col++) {\n             for (int i = col + 1; i < nCol; i++) {\n+                final double[] bpI = bp[i];\n+                final double[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                    bpI[j] -= bp[col][j] * luI[col];\n                 }\n             }\n         }\n \n         // Solve UX = Y\n         for (int col = nCol - 1; col >= 0; col--) {\n+            final double[] bpCol = bp[col];\n+            final double luDiag = lu[col][col];\n             for (int j = 0; j < nColB; j++) {\n-                bp[col][j] /= lu[col][col];\n+                bpCol[j] /= luDiag;\n             }\n             for (int i = 0; i < col; i++) {\n+                final double[] bpI = bp[i];\n+                final double[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                    bpI[j] -= bp[col][j] * luI[col];\n                 }\n             }\n         }\n \n-        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n-        return outMat;\n+        return new RealMatrixImpl(bp, false);\n+\n     }\n \n     /**\n      */\n     public void luDecompose() throws InvalidMatrixException {\n \n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n         if (nRows != nCols) {\n             throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n         }\n-        lu = this.getData();\n+        lu = getData();\n \n         // Initialize permutation array and parity\n         permutation = new int[nRows];\n \n             // upper\n             for (int row = 0; row < col; row++) {\n-                sum = lu[row][col];\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < row; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n+                    sum -= luRow[i] * lu[i][col];\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n             }\n \n             // lower\n             int max = col; // permutation row\n             double largest = 0d;\n             for (int row = col; row < nRows; row++) {\n-                sum = lu[row][col];\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < col; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n+                    sum -= luRow[i] * lu[i][col];\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n \n                 // maintain best permutation choice\n                 if (Math.abs(sum) > largest) {\n                 parity = -parity;\n             }\n \n-            //Divide the lower elements by the \"winning\" diagonal elt.\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n             for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] /= lu[col][col];\n+                lu[row][col] /= luDiag;\n             }\n         }\n     }\n         res.append(\"RealMatrixImpl{\");\n         if (data != null) {\n             for (int i = 0; i < data.length; i++) {\n-                if (i > 0)\n+                if (i > 0) {\n                     res.append(\",\");\n+                }\n                 res.append(\"{\");\n                 for (int j = 0; j < data[0].length; j++) {\n-                    if (j > 0)\n+                    if (j > 0) {\n                         res.append(\",\");\n+                    }\n                     res.append(data[i][j]);\n                 } \n                 res.append(\"}\");\n             return false;\n         }\n         RealMatrix m = (RealMatrix) object;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n             return false;\n         }\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                if (Double.doubleToLongBits(data[row][col]) != \n+                if (Double.doubleToLongBits(dataRow[col]) != \n                     Double.doubleToLongBits(m.getEntry(row, col))) {\n                     return false;\n                 }\n      */\n     public int hashCode() {\n         int ret = 7;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         ret = ret * 31 + nRows;\n         ret = ret * 31 + nCols;\n         for (int row = 0; row < nRows; row++) {\n-           for (int col = 0; col < nCols; col++) {\n+            final double[] dataRow = data[row];\n+            for (int col = 0; col < nCols; col++) {\n                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n-                   MathUtils.hash(data[row][col]);\n+                   MathUtils.hash(dataRow[col]);\n            }\n         }\n         return ret;\n      * @return the permutation\n      */\n     protected int[] getPermutation() {\n-        int[] out = new int[permutation.length];\n+        final int[] out = new int[permutation.length];\n         System.arraycopy(permutation, 0, out, 0, permutation.length);\n         return out;\n     }\n      * @return a copy of the underlying data array.\n      */\n     private double[][] copyOut() {\n-        int nRows = this.getRowDimension();\n-        double[][] out = new double[nRows][this.getColumnDimension()];\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][this.getColumnDimension()];\n         // can't copy 2-d array in one shot, otherwise get row references\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n      * @return true if the coordinate is with the current dimensions\n      */\n     private boolean isValidCoordinate(int row, int col) {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n     }\n \n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n-        BigMatrixImpl m = new BigMatrixImpl(testData);\n-        BigMatrixImpl m2 = new BigMatrixImpl(m.getData());\n-        assertEquals(m2,m);\n+        BigMatrixImpl m1 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        BigMatrixImpl m3 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n     }\n     \n     /** test constructors */\n         BigMatrix m1 = new BigMatrixImpl(testData);\n         BigMatrix m2 = new BigMatrixImpl(testDataString);\n         BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));\n+        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);\n+        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);\n         assertClose(\"double, string\", m1, m2, Double.MIN_VALUE);\n         assertClose(\"double, BigDecimal\", m1, m3, Double.MIN_VALUE);\n         assertClose(\"string, BigDecimal\", m2, m3, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/true\", m1, m4, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/false\", m1, m5, Double.MIN_VALUE);\n         try {\n             new BigMatrixImpl(new String[][] {{\"0\", \"hello\", \"1\"}});\n             fail(\"Expecting NumberFormatException\");\n     public void testAdd() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n-        BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);\n+        BigMatrix mPlusMInv = m.add(mInv);\n         double[][] sumEntries = asDouble(mPlusMInv.getData());\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n     public void testCreateRealMatrix() {\n         assertEquals(new RealMatrixImpl(testData), \n                 MatrixUtils.createRealMatrix(testData));\n+        assertEquals(new RealMatrixImpl(testData, false), \n+                MatrixUtils.createRealMatrix(testData, true));\n+        assertEquals(new RealMatrixImpl(testData, true), \n+                MatrixUtils.createRealMatrix(testData, false));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n     public void testCreateBigMatrix() {\n         assertEquals(new BigMatrixImpl(testData), \n                 MatrixUtils.createBigMatrix(testData));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));\n         assertEquals(new BigMatrixImpl(bigColMatrix), \n                 MatrixUtils.createBigMatrix(bigColMatrix));\n         assertEquals(new BigMatrixImpl(stringColMatrix), \n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n         QRDecomposition qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x3 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x3 Q size\", qr.getQ().getColumnDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getRowDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"4x3 Q size\", qr.getQ().getRowDimension(), 4);\n         assertEquals(\"4x3 Q size\", qr.getQ().getColumnDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getRowDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x4 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x4 Q size\", qr.getQ().getColumnDimension(), 3);\n \n     /** test A = QR */\n     public void testAEqualQR() {\n-        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false);\n         QRDecomposition qr = new QRDecompositionImpl(A);\n         RealMatrix Q = qr.getQ();\n         RealMatrix R = qr.getR();\n         double norm = Q.multiply(R).subtract(A).getNorm();\n         assertEquals(\"3x3 nonsingular A = QR\", 0, norm, normTolerance);\n \n-        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x3 singular A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x4 A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"4x3 A = QR\", 0, norm, normTolerance);\n \n     /** test the orthogonality of Q */\n     public void testQOrthogonal() {\n-        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n         matrix = new QRDecompositionImpl(matrix).getQ();\n         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n         double norm = matrix.transpose().multiply(matrix).subtract(eye)\n                 .getNorm();\n         assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x3Singular);\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n         matrix = new QRDecompositionImpl(matrix).getQ();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n         norm = matrix.transpose().multiply(matrix).subtract(eye)\n                 .getNorm();\n         assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         matrix = new QRDecompositionImpl(matrix).getQ();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n         norm = matrix.transpose().multiply(matrix).subtract(eye)\n                 .getNorm();\n         assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         matrix = new QRDecompositionImpl(matrix).getQ();\n         eye = MatrixUtils.createRealIdentityMatrix(4);\n         norm = matrix.transpose().multiply(matrix).subtract(eye)\n \n     /** test that R is upper triangular */\n     public void testRUpperTriangular() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n         RealMatrix R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrixImpl m2 = new RealMatrixImpl(m.getData());\n-        assertEquals(m2,m);\n+        RealMatrixImpl m1 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n     }           \n     \n     /** test add */\n     public void testAdd() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n-        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n         double[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {", "timestamp": 1212337339, "metainfo": ""}