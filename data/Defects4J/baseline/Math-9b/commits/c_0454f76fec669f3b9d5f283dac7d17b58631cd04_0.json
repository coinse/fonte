{"sha": "0454f76fec669f3b9d5f283dac7d17b58631cd04", "log": "Simpify exception checking: - use expected @Test attribute - don't catch and rethrow  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n \n     protected UnivariateRealFunction sin = new SinFunction();\n \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testSolveNull() {\n-        try {\n-            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n-            Assert.fail();\n-        } catch(MathIllegalArgumentException ex){\n-            // success\n-        }\n+        UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n     }\n \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testSolveBadEndpoints() {\n-        try { // bad endpoints\n-            double root = UnivariateRealSolverUtils.solve(sin, 4.0, -0.1, 1e-6);\n-            System.out.println(\"root=\" + root);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        double root = UnivariateRealSolverUtils.solve(sin, 4.0, -0.1, 1e-6);\n+        System.out.println(\"root=\" + root);\n     }\n \n     @Test\n         Assert.assertEquals(FastMath.PI, x, 1.0e-4);\n     }\n \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testSolveAccuracyNull()  {\n-        try {\n-            double accuracy = 1.0e-6;\n-            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n-            Assert.fail();\n-        } catch(MathIllegalArgumentException ex){\n-            // success\n-        }\n+        double accuracy = 1.0e-6;\n+        UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n     }\n \n     @Test\n         Assert.assertEquals(FastMath.PI, x, accuracy);\n     }\n \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testSolveNoRoot() {\n-        try {\n-            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);\n-            Assert.fail(\"Expecting MathIllegalArgumentException \");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);\n     }\n \n     @Test\n         Assert.assertTrue(sin.value(result[1]) > 0);\n     }\n \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testNullFunction() {\n-        try { // null function\n-            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n     }\n     \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testBadInitial() {\n-        try { // initial not between endpoints\n-            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n     }\n     \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testBadEndpoints() {\n-        try { // endpoints not valid\n-            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        // endpoints not valid\n+        UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n     }\n     \n-    @Test\n+    @Test(expected=MathIllegalArgumentException.class)\n     public void testBadMaximumIterations() {\n-        try { // bad maximum iterations\n-            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n-            Assert.fail(\"Expecting MathIllegalArgumentException\");\n-        } catch (MathIllegalArgumentException ex) {\n-            // expected\n-        }\n+        // bad maximum iterations\n+        UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.junit.Assert;\n import org.junit.Test;\n \n \n         return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));\n     }\n \n-    @Test\n+    @Test(expected=IllegalArgumentException.class)\n     public void testPolar2ComplexIllegalModulus() {\n-        try {\n-            ComplexUtils.polar2Complex(-1, 0);\n-            Assert.fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n+        ComplexUtils.polar2Complex(-1, 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n         Assert.assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n     }\n \n-    @Test\n+    @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        try {\n-            new ExponentialDistributionImpl(0);\n-            Assert.fail(\"Should have generated NotStrictlyPositiveException\");\n-        } catch (NotStrictlyPositiveException e) {\n-            // Expected.\n-        }\n+        new ExponentialDistributionImpl(0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n         Assert.assertEquals(1.4, distribution.getStandardDeviation(), 0);\n     }\n \n-    @Test\n+    @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        try {\n-            new NormalDistributionImpl(1, 0);\n-            Assert.fail(\"Should have generated NotStrictlyPositiveException\");\n-        } catch (NotStrictlyPositiveException e) {\n-            // Expected.\n-        }\n+        new NormalDistributionImpl(1, 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n         Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));\n     }\n \n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testNegativeMean() {\n+        new PoissonDistributionImpl(-1);\n+    }\n+\n     @Test\n     public void testMean() {\n-        PoissonDistribution dist;\n-        try {\n-            dist = new PoissonDistributionImpl(-1);\n-            Assert.fail(\"negative mean: NotStrictlyPositiveException expected\");\n-        } catch(NotStrictlyPositiveException ex) {\n-            // Expected.\n-        }\n-\n-        dist = new PoissonDistributionImpl(10.0);\n+        PoissonDistribution dist = new PoissonDistributionImpl(10.0);\n         Assert.assertEquals(10.0, dist.getMean(), 0.0);\n     }\n \n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n         Assert.assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);\n     }\n \n-    @Test\n+    @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        try {\n-            new TDistributionImpl(0);\n-            Assert.fail(\"Expecting NotStrictlyPositiveException for df = 0\");\n-        } catch (NotStrictlyPositiveException ex) {\n-            // expected\n-        }\n+        new TDistributionImpl(0);\n     }\n     \n     @Test\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n  */\n public class ZipfDistributionTest extends IntegerDistributionAbstractTest {\n \n-    @Test\n-    public void testPreconditions() {\n-        try {\n-            new ZipfDistributionImpl(0, 1);\n-            Assert.fail(\"NotStrictlyPositiveException expected\");\n-        } catch (NotStrictlyPositiveException e) {\n-            // Expected.\n-        }\n-        try {\n-            new ZipfDistributionImpl(1, 0);\n-            Assert.fail(\"NotStrictlyPositiveException expected\");\n-        } catch (NotStrictlyPositiveException e) {\n-            // Expected.\n-        }\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testPreconditions1() {\n+        new ZipfDistributionImpl(0, 1);\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testPreconditions2() {\n+        new ZipfDistributionImpl(1, 0);\n     }\n \n     //-------------- Implementations for abstract methods -----------------------\n--- a/src/test/java/org/apache/commons/math/exception/util/ExceptionContextTest.java\n+++ b/src/test/java/org/apache/commons/math/exception/util/ExceptionContextTest.java\n     }\n \n     @Test\n-    public void testSerializeUnserializable() {\n+    public void testSerializeUnserializable() throws Exception {\n         final ExceptionContext cOut = new ExceptionContext(new Exception(\"Apache Commons Math\"));\n         cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, \"OK\");\n         cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, new Unserializable());\n         String key = \"Key 1\";\n         cOut.setValue(key, new Unserializable());\n \n-        try {\n+        {\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos);\n             oos.writeObject(cOut);\n \n             String nsObjStr = (String) cIn.getValue(key);\n             Assert.assertTrue(nsObjStr.matches(\".*could not be serialized.*\"));\n-        } catch (Exception e) {\n-            Assert.fail(e.toString());\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n     public void testParse() {\n         String source = \"1 / 2\";\n \n-        try {\n+        {\n             BigFraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.ONE, c.getNumerator());\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.ONE, c.getNumerator());\n             Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n     }\n \n     @Test\n     public void testParseInteger() {\n         String source = \"10\";\n-        try {\n+        {\n             BigFraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n             Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n-        }\n-        try {\n+        }\n+        {\n             BigFraction c = improperFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(BigInteger.TEN, c.getNumerator());\n             Assert.assertEquals(BigInteger.ONE, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n     }\n \n     @Test\n     public void testParseNegative() {\n \n-        try {\n+        {\n             String source = \"-1 / 2\";\n             BigFraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-1, c.getNumeratorAsInt());\n             Assert.assertEquals(2, c.getDenominatorAsInt());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n     }\n \n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n-        try {\n+        {\n             BigFraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(5, c.getNumeratorAsInt());\n             Assert.assertEquals(3, c.getDenominatorAsInt());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n \n         try {\n     @Test\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n-        try {\n+        {\n             BigFraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-5, c.getNumeratorAsInt());\n             Assert.assertEquals(3, c.getDenominatorAsInt());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n \n         try {\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n         }\n     }\n \n-    @Test\n+    @Test(expected=ConvergenceException.class)\n     public void testGoldenRatio() {\n-        try {\n-            // the golden ratio is notoriously a difficult number for continuous\n-            // fraction\n-            new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n-            Assert.fail(\"an exception should have been thrown\");\n-        } catch (ConvergenceException ce) {\n-            // expected behavior\n-        }\n+        // the golden ratio is notoriously a difficult number for continuous fraction\n+        new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n     }\n \n     // MATH-179\n--- a/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n     @Test\n     public void testParseInteger() {\n         String source = \"10\";\n-        try {\n+        {\n             Fraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(10, c.getNumerator());\n             Assert.assertEquals(1, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n-        }\n-        try {\n+        }\n+        {\n             Fraction c = improperFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(10, c.getNumerator());\n             Assert.assertEquals(1, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n     }\n \n     @Test\n     public void testParseNegative() {\n \n-        try {\n+        {\n             String source = \"-1 / 2\";\n             Fraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-1, c.getNumerator());\n             Assert.assertEquals(2, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n     }\n \n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n-        try {\n+        {\n             Fraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(5, c.getNumerator());\n             Assert.assertEquals(3, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n \n         try {\n     @Test\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n-        try {\n+        {\n             Fraction c = properFormat.parse(source);\n             Assert.assertNotNull(c);\n             Assert.assertEquals(-5, c.getNumerator());\n             Assert.assertEquals(3, c.getDenominator());\n-        } catch (MathParseException ex) {\n-            Assert.fail(ex.getMessage());\n         }\n \n         try {", "timestamp": 1320944751, "metainfo": ""}